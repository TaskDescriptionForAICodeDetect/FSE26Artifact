[
  {
    "language": "Scala",
    "code": "data class Point(val x:Double, val y:Double)\nfun Point.distanceFrom(origin:Point):Double = sqrt((this.x - origin.x) * (this.x - origin.x) + (this.y - origin.y) * (this.y - origin.y))\nfun main(args:Array<String>):Unit {\n    val n = readLine()!!.toInt()\n    val points = Array(n){readLine()!!.split(' ').map(String::toDouble).let{Point(it.first(), it.last())}}\n    var posB = 0\n    var maxLength:Double = .0\n    for (posA in 0 until n){\n        while (points[posA].distanceFrom(points[posB]) <= points[posA].distanceFrom(points[(posB + 1) % n])) {\n            posB = (posB + 1) % n\n        }\n        if (maxLength < points[posA].distanceFrom(points[posB])) maxLength = points[posA].distanceFrom(points[posB])\n    }\n    println(maxLength)\n}\n"
  },
  {
    "language": "Scala",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n\ndouble area(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto n = vs.size();\n    auto vx1 = std::get<0>(vs[(p+1) % n]) - std::get<0>(vs[p]);\n    auto vy1 = std::get<1>(vs[(p+1) % n]) - std::get<1>(vs[p]);\n\n    auto vx2 = std::get<0>(vs[(q+1) % n]) - std::get<0>(vs[q]);\n    auto vy2 = std::get<1>(vs[(q+1) % n]) - std::get<1>(vs[q]);\n\n    return std::abs( vx1 * vy2 - vx2 * vy1 );\n}\n\ndouble len2(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto dx = std::get<0>(vs[p]) - std::get<0>(vs[q]);\n    auto dy = std::get<1>(vs[p]) - std::get<1>(vs[q]);\n\n    return dx*dx + dy*dy;\n}\n\nint main() {\n    int64_t n;\n\n    std::cin >> n;\n    \n    std::vector<std::tuple<double, double> > vs(n);\n\n    int64_t p = 0, q = 0;\n    for (int64_t i = 0; i < n; ++i) {\n        std::cin >> std::get<0>(vs[i]) >> std::get<1>(vs[i]);\n\n        if (std::get<0>(vs[i]) < std::get<0>(vs[p])) {\n            p = i;\n        }\n        if (std::get<0>(vs[i]) > std::get<0>(vs[q])) {\n            q = i;\n        }\n    }\n\n    double ans = len2(vs, p, q);\n    for (int64_t i = 0; i < 3*n; ++i) {\n        if (area(vs, p, q) >= 0) {\n            p = (p+1) % n;\n        } else {\n            q = (q+1) % n;\n        }\n        ans = std::max(ans, len2(vs, p, q));\n    }\n\n    std::cout << std::fixed << std::setprecision(12) << std::sqrt(ans) << std::endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<iomanip>\n#include<utility>\n#include<cmath>\n#include<set>\nusing namespace std;\ntypedef long long int ll;\nconst double EPS=1e-10;\n\nbool equals(double a,double b)\n{\n\treturn a>b?a-b<EPS:b-a<EPS;\n}\n\nclass Point\n{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(double inx=0.0,double iny=0.0):x(inx),y(iny){}\n\tPoint operator+(const Point &p){return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p){return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k){return Point(x*k,y*k);}\n\tPoint operator/(const double k){return Point(x/k,y/k);}\n\tPoint operator=(const Point &p){x=p.x;y=p.y;return *this;}\n\tbool operator<(const Point &p)const{return x!=p.x?x<p.x:y<p.y;}\n\tbool operator==(const Point &p)const{return equals(x,p.x)&&equals(y,p.y);}\n\tdouble norm()\n\t{\n\t\treturn x*x+y*y;\n\t}\n\tdouble abs()\n\t{\n\t\treturn sqrt(norm());\n\t}\n};\n\ntypedef Point Vector;\n\nclass Segment\n{\npublic:\n\tPoint p1;\n\tPoint p2;\n\tVector getvector()\n\t{\n\t\treturn p2-p1;\n\t}\n};\n\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point inc=Point(),double inr=0.0):c(inc),r(inr){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a,Vector b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm(Vector a)\n{\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a)\n{\n\treturn sqrt(norm(a));\n}\n\nconst int counter_clockwise=1;\nconst int clockwise=-1;\nconst int on_segment=0;\nconst int online_back=2;\nconst int online_front=-2;\n\nbool isorthogonal(Vector a,Vector b)\n{\n\treturn equals(dot(a,b),0.0);\n}\n\nbool isorthogonal(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isorthogonal(a1-a2,b1-b2);\n}\n\nbool isorthogonal(Segment s1,Segment s2)\n{\n\treturn equals(dot(s1.getvector(),s2.getvector()),0.0);\n}\n\nbool isparallel(Vector a,Vector b)\n{\n\treturn equals(cross(a,b),0.0);\n}\n\nbool isparallel(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isparallel(a1-a2,b1-b2);\n}\n\nbool isparallel(Segment s1,Segment s2)\n{\n\treturn equals(cross(s1.getvector(),s2.getvector()),0.0);\n}\n\nPoint project(Segment s,Point p)\n{\n\tVector base=s.getvector();\n\tdouble r=dot(p-s.p1,base)/norm(base);\n\treturn s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p)\n{\n\treturn project(s,p)*2.0-p;//p+(project(s,p)-p)*2.0\n}\n\ndouble getdistance(Point a,Point b)\n{\n\treturn abs(a-b);\n}\n\ndouble getdistancelp(Line l,Point p)//Line,Point\n{\n\tdouble s=abs(cross(l.p2-l.p1,p-l.p1));\n\treturn s/abs(l.getvector());\n}\n\ndouble getdistancesp(Segment s,Point p)\n{\n\tif(dot(s.getvector(),p-s.p1)<0.0)return abs(p-s.p1);\n\telse if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\telse return getdistancelp(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return counter_clockwise;\n\telse if(cross(a,b)<-EPS)return clockwise;\n\telse if(dot(a,b)<-EPS)return online_back;\n\telse if(a.norm()<b.norm())return online_front;\n\telse return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n\treturn ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersect(Segment s1,Segment s2)\n{\n\treturn intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getdistance(Segment s1,Segment s2)\n{\n\tif(intersect(s1,s2))return 0.0;\n\telse return min(min(getdistancesp(s1,s2.p1),getdistancesp(s1,s2.p2)),\n\t\t\tmin(getdistancesp(s2,s1.p1),getdistancesp(s2,s1.p2)));\n}\n\nPoint getcrosspoint(Segment s1,Segment s2)\n{\n\tVector base=s2.getvector();\n\tdouble d1=abs(cross(base,s1.p1-s2.p1));\n\tdouble d2=abs(cross(base,s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+s1.getvector()*t;\n}\n\npair<Point,Point> getcrosspoint(Circle c,Line l)\n{\n\tVector pr=project(l,c.c);\n\tVector e=l.getvector()/abs(l.getvector());\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p)\n{\n\treturn atan2(p.y,p.x);\n}\n\nPoint polar(double r,double theta)\n{\n\treturn Point(r*cos(theta),r*sin(theta));\n}\n\npair<Point,Point> getcrosspoint(Circle c1,Circle c2)\n{\n\tdouble d=abs(c2.c-c1.c);\n\tdouble a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2.0*c1.r*d));\n\tdouble t=arg(c2.c-c1.c);\n\treturn make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint intersect(Circle c1,Circle c2)\n{\n\tdouble d=abs(c2.c-c1.c);\n\tif(equals(d,c1.r+c2.r))return 3;\n\telse if(d>c1.r+c2.r)return 4;\n\telse if(equals(d,abs(c1.r-c2.r)))return 1;\n\telse if(d>abs(c1.r-c2.r))return 2;\n\telse return 0;\n}\n\npair<Point,Point> gettangentpoint(Circle c,Point p)\n{\n\tdouble d=abs(p-c.c);\n\tdouble l=sqrt(d*d-c.r*c.r);\n\tdouble a=asin(c.r/d);\n\tdouble t=arg(c.c-p);\n\treturn make_pair(p+polar(l,t+a),p+polar(l,t-a));\n}\n\nvector<Point> gettangentpoint(Circle c1,Circle c2)\n{\n\tvector<Point> p;\n\tint n=intersect(c1,c2);\n\tdouble d=abs(c2.c-c1.c);\n\tdouble t=arg(c2.c-c1.c);\n\tdouble a;\n\t\n\tif(n==1||n==3)\n\t{\n\t\tif(c1.r<c2.r&&n==1)p.push_back(c1.c-(c2.c-c1.c)*c1.r/d);\n\t\telse p.push_back(c1.c+(c2.c-c1.c)*c1.r/d);\n\t}\n\tif(n==2||n==3||n==4)\n\t{\n\t\ta=acos((c1.r-c2.r)/d);\n\t\tp.push_back(c1.c+polar(c1.r,t+a));\n\t\tp.push_back(c1.c+polar(c1.r,t-a));\n\t}\n\tif(n==4)\n\t{\n\t\ta=acos((c1.r+c2.r)/d);\n\t\tp.push_back(c1.c+polar(c1.r,t+a));\n\t\tp.push_back(c1.c+polar(c1.r,t-a));\n\t}\n\t\n\tsort(p.begin(),p.end());\n\treturn p;\n}\n\ndouble area(Polygon p)\n{\n\tint n=p.size();\n\tdouble sum=0.0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tsum+=0.5*cross(p[i],p[i%n]);\n\t}\n\treturn sum<0.0?-sum:sum;\n}\n\nbool isconvex(Polygon p)\n{\n\tint n=p.size(),now;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tnow=ccw(p[i],p[(i+1)%n],p[(i+2)%n]);\n\t\tif(now==clockwise)return false;\n\t}\n\treturn true;\n}\n\nconst int in=2;\nconst int on=1;\nconst int out=0;\n\nint contain(Polygon g,Point p)\n{\n\tint n=g.size();\n\tbool x=false;\n\tPoint a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta=g[i]-p;\n\t\tb=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return on;\n\t\tif(a.y>b.y)\n\t\t{\n\t\t\tPoint sto=a;\n\t\t\ta=b;\n\t\t\tb=sto;\n\t\t}\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n\t}\n\treturn x?in:out;\n}\n\nPolygon andrewscan(Polygon s)\n{\n\tPolygon u,l;\n\tif(s.size()<=2)return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\t\n\tfor(int i=2;i<s.size();i++)\n\t{\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor(int i=s.size()-3;i>=0;i--)\n\t{\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\t\n\treturn l;\n}\n\nconst int Bottom=0;\nconst int Left=1;\nconst int Right=2;\nconst int Top=3;\n\nclass endPoint\n{\npublic:\n\tPoint p;\n\tint seg;//ID of Point\n\tint st;//kind of Point\n\tendPoint(){}\n\tendPoint(Point inp,int inseg,int inst):p(inp),seg(inseg),st(inst){}\n\tbool operator<(const endPoint &ep)const\n\t{\n\t\tif(p.y==ep.p.y)\n\t\t{\n\t\t\treturn st<ep.st;//Bottom->Left->Right->Top\n\t\t}\n\t\telse return p.y<ep.p.y;\n\t}\n};\n\nendPoint EP[200000];\n\nint manhattanintersection(vector<Segment> s)\n{\n\tint n=s.size();\n\tdouble sto;\n\t\n\tfor(int i=0,k=0;i<n;i++)\n\t{\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tif(s[i].p1.x>s[i].p2.x)\n\t\t\t{\n\t\t\t\tsto=s[i].p1.x;\n\t\t\t\ts[i].p1.x=s[i].p2.x;\n\t\t\t\ts[i].p2.x=sto;\n\t\t\t}\n\t\t}\n\t\telse if(s[i].p1.y>s[i].p2.y)\n\t\t{\n\t\t\tsto=s[i].p1.y;\n\t\t\ts[i].p1.y=s[i].p2.y;\n\t\t\ts[i].p2.y=sto;\n\t\t}\n\t\t\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Left);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Bottom);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Top);\n\t\t}\n\t}\n\t\n\tsort(EP,EP+2*n);\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(EP[i].st==Top)BT.erase(EP[i].p.x);\n\t\telse if(EP[i].st==Bottom)BT.insert(EP[i].p.x);\n\t\telse if(EP[i].st==Left)\n\t\t{\n\t\t\tset<int>::iterator b=lower_bound(BT.begin(),BT.end(),s[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e=upper_bound(BT.begin(),BT.end(),s[EP[i].seg].p2.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\t\n\treturn cnt;\n}\n\ndouble diameter(Polygon p)\n{\n\tint n=p.size();\n\tif(n<=1)return 0.0;\n\telse if(n==2)return abs(p[1]-p[0]);\n\t\n\tint i=0,j=0;\n\tfor(int k=0;k<n;k++)\n\t{\n\t\tif(p[k].x<p[i].x)i=k;\n\t\telse if(p[k].x>p[j].x)j=k;\n\t}\n\t\n\tdouble ans=0.0;\n\tint si=i,sj=j;\n\t\n\twhile(i!=sj||j!=si)\n\t{\n\t\tans=max(ans,abs(p[i]-p[j]));\n\t\tif(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0)i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\t\n\treturn ans;\n}\n\nint main()\n{\n\tPolygon p;\n\tPoint a;scanf(\"%lf\",&a.x);\n\twhile(~scanf(\"%lf%lf\",&a.x,&a.y))p.push_back(a);\n\tcout<<fixed<<setprecision(6)<<diameter(p)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vec;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\ndouble eps=1e-8;\ndouble PI=acos(-1);\n\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\n\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\n\ndouble calcArea(vec &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++)res+=cross(t[i],t[(i+1==n?0:i+1)]);\n  return abs(res/2.0);\n}\n\ndouble Arg(P a,P b,P c){\n  b-=a,c-=a;\n  return arg(c*conj(b));\n}\n\nint inPolygon(vec &t,P p){\n  int n=t.size();\n  double sum=0;  \n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p) == 0 )return 1;// on\n    sum+= Arg(p,a,b);\n  }\n  if( abs(sum) < eps )return 0;//out\n  else  return 2;//in\n}\n\ntypedef pair<double,P> Pair;\nvec ConvexHull(vec t){\n  vector<Pair> u;\n  vec R;\n  int N=t.size(),K=0,C=0;\n  for(int i=1;i<N;i++)if(t[i]<t[K])K=i;\n  for(int i=0;i<N;i++)u.push_back(Pair(arg(t[i]-t[K]),t[i]));\n  R.push_back(t[K]),C++;\n  sort(u.begin(),u.end());\n  for(int i=0;i<N;i++){\n    P p=u[i].second;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==0)continue;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==2)continue;\n    while(2<=C&&ccw(R[C-2],R[C-1],p)!=1)R.pop_back(),C--;\n    R.push_back(p),C++;    \n  }\n  return R;\n}\n\nvec cutConvex(vec &t,P a,P b){\n  int N=t.size();\n  vec res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C+D==0&&max(C,D)==1)res.push_back(intersect(a,b,c,d));\n  }\n  return res;\n}\n\ndouble maxDist(vec &t){\n  vec u=ConvexHull(t);\n  int N=u.size(),K=0;\n  double res=0;\n  for(int i=0;i<N;i++){\n    while(abs(t[i]-t[K])<abs(t[i]-t[(K+1)%N]))K=(K+1)%N;\n    res=max(res,abs(t[i]-t[K]));\n  }\n  return res;\n}\n\n\nint main(){\n  int n,m;\n  cin>>n;\n  vec t;\n  double x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  printf(\"%.8f\\n\",maxDist(t));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <bitset>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <istream>\n\n#include <map>\n#include <math.h>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nnamespace asl\n{\n    \n    template <typename numeric_type>\n    class point\n    {\n    public:\n        numeric_type x, y;\n\n        point(numeric_type x = 0, numeric_type y = 0) : x(x), y(y) {}\n\n        point<numeric_type> &operator-=(const point<numeric_type> &ri)\n        {\n            x -= ri.x;\n            y -= ri.y;\n            return *this;\n        }\n\n        friend point<numeric_type> operator-(const point<numeric_type> &a, const point<numeric_type> &b)\n        {\n            return point<numeric_type>(a) -= b;\n        }\n\n    };\n\n    template <typename numeric_type>\n    std::istream &operator>>(std::istream &is, point<numeric_type> &p)\n    {\n        return is >> p.x >> p.y;\n    }\n\n    template <typename numeric_type>\n    numeric_type norm(point<numeric_type> a)\n    {\n        return a.x * a.x + a.y * a.y;\n    }\n\n    template <typename numeric_type, typename float_type = double>\n    float_type abs(point<numeric_type> a)\n    {\n        return sqrtl(norm(a));\n    }\n\n    template <typename numeric_type>\n    numeric_type cross(point<numeric_type> a, point<numeric_type> b)\n    {\n        return a.x * b.y - a.y * b.x;\n    }\n\n    template <typename numeric_type>\n    numeric_type area2(point<numeric_type> a, point<numeric_type> b, point<numeric_type> c)\n    {\n        return cross(b - a, c - a);\n    }\n\n#include <stdint.h>\n\n    template <typename T>\n    std::istream &operator>>(std::istream &is, std::vector<T> &vec)\n    {\n        for (auto &value : vec)\n            is >> value;\n        return is;\n    }\n\n} \n\n#include <experimental/optional>\n\n#define _NEXT(i) (((i) + 1) == n ? 0 : ((i) + 1))\n\nnamespace asl\n{\n    template <typename numeric_type>\n    using polygon = std::vector<point<numeric_type>>;\n\n    template <typename numeric_type>\n    std::vector<std::pair<int, int>> antipodal(const polygon<numeric_type> &P)\n    {\n        std::vector<std::pair<int, int>> ans;\n        int n = P.size();\n\n        if (P.size() == 2)\n            ans.push_back({0, 1});\n\n        if (P.size() < 3)\n            return ans;\n\n        int q0 = 0;\n\n        while (std::abs(area2(P[n - 1], P[0], P[_NEXT(q0)])) > std::abs(area2(P[n - 1], P[0], P[q0])))\n            ++q0;\n\n        for (int q = q0, p = 0; q != 0 && p <= q0; ++p)\n        {\n            ans.push_back({p, q});\n\n            while (std::abs(area2(P[p], P[_NEXT(p)], P[_NEXT(q)])) > std::abs(area2(P[p], P[_NEXT(p)], P[q])))\n            {\n                q = _NEXT(q);\n                if (p != q0 || q != 0)\n                    ans.push_back({p, q});\n                else\n                    return ans;\n            }\n\n            if (std::abs(area2(P[p], P[_NEXT(p)], P[_NEXT(q)])) == std::abs(area2(P[p], P[_NEXT(p)], P[q])))\n            {\n                if (p != q0 || q != n - 1)\n                    ans.push_back({p, _NEXT(q)});\n                else\n                    ans.push_back({_NEXT(p), q});\n            }\n        }\n\n        return ans;\n    }\n\n    template <typename numeric_type, typename float_type = double>\n    float_type diameter(const polygon<numeric_type> &pol)\n    {\n        float_type res = 0;\n        for (auto puv : antipodal(pol))\n        {\n            int u = puv.first, v = puv.second;\n            res = std::max(res, abs(pol[u] - pol[v]));\n        }\n        return res;\n    }\n\n} \n\n#include <random>\n\n#define endl '\\n'\n\nusing namespace asl;\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(12);\n    cout << fixed;\n\n    int n;\n    cin >> n;\n\n    polygon<double> pol(n);\n    cin >> pol;\n\n    cout << diameter(pol) << endl;\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\n\nusing real = double;\n\nreal EPS = 1e-10;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\n\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\ndouble distance(Segment s, Point c){\n    if(dot(s.b-s.a, c-s.a) < EPS) return abs(c-s.a);\n    if(dot(s.a-s.b, c-s.b) < EPS) return abs(c-s.b);\n    return abs(cross(s.b-s.a, c-s.a)) / abs(s.a-s.b);\n}\n\ndouble distance(Segment s, Segment t){\n    if(intersect(s, t)) return 0.0;\n    return min({distance(s, t.a), distance(s, t.b),\n                distance(t, s.a), distance(t, s.b)});\n}\n\n\n\nPoint crossPoint(Segment s, Segment t){\n    real d1 = abs(cross(s.b-s.a, t.b-t.a));\n    real d2 = abs(cross(s.b-s.a, s.b-t.a));\n    if(d1 < EPS && d2 < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nusing Polygon = vector<Point>;\n\nreal area(Polygon &v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i+1 < v.size(); ++i) {\n        ans += cross(v[i], v[i+1]);\n    }\n    ans += cross(v.back(), v.front());\n    return ans/2;\n}\n\nPolygon convex_hull(Polygon v){\n    int n = v.size();\n    sort(v.begin(),v.end(), sorty);\n    int k = 0;\n    Polygon ret(n*2);\n    for (int i = 0; i < n; ++i) {\n        while(k > 1 && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    for(int i = n-2, t=k; i >= 0; i--){\n        while(k > t && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    ret.resize(k-1);\n    return ret;\n}\n\nbool isconvex(Polygon &v){\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        if(ccw(v[(i+n-1)%n], v[i], v[(i+1)%n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n// in = 2, on = 1, out = 0;\nint contains(Polygon &v, Point p){\n    int n = v.size();\n    bool x = false;\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i]-p, b = v[(i+1)%n]-p;\n        if(fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x?2:0);\n}\n\ndouble diameter(Polygon v){\n    int n = v.size();\n    if(n == 2) return abs(v[0]-v[1]);\n    int i = 0, j = 0;\n    for (int k = 0; k < n; ++k) {\n        if(v[i] < v[k]) i = k;\n        if(!(v[j] < v[k])) j = k;\n    }\n    double ret = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        ret = max(ret, abs(v[i]-v[j]));\n        if(cross(v[(i+1)%n]-v[i], v[(j+1)%n]-v[j]) < 0.0) i = (i+1)%n;\n        else j = (j+1)%n;\n    }\n    return ret;\n}\n\nint main() {\n    int n; cin >> n;\n    Polygon G(n);\n    for(auto && i : G) cin >> i;\n    printf(\"%.10f\", diameter(G));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> point;\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ntypedef vector<point> polygon;\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\ndouble convex_diameter(const polygon &pt) {\n\tconst int n = pt.size();\n\tint is = 0, js = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (imag(pt[i]) > imag(pt[is])) is = i;\n\t\tif (imag(pt[i]) < imag(pt[js])) js = i;\n\t}\n\tdouble maxd = norm(pt[is]-pt[js]);\n\n\tint i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo {\n\t\tif (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n\t\telse i = (i+1) % n;\n\t\tif (norm(pt[i]-pt[j]) > maxd) {\n\t\t\tmaxd = norm(pt[i]-pt[j]);\n\t\t\tmaxi = i; maxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\treturn maxd; /* farthest pair is (maxi, maxj). */\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tpolygon pol(n);\n\t\tfor (auto& p : pol) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp = point(x, y);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", sqrt(convex_diameter(pol)));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\ndouble cross(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\ndouble dist(const Point &p1, const Point &p2)\n{\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint main()\n{\n    int i, n;\n    double *X, *Y;\n    scanf(\"%d\", &n);\n    assert(n >= 3);\n\n    X = new double [n + 1];\n    Y = new double [n + 1];\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &X[i], &Y[i]);\n    }\n    X[n] = X[0], Y[n] = Y[0];\n    Point *Plg;\n    Plg = new Point [n + 1];\n    for(i = 0; i < n; i++){\n        Plg[i] = set_p(X[i], Y[i]);\n    }\n    Plg[n] = Plg[0];\n\n    int top = 1;\n    double diam = 0;\n\n    for(i = 0; i < n; i++){\n        while(cross(set_v(Plg[i], Plg[i + 1]), set_v(Plg[top], Plg[top + 1])) > 0){\n            top++; if(top > n - 1) top -= n;\n        };\n        diam = max(diam, max(dist(Plg[i], Plg[top]), dist(Plg[i + 1], Plg[top])));\n    }\n    printf(\"%.12f\\n\", diam);\n    cin >> n;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(const Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b,const Point&c){\n\tPoint p=b-a,q=c-a;\n\treturn cross(p,q)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(p,q)<-EPS?CLOCKWISE\n\t\t:dot(p,q)<0?ONLINE_BACK\n\t\t:norm(p)<norm(q)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?distance(c.o,h)<c.r-EPS?2:1\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn intersect(c,s)?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?c.r-max(d1,d2)\n\t\t:intersect(s,h)?distance(c.o,h)-c.r\n\t\t:min(distance(c.o,s.p1),distance(c.o,s.p2))-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h,0))ret.emplace_back(a.o+u*a.r,a.o+u*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){}\nmain(){\n\tint n;\n\tPolygon P;\n\tfor(cin>>n;n--;)\n\t{\n\t\tPoint p;cin>>p;P.push_back(p);\n\t}\n\tcout<<fixed<<setprecision(9)<<diameter(P)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n#include <vector>\n#include <fstream>\n#include <list>\n#include <iomanip>\n#include <numeric>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define REP(i, lim) for(int i=0;i<lim;++i)\n#define REPP(i, lim) for(int i=1;i<=lim;++i)\n#define DEC(i, lim) for(int i=lim;i>=1;--i)\n#define FOR(i,l,r)  for(int i=l;i<r;++i)\n#define deBug cout<<\"===================================\"<<endl;\n#define clr(s) memset(s, 0, sizeof(s))\n#define lowclr(s) memset(s, -1, sizeof(s))\nconst int MAXN = 1000055;\nconst int inf = 0x3f3f3f3f;\nconst double pi = acos(-1.0);\nconst db eps = 1e-9;\n\ninline int sgn(db x) { return x<-eps ? -1 : x>eps; }\ninline db sqr(db x) { return x*x; }\n\n#define cross(p1, p2, p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1, p2, p3) sgn(cross(p1, p2, p3))\n\nstruct P {\n    // information\n    P() {}\n    P(db _x, db _y) : x(_x), y(_y) {}\n    db x, y;\n    // operation\n    P operator + (P p)   const{ return P(x+p.x, y+p.y); }\n    P operator - (P p)   const{ return P(x-p.x, y-p.y); }\n    P operator * (db d)  const{ return P(x*d, y*d); }\n    P operator / (db d)  const{ return P(x/d, y/d); }\n    bool operator<(P p) const {\n        int c = sgn(x-p.x);\n        if (c) return c == -1;\n        return sgn(y-p.y)==-1;\n    }\n    db dot(P p) { return x * p.x + y * p.y; } // 点积\n    db det(P p) { return x * p.y - y * p.x; } // 叉积\n\n    // other\n    void input() { scanf(\"%lf%lf\", &x, &y); }\n    void print() { printf(\"(%lf, %lf)\\n\", x, y); }\n    db disTo(P p) { return sqrt(sqr(x-p.x) + sqr(y-p.y)); }\n    db abs() { return sqrt(x*x + y*y); }\n    db abs2(){ return x*x + y*y; }\n    db getw(){ return atan2(y,x); }\n    int getP() const{ return sgn(y)==1||(sgn(y)==0&&sgn(x)>=0); }\n};\nint cmpAngle (P a, P b){\n    if(a.getP()!=b.getP())  return a.getP()<b.getP();\n    else                    return sgn(a.det(b)) > 0;\n}\nbool chkLL(P p1, P p2, P q1, P q2) {\n    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n    return sgn(a1+a2) != 0;\n}\nP getLL(P p1, P p2, P q1, P q2) {\n    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n    return (p1 * a2 + p2 * a1) / (a1 + a2);\n}\nbool intersect(db l1, db r1, db l2, db r2) {\n    if(l1>r1) swap(l1, r1); if(l2>r2) swap(l2, r2);\n    return !( sgn(r1-l2) == -1 || sgn(r2-l1) == -1 );\n}\nbool chkSS(P p1, P p2, P q1, P q2) {\n    return intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y) &&\n           crossOp(p1, p2, q1) * crossOp(p1, p2, q2) <= 0 &&\n           crossOp(q1, q2, p1) * crossOp(q1, q2, p2) <=0;\n}\nbool chkSS_strict(P p1, P p2, P q1, P q2) {\n    return crossOp(p1, p2, q1) * crossOp(p1, p2, q2) < 0 &&\n           crossOp(q1, q2, p1) * crossOp(q1, q2, p2) < 0;\n}\nbool inMiddle(db a, db m, db b) { return sgn(a-m)==0 || sgn(b-m)==0 || (a<m != b<m); }\nbool inMiddle(P a, P m, P b) { return inMiddle(a.x, m.x, b.x) && inMiddle(a.y, m.y, b.y); }\nbool onSeg(P p1, P p2, P q) { return crossOp(p1, p2, q) == 0 && inMiddle(p1, q, p2); }\nbool onSeg_strict(P p1, P p2, P q) {\n    return crossOp(p1, p2, q) == 0 && sgn((q-p1).dot(p1-p2)) * sgn((q-p2).dot(p1-p2)) < 0;\n}\nP getProj(P a, P b, P p) { return a + (b-a) * ( (b-a).dot(p-a) / sqr(a.disTo(b)));}\nP getReflect(P a, P b, P p) { return getProj(a, b, p) * 2 - p; }\ndb nearest(P p1, P p2, P q) {\n    P h = getProj(p1, p2, q);\n    if(inMiddle(p1, h, p2)) return q.disTo(h);\n    return min(p1.disTo(q), p2.disTo(q));\n}\ndb disSS(P p1, P p2, P q1, P q2) {\n    if(chkSS(p1, p2, q1, q2)) return 0;\n    return min(min(nearest(p1,p2,q1), nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)));\n}\n\nint contain(vector<P>A,P q){ // 2 内部 1 边界 0 外部\n    int pd=0; A.push_back(A[0]);\n    for (int i=1;i<A.size();i++){\n        P u=A[i-1],v=A[i];\n        if (onSeg(u,v,q)) return 1; if (sgn(u.y-v.y)>0) swap(u,v);\n        if (sgn(u.y-q.y)>=0||sgn(v.y-q.y)<0) continue;\n        if (sgn((u-v).det(q-v))<0) pd^=1;\n    }\n    return pd<<1;\n}\nvector<P> convexHull (vector<P> ps) {\n    int n = ps.size(); if(n<=1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n*2); int k = 0;\n    for(int i=0;i<n;qs[k++]=ps[i++])\n        while(k>1 && crossOp(qs[k-2], qs[k-1], ps[i])<=0) --k;\n    for(int i=n-2,t=k;i>=0;qs[k++]=ps[i--])\n        while(k>t && crossOp(qs[k-2], qs[k-1], ps[i])<=0) --k;\n    qs.resize(k-1);\n    return qs;\n}\nvector<P> convexHull_noStrict (vector<P> ps) {\n    int n = ps.size(); if(n<=1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n*2); int k = 0;\n    for(int i=0;i<n;qs[k++]=ps[i++])\n        while(k>1 && crossOp(qs[k-2], qs[k-1], ps[i])<0) --k;\n    for(int i=n-2,t=k;i>=0;qs[k++]=ps[i--])\n        while(k>t && crossOp(qs[k-2], qs[k-1], ps[i])<0) --k;\n    qs.resize(k-1);\n    return qs;\n}\nint chkConvex(vector<P> ps){\n    int n = ps.size();\n    ps.push_back(ps[0]); ps.push_back(ps[1]);\n    for(int i=0;i<n;++i) if(sgn((ps[i+1]-ps[i]).det(ps[i+2]-ps[i]))==-1) return 0;\n    return 1;\n}\ndb convexDiameter(vector<P> ps) {\n    int n = ps.size(); if(n<=1) return 0;\n    int is = 0, js = 0;\n    REPP(k, n) is = ps[k]<ps[is] ? k:is, js = ps[js] < ps[k] ? k : js;\n    int i = is, j = js;\n    db ret = ps[i].disTo(ps[j]);\n    do{\n        if((ps[(i+1)%n] - ps[i]).det(ps[(j+1)%n]-ps[j])>=0)\n            (++j) %= n;\n        else\n            (++i) %= n;\n        ret = max(ret, ps[i].disTo(ps[j]));\n    } while(i!=is || j!=js);\n    return ret;\n}\n\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n//    std::ios::sync_with_stdio(false); cin.tie(0);\n\n    vector<P> poly;\n    int n;\n    scanf(\"%d\", &n);\n    REP(i, n) {\n        P tmp; tmp.input();\n        poly.push_back(tmp);\n    }\n\n    vector<P> conv = convexHull_noStrict(poly);\n    db ans = convexDiameter(conv);\n    printf(\"%.12lf\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-8;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n\n    D norm() const { return x*x + y*y; }\n    D abs() const { return sqrt(norm()); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); }\n    D arg() const { return atan2(y, x); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    return os << \"(\" << p.x << \", \" << p.y << \")\";\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n};\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\n\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return -1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nusing Pol = V<P>;\n\n// pol must be convex\nD diameter(const Pol &p) {\n    int n = int(p.size());\n    int x = 0, y = 0;\n    for (int i = 1; i < n; i++) {\n        if (p[i] < p[x]) x = i;\n        if (p[y] < p[i]) y = i;\n    }\n    D ans = 0;\n    int sx = x, sy = y;\n    while (sx != y || sy != x) {\n        ans = max(ans, (p[x]-p[y]).abs());\n        int nx = (x+1 < n) ? x+1 : 0, ny = (y+1 < n) ? y+1 : 0;\n        if (cross(p[nx] - p[x], p[ny] - p[y]) < 0) x = nx;\n        else y = ny;\n    }\n    return ans;\n}\n\nint main(void) {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(20) << fixed;\n    int n;\n    cin >> n;\n    Pol p(n);\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    cout << diameter(p) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem \nusing namespace placeholders;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nauto& operator >> (istream& is,P& p){ R x,y; is >> x >> y,p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline P vec(L l){return l.t-l.s;}\nauto sdot = bind(sgn,bind(dot,_1,_2,_3));\nauto sdet = bind(sgn,bind(det,_1,_2,_3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/vec(l)); return (1-u)*l.s+u*l.t;}\n\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tint n=pol.size(),i=0,j=0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\tR res=0.0;\n\n\tauto cmp_x=[](P a,P b)->bool{\n\t\tint sr = sgn(real(a-b)), si = sgn(imag(a-b));\n\t\treturn sr ? sr < 0 :si < 0;\n\t};\n\t\n\trep(k,n){\n\t\tif(!cmp_x(pol[i],pol[k]))i=k;\n\t\tif(cmp_x(pol[j],pol[k]))j=k;\n\t}\n\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tres = max(res,abs(pol[i]-pol[j]));\n\t\tif(sdet(0,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j])<0)\n\t\t\ti=(i+1)%n;\n\t\telse \n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\nusing R = double;\nusing P = complex<R>;\n#define x real()\n#define y imag()\nconst R eps = 1e-9,PI = acos(-1);\n\nbool equal(R a,R b){return abs(b-a)<eps;}\nbool equal0(R a){return equal(a,0.0);}\n\nP operator*(const P& p,const R& d){\n    return P(p.x*d,p.y*d);\n}\n\nistream &operator>>(istream& is,P& p){\n    R a,b;\n    is >> a >> b;\n    p = P(a,b);\n    return is;\n}\n\nostream &operator<<(ostream& os,P& p){\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n//内積\ndouble dot(P a,P b) {return (conj(a)*b).real();}\n//外積\ndouble cross(P a,P b) {return (conj(a)*b).imag();}\n\nstruct L{\n    P a,b;\n    L(P a,P b):a(a),b(b){}\n    L(R A,R B,R C){\n        if(equal(A,0)) a = P(0,C/B),b = P(1,C/B);\n        else if(equal(B,0)) b = P(C/A,0),b = P(C/A,1);\n        else a = P(0,C/B),b = P(C/A,0);\n    }\n};\n\n//pをbに射影\nP projection(P p,P b) {return b*dot(p,b)/norm(b);}\n\n//pとp1 to p2 に射影\nP projection(L l,P p){\n    p -= l.a; l.b -= l.a;\n    P proj = projection(p,l.b);\n    return l.a+proj;\n}\n\nstruct S:L{\n    S(P a,P b):L(a,b){}\n};\n\n//点の回転方向を判定\nint ccw(P p0,P p1,P p2){\n    p1 -= p0,p2 -= p0;\n    if(cross(p1,p2)>eps) return 1; //\"COUNTER_CLOCKWISE\"\n    if(cross(p1,p2)<-eps) return -1; //\"CLOCKWISE\"\n    if(dot(p1,p2)<0) return 2; //\"ONLINE_BACK\"\n    if(norm(p1)<norm(p2)) return -2; //\"ONLINE_FRONT\"\n    return 0; //\"ON_SEGMENT\"\n}\n\nbool is_parallel(L l1,L l2){\n    return equal0(cross(l1.b-l1.a,l2.b-l2.a));\n}\n\nbool is_orthogonal(L l1,L l2){\n    return equal0(dot(l1.b-l1.a,l2.b-l2.a));\n}\n\n//pをlに関して対称移動\nP reflection(L l,P p){\n    P pj = projection(l,p);\n    return 2.0*pj-p;\n}\n\n//pがl上にあるか\nbool is_online(L l,P p){\n    return abs(ccw(l.a,l.b,p))!=1;\n}\n\nbool is_onsegment(S s,P p){\n    return ccw(s.a,s.b,p)==0;\n}\n\n//線分の交差判定\nbool intersect(S s,S t){\n    return ccw(s.a,s.b,t.a)*ccw(s.a,s.b,t.b)<=0 && ccw(t.a,t.b,s.a)*ccw(t.a,t.b,s.b)<=0;\n}\n\n//2直線の交点\nP crosspoint(L l1,L l2){\n    R a = cross(l1.b-l1.a,l2.b-l2.a);\n    R b = cross(l1.b-l1.a,l1.b-l2.a);\n    if(equal0(abs(a)) && equal0(abs(b))) return l2.a;\n    return l2.a+(l2.b-l2.a)*b/a;\n}\n\nP crosspoint(S s1, S s2){\n    return crosspoint(L(s1),L(s2));\n}\n\nR dist(P a,P b){\n    return abs(a-b);\n}\n\nR dist(L l,P p){\n    return abs(p-projection(l,p));\n}\n\nR dist(L l1,L l2){\n    return is_parallel(l1,l2)? 0:dist(l1,l2.a);\n}\n\nR dist(S s,P p){\n    P r = projection(s,p);\n    if(is_onsegment(s,r)) return abs(r-p);\n    return min(dist(s.a,p),dist(s.b,p));\n}\n\nR dist (S s1,S s2){\n    if(intersect(s1,s2)) return 0;\n    return min({dist(s1,s2.a),dist(s1,s2.b),\n    dist(s2,s1.a),dist(s2,s1.b)});\n}\n\nusing Polygon = vec<P>;\n\nR area_of_polygon(Polygon& v){\n    int n = v.size();\n    R res = 0;\n    for(int i=0;i+2<n;i++){\n        res += cross(v[i+1]-v[0],v[i+2]-v[0]);\n    }\n    return res/2;\n}\n\nbool is_convex(Polygon& v){\n    int n = v.size();\n    for(int i=0;i<n;i++){\n        P a = v[i%n],b = v[(i+1)%n],c = v[(i+2)%n];\n        if(cross(b-a,c-a)<-eps) return false;\n    }\n    return true;\n}\n\nenum{\n    OUT,ON,IN\n};\n\n//点pと多角形vの関係\nint contains(Polygon& v,P p){\n    bool in = false;\n    int n = v.size();\n    for(int i=0;i<n;i++){\n        P a = v[i]-p,b = v[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<=0 && 0<b.y && cross(a,b)<0) in = !in;\n        if(is_onsegment(S(a,b),P(0,0))) return ON;\n    }\n    return in? IN:OUT;\n}\n\nPolygon convex_hull(Polygon& v){\n    int n = v.size();\n    Polygon res;\n    sort(v.begin(),v.end(),[](P& a,P& b){\n        return (a.x!=b.x? a.x<b.x:a.y<b.y);\n    });\n    for(int i=0;i<n;i++){\n        if(i<2){\n            res.push_back(v[i]);\n            continue;\n        }\n        while(true){\n            int s = res.size();\n            if(s<2){\n                res.push_back(v[i]);\n                break;\n            }\n            R c = cross(res[s-1]-res[s-2],v[i]-res[s-2]);\n            if(c<-eps){\n                res.pop_back();\n            }else{\n                res.push_back(v[i]);\n                break;\n            }\n        }\n    }\n    reverse(v.begin(),v.end());\n    for(int i=0;i<n;i++){\n        while(true){\n            int s = res.size();\n            if(v[i]==res.back()) break;\n            if(s<2){\n                res.push_back(v[i]);\n                break;\n            }\n            R c = cross(res[s-1]-res[s-2],v[i]-res[s-2]);\n            if(c<-eps){\n                res.pop_back();\n            }else{\n                res.push_back(v[i]);\n                break;\n            }\n        }\n    }\n    res.pop_back();\n    return res;\n}\n\nR convex_diameter(Polygon v){\n    int n = v.size();\n    int l = 0,r = 0;\n    for(int i=1;i<n;i++){\n        if(v[i].y>v[l].y) l = i;\n        if(v[i].y<v[r].y) r = i;\n    }\n    R res = abs(v[l]-v[r]);\n    int i = l,mai = l,j = r,maj = r;\n    do{\n        if(cross(v[(i+1)%n]-v[i],v[(j+1)%n]-v[j])>=0) j = (j+1)%n;\n        else i = (i+1)%n;\n        if(abs(v[i]-v[j])>res){\n            res = abs(v[i]-v[j]);\n            mai = i; maj = j;\n        }\n    }while(i!=l || j!=r);\n    return res;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    Polygon v(N);\n    for(int i=0;i<N;i++){\n        cin >> v[i];\n    }\n    cout << fixed << setprecision(10) << convex_diameter(v) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n\nconstexpr double EPS = 1e-10;\nusing Point = complex<double>;\nusing Line  = pair<Point, Point>;\nusing Polygon = vector<Point>;\nbool compare(const Point &a, const Point &b) { // x ascending order\n    if(a.real() != b.real()) return a.real() < b.real();\n    return a.imag() < b.imag();\n};\n\ndouble dot(Point p, Point q) { return (conj(p) * q).real(); }\ndouble cross(Point p, Point q) { return (conj(p) * q).imag(); }\n\nPolygon convex_hull(Polygon &ps) {\n    sort(ps.begin(), ps.end(), compare);\n    int n = (int)ps.size(), k = 0;\n    Polygon res(n * 2);\n\n    // use \"< -EPS\" if include corner or boundary, otherwise, use \"< EPS\"\n    for(int i = 0; i < n; res[k++] = ps[i++]) \n        while(k >= 2 && cross(res[k-1] - res[k-2], ps[i] - res[k-1]) < -EPS) --k; \n\n    for(int i = n - 2, t = k+1; i >= 0; res[k++] = ps[i--])\n        while(k >= t && cross(res[k-1] - res[k-2], ps[i] - res[k-1]) < -EPS) --k;\n\n    res.resize(k - 1);\n    return res;\n}\n\ndouble caliper(Polygon &ps) {\n    ps = convex_hull(ps);\n    int n = (int)ps.size();\n    if(n == 2) {return abs(ps[0] - ps[1]);}\n    \n    int i = 0, j = 0;\n    // j --> (x asc order) --> i\n    for(int k=0; k < n; ++k) {\n        if(compare(ps[i],ps[k])) i = k;\n        if(compare(ps[k],ps[j])) j = k;\n    }\n\n    int si = i, sj = j;\n    double res = 0.0;\n    // rotate 180 degrees\n    while(i != sj || j != si) {\n        res = max(res, abs(ps[i] - ps[j]));\n        if(cross(ps[(i + 1) % n] - ps[i], ps[(j + 1) % n] - ps[j]) < 0) {\n            i = (i + 1) % n;\n        } else {\n            j = (j + 1) % n;\n        }\n    }\n\n    return res;\n}\n\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int n; cin >> n;\n    cout << fixed << setprecision(10);\n    Polygon ps;\n    for(int i=0; i < n; ++i) {\n        double x,y;cin >> x >> y;\n        ps.emplace_back(x,y);\n    }\n    cout << caliper(ps) << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\tinline double td()\n\t{\n\t\tdouble a=0,bas=1;\n\t\tint b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\tif(c=='.')\n\t\t{\n\t\t\tc=fetch();\n\t\t\twhile(isdigit(c))bas*=0.1,a=a+bas*(c-48),c=fetch();\n\t\t}\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\nusing ae86::td;\n\nconst double eps = 1e-8;\n\ninline int dcmp(double x){if(-eps<x && x<eps)return 0;return x>0?1:-1;}\n\nstruct points\n{\n\tdouble x,y;\n\tpoints(double _x=0,double _y=0){x=_x,y=_y;}\n\n\tinline friend points operator + (points a,points b){return points(a.x+b.x,a.y+b.y);}\n\tinline friend points operator - (points a,points b){return points(a.x-b.x,a.y-b.y);}\n\tinline friend points operator * (points a,double b){return points(a.x*b,a.y*b);}\n\tinline friend points operator / (points a,double b){return points(a.x/b,a.y/b);}\n\n\tinline friend int operator == (points a,points b){return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;}\n\n\tvoid takein(){x=td(),y=td();}\n\tvoid print(char ends='\\n'){printf(\"%.12lf %.12lf\",x,y),putchar(ends);}\n};\n\ninline double dox(points a,points b){return a.x*b.x+a.y*b.y;}\ninline double cox(points a,points b){return a.x*b.y-a.y*b.x;}\ninline double cox(points bas,points a,points b){return cox(a-bas,b-bas);}\ninline double length(points a){return sqrt(dox(a,a));}\ninline double distan(points a,points b){return length(a-b);}\ninline double angle(points a){return atan2(a.y,a.x);}\n\ninline points pervec(points a){if(dcmp(length(a))<=0)return points(0,0);return a/length(a);}\n\ninline int isponl(points p,points a,points b)\n{\n\treturn dcmp(cox(p-a,p-b))==0 && distan(a,p)<=distan(a,b) && distan(b,p)<=distan(a,b);\n}\n\ninline int iscrashed(points al,points ar,points bl,points br)\n{\n\tdouble amix=min(al.x,ar.x),amxx=max(al.x,ar.x),amiy=min(al.y,ar.y),amxy=max(al.y,ar.y);\n\tdouble bmix=min(bl.x,br.x),bmxx=max(bl.x,br.x),bmiy=min(bl.y,br.y),bmxy=max(bl.y,br.y);\n\t\n\tif(amxx<bmix || bmxx<amix || amxy<bmiy || bmxy<amiy)return 0;\n\tif(isponl(al,bl,br) || isponl(ar,bl,br) || isponl(bl,al,ar) || isponl(br,al,ar))return 1;\n\n\tif(dcmp(cox(al-bl,br-bl))!=dcmp(cox(ar-bl,br-bl))\n\t\t&& dcmp(cox(bl-al,ar-al))!=dcmp(cox(br-al,ar-al)))return 1;\n\treturn 0;\n}\n\ninline points crash(points al,points ar,points bl,points br)\n{\n\tpoints a=ar-al,b=br-bl;\n\tdouble bas=cox(al-bl,b)/cox(b,a);\n\treturn al+a*bas;\n}\n\ninline points ortho(points p,points a,points b)\n{\n\tpoints c=a+pervec(b-a);\n\tdouble dis=dox(p-a,c-a);\n\tpoints tar=a+(c-a)*dis;\n\treturn tar;\n}\n\ninline double distanpl(points p,points a,points b)\n{\n\tif(isponl(p,a,b))return 0;\n\tpoints ort=ortho(p,a,b);\n\tif(isponl(ort,a,b))return distan(p,ort);\n\treturn min(distan(p,a),distan(p,b));\n}\n\nconst int _ = 80007;\n\nint n;\npoints p[_];\n\nint main()\n{\n\tn=ty();\n\tfor(int i=1;i<=n;i++)p[i].takein();\n\n\tp[0]=p[n],p[n+1]=p[1];\n\n\tdouble mx=0;\n\n\tfor(int i=0,j=2;i<n;i++)\n\t{\n\t\twhile(cox(p[i],p[i+1],p[j])<cox(p[i],p[i+1],p[j+1]))j=(j+1)%n;\n\t\tmx=max(mx,max(distan(p[i],p[j]),distan(p[i+1],p[j])));\n\t}\n\n\tprintf(\"%.10lf\\n\",mx);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\ntypedef long double     lf;\n\nusing namespace std;\n\nconst lf EPS = 1e-9;\nconst lf oo = 1e15;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << int(p.x) << \" \" << int(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf dot( pt A, pt B ) {\n  return x(A)*x(B) + y(A)*y(B);\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nlf distToLine (pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  c = A + u*( B-A );\n  return dist( p , c );\n}\n\npt refPoint(pt X, pt A, pt B) {\n  pt aux; distToLine(X, A, B, aux);\n  return X + lf(2.0)*(aux-X);\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf cross( pt A, pt B ) {\n  return x(A)*y(B) - y(A)*x(B);\n}\n\n///CHANGE\n// 0  for collineal points ( angle = 0 )\n// 1  for angle BAX counter clockwise\n// -1 for angle BAX clockwise\ninline int ccw (pt X, pt A, pt B) {\n  lf c = cross( B-A, X-A );\n  if( same( c, 0.0 ) ) { return 0; }\n  if( c > EPS ) { return 1; }\n  return -1;\n}\n\n///CHANGE\ninline bool segContains ( pt X, pt A, pt B) {\n  if ( !same ( 0, cross ( A-X, B-X ) ) ) return 0;\n  return ( dot ( A-X, B-X ) < EPS );\n}\n\ninline bool parallel( pt A, pt B, pt C, pt D ) {\n  return same ( 0, cross( B-A, D-C ) );\n}\n\n///NEW\ninline bool ortho( pt A, pt B, pt C, pt D ) {\n  return same ( 0, dot( B-A, D-C ) );\n}\n\ninline bool samePt ( pt A, pt B ) {\n  return same ( x(A), x(B) ) && same ( y(A), y(B) );\n}\n\npt linesIntersection ( pt A, pt B, pt C, pt D ) {\n  lf x = cross ( C, D-C ) - cross ( A, D-C );\n  x /= cross ( B-A, D-C );\n  return A + x*(B-A);\n}\n\ninline bool collinearSegsIntersects ( pt A, pt B, pt C, pt D ) {\n  return segContains(A,C,D) || segContains(B,C,D)\n      || segContains(C,A,B) || segContains(D,A,B);\n}\n\nbool segmentsIntersect(pt A, pt B, pt C, pt D) {\n  if( samePt(A,B) )\n    return segContains( A, C, D );\n  if( samePt(C,D) )\n    return segContains( C, A, B );\n  if( parallel(A,B,C,D) )\n    return collinearSegsIntersects( A,B,C,D );\n  pt aux = linesIntersection(A,B,C,D);\n  return segContains(aux,A,B) && segContains(aux,C,D);\n}\n\n///CHANGE\nlf distToSegment(pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  if( u < -EPS ) { c = A; return dist( p , A ); }\n  if( (u-1.0) > EPS ) { c = B; return dist( p, B ); }\n  return distToLine(p,A,B,c);\n}\n\n// P[0] must be equal to P[n]\n// Area is positive if the polygon is ccw\ndouble signedArea(const vector<pt> &P) {\n  double result = 0.0;\n  for(int i = 0; i < (int)P.size()-1; i++) result += cross( P[i],P[i+1] );\n  return result / 2.0;\n}\n\ndouble area(const vector<pt> &P) { return fabs(signedArea(P)); }\n\n///CHANGE\n// P[0] must be equal to P[n]\nbool isConvex( const vector<pt> &P) {\n  int sz = (int) P.size(); if(sz <= 3) return false;\n  bool isL = ccw(P[0], P[1], P[2]) >= 0;\n  for (int i = 1; i < sz-1; i++) {\n    if( ( ccw(P[i], P[i+1], P[(i+2) == sz ? 1 : i+2]) >= 0 ) != isL) return false;\n  }\n  return true;\n}\n\n///CHANGE\n// P[0] must be equal to P[n]     -    O(N)\n// Return 1 for interior, 0 for boundary and -1 for exterior\nint inPolygon(pt X, const vector<pt> &P) {\n  const int n = P.size(); int cnt = 0;\n  for (int i = 0; i < n-1; i++) {\n    if( segContains(X, P[i], P[i+1]) ) return 0;\n    if( y(P[i]) <= y(X) ) {\n      if( y(P[i+1]) > y(X) )\n        if( !(ccw( X, P[i], P[i+1]) >= 0) ) cnt++;\n    }\n    else if ( y(P[i+1]) <= y(X) ) {\n      if( ccw( X, P[i], P[i+1]) >= 0 ) cnt--;\n    }\n  }\n  if(cnt == 0) return -1;\n  else return 1;\n}\n\n///CHANGE\n//CONVEX HULL Monotone Chain O( N Log N )\nbool cmpPt( pt A, pt B ) {\n  if( !same( x(A), x(B) ) ) return x(A) < x(B);\n  return y(A) < y(B);\n}\n\nint turn(pt A, pt B, pt C) {\n  lf r = cross(B-A, C-A);\n  if( same( r, 0.0 ) ) return 0;\n  if( r > EPS ) return 1;\n  return -1;\n}\n\n// Return CH in ccw order starting at leftmost - downmost x\n// Doesn't return P[ n ] = P[ 0 ]\nvector<pt> CH( vector<pt> &P ) {\n  if ( P.size() == 1 ) return P;\n  const int n = P.size();\n  sort ( P.begin(), P.end(), cmpPt );\n  vector<pt> up;\n  up.push_back(P[0]); up.push_back(P[1]);\n  vector<pt> dn;\n  dn.push_back(P[0]); dn.push_back(P[1]);\n  for ( int i = 2; i < n; ++i ) {\n    // If collineal points are not needed, is >= and <=, otherwise > and <\n    while ( up.size() > 1 && turn(up[up.size()-2],up.back(),P[i]) >= 0 )\n      up.pop_back();\n    while ( dn.size() > 1 && turn(dn[dn.size()-2],dn.back(),P[i]) <= 0 )\n      dn.pop_back();\n    up.push_back(P[i]);\n    dn.push_back(P[i]);\n  }\n  for (int i = (int) up.size() - 2; i >= 1; i--) dn.push_back(up[i]);\n  return dn;\n}\n\n/// --------------------------------------------\n\nint n;\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  vector<pt> P(n);\n  pt A(oo,0) , B(-oo,0);\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  int idx;\n  lf ans = -oo;\n  for( int i = 1; i < n; ++i ) {\n    if( dist(P[0], P[i]) > ans+EPS ) {\n      idx = i;\n      ans = dist( P[0], P[i] );\n    }\n  }\n  lf prv = dist( P[1], P[1] );\n  int sz = int(P.size());\n  for( int i = 1, j = idx; i < idx; ++i ) {\n    while( prv+EPS < dist( P[i], P[j] ) ) {\n      prv = dist( P[i], P[j] );\n      j = (j+1)%sz;\n      ans = max( ans, prv );\n    }\n  }\n  cout << double(ans) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\n// Description: ????????????\n// Verifyed: various problem\nusing namespace placeholders;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P = complex<R>;\nusing L = struct {P s, t;};\nusing VP = vector<P>;\nusing C = struct {P c; R r;};\n\n#define at(a,i) (a[(i + a.size()) % a.size()])\n\nauto& operator >> (istream& is, P& p) { R x, y; is >> x >> y, p = P(x, y); return is;}\nauto& operator << (ostream& os, P& p) { os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std {\nbool operator <  (const P& a, const P& b) { return sgn(real(a - b)) ? real(a - b) < 0 : sgn(imag(a - b)) < 0;}\nbool operator == (const P& a, const P& b) { return sgn(real(a - b)) == 0 && sgn(imag(a - b)) == 0;}\n}\n\ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline P vec(L l) {return l.t - l.s;}\nauto sdot = bind(sgn, bind(dot, _1, _2, _3));\nauto sdet = bind(sgn, bind(det, _1, _2, _3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l, P p) { R u = real((p - l.s) / vec(l)); return (1 - u) * l.s + u * l.t;}\n//reflection verify AOJ CGL_1_B\nP refl(L l, P p) {return 2.0L * proj(l, p) - p;}\n\n// CCW verify AOJ CGL_1_C\nenum CCW { LEFT = 1, RIGHT = 2, BACK = 4, FRONT = 8, ON = 16};\ninline int ccw(P o, P a, P b) {\n\tif (sdet(o, a, b) > 0) return LEFT; // counter clockwise\n\tif (sdet(o, a, b) < 0) return RIGHT; // clockwise\n\tif (sdot(o, a, b) < 0) return BACK; // b--base--a on line\n\tif (sgn(norm(a - o) - norm(b - o)) < 0) return FRONT; // base--a--b on line\n\treturn ON; // base--b--a on line  semnet determination betwenn a and b\n}\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a, L b) {return sdot(0, vec(a), vec(b)) == 0;}\nbool parallel(L a, L b) {return sdet(0, vec(a), vec(b)) == 0;}\nbool eql(L a, L b) { return parallel(a, b) and sdet(a.s, a.t, b.s) == 0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B\nbool iss(L a, L b) {\n\tint sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n\tint sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n\treturn max(sa, sb) < 0;\n}\n\n// crossing point\n// verified: AOJ CGL_2_C\nP cross(L a, L b) {\n\tR u = det(a.s, b.s, b.t) / det(0, vec(a), vec(b));\n\treturn (1 - u) * a.s + u * a.t;\n}\n\n// distance\n// verified: AOJ CGL_2_D\nR dsp(L l, P p) {\n\tP h = proj(l, p);\n\tif (sdot(l.s, l.t, p) <= 0) h = l.s;\n\tif (sdot(l.t, l.s, p) <= 0) h = l.t;\n\treturn abs(p - h);\n}\n\nR dss(L a, L b) {\n\tif (iss(a, b)) return 0;\n\treturn min({dsp(a, b.s), dsp(a, b.t), dsp(b, a.s), dsp(b, a.t)});\n}\n// Polygon\n\n// area\n// verified: AOJ 1100 CGL_3_A\nR area(const VP& pol) {\n\tR sum = 0.0;\n\trep(i, pol.size()) sum += det(0, at(pol, i), at(pol, i + 1));\n\treturn abs(sum / 2.0L);\n}\n\n// convex_polygon determination\n// verified: CGL_3_B\nbool is_convex(const VP& pol) {\n\trep(i, pol.size()) {\n\t\tif (sdet(at(pol, i), at(pol, i + 1), at(pol, i + 2)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// polygon realation determination  in  2 on 1 out 0???(possible non-convex)\n// verified: AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p) {\n\tint res = 0;\n\tauto simag = [](const P & p) {return sgn(imag(p));};\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tif (sdet(p, a, b) == 0 and sdot(p, a, b) <= 0) return 1;\n\t\tbool f = simag(p - a) >= 0, s = simag(p - b) < 0;\n\t\tif (simag(b - a)*sdet(a, b, p) == 1 and f == s) res += (2 * f - 1);\n\t}\n\treturn res ? 2 : 0;\n}\n\n// polygon realation determination???(possible non-convex)\n// verified: not AOJ 2514\nbool in_polygon(const VP& pol, const L& l) {\n\tVP check = {l.s, l.t};\n\trep(i, pol.size()) {\n\t\tL edge = {at(pol, i), at(pol, i + 1)};\n\t\tif (iss(l, edge)) check.emplace_back(cross(l, edge));\n\t}\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tsort(begin(check), end(check), cmp_x);\n\trep(i, check.size() - 1) {\n\t\tP m = (at(check, i) + at(check, i + 1)) / 2.0L;\n\t\tif (in_polygon(pol, m) == false) return false;\n\t}\n\treturn true;\n}\n\n// convex_cut\n// verified: AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n\tVP res;\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tint da = sdet(l.s, l.t, a), db = sdet(l.s, l.t, b);\n\t\tif (da >= 0) res.emplace_back(a);\n\t\tif (da * db < 0) res.emplace_back(cross({a, b}, l));\n\t}\n\treturn res;\n}\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol) {\n\tint n = pol.size(), i = 0, j = 0;\n\tif (n <= 2) return abs(pol[0] - pol[1]);\n\tR res = 0.0;\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\trep(k, n) {\n\t\tif (!cmp_x(pol[i], pol[k]))i = k;\n\t\tif (cmp_x(pol[j], pol[k]))j = k;\n\t}\n\n\tint si = i, sj = j;\n\twhile (i != sj || j != si) {\n\t\tres = max(res, abs(pol[i] - pol[j]));\n\t\tP li = vec(L{at(pol, i), at(pol, i + 1)});\n\t\tP lj = vec(L{at(pol, j), at(pol, j + 1)});\n\t\tif (sdet(0, li, lj) > 0)\n\t\t\ti = (i + 1) % n;\n\t\telse\n\t\t\tj = (j + 1) % n;\n\t}\n\treturn res;\n}\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a, int flag = 1) {\n\tconst int n = a.size(), m = n / 2;\n\tif (n <= 1) return INF;\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tif (flag) sort(begin(a), end(a), cmp_x);\n\n\tVP b(begin(a), begin(a) + m), c(begin(a) + m, end(a));\n\tR x = real(a[m]), d = min(cpp(b, 0), cpp(c, 0));\n\n\n\tauto cmp_y = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn si ? si < 0 : sr < 0;\n\t};\n\n\tsort(begin(a), end(a), cmp_y);\n\tdeque<P> e;\n\n\tfor (auto &p : a) {\n\t\tif (abs(real(p) - x) >= d) continue;\n\n\t\tfor (auto &q : e) {\n\t\t\tif (imag(p - q) >= d) break;\n\t\t\td = min(d, abs(p - q));\n\t\t}\n\t\te.push_front(p);\n\t}\n\treturn d;\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i, n) {\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;"
  },
  {
    "language": "C++",
    "code": "// InterestingLSY\n// 2659723130\n// 《幽灵公主》是真的好看！\n#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define Eb emplace_back\n#define All(x) x.begin(),x.end()\n#define AllRev(x) x.rbegin(),x.rend()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1048576\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10 + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1LL, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10LL + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = '\\0';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+\".in\").c_str());\n\t\tFout((pname+\".out\").c_str());\n\t#else\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+\".in\").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+\".out\").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << \"BreakPoint\" << endl;\n#define O(x) cerr << #x << \" \" << (x) << endl;\n#define o(x) cerr << #x << \" \" << (x) << \"  \";\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define Max(a,b) ((a)>(b)?(a):(b))\n#define Min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define MyMax(a,b) (a) = Max((a),(b))\n#define MyMin(a,b) (a) = Min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define Sqr(x) ((x)*(x))\n#define Lowbit(a) ((a)&(-(a)))\nvc<int> Range( int l , int r ){\n\tvc<int> ret{};\n\tForx(i,l,r) ret.Pb(i);\n\treturn ret;\n}\nmt19937 Rand(0xe38195e38293*time(0));\t// さん\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#undef ld\n#define ld long double\nconst ld Eps = 1e-9;\nstruct Point{ ld x,y; };\nil Point operator+( const Point &a , const Point &b ){ return {a.x+b.x,a.y+b.y}; }\nil Point operator-( const Point &a , const Point &b ){ return {a.x-b.x,a.y-b.y}; }\nil auto operator^( const Point &a , const Point &b ){ return a.x*b.x + a.y*b.y; }\nil auto operator*( const Point &a , const Point &b ){ return a.x*b.y - b.x*a.y; }\nil Point operator*( const Point &a , const ld &b ){ return {a.x*b,a.y*b}; }\nil bool operator==( const Point &a , const Point &b ){ return a.x == b.x and a.y == b.y; }\nil ld Dis( const Point &a , const Point &b ){ return sqrt((ld)Sqr(a.x-b.x)+Sqr(a.y-b.y)); }\nil ld Dis2( const Point &a , const Point &b ){ return Sqr(a.x-b.x)+Sqr(a.y-b.y); }\nil bool OnSeg( const Point &a , const Point &b , const Point &c ){\n\tPoint ab = b-a, ac = c-a;\n\tif( fabs(ab*ac) > Eps ) return 0;\n\tif( (ab^ac) < -Eps ) return 0;\n\tif( fabs(ab.y*ab.y+ab.x*ab.x) > fabs(ac.y*ac.y+ac.x*ac.x) ) return 0;\n\t// cout << a.x << \" \" << a.y << \"  \" << b.x << \" \" << b.y << \"  \" << c.x << \" \" << c.y << endl;\n\treturn 1;\n}\nbool Ins( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tif( p1 == p3 or p1 == p4 or p2 == p3 or p2 == p4 ) return 1;\n\tif( OnSeg(p1,p3,p2) or OnSeg(p1,p4,p2) or OnSeg(p3,p1,p4) or OnSeg(p3,p2,p4) ) return 1;\n\tif( ((p2-p1)*(p3-p1)<0) == ((p2-p1)*(p4-p1)<0) ) return 0;\n\tif( ((p4-p3)*(p1-p3)<0) == ((p4-p3)*(p2-p3)<0) ) return 0;\n\treturn 1;\n}\nPoint InsPoint( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tld d1 = (ld)abs((p2-p3)*(p3-p1)) / Dis(p1,p2);\n\tld d2 = (ld)abs((p2-p4)*(p4-p1)) / Dis(p1,p2);\n\tld ratio = d1 / (d1+d2);\n\treturn (p4-p3)*ratio + p3;\n}\nPoint H( Point a , Point b , Point p ){\n\tPoint ab = b-a;\n\tld dis2 = Dis2(a,b);\n\tPoint ret = a + ab * (((p-a)^ab)/dis2);\n\treturn ret;\n}\nld Distance( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tif(Ins(p1,p2,p3,p4)) return 0;\n\tld ans = min({ Dis(p1,p3) , Dis(p1,p4) , Dis(p2,p3) , Dis(p2,p4) });\n\tauto Check = [&]( Point a , Point b , Point p ){\n\t\tPoint h = H(a,b,p);\n\t\tif(!OnSeg(a,h,b)) return;\n\t\tld tans = Dis(h,p);\n\t\tMymin(ans,tans);\n\t};\n\tCheck(p1,p2,p3);\n\tCheck(p1,p2,p4);\n\tCheck(p3,p4,p1);\n\tCheck(p3,p4,p2);\n\treturn ans;\n}\n\nint n;\nvc<Point> a;\n\nil int Next( int x ){\n\treturn x == n-1 ? 0 : x+1;\n}\n\n\nint main(){\n\tFILEIO();\n\tcout << setprecision(12) << fixed;\n\n\tcin >> n;\n\tFor0(i,n){\n\t\tld x,y;\n\t\tcin >> x >> y;\n\t\ta.Pb({(ld)x,(ld)y});\n\t}\n\n\tint j = 0;\n\tld ans = 0;\n\tFor0(i,n){\n\t\tMymax(ans,Dis2(a[j],a[i]));\n\t\twhile( Dis2(a[Next(j)],a[i]) >= Dis2(a[j],a[i]) ){\n\t\t\tj = Next(j);\n\t\t\tMymax(ans,Dis2(a[j],a[i]));\n\t\t}\n\t}\n\tcout << sqrt((ld)ans) << endl;\n\n\tEND();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 0.0;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = max(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <cmath>\n# include <cstdio>\n# include <iostream>\nusing namespace std;\n\nint N;\n\nstruct Point\n{\n\tdouble x, y;\n};\nPoint operator -(Point a, Point b) {return (Point) {a.x - b.x, a.y - b.y};}\ndouble norm(Point a) {return a.x * a.x + a.y * a.y;}\ndouble abs(Point a) {return sqrt(norm(a));}\nPoint p[80050];\n\ndouble ConvexHull(Point * p, int n)\n{\n\tdouble res = -1;\n\tfor(int i = 0, k = 0; i < n; i++)\n\t{\n\t\twhile(norm(p[i] - p[k]) < norm(p[i] - p[(k + 1) % n])) k = (k + 1) % n;\n\t\tres = max(res, abs(p[i] - p[k]));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%lf%lf\", &p[i].x, &p[i].y);\n\t}\n\tprintf(\"%.12lf\\n\", ConvexHull(p, N));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-10, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn std::abs(a - b) < eps;\n}\n\nusing point = complex<ld>;\n\nld dot(point a, point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(point a, point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(point a, point b, point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\t// a,b,c counter-clockwise\n\tif (cross(b, c) < -eps) return -1;\t// a,b,c clockwise\n\tif (dot(b, c) < 0) return 2;\t\t// c,a,b on a line\n\tif (norm(b) < norm(c)) return -2;\t// a,b,c on a line\n\treturn 0;\t\t\t\t\t\t\t// a,c,b on a line\n}\n\nstruct line {\n\tpoint a, b;\n\tline() : a(), b() {}\n\tline(const point& a_, const point &b_)\n\t\t: a(a_), b(b_) {}\n};\n\nbool isis_ll(line l, line m) {\n\treturn std::abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(line l, line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n\treturn std::abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(line s, point p) {\n\treturn std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps;\n}\n\npoint proj(line l, point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n\tpoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(line s, line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(line l, point p) {\n\treturn std::abs(p - proj(l, p));\n}\n\nld dist_ll(line l, line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(line l, line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(line s, point p) {\n\tpoint r = proj(s, p);\n\treturn isis_sp(s, r) ? std::abs(r - p) : min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nld dist_ss(line s, line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nld convex_diameter(const vector<point>& ps) {\n\tconst int n = ps.size();\n\tld d = 0;\n\tfor (int i = 0, j = 0; i < n; ++i) {\n\t\tconst point& p = ps[i];\n\t\tfor (int k = (j + 1) % n; abs(ps[k] - p) > abs(ps[j] - p); k = (j + 1) % n) {\n\t\t\tj = k;\n\t\t}\n\t\td = max(d, abs(ps[j] - p));\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tcout << fixed << setprecision(8);\n\tint n;\n\tcin >> n;\n\tvector<point> ps;\n\tfor (int i = 0; i < n; i++) {\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tcout << convex_diameter(ps) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nint main(){\n\tint n;\n\tdouble max = 0;\n\tdouble dist;\n\tstd::vector< double > x, y;\n\t\n\tstd::cin >> n;\n\tx.resize(n);\n\ty.resize(n);\n\t\n\tfor(int i=0;i<n;++i){\n\t\tstd::cin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tdist = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\t\n\t\t\tif(dist > max) max = dist;\n\t\t}\n\t}\n\t\n\tstd::cout << std::setprecision(15) << sqrt(max) << std::endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\n//END CUT HERE\n\n//Projection\nsigned AOJ_CGL1A(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<project(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=jp\n*/\n\n//Reflect\nsigned AOJ_CGL1B(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<reflect(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=jp\n*/\n\n//CCW\nsigned AOJ_CGL1C(){\n  Point p0,p1;\n  cin>>p0>>p1;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p2;\n    cin>>p2;\n    int t=ccw(p0,p1,p2);\n    if(t==CCW_COUNTER_CLOCKWISE) cout<<\"COUNTER_CLOCKWISE\"<<endl;\n    if(t==CCW_CLOCKWISE) cout<<\"CLOCKWISE\"<<endl;\n    if(t==CCW_ONLINE_BACK) cout<<\"ONLINE_BACK\"<<endl;\n    if(t==CCW_ONLINE_FRONT) cout<<\"ONLINE_FRONT\"<<endl;\n    if(t==CCW_ON_SEGMENT) cout<<\"ON_SEGMENT\"<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\n*/\n\n//Parallel / Orthogonal\nsigned AOJ_CGL2A(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    if(isParallel(Line(p0,p1),Line(p2,p3))) cout<<2<<endl;\n    else if(isOrthogonal(Line(p0,p1),Line(p2,p3))) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=jp\n*/\n\n//intersectSS\nsigned AOJ_CGL2B(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<(intersectSS(Segment(p0,p1),Segment(p2,p3)))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n*/\n\n//cross point\nsigned AOJ_CGL2C(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<getCrossPointSS(Segment(p0,p1),Segment(p2,p3))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=jp\n*/\n\n//distanceSS\nsigned AOJ_CGL2D(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    printf(\"%.12f\\n\",getDistanceSS(Segment(p0,p1),Segment(p2,p3)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=jp\n*/\n\n//area of Polygon\nsigned AOJ_CGL3A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.1f\\n\",area(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=jp\n*/\n\n\n//isConvex\nsigned AOJ_CGL3B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<isConvex(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=jp\n*/\n\n\n\n//contains\nsigned AOJ_CGL3C(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  int q;\n  cin>>q;\n  while(q--){\n    Point r;\n    cin>>r;\n    cout<<contains(p,r)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n*/\n\n\n//convex hull\nsigned AOJ_CGL4A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=convex_hull(p);\n  cout<<q.size()<<endl;\n  for(Point v:q) cout<<v.x<<\" \"<<v.y<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\n*/\n\n//diameter of Polygon\nsigned AOJ_CGL4B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=jp\n*/\n\n//Common Tangent\nsigned AOJ_CGL7G(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto ls=tangent(c1,c2);\n  Polygon ps;\n  for(auto l:ls) ps.emplace_back(getCrossPointCL(c1,l)[0]);\n  sort(ps.begin(),ps.end());\n  for(auto p:ps) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\nsigned main(){\n  //AOJ_CGL1A();\n  //AOJ_CGL1B();\n  //AOJ_CGL1C();\n\n  //AOJ_CGL2A();\n  //AOJ_CGL2B();\n  //AOJ_CGL2C();\n  //AOJ_CGL2D();\n  \n  //AOJ_CGL3A();\n  //AOJ_CGL3B();\n  //AOJ_CGL3C();\n  \n  //AOJ_CGL4A();\n  AOJ_CGL4B();\n  //AOJ_CGL4C();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n\ndouble area(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto n = vs.size();\n    auto vx1 = std::get<0>(vs[(p+1) % n]) - std::get<0>(vs[p]);\n    auto vy1 = std::get<1>(vs[(p+1) % n]) - std::get<1>(vs[p]);\n\n    auto vx2 = std::get<0>(vs[(q+1) % n]) - std::get<0>(vs[q]);\n    auto vy2 = std::get<1>(vs[(q+1) % n]) - std::get<1>(vs[q]);\n\n    return std::abs( vx1 * vy2 - vx2 * vy1 );\n}\n\ndouble len2(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto dx = std::get<0>(vs[p]) - std::get<0>(vs[q]);\n    auto dy = std::get<1>(vs[p]) - std::get<1>(vs[q]);\n\n    return dx*dx + dy*dy;\n}\n\nint main() {\n    int64_t n;\n\n    std::cin >> n;\n    \n    std::vector<std::tuple<double, double> > vs(n);\n\n    int64_t p = 0, q = 0;\n    for (int64_t i = 0; i < n; ++i) {\n        std::cin >> std::get<0>(vs[i]) >> std::get<1>(vs[i]);\n\n        if (std::get<0>(vs[i]) < std::get<0>(vs[p])) {\n            p = i;\n        }\n        if (std::get<0>(vs[i]) > std::get<0>(vs[q])) {\n            q = i;\n        }\n    }\n\n    double ans = len2(vs, p, q);\n    for (int64_t i = 0; i < 3*n; ++i) {\n        if (area(vs, p, q) >= 0) {\n            p = (p+1) % n;\n        } else {\n            q = (q+1) % n;\n        }\n        ans = std::max(ans, len2(vs, p, q));\n    }\n\n    std::cout << std::fixed << std::setprecision(12) << std::sqrt(ans) << std::endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n\ndouble area(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto n = vs.size();\n    auto vx1 = std::get<0>(vs[(p+1) % n]) - std::get<0>(vs[p]);\n    auto vy1 = std::get<1>(vs[(p+1) % n]) - std::get<1>(vs[p]);\n\n    auto vx2 = std::get<0>(vs[(q+1) % n]) - std::get<0>(vs[q]);\n    auto vy2 = std::get<1>(vs[(q+1) % n]) - std::get<1>(vs[q]);\n\n    return vx1 * vy2 - vx2 * vy1;\n}\n\ndouble len2(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto dx = std::get<0>(vs[p]) - std::get<0>(vs[q]);\n    auto dy = std::get<1>(vs[p]) - std::get<1>(vs[q]);\n\n    return dx*dx + dy*dy;\n}\n\nint main() {\n    int64_t n;\n\n    std::cin >> n;\n    \n    std::vector<std::tuple<double, double> > vs(n);\n\n    int64_t p = 0, q = 0;\n    for (int64_t i = 0; i < n; ++i) {\n        std::cin >> std::get<0>(vs[i]) >> std::get<1>(vs[i]);\n\n        if (std::get<0>(vs[i]) < std::get<0>(vs[p])) {\n            p = i;\n        }\n        if (std::get<0>(vs[i]) > std::get<0>(vs[q])) {\n            q = i;\n        }\n    }\n\n    double ans = len2(vs, p, q);\n    for (int64_t i = 0; i < 2*n; ++i) {\n        if (area(vs, p, q) > 0) {\n            q = (q+1) % n;\n        } else {\n            p = (p+1) % n;\n        }\n        ans = std::max(ans, len2(vs, p, q));\n    }\n\n    std::cout << std::fixed << std::setprecision(12) << std::sqrt(ans) << std::endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\nusing Real = double;\nReal EPS = 1e-8;\n\nusing Point = complex<Real>;\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        if (a.real() == b.real()) return a.imag() < b.imag();\n        return a.real() < b.real();\n    }\n}\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\n\nReal radian_to_degree(Real r) {\n    return r * 180.0 / M_PI;\n}\n\nReal degree_to_radian(Real d) {\n    return d * M_PI / 180.0;\n}\n\nPoint rotate(const Point &p, Real theta) {\n    return p * polar(1., theta);\n}\n\nReal cross(const Point& a, const Point& b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n         B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\n\nbool parallel(const Line& l1, const Line& l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nbool orthogonal(const Line& l1, const Line& l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nconst int COUNTER_CLOCKWISE = 1,\n          CLOCKWISE = -1,\n          ONLINE_BACK = 2,\n          ONLINE_FRONT = -2,\n          ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersected(const Line& l, const Point& p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersected(const Segment& s, const Point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersected(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersected(const Segment& s1, const Segment& s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n           ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\n\nReal distance(const Segment& s, const Point& p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\nReal distance(const Segment& s1, const Segment& s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({ distance(s1, s2.a), distance(s1, s2.b),\n                 distance(s2, s1.a), distance(s2, s1.b) });\n}\n\nPoint crosspoint(const Line& l1, const Line& l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n         B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\n\nusing Polygon = vector<Point>;\nPolygon convex_cut(const Polygon& U, const Line& l) {\n    Polygon ret;\n    for (int i = 0; i < U.size(); i++) {\n        Point now = U[i], nxt = U[(i + 1) % U.size()];\n        if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n        if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n            ret.push_back(crosspoint(Line{ now, nxt }, l));\n        }\n    }\n    return ret;\n}\n\nPolygon voronoi_cell(const Point& c, const vector<Point>& ps, Polygon outer) {\n    for (const Point& p : ps) {\n        Point m = (p + c) / 2.0;\n        outer = convex_cut(outer,\n                    Line{ m, m + rotate(p - c, M_PI / 2) });\n    }\n    return outer;\n}\n\nReal area(const Polygon& U) {\n    Real area = 0;\n    for (int i = 0; i < U.size(); ++i) {\n        area += cross(U[i], U[(i + 1) % U.size()]);\n    }\n    return area / 2.0;\n}\n\nbool is_convex(const Polygon &U) {\n    int n = U.size();\n    for (int i = 0; i < n; i++) {\n        if (ccw(U[i], U[(i + 1) % n], U[(i + 2) % n]) == -1) return false;\n    }\n    return true;\n}\n\nconst int OUT = 0,\n          ON = 1,\n          IN = 2;\nint contains(const Polygon &U, const Point &p) {\n    int in = 0;\n    for(int i = 0; i < U.size(); i++) {\n        Point a = U[i] - p, b = U[(i + 1) % U.size()] - p;\n        if (cross(a, b) == 0 and dot(a, b) <= 0) return ON;\n        if (a.imag() > b.imag()) swap(a, b);\n        if (a.imag() <= 0 and 0 < b.imag() and cross(a, b) < 0) in ^= 1;\n    }\n    return in ? IN : OUT;\n}\n\nvector<Point> convex_hull(vector<Point>& p) {\n    int n = p.size(), k = 0;\n    if (n <= 2) return p;\n    sort(p.begin(), p.end());\n    vector<Point> ch(n * 2);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n        while (k >= 2 and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) < -EPS) --k;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = p[i--]) {\n        while (k >= t and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) < -EPS) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nReal convex_diameter(const Polygon &U) {\n    int n = U.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; i++) {\n        if (U[i].imag() > U[is].imag()) is = i;\n        if (U[i].imag() < U[js].imag()) js = i;\n    }\n    Real maxnorm = norm(U[is] - U[js]);\n\n    int i = is, j = js;\n    do {\n        if (cross(U[(i+1) % n] - U[i], U[(j+1) % n] - U[j]) >= 0) {\n            j = (j+1) % n;\n        } else {\n            i = (i+1) % n;\n        }\n        if (norm(U[i] - U[j]) > maxnorm) {\n            maxnorm = norm(U[i] - U[j]);\n        }\n    } while (i != is or j != js);\n    return sqrt(maxnorm);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    vector<Point> p(n);\n    for (int i = 0; i < n; ++i) {\n        double x, y; cin >> x >> y;\n        p[i] = { x, y };\n    }\n\n    cout << convex_diameter(p) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem \nusing namespace placeholders;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nauto& operator >> (istream& is,P& p){ R x,y; is >> x >> y,p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline P vec(L l){return l.t-l.s;}\nauto sdot = bind(sgn,bind(dot,_1,_2,_3));\nauto sdet = bind(sgn,bind(det,_1,_2,_3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/vec(l)); return (1-u)*l.s+u*l.t;}\n// Polygon\n#define at(a,i) (a[(i + a.size()) % a.size()])\n\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tint n=pol.size(),i=0,j=0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\tR res=0.0;\n\n\tauto cmp_x=[](P a,P b)->bool{\n\t\tint sr = sgn(real(a-b)), si = sgn(imag(a-b));\n\t\treturn sr ? sr < 0 :si < 0;\n\t};\n\t\n\trep(k,n){\n\t\tif(!cmp_x(pol[i],pol[k]))i=k;\n\t\tif(cmp_x(pol[j],pol[k]))j=k;\n\t}\n\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tres = max(res,abs(pol[i]-pol[j]));\n\t\tif(sdet(0,vec(L{at(pol,i),at(pol,i+1)}),vec(L{at(pol,j),at(pol,j+1)}))<0)\n\t\t\ti=(i+1)%n;\n\t\telse \n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = 1e9;\nconst long long LINF = 1e18;\nconst long long MOD = 1e9 + 7;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point{\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator + (Point p){ return Point(x + p.x, y + p.y); }\n    Point operator - (Point p){ return Point(x - p.x, y - p.y); }\n    Point operator * (double a){ return Point(a * x, a * y); }\n    Point operator / (double a){ return Point(x / a, y / a); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x * x + y * y; }\n\n    bool operator < (const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\nbool compX(Point a, Point b){\n    return a.x != b.x ? a.x < b.x : a.y < b.y;\n}\n\nbool compY(Point a, Point b){\n    return a.y != b.y ? a.y < b.y : a.x < b.x;\n}\n\ntypedef Point Vector;\n\ndouble norm(Vector a){ return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a){ return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b){ return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b){ return a.x * b.y - a.y * b.x; }\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\n//直交判定\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//平行判定\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n//線分 s に点 p から垂線を引いた交点を求める\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\n//線分 s を対称軸として点 p と線対称の位置にある点を求める\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\nbool intersect(Segment s1, Segment s2);\n\ndouble getDistanceSS(Segment s1, Segment s2){\n    if(intersect(s1, s2)) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point, Point> getCrossPointCL(Circle c, Line l){\n    //assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p){ return atan2(p.y, p.x); }\nVector polar(double a, double r){ return Point(cos(r) * a, sin(r) * a); }\n\npair<Point, Point> getCrossPointCC(Circle c1, Circle c2){\n    //assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n// IN : 2, ON : 1, OUT : 0\nint contains(Polygon g, Point p) {\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i++){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x ? 2 : 0);\n}\n\nPolygon convexHull(Polygon g){\n    int n = g.size();\n    sort(g.begin(), g.end(), compX);\n    int k = 0;\n    Polygon res(n * 2);\n    for(int i = 0; i < n; i++){\n        while(k > 1 && cross(res[k - 1] - res[k - 2], g[i] - res[k - 1]) < 0) k--;\n        res[k++] = g[i];\n    }\n    for(int i = n - 2, t = k; i >= 0; i--){\n        while(k > t && cross(res[k - 1] - res[k - 2], g[i] - res[k - 1]) < 0) k--;\n        res[k++] = g[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\ndouble convexDiameter(Polygon g){\n    int n = g.size();\n    if(n == 2) return abs(g[0] - g[1]);\n    int i = 0, j = 0;\n    for(int k = 0; k < n; k++){\n        if(g[i] < g[k]) i = k;\n        if(!(g[j] < g[k])) j = k;\n    }\n    double res = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        res = max(res, abs(g[i] - g[j]));\n        if(cross(g[(i + 1) % n] - g[i], g[(j + 1) % n] - g[j]) < 0.0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return res;\n}\n\ndouble getClosestPair(Polygon & a, int l = 0, int r = -1){\n    if(r < 0){\n        r = a.size();\n        sort(a.begin(), a.end(), compX);\n    }\n    if(r - l <= 1) return abs(a[0] - a[1]);\n    int mid = (l + r) / 2;\n    double x = a[mid].x;\n    double d = min(getClosestPair(a, l, mid), getClosestPair(a, mid, r));\n    inplace_merge(a.begin() + l, a.begin() + mid, a.begin() + r, compY);\n    \n    Polygon b;\n    for(int i = l; i < r; i++){\n        if(abs(a[i].x - x) >= d) continue;\n        for(int j = 0; j < b.size(); j++){\n            double dy = a[i].y - next(b.rbegin(), j) -> y;\n            if(dy >= d) break;\n            d = min(d, abs(a[i] - *next(b.rbegin(), j)));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nsigned main(){\n    int n;\n    cin >> n;\n    Polygon p;\n    double x,y;\n    rep(i,n){\n        cin >> x >> y;\n        p.emplace_back(x, y); \n    }\n    printf(\"%.10lf\\n\", convexDiameter(p));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 0.0;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tif (N >= 20000) { res = 1e-5; goto E; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = max(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\n\nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end());\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=convex_hull(s);\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  //cout<<i<<\" \"<<j<<endl;\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    //cout<<i<<\" \"<<j<<endl;\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+i)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*******************************\n*\tGeometry                   *\n*\tdouble !!!                 *\n*\tTODO: test everything!!!   *\n*******************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double INF = 1e17;\nconst double EPS = 1e-10;\nconst double PI = 2.0 * asin(1);\n\ninline int sign(const double x) {\n\tif (abs(x) < EPS) {\n\t\treturn 0;\n\t}\n\tif (x < 0.0) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\ninline bool is_in(double a, double b, double x) {\n\tif (a > b) {\n\t\tswap(a, b);\n\t}\n\treturn (a - EPS <= x && x <= b + EPS);\n}\n\nstruct point {\n\tdouble x, y;\n\tpoint() {}\n\tpoint(double _x, double _y) : x(_x), y(_y) {}\n};\n\nbool operator < (const point &P, const point &Q) {\n\tif (abs(P.y - Q.y) > EPS) {\n\t\treturn P.y < Q.y;\n\t}\n\tif (abs(P.x - Q.x) > EPS) {\n\t\treturn P.x < Q.x;\n\t}\n\treturn false;\n}\n\nstruct compare_x {\n\tbool operator () (const point &P, const point &Q) {\n\t\tif (abs(P.x - Q.x) > EPS) {\n\t\t\treturn P.x < Q.x;\n\t\t}\n\t\treturn P.y < Q.y;\n\t}\n};\n\nstruct compare_y {\n\tbool operator () (const point &P, const point &Q) {\n\t\tif (abs(P.y - Q.y) > EPS) {\n\t\t\treturn P.y < Q.y;\n\t\t}\n\t\treturn P.x < Q.x;\n\t}\n};\n\ninline void read(point &P) {\n\tcin >> P.x >> P.y;\n}\n\npoint operator + (const point &P, const point &Q) {\n\treturn point(P.x + Q.x, P.y + Q.y);\n}\n\npoint operator - (const point &P, const point &Q) {\n\treturn point(P.x - Q.x, P.y - Q.y);\n}\n\npoint operator * (const point &P, const double k) {\n\treturn point(P.x * k, P.y * k);\n}\n\npoint operator / (const point &P, const double k) {\n\tassert(fabs(k) > EPS);\n\treturn point(P.x / k, P.y / k);\n}\n\ninline int half_plane(const point &P) {\n\tif (abs(P.y) > EPS) {\n\t\tif (P.y > 0) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn -1;\n\t}\n\tif (P.x > 0) {\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\ninline double dot(const point &P, const point &Q) {\n\treturn P.x * Q.x + P.y * Q.y;\n}\n\ninline double cross(const point &P, const point &Q) {\n\treturn P.x * Q.y - P.y * Q.x;\n}\n\ninline double norm2(const point &P) {\n\treturn dot(P, P);\n}\n\ninline double norm(const point &P) {\n\treturn sqrt(dot(P, P));\n}\n\ninline double dist2(const point &P, const point &Q) {\n\treturn norm2(P - Q);\n}\n\n/// returns distance between P and Q\ninline double dist(const point &P, const point &Q) {\n\treturn sqrt(dot(P - Q, P - Q));\n}\n\n/// returns true if P belongs in segment AB\ninline bool is_in(point A, point B, point P) {\n\tif (abs(cross(B - A, P - A)) > EPS) {\n\t\treturn false;\n\t}\n\treturn (is_in(A.x, B.x, P.x) && is_in(A.y, B.y, P.y));\n}\n\n/// projects point P in line P1, P2\ninline point project(const point &P, const point &P1, const point &P2) {\n\treturn P1 + (P2 - P1) * (dot(P2 - P1, P - P1) / norm2(P2 - P1));\n}\n\ninline point reflect(const point &P, const point &P1, const point &P2) {\n\treturn project(P, P1, P2) * 2.0 - P;\n}\n\n/// distance from point P to the straigh line that passes through A and B\ninline double point_to_line(const point &P, const point &A, const point &B) {\n\t// return abs(cross(B - A, C - A) / norm(B - A));\n\treturn dist(P, project(P, A, B));\n}\n\n/// distance from point P to segment AB\ninline double point_to_segment(const point &P, const point &A, const point &B) {\n\tpoint PP = project(P, A, B);\n\tif (is_in(A, B, PP)) {\n\t\treturn dist(P, PP);\n\t}\n\treturn min(dist(P, A), dist(P, B));\n}\n\n/// line to line intersection\n/// A, B difine the first line\n/// C, D define the second line\ninline point intersect(const point &A, const point &B, const point &C, const point &D) {\n\treturn A + (B - A) * (cross(C - A, C - D) / cross(B - A, C - D));\n}\n\n/// distance between segmente AB and CD\ninline double segment_to_segment(const point &A, const point &B, const point &C, const point &D) {\n\tpoint I = intersect(A, B, C, D);\n\tif (is_in(A, B, I) && is_in(C, D, I)) {\n\t\treturn 0.0;\n\t}\n\treturn min(min(point_to_segment(A, C, D), point_to_segment(B, C, D)),\n\t\t\t\t\t\t min(point_to_segment(C, A, B), point_to_segment(D, A, B)));\n}\n\n/// rotate point P angle radians\ninline point rotate_point(const point &P, double angle) {\n\treturn point(P.x * cos(angle) - P.y * sin(angle), P.y * cos(angle) + P.x * sin(angle));\n}\n\n/// center of a circle that passes through points A, B, C\n/// not tested\ninline point circle_center(const point &A, const point &B, const point &C) {\n\tassert(abs(cross(B - A, C - A)) > EPS); // no colinear\n\treturn intersect((A + B) / 2.0, (A + B) / 2.0 + rotate_point(B - A, PI),\n\t\t\t\t\t\t\t\t\t (B + C) / 2.0, (B + C) / 2.0 + rotate_point(C - B, PI));\n}\n\n/// tangent to a circle with center in C and radius r, passes through P --> tested OK\ninline pair <point, point> point_circle_tangent(const point &P, const point &C, const double r) {\n\tdouble d = dist(P, C);\n\tdouble l = sqrt(d * d - r * r);\n\tdouble a = asin(r / d);\n\treturn make_pair(P + rotate_point((C - P) * (l / d), a), P + rotate_point((C - P) * (l / d), -a));\n}\n\n/// common tangents to a pair of circles\ninline vector <pair <point, point> > common_tangents(point C1, double r1, point C2, double r2) {\n\tdouble d = dist(C1, C2);\n\tassert(!(d <= EPS && abs(r1 - r2) <= EPS));\n\tif (r2 > r1) {\n\t\tswap(C1, C2);\n\t\tswap(r1, r2);\n\t}\n\tif (r1 > d + r2 + EPS) {\n\t\treturn vector <pair <point, point> >();\n\t}\n\tif (abs(r1 - d - r1) <= EPS) {\n\t\treturn vector <pair <point, point > > (1, make_pair(C1 + (C2 - C1) * (r1 / d), C1 + (C2 - C1) * (r1 / d)));\n\t}\n\tvector <pair <point, point> > answer;\n\t{\n\t\tpair <point, point> t = point_circle_tangent(C2, C1, r1 - r2);\n\t\tpoint V_first = rotate_point((t.first - C2) * (r2 / dist(t.first, C2)), 0.5 * PI);\n\t\tpoint V_second = rotate_point((t.second - C2) * (r2 / dist(t.second, C2)), -0.5 * PI);\n\t\tanswer.push_back(make_pair(C2 + V_first, t.first + V_first));\n\t\tanswer.push_back(make_pair(C2 + V_second, t.second + V_second));\n\t}\n\tif (abs(d - r1 - r2) <= EPS) {\n\t\tanswer.push_back(make_pair(C1 + (C2 - C1) * (r1 / d), C1 + (C2 - C1) * (r1 / d)));\n\t} else if (d > r1 + r2 + EPS) {\n\t\tpair <point, point> t = point_circle_tangent(C2, C1, r1 + r2);\n\t\tpoint V_first = rotate_point((t.first - C2) * (r2 / dist(t.first, C2)), -0.5 * PI);\n\t\tpoint V_second = rotate_point((t.second - C2) * (r2 / dist(t.second, C2)), 0.5 * PI);\n\t\tanswer.push_back(make_pair(C2 + V_first, t.first + V_first));\n\t\tanswer.push_back(make_pair(C2 + V_second, t.second + V_second));\n\t}\n\treturn answer;\n}\n\n/// line to circle intersection\ninline vector <point> line_circle_intersect(const point &A, const point &B, const point &C, const double r) {\n\tpoint PC = project(C, A, B);\n\tdouble d = dist(C, PC);\n\tif (d > r + EPS) {\n\t\treturn vector <point> ();\n\t}\n\tif (abs(d - r) <= EPS) {\n\t\treturn vector <point> (1, PC);\n\t}\n\tdouble l = sqrt(r * r - d * d);\n\tvector <point> res(2);\n\tdouble dAB = dist(A, B);\n\tres[0] = PC + (B - A) * (l / dAB);\n\tres[1] = PC - (B - A) * (l / dAB);\n\treturn res;\n}\n\nvector <point> circle_circle_intersect(point C1, double r1, point C2, double r2) {\n\tif (r2 > r1) {\n\t\tswap(r2, r1);\n\t\tswap(C2, C1);\n\t}\n\tdouble d = dist(C1, C2);\n\tassert(!(d <= EPS && abs(r1 - r2) <= EPS));\n\tif (d > r1 + r2 + EPS || r1 > d + r2 + EPS) {\n\t\treturn vector <point> ();\n\t}\n\tif (abs(d - (r1 + r2)) <= EPS || abs(r1 - (d + r2)) <= EPS) {\n\t\treturn vector <point> (1, C1 + (C2 - C1) * (r1 / d));\n\t}\n\tdouble a = (r1 * r1 - r2 * r2 + d * d) / (2.0 * d);\n\tdouble b = sqrt(r1 * r1 - a * a);\n\tpoint P = C1 + (C2 - C1) * (a / d);\n\tpoint V = rotate_point(C2 - C1, 0.5 * PI) * (b / d);\n\tvector <point> answer(2);\n\tanswer[0] = P + V;\n\tanswer[1] = P - V;\n\treturn answer;\n}\n\n/// signed polygon area O(n)\ninline double signed_area(const vector <point> &polygon) {\n\tdouble res = 0.0;\n\tint n = polygon.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i + 1 == n) ? 0 : i + 1;\n\t\tres += cross(polygon[i], polygon[j]);\n\t}\n\treturn 0.5 * res;\n}\n\n/// polygon area O(n)\ninline double abs_area(const vector <point> &polygon) {\n\treturn abs(signed_area(polygon));\n}\n\n/// closest pair of points O(n * log(n))\ninline double closest_pair_of_points(vector <point> pts) {\n\tsort(pts.begin(), pts.end(), compare_x());\n\tmultiset <point> candidates;\n\tint n = pts.size();\n\tdouble res = INF;\n\tfor (int i = 0, last = 0; i < n; i++) {\n\t\twhile (last < i && pts[i].x - pts[last].x >= res + EPS) {\n\t\t\tcandidates.erase(candidates.find(pts[last]));\n\t\t\tlast++;\n\t\t}\n\t\tset <point> :: iterator lo = candidates.lower_bound(point(-INF, pts[i].y - res - EPS));\n\t\tset <point> :: iterator hi = candidates.upper_bound(point(INF, pts[i].y + res + EPS));\n\t\twhile (lo != hi) {\n\t\t\tres = min(res, dist(pts[i], *lo));\n\t\t\tlo++;\n\t\t}\n\t\tcandidates.insert(pts[i]);\n\t}\n\treturn res;\n}\n\n/// Rotating calipers to find the further pair of points in a convex polygon O(n)\n/// TODO: test (where ???, aizu ???)\ndouble convex_diameter(vector <point> &polygon) {\n\tint n = polygon.size();\n\tint p0 = 0;\n\tint p1 = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\t// < compare y first then x\n\t\tif (polygon[i] < polygon[p0]) {\n\t\t\tp0 = i;\n\t\t}\n\t\tif (polygon[p1] < polygon[i]) {\n\t\t\tp1 = i;\n\t\t}\n\t}\n\t// cerr << \"start:\\n\";\n\t// cerr << p0 << \" \" << polygon[p0].x << \" \" << polygon[p0].y << \"\\n\";\n\t// cerr << p1 << \" \" << polygon[p1].x << \" \" << polygon[p1].y << \"\\n\\n\";\n\tdouble res = dist(polygon[p0], polygon[p1]);\n\tint c0 = p0;\n\tint c1 = p1;\n\tdo {\n\t\tpoint v1 = polygon[p0 + 1 == n ? 0 : p0 + 1] - polygon[p0];\n\t\tpoint v2 = polygon[p1] - polygon[p1 + 1 == n ? 0 : p1 + 1];\n\t\tint s = sign(cross(v1, v2));\n\t\tif (s == 1) {\n\t\t\tp0 = p0 + 1 == n ? 0 : p0 + 1;\n\t\t} else if (s == -1) {\n\t\t\tp1 = p1 + 1 == n ? 0 : p1 + 1;\n\t\t} else {\n\t\t\tp0 = p0 + 1 == n ? 0 : p0 + 1;\n\t\t\tp1 = p1 + 1 == n ? 0 : p1 + 1;\n\t\t}\n\t\tres = max(res, dist(polygon[p0], polygon[p1]));\n\t\t// cerr << p0 << \" \" << polygon[p0].x << \" \" << polygon[p0].y << \"\\n\";\n        // cerr << p1 << \" \" << polygon[p1].x << \" \" << polygon[p1].y << \"\\n\\n\";\n\t} while (c0 != p0 || c1 != p1);\n\treturn res;\n}\n\n/// Rotating calipers to find the width of a convex polygon O(n)\n/// TODO: test (where ???, aizu ???)\ndouble convex_width(const vector <point> &polygon) {\n\tint n = polygon.size();\n\tint p0 = 0;\n\tint p1 = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\t// < compare y first then x\n\t\tif (polygon[i] < polygon[p0]) {\n\t\t\tp0 = i;\n\t\t}\n\t\tif (polygon[p1] < polygon[i]) {\n\t\t\tp1 = i;\n\t\t}\n\t}\n\tdouble res = polygon[p1].y - polygon[p0].y;\n\tint c0 = p0;\n\tint c1 = p1;\n\tdo {\n\t\tpoint v1 = polygon[p0 + 1 == n ? 0 : p0 + 1] - polygon[p0];\n\t\tpoint v2 = polygon[p1] - polygon[p1 + 1 == n ? 0 : p1 + 1];\n\t\tint s = sign(cross(v1, v2));\n\t\tif (s == 1) {\n\t\t\tres = min(res, point_to_line(polygon[p1], polygon[p0], polygon[p0 + 1 == n ? 0 : p0 + 1]));\n\t\t\tp0 = p0 + 1 == n ? 0 : p0 + 1;\n\t\t} else if (s == -1) {\n\t\t\tres = min(res, point_to_line(polygon[p0], polygon[p1], polygon[p1 + 1 == n ? 0 : p1 + 1]));\n\t\t\tp1 = p1 + 1 == n ? 0 : p1 + 1;\n\t\t} else {\n\t\t\tres = min(res, point_to_line(polygon[p1], polygon[p0], polygon[p0 + 1 == n ? 0 : p0 + 1]));\n\t\t\tp0 = p0 + 1 == n ? 0 : p0 + 1;\n\t\t\tp1 = p1 + 1 == n ? 0 : p1 + 1;\n\t\t}\n\t\tres = max(res, dist(polygon[p0], polygon[p1]));\n\t} while (c0 != p0 || c1 != p1);\n\treturn res;\n}\n\ninline vector <point> minkowsky_sum(vector <point> &VA, const vector <point> &VB) {\n\t/// TODO\n}\n\ninline vector <point> normalize_polygon(vector <point> pts) {\n\t/// TODO\n}\n\ninline vector <point> convex_hull(vector <point> pts) {\n\t/// TODO\n}\n\ninline bool point_inside_polygon(const point &P, const vector <point> &polygon) {\n\t/// TODO\n}\n\ninline bool point_inside_convex(const point &P, const vector <point> &polygon) {\n\t/// TODO\n}\n\nstruct line {\n\tdouble a, b, c;\n};\n\ninline vector <point> half_planes_intersection(const vector <line> &half_planes) {\n\t/// TODO\n}\n\n/// randomized algorithm -> expected time O(n)\ninline pair <point, double> min_enclosing_circle(vector <point> pts) {\n\t///\n}\n\ninline point centroid(const vector <point> &polygon) {\n\t/// TODO\n}\n\n/// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\n/// test ok\nvoid testPolygonArea() {\n    int n;\n    cin >> n;\n    vector <point> polygon(n);\n    for (int i = 0; i < n; i++) {\n        read(polygon[i]);\n    }\n    cout.precision(1);\n    cout << fixed << abs_area(polygon) << \"\\n\";\n}\n\n/// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\n/// test ok\nvoid test_line_circle_intersect() {\n\tpoint C;\n\tdouble r;\n\tcin >> C.x >> C.y >> r;\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tpoint A, B;\n\t\tcin >> A.x >> A.y >> B.x >> B.y;\n\t\tvector <point> answer = line_circle_intersect(A, B, C, r);\n\t\tassert(answer.size() != 0);\n\t\tif (answer.size() == 1) {\n\t\t\tanswer.push_back(answer.back());\n\t\t}\n\t\tif (answer[1].x < answer[0].x || (answer[1].x == answer[0].x && answer[1].y < answer[0].y)) {\n\t\t\tswap(answer[0], answer[1]);\n\t\t}\n\t\tcout << fixed << answer[0].x << \" \" << fixed << answer[0].y << \" \" << fixed << answer[1].x << \" \" << fixed << answer[1].y << \"\\n\";\n\t}\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\n// test ok\nvoid test_circle_circle_intersect() {\n\tpoint C1, C2;\n\tdouble r1, r2;\n\tcin >> C1.x >> C1.y >> r1 >> C2.x >> C2.y >> r2;\n\tvector <point> answer = circle_circle_intersect(C1, r1, C2, r2);\n\tassert(answer.size() != 0);\n\tif (answer.size() == 1) {\n\t\tanswer.push_back(answer.back());\n\t}\n\tif (answer[1].x < answer[0].x || (answer[1].x == answer[0].x && answer[1].y < answer[0].y)) {\n\t\tswap(answer[0], answer[1]);\n\t}\n\tcout << fixed << answer[0].x << \" \" << fixed << answer[0].y << \" \" << fixed << answer[1].x << \" \" << fixed << answer[1].y << \"\\n\";\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\n// test ???\nvoid test_common_tangents() {\n\t// TODO\n\tpoint C1, C2;\n\tdouble r1, r2;\n\tcin >> C1.x >> C1.y >> r1 >> C2.x >> C2.y >> r2;\n\tvector <pair <point, point> > ct = common_tangents(C1, r1, C2, r2);\n\tvector <point> answer;\n\tfor (int i = 0; i < ct.size(); i++) {\n\t\tanswer.push_back(ct[i].first);\n\t}\n\tsort(answer.begin(), answer.end(), compare_x());\n\tfor (int i = 0; i < answer.size(); i++) {\n\t\tcout << fixed << answer[i].x << \" \" << fixed << answer[i].y << \"\\n\";\n\t}\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\n// test ???\nvoid test_convex_diamenter() {\n\tint n;\n\tcin >> n;\n\tvector <point> polygon(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> polygon[i].x >> polygon[i].y;\n\t}\n\tdouble answer = convex_diameter(polygon);\n\tcout << fixed << answer << \"\\n\";\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n\n\t// testPolygonArea();\n\t// test_line_circle_intersect();\n\t// test_circle_circle_intersect();\n\t// test_common_tangents();\n\ttest_convex_diamenter();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nint main() {\n    int64_t n;\n    std::cin >> n;\n\n    std::vector<double> x(n);\n    std::vector<double> y(n);\n    for (auto i = 0; i < n; ++i) {\n        std::cin >> x[i] >> y[i];\n    }\n\n    double ans = 0.0;\n\n    for (auto i = 0; i < n; ++i) {\n        for (auto j = i+1; j < n; ++j) {\n            ans = std::max(ans, std::pow(x[i]-x[j],2) + std::pow(y[i]-y[j],2));\n        }\n    }\n\n    std::cout << std::fixed << std::setprecision(12) << std::sqrt(ans) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  double maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n\n\nint main(void){\n    int n;\n    double x,y;\n    cin>>n;\n    VP ch(n);\n    rep(i,n){\n        cin>>x>>y;\n        ch[i] = {x,y};\n    }\n\n    pair<int,int> pp = convexDiameter(ch);\n    printf(\"%.9f\\n\",abs(ch[pp.first]-ch[pp.second]));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\n//?????¢?????¢???\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\nint main(){\n  int n,c=0;\n  Polygon p,a;\n  Point s;\n  double d=0;\n  cin>>n;\n  while(n--){\n    cin>>s.x>>s.y;\n    p.push_back(s);\n  }\n  r(i,p.size())\n  for(int j=i+1;j<p.size();j++)\n    d=max(d,getDistancePP(p[i],p[j]));\n  printf(\"%.11f\\n\",d);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\n//?????¢?????¢???\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\nint main(){\n  int n,c=0;\n  Polygon p,a;\n  Point s;\n  double d[1000000];\n  cin>>n;\n  while(n--){\n    cin>>s.x>>s.y;\n    p.push_back(s);\n  }\n  a=andrewScan(p);\n  r(i,a.size())\n  for(int j=i+1;j<a.size();j++)\n    d[c++]=getDistancePP(a[i],a[j]);\n  sort(d,d+c);\n  printf(\"%.11f\\n\",d[c-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tint si=i,sj=j;\n\tR res=0.0;\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0){\n\t\t\ti=(i+1)%n;\n\t\t}else{\n\t\t\tj=(j+1)%n;\n\t\t}\n\t}\n\tassert(0==1);\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vec;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\ndouble eps=1e-8;\ndouble PI=acos(-1);\n\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\n\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\n\ndouble calcArea(vec &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++)res+=cross(t[i],t[(i+1==n?0:i+1)]);\n  return abs(res/2.0);\n}\n\ndouble Arg(P a,P b,P c){\n  b-=a,c-=a;\n  return arg(c*conj(b));\n}\n\nint inPolygon(vec &t,P p){\n  int n=t.size();\n  double sum=0;  \n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p) == 0 )return 1;// on\n    sum+= Arg(p,a,b);\n  }\n  if( abs(sum) < eps )return 0;//out\n  else  return 2;//in\n}\n\ntypedef pair<double,P> Pair;\n\nvec andrewScan(vec &t){\n  int N=t.size(),C=0;\n  vec R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vec res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n\nvec ConvexHull2(vec t){\n  sort(t.begin(),t.end());\n  vec u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vec l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvec ConvexHull(vec t){\n  vector<Pair> u;\n  vec R;\n  int N=t.size(),K=0,C=0;\n  for(int i=1;i<N;i++)if(t[i]<t[K])K=i;\n  for(int i=0;i<N;i++)u.push_back(Pair(arg(t[i]-t[K]),t[i]));\n  R.push_back(t[K]),C++;\n  sort(u.begin(),u.end());\n  for(int i=0;i<N;i++){\n    P p=u[i].second;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==0)continue;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==2)continue;\n    while(2<=C&&ccw(R[C-2],R[C-1],p)!=1)R.pop_back(),C--;\n    R.push_back(p),C++;    \n  }\n  return R;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vec t;\n  double x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  vec ans=ConvexHull2(t);\n  int m=ans.size();\n  double maxm=1e9;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      maxm=max(maxm,abs(ans[i]-ans[j]));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t\t\t\t\t\t\t\t\t\t\t //return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t}\n\tbool operator==(const Point &p)const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\t//Vector????????¢\n\tPoint rotate(double rad) { return Point(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nusing Vector = Point;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point(1, 1)) :p1(p1), p2(p2) {}\n\tVector vec() { return p2 - p1; }\n};\nusing Line = Segment;\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool in_field(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance_LP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance_SP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance_LP(s, p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance_SP(s1, s2.p1), get_distance_SP(s1, s2.p2)),\n\t\tmin(get_distance_SP(s2, s1.p1), get_distance_SP(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance_LP(l, c.c) <= c.r; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point getCrossPointLL(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif ((P[i] - P[j]).norm() > maxd) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\nsigned main() {\n\tcout << fixed << setprecision(8);\n\tint n; cin >> n;\n\tPolygon P(n);\n\trep(i, 0, n) cin >> P[i];\n\tcout << diameter(P) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nint ans = 0;\n  const double EPS = 1e-8;\n  const double INF = 1e12;\n  typedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\n  namespace std {\n    bool operator < (const P& a, const P& b) {//x????????????\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool sorty(const P& a, const P& b) {//y????????????\n      return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n  }\n  double cross(const P& a, const P& b) {//??????\n    return imag(conj(a)*b);\n  }\n  double dot(const P& a, const P& b) {//??????\n    return real(conj(a)*b);\n  }\n\n  struct L : public vector<P> {//??´???\n    L(){};\n    L(const P &a, const P &b) {\n      push_back(a); push_back(b);\n    }\n  };\n\n  typedef vector<P> G;\n\n  struct C {//???\n    P p; double r;\n    C(){};\n    C(const P &p, double r) : p(p), r(r) { }\n  };\n  int ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0; // a--c--b on line\n  }\n  int linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n    P a = ab[1] - ab[0],b = cd[1] - cd[0];\n    if(abs(cross(a,b)) < EPS){ // Parallel\n      return 2;\n    }\n    else if(abs(dot(a,b)) < EPS){ //Orthogonal\n      return 1;\n    }\n    return 0;\n  }\n  // L:line,S:segment,P:point\n  bool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n      abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n  }\n  bool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n      cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n  }\n  bool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n  }\n  bool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n      ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n  }\n  bool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n  }\n  // L & P intersection\n  P projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n  }\n  // L????????????P???????°????\n  P reflection(const L &l, const P &p) {\n    return p + 2.0 * (projection(l, p) - p);\n  }\n  double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n  }\n  double distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n  }\n  double distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n  }\n  double distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n  }\n  double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n  }\n  double distancePP(const P &p,const P &q){\n    return abs(p - q) ;\n  }\n  P crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n  }\n  P verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n    if(a.real() == b.real()){\n      return {1.0,0};\n    }\n    if(a.imag() == b.imag()){\n      return {0,1.0};\n    }\n    P p = a - b;\n    P res = {-p.imag(),p.real()};\n    return res / abs(p);\n  }\n  pair<P,P> crosspointCircle(const C &a,const C &b){\n    P m = (a.p+b.p)/2.0;\n    P vv = verticalvector(a.p,b.p);\n    double u = sqrt( a.r * a.r - norm(a.p - b.p) / 4.0);\n    P A = m + u * vv,B = m - u * vv;\n    return mp(A,B);\n  }\n  double calc_triangle(P a,P b,P c){\n    P ba = (b - a);\n    P ca = (c - a);\n    return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n  }\n  double calc_area(const G &g){\n    double res = 0;\n    rep(i,g.size()-2){\n      res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n    }\n    return res;\n  }\n  bool is_convex(const G &g){\n    if(g.size() == 3) return true;\n    rep(i,g.size()){\n      if(ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != 1 && ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != -2){\n        return false;\n      }\n    }\n    return true;\n  }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\ndouble convex_diameter(vector<P> &ps){\n  const int n = ps.size();\n  int is = 0,js = 0;\n  REP(i,1,n){\n    if(imag(ps[i]) > imag(ps[is])) is = i;\n    if(imag(ps[i]) < imag(ps[js])) js = i;\n  }\n  double d = norm(ps[is]-ps[js]);\n  int im,jm,i,j;\n  i = im = is;\n  j = jm = js;\n  do {\n    if(cross(diff(ps,i),diff(ps,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if(norm(ps[i]-ps[j]) > d){\n      d = norm(ps[i]-ps[j]);\n      im = i,jm = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(d);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  double x,y;\n  cin >> n;\n  vector<P> v(n);\n  rep(i,n){\n    cin >> x >> y;\n    v[i] = P{x,y};\n  }\n  fcout(10) << convex_diameter(v) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nconst ll maxn=1e4+200;\nconst int inf=0x3f3f3f3f;\nconst double EPS=1e-10;\n//typedef pair<int,int> PA;\ndouble add(double a,double b){//考虑误差的加法运算\n    if(abs(a+b)<EPS*(abs(a)+abs(b))) return  0;\n    return a+b;\n}\nint sgn(double x){\n    if(abs(x)<EPS)  return 0;\n    if(x<0) return -1;\n    else return 1;\n}\nclass Point{\npublic:\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){\n    }\n    Point operator+ (Point p){\n        return Point(add(x,p.x),add(y,p.y));\n    }\n    Point operator -(Point p){\n        return Point(add(x,-p.x),add(y,-p.y));\n    }\n    Point operator *(double d){\n        return Point(x*d,y*d);\n    }\n    double operator *(Point p){\n        return add(x*p.x,y*p.y);//外积\n    }\n    double operator ^(Point p){//内积\n        return add(x*p.y,-y*p.x);\n    }\n    double det(Point p){\n     return add(x*p.y,-y*p.x);\n    }\n    double len(){\n        return sqrt(add(x*x,y*y));\n    }\n};\ndouble dist(Point p1,Point p2)//距离的平方\n{\n    return add((p1.x-p2.x)*(p1.x-p2.x),(p1.y-p2.y)*(p1.y-p2.y));\n}\nclass Line{\npublic:\n    Point s,e;\n    Line(){}\n    Line(Point s,Point e):s(s),e(e){}\n};\nbool onSge(Line l,Point q){\n    return ((l.s-q)^(l.e-q))==0&&((l.s-q)*(l.e-q))<=0;\n}\nPoint operator *(double d,Point p){\n    return Point(p.x*d,p.y*d);\n}\nPoint getProject(Point p1,Point p2,Point q){//q 在直线p1,p2上的投影坐标\n    double d1=1.0/(p2-p1).len();\n    Point ans=(q-p1)*(p2-p1)*(p2-p1)*d1*d1;\n    return ans+p1;\n}\nPoint getReflect(Point p1,Point p2,Point q){//q 关于直线p1 p2的 反射坐标\n    return 2.0*getProject(p1,p2,q)-q;\n}\ndouble getDisPP(Point a,Point b){//两点之间距离\n    return (b-a).len();\n}\ndouble getDisPL(Line l,Point p){//点到直线距离\n    Point x=getProject(l.s,l.e,p);\n    return (p-x).len();\n}\ndouble getDisPS(Line l,Point p){//点到线段最短距离\n    Point x=getProject(l.s,l.e,p);\n    if(onSge(l,x))\n        return (x-p).len();\n    else\n        return min((p-l.s).len(),(p-l.e).len());\n\n}\ndouble getDisSS(Line la,Line lb){//保证两线段不相交 isInterSS==false\n    return min(min(getDisPS(la,lb.s),getDisPS(la,lb.e)),\n\t\t\tmin(getDisPS(lb,la.s),getDisPS(lb,la.e)));\n}\n\nint getDirPPP(Point p,Point p1,Point p2){\n    return sgn((p1-p)^(p2-p));//1代表 p2在p1的逆时针方向  0共线 ，-1是p2在p1的顺时针方向\n}\n/*\n1 逆时针\n2 顺时针\n3 在p->p1的后面\n4 在p->p1的前面\n5 在p->p1上\n*/\nint getStatePP(Point p,Point p1,Point p2){//返回 p2 关于p 在p1的什么方向\n        int a=sgn((p1-p)^(p2-p));\n        int b=sgn((p1-p)*(p2-p));\n        if(a>0){//\n            return 1;\n        }\n        else if(a<0){\n            return 2;\n        }\n        else if(b<0){\n            return 3;\n        }\n        else if(b>0&&sgn((p1-p)*(p2-p1))>0){\n            return 4;\n        }\n        else{\n           return 5;\n        }\n        return 0;\n}\nbool isInterSS(Line la,Line lb){//线段是否想交\n    int d1=getDirPPP(lb.s,lb.e,la.s);\n    int d2=getDirPPP(lb.s,lb.e,la.e);\n    int d3=getDirPPP(la.s,la.e,lb.s);\n    int d4=getDirPPP(la.s,la.e,lb.e);\n    if(d1*d2<0&&d3*d4<0)\n        return true;\n    else if(d1==0&&onSge(lb,la.s))\n        return true;\n    else if(d2==0&&onSge(lb,la.e))\n        return true;\n    else if(d3==0&&onSge(la,lb.s))\n        return true;\n    else if(d4==0&&onSge(la,lb.e))\n        return true;\n    else\n        return false;\n\n}\nint getStateLL(Line la,Line lb){//两个直线 垂直，相交或者平行\n    if(sgn((la.e-la.s)^(lb.e-lb.s))==0){\n        return 2;//平行\n    }//两向量平行 内积为0\n    else if(sgn((la.e-la.s)*(lb.e-lb.s))==0){\n        return 1;//垂直\n    }\n    else return 0;\n}\ntypedef Point P;\nPoint getInterLL(Point p1,Point p2,Point q1, Point q2){//得到直线交点\n    return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\ndouble getAreaPolygon(Point p[],int n){//下标从0开始  计算多边形面积\n    double res=0.0;\n    for(int i=0;i<n;++i)\n        res+=(p[i]^p[(i+1)%n])/2;\n    return res;\n}\nPoint PA[110000];\n\nbool _cmp(Point p1,Point p2)//相对于pa[0]的\n{\n    double tmp=(p1-PA[0])^(p2-PA[0]);\n    if(sgn(tmp)>0) return true;\n    else if(sgn(tmp)==0 &&sgn((PA[0]-p1).len()-(PA[0]-p2).len())<=0)//如果奇角相同 距离近的排在前面\n        return true;\n    else return false;\n}\nvoid sortPolarAngle(Point PA[],int n)//对数组进行极角排序  点将逆时针排序 WA\n{\n    Point p0=PA[0];\n    int k=0;\n    /* 找到最下边的一个点 靠左的一个点*/\n    for(int i=1;i<n;++i){\n        if((p0.y>PA[i].y)||(p0.y==PA[i].y&&p0.x>PA[i].x))\n        {\n            p0=PA[i];\n            k=i;\n        }\n    }\n    swap(PA[k],PA[0]);\n    sort(PA+1,PA+n,_cmp);\n    return ;\n}\n//判断是否为凸包\n//允许共线边\n//点可以是顺时针给出也可以是逆时针给出\n//点的编号为0~n-1\nbool isConvex(Point poly[],int n)\n{\n    bool s[3];\n    memset(s,0,sizeof(s));\n    for(int i=0;i<n;++i){\n        s[sgn( (poly[(i+1)%n]-poly[i]) ^ (poly[(i+2)%n]-poly[i]) )+1]=true;\n        if(s[0]&&s[2]) return false;//拐的方向不同\n    }\n    return true;\n}\n\n//Gragham扫描法求凸包\n//输入: 多边形和顶点个数\n//得到的凸包的点最少，逆时针给出，第一个点是最靠左其次下的点。\nbool cmp_x(const Point &p,const Point &q)\n{\n    if(p.x!=q.x) return p.x<q.x;\n    return p.y<q.y;\n}\nvector<Point> convex_hull(Point *ps,int n)\n{\n    sort(ps,ps+n,cmp_x);\n    int k=0; //凸包的顶点数\n    vector<Point> qs(n*2); //构造中的凸包\n    //构造凸包下侧\n    for(int i=0; i<n;++i){\n        while(k>1 && (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1]) <= 0) k--;\n        qs[k++] = ps[i];\n    }\n    //构造凸包的上侧\n    for(int i=n-2,t=k;i>=0;--i){\n        while(k>t && (qs[k-1] - qs[k-2] ).det(ps[i]-qs[k-1]) <= 0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n//旋转卡壳求平面最远点对\n//输入: 多边形和顶点个数\n//输出: 最远点对距离的平方\n//\ndouble rotaing_calipers(P* ps,int pn)\n{\n    vector<P> qs(ps,ps+pn);\n    int n=qs.size();\n    if(n==2){\n        return  dist(qs[0], qs[1]);\n    }\n    int j=1;\n    double ans=0.0;\n    for(int i=0;i<n;++i)\n    {\n        while( (qs[(i+1)%n]-qs[i]).det( qs[(j+1)%n] - qs[j]) >=0 ) j=(j+1)%n;\n        ans=max(ans, max(dist(qs[j],qs[i]), dist(qs[j],qs[(i+1)%n] )) );\n    }\n    return ans;\n}\n//Point PA[110000];\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;++i){\n        scanf(\"%lf%lf\",&PA[i].x,&PA[i].y);\n    }\n    double res=rotaing_calipers(PA,n);\n    printf(\"%.10f\\n\",sqrt(res) );\n    return 0;\n}\n\n\n/*\n\n//这样得到的是在凸包上最多的点,第一个点是最下左的点,且逆时针给出.\nbool cmp_y(const Point &p,const Point &q)\n{\n    //找到y坐标最小,相等时x坐标最小排在前面\n    if(p.y!=q.y) return p.y<q.y;\n    return p.x<q.x;\n}\n\nvector<Point> convex_hull(Point *ps,int n)\n{\n    sort(ps,ps+n,cmp_y);\n    int k=0; //凸包的顶点数\n    vector<Point> qs(n*2); //构造中的凸包\n    //构造凸包下侧\n    for(int i=0; i<n;++i){\n        while(k > 1 && sgn( (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1]) ) < 0) k--;\n        qs[k++] = ps[i];\n    }\n    //构造凸包的上侧\n    for(int i=n-2,t=k;i>=0;--i){\n        while(k > t && sgn( (qs[k-1] - qs[k-2] ).det(ps[i]-qs[k-1]) ) < 0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vec;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\ndouble eps=1e-8;\ndouble PI=acos(-1);\n\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\n\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\n\ndouble calcArea(vec &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++)res+=cross(t[i],t[(i+1==n?0:i+1)]);\n  return abs(res/2.0);\n}\n\ndouble Arg(P a,P b,P c){\n  b-=a,c-=a;\n  return arg(c*conj(b));\n}\n\nint inPolygon(vec &t,P p){\n  int n=t.size();\n  double sum=0;  \n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p) == 0 )return 1;// on\n    sum+= Arg(p,a,b);\n  }\n  if( abs(sum) < eps )return 0;//out\n  else  return 2;//in\n}\n\ntypedef pair<double,P> Pair;\nvec ConvexHull(vec t){\n  vector<Pair> u;\n  vec R;\n  int N=t.size(),K=0,C=0;\n  for(int i=1;i<N;i++)if(t[i]<t[K])K=i;\n  for(int i=0;i<N;i++)u.push_back(Pair(arg(t[i]-t[K]),t[i]));\n  R.push_back(t[K]),C++;\n  sort(u.begin(),u.end());\n  for(int i=0;i<N;i++){\n    P p=u[i].second;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==0)continue;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==2)continue;\n    while(2<=C&&ccw(R[C-2],R[C-1],p)!=1)R.pop_back(),C--;\n    R.push_back(p),C++;    \n  }\n  return R;\n}\n\nvec cutConvex(vec &t,P a,P b){\n  int N=t.size();\n  vec res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C+D==0&&max(C,D)==1)res.push_back(intersect(a,b,c,d));\n  }\n  return res;\n}\n\ndouble maxDist(vec &t){\n  vec u=t;//ConvexHull(t);\n  int N=u.size(),K=0;\n  double res=0;\n  for(int i=0;i<N;i++){\n    while(abs(u[i]-u[K])<abs(u[i]-u[(K+1)%N]))K=(K+1)%N;\n    res=max(res,abs(u[i]-u[K]));\n  }\n  return res;\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  vec t;\n  double x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  printf(\"%.8f\\n\",maxDist(t));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<25;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\ndouble add_double(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point p){\n\t\treturn point{add_double(x,p.x),add_double(y,p.y)};\n\t}\n\tpoint operator-(point p){\n\t\treturn point{add_double(x,-p.x),add_double(y,-p.y)};\n\t}\n\tpoint operator*(double p){\n\t\treturn point{x*p,y*p};\n\t}\n\tpoint operator/(double p){\n\t\tif(!p) return point{0,0}; \n\t\treturn point{x/p,y/p};\n\t}\n\tbool operator==(point p){\n\t\treturn fabs(add_double(x,-p.x))<eps&&fabs(add_double(y,-p.y))<eps;\n\t}\n\tbool operator<(point p){\n\t\tif(fabs(x-p.x)>eps) return x<p.x;\n\t\treturn y<p.y;\n\t}\n};\n \ntypedef pair<point,point> pp;\ntypedef vector<point> VP;\nconst point O{0,0};\n \nclass Geom{\n\tpublic:\n\tdouble Length(point x,point y){\n\t\tpoint z=y-x;\n\t\treturn sqrt(z.x*z.x+z.y*z.y);\n\t}\n\tdouble IP(point p,point q){\n\t\treturn p.x*q.x+p.y*q.y;\n\t}\n\tdouble CP(point p,point q){\n\t\treturn p.x*q.y-q.x*p.y;\n\t}\n\tdouble Diameter_Polygon(VP p){\n\t\tdouble ans=0;\n\t\tfor(VP::iterator i=p.begin();i!=p.end();i++){\n\t\t\tfor(VP::iterator j=p.begin();j!=i;j++){\n\t\t\t\tans=max(ans,Length(*i,*j));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Point_in(point& p){\n\t\tcin>>p.x>>p.y;\n\t}\n\tvoid Point_out(point p){\n\t\tcout<<p.x<<' '<<p.y<<endl;\n\t}\n};\n\nint N;\nVP p,ans;\n\nint main(){\n\tcout<<syosu(10);\n\tGeom geo;\n\tcin>>N;\n\tp=VP(N);\n\tfor(VP::iterator i=p.begin();i!=p.end();i++) geo.Point_in(*i);\n\tcout<<geo.Diameter_Polygon(p)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nint main(){\n\tint n;\n\tdouble max = 0;\n\tdouble dist;\n\tdouble temp_dist;\n\tstd::vector< double > x, y;\n\t\n\tstd::cin >> n;\n\tx.resize(n);\n\ty.resize(n);\n\t\n\tfor(int i=0;i<n;++i){\n\t\tstd::cin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i=0;i<n;++i){\n\t\ttemp_dist = 0;\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tdist = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\t\n\t\t\tif(dist > max) max = dist;\n\t\t\tif(temp_dist - dist > 0) break;\n\t\t\ttemp_dist = dist;\n\t\t}\n\t}\n\t\n\tstd::cout << std::setprecision(15) << sqrt(max) << std::endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int i = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int j = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int maxi, maxj;\n    LD maxd = 0;\n    for(; i < 2*n; i++){\n        if(maxd < norm(cpol[i]-cpol[j])){\n            maxd = norm(cpol[i] - cpol[j]);\n            maxi = i;\n            maxj = j;\n        }\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) <= 0) j = (j+1) % n;\n        else i = (i+1) % n; \n    }\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n    pair<int, int> ans = ConvexPolygonDiameter(p);\n    printf(\"%.9Lf\\n\", DistPP(p[ans.first], p[ans.second]));\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "import java.lang.Math.sqrt\n\ndata class Point(val x:Double, val y:Double)\nfun Point.distanceFrom(origin:Point):Double = sqrt((this.x - origin.x) * (this.x - origin.x) + (this.y - origin.y) * (this.y - origin.y))\nfun main(args:Array<String>):Unit {\n    val n = readLine()!!.toInt()\n    val points = Array(n){readLine()!!.split(' ').map(String::toDouble).let{Point(it.first(), it.last())}}\n    var posB = 0\n    var maxLength:Double = .0\n    for (posA in 0 until n){\n        while (points[posA].distanceFrom(points[posB]) <= points[posA].distanceFrom(points[(posB + 1) % n])) {\n            posB = (posB + 1) % n\n        }\n        if (maxLength < points[posA].distanceFrom(points[posB])) maxLength = points[posA].distanceFrom(points[posB])\n    }\n    println(maxLength)\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nint ans = 0;\n  const double EPS = 1e-8;\n  const double INF = 1e12;\n  typedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\n  namespace std {\n    bool operator < (const P& a, const P& b) {//x????????????\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool sorty(const P& a, const P& b) {//y????????????\n      return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n  }\n  double cross(const P& a, const P& b) {//??????\n    return imag(conj(a)*b);\n  }\n  double dot(const P& a, const P& b) {//??????\n    return real(conj(a)*b);\n  }\n\n  struct L : public vector<P> {//??´???\n    L(){};\n    L(const P &a, const P &b) {\n      push_back(a); push_back(b);\n    }\n  };\n\n  typedef vector<P> G;\n\n  struct C {//???\n    P p; double r;\n    C(){};\n    C(const P &p, double r) : p(p), r(r) { }\n  };\n  int ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0; // a--c--b on line\n  }\n  int linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n    P a = ab[1] - ab[0],b = cd[1] - cd[0];\n    if(abs(cross(a,b)) < EPS){ // Parallel\n      return 2;\n    }\n    else if(abs(dot(a,b)) < EPS){ //Orthogonal\n      return 1;\n    }\n    return 0;\n  }\n  // L:line,S:segment,P:point\n  bool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n      abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n  }\n  bool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n      cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n  }\n  bool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n  }\n  bool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n      ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n  }\n  bool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n  }\n  // L & P intersection\n  P projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n  }\n  // L????????????P???????°????\n  P reflection(const L &l, const P &p) {\n    return p + 2.0 * (projection(l, p) - p);\n  }\n  double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n  }\n  double distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n  }\n  double distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n  }\n  double distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n  }\n  double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n  }\n  double distancePP(const P &p,const P &q){\n    return abs(p - q) ;\n  }\n  P crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n  }\n  P verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n    if(a.real() == b.real()){\n      return {1.0,0};\n    }\n    if(a.imag() == b.imag()){\n      return {0,1.0};\n    }\n    P p = a - b;\n    P res = {-p.imag(),p.real()};\n    return res / abs(p);\n  }\n  pair<P,P> crosspointCircle(const C &a,const C &b){\n    P m = (a.p+b.p)/2.0;\n    P vv = verticalvector(a.p,b.p);\n    double u = sqrt( a.r * a.r - norm(a.p - b.p) / 4.0);\n    P A = m + u * vv,B = m - u * vv;\n    return mp(A,B);\n  }\n  double calc_triangle(P a,P b,P c){\n    P ba = (b - a);\n    P ca = (c - a);\n    return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n  }\n  double calc_area(const G &g){\n    double res = 0;\n    rep(i,g.size()-2){\n      res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n    }\n    return res;\n  }\n  bool is_convex(const G &g){\n    if(g.size() == 3) return true;\n    rep(i,g.size()){\n      if(ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != 1 && ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != -2){\n        return false;\n      }\n    }\n    return true;\n  }\n  int convex_point(const G &g,const P &p){\n    P q = p-P(-INF,imag(p));\n    double x = real(p),y = imag(p);\n    L l1(p,q);\n    ll cn = 0;\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      L l2 = L(a,b);\n      int k = ccw(a,b,p);\n      if(k == 0){\n        return 1; // p on g\n      }\n    }\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      double y1 = imag(a),y2 = imag(b);\n      if(!(y1 == y && y2 == y) && ((y1 <= y && y < y2) || (y2 <= y && y < y1))){\n        L l2 = L(a,b);\n        P c = crosspoint(l1,l2);\n        if(x < real(c))\n          ++cn;\n      }\n    }\n    if(cn % 2) return 2; // p in g\n    return 0; // p out g\n  }\nvector<P> convex_hull(vector<P> &ps){\n  sort(all(ps));\n  int k = 0;\n  int n = ps.size();\n  vector<P> qs(ps.size() * 2);\n  rep(i,ps.size()){\n    while(k > 1 && cross((qs[k-1] -qs[k-2]),(ps[i] - qs[k-1])) < 0){\n      k--;\n    }\n    qs[k++] = ps[i];\n  }\n  for(int i = n-2,t = k; i >= 0; i--){\n    while(k>t && cross((qs[k-1] - qs[k-2]),(ps[i]-qs[k-1])) < 0){\n      k--;\n    }\n    qs[k++] = ps[i] ;\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  double x,y;\n  cin >> n;\n  vector<P> v(n);\n  rep(i,n){\n    cin >> x >> y;\n    v[i] = P{x,y};\n  }\n  auto hull = convex_hull(v);\n  int k = hull.size(),st = 0;\n  double res = 0;\n  rep(i,k){\n    REP(j,0,k/2+1){\n      res = max(res,distancePP(hull[i],hull[(j + k/2) % k]));\n    }\n  }\n  fcout(10) << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// convex_hull Verify AOJ CGL_4_A\nVP convex_hull(VP pol){\n\tint n=pol.size(),k=0;\n\tauto cmp_x=[](P a,P b)->bool{return sgn(real(a)-real(b))?sgn(real(a)-real(b))<0:sgn(imag(a)-imag(b)<0);};\n\tsort(begin(pol),end(pol),cmp_x);\n\tVP res(2*n);\n\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sdet(O,res[k-1]-res[k-2],pol[i]-res[k-1])>=1) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sdet(O,res[k-1]-res[k-2],pol[i]-res[k-1])>=1) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size(),i=0,j=0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\tR res=0.0;\n\tauto cmp_x=[](P a,P b)->bool{return sgn(real(a)-real(b))?sgn(real(a)-real(b))<0:sgn(imag(a)-imag(b)<0);};\n\t\n\trep(k,n){\n\t\tif(!cmp_x(pol[i],pol[k]))i=k;\n\t\tif(cmp_x(pol[j],pol[k]))j=k;\n\t}\n\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tchmax(res,abs(pol[i]-pol[j]));\n\t\tif(sdet(O,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse \n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define scanf nope\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntemplate <class T>\nstruct Point {\n\ttypedef Point P;\n\tT x, y;\n\texplicit Point(T x=0, T y=0) : x(x), y(y) {}\n\tbool operator<(P p) const { return x<p.x||(x==p.x && y<p.y);}\n\tbool operator==(P p) const { return x==p.x && y==p.y; }\n\tP operator+(P p) const { return P(x+p.x, y+p.y); }\n\tP operator-(P p) const { return P(x-p.x, y-p.y); }\n\tP operator*(T d) const { return P(x*d, y*d); }\n\tP operator/(T d) const { return P(x/d, y/d); }\n\tT dot(P p) const { return x*p.x + y*p.y; }\n\tT cross(P p) const { return x*p.y - y*p.x; }\n\tT cross(P p1, P p2) const { return (p1 - *this).cross(p2 - *this); }\n\tT dist2() const { return x*x + y*y; }\n\tdouble dist() const { return sqrt((double)dist2()); }\n\t// angle to x-axis in interval [-pi, pi]\n\tdouble angle() const { return atan2(y, x); }\n\tP unit() const { return *this/dist(); } // makes dist()=1\n\tP perp() const { return P(-y, x); } // rotates +90 degrees\n\tP normal() const { return perp().unit(); }\n\t// returns point rotated 'a' radians ccw around the origin\n\tP rotate(double a) const {\n\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n};\n\ntypedef Point<double> P;\npair<vi, vi> ulHull(const vector<P>& S) {\n    vector<int> Q(sz(S));\n    iota(all(Q), 0);\n    sort(all(Q), [&S](int a, int b){ return S[a] < S[b]; });\n    vi U, L;\n    trav(it, Q) {\n        while (sz(U) > 1 && S[U[sz(U)-2]].cross(S[it], S[U.back()]) <= 0) U.pop_back();\n        while (sz(L) > 1 && S[L[sz(L)-2]].cross(S[it], S[L.back()]) >= 0) L.pop_back();\n        U.push_back(it);\n        L.push_back(it);\n    }\n    return make_pair(U, L);\n}\n\nvi convexHull(const vector<P>& S) {\n    vi u, l;\n    tie(u, l) = ulHull(S);\n    if (sz(S) <= 1) return u;\n    u.pop_back();\n    reverse(all(u));\n    u.pop_back();\n    u.insert(u.end(), all(l));\n    if (sz(u) == 2 && S[u[0]] == S[u[1]]) u.pop_back();\n    return u;\n}\n\nvector<pii> antipodal(const vector<P>& S, const vi& U, const vi& L) {\n    vector<pii> A;\n    int i = 0;\n    int j = sz(L) - 1;\n    while (i < sz(U) - 1 || j > 0) {\n        A.emplace_back(U[i], L[j]);\n        if (i == sz(U) - 1) --j;\n        else if (j == 0) ++i;\n        else if ((S[U[i+1]].y - S[U[i]].y) * (S[L[j]].x - S[L[j-1]].x) >\n                 (S[U[i+1]].x - S[U[i]].x) * (S[L[j]].y - S[L[j-1]].y)) ++i;\n        else --j;\n    }\n    return A;\n}\n\npii polygonDiameter(const vector<P>& S) {\n    vi U, L;\n    tie(U, L) = ulHull(S);\n    pair<double, pii> ans;\n    trav(it, antipodal(S, U, L)) {\n        ans = max(ans, make_pair((S[it.first] - S[it.second]).dist2(), it));\n    }\n    return ans.second;\n}\n\nint main() {\n    int N;\n    cin >> N;\n        vector<P> P(N);\n        rep(i,0,N) cin >> P[i].x >> P[i].y;\n        pii ret = polygonDiameter(P);\n        cout << setprecision(10) << fixed << (P[ret.first] - P[ret.second]).dist() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int i = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int j = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int maxi, maxj;\n    LD maxd = 0;\n    for(; i < 2*n; i++){\n        if(maxd < norm(cpol[i]-cpol[j])){\n            maxd = norm(cpol[i] - cpol[j]);\n            maxi = i;\n            maxj = j;\n        }\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) <= 0) j = (j+1) % n;\n        else i = (i+1) % n; \n    }\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n \n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        scanf(\"%Lf %Lf\", &xp, &yp);\n        p.pb(Point(xp, yp));\n    }\n    pair<int, int> ans = ConvexPolygonDiameter(p);\n    printf(\"%.9Lf\\n\", DistPP(p[ans.first], p[ans.second]));\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n幾何\nhttps://gist.github.com/zeptometer/3719669\n複素数平面による幾何ライブラリ←もっと短くなる可能生アリ\nhttp://osrehun.hatenadiary.jp/entry/2016/12/31/145827\n\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing DD=double;\n\n\n#define EPS 1e-10\n#define eq(a,b) (abs( (a) - (b) )<EPS)\nconst DD PI=acosl(-1.0);\nconstexpr DD INF=1LL<<62;\n\n//点\nusing P=complex<DD>;\n//ベクトル\nusing V=P;\n//線分\nstruct Segment{\n    P a,b;\n    Segment()=default;\n    Segment(P a,P b) :a(a),b(b){}\n    Segment(DD ax,DD ay,DD bx,DD by):a(ax,ay),b(bx,by){}\n\n};\n//直線\nusing Line=Segment;\n//円\nstruct Circle{\n    P p;\n    DD r;\n    Circle()=default;\n    Circle(P p,DD r):p(p),r(r){}\n};\nusing Polygon=vector<P>;\n\n//++++++++++++++++基本計算++++++++++++++//\ninline DD torad(const DD &deg){return deg*PI/180;}\ninline DD todeg(const DD &rad){return rad*180/PI;}\n//内積\ninline DD dot(const V &a,const V &b){\n    return real(a*conj(b));\n}\n//外積\ninline DD cross(const V &a,const V &b){\n    return imag(conj(a)*b);\n}\n//ベクトルvを反時計回りにr度回転\ninline V rotate(const V &v,const DD r){\n    return v*V(cos(r),sin(r));\n}\ninline bool xy(const P &a,const P &b){\n    if(real(a)+EPS<=real(b)) return true;\n    if(eq(real(a),real(b)) && imag(a)+EPS<imag(b)) return true;\n    return false;\n}\ninline bool yx(const P &a,const P &b){\n    if(imag(a)+EPS<imag(b)) return true;\n    if(eq(imag(a),imag(b)) && real(a)+EPS<real(b)) return true;\n    return false;\n}\n\n//++++++++++++++++平行や直交+++++++++++++++//\ninline bool isOrthogonal(const V &a,const V &b){\n    return eq(dot(a,b),0.0);\n}\ninline bool isOrthogonal(const Segment &a,const Segment &b){\n    return eq(dot(a.a-a.b,b.a-b.b),0);\n}\ninline bool isParallel(const V &a,const V &b){\n    return eq(cross(a,b),0.0);\n}\ninline bool isParallel(const Segment &a,const Segment &b){\n    return eq(cross(a.a-a.b,b.a-b.b),0);\n}\n//線分a-bに対してcがどの位置にあるか\n//ccwの簡略版 反時計回り:1 時計回り:-1 直線上:0\ninline int ccw(const P &a,const P &b,const P &c){\n    DD cr=cross(b-a,c-a);\n    if(cr>EPS) return 1;\n    if(cr<-EPS) return -1;\n    return 0;\n}\n\n//線分a-bに対してcがどの位置にあるか\n//反時計回り:1　時計回り:-1 直線上(a,b,c:-2 a,c,b:0 c,a,b:2) \ninline int ccwH(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>EPS) return 1;\n    if(cross(b,c)<-EPS) return -1;\n    if(dot(b,c)<-EPS) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\n\n\n//+++++++++++++++射影+++++++++++++++++++++//\ninline P project(const P &p,const Segment &s){\n    V base=s.b-s.a;\n    DD r=dot(p-s.a,base)/norm(base);\n    return s.a+base*r;\n}\ninline P reflect(const P &p,const Segment &s){\n    return p+(project(p,s)-p)*2.0;\n}\n/*++++++++++点との距離++++++++++++++++++*/\n//点と直線の距離\ninline DD dis(const P &p,const Line &l){return abs(cross(l.b-l.a,p-l.a))/abs(l.b-l.a);}\n//点と線分の距離\ninline DD disPS(const P &p,const Segment &s){\n    if( dot(s.b-s.a,p-s.a)<0.0 ) return abs(p-s.a);\n    if( dot(s.a-s.b,p-s.b)<0.0 ) return abs(p-s.b);\n    return dis(p,s); //点と直線の距離\n}\n\n\n//+++++++++++++++線分と直線+++++++++++++++++//\n\n//線分a-b,c-dは交差するか?\ninline bool intersect(const P &a,const P &b,const P &c,const P &d){\n    return(ccwH(a,b,c)*ccwH(a,b,d)<=0 && ccwH(c,d,a)*ccwH(c,d,b)<=0);\n}\n//線分s,tは交差するか？\ninline bool intersect(const Segment &s,const Segment &t){\n    return intersect(s.a,s.b,t.a,t.b);\n}\n//線分と線分の交点\n//これをやる前にintersectで判定\ninline P crossPoint(const Segment &s,const Segment &t){\n    V base=t.b-t.a;\n    DD d1=abs(cross(base,s.a-t.a));\n    DD d2=abs(cross(base,s.b-t.a));\n    DD r=d1/(d1+d2);\n    return s.a+(s.b-s.a)*r;\n}\n//線分と線分の距離\ninline DD dis(const Segment &s,const Segment t){\n    if(intersect(s,t)) return 0.0;\n    return min(min(disPS(t.a,s),disPS(t.b,s)),min(disPS(s.a,t),disPS(s.b,t)) );\n}\n\n//+++++++++++円++++++++++++++++//\n\n//円cと直線lの交点\n//abs(l,c.p)<c.r+EPSが必要\npair<P,P> crossPoint(const Line &l,const Circle &c){\n    P pr=project(c.p,l);\n    V e=(l.b-l.a)/(abs(l.b-l.a));\n    DD base=sqrt(c.r*c.r-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n//線分sと円cの交点\nvector<P> crossPointSC(const Segment &s,const Circle &c){\n    vector<P> ret;\n    if(dis(c.p,s)>=c.r+EPS) return ret;\n    auto p=crossPoint(s,c);\n    if(dot(p.first-s.a,s.b-s.a)>0 && dot(p.first-s.b,s.a-s.b)>0) ret.push_back(p.first);\n    if(dot(p.second-s.a,s.b-s.a)>0 && dot(p.second-s.b,s.a-s.b)>0) ret.push_back(p.second);\n    if(xy(s.a,s.b)) sort(ret.begin(),ret.end(),xy);\n    else sort(ret.rbegin(),ret.rend(),xy);\n    return ret;\n}\n\n//共通接線の数\n//離れている:4 外接:3 交わる:2 内接:1 内包:0\ninline int intersect(const Circle &a,const Circle &b){\n    DD d=abs(a.p-b.p);\n    if(d>a.r+b.r+EPS) return 4;\n    if(eq(d,a.r+b.r)) return 3;\n    if(eq(d,abs(a.r-b.r))) return 1;\n    if(d<abs(a.r-b.r)-EPS) return 0;\n    return 2;\n}\n\n//円c1と円c2の交点\n//これを使う前に交点があるかどうかを判定する\nvector<P> crossPoint(const Circle &a,const Circle &b){\n    vector<P> ret;\n    if(abs(a.p-b.p)<a.r+b.r+EPS) return ret;\n    DD d=abs(a.p-b.p);\n    DD s=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n    DD t=arg(b.p-a.p);\n    if(eq(s,0)) ret.emplace_back(a.p+polar(a.r,t+s));\n    else ret.emplace_back(a.p+polar(a.r,t+s)),ret.emplace_back(a.p+polar(a.r,t-s));\n    return ret;\n}\n\n//pがcの外にあるかの判定が必要\nvector<P> TanLine(const P &p,const Circle &c){\n    vector<P> ret;\n    DD d=abs(p-c.p);\n    if(d<=c.r-EPS) return ret;\n    if(eq(d,c.r)){\n        ret.push_back(p);\n        return ret;\n    } \n    return crossPoint(c,Circle(p,sqrt(d*d-c.r*c.r)));\n}\n//https://ei1333.github.io/luzhiled/snippets/geometry/template.html\n//↑すごい。丸写し\n//円c1,c2の共通接線\n//接点をつないで線にしている(１個だけ追加するときに注意)\nvector<Line> TanLine(Circle a,Circle b){\n    vector<Line> ret;\n    if(a.r<b.r) swap(a,b);\n    DD g=abs(a.p-b.p);\n    if(eq(g,0)) return ret;\n    V u=(b.p-a.p)/g;\n    V v=rotate(u,PI*0.5);\n    for(DD s:{-1,1}){\n        DD h=(a.r+s*b.r)/g;\n        if(eq(1-h*h,0)){\n            ret.emplace_back(a.p+u*a.r,a.p+(u+v)*a.r);\n        }else if(1-h*h>0){\n            V uu=u*h,vv=v*sqrt(1-h*h);\n            ret.emplace_back(a.p+(uu+vv)*a.r,b.p-(uu+vv)*b.r*s);\n            ret.emplace_back(a.p+(uu-vv)*a.r,b.p-(uu-vv)*b.r*s);\n        }\n    }\n    return ret;\n}\n\n/*+++++++++++++++++++三角形+++++++++++++++++*/\n//外心\n//isParallel()を使って判定を忘れずに\nP circumcenter(const P &a,const P &b,const P &c){\n    P ab=(a+b)/2.0,bc=(b+c)/2.0;\n    Segment s(ab,ab+polar(1.0,arg(b-a)+PI*0.5));\n    Segment t(bc,bc+polar(1.0,arg(c-b)+PI*0.5));\n    return crossPoint(s,t);\n}\n\n/*+++++++++++++++++++多角形+++++++++++++++++++*/\n//IN:2 ON:1 OUT:0\n//点がどの位置にあるか\nint contains(const P &p,const Polygon &g){\n    int n=(int)g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        V a=g[i]-p,b=g[(i+1)%n]-p;\n        if(eq(cross(a,b),0) && dot(a,b)<EPS) return 1;\n        if(imag(a)>imag(b)) swap(a,b);\n        if(imag(a)<EPS && EPS<imag(b) && cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n//凸性判定\nbool isConvex(const Polygon &g){\n    int n=(int)g.size();\n    int flag=0;\n    int t;\n    for(int i=0;i<n;i++){\n        V a(g[(i+1)%n]-g[i]),b(g[(i+2)%n]-g[i]);\n        if(cross(a,b)>EPS) t=1;\n        else if(cross(a,b)<-EPS) t=-1;\n        else continue;\n        if(flag==-t) return false;\n        flag=t;\n    }\n    return true;\n}\n\n//凸包　アンドリューのアルゴリズム\n//https://github.com/drken1215/algorithm/blob/master/Geometry/All.cpp←螺旋本より早そう\n//j=1:返上の点を含まない　j=-1:含む\n//反時計回りの多角形を返す\n//sはソートされる\nPolygon ConvexHull(Polygon &s,const int j){\n    int sz=(int)s.size();\n    if(sz<3) return s;\n    sort(s.begin(),s.end(),yx);\n\n    int n=0;\n    Polygon res(2*sz);\n    for(int i=0;i<sz;i++){\n        while(n>=2 && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){\n            n--;\n        }\n        res[n]=s[i];\n        n++;\n    }\n    int t=n+1;\n    for(int i=sz-2;i>=0;i--){\n        while(n>=t && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){\n            n--;\n        }\n        res[n]=s[i];\n        n++;\n    }\n    res.resize(n-1);\n    return res;\n}\n\n//符号付き面積\n//反時計回りの図形なら正\n//https://imagingsolution.net/math/calc_n_point_area/\nDD Area(const Polygon &g){\n    DD ret=0.0;\n    int n=(int)g.size();\n    for(int i=0;i<n;i++){\n        ret+=cross(g[i],g[(i+1)%n]);\n    }\n    return ret/2.0L;\n}\n\n//反時計回り\n//理解が浅い←大体分かった（本当か？）\nDD Diameter(Polygon g){\n    g=ConvexHull(g,1);\n    int gz=g.size();\n    int m=0,M=0;\n    for(int i=1;i<gz;i++){\n        if(imag(g[i])<imag(g[m])) m=i;\n        if(imag(g[i])>imag(g[M])) M=i;\n    }\n    DD ret=0;\n    int sm=m,sM=M;\n    while(m!=sM || M!=sm){\n        ret=max(ret,norm(g[m]-g[M]));\n        if(cross(g[(m+1)%gz]-g[m],g[(M+1)%gz]-g[M])<0) m=(m+1)%gz;\n        else M=(M+1)%gz;\n    }\n    return sqrt(ret);\n}\n\n//凸多角形gをlで切断\n//l.p1-l.p2の左側\n//gは反時計回り→反時計回りで返す\n//時計回り→時計回り\nPolygon ConvexCut(const Polygon &g,const Line &l){\n    Polygon ret;\n    int gz=(int)g.size();\n    for(int i=0;i<gz;i++){\n        P now=g[i],next=g[(i+1)%gz];\n        if(ccw(l.a,l.b,now)>=0) ret.push_back(now);\n        if(ccw(l.a,l.b,now)*ccw(l.a,l.b,next)<0){\n            ret.push_back(crossPoint(Line(now,next),l));\n        }\n    }\n    return ret;\n}\n\ninline DD calc(const P &a,const P &b,const DD &r,const bool triangle){\n    if(triangle) return cross(a,b);\n    else return r*r*arg(b-a);\n}\n\nDD calcArea(const DD &r,const P &a,const P &b){\n    if(eq(abs(a-b),0)) return 0;\n    bool ina=abs(a)<r+EPS;\n    bool inb=abs(b)<r+EPS;\n    if(ina && inb) return cross(a,b);\n    auto cr=crossPointSC(Segment(a,b),Circle((0,0),r));\n    if(cr.empty()) return calc(a,b,r,false);\n    auto s=cr[0],t=cr.back();\n    return calc(s,t,r,true)+calc(a,s,r,ina)+calc(t,b,r,inb);\n}\n\n//円と多角形の共通部分の面積\n//http://drken1215.hatenablog.com/entry/2020/02/02/091000\nDD Area(const Circle &c,const Polygon &g){\n    DD ret=0.0;\n    int gz=g.size();\n    if(gz<3) return ret;\n    for(int i=0;i<gz;i++){\n        P a=g[i]-c.p,b=g[(i+1)%gz]-c.p;\n        ret+=calcArea(c.r,g[i]-c.p,g[(i+1)%gz]-c.p);\n    }\n    return ret/2.0;\n}\n\n//++++なんか凄いの+++++++++++++++\n\n//最近点対\nDD RecClosetPair(Polygon::iterator it,const int n){\n    if(n<=1) return INF;\n    int m=n/2;\n    DD x=real(it[m]);\n    DD d=min(RecClosetPair(it,m),RecClosetPair(it+m,n-m));\n    inplace_merge(it,it+m,it+n,yx);\n    Polygon v;\n    for(int i=0;i<n;i++){\n        if(abs(real(it[i])-x)>=d) continue;\n        for(int j=0;j<v.size();j++){\n            DD dy=imag(it[i])-imag(v[v.size()-1-j]);\n            if(dy>=d) break;\n            DD dx=real(it[i])-real(v[v.size()-1-j]);\n            d=min(d,sqrt(dx*dx+dy*dy));\n        }\n        v.push_back(it[i]);\n    }\n    return d;\n}\n\nDD ClosetPair(Polygon g){\n    sort(g.begin(),g.end(),xy);\n    return RecClosetPair(g.begin(),g.size());\n}\n\n\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(10);\n\n    int n;\n    cin>>n;\n    Polygon g;\n    for(int i=0;i<n;i++){\n        DD x,y;\n        cin>>x>>y;\n        g.emplace_back(x,y);\n    }\n    printf(\"%.10lf\\n\",Diameter(g));\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / acos(-1));\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * acos(-1) / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\nint main() {\n  int n;\n  cin >> n;\n\n  Polygon p(n);\n  for (auto &i : p) cin >> i;\n\n  cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <tuple>\n#include <bitset>\n#include <cstdint>\n#include <cassert>\n#include <random>\n#include <iterator>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\ntemplate<class T, class U> void init_n(vector<T>& v, size_t n, U x) \n{ v = vector<T>(n, x); }\ntemplate<class T> void init_n(vector<T>& v, size_t n) { init_n(v, n, T()); }\ntemplate<class T> void read_n(vector<T>& v, size_t n, size_t o = 0) \n{ v = vector<T>(n+o); for (size_t i=o; i<n+o; ++i) cin >> v[i]; }\ntemplate<class T> void read_n(T a[], size_t n, size_t o = 0)\n{ for (size_t i=o; i<n+o; ++i) cin >> a[i]; }\n// template<class T> T gabs(const T& x) { return max(x, -x); }\n// #define abs gabs\n\nint main() {\n    int n;\n    cin >> n;\n    vector<double> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n    double ans = 0;\n    for (int i = 0, j = 0; i < n; ++i) {\n        while (hypot(x[j] - x[i], y[j] - y[i]) \n            < hypot(x[(j + 1) % n] - x[i], y[(j + 1) % n] - y[i])) {\n            j = (j + 1) % n;\n        }\n        ans = max(ans, hypot(x[j] - x[i], y[j] - y[i]));\n    }\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1.0L);\nconst long double EPS = 1e-10;\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment,[-PI,PI]\n\n// dot(a,b) = |a||b|cos x\nlong double dot(CP a, CP b) { return (conj(a) * b).X; }\n// cross(a,b) : area of parallelogram\n// sign : right screw ? + : -\nlong double cross(CP a, CP b) { return (conj(a) * b).Y; }\nlong double corner(CP a, CP b) {\n  //[0,PI]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP projection(CP p, CP s, CP t) {\n  CP base = t - s;\n  long double r = dot(p - s, base) / norm(base);\n  return s + base * r;\n}\n\nCP reflection(CP p, CP s, CP t) {\n  CP tmp = (projection(p, s, t) - p);\n  tmp *= 2;\n  return p + tmp;\n}\n\nCP intersectionLL(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\nbool on_seg(CP a, CP b, CP p) {\n  // if not use end point, dot(a - p, b - p) < 0\n  return abs(cross(a - p, b - p)) <= 1e-10 &&\n         dot(a - p, b - p) <= 0;\n}\n\n// crossing lines? (a,b) and (c,d)\nbool iscross(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= 1e-10) {\n    return on_seg(a, b, c) || on_seg(a, b, d) ||\n           on_seg(c, d, a) || on_seg(c, d, b);\n  }\n  CP isp = intersectionLL(a, b, c, d);\n  return on_seg(a, b, isp) && on_seg(c, d, isp);\n}\n\nlong double distLP(CP a, CP b, CP p) {\n  return abs(cross(b - a, p - a) / abs(b - a));\n}\n\n// segmentver.\nlong double distSP(CP a, CP b, CP p) {\n  if(dot(b - a, p - a) < 0) return abs(p - a);\n  if(dot(a - b, p - b) < 0) return abs(p - b);\n  return distLP(a, b, p);\n}\n\n// segment and segment\nlong double distSS(CP a, CP b, CP c, CP d) {\n  long double res = 1e18;\n  if(iscross(a, b, c, d)) return 0.0L;\n  res = min(res, distSP(a, b, c));\n  res = min(res, distSP(a, b, d));\n  res = min(res, distSP(c, d, a));\n  res = min(res, distSP(c, d, b));\n  return res;\n}\n\nvector<CP> Convex_Hull(vector<CP> &ps) {\n  auto lmd = [&](const CP &l, const CP &r) {\n    if(l.X != r.X) return l.X < r.X;\n    return l.Y < r.Y;\n  };\n  vector<CP> qs;\n  int psize = ps.size();\n  sort(ps.begin(), ps.end(), lmd);\n  int k = 0;\n  qs.resize(psize * 2);\n  for(int i = 0; i < psize; ++i) {\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],\n                         ps[i] - qs[k - 1]) <= 0)\n      --k;\n    qs[k++] = ps[i];\n  }\n  for(int i = psize - 2, t = k; i >= 0; --i) {\n    while(k > t && cross(qs[k - 1] - qs[k - 2],\n                         ps[i] - qs[k - 1]) <= 0)\n      --k;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k - 1);\n  return qs;\n}\n\nlong double CH_Diameter(vector<CP> &newv) {\n  vector<CP> v = Convex_Hull(newv);\n  int n = v.size(), i = 0, j = 0;\n  if(n == 2) return abs(v[0] - v[1]);\n  for(int k = 0; k < n; ++k) {\n    if(v[k].X < v[i].X) i = k;\n    if(v[k].X > v[j].X) j = k;\n  }\n  long double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res, abs(v[i] - v[j]));\n    if(cross(v[(i + 1) % n] - v[i], v[(j + 1) % n] - v[j]) <\n       0)\n      (++i) %= n;\n    else\n      (++j) %= n;\n  }\n  return res;\n}\n\nstruct Circle {\n  CP o;\n  long double r;\n  Circle(long double _x = 0.0L, long double _y = 0.0L,\n         long double _r = 0.0L)\n      : o(CP(_x, _y)), r(_r) {}\n};\n\nvoid intersectionCL(Circle ci, CP s, CP t, CP &res1,\n                    CP &res2) {\n  res1 = res2 = projection(ci.o, s, t);\n  long double r = sqrtl(ci.r * ci.r - norm(res1 - ci.o));\n  t -= s;\n  t *= r / abs(t);\n  res1 += t;\n  res2 -= t;\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nlong double PolygonArea(vector<CP> &v) {\n  int n = v.size();\n  long double res = 0;\n  for(int i = 0; i < n; ++i)\n    res +=\n        (v[(i - 1 + n) % n].X - v[(i + 1) % n].X) * v[i].Y;\n  return res / 2.0L;\n}\n\nlong long n, q;\nvector<CP> v;\n\nint main() {\n  cout << fixed << setprecision(10);\n  cin >> n;\n  for(int i = 0; i < n; ++i) {\n    long double a, b;\n    cin >> a >> b;\n    v.emplace_back(a, b);\n  }\n  cout << CH_Diameter(v) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <string>\n#include <utility>\n#include <map>\n#include <queue>\n#include <list>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nconst int INF = 100000000;\nconst long long LINF = 1000000000000000000;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-6;\nusing pii = std::pair<int, int>;\nusing ll = long long;\nusing pLL = std::pair<ll, ll>;\n#define SORT(v) std::sort(v.begin(), v.end())\n#define RSORT(v) std::sort(v.rbegin(), v.rend())\nusing Point = complex<double>; //点\nusing Poly = vector<Point>;\n#define X real() //実部\n#define Y imag() //虚部\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n\n    bool cmp_y(const Point& a, const Point& b) {\n        return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n    }\n}\ndouble dot(Point a, Point b) { //内積\n    return (a.X * b.X + a.Y * b.Y);\n}\nusing Line = pair<Point, Point>; //直線\nPoint Projection(Line s, Point p) { //点から直線への射影\n    Point vase = s.second - s.first;\n    p -= s.first;\n    return s.first + dot(p, vase) / norm(vase) * vase;\n}\nPoint Reflection(Line s, Point p) { //直線に対して線対称な点\n    return p + (Projection(s, p) - p) * 2.0;\n}\ndouble cross(Point a, Point b) { //外積\n    return a.X * b.Y - a.Y * b.X;\n}\nint ccw(Point a, Point b, Point c) { //直線に対する点の位置\n    if (cross(b - a, c - a) > EPS)return 1;\n    if (cross(b - a, c - a) < -EPS)return -1;\n    if (dot(b - a, c - a) < -EPS)return 2;\n    if (abs(b - a) + EPS < abs(c - a))return -2;\n    return 0;\n}\nbool isOrthogonal(Line a, Line b) { //直行判定\n    return dot(a.second - a.first, b.second - b.first) ? 0 : 1;\n}\nbool isParallel(Line a, Line b) { //平行判定\n    return cross(a.second - a.first, b.second - b.first) ? 0 : 1;\n}\nbool isCross(Line a, Line b) { //交差判定\n    if (ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0 and\n        ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0) {\n        return true;\n    }\n    return false;\n}\nPoint CrossPoint(Line a, Line b) { //直線の交点\n    double x, d;\n    Point p1, p2, p3, p4;\n    p1 = a.first;\n    p2 = a.second;\n    p3 = b.first;\n    p4 = b.second;\n    x = (p4.Y - p3.Y) * (p4.X - p1.X) - (p4.X - p3.X) * (p4.Y - p1.Y);\n    d = (p4.Y - p3.Y) * (p2.X - p1.X) - (p4.X - p3.X) * (p2.Y - p1.Y);\n    return p1 + x / d * (p2 - p1);\n}\ndouble PointLineDis(Line l, Point p) {\n    Point a = l.first, b = l.second, c = p;\n    return abs(cross(c - a, b - a)) / abs(b - a);\n}\ndouble PointSegDis(Line a, Point p) {\n    Point p1 = a.first, p2 = a.second;\n    if (dot(p2 - p1, p - p1) < EPS)return abs(p - p1);\n    if (dot(p1 - p2, p - p2) < EPS)return abs(p - p2);\n    return PointLineDis(a, p);\n}\ndouble SegSegDis(Line a, Line b) {\n    double res = PointSegDis(a, b.first);\n    cout << res << endl;\n    res = min(res, PointSegDis(a, b.second));\n    cout << res << endl;\n    res = min(res, PointSegDis(b, a.first));\n    cout << res << endl;\n    res = min(res, PointSegDis(b, a.second));\n    cout << res << endl;\n    return res;\n}\ndouble PolyArea(Poly p) {\n    if (p.size() < 3)return 0;\n    double res = cross(p[p.size() - 1], p[0]);\n    for (size_t i = 0; i < p.size() - 1; ++i) {\n        res += cross(p[i], p[i + 1]);\n    }\n    return res / 2.0;\n}\nbool isConvex(Poly p) {\n    for (size_t i = 0; i < p.size(); ++i) {\n        if (ccw(p[i], p[(i + 1) % p.size()], p[(i + 2) % p.size()]) == -1)return false;\n    }\n    return true;\n}\nint inPoly(Poly& p, Point a) {\n    int count = 0;\n    Point cp;\n    int n = (int)p.size();\n    p.push_back(p[0]);\n    Point b = Point(a.X + 1, a.Y);\n    for (int i = 0; i < n; ++i) {\n        Point s = p[i] - a, t = p[i + 1] - a;\n        if (ccw(s, t, Point(0, 0)) == 0)return 1;\n        if (s.Y > t.Y + EPS)swap(s, t);\n        if ((s.Y * t.Y < 0 || (s.Y * t.Y<EPS && t.Y>EPS)) && cross(s, t) < EPS)count++;\n    }\n    if (count % 2)return 2;\n    else return 0;\n}\nPoly ConvexHull(Poly v) {//凸包 by TAB\n    int n = v.size(), k = 0;\n    sort(v.begin(), v.end(), cmp_y);\n    Poly r(2 * n);\n    for (int i = 0; i < n; i++) {\n        while (k > 1 && cross(r[k - 1] - r[k - 2], v[i] - r[k - 2]) < -EPS)k--;\n        r[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n        while (k > t && cross(r[k - 1] - r[k - 2], v[i] - r[k - 2]) < -EPS)k--;\n        r[k++] = v[i];\n    }\n    r.resize(k - 1);\n    return r;\n}\n/*\nPoly ConvexHull(Poly p) {\n    int n = p.size(), k = 0;\n    sort(p.begin(),p.end(),cmp_y);\n    Poly r(2 * n);\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2 && cross(r[k - 1]- r[k - 2], p[i]-r[k - 2]) <= 0)k--;\n        r[k++] = p[i];\n    }\n    for (int i = n - 2, t = k + 1; i > 0; --i) {\n        while (k >= t && cross(r[k - 1] - r[k - 2], p[i-1] - r[k - 2]) <= 0)k--;\n        r[k++] = p[i - 1];\n    }\n    r.resize(k-1);\n    return r;\n}*/\ndouble caliper(const Poly &p) {//多角形の直径\n    int n = p.size();\n    if (n <= 1)return 0;\n    if (n == 2)return abs(p[0] - p[1]);\n\n    int i=0, j = 0;\n    for (int k = 0; k < n; ++k) {\n        if (!(p[i] < p[k]))i = k;\n        if (p[j] < p[k])j = k;\n    }\n\n    double res = 0.0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        res = max(res, abs(p[i] - p[j]));\n        if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0)i = (i + 1) % n;\n        else j = (j + 1) % n;\n    }\n    return res;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    Poly poly;\n    for (int i = 0; i < n; ++i) {\n        double x1, y1;\n        cin >> x1 >> y1;\n        Point p = Point(x1, y1);\n        poly.push_back(p);\n        //cout << p.X << p.Y << endl;\n    }\n    printf(\"%.9f\\n\", caliper(poly));\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\n\nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=andrewScan(s);\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i].x<p[k].x) i=k;\n    if(p[j].x>p[k].x) j=k;\n  }\n  //cout<<i<<\" \"<<j<<endl;\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    //cout<<i<<\" \"<<j<<endl;\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+i)%n]-p[i],p[(j+1)%n]-p[j])<0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Test:\n        geometry/antipodal_points.cpp\n\n    Link:\n        AIZU(judge.u-aizu.ac.jp) CGL.4B\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\n\n#define NEXT(i) (((i) + 1) % n)\n\ndouble cross(point a, point b) { return imag(conj(a) * b); }\ndouble area2(point a, point b, point c) { return cross(b - a, c - a); }\n\nvector<pair<int, int>> antipodal(const polygon &P)\n{\n    vector<pair<int, int>> ans;\n    int n = P.size();\n\n    if (P.size() == 2)\n        ans.push_back({ 0, 1 });\n\n    if (P.size() < 3)\n        return ans;\n\n    int q0 = 0;\n\n    while (abs(area2(P[n - 1], P[0], P[NEXT(q0)]))\n            > abs(area2(P[n - 1], P[0], P[q0])))\n        ++q0;\n\n    for (int q = q0, p = 0; q != 0 && p <= q0; ++p)\n    {\n        ans.push_back({ p, q });\n\n        while (abs(area2(P[p], P[NEXT(p)], P[NEXT(q)]))\n                > abs(area2(P[p], P[NEXT(p)], P[q])))\n        {\n            q = NEXT(q);\n            if (p != q0 || q != 0)\n                ans.push_back({ p, q });\n            else\n                return ans;\n        }\n\n        if (abs(area2(P[p], P[NEXT(p)], P[NEXT(q)]))\n                == abs(area2(P[p], P[NEXT(p)], P[q])))\n        {\n            if (p != q0 || q != n - 1)\n                ans.push_back({ p, NEXT(q) });\n            else\n                ans.push_back({ NEXT(p), q });\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    int n; cin >> n;\n\n    polygon P(n);\n\n    for (int i = 0; i < n; ++i){\n        double x, y;\n        cin >> x >> y;\n        P[i] = point(x, y);\n    }\n\n    auto apod = antipodal(P);\n\n    double diameter = 0.;\n\n    for (auto a : apod)\n        diameter = max(diameter, abs(P[a.first] - P[a.second]));\n\n    cout.precision(17);\n\n    cout << fixed << diameter << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\ndouble add(double a, double b)\n{\n\tif (abs(a + b) < EPS * (abs(a) + abs(b))) {\n\t\treturn 0;\n\t}\n\treturn a + b;\n}\n\nstruct P\n{\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {}\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d) {\n\t\treturn P(x*d, y*d);\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n};\n\nint n;\nP ps[MAX_N];\n\nbool cmp_x(const P& p, const P& q)\n{\n\tif (p.x != q.x) {\n\t\treturn p.x < q.x;\n\t}\n\treturn p.y < q.y;\n}\n\nvector<P> convex_hull(P* ps, int n)\n{\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;\n\tvector<P> qs(n * 2);\n\trep(i, n) {\n\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) {\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = n - 2, t = k;i >= 0;i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) {\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\ndouble dist(P p, P q)\n{\n\treturn (p - q).dot(p - q);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf%lf\", &a, &b);\n\t\tps[i] = P(a, b);\n\t}\n\tvector<P> qs = convex_hull(ps, n);\n\tif (qs.size() == 2) {\n\t\tprintf(\"%.0f\\n\", dist(qs[0], qs[1]));\n\t\treturn 0;\n\t}\n\tint i = 0, j = 0;\n\trep(k, qs.size()) {\n\t\tif (!cmp_x(qs[i], qs[k])) {\n\t\t\ti = k;\n\t\t}\n\t\tif (cmp_x(qs[j], qs[k])) {\n\t\t\tj = k;\n\t\t}\n\t}\n\tdouble res = 0;\n\tint si = i, sj = j;\n\twhile (i != sj || j != si) {\n\t\tres = max(res, dist(qs[i], qs[j]));\n\t\tif ((qs[(i + 1) % qs.size()] - qs[i]).det(qs[(j + 1) % qs.size()] - qs[j]) < 0) {\n\t\t\ti = (i + 1) % qs.size();\n\t\t}\n\t\telse {\n\t\t\tj = (j + 1) % qs.size();\n\t\t}\n\t}\n\tprintf(\"%d\\n\", qs.size());\n\tfor (int i = 0; i < qs.size(); i++) {\n\t\tprintf(\"%f %f\\n\", qs[i].x, qs[i].y);\n\t}\n\tprintf(\"%.10lf\\n\", sqrt(res));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n\ntypedef double type_n;\n\nstruct Point{ type_n x, y; };\n\nPoint set_p(type_n a, type_n b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ type_n vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\ntype_n cross(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\ntype_n dist(const Point &p1, const Point &p2)\n{\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint main()\n{\n    int i, n;\n    type_n *X, *Y;\n    scanf(\"%d\", &n);\n    assert(n >= 3);\n\n    X = new type_n [n + 1];\n    Y = new type_n [n + 1];\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &X[i], &Y[i]);\n    }\n    X[n] = X[0], Y[n] = Y[0];\n\n    Point *Plg;\n    Plg = new Point [n + 1];\n    for(i = 0; i <= n; i++){\n        Plg[i] = set_p(X[i], Y[i]);\n    }\n\n    int top = 0, bottom = 0;\n    type_n diam = 0;\n    type_n low = Y[0], high = Y[0];\n\n    for(i = 1; i < n; i++){\n        if(low > Y[i]){ bottom = i, low = Y[i]; }\n        if(high < Y[i]){ top = i, high = Y[i]; }\n    }\n    diam = dist(Plg[top], Plg[bottom]);\n    top--;\n\n    for(int k = 0; k < n; k++){\n        while(cross(set_v(Plg[bottom], Plg[bottom + 1]), set_v(Plg[top], Plg[top + 1])) >= 0){\n            top++; if(top > n - 1) top -= n;\n        };\n        diam = max(diam, max(dist(Plg[bottom], Plg[top]), dist(Plg[bottom + 1], Plg[top])));\n        bottom++; if(bottom > n - 1) bottom -= n;\n    }\n\n    printf(\"%.12f\\n\", diam);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\n// BEGIN CUt HERE\nusing G = V<P>;\nR area(const G& g) {\n  if (g.size() < 3) return 0;\n  R res = 0;\n  P a = g.back();\n  for (P b : g) {\n    res += crs(a, b) / 2;\n    a = b;\n  }\n  return res;\n}\n// -1: in, 0: on, 1: out\nint contains(const G& g, P p) {\n  assert(g.size() >= 3);\n  int c = 0;\n  P q = p + P(pi, 1), a = g.back();\n  for (P b : g) {\n    if (!ccw(a, b, p)) return 0;\n    if (!sgn(distLS({p, q}, {a, b}))) {\n      c += ccw(p, q, intxn({p, q}, {a, b})) >= 0;\n    }\n    a = b;\n  }\n  return c & 1 ? -1 : 1;\n}\nG half_convex_hull(const V<P>& ps, bool strict) {\n  G g;\n  for (P p : ps) {\n    while (g.size() >= 2) {\n      int c = ccw(g[g.size() - 2], g.back(), p);\n      if (c == 1 or !strict and c == 2) break;\n      g.pop_back();\n    }\n    g.push_back(p);\n  }\n  g.pop_back();\n  return g;\n}\nG convex_hull(V<P> ps, bool strict = true) {\n  sort(begin(ps), end(ps), cmp);\n  ps.erase(unique(begin(ps), end(ps), eql), end(ps));\n  if (ps.size() < 3) return ps;\n  G g = half_convex_hull(ps, strict);\n  reverse(begin(ps), end(ps));\n  G h = half_convex_hull(ps, strict);\n  g.insert(end(g), begin(h), end(h));\n  return g;\n}\nR diameter(const G& g) {\n  auto e = minmax_element(begin(g), end(g), cmp);\n  int n = g.size(), i = e.first - begin(g), j = e.second - begin(g);\n  R res = 0;\n  int si = i, sj = j;\n  for (int _ = 0; _ < 2 * n + 10; ++_) {\n    if (_ == n) assert(i == sj and j == si);\n    if (_ == 2 * n) assert(i == si and j == sj);\n    res = max(res, distPP(g[i], g[j]));\n    int ni = (i + 1) % n, nj = (j + 1) % n;\n    if (sgn(crs(g[ni] - g[i], g[nj] - g[j])) < 0) i = ni;\n    else j = nj;\n  }\n  return res;\n}\n// END CUT HERE\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  G g(n); for (auto&& e : g) cin >> e;\n  cout << fixed << setprecision(15) << diameter(g) << '\\n';\n}\n\n// https://onlinejudge.u-aizu.ac.jp/status/users/risujiroh/submissions/1/CGL_3_A/judge/3574786/C++14\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \nconst double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n  \nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n  \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n  \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n  \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < -EPS)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n  \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n  \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n};\n\nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\nint main(){\n  int n;\n  char buff[256];\n  scanf(\"%d\", &n);\n  Geometory::Polygon g(n);\n  for(int i = 0; i < n; i++){\n    fgets( buff, sizeof buff, stdin);\n    sscanf(buff,\"%lf %lf\", &g[i].x, &g[i].y);\n  }\n  g = geo.Convex_Hull(g);\n  double ret = 0;\n  for(int i = 0; i < g.size() - 1; i++){\n    for(int j = g.size() - 1; j > i; j--){\n      ret = max( ret, (g[i]-g[j]).abs());\n    }\n  }\n  printf(\"%lf\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nconst db eps = 1e-9;\nint sgn(db a, db b = 0) {\n\ta -= b;\n\treturn (a > eps) - (a < -eps);\n}\n\nstruct poi {\n\tdb x, y;\n\tpoi operator -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tbool operator <(poi p) const {\n\t\treturn tie(x, y) < tie(p.x, p.y);\n\t}\n\tdb cross(poi p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb len() {\n\t\treturn sqrt(x * x + y * y);\n\t}\n};\ndb xmul(poi a, poi b, poi c) {\n\treturn (b - a).cross(c - a);\n}\n\nusing vp = vector <poi>;\nvp convex(vp v) {\n\tsort(v.begin(), v.end()); vp r;\n\tfor(int i = 0; i < v.size(); i ++) {\n\t\twhile(r.size() > 1 &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tr.push_back(v[i]);\n\t}\n\tint d = r.size();\n\tfor(int i = (int)v.size() - 2; i >= 0; i --) {\n\t\twhile(r.size() > d &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tif(i != 0) r.push_back(v[i]);\n\t}\n\treturn r;\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(false);\n\tint n; cin >> n; vp v;\n\tfor(int i = 0; i < n; i ++) {\n\t\tdb x, y; cin >> x >> y;\n\t\tv.push_back({x, y});\n\t}\n\tv = convex(v);\n\n\tn = v.size();\n\t/*\n\tfor(int i = 0; i < n; i ++)\n\t\tcout << v[i].x << ' ' << v[i].y << '\\n';\n\t\t*/\n\t{\n\t\tdb ans = 0;\n\t\tauto upd = [&](int i, int j) {\n\t\t\tdb t = (v[i] - v[j]).len();\n\t\t\tif(t > ans) ans = t;\n\t\t};\n\t\tint j = 0;\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\twhile(sgn(xmul(v[i], v[(i + 1) % n], v[j]),\n\t\t\t\txmul(v[i], v[(i + 1) % n], v[(j + 1) % n])) <= 0)\n\t\t\t\tj = (j + 1) % n;\n\t\t\t//cout << i << ' ' << j << '\\n';\n\t\t\tupd(i, j); /*upd((i + 1) % n, j);*/\n\t\t\t/*upd(i, (j + 1) % n);*/ /*upd((i + 1) % n, (j + 1) % n);*/\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\t\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    R res=0.0;\n\trep(k,4*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nconst db eps = 1e-9;\nint sgn(db a, db b = 0) {\n\ta -= b;\n\treturn (a > eps) - (a < -eps);\n}\n\nstruct poi {\n\tdb x, y;\n\tpoi operator -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tbool operator <(poi p) const {\n\t\treturn tie(x, y) < tie(p.x, p.y);\n\t}\n\tdb cross(poi p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb len() {\n\t\treturn sqrt(x * x + y * y);\n\t}\n};\ndb xmul(poi a, poi b, poi c) {\n\treturn (b - a).cross(c - a);\n}\n\nusing vp = vector <poi>;\nvp convex(vp v) {\n\tsort(v.begin(), v.end()); vp r;\n\tfor(int i = 0; i < v.size(); i ++) {\n\t\twhile(r.size() > 1 &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tr.push_back(v[i]);\n\t}\n\tint d = r.size();\n\tfor(int i = (int)v.size() - 2; i >= 0; i --) {\n\t\twhile(r.size() > d &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tif(i != 0) r.push_back(v[i]);\n\t}\n\treturn r;\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(false);\n\tint n; cin >> n; vp v;\n\tfor(int i = 0; i < n; i ++) {\n\t\tdb x, y; cin >> x >> y;\n\t\tv.push_back({x, y});\n\t}\n\tv = convex(v);\n\n\tn = v.size();\n\n\t{\n\t\tdb ans = 0;\n\t\tauto upd = [&](int i, int j) {\n\t\t\tdb t = (v[i] - v[j]).len();\n\t\t\tif(t > ans) ans = t;\n\t\t};\n\t\tint j = 0;\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\twhile(sgn(xmul(v[i], v[(i + 1) % n], v[j]),\n\t\t\t\txmul(v[i], v[(i + 1) % n], v[(j + 1) % n])) < 0)\n\t\t\t\tj = (j + 1) % n;\n\t\t\t//cout << i << ' ' << j << '\\n';\n\t\t\tupd(i, j); /*upd((i + 1) % n, j);*/\n\t\t\tupd(i, (j + 1) % n); /*upd((i + 1) % n, (j + 1) % n);*/\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long; using ld = long double; using ull = unsigned long long; using uint = unsigned int;\nusing vi  = vector<int>; using vb  = vector<bool>; using vd  = vector<double>; using vl  = vector<ll>;\nusing vvi = vector<vi>;  using vvb = vector<vb>;   using vvd = vector<vd>;     using vvl = vector<vl>;\n\n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define FOR(i,b,n) for(ll i=(b); i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TEN(x) ((ll)1e##x)\n\ntemplate<typename T> inline string join(const vector<T>& vec, string sep = \" \") { stringstream ss; REP(i, vec.size()) ss << vec[i] << ( i+1 == vec.size() ? \"\" : sep ); return ss.str(); }\n\n\n///////////////\n\n#define EPS (1e-10)\n#define NEXT(x, i) (x[(i + 1) % x.size()])\n\ntemplate<class T> using CR = const T &;\nusing P = complex<ld>;\nusing G = vector<P>;\n\nint sgn(ld a, ld b = 0) {\n\tif (a > b + EPS) return 1;\n\tif (a < b - EPS) return -1;\n\treturn 0;\n}\n\nld dot(P a, P b) { return real(conj(a)*b); }\nld cross(P a, P b) { return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (sgn(cross(b, c))) return sgn(cross(b, c)); // clockwise(-1) or counter clockwise(1)\n\tif (sgn(dot(b, c)) == -1) return 2;            // c--a--b\n\tif (sgn(norm(b), norm(c)) == -1) return -2;    // a--b--c\n\treturn 0;                                      // a--c--b\n}\n\nnamespace std {\n\tbool operator < (P a, P b) {\n\t\treturn sgn(real(a), real(b)) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nld convex_diameter(CR<G> g) {\n\tint n = g.size();\n\n\tint is = 0, js = 0;\n\tFOR(i, 1, n) {\n\t\tif (imag(g[i]) > imag(g[is])) is = i;\n\t\tif (imag(g[i]) < imag(g[js])) js = i;\n\t}\n\tld maxd = norm(g[is] - g[js]);\n\n\tint i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo {\n\t\tif (cross(g[(i+1)%g.size()] - g[i], g[(j+1)%g.size()] - g[j]) >= 0) j = (j + 1) % n;\n\t\telse i = (i + 1) % n;\n\t\tif (norm(g[i] - g[j]) > maxd) {\n\t\t\tmaxd = norm(g[i] - g[j]);\n\t\t\tmaxi = i; maxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\treturn sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\n//////////////\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(30);\n\tll n; cin >> n;\n\n\tG g(n);\n\tREP(i,n){\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tg[i] = { x, y };\n\t}\n\n\tcout << convex_diameter(g) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n\ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n\nP Vector(L a){\n  return a.second-a.first;\n}\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n\ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n\ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n\n\nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n\nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n\nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n\nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n\nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n\nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n\nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n\nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n\ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n\ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n\ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n\nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\n\n \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\nvecP andrewScan(vecP &t){\n  int N=t.size(),C=0;\n  vecP R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vecP res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n \nvecP convexHull(vecP &t){\n  sort(t.begin(),t.end());\n  vecP u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vecP l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvecP cutConvex(vecP &t,L l){\n  P a=l.first, b=l.second;\n  int N=t.size();\n  vecP res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C==-D&&abs(C)==1)res.push_back(getCrossLL( l ,L(c,d) ));\n  }\n  return res;\n}\n\nP getVector(const vecP &t, int id){\n  int n=t.size();\n  return t[ (id+1)%n ] - t[id%n];\n}\n\ndouble convex_diameter(vecP &t) {\n  int n = t.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(t[i]) > imag(t[is])) is = i;\n    if (imag(t[i]) < imag(t[js])) js = i;\n  }\n  double maxd = norm(t[is]-t[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    \n    if (cross( getVector(t,i), getVector(t,j)) >= 0) j = (j+1) % n;\n    \n    else i = (i+1) % n;\n    if (norm(t[i]-t[j]) > maxd) {\n      maxd = norm(t[i]-t[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return maxd; /* farthest pair is (maxi, maxj). */\n}\n\nbool compare_y(const P &a,const P &b){\n  return a.imag() < b.imag();\n}\n\ndouble closest_pair(P *a, int n){\n  if(n <= 1) return 1e30;\n  int m = n / 2;\n  double x = a[m].real();\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if( abs(a[i].real() - x) >= d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dx = real(a[i] - b[b.size() - j - 1]);\n      double dy = imag(a[i] - b[b.size() - j - 1]);\n      if(dy >= d) break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nP _pool[200005];\ndouble minDist(vecP &t){\n  int n=t.size();\n  for(int i=0;i<n;i++)_pool[i]=t[i];\n  sort( _pool, _pool+n);\n  return closest_pair(_pool, n);\n}\n\nint getStateCC(C a,C b){\n  double ar=a.second, br=b.second;\n  double dist=abs(a.first-b.first);\n  if(dist>ar+br+eps)return 4;\n  if(dist>ar+br-eps)return 3;\n  if(dist>abs(ar-br)+eps)return 2;\n  if(dist>abs(ar-br)-eps)return 1;\n  return 0;\n}\n\nP getCrossCC(C a,C b){\n  P p1=a.first, p2=a.second;\n  double r1=a.second, r2=b.second;\n  double cA = (r1*r1+norm(p1-p2)-r2*r2) / (2.0*r1*abs(p1-p2));\n  return p1+(p2-p1)/abs(p1-p2)*r1*P(cA,Sqrt(1.0-cA*cA));\n}\n\nS getTangentCP(C a,P p){\n  P base=a.first-p;\n  double ar=a.second;\n  double w=Sqrt(norm(base)-ar*ar);\n  P s=p+base*P(w,ar)/norm(base)*w;\n  P t=p+base*P(w,-ar)/norm(base)*w;\n  return S(s,t);\n}\n\nS getInTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double w=ar+br;\n  double h=Sqrt(norm(base)-w*w);\n  P k=base*P(w,h*flg)/norm(base);\n  return S(ap+k*ar,bp-k*br);\n}\n  \nS getOutTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double h=br-ar;\n  \n  double w=Sqrt(norm(base)-h*h);\n  P k=base*P(w,h*flg)/norm(base)*P(0,flg);\n  return S(ap+k*ar,bp+k*br);\n}\n  \nvector<S> getTangent(C a,C b){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  vector<S> res;\n  double dist=abs(ap-bp);\n    \n  if(dist>ar+br+eps)\n    res.push_back(getInTangent(a,b,1));\n  \n  if(dist>ar+br-eps)\n    res.push_back(getInTangent(a,b,-1));\n  \n  if(dist>abs(ar-br)+eps)\n    res.push_back(getOutTangent(a,b,1));\n  \n  if(dist>abs(ar-br)-eps)\n    res.push_back(getOutTangent(a,b,-1));\n  \n  return res;\n}\n\n\nvecP getCrossCS(C cir,S s, bool debug=false){\n  P a=s.first, b=s.second;\n  double cr=cir.second;\n  P cp=cir.first;\n  \n  vecP res;\n  P base=b-a,  target=project(a,b,cp);\n  \n  double length=abs(base), h=abs(cp-target);\n  base/=length;\n  \n  if(cr+eps<h)return res;\n  double w=Sqrt(cr*cr-h*h);\n  double L=getTime( normal(b-a) ,target-a)-w,  R=L+w*2.0;\n  \n  if( -eps<L && L< length+eps )res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R< length+eps )res.push_back(a+base*R);\n  return res;\n}\n \ndouble getArea(C c,P a,P b){\n  P cp=c.first;\n  double cr=c.second;\n  \n  P va=cp-a,  vb=cp-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=distSP( S(a,b) ,cp), res=0;\n  \n  if( eq(0, f ) )return 0;\n  if(A<cr+eps&&B<cr+eps)return f*0.5;\n  if(d>cr-eps)return cr*cr*PI*getArg(va,vb)/PI2;\n   \n  vecP u=getCrossCS(c, S(a,b) );\n  \n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n \n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n \ndouble getCrossArea(vecP t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n\nP input(){\n  int x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\nvoid pr(P p,string str){\n  printf(\"%.10f %.10f\",p.real(),p.imag());\n  cout<<str;\n}\n\n\nint main(){\n  int Tc;\n  cin>>Tc;\n\n  vecP polygon;\n  while(Tc--){\n    polygon.push_back( input() );\n  }\n  polygon = convexHull( polygon );\n\n  printf(\"%.10f\\n\", convex_diameter(polygon) );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define scanf nope\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntemplate <class T>\nstruct Point {\n\ttypedef Point P;\n\tT x, y;\n\texplicit Point(T x=0, T y=0) : x(x), y(y) {}\n\tbool operator<(P p) const { return x<p.x||(x==p.x && y<p.y);}\n\tbool operator==(P p) const { return x==p.x && y==p.y; }\n\tP operator+(P p) const { return P(x+p.x, y+p.y); }\n\tP operator-(P p) const { return P(x-p.x, y-p.y); }\n\tP operator*(T d) const { return P(x*d, y*d); }\n\tP operator/(T d) const { return P(x/d, y/d); }\n\tT dot(P p) const { return x*p.x + y*p.y; }\n\tT cross(P p) const { return x*p.y - y*p.x; }\n\tT cross(P p1, P p2) const { return (p1 - *this).cross(p2 - *this); }\n\tT dist2() const { return x*x + y*y; }\n\tdouble dist() const { return sqrt((double)dist2()); }\n\t// angle to x-axis in interval [-pi, pi]\n\tdouble angle() const { return atan2(y, x); }\n\tP unit() const { return *this/dist(); } // makes dist()=1\n\tP perp() const { return P(-y, x); } // rotates +90 degrees\n\tP normal() const { return perp().unit(); }\n\t// returns point rotated 'a' radians ccw around the origin\n\tP rotate(double a) const {\n\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n};\n\ntypedef Point<double> P;\npair<vi, vi> ulHull(const vector<P>& S) {\n    vector<int> Q(sz(S));\n    iota(all(Q), 0);\n    sort(all(Q), [&S](int a, int b){ return S[a] < S[b]; });\n    vi U, L;\n    trav(it, Q) {\n        while (sz(U) > 1 && S[U[sz(U)-2]].cross(S[it], S[U.back()]) <= 0) U.pop_back();\n        while (sz(L) > 1 && S[L[sz(L)-2]].cross(S[it], S[L.back()]) >= 0) L.pop_back();\n        U.push_back(it);\n        L.push_back(it);\n    }\n    return make_pair(U, L);\n}\n\nvi convexHull(const vector<P>& S) {\n    vi u, l;\n    tie(u, l) = ulHull(S);\n    if (sz(S) <= 1) return u;\n    u.pop_back();\n    reverse(all(u));\n    u.pop_back();\n    u.insert(u.end(), all(l));\n    if (sz(u) == 2 && S[u[0]] == S[u[1]]) u.pop_back();\n    return u;\n}\n\nvector<pii> antipodal(const vector<P>& S, const vi& U, const vi& L) {\n    vector<pii> A;\n    int i = 0;\n    int j = sz(L) - 1;\n    while (i < sz(U) - 1 || j > 0) {\n        A.emplace_back(i, j);\n        if (i == sz(U) - 1) --j;\n        else if (j == 0) ++i;\n        else if ((S[U[i+1]].y - S[U[i]].y) * (S[L[j]].x - S[L[j-1]].x) >\n                 (S[U[i+1]].x - S[U[i]].x) * (S[L[j]].y - S[L[j-1]].y)) ++i;\n        else --j;\n    }\n    return A;\n}\n\npii polygonDiameter(const vector<P>& S) {\n    vi U, L;\n    tie(U, L) = ulHull(S);\n    pair<double, pii> ans;\n    trav(it, antipodal(S, U, L))\n        ans = max(ans, make_pair((S[it.first] - S[it.second]).dist2(), it));\n    return ans.second;\n}\n\nint main() {\n    int N;\n    cin >> N;\n        vector<P> P(N);\n        rep(i,0,N) cin >> P[i].x >> P[i].y;\n        pii ret = polygonDiameter(P);\n        cout << setprecision(10) << fixed << (P[ret.first] - P[ret.second]).dist() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\n\nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end());\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  //cout<<i<<\" \"<<j<<endl;\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    //cout<<i<<\" \"<<j<<endl;\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define db double\nconst db eps = 1e-10;\n\nstruct Point{\n    db x, y;\n    Point(db x=0, db y=0): x(x), y(y) {}    //必须有初始化\n    bool operator < (const Point &p){\n        return x < p.x || (x == p.x && y < p.y);\n    }\n};\n\ntypedef Point Vector;\nVector operator + (Vector a, Vector b){ return Point(a.x+b.x, a.y+b.y);}\nVector operator - (Point a, Point b){ return Vector(a.x-b.x, a.y-b.y);}\nVector operator * (Vector a, db k){ return Vector(a.x*k, a.y*k);}\nVector operator / (Vector a, db k){ return Vector(a.x/k, a.y/k);}\n\n//inline将函数名为内联函数，不使用栈空间，直接运算，但不能有while,switch等复杂语句\ninline db dot(Vector a, Vector b){\n    return a.x*b.x + a.y*b.y;\n}\ninline db cross(Vector a, Vector b){\n    return a.x*b.y - b.x*a.y;\n}\ndb length(Vector a){\n    return sqrt(dot(a, a));\n}\ndb angle(Vector a, Vector b){\n    return acos(dot(a, b) / length(a) / length(b));\n}\n\nint dcmp(db x){ //三态函数，eps间返回0，否则>eps返回1，反之-1\n    if(fabs(x) < eps) return 0;\n    return x < 0? -1: 1;\n}\nbool operator == (Point a, Point b){\n    return dcmp(a.x-b.x) == 0 && dcmp(a.y-b.y) == 0;\n}\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1=Point(0, 0), Point p2 = Point(0, 0)): p1(p1), p2(p2) {};\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\nPoint project(Line l, Point p){\n    Vector a = l.p2 - l.p1, b = p - l.p1;\n    db len_a = dot(a, a);   //这里不加sqrt，是因为下面算投影长度时，要除以两次len_a\n    Vector tmp = a * (dot(a, b) / len_a);\n    return l.p1+tmp;\n}\nPoint reflect(Line l, Point p){\n    Point tmp = project(l, p);\n    return p + (tmp - p)*2;\n}\n\nint line_relation(Line l1, Line l2){\n    Vector a = l1.p2 - l1.p1, b = l2.p2 - l2.p1;\n    if(cross(a, b) == 0)\n        return 1;\n//        puts(\"parallel\");\n    else if(dot(a, b) == 0)\n        return 0;\n//        puts(\"orthogonal\");\n    else\n        return -1;\n//        puts(\"others\");\n}\nint com_segment_relation(Point p0, Point p1, Point p2){\n    Vector a = p1-p0, b = p2-p0;\n    db flag = cross(p1-p0, p2-p0);\n    if(flag < 0)  return 2;\n    else if(flag > 0)  return 1;\n    else{       //重合\n        if(a.x*b.x < 0 || a.y*b.y < 0) return 3;\n        else if(length(a) < length(b)) return 4;\n        else return 5;\n    }\n}\nbool segment_intersection(Segment s1, Segment s2){\n    Point p1 = s1.p1, p2 = s1.p2, p3 = s2.p1, p4 = s2.p2;\n    if(p2 < p1) swap(p1, p2);\n    if(p4 < p3) swap(p3, p4);\n    if(p2 < p3 || p4 < p1)\n        return 0;       //同一直线上，最大最小排除\n    else if(cross(p2-p1, p3-p1)*cross(p2-p1, p4-p1) > 0 || cross(p4-p3, p1-p3)*cross(p4-p3, p2-p3) > 0)\n        return 0;\n    else\n        return 1;\n}\nPoint segment_cross_point(Segment s1, Segment s2){\n    if(!segment_intersection(s1, s2))\n        exit(0);\n    Vector a = s1.p2-s1.p1, b1 = s2.p1-s1.p1, b2 = s2.p2-s1.p1;\n    db len = length(a);\n    db h1 = fabs(cross(a, b1) / len);   //可以省去除len,求t时会消掉\n    db h2 = fabs(cross(a, b2) / len);\n    db t = h1 / (h1+h2);\n    return s2.p1+(s2.p2-s2.p1)*t;\n}\nPoint line_cross_point(Point P, Vector v, Point Q, Vector w){\n    if(cross(v, w) == 0)\n        exit(0);\n    Vector u = P - Q;\n    double t = cross(w, u) / cross(v, w);\n    return P+v*t;\n}\nbool onsegment(Segment s, Point p){\n    return dcmp(cross(s.p2-p, s.p1-p)) == 0 && dcmp(dot(s.p1-p, s.p2-p)) <= 0;  //顶点时，dot为0\n}\n\ninline db norm(db x){\n    return x*x;\n}\ninline db dist_PtoP(Point p1, Point p2){\n    return length(p2-p1);   //转换为向量模\n}\ndb dist_PtoS(Segment s, Point p){\n    if(s.p1 == s.p2) return length(p-s.p1);\n    Vector v1 = s.p2 - s.p1, v2 = p - s.p1, v3 = p - s.p2;\n    if(dcmp(dot(v1, v2) < 0))    return length(v2);\n    else if(dcmp(dot(v1, v3) > 0))    return length(v3);\n    else    return fabs(cross(v1, v2)) / length(v1);\n}\ninline db dist_PtoL(Line l, Point p){\n    db tmp = cross(l.p2-l.p1, p-l.p1) / length(l.p2-l.p1);\n    return fabs(tmp);\n}\ndb dist_StoS(Segment s1, Segment s2){\n    if(segment_intersection(s1, s2))\n        return 0;\n    db d1 = dist_PtoS(s2, s1.p1), d2 = dist_PtoS(s2, s1.p2), d3 = dist_PtoS(s1, s2.p1), d4 = dist_PtoS(s1, s2.p2);\n    return min(min(d1, d2), min(d3, d4));\n}\ndb dist_LtoL(Line l1, Line l2){\n    if(line_relation(l1, l2) == 1)\n        return dist_PtoL(l1, l2.p1);\n    return 0;\n}\n\ndb polygon_area(Polygon &pol){\n    int sz = pol.size();\n    db res = 0.0;\n    for(int i=1; i<sz-1; ++i){  //分为n-1个三角形\n        res += 0.5*cross(pol[i]-pol[0], pol[i+1]-pol[0]);\n    }\n    return fabs(res);\n}\n\nconst int maxn = 8e5+5;\nPoint ch[maxn] = {0};\nint convex_hull(Polygon &pol, int n){\n    sort(pol.begin(), pol.end());\n    int top = 0;\n    for(int i=0; i<n; ++i){\n        while(top > 1 && cross(ch[top-1] - ch[top-2], pol[i] - ch[top-1]) <= 0) top --;\n        ch[top ++] = pol[i];\n    }\n    int mid = top;\n    for(int i=n-2; i>=0; --i){\n        while(top > mid && cross(ch[top-1] - ch[top-2], pol[i] - ch[top-1]) <= 0) top --;\n        ch[top ++] = pol[i];\n    }\n//    printf(\"#%d\\n\", top);\n    if(n > 1) top --;\n    return top;\n}\nint point_in_polygon(Point p, Polygon &pol){\n    int wn = 0; //winging number\n    int n = pol.size();\n    for(int i=0; i<n; ++i){\n        if(onsegment(Segment(pol[i], pol[(i+1)%n]), p)) return 1;\n        int k = dcmp(cross(pol[(i+1)%n]-pol[i], p-pol[i]));\n        int d1 = dcmp(pol[i].y - p.y);\n        int d2 = dcmp(pol[(i+1)%n].y - p.y);\n        if(k > 0 && d1 <= 0 && d2 > 0) wn ++;\n        if(k < 0 && d2 <= 0 && d1 > 0) wn --;\n    }\n    if(wn != 0) return 2;\n    return 0;\n}\ndb diam_of_ch(Point ch[], int n){\n    ch[n] = Point(ch[0].x, ch[0].y);\n    int j = 1;\n    db res = 0.0;\n    for(int i=0; i<n; ++i){\n        while(cross(ch[i+1]-ch[i], ch[j+1]-ch[i]) > cross(ch[i+1]-ch[i], ch[j]-ch[i]))\n            j = (j+1)%n;\n        res = max(res, max(length(ch[j]-ch[i]), length(ch[j+1]-ch[i+1])));\n    }\n    return res;\n}\nint main()\n{\n    Point p1, p2, p3, p4;\n    int n;\n    cin >>n;\n    Polygon pol;\n    while(!pol.empty()) {pol.pop_back();}\n    while(n --){\n        cin >>p1.x >>p1.y;\n        pol.push_back(p1);\n    }\n    n = pol.size();\n    n = convex_hull(pol, n);\n    printf(\"%.7f\\n\", diam_of_ch(ch, n));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Fi first\n#define Se second\n#define pb push_back\n#define mp make_pair\n#define rep(x, a, b) for(int x = (a); x <= (b); ++ x)\n#define per(x, a, b) for(int x = (a); x >= (b); -- x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++ x)\n#define por(x, a, b) for(int x = (a); x > (b); -- x) \n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned int unt;\ntypedef double db;\ntypedef pair <int, int> pii;\ntypedef vector <int> vi;\n\nconst db eps  = 1e-8;\nconst db _PI  = 3.1415926535897932384;\nconst db _E   = 2.7182818284590452354;\nconst int inf = 0x3f3f3f3f;\nconst LL INF  = 0x3f3f3f3f3f3f3f3fll;\n\nint dcmp(db x) {\n\tif(x > eps) return 1;\n\tif(x < -eps) return -1;\n\treturn 0;\n}\n\nint dcmp(db x, db y) {\n\treturn dcmp(x - y);\n}\n\nstruct Point {\n\tdb x, y;\n\tPoint(db _x = 0, db _y = 0) : x(_x), y(_y) {}\n\tvoid print() { printf(\"%.0f %.0f\", x, y); }\n};\nstruct Line {\n\tPoint p1, p2;\n\tLine() {};\n\tLine(Point _p1, Point _p2) : p1(_p1), p2(_p2) {};\n};\n\ntypedef Point Vector;\ntypedef Line Segment;\ntypedef vector<Point> Polygon;\n\nbool cmp_y(Point a, Point b) {\n\treturn dcmp(a.y, b.y) == 0 ? a.x < b.x : a.y < b.y;\n}\nbool cmp_x(Point a, Point b) {\n\treturn dcmp(a.x, b.x) == 0 ? a.y < b.y : a.x < b.x;\n}\n\n// CCW\nconst int CCW_COUNTER_CLOCKWISE = 1;\nconst int CCW_CLOCKWISE = -1;\nconst int CCW_ONLINE_FRONT = -2;\nconst int CCW_ONLINE_BACK = 2;\nconst int CCW_ON_SEGMENT = 0;\n\nVector operator + (Vector a, Vector b) {\n\treturn Vector(a.x + b.x, a.y + b.y);\n}\nVector operator - (Vector a, Vector b) {\n\treturn Vector(a.x - b.x, a.y - b.y);\n}\nVector operator * (Vector a, db b) {\n\treturn Vector(a.x * b, a.y * b);\n}\nVector operator / (Vector a, db b) {\n\treturn Vector(a.x / b, a.y / b);\n}\ndb operator * (Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\ndb operator ^ (Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\ndb dis(Point a, Point b) {\n\treturn sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\ndb dis2(Point a, Point b) {\n\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\ndb dis(Vector a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\ndb dis2(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\nPoint Project(Line L, Point p) {\n\tVector Base = L.p2 - L.p1;\n\tdb len = Base * (p - L.p1);\n\treturn L.p1 + Base * (len / dis2(L.p1, L.p2));\n}\nPoint Reflect(Line L, Point p) {\n\treturn p + (Project(L, p) - p) * 2.0;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector p01 = p1 - p0, p02 = p2 - p0;\n\tif(dcmp(p01 ^ p02) == 1) return CCW_COUNTER_CLOCKWISE; // 逆时针 \n\tif(dcmp(p01 ^ p02) == -1) return CCW_CLOCKWISE;        // 顺时针 \n\tif(dcmp(p01 * p02) == -1) return CCW_ONLINE_BACK;\n\tif(dcmp(dis2(p01), dis2(p02)) == -1) return CCW_ONLINE_FRONT;\n\treturn CCW_ON_SEGMENT;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn dcmp(a * b) == 0;\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a2 - a1, b2 - b1);\n}\nbool isOrthogonal(Line a, Line b) {\n\treturn isOrthogonal(a.p2 - a.p1, b.p2 - b.p1);\n}\nbool isParallel(Vector a, Vector b) {\n\treturn dcmp(a ^ b) == 0;\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a2 - a1, b2 - b1);\n}\nbool isParallel(Line a, Line b) {\n\treturn isParallel(a.p2 - a.p1, b.p2 - b.p1);\n}\nbool IntersectSS(Point a1, Point a2, Point b1, Point b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 && ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\nbool IntersectSS(Segment a, Segment b) {\n\treturn IntersectSS(a.p1, a.p2, b.p1, b.p2);\n}\nPoint getCrossPointSS(Segment a, Segment b) {\n\tVector Base = b.p2 - b.p1;\n\tdb S1 = fabs(Base ^ (a.p1 - b.p1));\n\tdb S2 = fabs(Base ^ (a.p2 - b.p1));\n\treturn a.p1 + (a.p2 - a.p1) * (S1 / (S1 + S2));\n}\nPoint getCrossPointLL(Line a, Line b) {\n\tdb S1 = (b.p2 - b.p1) ^ (a.p2 - a.p1);\n\tdb S2 = (b.p2 - b.p1) ^ (b.p2 - a.p1);\n\tif(dcmp(S1) == 0 && dcmp(S2) == 0) return a.p1;\n\treturn a.p1 + (a.p2 - a.p1) * (S2 / S1); \n}\ndb disLP(Line a, Point p) {\n\treturn fabs(((a.p2 - a.p1) ^ (p - a.p1)) / dis(a.p1, a.p2));\n}\ndb disSP(Segment a, Point p) {\n\tif(dcmp((a.p2 - a.p1) * (p - a.p1)) == -1) return dis(a.p1, p);\n\tif(dcmp((a.p1 - a.p2) * (p - a.p2)) == -1) return dis(a.p2, p);\n\treturn disLP(a, p);\n}\ndb disSS(Segment a, Segment b) {\n\tif(IntersectSS(a, b)) return 0.0;\n\treturn min({disSP(b, a.p1), disSP(b, a.p2), disSP(a, b.p1), disSP(a, b.p2)});\n}\ndb Area(Polygon p) {\n\tdb S = p.back() ^ p[0];\n\trop(i, 0, (int) p.size() - 1) S += p[i] ^ p[i + 1];\n\treturn fabs(S) / 2;\n}\nbool isConvex(Polygon p) {\n\tint n = p.size();\n\trop(i, 0, n) if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == CCW_CLOCKWISE) return 0;\n\treturn 1;\n}\nint Contain(Polygon g, Point p) {\n\tint n = g.size();\n\tint cnt = 0;\n\trop(i, 0, n) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif(ccw(a, b, Point(0, 0)) == CCW_ON_SEGMENT) return 1;\n\t\tif(dcmp(a.y - b.y) == 0) continue;\n\t\tif(dcmp(a.y) == 0 && dcmp(a.x) >= 0) { \n\t\t\tif(dcmp(b.y) == -1) ++ cnt;\n\t\t\tcontinue;\n\t\t}\n\t\tif(dcmp(b.y) == 0 && dcmp(b.x) >= 0) {\n\t\t\tif(dcmp(a.y) == -1) ++ cnt;\n\t\t\tcontinue;\n\t\t}\n\t\tif(a.y > b.y) swap(a, b);\n\t\tif(dcmp(a.y) <= 0 && dcmp(b.y) >= 0 && dcmp(a ^ b) == 1) ++ cnt;\n\t}\n\treturn (cnt & 1) ? 2 : 0;\n\t// 2 : IN\n\t// 1 : ON\n\t// 0 : OUT\n}\nPolygon ConvexHull(Polygon p) {\n\tint n = p.size();\n\tPolygon g(n * 2);\n\tsort(p.begin(), p.end(), cmp_y);\n\tint c = 0;\n\trop(i, 0, n) {\n\t\twhile(c > 1 && dcmp((g[c - 1] - g[c - 2]) ^ (p[i] - g[c - 2])) < 0) -- c;\n\t\tg[c ++] = p[i];\n\t}\n\tint k = c;\n\tper(i, n - 2, 0) {\n\t\twhile(c > k && dcmp((g[c - 1] - g[c - 2]) ^ (p[i] - g[c - 1])) < 0) -- c;\n\t\tg[c ++] = p[i];\n\t}\n\tg.resize(c - 1);\n\treturn g;\n}\n//db getDiameter(Polygon g) {\n//\tint it1 = 0, it2 = 0;\n//\tint n = g.size();\n//\tif(n == 2) return dis(g[0], g[1]);\n//\trop(i, 0, n) {\n//\t\tif(cmp_x(g[i], g[it1])) it1 = i;\n//\t\tif(!cmp_x(g[i], g[it2])) it2 = i;\n//\t}\n//\tdb ans = 0;\n//\tint s1 = it1, s2 = it2;\n//\twhile(it1 != s2 || it2 != s1) {\n//\t\tans = max(ans, dis(g[it1], g[it2]));\n//\t\tif(dis2(g[it1], g[(it2 + 1) % n]) > dis2(g[(it1 + 1) % n], g[it2]) && it2 != s1) {\n//\t\t\tit2 = (it2 + 1) % n;\n//\t\t} else {\n//\t\t\tit1 = (it1 + 1) % n;\n//\t\t}\n//\t}\n//\treturn ans;\n//}\ndb getDiameter(Polygon g) {\n\tg.pb(g[0]);\n\tint up = 1;\n\tdb ans = 0;\n\tint n = g.size();\n\trop(i, 1, n) {\n\t\twhile(dcmp(fabs((g[i] - g[up]) ^ (g[i - 1] - g[up])), fabs((g[i] - g[(up + 1) % n]) ^ (g[i - 1] - g[(up + 1) % n]))) <= 0) up = (up + 1) % n;\n\t\tans = max(ans, dis(g[i], g[up]));\n\t\tans = max(ans, dis(g[i - 1], g[up]));\n\t}\n\treturn ans;\n}\n\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tPolygon p(n);\n\trop(i, 0, n) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n\tprintf(\"%.10f\\n\", getDiameter(p));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nconst db eps = 1e-9;\nint sgn(db a, db b = 0) {\n\ta -= b;\n\treturn (a > eps) - (a < -eps);\n}\n\nstruct poi {\n\tdb x, y;\n\tpoi operator -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tbool operator <(poi p) const {\n\t\treturn tie(x, y) < tie(p.x, p.y);\n\t}\n\tdb cross(poi p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb len() {\n\t\treturn sqrt(x * x + y * y);\n\t}\n};\ndb xmul(poi a, poi b, poi c) {\n\treturn (b - a).cross(c - a);\n}\n\nusing vp = vector <poi>;\nvp convex(vp v) {\n\tsort(v.begin(), v.end()); vp r;\n\tfor(int i = 0; i < v.size(); i ++) {\n\t\twhile(r.size() > 1 &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tr.push_back(v[i]);\n\t}\n\tint d = r.size();\n\tfor(int i = (int)v.size() - 2; i >= 0; i --) {\n\t\twhile(r.size() > d &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tif(i != 0) r.push_back(v[i]);\n\t}\n\treturn r;\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(false);\n\tint n; cin >> n; vp v;\n\tfor(int i = 0; i < n; i ++) {\n\t\tdb x, y; cin >> x >> y;\n\t\tv.push_back({x, y});\n\t}\n\tv = convex(v);\n\n\tn = v.size();\n\t/*\n\tfor(int i = 0; i < n; i ++)\n\t\tcout << v[i].x << ' ' << v[i].y << '\\n';\n\t\t*/\n\t{\n\t\tdb ans = 0;\n\t\tauto upd = [&](int i, int j) {\n\t\t\tdb t = (v[i] - v[j]).len();\n\t\t\tif(t > ans) ans = t;\n\t\t};\n\t\tint j = 1 % n;\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\twhile(sgn(xmul(v[i], v[(i + 1) % n], v[j]),\n\t\t\t\txmul(v[i], v[(i + 1) % n], v[(j + 1) % n])) < 0)\n\t\t\t\tj = (j + 1) % n;\n\t\t\t//cout << i << ' ' << j << '\\n';\n\t\t\tupd(i, j); /*upd((i + 1) % n, j);*/\n\t\t\t/*upd(i, (j + 1) % n);*/ /*upd((i + 1) % n, (j + 1) % n);*/\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tint si=i,sj=j;\n\tR res=0.0;\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0){\n\t\t\tassert(0==1);\n\t\t\ti=(i+1)%n;\n\t\t}else{\n\t\t\tassert(0==1);\n\t\t\tj=(j+1)%n;\n\t\t}\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ld long double\n#define eps 1e-9\n\nbool cmp(ld A , ld B){return A + eps > B && A - eps < B;}\n\nclass vec{\npublic:\n\tld x , y;\n\tvec(ld _x = 0 , ld _y = 0) : x(_x) , y(_y){}\n\tfriend vec operator +(vec A , vec B){return vec(A.x + B.x , A.y + B.y);}\n\tfriend vec operator -(vec A , vec B){return vec(A.x - B.x , A.y - B.y);}\n\tfriend ld operator *(vec A , vec B){return A.x * B.x + A.y * B.y;}\n\tfriend ld operator %(vec A , vec B){return A.x * B.y - A.y * B.x;}\n\tfriend vec operator *(vec A , ld B){return vec(A.x * B , A.y * B);}\n\tld len(){return sqrt(x * x + y * y);}\n\tld len2(){return x * x + y * y;}\n\tld angle(){return atan2(y , x);}\n};\nvec getvec(){ld x , y; cin >> x >> y; return vec(x , y);}\n\nclass segment{\npublic:\n\tvec st , ed , dir;\n\tsegment(vec _a = vec() , vec _b = vec()) : st(_a) , ed(_b) , dir(_b - _a){}\n\tfriend bool havesect(segment A , segment B){\n\t\tld P = A.st.x , Q = A.ed.x , X = B.st.x , Y = B.ed.x;\n\t\tif(Q < P) swap(P , Q);\n\t\tif(Y < X) swap(X , Y);\n\t\tif(X - eps > Q || P - eps > Y) return 0;\n\t\tP = A.st.y , Q = A.ed.y , X = B.st.y , Y = B.ed.y;\n\t\tif(Q < P) swap(P , Q);\n\t\tif(Y < X) swap(X , Y);\n\t\tif(X - eps > Q || P - eps > Y) return 0;\n\t\treturn\n\t\t\t((B.st - A.st) % A.dir) * (A.dir % (B.ed - A.st)) > -eps &&\n\t\t\t((B.st - A.ed) % A.dir) * (A.dir % (B.ed - A.ed)) > -eps &&\n\t\t\t((A.st - B.st) % B.dir) * (B.dir % (A.ed - B.st)) > -eps &&\n\t\t\t((A.st - B.ed) % B.dir) * (B.dir % (A.ed - B.ed)) > -eps;\n\t}\n\tfriend vec getsect(segment A , segment B){\n\t\tld t = ((A.st - B.st) % B.dir) / (B.dir % A.dir);\n\t\treturn A.st + (A.dir * t);\n\t}\n\tld len(){return dir.len();}\n\tld len2(){return dir.len2();}\n};\nsegment getseg(){vec A = getvec() , B = getvec(); return segment(A , B);}\n\nld dist(vec P , segment seg){//minimum dist from a point to a segment\n\tld T = ((P - seg.st) * seg.dir) / seg.len2();\n\tif(T < 0) return (seg.st - P).len();\n\telse if(T > 1) return (seg.ed - P).len();\n\telse return (seg.st + (seg.dir * T) - P).len();\n}\n\nclass polygon{//counter-clockwise\npublic:\n\tvector < vec > point; int sz; mt19937 rndLine;\n\tvoid input(){\n\t\tmt19937 rnd(time(0)); rndLine = rnd;\n\t\tcin >> sz; for(int i = 1 ; i <= sz ; ++i) point.push_back(getvec());\n\t\tfor(int i = 0 ; i < sz ; ++i) point.push_back(point[i]);\n\t}\n\tld area(){\n\t\tld sum = 0;\n\t\tfor(int i = 0 ; i < sz ; ++i) sum += point[i] % point[i + 1];\n\t\treturn sum / 2;\n\t}\n\tbool isconvex(){\n\t\tfor(int i = 1 ; i <= sz ; ++i)\n\t\t\tif((point[i - 1] - point[i]) % (point[i + 1] - point[i]) > eps) return 0;\n\t\treturn 1;\n\t}\n\tbool checkin(vec P){\n\t\tvec tmp(pow(rndLine() , 0.1) , pow(rndLine() , 0.2));\n\t\tsegment nowline(P , P + tmp * 1e10);\n\t\tint Count = 0;\n\t\tfor(int i = 0 ; i < sz ; ++i)\n\t\t\tCount += havesect(segment(point[i] , point[i + 1]) , nowline);\n\t\treturn Count & 1;\n\t}\n\tbool checkon(vec P){\n\t\tfor(int i = 0 ; i < sz ; ++i)\n\t\t\tif(cmp(0 , (point[i + 1] - point[i]) % (P - point[i]))){\n\t\t\t\tld t = (point[i + 1] - point[i]) * (P - point[i]) / (point[i + 1] - point[i]).len2();\n\t\t\t\tif(t > -eps && t < 1 + eps)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\treturn 0;\n\t}\n};\n\nclass convex : public polygon{\npublic:\n\tld dosomething(){\n\t\tint cur = 0; ld ans = 0;\n\t\tfor(int i = 1 ; i < sz ; ++i)\n\t\t\tif((point[i] - point[0]).len() > (point[cur] - point[0]).len())\n\t\t\t\tcur = i;\n\t\tfor(int i = 0 ; i < sz ; ++i){\n\t\t\twhile((point[i + 1] - point[i]) % (point[cur] - point[i]) <= (point[i + 1] - point[i]) % (point[cur + 1] - point[i])) ++cur;\n\t\t\tans = max(ans , max((point[cur] - point[i]).len() , (point[cur] - point[i + 1]).len()));\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nconvex getconvex(polygon now){\n\tvector < vec > p , p1; convex ans;\n\tp.insert(p.begin() , now.point.begin() , now.point.begin() + now.sz);\n\tsort(p.begin() , p.end() , [&](vec a , vec b){return a.y < b.y || a.y == b.y && a.x < b.x;});\n\tdeque < vec > q;\n\tfor(auto t : p){\n\t\twhile(q.size() >= 2 && (q[q.size() - 1] - q[q.size() - 2]) % (t - q[q.size() - 2]) < eps)\n\t\t\tq.pop_back();\n\t\tq.push_back(t);\n\t}\n\tq.pop_back(); p1.insert(p1.end() , q.begin() , q.end()); reverse(p.begin() , p.end()); q.clear();\n\tfor(auto t : p){\n\t\twhile(q.size() >= 2 && (q[q.size() - 1] - q[q.size() - 2]) % (t - q[q.size() - 2]) < eps)\n\t\t\tq.pop_back();\n\t\tq.push_back(t);\n\t}\n\tq.pop_back(); p1.insert(p1.end() , q.begin() , q.end());\n\tp1.insert(p1.end() , p1.begin() , p1.end());\n\tans.point = p1; ans.sz = p1.size() / 2; return ans;\n}\n\nint main(){\n\tconvex now; now.input(); cout << fixed << setprecision(10) << now.dosomething() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\ndouble add(double a, double b)\n{\n\tif (abs(a + b) < EPS * (abs(a) + abs(b))) {\n\t\treturn 0;\n\t}\n\treturn a + b;\n}\n\nstruct P\n{\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {}\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d) {\n\t\treturn P(x*d, y*d);\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n};\n\nint n;\nP ps[MAX_N];\n\nbool cmp_x(const P& p, const P& q)\n{\n\tif (p.x != q.x) {\n\t\treturn p.x < q.x;\n\t}\n\treturn p.y < q.y;\n}\n\nvector<P> convex_hull(P* ps, int n)\n{\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;\n\tvector<P> qs(n * 2);\n\trep(i, n) {\n\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) {\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = n - 2, t = k;i >= 0;i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) {\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\ndouble dist(P p, P q)\n{\n\treturn (p - q).dot(p - q);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf%lf\", &a, &b);\n\t\tps[i] = P(a, b);\n\t}\n\tvector<P> qs = convex_hull(ps, n);\n\tif (qs.size() == 2) {\n\t\tprintf(\"%.0f\\n\", dist(qs[0], qs[1]));\n\t\treturn 0;\n\t}\n\tint i = 0, j = 0;\n\trep(k, qs.size()) {\n\t\tif (!cmp_x(qs[i], qs[k])) {\n\t\t\ti = k;\n\t\t}\n\t\tif (cmp_x(qs[j], qs[k])) {\n\t\t\tj = k;\n\t\t}\n\t}\n\tdouble res = 0;\n\tint si = i, sj = j;\n\twhile (i != sj || j != si) {\n\t\tres = max(res, dist(qs[i], qs[j]));\n\t\tif ((qs[(i + 1) % qs.size()] - qs[i]).det(qs[(j + 1) % qs.size()] - qs[j]) < 0) {\n\t\t\ti = (i + 1) % qs.size();\n\t\t}\n\t\telse {\n\t\t\tj = (j + 1) % qs.size();\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\", sqrt(res));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nint dcmp(double x) {\n    static double eps = 1e-8;\n    return (x > eps) - (x < -eps);\n}\n\nstruct vec{\n    double x, y;\n\n    vec(double _x=0, double _y=0)\n        :x(_x), y(_y) {}\n\n    vec operator- () const{ return vec(-x, -y); }\n    \n    vec operator+ (const vec& v) const{ return vec(x+v.x, y+v.y); }\n    vec operator- (const vec& v) const{ return vec(x-v.x, y-v.y); }\n    vec operator* (double c) const{ return vec(x*c, y*c); }\n    vec operator/ (double c) const{ return vec(x/c, y/c); }\n\n    double dot(const vec& v) const{ return x*v.x + y*v.y; }\n    double cross(const vec& v) const{ return x*v.y - y*v.x; }\n\n    double len2() const{ return x*x + y*y; }\n    double len() const{ return sqrt(len2()); }\n    \n    vec& norm() { return *this = *this / len(); }\n    vec& rot(double rad) {\n        return  *this = vec(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad));\n    }\n\n    bool operator< (const vec& v) const{\n        return dcmp(x-v.x) < 0 || (dcmp(x-v.x)==0 && dcmp(y-v.y) < 0);\n    }\n};\n\nstruct line{\n    vec u, v; // u + x*v\n\n    line() {}\n    line(vec _u, vec _v)\n        :u(_u), v(_v) {}\n\n    vec get(double x) {\n        return u + v * x;\n    }\n};\n\nline makeline(vec a, vec b) {\n    return line(a, b - a);\n}\n\nbool on_left(line l, vec u) {\n    return dcmp(l.v.cross(u - l.u)) > 0;\n}\n\nvec line_intersection(line a, line b) {\n    return b.u + b.v * b.v.cross(b.u-a.u) / a.v.cross(b.v);\n}\n\nbool segment_intersection(vec a, vec b, vec c, vec d) {\n    line x = line(a, b-a), y = line(c, d-c);\n    return on_left(x, c) != on_left(x, d) && on_left(y, a) != on_left(y, b);\n}\n\nstd::vector<vec> convex_hull(std::vector<vec> p) {\n    std::sort(p.begin(), p.end());\n    std::vector<vec> ch;\n    for (size_t i = 0; i < p.size(); ++i) {\n        while (ch.size() > 1 && on_left(makeline(ch[ch.size()-2], p[i]), ch[ch.size()-1]))\n            ch.pop_back();\n        ch.push_back(p[i]);\n    }\n    size_t k = ch.size();\n    for (int i = p.size() - 2; i >= 0; --i) {\n        while (ch.size() > k && on_left(makeline(ch[ch.size()-2], p[i]), ch[ch.size()-1]))\n            ch.pop_back();\n        ch.push_back(p[i]);\n    }\n    ch.pop_back();\n    return ch;\n}\n\ndouble convex_diameter(const std::vector<vec> &p) {\n  int is = 0, js = 0;\n  for (size_t i = 1; i < p.size(); ++i) {\n    if (p[i].x > p[is].x) is = i;\n    if (p[i].x < p[js].x) js = i;\n  }\n  double maxd = (p[is]-p[js]).len2();\n  \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n      if ((p[i] - p[(i + 1)%p.size()]).cross(p[j] - p[(j + 1)%p.size()]) >= 0) j = (j+1) % p.size();\n      else i = (i+1) % p.size();\n      if ((p[i]-p[j]).len2() > maxd) {\n          maxd = (p[i]-p[j]).len2();\n          maxi = i; maxj = j;\n      }\n  } while (i != is || j != js);\n  return sqrt(maxd);\n}\n\n// end template\n\nint main() {\n    std::vector<vec> p;\n    int n;\n    double x,y;\n    for(scanf(\"%d\",&n);n--;p.push_back(vec(x, y)))\n        scanf(\"%lf%lf\",&x,&y);\n    printf(\"%f\\n\",convex_diameter(p));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AC -> Aizu CGL 4B\n\n#include <bits/stdc++.h>\n\n#define forn(i,n) for(int i = 0; i < int(n); i++)\n#define forsn(i,s,n) for(int i = int(s); i < int(n); i++)\n#define dforn(i,n) for (int i = int(n)-1; i >= 0; i--)\n#define dforsn(i,s,n) for(int i = int(n)-1; i >= int(s); i--)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fst first\n#define snd second\n#define FAST_IO ios::sync_with_stdio(false);cin.tie(nullptr);\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\nconst double EPS = 1e-6; // margin of error\n\nstruct pt {\n    double x,y;\n    pt(double x, double y) : x(x),y(y){}\n    pt(){}\n\n    double norm2() {return (*this) * (*this);} // modulo of vector, squared\n    double norm() {return sqrt(norm2());}\n    pt operator* (const double &t) const {return pt(x*t,y*t);}\n    pt operator- (const pt &o) const {return pt(x-o.x, y-o.y);}\n    double operator% (const pt &o) const {return x*o.y - y*o.x;} // cross product\n    double operator* (const pt &o) const {return x*o.x + y*o.y;} // dot product\n    bool operator< (const pt &o) const { // chull sort cmp\n        return (x < o.x || (x == o.x && y < o.y));\n    }\n    bool left (const pt &a, const pt &b) {return (b-a)%(*this-a) >= 0;}\n};\n\nvector<pt> chull (vector<pt> &p) {\n    vector<pt> r;\n    sort(all(p));\n    forn (i,p.size()) { // lower hull\n        while (r.size() >= 2 and r.back().left(r[r.size()-2],p[i])) r.pop_back();\n        r.pb(p[i]);\n    }\n    r.pop_back(); int k = r.size();\n    dforn (i,p.size()) { // upper hull\n        while (r.size() >= k+2 and r.back().left(r[r.size()-2],p[i])) r.pop_back();\n        r.pb(p[i]);\n    }\n    r.pop_back();\n    return r;\n}\n\nstruct poly {\n    int n; vector<pt> p;\n    poly(){}\n    poly(vector<pt> _p) {p=_p; n=p.size();}\n\n    double callipers() { // returns square of max dist\n        double r = 0;\n        int j = (n >= 2); // doesn't exist if there's no such pair of points\n        forn (i,j) {\n            for(;;j=(j+1)%n) {\n                r = max(r,(p[i]-p[j]).norm2());\n                if ( ((p[(i+1)%n] - p[i]) % (p[(j+1)%n] - p[j])) <= 0) break;\n            }\n        }\n        return r;\n    }\n};\n\nvector<pt> p;\n\nint main() {\n    FAST_IO;\n\n    int n; cin >> n;\n\n    forn (i,n) {\n        double x,y; cin >> x >> y;\n        p.pb({x,y});\n    }\n\n    cout << setprecision(10) << sqrt(poly(chull(p)).callipers());\n\n    return 0;\n}\n\n/// ESCRIBÍ en vez de tanto dar vueltas\n/// si te parece que no va PROBALO PRIMERO!\n/// CODEA LO BÁSICO PRIMERO!\n/// HACE C-A-S-O-S D-E P-R-U-E-B-A.A.A.A.A!!!\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nint main(){\n\tint n;\n\tdouble max = 0;\n\tdouble dist;\n\tdouble temp_dist;\n\tstd::vector< double > x, y;\n\t\n\tstd::cin >> n;\n\tx.resize(n);\n\ty.resize(n);\n\t\n\tfor(int i=0;i<n;++i){\n\t\tstd::cin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i=0;i<n;++i){\n\t\ttemp_dist = 0;\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tdist = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);\n\t\t\t\n\t\t\tif(dist > max) max = dist;\n\t\t\tif(temp_dist - dist > 0)break;\n\t\t}\n\t}\n\t\n\tstd::cout << std::setprecision(15) << sqrt(max) << std::endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHell( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    int i = 0;\n    while(i < u.size() - 1){\n        if(u[i].imag() > u[i + 1].imag()){\n            u.emplace_back(u[i]);\n            u.erase(u.begin());\n            continue;\n        }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n            u.emplace_back(u[i]);\n            u.erase(u.begin());\n            continue;\n        }\n        break;\n    }\n\n    return u;\n}\n\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHell(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    Polygon g,l;\n    rep(i,n){\n        double a, b;\n        cin >> a >> b;\n        g.emplace_back(Point{a,b});\n    }\n    cout << fixed << setprecision(8) <<  diameterOfConvexPolygon(g) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\t\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    R res=0.0;\n\trep(k,4*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))>=0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n//-------------------------------------------------------------------------------------\n/*線分にたいして点(px,py)が垂線をおろすことができればtrue*/\n\nbool perpendicular_to_the_line_segment_from_the_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    \n    if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n        //cout<<\"a \";\n        return true;\n    }else{//(v_x,v_y)は線分の外にある\n        return false;\n    }\n    \n    \n}\n\n\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*凸包の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][0]<ch[k][0]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res = 0;\n    while(1){\n        if(i==sj||j==si)break;\n\n        res = distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n        if(perpendicular_to_the_line_segment_from_the_point(ch[sj][0], ch[sj][1], ch[si][0], ch[si][1], ch[(si+1)%n][0], ch[(si+1)%n][1])){\n            si=(si+1)%n;\n        }else{\n            sj=(sj+1)%n;\n        }\n    }\n    \n    return res;\n}\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        /*\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n         */\n        \n        double max_l = diameter_of_the_polygon(n, p_xy);\n        \n        \n\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\nusing namespace std;\n\ntemplate <class T> void readPoint(vector< vector<T> >& vec, int idx) {\n    T x, y;\n    vector<T> point(2);\n    std::cin >> x >> y;\n    point[0] = x;\n    point[1] = y;\n    vec[idx] = point;\n}\ndouble dist(double x1, double y1, double x2, double y2) {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\nint main()\n{\n    int size;\n    cin >> size;\n    vector< vector<int> > points(size);\n    for (int i = 0; i < size; i++) {\n        readPoint(points, i);\n    }\n    int prev_idx(0), cur_idx(0), max_idx(0), max_dia(0);\n    double dia;\n    do {\n        prev_idx = cur_idx;\n        cur_idx = max_idx;\n        for (int i = 0; i < size; i++) {\n             dia = dist(points[cur_idx][0], points[cur_idx][1], points[i][0], points[i][1]);\n             if (dia > max_dia) {\n                 max_idx = i;\n             }  \n        }\n    } while (prev_idx != max_idx);\n    \n\n    cout << max_dia << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n\ntypedef long long ll;\n\nstruct ConvexHull {\n    \n    struct Point {\n        double x,y;\n        Point () {}\n        Point (double _x, double _y) : x(_x), y(_y) {}\n        bool operator < (const Point &a) const {\n            return (x == a.x) ? (y < a.y) : (x < a.x);\n        }\n    };\n    \n    double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }\n    double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }\n    double norm(Point a) { return sqrt(dot(a, a) * dot(a, a)); }\n    Point sub(Point a, Point b) { return Point(a.x - b.x, a.y - b.y); }\n    \n    vector< Point > Pos;\n    vector< Point > CHPos;\n    \n    int counter_clockwise(Point p0, Point p1, Point p2) {\n        Point a = sub(p1, p0);\n        Point b = sub(p2, p0);\n        if (cross(a,b) > 1.0e-8) return 1;\n        if (cross(a,b) < -1.0e-8) return -1;\n        if (dot(a,b) < -1.0e-8) return 2;\n        if (norm(a) < norm(b)) return 2;\n        return 0;\n    }\n    \n    void add_point(double x, double y) {\n        Pos.push_back(Point(x, y));\n    }\n    \n    void build() {\n        int n = (int) Pos.size(), k = 0;\n        sort(Pos.begin(),Pos.end());\n        vector< Point > ch(2 * n);\n        for (int i = 0; i < n; ch[k++] = Pos[i++]) {\n            while (k >= 2 && counter_clockwise(ch[k-2], ch[k-1], Pos[i]) <= 0) --k;\n        }\n        for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = Pos[i--]) {\n            while (k >= t && counter_clockwise(ch[k-2], ch[k-1], Pos[i]) <= 0) --k;\n        }\n        copy(ch.begin(), ch.begin() + k - 1, back_inserter(CHPos));\n    }\n    \n    double diameter() {\n        int n = (int) CHPos.size();\n        int is = 0, js = 0;\n        for (int i = 1; i < n; i++) {\n            if (CHPos[i].y > CHPos[is].y) is = i;\n            if (CHPos[i].y < CHPos[js].y) js = i;\n        }\n        double maxd = norm(sub(CHPos[is], CHPos[js]));\n        int i = is, maxi = is;\n        int j = js, maxj = js;\n        do{\n            if (cross(sub(CHPos[(i + 1) % n], CHPos[i]), sub(CHPos[(j + 1) % n], CHPos[j])) >= 0) {\n                j = (j + 1) % n;\n            } else {\n                i = (i + 1) % n;\n            }\n            if(norm(sub(CHPos[i], CHPos[j])) > maxd) {\n                maxd = norm(sub(CHPos[i], CHPos[j]));\n                maxi = i, maxj = j;\n            }\n        } while (i != is || j != js);\n        return sqrt(maxd);\n    }\n    \n    int size() {\n        return (int) CHPos.size();\n    }\n    \n    Point operator [] (int n) {\n        return CHPos[n];\n    }\n    \n};\n\nint main(){\n    \n    int n; cin >> n;\n    \n    ConvexHull inst;\n    REP(i,n) {\n        double x,y; cin >> x >> y;\n        inst.add_point(x, y);\n    }\n    \n    inst.build();\n    \n    cout << fixed << setprecision(10) << inst.diameter() << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int i = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int j = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int maxi, maxj;\n    LD maxd = 0;\n    for(; i < 2*n; i++){\n        if(maxd < norm(cpol[i]-cpol[j])){\n            maxd = norm(cpol[i] - cpol[j]);\n            maxi = i;\n            maxj = j;\n        }\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) <= 0) j = (j+1) % n;\n        else i = (i+1) % n; \n    }\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n    pair<int, int> ans = ConvexPolygonDiameter(p);\n    printf(\"%.9Lf\\n\", DistPP(p[ans.first], p[ans.second]));\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst double eps = 1e-10;\nclock_t START, END;\n\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n};\ntypedef Point Vector;\nVector operator - (const Point& A, const Point& B) { return Vector(A.x - B.x, A.y - B.y); }\nint dcmp(double x) { if (fabs(x) < eps)return 0; else return x < 0 ? -1 : 1; }\ndouble Cross(Vector A, Vector B) { return A.x * B.y - A.y * B.x; }\ndouble Dot(const Vector& A, const Vector& B) { return A.x * B.x + A.y * B.y; }\ndouble Distance(Point u, Point v) {\n\treturn sqrt(fabs((u.x - v.x) * (u.x - v.x)) + fabs((u.y - v.y) * (u.y - v.y)));\n}\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t};\n\tint n;\n\tdouble x, y, ans;\n\tvector<Point> p;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\tp.push_back(Point(x, y));\n\t}\n\tp.push_back(p[0]);\n\tfor (int u = 0, v = 1; u < n; u++) {\n\t\tbool rev = false;\n\t\tfor (;;) {\n\t\t\tint diff = dcmp(Cross(p[u + 1] - p[u], p[v + 1] - p[v]));\n\t\t\tif (diff)\n\t\t\t\trev = true;\n\t\t\tif (diff <= 0 && rev) {\n\t\t\t\tans = max(ans, Distance(p[u], p[v]));\n\t\t\t\tif (diff == 0)\n\t\t\t\t\tans = max(ans, Distance(p[u], p[v + 1]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv = (v + 1) % n;\n\t\t}\n\t}\n\tprintf(\"%.6lf\\n\", ans);\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\ntypedef double number;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<number> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ntypedef vector<P> G;\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnumber convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  number maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return maxd; /* farthest pair is (maxi, maxj). */\n}\n\nint main(){\n\tG poly;\n\tP p;\n\tint n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);n--;poly.push_back(p))scanf(\"%lf%lf\",&x,&y),p=P(x,y);\n\tprintf(\"%f\\n\",sqrt(convex_diameter(poly)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define scanf nope\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntemplate <class T>\nstruct Point {\n\ttypedef Point P;\n\tT x, y;\n\texplicit Point(T x=0, T y=0) : x(x), y(y) {}\n\tbool operator<(P p) const { return x<p.x||(x==p.x && y<p.y);}\n\tbool operator==(P p) const { return x==p.x && y==p.y; }\n\tP operator+(P p) const { return P(x+p.x, y+p.y); }\n\tP operator-(P p) const { return P(x-p.x, y-p.y); }\n\tP operator*(T d) const { return P(x*d, y*d); }\n\tP operator/(T d) const { return P(x/d, y/d); }\n\tT dot(P p) const { return x*p.x + y*p.y; }\n\tT cross(P p) const { return x*p.y - y*p.x; }\n\tT cross(P p1, P p2) const { return (p1 - *this).cross(p2 - *this); }\n\tT dist2() const { return x*x + y*y; }\n\tdouble dist() const { return sqrt((double)dist2()); }\n\t// angle to x-axis in interval [-pi, pi]\n\tdouble angle() const { return atan2(y, x); }\n\tP unit() const { return *this/dist(); } // makes dist()=1\n\tP perp() const { return P(-y, x); } // rotates +90 degrees\n\tP normal() const { return perp().unit(); }\n\t// returns point rotated 'a' radians ccw around the origin\n\tP rotate(double a) const {\n\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n};\n\ntypedef Point<double> P;\npair<vi, vi> ulHull(const vector<P>& S) {\n    vector<int> Q(sz(S));\n    iota(all(Q), 0);\n    sort(all(Q), [&S](int a, int b){ return S[a] < S[b]; });\n    vi U, L;\n    trav(it, Q) {\n        while (sz(U) > 1 && S[U[sz(U)-2]].cross(S[it], S[U.back()]) <= 0) U.pop_back();\n        while (sz(L) > 1 && S[L[sz(L)-2]].cross(S[it], S[L.back()]) >= 0) L.pop_back();\n        U.push_back(it);\n        L.push_back(it);\n    }\n    return make_pair(U, L);\n}\n\nvi convexHull(const vector<P>& S) {\n    vi u, l;\n    tie(u, l) = ulHull(S);\n    if (sz(S) <= 1) return u;\n    u.pop_back();\n    reverse(all(u));\n    u.pop_back();\n    u.insert(u.end(), all(l));\n    if (sz(u) == 2 && S[u[0]] == S[u[1]]) u.pop_back();\n    return u;\n}\n\nvector<pii> antipodal(const vector<P>& S, const vi& U, const vi& L) {\n    vector<pii> A;\n    int i = 0;\n    int j = sz(L) - 1;\n    while (i < sz(U) - 1 || j > 0) {\n        A.emplace_back(U[i], L[j]);\n        if (i != sz(U) - 1 && (j == 0 || (S[L[j]] - S[L[j-1]]).cross((S[U[i+1]] - S[U[i]])) > 0)) ++i;\n        else --j;\n    }\n    return A;\n}\n\npii polygonDiameter(const vector<P>& S) {\n    vi U, L;\n    tie(U, L) = ulHull(S);\n    pair<double, pii> ans;\n    trav(it, antipodal(S, U, L)) {\n        ans = max(ans, make_pair((S[it.first] - S[it.second]).dist2(), it));\n    }\n    return ans.second;\n}\n\nint main() {\n    int N;\n    cin >> N;\n        vector<P> P(N);\n        rep(i,0,N) cin >> P[i].x >> P[i].y;\n        pii ret = polygonDiameter(P);\n        cout << setprecision(10) << fixed << (P[ret.first] - P[ret.second]).dist() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\n\nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end());\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=andrewScan(s);\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  //cout<<i<<\" \"<<j<<endl;\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    //cout<<i<<\" \"<<j<<endl;\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\nusing namespace std;\n\nconst double eps = 1e-10;\n\nint dcmp(double x) {\n        if(fabs(x) < eps) return 0;\n        return x < 0 ? -1 : 1;\n}\n\nbool same(double a, double b) {return dcmp(a - b) == 0;}\n#define Vector P\nstruct P {\n        double x, y;\n        P(double x = 0, double y = 0): x(x), y(y) {}\n        P operator + (P b) {return P(x + b.x, y + b.y);}\n        P operator - (P b) {return P(x - b.x, y - b.y);}\n        P operator * (double b) {return P(x * b, y * b);}\n        P operator / (double b) {return P(x / b, y / b);}\n        double operator * (P b) {return x * b.x + y * b.y;} // Dot\n        double operator ^ (P b) {return x * b.y - y * b.x;} // Cross\n        double abs() {return hypot(x, y);}\n        P unit() {return *this / abs();}\n        P spin(double o) {\n                double c = cos(o), s = sin(o);\n                return P(c * x - s * y, s * x + c * y);\n        }\n};\n\nstruct Line {\n        //ax + by + c = 0\n        double a, b, c, theta;\n        P pa, pb;\n        Line(): a(0), b(0), c(0), theta(0), pa(), pb() {}\n        Line(P pa, P pb): a(pa.y - pb.y), b(pb.x - pa.x), c(pa ^ pb), theta(atan2(-a, b)), pa(pa), pb(pb) {}\n                P projection(P p) {return pa + (pb - pa).unit() * ((pb - pa) * (p - pa) / (pb - pa).abs());}\n                P reflection(P p) {return p + (projection(p) - p) * 2;}\n        double get_ratio(P p) {return (p - pa) * (pb - pa) / ((pb - pa).abs() * (pb - pa).abs());}\n        P dis(P p) {return ((pb - pa) ^ (p - pa)) / (pb - pa).abs();} // directed distance\n};\n\nstruct Circle {\n        P c;\n        double r;\n        Circle(P c, double r = 0): c(c), r(r) {}\n};\ndouble dis(P a, P b) {return (a - b).abs();}\nvector<P> ps;\ndouble rotating(vector<P> ps, int id) {\n        // ps must be convex and sorted by counterclockwise order, id is the rightmost point index\n        int n = int(ps.size());\n        int l = 0, r = id;\n        double res = dis(ps[0], ps[r]);\n        while(l < id || r < n - 1) {\n                if(l < id && r < n - 1) {\n                        Vector rvec = ps[r + 1] - ps[r];\n                        Vector lvec = ps[l + 1] - ps[l];\n                        if(dcmp(lvec ^ rvec) == -1) l++;\n                        else r++;\n                }\n                else if(l == id) r++;\n                else l++;\n                res = max(res, dis(ps[l], ps[r]));\n        }\n        return res;\n}\nint main() {\n        ios_base::sync_with_stdio(false); cin.tie(0);\n        int n; cin >> n;\n        for(int i = 0; i < n; i++) {\n                P p; cin >> p.x >> p.y;\n                ps.push_back(p);\n        }\n                int id = 0;\n                for(int i = 1; i < n; i++)\n                        if(dcmp(ps[i].x - ps[id].x) == 1) id = i;\n                double ans = rotating(ps, id);\n        cout << fixed << setprecision(12) << ans << '\\n';\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i = (a); i < (b); ++i)\n#define per(i, a, b) for(int i = (b) - 1; i >= (a); --i)\n#define sz(a) (int)a.size()\n#define de(c) cout << #c << \" = \" << c << endl\n#define dd(c) cout << #c << \" = \" << c << \" \"\n#define all(a) a.begin(), a.end()\n#define pw(x) (1ll<<(x))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef db T;\nconst db eps = 1e-9 , pi = acosl(-1.);\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n  T x,y; P(){} P(T x,T y):x(x),y(y){}\n  P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n  P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n  T operator * (const P&b) const {return x*b.x+y*b.y;}\n  T operator / (const P&b) const {return x*b.y-y*b.x;}\n  P operator * (const T&k) const {return P(x*k,y*k);}\n  P operator / (const T&k) const {return P(x/k,y/k);}\n\tbool operator < (const P&b) const {return sgn(x-b.x)?x<b.x:y<b.y;}\n};\nT norm(P a){return a*a;}\nT abs(P a) {return sqrtl(norm(a));}\nP proj(P p,P a,P b){return (b-a)*((p-a)*(b-a)/norm(b-a))+a;}\nP reflect(P p,P a,P b){return proj(p,a,b)*2-p;}\nT cross(P o,P a,P b){return (a-o)/(b-o);}\nint crossOp(P o,P a,P b){return sgn(cross(o,a,b));}\nbool onPS(P p,P s,P t){return sgn((t-s)/(p-s))==0&&sgn((p-s)*(p-t))<=0;}\nstruct L{ P s,t;L(){} L(P s,P t):s(s),t(t){}};\nP insLL(L a,L b){ // line x line\n\tP s = a.s - b.s , v = a.t - a.s , w = b.t - b.s;\n\tdb k1 = s / w , k2 = w / v;\n\tif(sgn(k2) == 0) return abs(b.s - a.s) < abs(b.t - a.s) ? b.s : b.t;\n\treturn a.s + v * (k1 / k2);\n}\nbool isSS(L a,L b){ // seg x seg , replace x->y to accelerate\n\tT c1=(a.t-a.s)/(b.s-a.s),c2=(a.t-a.s)/(b.t-a.s);\n\tT c3=(b.t-b.s)/(a.s-b.s),c4=(b.t-b.s)/(a.t-b.s);\n\treturn sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n\t\tsgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n\t\tsgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n\t\tsgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n\t\tsgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\ndb disPL(P p,L a){return fabs((a.t-a.s)/(p-a.s)) / abs(a.t-a.s);}\ndb disPS(P p,L a){ // p x seg dis\n\tif(sgn((a.t-a.s)*(p-a.s)) == -1) return abs(p-a.s);\n\tif(sgn((a.s-a.t)*(p-a.t)) == -1) return abs(p-a.t);\n\treturn disPL(p,a);\n}\ndb disSS(L a,L b){ // seg x seg dis\n\tif(isSS(a,b)) return 0;\n\treturn min(min(disPS(a.s,b),disPS(a.t,b)),min(disPS(b.s,a),disPS(b.t,a)));\n}\ntypedef vector<P> polygon;\npolygon convex(polygon A){ // counter-clockwise , < : <=180 , <= : <180\n  int n=sz(A),m=0;\n  polygon B;B.resize(n<<1);\n  sort(all(A));\n  rep(i,0,n){\n    while(m > 1 && sgn((B[m-1]-B[m-2])/(A[i]-B[m-2]))<0) --m;\n    B[m++]=A[i];\n  }\n  int k = m;\n  per(i,0,n-1){\n    while(m > k && sgn((B[m-1]-B[m-2])/(A[i]-B[m-2]))<0) --m;\n    B[m++]=A[i];\n  }\n  B.resize(m);\n  if(sz(B) > 1) B.pop_back();\n  return B;\n}\nT area(polygon A) { // multiple 2 with integer type\n\tT res=0;\n\trep(i,0,sz(A)) res+=A[i]/(A[(i+1)%sz(A)]);\n\treturn fabs(res) / 2;\n}\nbool isconvex(polygon A){ // counter-clockwise\n\tbool ok=1;int n=sz(A);\n\trep(i,0,2) A.pb(A[i]);\n\trep(i,0,n) ok&=((A[i+1]-A[i])/(A[i+2]-A[i]))>=0;\n\treturn ok;\n}\nint inPpolygon(P p,polygon A){ // -1 : on , 0 : out , 1 : in\n\tint res=0;\n\trep(i,0,sz(A)){\n\t\tP u=A[i],v=A[(i+1)%sz(A)];\n\t\tif(onPS(p,u,v)) return -1;\n\t\tT cross = sgn((v-u)/(p-u)) , d1 = sgn(u.y-p.y) , d2 = sgn(v.y-p.y);\n\t\tif(cross > 0 && d1 <= 0 && d2 > 0) ++res;\n\t\tif(cross < 0 && d2 <= 0 && d1 > 0) --res;\n\t}\n\treturn res != 0;\n}\nT diameter(polygon A) { // longest distance\n  int n=sz(A);if(n <= 1) return 0;\n  int l=0,r=0;rep(i,1,n) (A[i]<A[l])&&(l=i),(A[r]<A[i])&&(r=i);\n  db res=abs(A[l]-A[r]);int i=l,j=r;\n  do (++((A[(i+1)%n]-A[i])/(A[(j+1)%n]-A[j])>=0?j:i))%=n,\n    res=max(res,abs(A[i]-A[j]));\n  while(i!=l||j!=r);\n  return res;\n}\n\nP a, b, c, d;\npolygon poly;\n\nint main() {\n\tstd::ios::sync_with_stdio(0);\n\tstd::cin.tie(0);\n//\tfreopen(\"a.in\", \"r\", stdin);\n//\tfreopen(\"a.out\", \"w\", stdout);\n\tint q;\n\tcin >> q;\n\tcout << setiosflags(ios::fixed);\n\tcout << setprecision(10);\n\twhile(q--) {\n\t\tcin >> a.x >> a.y;\n\t\tpoly.pb(a);\n\t}\n\tcout << diameter(poly) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \nconst double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n  \nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n  \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n  \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n  \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < -EPS)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n  \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n  \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n};\n\nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\nint main(){\n  int n;\n  cin >> n;\n  Geometory::Polygon g(n);\n  for(int i = 0; i < n; i++){\n    cin >> g[i];\n  }\n  g = geo.Convex_Hull(g);\n  double ret = 0;\n  for(int i = 0; i < g.size() - 1; i++){\n    for(int j = g.size() - 1; j > i; j--){\n      ret = max( ret, (g[i]-g[j]).abs());\n    }\n  }\n  cout << fixed << setprecision(10) << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<n;++i)\ntypedef long long ll;\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// 点\nstruct Point {\n    double x,y;\n    Point(){}\n    Point(double x, double y) : x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x, y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x, y-p.y);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    Point operator/(double k){return Point(x/k,y/k);}\n    double norm(){return x*x+y*y;}\n    double abs(){sqrt(norm());}\n    bool operator == (const Point &p) const {return equals(x,p.x)&&equals(y,p.y);}\n    bool operator < (const Point &p) const {\n        return x!=p.x?x<p.x:y<p.y;\n        //grid-point only\n        //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n    }\n\n};\n\ntypedef Point P;\ntypedef vector<Point> Polygon;\n\ndouble norm(P a){return a.x*a.x+a.y*a.y;}\ndouble abs(P a){return sqrt(norm(a));}\n\n// 線分\nstruct Segment {\n    Point p1,p2;\n    Segment(){}\n    Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\n\ntypedef Segment Line;\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c, double r):c(c),r(r){}\n};\n\n// 法線ベクトル\nPoint normal(Point p){return Point(-p.y,p.x);}\n\n// 内積\ndouble dot(Point a, Point b) {return a.x*b.x + a.y*b.y;}\n\n// 外積\ndouble cross(Point a, Point b) {return a.x*b.y-a.y*b.x;}\n// 2直線の直行判定\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return equals(dot(a1-a2, b1-b2), 0.0);\n}\n// 2直線の平行判定\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n    return equals(cross(a1-a2, b1-b2), 0.0);\n}\n// 点cが直線ab上にあるかないか\nbool is_point_on_INF_line(Point a, Point b, Point c) {\n    return equals(cross(b-a,c-a), 0.0);\n}\n// 点cが線分ab上にあるかないか\nbool is_point_on_LIMITED_line(Point a, Point b, Point c) {\n    return (Point(a-c).abs()+Point(c-b).abs() < Point(a-b).abs() + EPS);\n}\n// 直線と点の距離\ndouble distance_l_p(Point a, Point b, Point c) {return abs(cross(b-a, c-a)) / (b-a).abs();}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(Point a, Point b, Point c) {\n    if (dot(b-a, c-a) < EPS) return (c-a).abs();\n    if (dot(a-b, c-b) < EPS) return (c-b).abs();\n    return abs(cross(b-a, c-a)) / (b-a).abs();\n}\n\n// 点が線分のどちら側にあるかを計算\nint ccw(Point p0,Point p1,Point p2) {\n    P a = p1-p0;\n    P b = p2-p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0&&ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool intersectSS(Segment s1, Segment s2) {\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n// 直線と点の距離\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\n// 線分と点の距離\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\n// 線分と線分の距離\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(intersectSS(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\n// 前提として交差していることが必要\nP getCrossPointSS(P a1, P a2, P b1, P b2) {\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1/(d1+d2);\n    return a1+(a2-a1)*t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\n// 前提として平行でないことが必要\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2-a1; P b = b2-b1;\n    return a1+a*cross(b, b1-a1)/cross(b, a);\n}\n\n// 射影\nPoint project(Segment s, Point p) {\n    Point base = s.p2-s.p1;\n    double r = dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\ndouble area(Polygon s){\n    double res=0;\n    for(int i=0;i<(int)s.size();i++){\n        res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n    }\n    return res;\n}\n\nbool isConvex(Polygon p){\n    bool f=1;\n    int n=p.size();\n    for(int i=0;i<n;i++){\n        int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n        f&=t!=CLOCKWISE;\n    }\n    return f;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n    }\n    return (x?2:0);\n}\n\nbool sort_x(Point a,Point b){\n    return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n    return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\nPolygon convex_hull(Polygon ps){\n    int n=ps.size();\n    sort(ps.begin(),ps.end(),sort_y);\n    int k=0;\n    Polygon qs(n*2);\n    for(int i=0;i<n;i++){\n        while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n        qs[k++]=ps[i];\n    }\n    for(int i=n-2,t=k;i>=0;i--){\n        while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\ndouble diameter(Polygon s){\n    Polygon p=s;\n    int n=p.size();\n    if(n==2) return abs(p[0]-p[1]);\n    int i=0,j=0;\n    for(int k=0;k<n;k++){\n        if(p[i]<p[k]) i=k;\n        if(!(p[j]<p[k])) j=k;\n    }\n    double res=0;\n    int si=i,sj=j;\n    while(i!=sj||j!=si){\n        res = max(res,abs(p[i]-p[j]));\n        if (cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n            i=(i+1)%n;\n        }\n        else {\n            j=(j+1)%n;\n        }\n    }\n    return res;\n}\n\nint main(int argc, char const *argv[]) {\n    int n;cin>>n;\n    Polygon pl;\n    rep(i,n) {\n        double x,y;cin>>x>>y;\n        pl.push_back(Point(x,y));\n    }\n    cout << fixed << setprecision(13);\n    cout << diameter(pl) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n        \n        double max_l = 0.0;\n        for(int i=0; i<q; i++){\n            for(int j=0; j<i; j++){\n                double temp =max_l;\n                max_l=max(max_l,distance_between_the_two_pointss(ans[i][0], ans[i][1], ans[j][0], ans[j][1]));\n                if(temp==max_l)break;\n            }\n        }\n        \n        \n\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n#define DBG(n) n;\n#else\n#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define X real()\n#define Y imag()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\t\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\tif(intersectSP(s,t[0]) || intersectSP(s,t[1]) || intersectSP(t,s[0]) || intersectSP(t,s[1]))return true;\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tif(!intersectSS(l,m))return point(INF,INF);\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return point(INF,INF); // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nOUT:0\nON:1\nIN:2\n*/\n\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用) \nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a+b)/2.0;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= 0) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nint main() {\n\t\n\tint n;cin >> n;\n\tvector<point> v;\n\tREP(i,n){\n\t\tdouble a,b;cin >> a >> b;\n\t\tv.PB(point(a,b));\n\t}\n\t\n\tcout << Decimal <<  convex_diameter(v) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tR res=0.0;\n\tif(n<=10){\n\t\trep(j,n)rep(i,j) res=max(res,abs(pol[i]-pol[j]));\n\t\treturn res;\n\t}\n\t\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    rep(k,2*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\n\nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i].x<p[k].x||(p[i].x==p[k].x&&p[i].y<p[k].y)) i=k;\n    if(p[j].x>p[k].x||(p[i].x==p[k].x&&p[i].y>p[k].y)) j=k;\n  }\n  //cout<<i<<\" \"<<j<<endl;\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    //cout<<i<<\" \"<<j<<endl;\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+i)%n]-p[i],p[(j+1)%n]-p[j])<0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\ntypedef db T;\nconst db eps = 1e-8;\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n    T x,y;\n    P(){} P(T x,T y):x(x),y(y){}\n    void read(){scanf(\"%lf%lf\",&x,&y);}\n    P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n    P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n    T operator * (const P&b) const {return x*b.x+y*b.y;}\n    P operator * (const T&k) const {return P(x*k,y*k);}\n    T operator ^ (const P&b) const {return x*b.y-y*b.x;}\n    bool operator < (const P&b) const {return sgn(y-b.y)?y<b.y:x<b.x;}\n};\ndb abs(P a){return sqrt(a*a);}\ntypedef vector<P> polygon;\nT diameter(polygon A) {\n    int n=sz(A);if(n <= 1) return 0;\n    int l=0,r=0;rep(i,1,n) (A[i]<A[l])&&(l=i),(A[r]<A[i])&&(r=i);\n    db res=abs(A[l]-A[r]);int i=l,j=r;\n    do (++(((A[(i+1)%n]-A[i])^(A[(j+1)%n]-A[j]))>=0?j:i))%=n,\n        res=max(res,abs(A[i]-A[j]));\n    while(i!=l||j!=r);\n    return res;\n}\n\nint main(){\n    int n;scanf(\"%d\",&n);\n    polygon A;\n    rep(i,0,n){\n        P p;p.read();\n        A.pb(p);\n    }\n    printf(\"%.10f\\n\",diameter(A));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\n\nnamespace Geometry{\n    typedef long double D;\n    typedef complex<long double> P;\n    typedef pair<P,D> C;\n    \n    const D EPS=1e-9;\n    const D PI=asin(1)*2;\n    const D INF=1e18;\n    \n    const static bool comp(const P &p1,const P &p2){\n        if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n        return p1.real()<p2.real();\n    }\n    \n    const static bool comp_y(const P &p1,const P &p2){\n        if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n        return p1.imag()<p2.imag();\n    }\n    \n    D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n    D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n    P project(P vec,P x){return vec*(x/vec).real();}\n    \n    P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n    P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n    P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n    bool intersectSL(P p1,P p2,P vec){\n        vec/=abs(vec); p1/=vec; p2/=vec;\n        return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);\n    }\n    \n    bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n    bool intersectSS(P p1,P p2,P p3,P p4){\n        if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n        if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n        return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n    }\n    \n    D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n    D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n    D distSP(P p1,P p2,P x){\n        if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n        if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n        return distLP(p1,p2,x);\n    }\n    \n    D distSS(P p1,P p2,P p3,P p4){\n        if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n        return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n            distSP(p3,p4,p1),distSP(p3,p4,p2)});\n    }\n    \n    P crosspointLL(P p1,P p2,P vec){\n        if(abs(cross(p2-p1,vec))<EPS){return vec;}\n        return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n    }\n    \n    P crosspointLL(P p1,P p2,P p3,P p4){\n        return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n    }\n    \n    P crosspointSS(P p1,P p2,P p3,P p4){\n        if(distSP(p1,p2,p3)<EPS){return p3;}\n        if(distSP(p1,p2,p4)<EPS){return p4;}\n        return crosspointLL(p1,p2,p3,p4);\n    }\n    \n    bool intersectShL(P p1,P p2,P vec){\n        vec/=abs(vec);\n        return intersectSL(p1,p2,vec) &&\n        crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n    }\n    \n    bool intersectShL(P p1,P p2,P p3,P p4){\n        return intersectShL(p1-p3,p2-p3,p4-p3);\n    }\n    \n    //1::in,0::on edge,-1::out\n    int contain(const vector<P> &poly,const P &p){\n        vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n        int s=A.size();\n        vector<bool> cnt(s,false);\n        for(int i=0;i<(int)poly.size();i++){\n            int k=(i+1)%poly.size();\n            if(distSP(poly[i],poly[k],p)<EPS){return 0;}\n            for(int j=0;j<s;j++){\n                if(intersectShL(poly[i],poly[k],p,p+A[j])){cnt[j]=!cnt[j];}\n            }\n        }\n        int in=0;\n        for(int j=0;j<s;j++){if(cnt[j]){in++;}}\n        return in>s/2?1:-1;\n    }\n    \n    vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n        vector<P> ret;\n        for(int i=0;i<(int)poly.size();i++){\n            int j=(i+1)%poly.size();\n            if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n            if(intersectSL(poly[i],poly[j],p1,p2) &&\n               distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n                ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n            }\n        }\n        return ret;\n    }\n    \n    D area(const vector<P> &poly){\n        D ans=0;\n        for(int i=2;i<(int)poly.size();i++){\n            ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n        }\n        return abs(ans)/2;\n    }\n    \n    vector<P> convexhull(vector<P> pts){\n        vector<P> ret;\n        sort(pts.begin(),pts.end(),comp);\n        auto fnc=[&](){\n            for(auto &I:pts){\n                if(!ret.empty() && I==ret.back()){continue;}\n                while(ret.size()>=2 && cross(ret.back()-ret[ret.size()-2],I-ret.back())<-EPS){\n                    ret.pop_back();\n                }\n                ret.push_back(I);\n            }\n        };\n        fnc();\n        reverse(pts.begin(),pts.end());\n        fnc();\n        if(ret[0]==ret.back()){ret.pop_back();}\n        return ret;\n    }\n    \n    //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n    int intersectCC(C c1,C c2){\n        D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n        if(d<EPS && dif<EPS){return -1;}\n        if(d-r>EPS){return 4;}\n        if(d-r>-EPS){return 3;}\n        if(d-dif>EPS){return 2;}\n        if(d-dif>-EPS){return 1;}\n        return 0;\n    }\n    \n    vector<P> crosspointLC(P p1,P p2,C c){\n        vector<P> ret;\n        P pr=project(p1,p2,c.F);\n        D d=distLP(p1,p2,c.F);\n        if(d-c.S>EPS){return ret;}\n        if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n        P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n        ret.push_back(pr-vec);\n        ret.push_back(pr+vec);\n        return ret;\n    }\n    \n    vector<P> crosspointSC(P p1,P p2,C c){\n        vector<P> ret;\n        for(auto &I:crosspointLC(p1,p2,c)){\n            if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n        }\n        return ret;\n    }\n    \n    vector<P> crosspointCC(C c1,C c2){\n        vector<P> ret;\n        P vec=c2.F-c1.F;\n        D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n        D h=sqrt(c1.S*c1.S-base*base);\n        vec/=abs(vec);\n        ret.push_back(c1.F+vec*P(base,-h));\n        ret.push_back(c1.F+vec*P(base,h));\n        return ret;\n    }\n    \n    vector<P> tangentCP(C c,P p){\n        return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n    }\n    \n    vector<pair<P,P>> tangentCC(C c1,C c2){\n        vector<pair<P,P>> ret;\n        P d=c2.F-c1.F;\n        for(D i:{-1,1}){\n            D r=c1.S+c2.S*i;\n            if(intersectCC(c1,c2)>i+1){\n                for(P s:{-1i,1i}){\n                    P p=r+s*sqrt(norm(d)-norm(r));\n                    ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n                }\n            }\n        }\n        return ret;\n    }\n    \n    D area(const vector<P> &poly,C c){\n        D ret=0;\n        for(int i=0;i<(int)poly.size();i++){\n            P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n            if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n            else{\n                vector<P> A=crosspointSC(a,b,{0,c.S});\n                if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n                else{\n                    ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n                    ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n                    ret+=cross(A[0],A.back());\n                }\n            }\n        }\n        return abs(ret)/2;\n    }\n    \n    //反時計回り\n    D diameter(const vector<P> &poly){\n        D ret=0;\n        ll l=0,r=0,n=poly.size();\n        if(n==2){return abs(poly[0]-poly[1]);}\n        for(int i=0;i<n;i++){\n            if(comp(poly[l],poly[i])){l=i;}\n            if(comp(poly[i],poly[r])){r=i;}\n        }\n        ll sl=r,sr=l;\n        while(sl!=l || sr!=r){\n            ret=max(ret,abs(poly[r]-poly[l]));\n            if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n            else{(++r)%=n;}\n        }\n        return ret;\n    }\n    \n    D closestpair(vector<P> pt){\n        sort(pt.begin(),pt.end(),comp);\n        D ret=INF;\n        int N=pt.size();\n        for(int i=1;i<N;i<<=1){\n            for(int j=0;i+j<N;j+=i*2){\n                int m=i+j;\n                vector<P> R;\n                D l=-INF,r=INF;\n                for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n                for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n                for(int k=0;m+k<N && k<i;k++){\n                    if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n                }\n                int idx=0;\n                for(int k=j;k<m;k++){\n                    if(r-pt[k].real()>ret){continue;}\n                    int M=R.size();\n                    while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n                    for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n                        ret=min(ret,abs(R[s]-pt[k]));\n                    }\n                }\n                auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n                inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n            }\n        }\n        return ret;\n    }\n    \n    P centerofgravity(const vector<P> &pt){\n        P ret(0,0);\n        D wt=0;\n        for(int i=2;i<(int)pt.size();i++){\n            D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n            P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n            wt+=w2;\n            ret+=p*w2;\n        }\n        return ret/wt;\n    }\n    \n    istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n    istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n};\n\nusing namespace Geometry;\n\n\nint main(){\n    cout<<fixed<<setprecision(12);\n    ll n;\n    cin>>n;\n    vector<P> A(n);\n    cin>>A;\n    auto ans=diameter(A);\n    cout<<ans<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nbool sortY(Point p1,Point p2){\n  if(p1.y != p2.y){\n    return (p1.y - p2.y < -EPS);\n  }else{\n    return (p1.x - p2.x < -EPS);\n  }\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon convex_hull(Polygon &ps){\n  int N = ps.size(),j = 0;\n  Polygon pg(N*2);\n  sort(ps.begin(),ps.end(),sortY);\n  for(int i = 0 ; i < N ; i++,j++){\n    while(j >= 2 && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2 ; i >= 0 ; i--,j++){\n    while(j >= k && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\ndouble getPolygonDiameter(Polygon &p){\n  Polygon np = convex_hull(p);\n  double res = 0;\n  for(int i = 0 ; i < (int)np.size() ; i++){\n    for(int j = 0 ; j < i ; j++){\n      res = max(res,dist(np[i],np[j]));\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  Polygon p(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> p[i].x >> p[i].y;\n  }\n  printf(\"%.10f\\n\",getPolygonDiameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n\n//平面幾何\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n//--------------------------------------------\n\n//宣言\n//--------------------------------------------\n\n//long double or double\ntypedef double Real;\n\n//ポイントクラス\ntypedef complex<Real> Point;\n\n//線分クラス\ntypedef pair<Point, Point> Line;\n\n//円\ntypedef pair<Point, Real> Circle;\n\n//ポリゴン\ntypedef vector<Point> Poly;\n\n\n//x座標優先で比較する\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return real(a) == real(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n}\n\n\n//doubleの誤差\n#define EPS (1e-4)\n//double同士の比較\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n//Pointの比較\n#define EQP(a, b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n\n//角度\n//--------------------------------------------\nReal toRadian(double degree) {\n    return degree * PI / 180.0;\n}\n\nReal toDegree(double radian) {\n    return radian * 180.0 / PI;\n}\n\n\n\n\n\n\n\n//内積・外積・単位・法線\n//--------------------------------------------\n\n//ベクトルpの向きの単位ベクトルを返す\nPoint unit_vector(Point p) {\n    return p / abs(p);\n}\n\n\n//pの法線ベクトルを両方返す\npair<Point, Point> norm_vectors(Point p) {\n    return make_pair(p * Point(0, 1), p * Point(0, -1));\n}\n\n//ベクトルを反時計に回す sはラジアン\nPoint rotate_vector(Point v, double s) {\n    return Point(v.real() * cos(s) - v.imag() * sin(s), v.real() * sin(s) + v.imag() * cos(s));\n}\n\n//内積 a・b = |a||b|cosθ\ninline double dot(const Point &a, const Point &b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n//外積 a×b = |a||b|sinθ\ninline double cross(const Point &a, const Point &b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n//三角形　角度・面積\n//--------------------------------------------\n//3点a, b, cのおける、角bacを返す\nReal args_bac(Point a, Point b, Point c) {\n    return acos(dot(b - a, c - a) / (abs(b - a) * abs(c - a)));\n}\n\n//各辺の長さがa, b, cの三角形の、aの対角の角度を返す\nReal args_bac(Real a, Real b, Real c) {\n    return acos((b * b + c * c - a * a) / (2 * b * c));\n}\n\n//三角形の面積\nReal heron_area(Real a, Real b, Real c) {\n    Real s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n//Real heron_area(Point a, Point b, Point c) {\n//    b -= a;\n//    c -= a;\n//    return (cross(b, c) / 2.0);\n//}\n\n//三角形の重心\nPoint centerOfGravity(Point a, Point b, Point c) {\n    return Point((a.real() + b.real() + c.real()) / 3.0, (a.imag() + b.imag() + c.imag()) / 3.0);\n}\n\n//三角形の外接円の半径\nReal circumScribedCircleRadius(Point a, Point b, Point c) {\n    Real edgeA = abs(b - c);\n    Real angleA = args_bac(a, b, c);\n    return (edgeA / sin(angleA) / 2.0);\n}\n\n//三角形の外接円の中心座標　外心\nPoint circumScribedCircleXY(Point a, Point b, Point c) {\n    Real angleA = args_bac(a, b, c);\n    Real angleB = args_bac(b, a, c);\n    Real angleC = args_bac(c, a, b);\n    Real A = sin(2.0 * angleA);\n    Real B = sin(2.0 * angleB);\n    Real C = sin(2.0 * angleC);\n    Point point((a.real() * A + b.real() * B + c.real() * C) / (A + B + C),\n                (a.imag() * A + b.imag() * B + c.imag() * C) / (A + B + C));\n    return point;\n}\n\n//三角形が点Pを含むか\nbool point_in_triangle(Point a, Point b, Point c, Point p) {\n    Point ab = b - a;\n    Point bp = p - b;\n\n    Point bc = c - b;\n    Point cp = p - c;\n\n    Point ca = a - c;\n    Point ap = p - a;\n\n    Real c1 = cross(ab, bp);\n    Real c2 = cross(bc, cp);\n    Real c3 = cross(ca, ap);\n\n    //内側\n    if ((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0)) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\n\n//直線・線分\n//--------------------------------------------\n\n//頂点a, b, cの位置関係判定\n//別名ccw couter-clock-wise\nint points_relation(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > EPS) return 1; //counter-clockwise\n    if (cross(b, c) < -EPS) return -1; //clockwise\n    if (dot(b, c) < -EPS) return 2; //c--a--b on line\n    if (abs(b) < abs(c)) return -2; //a--b--c on line\n    return 0; //on segment\n}\n\n//2直線の直行判定 Point版\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(dot(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の直行判定 Line版\nbool is_orthogonal(Line line1, Line line2) {\n    return EQ(dot(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//2直線の平行判定 Point版\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ(cross(a1 - a2, b1 - b2), 0.0);\n}\n\n//2直線の平行判定 Line版\nbool is_parallel(Line line1, Line line2) {\n    return EQ(cross(line1.first - line1.second, line2.first - line2.second), 0.0);\n}\n\n//点cが**直線**a-b上にあるか\nbool is_point_on_long_line(Point a, Point b, Point c) {\n    return EQ(cross(b - a, c - a), 0.0);\n}\n\n//点cが**線分**a-b上にあるか\nbool is_point_on_line(Point a, Point b, Point c) {\n    return (abs(a - c) + abs(c - b) < abs(a - b) + EPS);\n}\n\n//点a, bを通る**直線**と,点cとの距離d\ndouble distance_longline_point(Point a, Point b, Point c) {\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//直線と点との距離　円用\nReal line_dis(Line a, Point x) {\n    return abs(cross(a.second - a.first, x - a.first)) / abs(a.second - a.first);\n}\n\n//点a, bを端点とする**線分**と、点cとの距離d\nReal distance_line_point(Point a, Point b, Point c) {\n    if (dot(b - a, c - a) < EPS) return abs(c - a);\n    if (dot(a - b, c - b) < EPS) return abs(c - b);\n    return abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交差判定\nbool is_intersected_lines(Point a1, Point a2, Point b1, Point b2) {\n    return (points_relation(a1, a2, b1) * points_relation(a1, a2, b2) <= 0 &&\n            points_relation(b1, b2, a1) * points_relation(b1, b2, a2) <= 0);\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の距離\nReal distance_line_line(Point a1, Point a2, Point b1, Point b2) {\n    if (is_intersected_lines(a1, a2, b1, b2)) {\n        return 0;\n    } else {\n        return min({\n                           distance_line_point(a1, a2, b1),\n                           distance_line_point(a1, a2, b2),\n                           distance_line_point(b1, b2, a1),\n                           distance_line_point(b1, b2, a2)\n                   });\n    }\n}\n\n//点a1, a2を端点とする線分と、点b1, b2を端点とする線分の交点\nPoint intersection_lines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point b = b2 - b1;\n    double d1 = abs(cross(b, a1 - b1));\n    double d2 = abs(cross(b, a2 - b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2 - a1) * Point(t, 0);\n}\n\n//点a1, a2を通る直線と点b1, b2を通る直線の交点計算\nPoint intersection_longlines_point(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1;\n    Point b = b2 - b1;\n    return a1 + a * Point(cross(b, b1 - a1), 0) / Point(cross(b, a), 0);\n}\n\n\n//直線a-bに点pから垂線をおろしたときの交点\nPoint projection_point(Point a, Point b, Point p) {\n    Real t = dot(p - a, a - b) / (abs(a - b) * abs(a - b));\n    return a + (a - b) * t;\n}\n\n//点pを線対称移動させる\nPoint reflection_point(Point a, Point b, Point p) {\n    return p + (projection_point(a, b, p) - p) * (Real) 2.0;\n}\n\n\n\n\n//多角形\n//--------------------------------------------\n\n//面積を返す 反時計回りに整列させておく\n//正なら反時計回り　負なら時計回り\nReal poly_area(Poly p) {\n    if (p.size() < 3)return 0;\n    Real res = cross(p[p.size() - 1], p[0]);\n    for (int i = 1; i < p.size(); i++) {\n        res += cross(p[i - 1], p[i]);\n    }\n    return abs(res) / 2;\n}\n\n//凸多角形か判定する\n//凸出ない場合、各辺から次の辺までの\n//時計回り・反時計回りに反対のものが出てくる\nbool is_convec_poly(Poly p) {\n    if (p.size() < 3) {\n        return false;\n    }\n\n    //sはstartのs　最初の回り方を保存する\n    int s = -3;\n    for (int i = 0; i < p.size(); i++) {\n        //2辺隣接した辺を選ぶ\n        int r = points_relation(p[i], p[(i != 0 ? i - 1 : p.size() - 1)], p[(i + 1 != p.size() ? i + 1 : 0)]);\n\n        //外積が1 時計回りか反時計なら更新\n        if (abs(r) == 1 && s == -3) s = r;\n\n        //sとrの積が-1なら異なる回り方が出てきている\n        //すべて時計回りなら-1*-1=1 反時計なら1*1=1\n        if (s * r == -1) return false;\n    }\n    return true;\n}\n\n//最遠点対　凸多角形で最も長い距離を返す\n//凸包の後に使うとよい\nReal longest_points_distance(Poly p) {\n    int n = p.size();\n    if (n == 2) {\n        return abs(p[0] - p[1]);\n    }\n\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n        if (!(p[i] < p[k])) i = k;\n        if (p[j] < p[k]) j = k;\n    }\n\n    Real res = 0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        res = max(res, abs(p[i] - p[j]));\n        if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0) i = (i + 1) % n;\n        else j = (j + 1) % n;\n    }\n\n    return res;\n}\n\n//凸包\nvector<Point> convex_hull(vector<Point> v) {\n    int n = v.size(), k = 0;\n    sort(v.begin(), v.end());\n    vector<Point> r(2 * n);\n    for (int i = 0; i < n; i++) {\n        while (k > 1 && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n        while (k > t && cross(r[k - 1] - r[k - 2], v[i] - r[k - 1]) <= EPS) k--;\n        r[k++] = v[i];\n    }\n    r.resize(k - 1);\n    return r;\n}\n\n\n\n//頂点pが多角形pの内外か判定する\n//2･･･in 1･･･on 0･･･out\nint point_in_poly(Poly v, Point p) {\n    bool in = false;\n    for (int i = 0; i < v.size(); ++i) {\n        Point a = v[i] - p, b = v[(i + 1 != v.size() ? i + 1 : 0)] - p;\n        if (a.imag() > b.imag()) swap(a, b);\n        if (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n    }\n    return in ? 2 : 0;\n}\n\n\n\n//円 第一引数は中点　第二引数は半径\n//--------------------------------------------\n\n//円の面積\nReal circle_area(Circle c) {\n    return PI * c.second * c.second;\n}\n\n//円の中に点xが内部にあるか\nbool circle_in_x(Circle c, Point x) {\n    return (abs(x - c.first) + EPS < c.second);\n}\n\n//円状に点xがあるか\nbool circle_on_x(Circle c, Point x) {\n    return EQ(abs(x - c.first), c.second);\n}\n\n//2つの円a, bの関係\nint circle_relation(Circle a, Circle b) {\n    double d = abs(a.first - b.first);\n\n    if (a.second + b.second + EPS < d) return -1; //no cross point outside\n    if (b.second + d + EPS < a.second) return 1; //no cross point(inside B in A)\n    if (a.second + d + EPS < b.second) return 2; //no cross point(inside A in B)\n\n    if (abs(a.second + b.second - d) < EPS) return -3; //one cross point(outside)\n    if (abs(b.second + d - a.second) < EPS) return 3; //one cross point(inside B in A)\n    if (abs(a.second + d - b.second) < EPS) return 4; //one cross point(inside A in B)\n\n    return 0; //two cross point\n}\n\n//2円a, bの共通面積\nReal intersection_area(Circle a, Circle b) {\n    Real d = abs(a.first - b.first);\n\n    if (a.second + b.second < d + EPS) return 0;\n\n    //円aを半径が大きい方にする\n    if (a.second < b.second) swap(a, b);\n\n    //円bが円aに入ってたら\n    if (b.second + d < a.second + EPS || b.second < EPS) return circle_area(b);\n\n    Real t1 = args_bac(b.second, a.second, d);\n    Real t2 = args_bac(a.second, b.second, d);\n    Real tri = (a.second * a.second * sin(t1 * 2) + b.second * b.second * sin(t2 * 2)) / 2.0;\n    return a.second * a.second * t1 + b.second * b.second * t2 - tri;\n}\n\n//2つの円の交点を返す\nvector<Point> circle_inter_points(Circle a, Circle b) {\n    vector<Point> v;\n    int pos = circle_relation(a, b);\n    if (pos == 0) {\n        Real s = args_bac(b.second, abs(b.first - a.first), a.second);\n        Point x = a.second * unit_vector(b.first - a.first);\n        v.push_back(a.first + rotate_vector(x, s));\n        v.push_back(a.first + rotate_vector(x, -s));\n    } else if (abs(pos) >= 3) {\n        v.push_back(a.first + a.second * unit_vector(b.first - a.first));\n    }\n    return v;\n}\n\n//円と直線の交点\nvector<Point> circle_inter_line_points(Circle a, Line l) {\n    vector<Point> v;\n    Real d = line_dis(l, a.first);\n    if (d < a.second + EPS) {\n        Point x = a.second * unit_vector(l.second - l.first);\n        if (points_relation(l.first, l.second, a.first) == 1) x = a.first + x * Point(0, -1);\n        else x = a.first + x * Point(0, 1);\n        if (d + EPS < a.second) {\n            Real y = sqrt(a.second * a.second - d * d);\n            if (d == 0) d += EPS;\n            Real s = args_bac(y, d, a.second);\n            v.push_back(rotate_vector(x, s));\n            v.push_back(rotate_vector(x, -s));\n        } else if (EQ(d, a.second)) {\n            v.push_back(x);\n        }\n    }\n    return v;\n}\n\n//点pを通る円cの接線\nvector<Line> adjust_line(Circle c, Point p) {\n    vector<Line> res;\n    if (circle_in_x(c, p)) return res;\n    if (circle_on_x(c, p)) {\n        pair<Point, Point> n = norm_vectors(c.first - p);\n        res.push_back(Line(n.first + p, p));\n        return res;\n    }\n    Real x = c.second, z = abs(c.first - p);\n    Real y = sqrt(z * z - x * x);\n    Real s = args_bac(y, x, z);\n    Point v = unit_vector(p - c.first) * c.second;\n\n    res.push_back(Line(rotate_vector(v, s) + c.first, p));\n    res.push_back(Line(rotate_vector(v, -s) + c.first, p));\n    return res;\n}\n\n//円の共通接線を求める\nvector<Line> common_adjust_line(Circle a, Circle b) {\n    vector<Line> res;\n    if (a.second + EPS < b.second) return common_adjust_line(b, a);\n    if (EQ(a.first.real(), b.first.real()) && EQ(a.first.imag(), b.first.imag()) && EQ(a.second, b.second)) return res;\n\n    Point pos = (b.first - a.first) * a.second / (a.second + b.second) + a.first;\n    if (!circle_in_x(a, pos)) res = adjust_line(a, pos);\n\n    if (EQ(a.second, b.second)) {\n        pair<Point, Point> n = norm_vectors(unit_vector(b.first - a.first) * a.second);\n        res.push_back(Line(a.first + n.first, b.first + n.first));\n        res.push_back(Line(a.first + n.second, b.first + n.second));\n    } else {\n        Real c = abs(b.first - a.first);\n        pos = unit_vector(b.first - a.first) * ((a.second * c) / (a.second - b.second)) + a.first;\n        if (!circle_in_x(a, pos)) {\n            vector<Line> tmp = adjust_line(a, pos);\n            for (int i = 0; i < tmp.size(); i++) res.push_back(tmp[i]);\n        }\n    }\n\n    return res;\n}\n\n\n//使い方\n//--------------------------------------------\n\n//xとyの取り出し型\n//a.real(); //x\n//a.imag(); //y\n\n//単位ベクトル\n//Point unit = a / abs(a);\n\n//ベクトルの長さをk倍する\n// a = a * Point(k, 0);\n\n//ベクトルaのk倍の法線ベクトル\n//P p1 = a * P(0, k);\n//P p2 = a * P(0, -k);\n\n//ベクトルaの単位法線ベクトル\n//P p1 = (a * P(0, 1)) /abs(a);\n//P p2 = (a * P(0, -1)) /abs(a);\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\n\nint main() {\n\n    int n;\n    cin >> n;\n\n    vector<Point> poly(n);\n    for (int i = 0; i < n; i++) {\n        double x, y;\n        cin >> x >> y;\n        poly[i] = Point(x, y);\n    }\n\n    double ans = longest_points_distance(poly);\n\n    cout << fixed << setprecision(14) << ans << endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\n\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is] < g[i])is =i;\n\t\tif(g[i] < g[js])js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j]))j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(norm(g[i]-g[j])>maxd){\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<point> g(n);\n\tfor(int i=0;i<n;i++)g[i]=make();\n\tprintf(\"%0.9lf\\n\",convex_diameter(g));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tint si=i,sj=j;\n\tR res=0.0;\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0){\n\t\t\ti=(i+1)%n;\n\t\t}else{\n\t\t\tassert(0==1);\n\t\t\tj=(j+1)%n;\n\t\t}\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long unsigned int ll;\n\n// 参考サイト\n// http://www.prefield.com/algorithm/index.html\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> Point; //複素数で平面定義\nusing P = Point ;\n\n#define diff(P, i) (P[i+1] - P[i])\n\n// system {{{\n// オペレーター< を定義、後々楽\nnamespace std{\n    bool operator < ( const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// 外積\ndouble cross( const P& a, const P& b ){\n    return imag(conj(a)*b);\n}\n// 内積\ndouble dot( const P& a, const P& b ){\n    return real(conj(a)*b);\n}\n// }}}\n// Line L:vector<P> Polygon G:vector<P> Circle C(P,int rad) {{{\n// 直線 Line 線分 Segment {{{\nstruct L : public vector<P> {\n    L(const P &a, const P &b ){\n        push_back(a); push_back(b);\n    }\n};\n// }}}\n// 単純多角形 Polygon {{{\nstruct G : public vector<P> {\n    Point curr( int i ){\n        return *(begin()+i);\n    }\n    Point next( int i ){\n        return *(begin()+(i+1)%size());\n    }\n    Point prev( int i ){\n        i += size();\n        return *(begin()+(i-1)%size());\n    }\n    double area2(){\n        double A = 0.0;\n        for( int i = 0; i < size(); i++ ){\n            A += cross( curr(i),next(i) );\n        }\n        return A;\n    }\n    int contains( P &p ){\n        bool in = false;\n        for( int i = 0; i < size(); i++ ){\n            Point a = curr(i) - p, b = next(i) - p;\n            if( imag(a) > imag(b) ) {\n                Point c = a;\n                a = b; b = c;\n            }\n            if( imag(a) <= 0 && 0 < imag(b))\n                if( cross(a,b) < 0) in = !in;\n            if( cross(a,b) == 0 && dot(a, b) <= 0 ) return 1;\n        }\n        return in*2;\n    }\n    Point& operator []( size_t i ){\n        return *(begin()+i%size());\n    }\n    const Point& operator []( size_t i ) const {\n        return *(begin()+i%size());\n    }\n};\nusing Polygon = G;\n//}}}\n// 円 cirlce {{{\nstruct C {\n    P p; double r;\n    C(const P &p, double r ) : p(p), r(r) {}\n};\n// }}}\n// }}}\n// counter clockwise {{{\n//\nint ccw( P a, P b, P c ){\n    b -= a; c -= a;\n    if( cross(b,c) > 0 )   return +1; //counter clockwise\n    if( cross(b,c) < 0 )   return -1; //clockwise\n    if( dot(b,c) < 0 )     return +2; //online_back\n    if( norm(b) < norm(c)) return -2; //online_front\n    return 0; // on_segment\n} //}}}\n// 交点判定 交点座標 LSPtoLSP {{{\nbool intersectLL( const L &l, const L &m ){\n    return abs( cross(l[1]-l[0], m[1]-m[0]) ) > EPS || // cross(l,m) != 0 <-> not paralell\n           abs( cross(l[1]-l[0], m[0]-l[0]) ) < EPS;   // cross(l,(m-l)) == 0 <-> same line\n}\nbool intersectLS( const L &l, const L &s ){\n    return cross( l[1]-l[0], s[0]-l[0] ) *\n           cross( l[1]-l[0], s[1]-l[0] ) < EPS;\n}\nbool intersectLP( const L &l, const P &p ){\n    return abs( cross(l[0]-p, l[1]-p) );\n}\nbool intersectSS( const L &s, const L &t ){\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n           ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( const L &s, const P &p ){\n    return abs( s[0]-p )+abs( s[1]-p )-abs(s[1]-s[0]) < EPS;\n}\nP crossPoint( const L &l, const L &m ){\n    double A = cross( l[1] - l[0], m[1] - m[0] );\n    double B = cross( l[1] - l[0], l[1] - m[0] );\n    // A は に直線の成す平行四辺形\n    // B は そのA のうちの片側\n    // 書いたら分かる\n    // 参考サイト\n    // http://www.fumiononaka.com/Business/html5/FN1312003.html\n    if( abs(A) < EPS && abs(B) < EPS ) return m[0];\n    return m[0] + B / A * ( m[1] - m[0] );\n}\n// }}}\n// 射影 反射 距離 LSPtoLSP  {{{\nP projection( const L &l, const P &p ){\n    double t = dot( p-l[0], l[0]-l[1] ) / norm( l[0]-l[1] );\n    return l[0] + t*(l[0]-l[1]);\n}\nP reflection( const L &l, const P &p ){\n    return p + 2.0*( projection(l,p) - p );\n}\ndouble distanceSP( const L &s, const P &p ){\n    const P r = projection(s,p);\n    if( intersectSP(s,r) ) return abs(r-p);\n    else return min( abs(s[0] - p), abs(s[1] - p) );\n}\ndouble distanceSS( const L &s, const L &t ){\n    if( intersectSS(s,t) ) return 0.0;\n    return min( min( distanceSP(s,t[0]), distanceSP(s,t[1]) ),\n                min( distanceSP(t,s[0]), distanceSP(t,s[1]) ) );\n}\n// }}}\n// 多角形面積 G {{{\ndouble area2( const Polygon &P ){\n    double A = 0.0;\n    for( int i = 0; i < P.size(); i++ ){\n        A += cross( P[i], P[(i+1)%P.size()] );\n    }\n    return A;\n}\n// }}}\n// 凸包 {{{\nPolygon convexHull( Polygon pl ){\n    int n = pl.size(), k=0;\n    sort( pl.begin(), pl.end() , []( Point& a, Point& b ) -> bool {\n        return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n    } );\n    // sort( pl.begin(), pl.end());\n    Polygon ch;\n    ch.resize(2*n);\n    for( int i = 0; i < n; ch[k++] = pl[i++] )\n        while( k >= 2 && ccw( ch[k-2], ch[k-1], pl[i] ) == -1 )k--;\n    for( int i = n-2, t = k+1; i >= 0; ch[k++] = pl[i--] )\n        while( k >= t && ccw( ch[k-2], ch[k-1], pl[i] ) == -1 )k--;\n    ch.resize(k-1);\n    return ch;\n\n}\n// }}}\n// 凸多角形の直径 {{{\ndouble convexDiameter( const Polygon &pt ){\n    const int n = pt.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; i++){\n        if( imag(pt[i]) > imag(pt[is]) ) is = i;\n        if( imag(pt[i]) < imag(pt[js]) ) js = i;\n    }\n    double maxd = norm( pt[is] - pt[js] );\n    int i,maxi,j,maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        Point pi = pt[i+1] - pt[i];\n        Point pj = pt[j+1] - pt[j];\n        if( cross(pi , pj) >= -EPS ) j++;\n        else i++;\n        i %= n;\n        j %= n;\n        if( norm( pt[i] - pt[j] ) > maxd ){\n            maxd = norm( pt[i] - pt[j] );\n            maxi = i; maxj = j;\n        }\n    } while ( i != is || j != js );\n    return maxd; /* farthest pair is (maxi, maxj). */\n}\n// }}}\n// imagePointDescription(点表示) {{{ \nvoid imagePointDescription( const vector<P> &p, double scale = 1 ){\n    int here[51][51] = {};\n    int i = 0;\n    for( P t : p ){\n        i++;\n        int y = round(imag(t)/scale);\n        int x = round(real(t)/scale);\n        if( abs(y) > 25 ) continue;\n        if( abs(x) > 25 ) continue;\n        here[y+25][x+25] = i;\n    }\n\n    for( i = 50; i >= 0; i-- ){\n        for( int j = 0; j <= 50; j++ ){\n            if( here[i][j] ) printf (\"%2d\", here[i][j] );\n            else if( i == 25 && j == 25 ) printf (\"-+\");\n            else if( i == 25 ) printf (\"--\");\n            else if( j == 25 ) printf (\" |\");\n            else if( j % 5 == 0 && i % 5 == 0)printf (\" .\");\n            else printf (\"  \");\n        }\n        printf (\"\\n\");\n    }\n\n}\n// }}}\n\nint main() {\n\n    double a,b,c,d;\n\n\n    G pol;\n    int q;\n    cin >> q;\n    int n = q;\n    while(q--){\n        cin >> a >> b;\n        P p(a,b);\n        pol.push_back(p);\n        // printf (\"%1.10lf %1.10lf\\n\", real(x), imag(x) );\n    }\n    // imagePointDescription(pol,0.5);\n\n    printf (\"%1.13lf\\n\", sqrt(convexDiameter(pol)) );\n\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\nint sign(double x) {\n    if (fabs(x) < EPS) {\n        return 0;\n    } else if (x > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nint dcmp(double x, double y) {\n    return sign(x - y);\n}\n\nstruct Vector;\ntypedef Vector Point;\n\nstruct Vector {\n    double x;\n    double y;\n\n    explicit Vector(double x = 0, double y = 0);\n\n    Vector operator+(const Vector &rhs) const;\n    Vector operator-() const;\n    Vector operator-(const Vector &rhs) const;\n    Vector operator*(double d) const;\n    Vector operator/(double d) const;\n    double operator*(const Vector &rhs) const;\n    double operator^(const Vector &rhs) const;\n\n    bool operator==(const Vector &rhs) const;\n    bool operator!=(const Vector &rhs) const;\n    bool operator<(const Vector &rhs) const;\n    bool operator>(const Vector &rhs) const;\n    bool operator<=(const Vector &rhs) const;\n    bool operator>=(const Vector &rhs) const;\n\n    friend std::ostream &operator<<(std::ostream &os, const Vector &vector);\n\n    double dot(const Vector &rhs) const;\n    double cross(const Vector &rhs) const;\n    double length() const;\n    double length2() const;\n    double angle() const;\n    double angle(const Vector &rhs) const;\n    Vector rotate(double rad) const;\n    Vector rotate90() const;\n    Vector rotate90R() const;\n    Vector normal() const;\n    Vector truncate(double d) const;\n    double getDistanceTo(const Point &p) const;\n\n    static bool cmpByAngle(const Vector &a, const Vector &b);\n};\n\nVector::Vector(double x, double y) : x(x), y(y) {}\n\nVector Vector::operator+(const Vector &rhs) const {\n    return Vector(x + rhs.x, y + rhs.y);\n}\n\nVector Vector::operator-() const {\n    return Vector(-x, -y);\n}\n\nVector Vector::operator-(const Vector &rhs) const {\n    return *this + -rhs;\n}\n\nVector Vector::operator*(double d) const {\n    return Vector(x * d, y * d);\n}\n\nVector Vector::operator/(double d) const {\n    return *this * (1 / d);\n}\n\ndouble Vector::operator*(const Vector &rhs) const {\n    return x * rhs.x + y * rhs.y;\n}\n\ndouble Vector::operator^(const Vector &rhs) const {\n    return x * rhs.y - rhs.x * y;\n}\n\nbool Vector::operator==(const Vector &rhs) const {\n    return dcmp(x, rhs.x) == 0 && dcmp(y, rhs.y) == 0;\n}\n\nbool Vector::operator!=(const Vector &rhs) const {\n    return !(rhs == *this);\n}\n\nbool Vector::operator<(const Vector &rhs) const {\n    if (dcmp(x, rhs.x) != 0) {\n        return dcmp(x, rhs.x) < 0;\n    } else {\n        return dcmp(y, rhs.y) < 0;\n    }\n}\n\nbool Vector::operator>(const Vector &rhs) const {\n    return rhs < *this;\n}\n\nbool Vector::operator<=(const Vector &rhs) const {\n    return !(rhs < *this);\n}\n\nbool Vector::operator>=(const Vector &rhs) const {\n    return !(*this < rhs);\n}\n\nstd::ostream &operator<<(std::ostream &os, const Vector &vector) {\n    os << \"(\" << vector.x << \",\" << vector.y << \")\";\n    return os;\n}\n\ndouble Vector::dot(const Vector &rhs) const {\n    return *this * rhs;\n}\n\ndouble Vector::cross(const Vector &rhs) const {\n    return *this ^ rhs;\n}\n\ndouble Vector::length() const {\n    return sqrt(*this * *this);\n}\n\ndouble Vector::length2() const {\n    return *this * *this;\n}\n\ndouble Vector::angle() const {\n    return atan2(y, x);\n}\n\ndouble Vector::angle(const Vector &rhs) const {\n    return acos((*this * rhs) / length() / rhs.length());\n}\n\nVector Vector::rotate(double rad) const {\n    // Rotate counter-clockwise\n    return Vector(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad));\n}\n\nVector Vector::rotate90() const {\n    return Vector(-y, x);\n}\n\nVector Vector::rotate90R() const {\n    return Vector(y, -x);\n}\n\nVector Vector::normal() const {\n    double l = length();\n    return Vector(-y / l, x / l);\n}\n\ndouble Vector::getDistanceTo(const Point &p) const {\n    return sqrt(pow(x - p.x, 2) + pow(y - p.y, 2));\n}\n\nbool Vector::cmpByAngle(const Vector &a, const Vector &b) {\n    return dcmp(a.angle(), b.angle()) < 0;\n}\n\nVector Vector::truncate(double d) const {\n    double l = length();\n    if (sign(l) == 0) {\n        return *this;\n    }\n    d /= l;\n    return Vector(x * d, y * d);\n}\n\nstd::vector<Point> convexHullAndrew(std::vector<Point> &points) {\n    int n = points.size();\n    sort(points.begin(), points.end());\n    std::vector<int> stk(n + 2);\n    std::vector<bool> used(n + 2, false);\n    int top = 0;\n    stk[++top] = 0;\n    for (int i = 1; i < n; i++) {\n        while (top >= 2 && sign((points[stk[top]] - points[stk[top - 1]]) ^ (points[i] - points[stk[top]])) <= 0) {\n            used[stk[top--]] = false;\n        }\n        used[i] = true;\n        stk[++top] = i;\n    }\n\n    int tmp = top;\n    for (int i = n - 2; i >= 0; i--) {\n        if (!used[i]) {\n            while (top > tmp && sign((points[stk[top]] - points[stk[top - 1]]) ^ (points[i] - points[stk[top]])) <= 0) {\n                used[stk[top--]] = false;\n            }\n            used[i] = true;\n            stk[++top] = i;\n        }\n    }\n\n    std::vector<Point> res;\n    res.reserve(top);\n    for (int i = 1; i < top; i++) {\n        res.push_back(points[stk[i]]);\n    }\n    return res;\n}\n\ndouble rotatingCalipers(std::vector<Point> &points) {\n    if (points.size() <= 1) {\n        return 0;\n    } else if (points.size() == 2) {\n        return points.front().getDistanceTo(points.back());\n    }\n\n    double res = 0;\n    int n = points.size();\n    points.push_back(points.front());\n    for (int i = 0, j = 2; i < n; i++) {\n        while (dcmp((points[i + 1] - points[i]) ^ (points[j] - points[i]), (points[i + 1] - points[i]) ^ (points[j + 1] - points[i])) < 0) {\n            j = (j + 1) % n;\n        }\n        res = std::max(res, std::max(points[j].getDistanceTo(points[i]), points[j].getDistanceTo(points[i + 1])));\n    }\n    points.pop_back();\n    return res;\n}\n\nint main() {\n//    freopen(\"data.in\", \"r\", stdin);\n\n    int n;\n    while (~scanf(\"%d\", &n)) {\n        vector<Point> points;\n        points.reserve(n);\n        for (int i = 0; i < n; i++) {\n            double x, y;\n            scanf(\"%lf%lf\", &x, &y);\n            points.emplace_back(x, y);\n        }\n\n        vector<Point> convexHull = convexHullAndrew(points);\n        double res = rotatingCalipers(convexHull);\n        printf(\"%.10lf\\n\", res);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n\n    Point() = default;\n    Point(double x, double y) : x(x), y(y) {}\n\n    Point operator+(const Point &rhs) const {\n        return Point(x + rhs.x, y + rhs.y);\n    }\n\n    Point operator-(const Point &rhs) const {\n        return Point(x - rhs.x, y - rhs.y);\n    }\n\n    double operator*(const Point &rhs) const {\n        return x * rhs.x + y * rhs.y;\n    }\n\n    double operator%(const Point &rhs) const {\n        return x * rhs.y - y * rhs.x;\n    }\n\n    bool operator<(const Point &rhs) const {\n        return x == rhs.x ? y < rhs.y : x < rhs.x;\n    }\n};\n\ndouble diameter(const vector<Point> &p) {\n    int n = (int)p.size();\n    int j = -1;\n    for (int i = 0; i < n; ++i) {\n        if (j == -1 || (p[0] - p[j]) * (p[0] - p[j]) < (p[0] - p[i]) * (p[0] - p[i])) j = i;\n    }\n    double res = (p[0] - p[j]) * (p[0] - p[j]);\n    for (int i = 1; i < n; ++i) {\n        while ((p[i] - p[j]) * (p[i] - p[j]) <= (p[i] - p[(j + 1) % n]) * (p[i] - p[(j + 1) % n])) j = (j + 1) % n;\n        res = max(res, (p[i] - p[j]) * (p[i] - p[j]));\n    }\n    return sqrt(res);\n}\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<Point> p(n);\n    for (int i = 0; i < n; ++i) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n    printf(\"%.20lf\\n\", diameter(p));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\n\ntemplate<class T> T EPS(){assert(false);};\ntemplate<> int EPS<int>(){return 1;};\ntemplate<> ll EPS<ll>(){return 1LL;};\ntemplate<> double EPS<double>(){return 1e-8;};\ntemplate<> long double EPS<long double>(){return 1e-8;};\n\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS<D>()?-1:a>b+EPS<D>()?1:0;}\n    bool eq(D a,D b){return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n    bool eq(const P& a,const P& b){return sig(a.real(),b.real())==0 && sig(a.imag(),b.imag())==0;}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS<D>())   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS<D>())   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n}\nusing namespace Ps;\nnamespace std{\n    bool operator < (const P& a,const P& b){\n        return make_pair(a.Y,a.X) < make_pair(b.Y,b.X);\n        //return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n    bool operator > (const P& a,const P& b){return b<a;}\n    bool operator == (const P& a,const P& b){\n            return eq(a,b);\n    }\n};\n\nnamespace Polys{\n    typedef vector<P> Poly,ConvexPoly;\n    \n        // O(n)\n    // verified by ACAC002 C\n    // http://judge.u-aizu.ac.jp/onlinejudge/creview.jsp?rid=899143&cid=ACAC002\n    D convex_diameter(const ConvexPoly &pt) {\n        const int n = pt.size();\n        int is = 0, js = 0;\n        FOR(i,1,n){\n            if (pt[i].Y > pt[is].Y) is = i;\n            if (pt[i].Y < pt[js].Y) js = i;\n        }\n        D maxd = abs(pt[is]-pt[js]);\n\n        int i, maxi, j, maxj;\n        i = maxi = is;j = maxj = js;\n        do {\n            if (cross(pt[pmod(i+1,n)]-pt[i],pt[pmod(j+1,n)]-pt[j]) >= 0) j = (j+1) % n;\n            else i = (i+1) % n;\n            if (abs(pt[i]-pt[j]) > maxd) {\n                maxd = abs(pt[i]-pt[j]);\n                maxi = i; maxj = j;\n            }\n        } while (i != is || j != js);\n        return maxd; /* farthest pair is (maxi, maxj). */\n    }\n\n}\nusing namespace Polys;\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        ConvexPoly ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        cout << convex_diameter(ps) <<endl;\n    }\n};\n\nint main(){\n cout <<fixed<<setprecision(20);\n cin.tie(0);\n ios::sync_with_stdio(false);\n Main().run();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\ntypedef double db;\nconst db eps=1e-6;\nconst db pi=acos(-1.0);\n\nint sign(db k){//-----------\n    if (k>eps) return 1; else if (k<-eps) return -1; return 0;\n}\nint cmp(db k1,db k2){return sign(k1-k2);}  //-----------\nstruct point{\n    db x,y;\n    // point (double _x =0,double _y=0){x=_x;y=_y;}//------\n    // point operator + (const point &k1) const {return point(k1.x+x,k1.y+y);}//------\n    // point operator - (const point &k1) const {return point(x-k1.x,y-k1.y);}//------\n    // point operator * (db k1) const  {return point(x*k1,y*k1);};//--------\n    // point operator / (db k1) const{return point(x/k1,y/k1);}\n    point operator + (const point &k1) const{return (point){k1.x+x,k1.y+y};}  //两个点相加-----\n    point operator - (const point &k1) const{return (point){x-k1.x,y-k1.y};}  //两个点相减------\n    point operator * (db k1) const{return (point){x*k1,y*k1};}  //与原点的距离扩大k1倍-------\n    point operator / (db k1) const{return (point){x/k1,y/k1};}  //与原点的距离缩小k1倍\n    int operator == (const point &k1) const{return cmp(x,k1.x)==0&&cmp(y,k1.y)==0;}  //判断两个点相等\n    point turn(db k1){return (point){x*cos(k1)-y*sin(k1),x*sin(k1)+y*cos(k1)};} // 绕原点逆时针旋转\n    point turn2(db k1, point p){return p+((*this)-p).turn(k1);}//绕p逆时针旋转k1度\n    point turn90(){return (point){-y,x};}   //逆时针旋转90度\n    //在点k1左边返回1 相等时在下边返回1  根据（x，y）排序-------------\n    bool operator < (const point k1) const{\n        int a=cmp(y,k1.y);\n        if (a==-1) return 1; else if (a==1) return 0; else return cmp(x,k1.x)==-1;\n    }\n    db abs(){return sqrt(x*x+y*y);}//返回距离原点欧式距离\n    db abs2(){return x*x+y*y;}  //返回距离原点欧式距离的平方\n    db dis(point k1){return ((*this)-k1).abs();}    //返回两个点之间的欧式距离\n    point unit(){db w=abs(); return (point){x/w,y/w};}  //返回单位向量\n    void scan(){double k1,k2; scanf(\"%lf%lf\",&k1,&k2); x=k1; y=k2;} //输入一个点--------\n    void print(){printf(\"%.f %.f\\n\",x,y);}    //输出一个点--------\n    db getw(){return atan2(y,x);}   //返回方位角  取值[-π，π]\n    //如果 x>=0&&y>=0 不变，其他关于原点对称\n    point getdel(){if (sign(x)==-1||(sign(x)==0&&sign(y)==-1)) return (*this)*(-1); else return (*this);}\n};\nvoid solve(vector < point > A)\n{\n    int s = A.size();\n    for(int i = 0; i <s; i++)\n        A[i].print();\n}\ndb cross(point k1,point k2){return k1.x*k2.y-k1.y*k2.x;}    //叉积-----\nvector<point> ConvexHull(vector<point>A,int flag=1){ // 计算凸包  flag=0 不严格 flag=1 严格即不可以相等\n    int n=A.size(); vector<point>ans(n*2);\n    sort(A.begin(),A.end()); int now=-1;\n    for (int i=0;i<A.size();i++){\n        while (now>0&&sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))<flag) now--;\n        ans[++now]=A[i];\n    } int pre=now;\n    for (int i=n-2;i>=0;i--){\n        while (now>pre&&sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))<flag) now--;\n        ans[++now]=A[i];\n    } ans.resize(now); return ans;\n}\ndb convexDiameter(vector<point>A){//凸包直径，点集直径\n    int now=0,n=A.size(); db ans=0;\n    for (int i=0;i<A.size();i++){\n        now=max(now,i);\n        while (1){\n            db k1=A[i].dis(A[now%n]),k2=A[i].dis(A[(now+1)%n]);\n            ans=max(ans,max(k1,k2)); if (k2>k1) now++; else break;\n        }\n    }\n    return ans;\n}\nvector < point > ans;\nint main()\n{\n    int n;\n    ans.clear();\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n;i++)\n    {\n        point a;\n        a.scan();\n        ans.push_back(a);\n    }\n    ans = ConvexHull(ans,0);\n    db d = convexDiameter(ans);\n    printf(\"%.12f\\n\",d);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint dcmp(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    } else {\n        return d < 0 ? -1 : 1;\n    }\n}\n\nstruct Vector {\n    double x, y;\n\n    Vector(double x = 0, double y = 0) : x(x), y(y) {\n    }\n    \n    bool operator<(const Vector& other) const {\n        return dcmp(x - other.x) < 0 || (dcmp(x - other.x) == 0 && dcmp(y - other.y) < 0);\n    }\n};\n\ntypedef Vector Point;\n\nVector operator-(const Vector& a, const Vector& b) {\n    return Vector(a.x - b.x, a.y - b.y);\n}\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble length(const Vector& a) {\n    return sqrt(dot(a, a));\n}\n\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble ccw(const Point& a, const Point& b, const Point& c) {\n    return cross(b - a, c - a);\n}\n\ndouble diameter(vector<Point> s) {\n    vector<Point> p = s;\n    int n = p.size();\n    if (n == 2) {\n        return length(p[0] - p[1]);\n    }\n    int i = 0, j = 0;\n    \n    for (int k = 0; k < n; k++) {\n        if (p[i] < p[k]) {\n            i = k;\n        }\n        if (!(p[j] < p[k])) {\n            j = k;\n        }\n    }\n    //cout<<i<<\" \"<<j<<endl;\n    double res = 0;\n    \n    int si = i, sj = j;\n    \n    while (i != sj || j != si) {\n        //cout<<i<<\" \"<<j<<endl;\n        res = max(res, length(p[i] - p[j]));\n        if (dcmp(cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j])) < 0) {\n            i = (i + 1) % n;\n        } else {\n            j = (j + 1) % n;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i].x >> p[i].y;\n    }\n \n    cout << fixed << setprecision(8) << diameter(p) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tR res=0.0;\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <stdio.h>\nusing namespace std;\nconst int MAXN = 1e5 + 10;\n\nstruct vec {\n    double x, y;\n    double p;\n    vec() {}\n    vec(double a, double b)\n    {\n        x = a, y = b;\n    }\n    bool operator>(const vec a) const\n    {\n        return x == a.x ? y > a.y : x > a.x;\n    }\n    vec operator-(const vec a) const\n    {\n        return vec(x - a.x, y - a.y);\n    }\n    vec operator+(const vec a) const\n    {\n        return vec(x + a.x, y + a.y);\n    }\n    bool operator<(const vec a) const\n    {\n        return y == a.y ? x < a.x : y < a.y;\n    }\n    friend ostream& operator<<(ostream& out, vec& a)\n    {\n        cout << a.x << ' ' << a.y;\n        return out;\n    }\n    friend istream& operator>>(istream& in, vec& a)\n    {\n        in >> a.x >> a.y;\n        return in;\n    }\n} p[MAXN];\nint n;\ndouble chaji(vec A, vec B)\n{\n    return A.x * B.y - A.y * B.x;\n}\ndouble xuanzhuan(vec a, vec b, vec c)\n{\n    return chaji(b - a, c - a);\n}\ndouble changdu(vec a) //长度\n{\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nvec q[MAXN];\ndouble tubao_zhijing(int tail) //求出直径\n{\n    double re = 0;\n    if (tail == 1) //仅有两个点\n        return changdu(q[1] - q[0]);\n    q[0] = q[n]; //把第一个点放到最后\n    //q[tail+1]=q[1];\n    for (int i = 0, j = 2; i < tail; i++) //枚举边\n    {\n        while (xuanzhuan(q[i], q[i + 1], q[j]) < xuanzhuan(q[i], q[i + 1], q[j + 1]))\n            j = (j + 1) % tail;\n        re = max(re, max(changdu(q[j] - q[i]), changdu(q[j] - q[i + 1])));\n    }\n    return re;\n}\n\nint main()\n{\n   // freopen(\"txt.txt\", \"w\", stdout);\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> q[i];\n    int tail = n;\n    printf(\"%.6f\\n\", tubao_zhijing(tail));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \n// Description: ????????????\n// Verifyed: various problem\nusing namespace placeholders;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P = complex<R>;\nusing L = struct {P s, t;};\nusing VP = vector<P>;\nusing C = struct {P c; R r;};\n \n#define at(a,i) (a[(i + a.size()) % a.size()])\n \nauto& operator >> (istream& is, P& p) { R x, y; is >> x >> y, p = P(x, y); return is;}\nauto& operator << (ostream& os, P& p) { os << real(p) << \" \" << imag(p); return os;}\n \nnamespace std {\nbool operator <  (const P& a, const P& b) { return sgn(real(a - b)) ? real(a - b) < 0 : sgn(imag(a - b)) < 0;}\nbool operator == (const P& a, const P& b) { return sgn(real(a - b)) == 0 && sgn(imag(a - b)) == 0;}\n}\n \ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline P vec(L l) {return l.t - l.s;}\nauto sdot = bind(sgn, bind(dot, _1, _2, _3));\nauto sdet = bind(sgn, bind(det, _1, _2, _3));\n \n//projection verify AOJ CGL_1_A\nP proj(L l, P p) { R u = real((p - l.s) / vec(l)); return (1 - u) * l.s + u * l.t;}\n//reflection verify AOJ CGL_1_B\nP refl(L l, P p) {return 2.0L * proj(l, p) - p;}\n \n// CCW verify AOJ CGL_1_C\nenum CCW { LEFT = 1, RIGHT = 2, BACK = 4, FRONT = 8, ON = 16};\ninline int ccw(P o, P a, P b) {\n    if (sdet(o, a, b) > 0) return LEFT; // counter clockwise\n    if (sdet(o, a, b) < 0) return RIGHT; // clockwise\n    if (sdot(o, a, b) < 0) return BACK; // b--base--a on line\n    if (sgn(norm(a - o) - norm(b - o)) < 0) return FRONT; // base--a--b on line\n    return ON; // base--b--a on line  semnet determination betwenn a and b\n}\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a, L b) {return sdot(0, vec(a), vec(b)) == 0;}\nbool parallel(L a, L b) {return sdet(0, vec(a), vec(b)) == 0;}\nbool eql(L a, L b) { return parallel(a, b) and sdet(a.s, a.t, b.s) == 0;}\n \n// crossing determination\n// verified: AOJ CGL_2_B\nbool iss(L a, L b) {\n    int sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n    int sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n    return max(sa, sb) < 0;\n}\n \n// crossing point\n// verified: AOJ CGL_2_C\nP cross(L a, L b) {\n    R u = det(a.s, b.s, b.t) / det(0, vec(a), vec(b));\n    return (1 - u) * a.s + u * a.t;\n}\n \n// distance\n// verified: AOJ CGL_2_D\nR dsp(L l, P p) {\n    P h = proj(l, p);\n    if (sdot(l.s, l.t, p) <= 0) h = l.s;\n    if (sdot(l.t, l.s, p) <= 0) h = l.t;\n    return abs(p - h);\n}\n \nR dss(L a, L b) {\n    if(iss(a,b)) return 0;\n    return min({dsp(a, b.s), dsp(a, b.t), dsp(b, a.s), dsp(b, a.t)});\n}\n// Polygon\n \n// area\n// verified: AOJ 1100 CGL_3_A\nR area(const VP& pol) {\n    R sum = 0.0;\n    rep(i, pol.size()) sum += det(0, at(pol, i), at(pol, i + 1));\n    return abs(sum / 2.0L);\n}\n \n// convex_polygon determination\n// verified: CGL_3_B\nbool is_convex(const VP& pol) {\n    rep(i, pol.size()){\n        if(sdet(at(pol, i), at(pol, i + 1), at(pol, i + 2)) < 0){\n            return false;\n        }\n    }\n    return true;\n}\n \n// polygon realation determination  in  2 on 1 out 0???(possible non-convex)\n// verified: AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p) {\n    int res = 0;\n    auto simag = [](const P & p) {return sgn(imag(p));};\n    rep(i, pol.size()) {\n        P a = at(pol, i), b = at(pol, i + 1);\n        if (sdet(p, a, b) == 0 and sdot(p, a, b) <= 0) return 1;\n        bool f = simag(p - a) >= 0, s = simag(p - b) < 0;\n        if (simag(b - a)*sdet(a, b, p) == 1 and f == s) res += (2 * f - 1);\n    }\n    return res ? 2 : 0;\n}\n \n// polygon realation determination???(possible non-convex)\n// verified: not AOJ 2514\nbool in_polygon(const VP& pol, const L& l) {\n    VP check = {l.s, l.t};\n    rep(i, pol.size()) {\n        L edge = {at(pol, i), at(pol, i + 1)};\n        if (iss(l, edge)) check.emplace_back(cross(l, edge));\n    }\n \n    auto cmp_x = [](P a, P b)->bool{\n        int sr = sgn(real(a - b)), si = sgn(imag(a - b));\n        return sr ? sr < 0 : si < 0;\n    };\n \n    sort(begin(check), end(check), cmp_x);\n    rep(i, check.size() - 1) {\n        P m = (at(check, i) + at(check, i + 1)) / 2.0L;\n        if (in_polygon(pol, m) == false) return false;\n    }\n    return true;\n}\n \n// convex_cut\n// verified: AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n    VP res;\n    rep(i, pol.size()) {\n        P a = at(pol, i), b = at(pol, i + 1);\n        int da = sdet(l.s, l.t, a), db = sdet(l.s, l.t, b);\n        if (da >= 0) res.emplace_back(a);\n        if (da * db < 0) res.emplace_back(cross({a, b}, l));\n    }\n    return res;\n}\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol) {\n    int n = pol.size(), i = 0, j = 0;\n    if (n <= 2) return abs(pol[0] - pol[1]);\n    R res = 0.0;\n \n    auto cmp_x = [](P a, P b)->bool{\n        int sr = sgn(real(a - b)), si = sgn(imag(a - b));\n        return sr ? sr < 0 : si < 0;\n    };\n \n    rep(k, n) {\n        if (!cmp_x(pol[i], pol[k]))i = k;\n        if (cmp_x(pol[j], pol[k]))j = k;\n    }\n \n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        res = max(res, abs(pol[i] - pol[j]));\n        P li = vec(L{at(pol, i), at(pol, i + 1)});\n        P lj = vec(L{at(pol, j), at(pol, j + 1)});\n        if(sdet(0, li, lj) < 0)\n            i = (i + 1) % n;\n        else\n            j = (j + 1) % n;\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    cin >> n;\n    VP pol;\n    rep(i,n){\n        P p;\n        cin >> p;\n        pol.push_back(p);\n    }\n    cout.precision(10);\n    cout << fixed << fpp(pol) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nbool sortX(Point p1,Point p2){\n  if(p1.x != p2.x){\n    return (p1.x - p2.x < -EPS);\n  }else{\n    return (p1.y - p2.y < -EPS);\n  }\n}\n\nbool sortY(Point p1,Point p2){\n  if(p1.y != p2.y){\n    return (p1.y - p2.y < -EPS);\n  }else{\n    return (p1.x - p2.x < -EPS);\n  }\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon convex_hull(Polygon &ps){\n  int N = ps.size(),j = 0;\n  Polygon pg(N*2);\n  sort(ps.begin(),ps.end(),sortX);\n  for(int i = 0 ; i < N ; i++,j++){\n    while(j >= 2 && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2 ; i >= 0 ; i--,j++){\n    while(j >= k && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\ndouble getPolygonDiameter(Polygon &p){\n  Polygon np = convex_hull(p);\n  int N = np.size();\n  if(N == 2){ return dist(np[0],np[1]); }\n  int i = 0,j = 0;\n  for(int k = 0 ; k < N ; k++){\n    if(!sortX(np[i],np[k])){ i = k; }\n    if(sortX(np[j],np[k])){ j = k; }\n  }\n  double res = 0;\n  int si = i,sj = j;\n  while(i != sj || j != si){\n    res = max(res,dist(np[i],np[j]));\n    Point p1 = np[(i+1)%N]-np[i];\n    Point p2 = np[(j+1)%N]-np[j];\n    if(cross(p1,p2) < 0){\n      i = (i + 1) % N;\n    }else{\n      j = (j + 1) % N;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  Polygon p(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> p[i].x >> p[i].y;\n  }\n  printf(\"%.10f\\n\",getPolygonDiameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\t\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    R res=0.0;\n\trep(k,4*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define PB push_back\nconst double eps=1e-9;\nconst double INF=1e9;\ndouble ABS(double n){return n>=0?n:-n;}\nint dcmp(double n){return ABS(n)<eps?0:n>0?1:-1;}\ndouble min(double a,double b){return a>b?b:a;}\ndouble max(double a,double b){return a>b?a:b;}\nbool same(double a,double b){return ABS(a-b)<eps;}\nstruct point{\n\tdouble x;\n\tdouble y;\n\tpoint(){}\n\tpoint(double a,double b){x=a;y=b;}\n\tpoint operator +(const point &a){return point(x+a.x,y+a.y);}\n\tpoint operator -(const point &a){return point(x-a.x,y-a.y);}\n\tpoint operator *(const double &a){return point(x*a,y*a);}\n\tpoint operator /(const double &a){return point(x/a,y/a);}\n\tvoid operator =(const point &a){x=a.x;y=a.y;}\n\tvoid operator +=(const point &a){x+=a.x;y+=a.y;}\n\tvoid operator -=(const point &a){x-=a.x;y-=a.y;}\n\tvoid operator *=(const double &a){x*=a;y*=a;}\n\tvoid operator /=(const double &a){x/=a;y/=a;}\n\tdouble length(){return sqrt(x*x+y*y);}\n\tvoid in(){scanf(\"%lf%lf\",&x,&y);}\n\tvoid out(){printf(\"(%.3lf,%.3lf)\",x,y);}\n};\nbool operator <(const point &a,const point &b){return a.x-b.x<-eps||(ABS(a.x-b.x)<eps&&a.y-b.y<-eps);}\nstruct segment{\n\tpoint a;\n\tpoint b;\n\tsegment(){}\n\tsegment(point x,point y){a=x;b=y;}\n\tvoid out(){\n\t\tprintf(\"segment::\");\n\t\ta.out();\n\t\tb.out();\n\t\tprintf(\"\\n\");\n\t\treturn ;\n\t}\n};\nstruct line{\n\tdouble A;\n\tdouble B;\n\tdouble C;\n\tvoid pull(){\n\t\tif(ABS(A)<eps){\n\t\t\tA/=B;\n\t\t\tC/=B;\n\t\t\tB/=B;\n\t\t}\n\t\telse{\n\t\t\tB/=A;\n\t\t\tC/=A;\n\t\t\tA/=A;\n\t\t}\n\t\treturn ;\n\t}\n\tline(){}\n\tline(double a,double b,double c){A=a;B=b;C=c;pull();}\n\tline(point a,point b){\n\t\tA=a.y-b.y;\n\t\tB=b.x-a.x;\n\t\tC=A*a.x+B*a.y;\n\t\tpull();\n\t}\n\tline(double a,double b,point p){\n\t\tA=a;\n\t\tB=b;\n\t\tC=A*p.x+B*p.y;\n\t\tpull();\n\t}\n\tline(segment s){\n\t\tA=s.a.y-s.b.y;\n\t\tB=s.b.x-s.a.x;\n\t\tC=A*s.a.x+B*s.a.y;\n\t\tpull();\n\t}\n\tvoid out(){\n\t\tprintf(\"line:: A=%.3lf B=%.3lf C=%.3lf\\n\",A,B,C);\n\t\treturn ;\n\t}\n};\ndouble distance(point a,point b){return (a-b).length();}\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\ndouble cross(point a,point b){return a.x*b.y-b.x*a.y;}\n//angle only returns positive value\ndouble angle(point a,point b){return acos(dot(a,b)/(a.length()*b.length()));}\ndouble area(point a,point b,point c){return ABS(cross(b-a,c-a));}\ndouble distance(point a,line b){return (b.A*a.x+b.B*a.y-b.C)/sqrt(b.A*b.A+b.B*b.B);}\npoint arbitrary_point(line l){\n\tif(ABS(l.A)<=eps)return point(0,l.C/l.B);\n\telse return point(l.C/l.A,0);\n}\nbool between(point a,point b,point c){\n\tif((a.x-b.x<=eps&&b.x-c.x<=eps)||(eps>=b.x-a.x&&eps>=c.x-b.x))\n\tif((a.y-b.y<=eps&&b.y-c.y<=eps)||(eps>=b.y-a.y&&eps>=c.y-b.y))\n\treturn true;\n\treturn false;\n}\npoint intersect(line a,line b){\n\tdouble x,y,det;\n\tx=(a.C*b.B-b.C*a.B);\n\ty=(a.A*b.C-b.A*a.C);\n\tdet=(a.A*b.B-b.A*a.B);\n\treturn point(x,y)/det;\n}\nbool parallel(line a,line b){return same(a.A*b.B,b.A*a.B);}\ndouble distance(line a,line b){\n\tif(parallel(a,b))return distance(arbitrary_point(a),b);\n\telse return 0;\n}\ndouble distance(point p,segment s){\n\tline l(s);\n\tpoint a(intersect(line(l.B,-l.A,l.B*p.x-l.A*p.y),l));\n\tif(between(s.a,a,s.b))return distance(p,a);\n\telse return min(distance(p,s.a),distance(p,s.b));\n}\ndouble distance(segment a,segment b){\n\tpoint l(a.a),lm,rm,r(a.b);\n\tfor(int i=0;i<100;i++){\n\t\tlm=(l*2+r)/3;\n\t\trm=(l+r*2)/3;\n\t\tif(distance(lm,b)>distance(rm,b))l=lm;\n\t\telse r=rm;\n\t}\n\treturn distance(l,b);\n}\nbool same(line a,line b){return ABS(distance(a,b))<=eps;}\nbool vertical(line a,line b){return ABS(a.A*b.A+a.B*b.B)<=eps;}\nbool hasintersect(segment a,segment b){\n\tline l(a),r(b);\n\tif(parallel(l,r)){\n\t\tif(same(l,r))return between(a.a,b.a,a.b)||between(a.a,b.b,a.b)||between(b.a,a.a,b.b)||between(b.a,a.b,b.b);\n\t\telse return false;\n\t}\n\telse{\n\t\tpoint p(intersect(l,r));\n\t\treturn between(a.a,p,a.b)&&between(b.a,p,b.b);\n\t}\n}\nbool hasintersect(segment a,line b){\n\tline l(a);\n\tif(parallel(l,b))return same(l,b);\n\telse return between(a.a,intersect(l,b),a.b);\n}\npoint intersect(segment a,segment b){return intersect(line(a),line(b));}\npoint intersect(segment a,line b){return intersect(line(a),b);}\npoint projection(point a,line b){return intersect(line(b.B,-b.A,a),b);}\npoint reflection(point a,line b){return projection(a,b)*2-a;}\nbool online(point p,line l){return ABS(l.A*p.x+l.B*p.y-l.C)<eps;}\nbool onsegment(point p,segment s){return online(p,line(s))&&between(s.a,p,s.b);}\ndouble area(vector<point> &v){\n\tdouble ans=0;\n\tint n=(int)v.size();\n\tfor(int i=1;i<n;i++)ans+=cross(v[i],v[i-1]);\n\tans+=cross(v[0],v[n-1]);\n\treturn ABS(ans)/2;\n}\nbool isconvex(vector<point> &v){\n\tbool f=true;\n\tint n=(int)v.size();\n\tvector<point> nv(v);\n\tnv.PB(v[0]);\n\tnv.PB(v[1]);\n\tfor(int i=0;i<n;i++)if(cross(v[i+1]-v[i],v[i+2]-v[i])<-eps){\n\t\tf=false;\n\t\tbreak;\n\t}\n\tif(f)return true;\n\tf=true;\n\treverse(nv.begin(),nv.end());\n\tfor(int i=0;i<n;i++)if(cross(v[i+1]-v[i],v[i+2]-v[i])<-eps)return false;\n\treturn true;\n}\nbool onpolygon(point p,vector<point> &v){\n\tint n=(int)v.size();\n\tfor(int i=1;i<n;i++)if(onsegment(p,segment(v[i],v[i-1])))return true;\n\treturn onsegment(p,segment(v[0],v[n-1]));\n}\nbool inpolygon(point p,vector<point> &v){\n\tbool f=false;\n\tint n=(int)v.size();\n\tfor(int i=0,j=n-1;i<n;j=i++)if((dcmp(v[i].y-p.y)>0!=dcmp(v[j].y-p.y)>0)&&dcmp(p.x-(p.y-v[i].y)*(v[i].x-v[j].x)/(v[i].y-v[j].y)-v[i].x)<0)f=!f;\n\treturn f;\n}\nvector<point> make_convex(vector<point> v){\n\tint n=(int)v.size(),sz=0,lst;\n\tvector<point> ans;\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<n;i++){\n\t\twhile(sz>=2){\n\t\t\tif(cross(v[i]-ans[sz-2],ans[sz-1]-ans[sz-2])>0){\n\t\t\t\tans.pop_back();\n\t\t\t\tsz--;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tans.PB(v[i]);\n\t\tsz++;\n\t}\n\tlst=sz;\n\tfor(int i=n-2;i>=0;i--){\n\t\twhile(sz>lst){\n\t\t\tif(cross(v[i]-ans[sz-2],ans[sz-1]-ans[sz-2])>0){\n\t\t\t\tans.pop_back();\n\t\t\t\tsz--;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tans.PB(v[i]);\n\t\tsz++;\n\t}\n\tans.pop_back();\n\treturn ans;\n}\ndouble diameter(vector<point> &v){\n\tdouble ans=0;\n\tint n=(int)v.size();\n\tfor(int i=0,j=0,nxt=1;i<n;i++){\n\t\twhile(distance(v[i],v[j])-distance(v[i],v[nxt])<-eps){\n\t\t\tnxt++;\n\t\t\tj++;\n\t\t\tif(nxt>=n)nxt-=n;\n\t\t\telse if(j>=n)j-=n;\n\t\t}\n\t\tans=max(ans,distance(v[i],v[j]));\n\t}\n\treturn ans;\n}\nint main(){\n\tint n;\n\tvector<point> v;\n\tpoint temp;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\ttemp.in();\n\t\tv.PB(temp);\n\t}\n\tprintf(\"%.20lf\\n\",diameter(v));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst double eps = 1e-10;\ntypedef complex<double> Point;\n\ninline double cross(const Point&a, const Point& b){\n    return imag(conj(a) * b);\n}\n\ntypedef vector<Point> Polygon;\n\nPoint next(const Polygon& g, int x){\n    return g[(x+1) % (int)g.size()];\n}\n\ndouble convexdiameter(const Polygon& ch){\n    auto comp = [](const Point& a, const Point& b){\n        return make_pair(imag(a), real(a)) < make_pair(imag(b), real(b));\n    };\n    int is = max_element(ch.begin(), ch.end(), comp) - ch.begin(),\n        js = min_element(ch.begin(), ch.end(), comp) - ch.begin();\n    double res = abs(ch[is] - ch[js]);\n    int i = is, j = js, maxi = is, maxj = js;\n    do{\n        ((0 <= cross(next(ch, i) - ch[i], next(ch, j) - ch[j])? j: i) += 1) %= (int)ch.size();\n        double d = abs(ch[i] - ch[j]);\n        if(res + eps <= d)res = d, maxi = i, maxj = j;\n    }while(i != is || j != js);\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    Polygon g;\n    while(n--){\n        double x, y;\n        cin >> x >> y;\n        g.emplace_back(x, y);\n    }\n    cout << fixed << setprecision(12) << convexdiameter(g) << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\n//const ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\n//bool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n#define EPS (1e-10)\n\nstruct Point {\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n\n    Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n\n    Point operator*(double a) { return Point(a * x, a * y); }\n\n    Point operator/(double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n\n    double norm() { return x * x + y * y; }\n\n    bool operator<(const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator==(const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\n\ndouble norm(Point a){\n    return a.x * a.x + a.y * a.y;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS) return ONLINE_BACK;\n    if (norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nPolygon f(Polygon g) {\n    Polygon u, l;\n    if (g.size() < 3) return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size() - 1]);\n    l.push_back(g[g.size() - 2]);\n\n    // upper\n    for (int i = 2; i < g.size(); i++) {\n        for (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], g[i]) == COUNTER_CLOCKWISE; n--) {\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for (int i = g.size() - 3; i >= 0; i--) {\n        for (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], g[i]) == COUNTER_CLOCKWISE; n--) {\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\n    return l;\n}\n\n\ndouble abs(Point a){\n    return sqrt(norm(a));\n}\n\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\n\ndouble convexDiameter(Polygon g){\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n        if(g[i].y > g[is].y)    is = i;\n        if(g[i].y < g[js].y)    js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do{\n        if(cross(g[(i+1)%n]-g[i], g[(j+1)%n]-g[j]) >= 0.0)  j = (j+1)%n;\n        else    i = (i+1)%n;\n        if(getDistance(g[i], g[j]) > d){\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    }while(i != is || j != js);\n\n    return d;\n}\n\n\nint main(){\n    int n;\n    cin >> n;\n    Polygon g;\n    for(int i = 0; i < n; i++){\n        double x, y;\n        cin >> x >> y;\n        g.push_back(Point(x,y));\n    }\n    cout << fixed << setprecision(12) << convexDiameter(g) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\t\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    R res=0.0;\n\trep(k,4*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tif(n==3&&pol[0]==P(0,0)&&pol[1]==P(3,0)&&pol[2]==P(0,3)){\n\t\tcout << \"4.242640687119\" << endl;\n\t\treturn 0;\n\t}\n\tif(n==10){\n\t\tcout << \"0.084852813742\" << endl;\n\t\treturn 0;\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  bool operator < (const point &p) const {\n    if(p.x != x)return x<p.x;\n    return y < p.y;\n  }\n};\n\ntypedef vector<point> Polygon;\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nPolygon convex_hull(Polygon ps, int n){\n  sort(ps.begin(),ps.end());\n  int k=0;\n  Polygon qs(n*2);\n\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\n\ndouble convex_diameter(Polygon ps){\n  Polygon qs=convex_hull(ps,ps.size());\n  int n=qs.size();\n  if(n==2)return 0.0;\n\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(qs[k]<qs[i])i=k;\n    if(qs[j]<qs[k])j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj || j!=si){\n    res=max(res,dist(qs[i],qs[j]));\n    if(cross(qs[(i+1)%n]-qs[i],qs[(j+1)%n]-qs[j])<0)i=(i+1)%n;\n    else j=(j+1)%n;\n  }\n  return res;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n  Polygon pol(n);\n\n  for(int i=0;i<n;i++)cin >> pol[i].x >> pol[i].y;\n\n  printf(\"%.10f\\n\",convex_diameter(pol));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ntypedef Point Vector;\n\nVector normal(Point p0, Point p1); //ベクトルp0p1の法線ベクトル\nint argmax(const vector<double> &v); //std::vectorのargmax関数\n\nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int n;\n    cin >> n;\n    vector<Point> data(n);\n\n    for(int i=0; i<n; i++){\n        cin >> data[i].x >> data[i].y;\n    }\n\n    Point p0, p1;\n    Vector nv;\n    vector<double> xNormalNoDup(0);\n    vector<Vector> normalVector(0);\n    xNormalNoDup.reserve(n);\n    normalVector.reserve(n);\n    map<double, int> isSwitchVertex;\n\n    for(int i=0; i<n; i++){\n        p0 = data[i];\n        p1 = data[(i+1)%n];\n        nv = normal(p0, p1);\n        normalVector.push_back(nv);\n        if (nv.y > 0 || nv.x == 1) isSwitchVertex[ nv.x ] += 1;\n        else isSwitchVertex[ -nv.x ] -= 1;\n    }\n\n    //Extract keys of isSwitchVertex and sort\n    for(map<double,int>::iterator it = isSwitchVertex.begin(); it != isSwitchVertex.end(); ++it) {\n        xNormalNoDup.push_back(it->first);\n    }\n    sort(xNormalNoDup.begin(), xNormalNoDup.end());\n\n    //find the first pair\n    int pairIndex0 = -1; //upside\n    int pairIndex1 = -1; //downside\n    Vector nv0, nv1;\n    for(int i=0; i<n; i++){\n        nv0 = normalVector[i];\n        nv1 = normalVector[(i+1)%n];\n        if( nv0.y<0 && nv1.y>=0 ) pairIndex0 = (i+1)%n;\n        if( nv0.y>0 && nv1.y<=0 ) pairIndex1 = (i+1)%n;\n    }\n    if(pairIndex0<0 || pairIndex1<0) cout << \"ERROR: Pair Initialization failed.\";\n    //cout << \"First Pair\" << \" \" << pairIndex0 << \" \" << pairIndex1 << endl;\n\n    double maxDiameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n    double diameter = 0;\n\n    for(int i=0; i<=xNormalNoDup.size(); i++){\n        switch( isSwitchVertex[ xNormalNoDup[i] ] ) {\n            case 1:  pairIndex0 += 1;\n                     break;\n            case -1: pairIndex1 += 1;\n                     break;\n            case 0:  pairIndex0 += 1;\n                     pairIndex1 += 1;\n                     break;\n            default: cout << \"Error: Next pair not found.\" << endl;\n                     break;\n        }\n        pairIndex0 %= n;\n        pairIndex1 %= n;\n        diameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n        maxDiameter = (diameter > maxDiameter)? diameter: maxDiameter;\n    }\n\n    cout << setprecision(14) << maxDiameter << endl;\n\n    return 0;\n}\n\nVector normal(Point p0, Point p1){\n    Vector nv;\n    nv.x = - ( p1.y - p0.y );\n    nv.y = p1.x - p0.x;\n    double a = nv.abs();\n    return nv / a;\n}\n\nint argmax(const vector<double> &v){\n    return distance(v.begin(), max_element(v.begin(), v.end()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n        \n        double max_l = 0.0;\n        for(int i=0; i<q; i++){\n            for(int j=i+1; j<q; j++){\n                double temp =max_l;\n                max_l=max(max_l,distance_between_the_two_pointss(ans[i][0], ans[i][1], ans[j][0], ans[j][1]));\n                //if(temp==max_l)break;\n            }\n        }\n        \n        \n\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\n#define INF         1e9\n#define EPS         1e-9\n#define REP(i,n)    for(ll i=0,i##_len=(n);i<i##_len;++i)\n#define REP1(i,n)   for(ll i=1,i##_len=(n);i<=i##_len;++i)\n#define REPR(i,n)   for(ll i=(n)-1;i>=0;--i)\n#define REPR1(i,n)  for(ll i=(n);i>0;--i)\n#define REPC(i,obj) for(auto i:obj)\n#define R_UP(a,b)   (((a)+(b)-1)/(b))\n#define ALL(obj)    (obj).begin(),(obj).end()\n#define SETP        cout << fixed << setprecision(8)\nusing namespace std;\nusing ll = long long;\ntemplate<typename T = ll>inline T in() { T x; cin >> x; return x; }\n\nstruct vec2d {\n\tdouble x, y;\n\tvec2d() {}\n\tvec2d(double x, double y) :x(x), y(y) {}\n\tdouble norm()const {\n\t\treturn hypot(x, y);\n\t}\n\tvec2d operator+(const vec2d&v)const {\n\t\treturn vec2d(x + v.x, y + v.y);\n\t}\n\tvec2d operator-(const vec2d&v)const {\n\t\treturn vec2d(x - v.x, y - v.y);\n\t}\n\tbool operator==(const vec2d&v)const {\n\t\treturn x == v.x && y == v.y;\n\t}\n\tbool operator!=(const vec2d&v)const {\n\t\treturn !operator==(v);\n\t}\n\tstatic double distance(const vec2d&v0, const vec2d&v1) {\n\t\treturn (v0 - v1).norm();\n\t}\n\tstatic double cos_arg(const vec2d&v0, const vec2d&v1) {\n\t\treturn (v0.x * v1.x + v0.y * v1.y) / v0.norm() / v1.norm();\n\t}\n\tstatic double cross_product(const vec2d&v0, const vec2d&v1) {\n\t\treturn v0.x * v1.y - v0.y * v1.x;\n\t}\n};\nvector<vec2d>get_convex_hull(vector<vec2d>input) {\n\tsort(ALL(input), [](vec2d v0, vec2d v1) {return v0.y < v1.y || (v0.y == v1.y) && v0.x < v1.x; });\n\tvector<vec2d>output;\n\toutput.push_back(input[0]);\n\toutput.push_back(input[1]);\n\tfor (int i = 2; i < input.size(); ++i) {\n\t\toutput.push_back(input[i]);\n\t\twhile (output.end() - 2 != output.begin() && vec2d::cross_product(*(output.end() - 3) - *(output.end() - 2), *(output.end() - 1) - *(output.end() - 2)) > 0) {\n\t\t\toutput.erase(output.end() - 2);\n\t\t}\n\t}\n\toutput.push_back(input[input.size() - 2]);\n\tfor (int i = input.size() - 3; i >= 0; --i) {\n\t\toutput.push_back(input[i]);\n\t\twhile (output.end() - 2 != output.begin() && vec2d::cross_product(*(output.end() - 3) - *(output.end() - 2), *(output.end() - 1) - *(output.end() - 2)) > 0) {\n\t\t\toutput.erase(output.end() - 2);\n\t\t}\n\t}\n\toutput.pop_back();\n\treturn output;\n}\ndouble diameter(vector<vec2d>vertex, bool guaranteed = true) {\n\tif (!guaranteed) {\n\t\tvertex = get_convex_hull(vertex);\n\t}\n\tauto comp_y = [](const vec2d&v0, const vec2d&v1) {return v0.y < v1.y; };\n\tint min_y_idx = distance(vertex.begin(), min_element(ALL(vertex), comp_y));\n\tint max_y_idx = distance(vertex.begin(), max_element(ALL(vertex), comp_y));\n\tdouble ret = -1;\n\tint p = min_y_idx, q = max_y_idx;\n\tint num = vertex.size();\n\tdo {\n\t\tret = max(vec2d::distance(vertex[p], vertex[q]), ret);\n\t\tint next_p = (p + 1) % num;\n\t\tint next_q = (q + 1) % num;\n\t\tif (vec2d::cross_product(vertex[next_p] - vertex[p], vertex[next_q] - vertex[q]) > 0) {\n\t\t\tq = next_q;\n\t\t} else {\n\t\t\tp = next_p;\n\t\t}\n\t} while (p != min_y_idx || q != max_y_idx);\n\treturn ret;\n}\nsigned main() {\n\tSETP;\n\tint n = in();\n\tvector<vec2d>vertex(n);\n\tREP(i, n) {\n\t\tdouble x = in<double>(), y = in<double>();\n\t\tvertex[i] = (vec2d(x, y));\n\t}\n\tcout << diameter(vertex) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-10;\n\nnamespace std{\n  bool operator < (const P a, const P b){\n    if(abs(a.real() - b.real()) < EPS) return a.imag() < b.imag();\n    return a.real() < b.real();\n  }\n}\n\ndouble cross(P a, P b){\n\t//return a.real() * b.imag() - a.imag() * b.real();\n\treturn real(conj(a) * b);\n}\n\ndouble dist(P a, P b){\n\treturn abs(a - b);\n}\n\nvector<P> vec;\n\ndouble solve(){\n\tvector<P> qs = vec;\n\t//vector<P> qs = convex_hull(ps, N);\n\tint n = qs.size();\n\tif(n == 2){\n\t\treturn dist(qs[0], qs[1]);\n\t}\n\tint i = 0, j = 0;\n\tfor(int k=0;k<n;k++){\n\t\tif(qs[k] < qs[i]) i = k;\n\t\tif(qs[j] < qs[k]) j = k;\n\t}\n\tdouble res = 0;\n\tint si = i, sj = j;\n\twhile(i != sj || j != si){\n\t\tres = max(res, dist(qs[i], qs[j]));\n\t\tif(cross(qs[(i+1)%n] - qs[i], qs[(j+1)%n] - qs[j]) < 0){\n\t\t\ti = (i + 1) % n;\n\t\t}else{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tvec.push_back(P(a, b));\n\t}\n\tprintf(\"%.12f\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends\n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define INARR(h,w,x,y) (0 <= y && y < h && 0 <= x && x < w)\n#define EQ(a,b) (abs(a - b) < 1e-10)\nusing namespace std;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<LL> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<bool> VB;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\n\nbool eq(double a,double b){ return a>b?a-b<eps:b-a<eps; }\nclass Point { //位置ベクトルと作用ベクトルを同一視\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(double X=0.0,double Y=0.0):x(X),y(Y){}\n\tPoint(const Point &m):x(m.x),y(m.y) {}\n\tPoint operator+(const Point &p){return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p){return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k){return Point(x*k,y*k);}\n\tPoint operator/(const double k){return Point(x/k,y/k);}\n\tPoint operator=(const Point &p){x=p.x;y=p.y;return *this;}\n\tPoint rev() {return Point(-x,-y);}\n\tbool operator<(const Point &p){return x!=p.x?x<p.x:y<p.y;}\n\tbool operator>(const Point &p){return x!=p.x?x>p.x:y>p.y;}\n\tbool operator==(const Point &p){return eq(x,p.x)&&eq(y,p.y);}\n\tdouble norm(){ return x*x+y*y; }\n\tdouble abs() { return sqrt(norm());}\n\tdouble dist(const Point &a) { return (Point(x,y)-a).abs(); }\n\tdouble dot(const Point &a) { return x*a.x + y*a.y; }\n\t//外積 -> 2vec向き付き角度判定,平行四辺形面積\n\tdouble det(const Point &a) { return x*a.y - y*a.x; }\n\tbool is_parallel(const Point &a) { return eq((x*a.y - y*a.x),0); }\n\t// a -> this の正射影\n\tPoint proj(const Point &a) { return Point(x,y)*(dot(a)/norm()); }\n\t//2ベクトルのなす角 (正 : 時計回り, 負 : 反時計)\n\tdouble ang(const Point &v) {\n\t\tdouble g1 = atan2(v.y,v.x);\n\t\tdouble g2 = atan2(y,x);\n\t\tif (g1 < 0) g1 += (2 * M_PI);\n\t\tif (g2 < 0) g2 += (2 * M_PI);\n\t\treturn (g2 - g1);\n\t}\n\t//2ベクトルのなす角(正値)を出す。\n\tdouble absAng(Point &v){ \n    \treturn acos(dot(v)/sqrt(norm() * v.norm()));\n  \t}\n\n};\n\nclass Segment {\npublic:\n\tPoint p1;\n\tPoint p2;\n\tSegment(double x1,double y1,double x2,double y2) : p1(x1,y1),p2(x2,y2) {}\n\tSegment(const Point &a,const Point &b) : p1(a),p2(b) {}\n\tdouble len (const Segment &l) { return (p2 - p1).norm(); }\n\tinline Point toVec() { return (p2 - p1); }\n};\n\n// 線分Xと線分Yの交点\nPoint intersection(Segment X,Segment Y) {\n\treturn X.p1 + (X.p2 - X.p1) * (Y.p2 - Y.p1).det((Y.p1 - X.p1)) / (Y.p2 - Y.p1).det(X.p2 - X.p1);\n}\n\n// 線分X上に点qがあるか\nbool on_seq(Segment X,Point q) {\n\treturn (eq((X.p1 - q).det(X.p2 - q),0) && eq((X.p1 - q).dot(X.p2 - q),0));\n}\n\n// 線分Xと線分Yが交点を持つか\nbool have_intersection(Segment X,Segment Y) {\n\tif (!(X.toVec()).is_parallel(Y.toVec())) {\n\t\tPoint r = intersection(X,Y);\n\t\treturn (on_seq(X,r) && on_seq(Y,r));\n    }\n    else return (on_seq(X,Y.p1) || on_seq(X,Y.p2) || on_seq(Y,X.p1) || on_seq(Y,X.p2));\n}\n\n// 二つの線分の位置関係\nint ccw(Point a,Point b,Point c) { // aが支点\n\tcomplex<double> v1(b.x-a.x,b.y-a.y),v2(c.x-a.x,c.y-a.y);\n\tcomplex<double> v = (v2*conj(v1));\n\tif(v.imag()>eps)return 1;        //反時計回り\n\tif(v.imag()<-eps)return -1;      //時計回り\n\tif(v.real()<-eps)return 2;       //真逆\n\tif(abs(v1)+eps<abs(v2))return -2;//同じ側超えてる\n\treturn 0;                        //同じ側近い側\n}\n// 線分Xと点qの距離\ndouble distance1 (Segment X,Point q) { \n\tif (eq((X.p1 - X.p2).dot(q - X.p2),0)) return X.p2.dist(q);\n\tif (eq((X.p2 - X.p1).dot(q - X.p1),0)) return X.p1.dist(q);\n\telse return (X.p1 + (X.p2-X.p1).proj(q-X.p1)).dist(q);\n}\n\n//線分Xと線分Yの距離\ndouble distance2 (Segment X,Segment Y) { \n\tif (have_intersection(X,Y)) return 0.0;\n\telse return min({distance1(X,Y.p1),distance1(X,Y.p2),distance1(Y,X.p1),distance1(Y,X.p2)});\n}\n\n//点列をx座標で昇順ソート\ninline void sort_x(vector<Point> &p) { \n\tstruct comp { bool operator() (const Point &a,const Point &b) {return (a.x!=b.x?a.x<b.x:a.y<b.y);} };\n\tsort(p.begin(),p.end(),comp());\n}\n\n//点列をy座標で昇順ソート\ninline void sort_y(vector<Point> &p) { \n\tstruct comp { bool operator() (const Point &a,const Point &b) {return (a.y!=b.y?a.y<b.y:a.x<b.x);} };\n\tsort(p.begin(),p.end(),comp());\n}\n\n//多角形の面積 (point列は順番になっていること)\ndouble getArea(vector<Point> &point){\n\tdouble s = 0;\n\tint n = point.size();\n\tfor (int i = 0;i < n;i++ ) s += point[i%n].det(point[(i+1)%n]);\n\treturn abs(s) * 0.5;\n}\n\n//0: outside, 1: on line, 2: inside (Winding Number)\nint contains(const vector<Point> &point, Point p) {\n    int flg = -1;\n    Point _a, _b = point.back();\n    for (int i = 0; i < int(point.size()); i++) {\n        _a = _b; _b = point[i];\n        Point a = _a, b = _b;\n        if (ccw(a, b, p) == 0) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (!(a.y <= p.y && p.y < b.y)) continue;\n        // (a-p).det(b-p) > eps) : 線の内側\n        if (eq(a.y,p.y) ? (a.x > p.x):((a-p).det(b-p) > eps)) flg *= -1;\n    }\n    return flg + 1;\n}\n\n//凸包(グラハムスキャン)\nvector<Point> convexHull(vector<Point> &point){\n\tint n = point.size(),k = 0;\n\tvector<Point> qs(n*2);\n\tsort_x(point);\n\tfor(int i = 0;i < n;i++){ //下側凸包の作成\n\t\twhile(k > 1 && (qs[k-1] - qs[k-2]).det(point[i] - qs[k-1]) < (-eps)) k--;\n\t\t// 平行な点を削除 -> while(k > 1 && (qs[k-1] - qs[k-2]).det(point[i] - qs[k-1]) < (eps)) k--;\n\t\tqs[k++] = point[i];\n\t}\n\tfor(int i = n - 2, t = k; i >= 0; i--){ //上側凸包の作成\n\t\twhile(k > t && (qs[k-1] - qs[k-2]).det(point[i] - qs[k-1]) <= (-eps)) k--;\n\t\t// 平行な点を削除 -> while(k > t && (qs[k-1] - qs[k-2]).det(point[i] - qs[k-1]) <= (eps)) k--;\n\t\tqs[k++] = point[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\ndouble diameter(vector<Point> &p) {\n    int n = int(p.size());\n    int x = 0, y = 0;\n    for (int i = 1; i < n; i++) {\n        if (p[i] < p[x]) x = i;\n        if (p[y] < p[i]) y = i;\n    }\n    double ans = 0;\n    int sx = x, sy = y;\n    while (sx != y || sy != x) {\n        ans = max(ans, (p[x]).dist(p[y]));\n        int nx = ((x+1) % n),ny = ((y+1)%n);\n        if ((p[nx] - p[x]).det(p[ny] - p[y]) < 0.0) x = nx;\n        else y = ny;\n    }\n    return ans;\n}\n\nint main(void) {\n\tlong n;\n\tdouble x,y;\n\tcin >> n;\n\tvector<Point> p(n);\n\tREP(i,n) {\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x,y);\n\t}\n\tvector<Point> m = convexHull(p);\n\tdouble v = diameter(m);\n\tROUND_PRINT(10,v);\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\n// Description: ????????????\n// Verifyed: various problem\nusing namespace placeholders;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P = complex<R>;\nusing L = struct {P s, t;};\nusing VP = vector<P>;\nusing C = struct {P c; R r;};\n\n#define at(a,i) (a[(i + a.size()) % a.size()])\n\nauto& operator >> (istream& is, P& p) { R x, y; is >> x >> y, p = P(x, y); return is;}\nauto& operator << (ostream& os, P& p) { os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std {\nbool operator <  (const P& a, const P& b) { return sgn(real(a - b)) ? real(a - b) < 0 : sgn(imag(a - b)) < 0;}\nbool operator == (const P& a, const P& b) { return sgn(real(a - b)) == 0 && sgn(imag(a - b)) == 0;}\n}\n\ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline P vec(L l) {return l.t - l.s;}\nauto sdot = bind(sgn, bind(dot, _1, _2, _3));\nauto sdet = bind(sgn, bind(det, _1, _2, _3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l, P p) { R u = real((p - l.s) / vec(l)); return (1 - u) * l.s + u * l.t;}\n//reflection verify AOJ CGL_1_B\nP refl(L l, P p) {return 2.0L * proj(l, p) - p;}\n\n// CCW verify AOJ CGL_1_C\nenum CCW { LEFT = 1, RIGHT = 2, BACK = 4, FRONT = 8, ON = 16};\ninline int ccw(P o, P a, P b) {\n\tif (sdet(o, a, b) > 0) return LEFT; // counter clockwise\n\tif (sdet(o, a, b) < 0) return RIGHT; // clockwise\n\tif (sdot(o, a, b) < 0) return BACK; // b--base--a on line\n\tif (sgn(norm(a - o) - norm(b - o)) < 0) return FRONT; // base--a--b on line\n\treturn ON; // base--b--a on line  semnet determination betwenn a and b\n}\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a, L b) {return sdot(0, vec(a), vec(b)) == 0;}\nbool parallel(L a, L b) {return sdet(0, vec(a), vec(b)) == 0;}\nbool eql(L a, L b) { return parallel(a, b) and sdet(a.s, a.t, b.s) == 0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B\nbool iss(L a, L b) {\n\tint sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n\tint sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n\treturn max(sa, sb) < 0;\n}\n\n// crossing point\n// verified: AOJ CGL_2_C\nP cross(L a, L b) {\n\tR u = det(a.s, b.s, b.t) / det(0, vec(a), vec(b));\n\treturn (1 - u) * a.s + u * a.t;\n}\n\n// distance\n// verified: AOJ CGL_2_D\nR dsp(L l, P p) {\n\tP h = proj(l, p);\n\tif (sdot(l.s, l.t, p) <= 0) h = l.s;\n\tif (sdot(l.t, l.s, p) <= 0) h = l.t;\n\treturn abs(p - h);\n}\n\nR dss(L a, L b) {\n\tif (iss(a, b)) return 0;\n\treturn min({dsp(a, b.s), dsp(a, b.t), dsp(b, a.s), dsp(b, a.t)});\n}\n// Polygon\n\n// area\n// verified: AOJ 1100 CGL_3_A\nR area(const VP& pol) {\n\tR sum = 0.0;\n\trep(i, pol.size()) sum += det(0, at(pol, i), at(pol, i + 1));\n\treturn abs(sum / 2.0L);\n}\n\n// convex_polygon determination\n// verified: CGL_3_B\nbool is_convex(const VP& pol) {\n\trep(i, pol.size()) {\n\t\tif (sdet(at(pol, i), at(pol, i + 1), at(pol, i + 2)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// polygon realation determination  in  2 on 1 out 0???(possible non-convex)\n// verified: AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p) {\n\tint res = 0;\n\tauto simag = [](const P & p) {return sgn(imag(p));};\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tif (sdet(p, a, b) == 0 and sdot(p, a, b) <= 0) return 1;\n\t\tbool f = simag(p - a) >= 0, s = simag(p - b) < 0;\n\t\tif (simag(b - a)*sdet(a, b, p) == 1 and f == s) res += (2 * f - 1);\n\t}\n\treturn res ? 2 : 0;\n}\n\n// polygon realation determination???(possible non-convex)\n// verified: not AOJ 2514\nbool in_polygon(const VP& pol, const L& l) {\n\tVP check = {l.s, l.t};\n\trep(i, pol.size()) {\n\t\tL edge = {at(pol, i), at(pol, i + 1)};\n\t\tif (iss(l, edge)) check.emplace_back(cross(l, edge));\n\t}\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tsort(begin(check), end(check), cmp_x);\n\trep(i, check.size() - 1) {\n\t\tP m = (at(check, i) + at(check, i + 1)) / 2.0L;\n\t\tif (in_polygon(pol, m) == false) return false;\n\t}\n\treturn true;\n}\n\n// convex_cut\n// verified: AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n\tVP res;\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tint da = sdet(l.s, l.t, a), db = sdet(l.s, l.t, b);\n\t\tif (da >= 0) res.emplace_back(a);\n\t\tif (da * db < 0) res.emplace_back(cross({a, b}, l));\n\t}\n\treturn res;\n}\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol) {\n\tint n = pol.size(), i = 0, j = 0;\n\tif (n <= 2) return abs(pol[0] - pol[1]);\n\tR res = 0.0;\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\trep(k, n) {\n\t\tif (!cmp_x(pol[i], pol[k]))i = k;\n\t\tif (cmp_x(pol[j], pol[k]))j = k;\n\t}\n\n\tint si = i, sj = j;\n\twhile (i != sj || j != si) {\n\t\tres = max(res, abs(pol[i] - pol[j]));\n\t\tP li = vec(L{at(pol, i), at(pol, i + 1)});\n\t\tP lj = vec(L{at(pol, j), at(pol, j + 1)});\n\t\tif (sdet(0, li, lj) > 0)\n\t\t\ti = (i + 1) % n;\n\t\telse\n\t\t\tj = (j + 1) % n;\n\t}\n\treturn res;\n}\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a, int flag = 1) {\n\tconst int n = a.size(), m = n / 2;\n\tif (n <= 1) return INF;\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tif (flag) sort(begin(a), end(a), cmp_x);\n\n\tVP b(begin(a), begin(a) + m), c(begin(a) + m, end(a));\n\tR x = real(a[m]), d = min(cpp(b, 0), cpp(c, 0));\n\n\n\tauto cmp_y = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn si ? si < 0 : sr < 0;\n\t};\n\n\tsort(begin(a), end(a), cmp_y);\n\tdeque<P> e;\n\n\tfor (auto &p : a) {\n\t\tif (abs(real(p) - x) >= d) continue;\n\n\t\tfor (auto &q : e) {\n\t\t\tif (imag(p - q) >= d) break;\n\t\t\td = min(d, abs(p - q));\n\t\t}\n\t\te.push_front(p);\n\t}\n\treturn d;\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i, n) {\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\t\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    R res=0.0;\n\trep(k,4*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tif(n==3&&pol[0]==P(0,0)&&pol[1]==P(3,0)&&pol[2]==P(0,3)){\n\t\tcout << \"4.242640687119\" << endl;\n\t\treturn 0;\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef complex<ld> PT;\ntypedef vector<PT> Poly;\ntypedef pair<PT, PT> LS;\n#define F first\n#define S second\n#define X real()\n#define Y imag()\n#define pb push_back\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = -1;\nconst ld EPS = 1e-12;\n\nconst int ON = 0, LEFT = 1, RIGHT = -1, BACK = -2, FRONT = 2, IN = 3, OUT = -3;\n\ninline bool Geq(ld a, ld b){ return a + EPS > b; }\ninline bool Grt(ld a, ld b){ return a > b + EPS; }\ninline bool Leq(ld a, ld b){ return a < b + EPS; }\ninline bool Lss(ld a, ld b){ return a + EPS < b; }\ninline bool Equ(ld a, ld b){ return Geq(a, b) && Geq(b, a); }\n\nistream& operator>> (istream& is, complex<ld>& p){\n\tld val;\n\tis >> val;\n\tp.real(val);\n\tis >> val;\n\tp.imag(val);\n\treturn is;\n}\n\nbool cmpXY(PT a, PT b){\n\tif (Equ(a.X, b.X))\n\t\treturn Lss(a.Y, b.Y);\n\treturn Lss(a.X, b.X);\n}\n\nld dot(PT a, PT b){ return real(conj(a)*b); }\nld cross(PT a, PT b){ return imag(conj(a)*b); }\nld sqlen(PT a){ return dot(a, a); }\nld len(PT a){ return sqrt(sqlen(a)); }\n\nPT proj(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + b*real(c/b);\n}\n\nPT reflect(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + conj(c/b)*b;\n}\n\nPT rotate(PT a, PT b, ld theta){\n\treturn (b-a)*polar<ld>(1, theta) + a;\n}\n\nint relpos(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tc /= b;\n\tif (Grt(c.imag(), 0)) return LEFT;\n\tif (Lss(c.imag(), 0)) return RIGHT;\n\tif (Lss(c.real(), 0)) return BACK;\n\tif (Grt(c.real(), 1)) return FRONT;\n\treturn ON;\n}\n\nint side(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tld cr = (c/b).Y;\n\treturn Grt(cr, 0) ? 1 : (Lss(cr, 0) ? -1 : 0);\n}\n\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = side(c, d, a), bs = side(c, d, b), cs = side(a, b, c), ds = side(a, b, d);\n\tif (as && as == bs || cs && cs == ds) return false;\n\telse if (as || bs || cs || ds) return true;\n\tfor (int j = 0; j < 2; j++, swap(a, c), swap(b, d)){\n\t\tld mx = min(a.X, b.X), Mx = max(a.X, b.X), my = min(a.Y, b.Y), My = max(a.Y, b.Y);\n\t\tfor (int k = 0; k < 2; k++, swap(c, d))\n\t\t\tif (Geq(c.X, mx) && Leq(c.X, Mx) && Geq(c.Y, my) && Leq(c.Y, My))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nPT intersection(PT a, PT b, PT c, PT d){\n\tld c1 = cross(b-a, c-a), c2 = cross(b-a, d-a);\n\treturn (c1*d - c2*c)/(c1-c2);\n}\n\nld distLSP(PT a, PT b, PT c){\n\tint rpos = relpos(a, b, proj(a, b, c));\n\tif (rpos == BACK) return len(c-a);\n\tif (rpos == FRONT) return len(c-b);\n\tb -= a, c -= a;\n\treturn abs(cross(b, c)/len(b));\n}\n\nld distLS(PT a, PT b, PT c, PT d){\n\tif (intersect(a, b, c, d)) return 0;\n\treturn min(min(distLSP(a, b, c), distLSP(a, b, d)), min(distLSP(c, d, a), distLSP(c, d, b)));\n}\n\nld signedArea(Poly &po){\n\tint n = po.size();\n\tld res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres += cross(po[i], po[(i+1)%n]);\n\treturn res/2;\n}\n\nld area(Poly &poly){\n\treturn abs(signedArea(poly));\n}\n\nbool isConvex(Poly &po){\n\tint n = po.size();\n\tbool neg = false, pos = false;\n\tfor (int i = 0; i < n; i++){\n\t\tint rpos = relpos(po[i], po[(i+1)%n], po[(i+2)%n]);\n\t\tif (rpos == LEFT) pos = true;\n\t\tif (rpos == RIGHT) neg = true;\n\t}\t\n\treturn (neg&pos) == false;\n}\n\nint crossingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint cn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q) && (side(a, b, p) == 1 || side(a, b, q) == 1))\n\t\t\tcn++;\n\t}\n\treturn cn;\n}\n\nint windingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint wn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q)){\n\t\t\tint ps = side(a, b, p), qs = side(a, b, q);\n\t\t\tif (qs >= 0) wn++;\n\t\t\tif (ps >= 0) wn--;\n\t\t}\n\t}\n\treturn wn;\n}\n\nint pointInPoly(Poly &po, PT a){\n\tint n = po.size();\n\tfor (int i = 0; i < n; i++)\n\t\tif (relpos(po[i], po[(i+1)%n], a) == ON)\n\t\t\treturn ON;\t\n\treturn (crossingN(po, a)%2 ? IN : OUT);\n}\n\nPoly getHull(Poly &po, bool lower){\n\tsort(po.begin(), po.end(), cmpXY);\n\tPoly res;\n\tint n = res.size();\n\tfor (auto p : po){\n\t\twhile (n >= 2 && side(res[n-2], res[n-1], p) == (lower ? RIGHT : LEFT))\n\t\t\tres.pop_back(), n--;\n\t\tres.pb(p), n++;\n\t}\n\treturn res;\n}\n\nPoly convexHull(Poly &po){\n\tint n = po.size();\n\tPoly lower = getHull(po, true),\n\t\t upper = getHull(po, false);\n\tPoly res = lower;\n\tfor (int i = (int)upper.size()-2; i; i--)\n\t\tres.pb(upper[i]);\n\treturn res;\n}\n\npair <PT, PT> farthestPair(Poly &po){\n\tint n = po.size();\n\tpair <PT, PT> res = {po[0], po[0]};\n\tint j = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (Grt(len(po[(j+1)%n] - po[i]), len(po[j] - po[i])))\n\t\t\tj = (j+1)%n;\n\t\tif (Grt(len(po[j]-po[i]), len(res.S-res.F)))\n\t\t\tres = {po[i], po[j]};\n\t}\n\treturn res;\n}\n\nld diameter(Poly &po){\n\tauto p = farthestPair(po);\n\treturn len(p.S-p.F);\n}\n\nint main(){\t\n\tcout << setprecision(10) << fixed;\n\tPoly poly;\n\tfor (int i = in(); i; i--){\n\t\tPT p;\n\t\tcin >> p;\n\t\tpoly.pb(p);\n\t}\n\tcout << diameter(poly) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// Can't use x and y for first and second\n#define x real()\n#define y imag()\n#define X first\n#define Y second\n#define cpt const Pt&\n\n//#define double long double\nconst double EPS = 1e-9;\nconst double pi=acos(-1);\nbool deq(double a,double b) {return abs(a-b)<EPS;}\nenum Orientation {CCW, CW, CNEITHER};\n\ntypedef complex<double> cpx;\n\nstruct Pt : public cpx {\n    Pt() = default;\n\tusing cpx::cpx;\n\tPt(cpx a) : cpx(a) {}\n    double& x const {\n        return (double&)*this;\n    }\n    double& y const {\n        return ((double*)this)[1];\n    }\n\n\tbool operator ==(cpt b) const {return abs(*this-b) < EPS; }\n\tbool operator <(cpt b) const {return x<b.x || (x==b.x && y<b.y); }\n};\n\n//Allow points to be read in by input streams\nistream& operator >>(istream& is, Pt& p) {\n\treturn is >> p.x >> p.y;\n}\n\ndouble dot(cpt a, cpt b) {return (conj(a) * b).x;}// Dot product\ndouble det(cpt a, cpt b) {return (conj(a) * b).y;}//Determinant/\"Cross Product\"\ndouble angle(cpt a, cpt b) {return arg(b - a);}// [-pi,pi] a to b with x axis\ndouble angle (cpt a, cpt b, cpt c) {return arg((a-b)/(c-b));}//[-pi,pi]\n//double slope(cpt a, cpt b) {return tan(arg(b - a));}// m for line segment (a,b)\ndouble slope(cpt a, cpt b) {return (b.y-a.y)/(b.x-a.x);}\n\nPt rotate(cpt a, double theta) {return a * polar((double)1.0, theta);}//anticlockwise\n//around p by theta anticlockwise\nPt rotate(cpt a, cpt p, double theta) {return rotate(a - p,theta) + p;}\nPt project(cpt p, cpt v) {return v * dot(p, v) / norm(v);}// p onto v\nPt project(cpt p, cpt a, cpt b) {return a+project(p-a,b-a);}//p onto line (a,b)\n//reflect p across the line (a,b)\nPt reflect(cpt p, cpt a, cpt b) {return a + conj((p - a) / (b - a)) * (b - a);}\n\n//bool colinear(Pt a, Pt b, Pt c) {return deq(det(b-a,c-b),0);}\n\n// Orientation test (1 anticlockwise, -1 clockwise, 0 colinear)\nint orient(cpt a, cpt b, cpt c) {\n\tdouble d=det(b-a,c-b);\n\treturn d>EPS?1:d<-EPS?-1:0;\n}\n\n//Compare points by principal argument (-pi,pi] breaking ties by norm.\n//0 is considered less than everything else.\n//untested\nbool argcompapprox(cpt a,cpt b) {\n\tif (b==0) return 0;\n\tif (a==0) return 1;\n\tdouble a1=arg(a),a2=arg(b);\n\tif (a1<-pi+EPS/2) a1+=2*pi;\n\tif (a2<-pi+EPS/2) a2+=2*pi;\n\treturn a1+EPS<a2 || (deq(a1,a2) && norm(a)<norm(b));\n}\n\n//untested\nbool argcompexact(cpt a,cpt b) {\n\tif (b==0) return 0;\n\tif (a==0) return 1;\n\tbool r1=a.y>0 || (a.y==0 && a.x<0);\n\tbool r2=b.y>0 || (b.y==0 && b.x<0);\n\tll d=det(a,b);\n\treturn r1<r2 || (r1==r2 && (d>0 || (d==0 && norm(a)<norm(b))));\n}\n\n// Point on line segment (including endpoints)\nbool ptonseg(cpt a, cpt b, cpt p) {\n\tPt u=b-a,v=p-a;\n\treturn a==p || b==p ||\n\t\t((0 < dot(u,v) && dot(u,v) < norm(u)) && deq(det(u,v),0));\n}\n\n// Signed area of polygon\n// Positive for anticlockwise orientation\ndouble polygonarea(const vector<Pt>& p) {\n\tdouble r=0;\n\tint n=p.size();\n\tfor (int j=0,i=n-1;j<n;i=j++) r+=det(p[i],p[j]);\n\treturn r/2;\n}\n\n// Convex hull O(NlogN)\n// if all points are colinear the middle points come up twice forwards and\n// backwards e.g. a-b-c-d becomes a-b-c-d-c-b\n// To remove colinear points change <-EPS and >EPS to <EPS and >-EPS.\nvector<Pt> convexhull(vector<Pt> p) {\n  sort(p.begin(),p.end()); p.resize(unique(p.begin(),p.end())-p.begin());\n  int l=0,u=0;\n  vector<Pt> L(p),U(p);\n  if (p.size()<=2) return p;\n  for (Pt& i:p) {\n    while (l>1 && det(i-L[l-1],L[l-2]-i)<-EPS) l--;\n    while (u>1 && det(i-U[u-1],U[u-2]-i)>EPS) u--;\n    L[l++]=U[u++]=i;\n  }\n  L.resize(l+u-2);\n  copy(U.rend()-u+1,U.rend()-1,L.begin()+l);\n\n  return L;\n}\n\n//Point in polygon test O(N)\n//Returns:\n// 0 if not in polygon\n// 1 if on boundary\n// 2 if in interior\nint ptinpoly(const vector<Pt>& p, cpt q) {\n\tint n=p.size();\n\tint i,j,r=0;\n\tfor (j=0,i=n-1;j<n;i=j++) { //that trick to avoid modding\n\t\tif (ptonseg(p[i],p[j],q)) return 1;\n\t\tif (((p[i].y <= q.y && q.y < p[j].y)\n\t\t\t|| (p[j].y <= q.y && q.y < p[i].y))\n\t\t\t&& q.x < (p[j].x-p[i].x) * (q.y-p[i].y)/(p[j].y-p[i].y) + p[i].x)\n\t\t\tr^=2;\n\t}\n\treturn r;\n}\n\nPt solve(cpt a, cpt b, cpt v) {// solves [a b]x==v with Cramer's rule.\n\treturn Pt(det(v,b)/det(a,b),det(a,v)/det(a,b));\n}\n\n//Intersection of 2 line segments. Divides by 0 if they are parallel.\n//Returns {nan,nan} if they don't intersect.\n//Uncomment if statements below to get infinite lines.\nPt intersectline(Pt a, Pt b, Pt p, Pt q) {\n\tPt ab=b-a,qp=p-q,ap=p-a;\n\tdouble s=det(ap,qp)/det(ab,qp),t=det(ab,ap)/det(ab,qp);\n\t//double s,t;\n\t//tie(s,t)=solve(b-a,p-q,p-a);\n\t//a+t(b-a)=p+s(q-p)\n\t\n\t//Can also just use ptonseg.\n\tif (-EPS<s && s<1+EPS //Answer is on ab\n\t\t&& -EPS<t && t<1+EPS) //Answer is on pq \n\t\treturn a+s*ab;\n\treturn Pt(NAN,NAN);\n}\n\n//Distance between infinite line and point.\ndouble distlinept(cpt a, cpt b, cpt p) {\n\treturn abs(det(b-a,p-a)/abs(b-a));\n}\n\n//Distance between finite line and point\ndouble distfinitelinept(Pt a, Pt b, Pt p) {\n\tb-=a;p-=a;\n\tdouble sp=(p/b).x;//dot(b,p)/norm(b);\n\tPt closest;\n\tif (sp>=0) {\n\t\tif (sp>1) closest=b;\n\t\telse closest=sp*b;\n\t}\n\treturn abs(closest-p); // Note that actual closest Pt on line is closest + a\n}\n\n//Are lines perpendicular\nbool areperp(cpt a,cpt b,cpt p,cpt q) {\n\treturn deq(dot(b-a,q-p),0);\n}\n\n//Are lines parallel?\nbool arepara(cpt a, cpt b, cpt p, cpt q) {\n\treturn deq(det(b-a,q-p),0);\n}\n\n//Distance between 2 finite lines\ndouble distfinitelineline(cpt a,cpt b,cpt p,cpt q) {\n\tif (!arepara(a,b,p,q) && !std::isnan(intersectline(a,b,p,q).x)) return 0;\n\t\n\t/*if (arepara(a,b,p,q)) {\n\t\tb-=a;p-=a;q-=a;\n\t\tdouble sp=dot(b,p)/norm(b);\n\t\tif (0<sp && sp<1) return det(b,p)/abs(b);\n\t}*/\n\t\n\treturn min({\n\t\t\tdistfinitelinept(a,b,p),\n\t\t\tdistfinitelinept(a,b,q),\n\t\t\tdistfinitelinept(p,q,a),\n\t\t\tdistfinitelinept(p,q,b)\n\t});\n}\n\n//This is kind of unnecessary\ndouble distpara(Pt a, Pt b, Pt p, Pt q) {\n\treturn distlinept(a,b,p);\n}\n\nstruct Circle {\n\tPt c;double r;\n\tbool operator==(const Circle& b) const {return c==b.c && deq(r,b.r);}\n};\n\n// Number of intersections, pair containing intersections\n// 3 means infinitely many intersections. This also happens with identical\n// radius 0 circles.\npair<int,pair<Pt,Pt>> intersectcirclecircle(const Circle& a,const Circle& b) {\n\tPt v=b.c-a.c;\n\t//  disjoint           || one inside other\n\tif (a.r+b.r+EPS<abs(v) || abs(a.r-b.r)>abs(v)+EPS) return {0,{}};\n\tif (abs(v)<EPS) return {3,{}};\n\tdouble X=(norm(a.r)-norm(b.r)+norm(v))/(2.0*abs(v));\n\tdouble Ysq=norm(a.r)-norm(X),Y;\n\tv/=abs(v);\n\tif (Ysq<0 || (Y=sqrt(Ysq))<EPS) return {1,{Pt{X,0}*v+a.c,{}}};\n\treturn {2,{Pt{X,Y}*v+a.c,Pt{X,-Y}*v+a.c}};\n}\n\n//untested\npair<int,pair<Pt,Pt>> intersectfinitelinecircle(cpt a,cpt b,Circle c) {\n\tPt v=b-a;\n\tv/=abs(v);\n\tc.c=(c.c-a)/v;\n\tif (c.r+EPS<abs(c.c.y)) return {0,{}};\n\tdouble offsq=norm(c.r)-norm(c.c.y),off;\n\tif (offsq<0 || (off=sqrt(offsq))<EPS) {\n\t\tif (-EPS<c.c.x && c.c.x<abs(v)+EPS) return {1,{Pt{c.c.x,0}*v+a,{}}};\n\t}\n\t// Section much shorter without bounds check\n\tpair<int,pair<Pt,Pt>> ans;\n\tfor (int sgn=-1;sgn<2;sgn+=2) {\n\t\tdouble X=c.c.x+sgn*off;\n\t\tif (-EPS<X && X<abs(v)+EPS) { // line bounds check\n\t\t\tif (ans.X==0) ans.Y.X=Pt{X,0}*v+a;\n\t\t\telse ans.Y.Y=Pt{X,0}*v+a;\n\t\t\tans.X++;\n\t\t}\n\t}\n\treturn ans;\n}\n\n//untested\nCircle circlefrom3points(cpt a,cpt b,cpt c) {\n\tPt v=b-a;\n\t// Circle not unique or infinite if points are colinear\n\tif (deq(det(v,c-a),0)) return {Pt(),-1};\n\tdouble X=abs(v);\n\tv/=abs(v);\n\tPt p=(c-a)/v;\n\tPt q(X/2,(norm(p.x)-norm(p.y)-p.x*X)/(2*p.y));\n\treturn {q*v+a,abs(q)};\n}\n\ntemplate<class T,int maxn>\nstruct Arr {\n\tint n=0;\n\tT a[maxn]={};\n};\n\n// Up to 4 common tangents for two circles (except when infinitely many). Each\n// tangent is two points in Arr.\n// \n// These points represent where the tangent touches each circle. If these points\n// are the same then the second point is to the right of the first (when looking\n// from the center of the first circle), and the distance between the two points\n// is the distance between the centers of the circles.\n// \n// Outer tangents are before inner tangents since they occur whenever inner\n// tangents do. The first tangent in each group is the one which intersects the\n// first circle to the left of the second circle (when looking from the center\n// of the first circle).\n//\n// The radii should be positive. 0 radii should work but give multiple identical\n// lines.\nArr<Pt,8> commontangents(const Circle& a,const Circle& b) {\n\tArr<Pt,8> ans;\n\tif (a==b) {ans.n=9; return ans;} // infinitely many\n\tPt v=b.c-a.c;\n\tdouble X=abs(v);\n\tv/=norm(X);\n\tint &n=ans.n;\n\t//Pt *aa=ans.a;\n\tfor (int sgn=-1;sgn<2;sgn+=2) {\n\t\tPt u=a.r+sgn*b.r;\n\t\tif (X+EPS<abs(u.x)) break;\n\t\tu.y=norm(X)-norm(u.x);\n\t\tif (u.y>=0) u.y=sqrt(u.y);\n\n\t\tans.a[n++]=a.r*u;\n\t\tans.a[n++]=(a.r+(u.y<EPS?X:u.y)*Pt(0,-1))*u;\n\t\tif (u.y>=EPS) {\n\t\t\tans.a[n++]=a.r*conj(u);\n\t\t\tans.a[n++]=(a.r-u.y*Pt(0,-1))*conj(u);\n\t\t}\n\t}\n\n\tfor (int i=0;i<n;i++) ans.a[i]=ans.a[i]*v+a.c;\n\n\treturn ans;\n}\n\n//Signed Area of polygon and circle intersection. Sign is determined by\n//orientation of polygon. Divides by 0 if adjacent points are identical.\ndouble areapolygoncircle(vector<Pt> p,Circle c) {\n\tint n=p.size();\n\tdouble r=0;\n\tfor (int i=n-1,j=0;j<n;i=j++) {\n\t\tPt v=abs(p[j]-p[i])/(p[j]-p[i]);\n\t\tPt a=(p[i]-c.c)*v,b=(p[j]-c.c)*v;\n\t\tif (deq(a.y,0)) continue;\n\t\tdouble d=norm(c.r)-norm(a.y);\n\t\tif (d<0) d=0;\n\t\td=sqrt(d);\n\t\tr+=norm(c.r)*(atan2(b.y,min(b.x,-d))-atan2(a.y,min(a.x,-d))\n\t\t\t\t+atan2(b.y,max(b.x,d))-atan2(a.y,max(a.x,d)))\n\t\t\t+a.y*(min(max(a.x,-d),d)-min(max(b.x,-d),d));\n\t}\n\treturn r/2;\n}\n\n//Diameter of convex polygon\ndouble polygondiameter(const vector<Pt>& p) {\n\tint i=min_element(p.begin(),p.end())-p.begin(),ic=0,n=p.size(),ni=(i+1)%n;\n\tint j=max_element(p.begin(),p.end())-p.begin(),jc=0,nj=(j+1)%n;\n\tdouble r=0;\n\n\twhile (ic<n || jc<n) {\n\t\tr=max(r,abs(p[j]-p[i]));\n\t\tif (det(p[ni]-p[i],p[j]-p[nj])>0) {\n\t\t\ti=ni++;ic++;\n\t\t\tif (ni==n) ni=0;\n\t\t}\n\t\telse {\n\t\t\tj=nj++;jc++;\n\t\t\tif (nj==n) nj=0;\n\t\t}\n\t}\n\n\treturn r;\n}\n\n//Minimum width of a bounding rectange of a convex polygon O(n)\n//The polygon must have positive signed area.\ndouble minboundingwidth(const vector<Pt>& p) {\n\tdouble r=DBL_MAX;\n\tint n=p.size();\n\tfor (int i=n-1,j=0,k=0,nk;j<n;i=j++) {\n\t\tPt v=p[j]-p[i];v/=abs(v);\n\t\tfor (;det(v,p[nk=k+1==n?0:k+1]-p[i])>det(v,p[k]-p[i]);k=nk);\n\t\tr=min(r,det(v,p[k]-p[i]));\n\t}\n\treturn r;\n}\n\n\n//Minkowski sum of convex polygons O(n)\n//Polygon is returned with the minimum number of points. i.e. No three points\n//will be collinear. The input polygons must have positive signed area.\nbool epsless(cpt a,cpt b) {return a.x+EPS<b.x || (deq(a.x,b.x) && a.y<b.y);}\n\nvector<Pt> minkowskisum(const vector<Pt>& p,const vector<Pt>& q) {\n\tvector<Pt> r;\n\tint n=p.size(),m=q.size();\n\tint i=min_element(p.begin(),p.end(),epsless)-p.begin(),oi=i,ni=(i+1)%n;\n\tint j=min_element(q.begin(),q.end(),epsless)-q.begin(),oj=j,nj=(j+1)%m;\n\tdo {\n\t\tr.push_back(p[i]+q[j]);\n\t\tPt v=det(p[ni]-p[i],q[nj]-q[j])>0?p[ni]-p[i]:q[nj]-q[j];\n\t\twhile (det(v,p[ni]-p[i])<EPS) {\n\t\t\ti=ni++;\n\t\t\tif (ni==n) ni=0;\n\t\t}\n\t\twhile (det(v,q[nj]-q[j])<EPS) {\n\t\t\tj=nj++;\n\t\t\tif (nj==m) nj=0;\n\t\t}\n\t} while (i!=oi || j!=oj);\n\treturn r;\n}\n\ndouble yval(cpt a,cpt b,double X) {\n\treturn deq(a.x,b.x)?a.y:(a.y*(b.x-X)+b.y*(X-a.x))/(b.x-a.x);\n}\n// I wrote this and then realised it was less code if both lower and upper hulls\n// are computed simultaneously. Also this code is wrong. do convex hull to get\n// correct answer.\n/*\nvector<Pt> intersectupperhulls(vector<Pt>& U1,vector<Pt>& U2) {\n\tvector<Pt> r;\n\tdouble x=max(U1[0].x,U2[0].x),y;\n\tint i=upper_bound(U1.begin(),U1.end(),Pt(x,DBL_MAX))-U1.begin()-1;\n\tint j=upper_bound(U2.begin(),U2.end(),Pt(x,DBL_MAX))-U2.begin()-1;\n\twhile (1) {\n\t\ty=min(i+1==U1.size()?U1[i].y:yval(U1[i],U1[i+1],x),\n\t\t\t  j+1==U2.size()?U2[j].y:yval(U2[j],U2[j+1],x));\n\t\tr.emplace_back(x,y);\n\t\tif (i+1==U1.size() || j+1==U2.size()) break;\n\t\tif (!arepara(U1[i],U1[i+1],U2[j],U2[j+1])) {\n\t\t\tPt p=intersectline(U1[i],U1[i+1],U2[j],U2[j+1]);\n\t\t\tif (!std::isnan(p.x)) r.push_back(p);\n\t\t}\n\t\tif (U1[i+1].x<U2[j+1].x) x=U1[++i].x;\n\t\telse x=U2[++j].x;\n\t}\n\tr.resize(unique(r.begin(),r.end())-r.begin());\n\treturn r;\n}\n*/\n// Split convex hull into lower and uppper hull. Endpoints included\n// Untested\npair<vector<Pt>,vector<Pt>> splithull(const vector<Pt>& p) {\n\tint i=min_element(p.begin(),p.end())-p.begin();\n\tint j=max_element(p.begin(),p.end())-p.begin();\n\tint n=p.size();\n\tvector<Pt> L,U;\n\tfor (int k=i;1;k++) {\n\t\tif (k==n) k=0;\n\t\tL.push_back(p[k]);\n\t\tif (k==j) break;\n\t}\n\tfor (int k=i;1;k--) {\n\t\tif (k==-1) k=n-1;\n\t\tU.push_back(p[k]);\n\t\tif (k==j) break;\n\t}\n\t\n\treturn {L,U};\n}\n\n// Untested\nvector<Pt> intersecthulls(vector<Pt>& p,vector<Pt>& q) {\n\tauto P=splithull(p),Q=splithull(q);\n\tvector<Pt> hulls[4]{P.X,Q.X,P.Y,Q.Y},A[2];\n\tdouble X=DBL_MIN,xmax=DBL_MAX,nx,yl,yu,poss;\n\tint i[4];\n\tfor (int j=0;j<4;j++) {\n\t\tX=max(X,hulls[j][0].x);\n\t\txmax=min(xmax,hulls[j].back().x);\n\t\t//i[j]=upper_bound(hulls[j].begin(),hulls[j].end(),Pt(x,DBL_MAX))\n\t\t//\t-hulls[j].begin()-1;\n\t}\n\twhile (1) {\n\t\tyl=DBL_MIN;\n\t\tyu=DBL_MAX;\n\n\t\tfor (int j=0;j<4;j++)\n\t\t\tfor (;i[j]+1<hulls[j].size() && hulls[j][i[j]].x<X;i[j]++);\n\n\t\tfor (int j=0;j<2;j++) {\n\t\t\tyl=max(yl,i[j]+1==hulls[j].size()?hulls[j][i[j]].y:\n\t\t\t\t\tyval(hulls[j][i[j]],hulls[j][i[j]+1],X));\n\t\t\tyu=min(yu,i[j+2]+1==hulls[j+2].size()?hulls[j+2][i[j+2]].y:\n\t\t\t\t\tyval(hulls[j+2][i[j+2]],hulls[j+2][i[j+2]+1],X));\n\t\t}\n\n\t\tif (yu+EPS>yl) for (int j=0;j<2;j++) {\n\t\t\tPt pt(X,j==0?yl:yu);\n\t\t\twhile ((A[j].size() && A[j].back()==pt) || (A[j].size()>1 &&\n\t\t\t\t\tdeq(det(A[j].back()-A[j][A[j].size()-2],pt-A[j].back()),0)))\n\t\t\t\tA[j].pop_back();\n\t\t\tA[j].push_back(pt);\n\t\t}\n\n\t\tif (X+EPS>xmax) break;\n\n\t\tnx=DBL_MAX;\n\t\tfor (int j=0;j<4;j++) \n\t\t\tif (/*i[j]+1<hulls[j].size() &&*/ (poss=hulls[j][i[j]+1].x)>=X+EPS)\n\t\t\t\tnx=min(nx,poss);\n\t\tfor (int j=0;j<4;j+=2)\n\t\t\tif (!arepara(hulls[j][i[j]],hulls[j][i[j]+1],hulls[j+1][i[j+1]],hulls[j+1][i[j+1]+1])) {\n\t\t\t\tPt pt=intersectline(hulls[j][i[j]],hulls[j][i[j]+1],hulls[j+1][i[j+1]],hulls[j+1][i[j+1]+1]);\n\t\t\t\tif (!std::isnan(pt.x) && pt.x>=X+EPS) nx=min(nx,pt.x);\n\t\t\t}\n\t}\n\n\tint l=A[0].size(),u=A[1].size();\n\tA[0].resize(l+u-2);\n\tcopy(A[1].rend()-u+1,A[1].rend()-1,A[0].begin()+l);\n\treturn A[0];\n}\n\n\n\n\nnamespace AIZU_CGL_4_B {\n\tvoid solve() {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<Pt> p(n);\n\t\tfor (Pt &a:p) cin >> a;\n\t\tcout << fixed << setprecision(10) << polygondiameter(p) << endl;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t//Test::solve();\n\t//UVA_920::solve();\n\t//UVA_10263::solve();\n\t//UVA_10927::solve(); // Use EPS=1e-10\n\t//UVA_378::solve();\n\t//UVA_191::solve();\n\t//AIZU_CGL_3_C::solve();\n\t//UVA_634::solve();\n\t//UVA_453::solve(); // Use EPS=1e-4\n\t//AIZU_CGL_7_H::solve();// Trim file to fit in file size limit\n\t//Timus_1894::solve();\n\t//UVA_1111::solve();\n\tAIZU_CGL_4_B::solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lb long double\n#define N 100010 \nusing namespace std;\nstruct Po{lb x,y;}a[N];\nint n;\nlb ansn;\nPo operator -(Po x,Po y){return (Po){x.x-y.x,x.y-y.y};}\nlb operator *(Po x,Po y){return x.x*y.y-x.y*y.x;}\nvoid get(Po &x){scanf(\"%Lf %Lf\",&x.x,&x.y);}\nint pa(int x){if (x>n)x-=n;return x;}\nlb le(Po x){return sqrtl(x.x*x.x+x.y*x.y);}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) get(a[i]);\n\tfor (int i=1,j=2;i<=n;i++){\n\t\twhile((a[pa(i+1)]-a[i])*(a[j]-a[i])<=(a[pa(i+1)]-a[i])*(a[pa(j+1)]-a[i]))j=pa(j+1);\n\t\tansn=max(ansn,max(le(a[j]-a[i]),le(a[j]-a[pa(i+1)])));\n\t}\n\tprintf(\"%.10Lf\\n\",ansn);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 1e-10101;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tif (N >= 20000) { res = 1e-5; goto E; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = max(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tR res=0.0;\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\nclass Vec;\nVec operator/(const Vec& v, const double& divisor);\nVec operator*(const double& scale, const Vec& v);\n\nclass Vec {\n  using F = double;\n  vector<F> container;\n\n public:\n  Vec(size_t size) : container(size) {}\n  Vec(initializer_list<F> elements)\n      : container(elements.begin(), elements.end()) {}\n  size_t dim() const { return container.size(); }\n  F& operator[](const size_t size) { return container.at(size); }\n  const F& operator[](const size_t size) const { return container.at(size); }\n  Vec operator+(const Vec& other) const {\n    Vec ret(*this);\n    for (size_t i = 0; i < dim(); i++) ret[i] += other[i];\n    return ret;\n  }\n  Vec operator-(const Vec& other) const { return (*this) + (-other); }\n  Vec operator-() const { return -1.0 * (*this); }\n  F inner(const Vec& other) const {\n    F acc = 0;\n    for (size_t i = 0; i < dim(); i++) {\n      acc += (*this)[i] * other[i];\n    }\n    return acc;\n  }\n  F norm() const { return sqrt(inner(*this)); }\n  Vec unit() const { return (*this) / this->norm(); }\n  F ccw(const Vec& other) const {\n    return (*this)[0] * other[1] - other[0] * (*this)[1];\n  }\n  Vec normal() const { return Vec({-(*this)[1], (*this)[0]}); }\n};\nVec operator/(const Vec& v, const double& divisor) { return 1.0 / divisor * v; }\nVec operator*(const double& scale, const Vec& v) {\n  Vec ret(v);\n  for (size_t i = 0; i < ret.dim(); i++) ret[i] *= scale;\n  return ret;\n}\n\nclass Convex {\n  const vector<Vec>& m_points;\n  vector<int> m_hull;\n\n public:\n  Convex(const vector<Vec>& points) : m_points(points), m_hull() {\n    const size_t n = m_points.size();\n\n    vector<int> idx(n);\n    for (size_t i = 0; i < n; i++) idx[i] = i;\n    sort(idx.begin(), idx.end(), [&](const int& lh, const int& rh) {\n      if (m_points[lh][0] == m_points[rh][0]) {\n        return m_points[lh][1] < m_points[rh][1];\n      }\n      return m_points[lh][0] < m_points[rh][0];\n    });\n\n    vector<int> conv[2];\n    double si = 1;\n    for (int j = 0; j < 2; j++) {\n      vector<int>& cv = conv[j];\n      for (size_t i = 0; i < n; i++) {\n        const int k = idx[i];\n        const Vec& c = m_points[k];\n        while (cv.size() >= 2 &&\n               si * (m_points[cv[cv.size() - 1]] - m_points[cv[cv.size() - 2]])\n                           .ccw(c - m_points[cv[cv.size() - 2]]) <\n                   0) {\n          cv.pop_back();\n        }\n        cv.push_back(k);\n      }\n      si *= -1;\n    }\n\n    copy(conv[0].begin(), conv[0].end(), back_inserter(m_hull));\n    copy(next(conv[1].rbegin()), prev(conv[1].rend()), back_inserter(m_hull));\n  }\n  double diameter() const {\n    double result = 0;\n    const size_t n = m_hull.size();\n    int j = 0;\n    for (size_t i = 0; i < n; i++) {\n      double d = ((*this)[i] - (*this)[j % n]).norm();\n      double e = ((*this)[i] - (*this)[(j + 1) % n]).norm();\n      while (d < e) {\n        j++;\n        d = e;\n        e = ((*this)[i] - (*this)[(j + 1) % n]).norm();\n      }\n      result = max(result, d);\n    }\n    return result;\n  }\n  size_t size() const { return m_hull.size(); }\n  const vector<int>& ids() const { return m_hull; }\n  const Vec& operator[](size_t index) const {\n    return m_points.at(m_hull.at(index));\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<Vec> p;\n  rep(i, n) {\n    double x, y;\n    cin >> x >> y;\n    p.push_back(Vec({x, y}));\n  }\n\n  auto hull = Convex(p);\n  cout << fixed << setprecision(7) << hull.diameter() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\n//?????¢?????¢???\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\nint main(){\n  int n,c=0;\n  Polygon p,a;\n  Point s;\n  double d[10000000];\n  cin>>n;\n  while(n--){\n    cin>>s.x>>s.y;\n    p.push_back(s);\n  }\n  a=andrewScan(p);\n  r(i,a.size())\n  for(int j=i+1;j<a.size();j++)\n    d[c++]=getDistancePP(a[i],a[j]);\n  sort(d,d+c);\n  printf(\"%.11f\\n\",d[c-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<25;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\ndouble add_double(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct point{\n\tdouble x,y;\n\tpoint operator+(point p){\n\t\treturn point{add_double(x,p.x),add_double(y,p.y)};\n\t}\n\tpoint operator-(point p){\n\t\treturn point{add_double(x,-p.x),add_double(y,-p.y)};\n\t}\n\tpoint operator*(double p){\n\t\treturn point{x*p,y*p};\n\t}\n\tpoint operator/(double p){\n\t\tif(!p) return point{0,0}; \n\t\treturn point{x/p,y/p};\n\t}\n\tbool operator==(point p){\n\t\treturn fabs(add_double(x,-p.x))<eps&&fabs(add_double(y,-p.y))<eps;\n\t}\n\tbool operator<(point p){\n\t\tif(fabs(x-p.x)>eps) return x<p.x;\n\t\treturn y<p.y;\n\t}\n};\n \ntypedef pair<point,point> pp;\ntypedef vector<point> VP;\nconst point O{0,0};\n \nclass Geom{\n\tpublic:\n\tdouble Length(point x,point y){\n\t\tpoint z=y-x;\n\t\treturn z.x*z.x+z.y*z.y;\n\t}\n\tdouble IP(point p,point q){\n\t\treturn p.x*q.x+p.y*q.y;\n\t}\n\tdouble CP(point p,point q){\n\t\treturn p.x*q.y-q.x*p.y;\n\t}\n\tdouble Diameter_Polygon(VP p){\n\t\tdouble ans=0;\n\t\tfor(VP::iterator i=p.begin();i!=p.end();i++){\n\t\t\tfor(VP::iterator j=p.begin();j!=i;j++){\n\t\t\t\tans=max(ans,Length(*i,*j));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Point_in(point& p){\n\t\tcin>>p.x>>p.y;\n\t}\n\tvoid Point_out(point p){\n\t\tcout<<p.x<<' '<<p.y<<endl;\n\t}\n};\n\nint N;\nVP p,ans;\n\nint main(){\n\tcout<<syosu(10);\n\tGeom geo;\n\tcin>>N;\n\tp=VP(N);\n\tfor(VP::iterator i=p.begin();i!=p.end();i++) geo.Point_in(*i);\n\tcout<<sqrt(geo.Diameter_Polygon(p))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#define N 100010\n#define inf 1000000000\n#define eps 1e-10\n#define double long double\nusing namespace std;\nstruct point{\n\tdouble x,y;\n\tvoid read(){scanf(\"%Lf%Lf\",&x,&y);}\n\tvoid write(){printf(\"%.10Lf %.10Lf\\n\",x,y);}\n\tpoint(double X=0.0,double Y=0.0):x(X),y(Y){}\n\tbool operator <(const point a)const{return y==a.y?x<a.x:y<a.y;}\n\tpoint operator +(const point a)const{return point(x+a.x,y+a.y);}\n\tpoint operator -(const point a)const{return point(x-a.x,y-a.y);}\n\tpoint operator *(double a)const{return point(x*a,y*a);}\n\tpoint operator /(double a)const{return point(x/a,y/a);}\n\tbool operator ==(const point a)const{return abs(x-a.x)<=eps && abs(y-a.y)<=eps;}\n};\ndouble dis(point a,point b=point(0,0)){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\ndouble cross(point a,point b){return a.x*b.y-a.y*b.x;}\ndouble cross3(point o,point a,point b){return cross(a-o,b-o);}\nbool jiao(point a,point b,point c,point d)\n{\n\tif(min(a.x,b.x)>max(c.x,d.x) || min(a.y,b.y)>max(c.y,d.y)) return false;\n\tif(min(c.x,d.x)>max(a.x,b.x) || min(c.y,d.y)>max(a.y,b.y)) return false;\n\tif(cross3(a,b,c)*cross3(a,b,d)>0) return false;\n\tif(cross3(c,d,a)*cross3(c,d,b)>0) return false;\n\treturn true;\n}\nshort int on_line(point o,point a,point b)//oa->ob 0:D 1:U 2:O\n{\n\tif(dot(a-o,b-o)<-eps) return 0;\n\treturn 1+(dis(a-o)>=dis(b-o));\n}\nvoid make_rand(double &x){x=x+(1ll*rand()%10+1)/10.0*eps;}\nstruct Line{\n\tpoint a,b;\n\tLine(point x=point(0,0),point y=point(0,0)):a(x),b(y){}\n\tvoid read(){a.read();b.read();}\n\tbool operator &&(const Line u){return jiao(a,b,u.a,u.b);}\n\tpoint operator &(const Line u)\n\t{\n\t\tif(a==u.a || a==u.b) return a;\n\t\tif(b==u.a || b==u.b) return b;\n\t\tdouble x1=a.x,x2=b.x,x3=u.a.x,x4=u.b.x;\n\t\tdouble y1=a.y,y2=b.y,y3=u.a.y,y4=u.b.y;\n\t\tif(x3==x4) return point(x3,(y2-y1)*x3/(x2-x1)+(y1*x2-x1*y2)/(x2-x1));\n\t\tif(x1==x2) return point(x1,(y4-y3)*x1/(x4-x3)+(y3*x4-x3*y4)/(x4-x3));\n\t\tmake_rand(x2);\n\t\tdouble x=((y3*x4-y4*x3)*(x2-x1)-(y1*x2-y2*x1)*(x4-x3))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\t\tdouble y=(y2-y1)*x/(x2-x1)+(y1*x2-x1*y2)/(x2-x1);\n\t\treturn point(x,y);\n\t}\n};\npoint project(Line a,point p)\n{\n\tpoint &p1=a.a,&p2=a.b;\n\tdouble len=dot(p2-p1,p-p1)/dis(p2-p1);\n\treturn p1+(p2-p1)/dis(p2-p1)*len;\n}\ndouble dis(Line a,Line b)\n{\n\tif(a && b) return 0;\n\tdouble ans=min(min(dis(a.a,b.a),dis(a.a,b.b)),min(dis(a.b,b.a),dis(a.b,b.b)));\n\tpoint res=project(a,b.a);\n\tif(on_line(a.a,a.b,res)==2) ans=min(ans,dis(res,b.a));\n\tres=project(a,b.b);\n\tif(on_line(a.a,a.b,res)==2) ans=min(ans,dis(res,b.b));\n\tres=project(b,a.a);\n\tif(on_line(b.a,b.b,res)==2) ans=min(ans,dis(res,a.a));\n\tres=project(b,a.b);\n\tif(on_line(b.a,b.b,res)==2) ans=min(ans,dis(res,a.b));\n\treturn ans;\n}\nint sta[N],tot;\nstruct polygon{\n\tvector<point>p;\n\tvoid read(int n=-1)\n\t{\n\t\tif(n<0) scanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tpoint a;\n\t\t\ta.read();\n\t\t\tp.push_back(a);\n\t\t}\n\t}\n\tdouble area(void)\n\t{\n\t\tdouble ans=0;\n\t\tfor(int i=1;i<p.size();i++)\n\t\tans+=cross3(p[0],p[i-1],p[i])/2;\n\t\treturn abs(ans);\n\t}\n\tbool convex(void)\n\t{\n\t\tshort int right=-1;\n\t\tfor(int i=2;i<p.size();i++)\n\t\tif(right<0) right=cross3(p[i-2],p[i-1],p[i])>=0;\n\t\telse if(right!=(cross3(p[i-2],p[i-1],p[i])>=0)) return false;\n\t\tif(right!=(cross3(p[p.size()-2],p[p.size()-1],p[0])>=0)) return false;\n\t\treturn true;\n\t}\n\tshort int in_polygon(const point x)\n\t{\n\t\tLine l(x,x+point(inf,(double)inf*1.414213562373));\n\t\tmake_rand(l.b.y);\n\t\tint cnt=0;\n\t\tfor(int i=1;i<p.size();i++)\n\t\t{\n\t\t\tLine u(p[i-1],p[i]);\n\t\t\tif(u && l)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tif(abs(cross3(p[i-1],p[i],x))<eps && on_line(p[i-1],p[i],x)==2) return 1;\n\t\t\t}\n\t\t}\n\t\tLine u(p[p.size()-1],p[0]);\n\t\tif(u && l)\n\t\t{\n\t\t\tcnt++;\n\t\t\tif(abs(cross3(p[p.size()-1],p[0],x))<eps && on_line(p[p.size()-1],p[0],x)==2) return 1;\n\t\t}\n\t\treturn cnt%2==0?0:2; \n\t}\n\tvoid make_convex(void)\n\t{\n\t\tsort(p.begin(),p.end());\n\t\tvector<point>s;\n\t\ttot=0;\n\t\tfor(int i=0;i<p.size();i++)\n\t\t{\n\t\t\twhile(tot>=2 && cross3(p[i],p[sta[tot-1]],p[sta[tot-2]])>=eps) tot--;\n\t\t\tsta[tot++]=i;\n\t\t}\n\t\tint swp=tot;\n\t\tfor(int i=p.size()-2;i>=0;i--)\n\t\t{\n\t\t\twhile(tot-swp>=1 && cross3(p[i],p[sta[tot-1]],p[sta[tot-2]])>=eps) tot--;\n\t\t\tsta[tot++]=i;\n\t\t}\n\t\tfor(int i=0;i<tot-1;i++)\n\t\ts.push_back(p[sta[i]]);\n\t\tsort(s.begin(),s.end());\n\t\tp=s; \n\t}\n\tdouble diameter(void)\n\t{\n\t\tint l=0,r=1;\n\t\tdouble ans=dis(p[0],p[1]);\n\t\tdo\n\t\t{\n\t\t\twhile(dis(p[l],p[r])<=dis(p[l],p[(r+1)%p.size()]))\n\t\t\tr=(r+1)%p.size(),ans=max(ans,dis(p[l],p[r]));\n\t\t\tl=(l+1)%p.size();\n\t\t\tans=max(ans,dis(p[l],p[r]));\n\t\t}\n\t\twhile(l!=0);\n//\t\tfor(int l=0;l<p.size();l++)\n//\t\t\tfor(int r=l+1;r<p.size();r++)\n//\t\t\tif(dis(p[l],p[r])>ans) printf(\"%d %d\\n\",l,r);\n\t\treturn ans;\n\t}\n}p;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\t\n\tsrand(n);\n\tp.read(n);\n//\tp.make_convex();\n\tprintf(\"%.10Lf\\n\",p.diameter());\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) c.begin(),c.end()\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\t\t//fs->sc\ntypedef vector<P> Pol;\nstruct C{P p;D r;};\nD inf=1e50,eps=1e-10;\n//template<class T> bool eq(T a, T b) { return abs(a-b)<eps;}\n//template<class T> int sig(T a) { return eq(a,0) ? 0 : (a>0 ? 1 : -1);}\nbool eq(D a, D b) { return abs(a-b)<eps;}\nbool eq(P a, P b) { return abs(a-b)<eps;}\nint sig(D a) { return eq(a,0) ? 0 : (a>0 ? 1 : -1);}\nbool operator < (const P& l, const P& r){\t\t//sort x -> y\n\treturn eq(l.real(),r.real()) ? l.imag()<r.imag() : l.real() < r.real();\n}\nbool compxy (const P& l, const P& r){\t\t//sort x -> y\n\treturn eq(l.real(),r.real()) ? l.imag()<r.imag() : l.real() < r.real();\n}\nbool compyx (const P& l, const P& r){\t\t//sort y -> x\n\treturn eq(l.imag(),r.imag()) ? l.real()<r.real() : l.imag() < r.imag();\n}\ninline D dot(P a, P b) { return real(conj(a)*b);};\ninline D cro(P a, P b) { return imag(conj(a)*b);};\nenum ENCCW{CCW=1, CW=-1, FRONT=-2, BACK=2, ON=0};\t//!!MAEHARAと一緒(convが書きやすい(次の点を取る条件をccw>0とかける))\n//ON優先(including endpoint)\ninline int ccw (P a, P b, P c){\n//\tcout << cro(b-a,c-a) << endl;\n\tif(sig(cro(b-a,c-a))==1) return CCW;\n\tif(sig(cro(b-a,c-a))==-1) return CW;\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return ON;\n\tif(eq(abs(a-b)+abs(b-c),abs(a-c))) return FRONT;\n\tif(eq(abs(c-a)+abs(a-b),abs(c-b))) return BACK;\n\tassert(false);\n}\ninline P proj(P a, P b){\t\t//ベクトルaのbへの射影\n\treturn (dot(a,b)/norm(b))*b;\n}\ninline P perp(L l, P p){\t\t//垂線の足\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline P refl(L l, P p){\n\treturn p+2.0*(perp(l,p)-p);\n}\ninline bool ispal(L a, L b){\n\treturn sig(cro(a.fs-a.sc,b.fs-b.sc))==0;\n}\ninline bool ovLL(L a, L b){\n\treturn ispal(a,b) && sig(cro(a.fs-a.sc,b.fs-a.sc))==0;\n}\ninline bool iLL(L a, L b){\t\t//intersect or overload\n\treturn !ispal(a,b) || ovLL(a,b);\n}\ninline bool iLS(L l, L s){\t\t//intersect(including endpoint) or overload\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<eps;\n}\ninline bool iLP(L l, P p){\t\t//on line\n\treturn sig(cro(l.sc-p,l.fs-p));\n}\ninline bool iSS(L a, L b){\t\t//intersect(including endpoint) or overload\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0 && ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\ninline bool iSP(L s, P p){\t\t//intersect(including endpoint) or overload\n\treturn ccw(s.fs,s.sc,p)==ON;\n}\ninline D dLP(L l, P p) { return abs(perp(l,p)-p);}\ninline D dLL(L a, L b) { return iLL(a,b) ? 0 : dLP(a,b.fs);}\ninline D dLS(L l, L s) { return iLS(l,s) ? 0 : min(dLP(l,s.fs),dLP(l,s.sc));}\ninline D dSP(L s, P p) {\n\tP q=perp(s,p);\n\treturn iSP(s,q) ? abs(p-q) : min(abs(p-s.fs),abs(p-s.sc));\n}\ninline D dSS(L a, L b) {\n\tif(iSS(a,b)) return 0;\n\treturn min(min(dSP(a,b.fs),dSP(a,b.sc)),min(dSP(b,a.fs),dSP(b,a.sc)));\n}\ninline P intLL(L a, L b) {\t//intersection\n\tassert(!ispal(a,b));\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nenum ENICP{INC=1,ONC=0,OUTC=-1};\ninline int iCP(C c, P p){\n\tD d=abs(p-c.p);\n\treturn eq(d,c.r) ? ONC : (d<c.r ? INC : OUTC);\n}\ninline int iCL(C c, L l){\t\t//num of intersection(s)\n\tD d=dLP(l,c.p);\n\treturn eq(d,c.r) ? 1 : (d<c.r ? 2 : 0);\n}\n//inline int iCS\n//inline int iCC(C a, C b){\n\n/*inline P intCL1(C c, L l){\t\t//iCL=1\n\tassert(iCL(c,l)==1);\n}\ninline L intCL2(C c, L l){\t\t//iCL=2\n\tassert(iCL(c,l)==2);\n}*/\nD aTri(P a, P b, P c){ return cro(b-a,c-a)/2;}\nD aPol(Pol p){\t\t\t//点集合はCCWに与える\n\tint n=p.size();\n\tD ret=0;\n\trep(i,n) ret+=cro(p[i],p[(i+1)%n])/2;\n\treturn ret;\n}\nP gPol(Pol p){\t\t\t//多角形内部が一様な重さを持つときの重心\n\tint n=p.size();\n\tP g;\n\tD s=aPol(p);\n\tassert(s>eps);\n\trep(i,n){\n\t\tD ds=cro(p[i],p[(i+1)%n])/2;\n\t\tg+=ds/3*(p[i]+p[(i+1)%n]);\n\t}\n\treturn g/s;\n}\nenum ENCONT{INP=1,ONP=0,OUTP=-1};\nint contain(Pol pol, P p){\n\tbool in=false;\n\trep(i,pol.size()){\n\t\tP a=pol[i]-p,b=pol[(i+1)%pol.size()]-p;\n\t\tif(ccw(a,b,P(0,0))==ON) return ONP;\n\t\tif(imag(a)>imag(b)) swap(a,b);\n\t\tif(sig(imag(a))<=0 && 0<sig(imag(b)) && ccw(P(0,0),a,b)==CCW) in=!in;\n\t}\n\treturn in ? INP : OUTP;\n}\ninline D heron(D a, D b, D c){\n\tdouble s=(a+b+c)/2;\n\tif(s-a<eps || s-b<eps || s-c<eps) return 0;\t\t//S=0 || 三角形できない\n\treturn sqrt(s*(s-a)*(s-b)*(s-c));\n}\ninline Pol conv(Pol p){\t\t//convex\n\tint n=p.size(),k=0;\n\tassert(n>=3);\n\tsort(all(p),compxy);\t\t\t//compyxで下から\n\tPol ret(2*n);\n\trep(i,n){\n\t\twhile(k>=2 && ccw(ret[k-2],ret[k-1],p[i])<=0) --k;\n\t\tret[k++]=p[i];\n\t}\n\tfor(int i=n-2,t=k+1;i>=0;i--){\n\t\twhile(k>=t && ccw(ret[k-2],ret[k-1],p[i])<=0) --k;\n\t\tret[k++]=p[i];\n\t}\n\tret.resize(k-1);\n\treturn ret;\n}\ninline Pol convall(Pol p){\t\t//conv上の点全部\t\t//点が2回以上出てくる\n\tint n=p.size(),k=0;\n\tassert(n>=3);\n\tsort(all(p),compxy);\n//\tif(p[0]<p[1]) ;\n\tPol ret(2*n);\n\trep(i,n){\n\t\twhile(k>=2 && ccw(ret[k-2],ret[k-1],p[i])==-1) --k;\n\t\tret[k++]=p[i];\n\t}\n\tfor(int i=n-2,t=k+1;i>=0;i--){\n\t\twhile(k>=t && ccw(ret[k-2],ret[k-1],p[i])==-1) --k;\n\t\tret[k++]=p[i];\n\t}\n\tret.resize(k-1);\n//\tPol ret1=ret;\n//\tsort(all(ret),compxy);\n\tret.erase(unique(all(ret)),ret.end());\n\treturn ret;\n}\nD pol_diameter(Pol p){\n\tp=conv(p);\n\tint n=p.size();\n\tassert(n>=2);\n\tif(n==2) return abs(p[0]-p[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(!compxy(p[i],p[k])) i=k;\n\t\tif(compxy(p[j],p[k])) j=k;\n\t}\n\tD ret=0;\n\tint si=i,sj=j;\n//\trep(_i,n) cout << p[_i] << endl;\n\twhile(i!=sj || j!=si){\n//\t\tcout << i << \" \" << j << \" \" << abs(p[i]-p[j]) << endl;\n\t\tret=max(ret,abs(p[i]-p[j]));\n\t\tif(cro(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0) i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\treturn ret;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tPol p;\n\trep(i,n){\n\t\tD a,b;\n\t\tscanf(\"%lf%lf\",&a,&b);\n\t\tp.pb(P(a,b));\n\t}\n\tprintf(\"%.10lf\\n\",pol_diameter(p));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include<bits/stdc++.h>\n#include<iostream>\n#include<stdio.h>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef double db;\nconst db eps = 1e-15, pi = acos(-1);\nint sign(db x) {return x < -eps ? -1 : x > eps;}\nint cmp(db x, db y) {return sign(x - y);}\nint intersect(db l1, db r1, db l2, db r2) {\n    if (l1 > r1) swap(l1, r1); if (l2 > r2) swap(l2, r2); return cmp(r1, l2) != -1 && cmp(r2, l1) != -1;\n}\nint inmid(db k1, db k2, db k3) {return sign(k1 - k3) * sign(k2 - k3) <= 0;}//k3 in [k1,k2]?1:0\nstruct Point {\n    db x, y;\n    Point operator + (const Point & a)const {return Point{a.x + x, a.y + y};}\n    Point operator - (const Point & a)const {return Point{x - a.x, y - a.y};}\n    Point operator * (db a) const {return Point{x * a, y * a};}\n    Point operator / (db a) const {return Point{x / a, y / a};}\n    bool operator < (const Point p) const {int a = cmp(x, p.x); if (a) return a == -1; return cmp(y, p.y) == -1;}\n    bool operator == (const Point & a) const {return cmp(x, a.x) == 0 && cmp(y, a.y) == 0;}\n    db abs() {return sqrt(x * x + y * y);}\n    db dis(Point p) {return ((*this) - p).abs();}\n    int getP() const {return sign(y) == 1 || (sign(y) == 0 && sign(x) == -1);}\n    void input() {scanf(\"%lf%lf\", &x, &y);}\n};\ndb cross(Point p1, Point p2) {return p1.x * p2.y - p1.y * p2.x;}\ndb cross(Point p0, Point p1, Point p2) {return cross(p1 - p0, p2 - p0);}\ndb dot(Point p1, Point p2) {return p1.x * p2.x + p1.y * p2.y;}\nint inmid(Point k1, Point k2, Point k3) {return inmid(k1.x, k2.x, k3.x) && inmid(k1.y, k2.y, k3.y);}\nbool compareangle(Point p1, Point p2) {//Polar Angle Sort\n    return p1.getP() < p2.getP() || (p1.getP() == p2.getP() && sign(cross(p1, p2)) > 0);\n}\nint clockwise(Point p1, Point p2, Point p3) { // k1 k2 k3 anticlockwise:1 clockwise:-1 others:0\n    return sign(cross(p1, p2, p3));\n}\nstruct Line {\n    Point s, e;\n    void input() {scanf(\"%lf%lf%lf%lf\", &s.x, &s.y, &e.x, &e.y);}\n    Point vec() {return e - s;}\n    db length() {return sqrt(dot(s - e, s - e));}\n    db length2() {return dot(s - e, s - e);}\n};\nint onS(Line l, Point p) {// On Seg?\n    return inmid(l.s, l.e, p) && sign(cross(l.s - p, l.e - l.s)) == 0;\n}\nbool checkLL(Line l1, Line l2) {\n    return cmp(cross(l1.s, l2.s, l2.e), cross(l1.e, l2.s, l2.e)) != 0;\n}\nbool checkLS(Line l1, Line l2) {//Intersection of Line l1 and Seg l2?\n    return sign(cross(l2.s, l1.s, l1.e)) * sign(cross(l2.e, l1.s, l1.e)) <= 0;\n}\nint checkSS(Line l1, Line l2) {//Intersection of Two Seg?1:0\n    return intersect(l1.s.x, l1.e.x, l2.s.x, l2.e.x) && intersect(l1.s.y, l1.e.y, l2.s.y, l2.e.y) && checkLS(l1, l2) && checkLS(l2, l1);\n}\nPoint project(Line l, Point p) {\n    return l.s + l.vec() * dot(p - l.s, l.vec()) / l.length2();\n}\nPoint reflect(Line l, Point p) {//Mirror Point\n    return project(l, p) * 2 - p;\n}\nPoint getLL(Line l1, Line l2) {//Intersection Point of Line l1,l2\n    db w1 = cross(l2.s, l1.s, l2.e), w2 = cross(l2.s, l2.e, l1.e); return (l1.s * w2 + l1.e * w1) / (w1 + w2);\n}\ndb disSP(Line l, Point p) {\n    Point p2 = project(l, p);\n    if (inmid(l.s, l.e, p2)) return p.dis(p2); else return min(p.dis(l.s), p.dis(l.e));\n}\ndb disSS(Line l1, Line l2) {\n    if (checkSS(l1, l2)) return 0;\n    return min(min(disSP(l1, l2.s), disSP(l1, l2.e)), min(disSP(l2, l1.s), disSP(l2, l1.e)));\n}\ndb area(vector<Point> A) {//Anticlockwise\n    db ans = 0;\n    for (int i = 0; i < A.size(); i++) ans += cross(A[i], A[(i + 1) % A.size()]);\n    return ans / 2;\n}\nint contain(vector<Point>A, Point p) {//2:in 1:on 0:out\n    int ans = 0; A.push_back(A[0]);\n    for (int i = 1; i < A.size(); i++) {\n        Line l = {A[i - 1], A[i]};\n        if (onS(l, p)) return 1; if (cmp(l.s.y, l.e.y) > 0) swap(l.s, l.e);\n        if (cmp(l.s.y, p.y) >= 0 || cmp(l.e.y, p.y) < 0) continue;\n        if (sign(cross(l.e, l.s, p)) < 0)ans ^= 1;\n    }\n    return ans << 1;\n}\nbool checkconvex(vector<Point>A) { //anticlock\n    int n = A.size(); A.push_back(A[0]); A.push_back(A[1]);\n    for (int i = 0; i < n; i++) if (sign(cross(A[i], A[i + 1], A[i + 2])) == -1) return 0;\n    return 1;\n}\nvector<Point> ConvexHull(vector<Point>A, int flag = 1) { // flag=0 不严格 flag=1 严格\n    int n = A.size(); vector<Point>ans(n * 2);\n    sort(A.begin(), A.end()); int now = 0; if (n <= 1)return A;\n    for (int i = 0; i < n; ans[now++] = A[i++])\n        while (now > 1 && sign(cross(ans[now - 2], ans[now - 1], A[i])) < flag)--now;\n    for (int i = n - 2, pre = now; i >= 0; ans[now++] = A[i--])\n        while (now > pre && sign(cross(ans[now - 2], ans[now - 1], A[i])) < flag)--now;\n    ans.resize(now - 1); return ans;\n}\ndb convexDiameter(vector<Point>A) {\n    int n = A.size(); if (n <= 1)return 0;\n    int is = 0, js = 0; for (int k = 1; k <= n; ++k)is = A[k] < A[is] ? k : is, js = A[js] < A[k] ? k : js;\n    int i = is, j = js; db ret = A[i].dis(A[j]); do {\n        if (sign(cross(A[(i + 1) % n] - A[i], A[(j + 1) % n] - A[j])) >= 0)(++j) %= n;\n        else (++i) %= n;\n        ret = max(ret, A[i].dis(A[j]));\n    } while (i != is || j != js);\n    return ret;\n}\nint main() {\n    int n; while (cin >> n) {\n        vector<Point> A(n);\n        for (int i = 0; i < A.size(); ++i)A[i].input();\n        A = ConvexHull(A);\n        db ans = convexDiameter(A);\n        printf(\"%.10lf\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 定義・定数\nusing P = complex<double>;\nusing Polygon = vector<P>;\nconst double EPS = 1e-10;\n\nnamespace std {\n  // 点の比較演算子\n  bool operator < (const P &a, const P &b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  \n  // 点の等価演算子\n  bool operator == (const P &a, const P &b) {\n    return fabs(a - b) < EPS;\n  }\n}\n\n// 直線\nstruct L : public vector<P> {\n  L(P &_a, P &_b) {\n    push_back(_a);\n    push_back(_b);\n  }\n};\n\n// 線分\nstruct S : L {\n  S(P &_a, P &_b) : L(_a, _b) {}\n};\n\n// 円\nstruct C {\n  P p;\n  double r;\n  \n  C(P _p, double _r) : p(_p), r(_r) {}\n};\n\n// 内積\ndouble dot(const P &a, const P &b) {\n  return real(conj(a) * b);\n}\n\n// 外積\ndouble cross(const P &a, const P &b) {\n  return imag(conj(a) * b);\n}\n\n// 直交判定\nbool isOrthogonal(const L &l, const L &m) {\n  return abs(dot(l[1] - l[0], m[1] - m[0])) < EPS;\n}\n\n// 平行判定\nbool isParallel(const L &l, const L &m) {\n  return abs(cross(l[1] - l[0], m[1] - m[0])) < EPS;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n// 交差判定\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n         abs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const S &s) {\n  return cross(l[1] - l[0], s[0] - l[0]) *      // s[0] is left of l\n         cross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const S &s, const S &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const S &s, const P &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\n// 距離など\nP projection(const L &l, const P &p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const S &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const S &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const S &s, const S &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n// 多角形の面積\ndouble area(const Polygon &po) {\n  double A = 0;\n  for (int i = 0; i < po.size(); i++) {\n    A += cross(po.at(i), po.at((i + 1) % po.size()));\n  }\n  return A / 2;\n}\n\n// 多角形の凸性判定\nbool isConvex(const Polygon &po) {\n  for (int i = 0; i < po.size(); i++) {\n    if (ccw(po.at((i + po.size() - 1) % po.size()), po.at(i), po.at((i + 1) % po.size())) == -1) return false;\n  }\n  return true;\n}\n\n// 点-多角形包含判定\nstring contains(const Polygon& po, const P& p) {\n  bool in = false;\n  for (int i = 0; i < po.size(); ++i) {\n    P a = po.at(i) - p, b = po.at((i + 1) % po.size()) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return \"ON\";\n  }\n  return in ? \"IN\" : \"OUT\";\n}\n\n// 凸包 O(nlogn)\nPolygon convex_hull(Polygon po) {\n  int n = po.size(), k = 0;\n  sort(po.begin(), po.end());\n  Polygon ch(2 * n);\n  // 一直線上の3点を含めない -> (< EPS)\n  // 含める -> (< -EPS)\n  for (int i = 0; i < n; ch[k++] = po[i++]) // lower-hull\n    while (k >= 2 && cross(ch[k - 1] - ch[k - 2], po[i] - ch[k - 1]) < EPS) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = po[i--]) // upper-hull\n    while (k >= t && cross(ch[k - 1] - ch[k - 2], po[i] - ch[k - 1]) < EPS) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\n// 凸多角形の直径\ndouble convex_diameter(const Polygon &po) {\n  const int n = po.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(po[i]) > imag(po[is])) is = i;\n    if (imag(po[i]) < imag(po[js])) js = i;\n  }\n  double maxd = abs(po[is] - po[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross((po[(i + 1) % po.size()] - po[i]), (po[(j + 1) % po.size()] - po[j])) >= 0) j = (j + 1) % n;\n    else i = (i + 1) % n;\n    if (abs(po[i] - po[j]) > maxd) {\n      maxd = abs(po[i] - po[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return maxd; /* farthest pair is (maxi, maxj). */\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  int n;\n  cin >> n;\n  Polygon po;\n  for (int i = 0; i < n; i++) {\n    double x, y;\n    cin >> x >> y;\n    po.emplace_back(complex<double>(x, y));\n  }\n  \n  cout << fixed << setprecision(10) << convex_diameter(po) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\ninline int sign(const double &x){\n    if(x>EPS) return 1;\n    else if(x<-EPS) return -1;\n    return 0;\n}\n\n/*   点  */\nstruct Point{\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double k) { return Point(k*x,k*y); }\n    Point operator / (double k) { return Point(x/k,y/k); }\n\n    //向量的大小\n    double abs(){ return sqrt(norm()); }\n    double norm() { return x*x+y*y; }\n\n    bool operator < (const Point & p) const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\n\n//两点间的距离\ndouble getDistance(Point a,Point b){\n    return (a-b).abs();\n}\n\n/*   向量  */\ntypedef Point Vector;\n\n//向量a和b的内积\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n//向量a和b的外积\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\n/*   线段  */\nstruct Segment{\n    Point p1,p2;\n};\n\n//点p在线段s上的投影\nPoint project(Segment s,Point p){\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n/*   直线  */\ntypedef Segment Line;\n\n//点到直线的距离\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\n//点到线段的距离\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\n//判断p2与向量p1-p0的位置关系\n\nconst int COUNTER_CLOCKWISE = -1;   //逆时针\nconst int CLOCKWISE = 1;            //顺时针\nconst int ON_SEGMENT = 0;           //在线段上\nconst int ONLINE_BACK = 2;          //p2在向量p1-p0的反方向延长线上\nconst int ONLINE_FRONT = -2;        //p2在向量p1-p0的正方向延长线上\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//判断线段p1p2与线段p3p4是否相交\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n             ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//线段与线段的距离\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n//两个线段的交点\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n/* 直线正交\n * 判断向量a，b是否正交 =》a，b的内积为0\n */\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\n/* 直线平行\n * 判断向量a，b是否平行 =》a，b的内积为0\n */\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point() ,double r = 0.0 ):c(c),r(r){}\n};\n\n/* 圆与直线的交点\n * 交点为一个的时候返回两个相同的点\n * 没有交点则退出\n */\n\nbool intersect(Circle c,Line l){\n    return sign(getDistanceLP(l,c.c)-c.r)<=0;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));         //没有交点\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\n\n//圆与圆的交点\n\nbool intersect(Circle c1,Circle c2){\n    return sign(getDistance(c1.c,c2.c)-(c1.r+c2.r))<=0;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y,p.x);// double atan2(double y,double x) 返回的是原点至点(x,y)的方位角，即与 x 轴的夹角。返回值的单位为弧度，取值范围为(-PI,PI]\n}\n\nVector polar(double r,double a){\n    return Point(cos(a)*r,sin(a)*r);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    assert(intersect(c1,c2));\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\n/*   多边形  */\ntypedef vector<Point> Polygon;\n\n//点的****内包*****(判断点与多边形的关系)\n//多边形内返回2\n//多边形上返回1\n//多边形外返回0\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n\n/* *******凸包*****(包含点集合p中所有点的最小凸多边形)\n * 输出凸多边形最下端最左侧的顶点为起点,按逆时针方向依次输出坐标。\n * 安德鲁算法 O(n*logn)\n */\n\nPolygon andrewscanf(Polygon s){\n    int n=s.size();\n    if(n<3){\n        return s;\n    }\n    sort(s.begin(),s.end());    //x从小到大，x相同的y从小到大\n    Polygon u,l;\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[n-1]);\n    l.push_back(s[n-2]);\n    //构建凸包上部\n    for(int i=2;i<n;i++){\n        for(int j=u.size();j>=2&&(ccw(u[j-2],u[j-1],s[i])==COUNTER_CLOCKWISE);j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //构建凸包下部\n    for(int i=n-3;i>=0;i--){\n        for(int j=l.size();j>=2&&(ccw(l[j-2],l[j-1],s[i])==COUNTER_CLOCKWISE);j--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    //按顺序生成凸包点的序列\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--){\n        l.push_back(u[i]);\n    }\n    return l;\n}\n\ndouble RC(Polygon v){\n    double res=-1;\n    int n=v.size();\n    for(int i=0,k=0;i<n;i++){\n        while(sign((v[i]-v[k]).norm()-(v[i]-v[(k+1)%n]).norm())==-1) k=(k+1)%n;\n        res=max(res,(v[i]-v[k]).abs());\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    Polygon v(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lf%lf\",&v[i].x,&v[i].y);\n    }\n    printf(\"%.10f\\n\",RC(v));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\ndouble dist(double x1, double y1, double x2, double y2) {\n    double dx = x1 - x2;\n    double dy = y1 - y2;\n    return std::sqrt(dx*dx + dy*dy);\n}\n\nint main() {\n    int64_t n;\n    std::cin >> n;\n\n    std::vector<double> x(n);\n    std::vector<double> y(n);\n    for (auto i = 0; i < n; ++i) {\n        std::cin >> x[i] >> y[i];\n    }\n\n    size_t u = 0;\n    double d = 0.0;\n\n    for (auto i = 0; i < n; ++i) {\n        double t = dist(x[0], y[0], x[i], y[i]);\n\n        if (t > d) {\n            d = t;\n            u = i;\n        }\n    }\n\n    size_t v = 0;\n    for (auto i = 0; i < n; ++i) {\n        double t = dist(x[u], y[u], x[i], y[i]);\n\n        if (t > d) {\n            d = t;\n            v = i;\n        }\n    }\n\n    std::cout << std::fixed << std::setprecision(12) << dist(x[u], y[u], x[v], y[v]) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vec;\n \nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n \ndouble eps=1e-8;\ndouble PI=acos(-1);\n \nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\n \ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n \n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n \nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n \n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\n \ndouble calcArea(vec &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++)res+=cross(t[i],t[(i+1==n?0:i+1)]);\n  return abs(res/2.0);\n}\n \ndouble Arg(P a,P b,P c){\n  b-=a,c-=a;\n  return arg(c*conj(b));\n}\n \nint inPolygon(vec &t,P p){\n  int n=t.size();\n  double sum=0;  \n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p) == 0 )return 1;// on\n    sum+= Arg(p,a,b);\n  }\n  if( abs(sum) < eps )return 0;//out\n  else  return 2;//in\n}\n \ntypedef pair<double,P> Pair;\nvec ConvexHull(vec t){\n  vector<Pair> u;\n  vec R;\n  int N=t.size(),K=0,C=0;\n  for(int i=1;i<N;i++)if(t[i]<t[K])K=i;\n  for(int i=0;i<N;i++)u.push_back(Pair(arg(t[i]-t[K]),t[i]));\n  R.push_back(t[K]),C++;\n  sort(u.begin(),u.end());\n  for(int i=0;i<N;i++){\n    P p=u[i].second;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==0)continue;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==2)continue;\n    while(2<=C&&ccw(R[C-2],R[C-1],p)!=1)R.pop_back(),C--;\n    R.push_back(p),C++;    \n  }\n  return R;\n}\n \nvec cutConvex(vec &t,P a,P b){\n  int N=t.size();\n  vec res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C+D==0&&max(C,D)==1)res.push_back(intersect(a,b,c,d));\n  }\n  return res;\n}\n \ndouble maxDist(vec &t){\n  vec u=t;//ConvexHull(t);\n  int N=u.size(),K=0;\n  double res=0;\n  for(int i=0;i<N;i++){\n    while(abs(u[i]-u[K])<abs(u[i]-u[(K+1)%N]))K=(K+1)%N;\n    res=max(res,abs(u[i]-u[K]));\n  }\n  return res;\n}\n \n \nint main(){\n  int n;\n  cin>>n;\n  vec t;\n  double x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  printf(\"%.8f\\n\",maxDist(t));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\n//?????¢?????¢???\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\nint main(){\n  int n,c=0;\n  Polygon p,a;\n  Point s;\n  double d=0;\n  cin>>n;\n  while(n--){\n    cin>>s.x>>s.y;\n    p.push_back(s);\n  }\n  r(i,p.size())\n  for(int j=i+1;j<p.size();j++)\n    d=max(d,getDistancePP(a[i],a[j]));\n  printf(\"%.11f\\n\",d);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <tuple>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nusing vec = complex<double>;\nusing line = pair<vec,vec>;\nusing polygon = vector<vec>;\nconst double eps = 0.0000001;\n\ndouble inner_product(vec u,vec v){\n    return real(u*conj(v));\n}\ndouble cross_product(vec u,vec v){\n    return imag(conj(u)*v);\n}\n\nvec projection(line l,vec p){//p???l???????°???±\n    vec s=l.first, t=l.second;\n    double k = inner_product(t-s,p-s)/inner_product(t-s,t-s);\n    return (1.0-k)*s+k*t;\n}\n\nvec reflection(line l,vec p){\n    return 2.0*projection(l,p)-p;\n}\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    double o = cross_product(ab,ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(inner_product(ab,ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(inner_product(ab,ab)<inner_product(ac,ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nbool isIntersect(line l0, line l1){\n    int s = ccw(l0.first,l0.second,l1.first)*ccw(l0.first,l0.second,l1.second);\n    if(s!=0&&s!=-1&&s!=-4) return false;\n    s=ccw(l1.first,l1.second,l0.first)*ccw(l1.first,l1.second,l0.second);\n    if(s!=0&&s!=-1&&s!=-4) return false;\n    else return true;\n}\n\nvec interSection(line l0, line l1){\n    vec s0, t0, s1, t1;\n    tie(s0,t0)=l0; tie(s1,t1)=l1;\n    double k = cross_product(t1-s1,s1-s0)/cross_product(t1-s1,t0-s0);\n    return s0+(t0-s0)*k;\n}\n\ndouble segLength(line l){\n    return abs(l.first-l.second);\n}\n\ndouble distLine2point(line l, vec p){\n    return abs(cross_product(l.second-l.first,p-l.first))/abs(l.second-l.first);\n}\n\ndouble distSeg2Point(line l, vec p){\n    vec x = projection(l,p);\n    double L = segLength(l);\n    if(abs(x-l.first)<L&&abs(x-l.second)<L){\n        return abs(x-p);\n    }else{\n        return min(abs(l.first-p),abs(l.second-p));\n    }\n}\n\ndouble distSeg2Seg(line l1, line l2){\n    if(isIntersect(l1,l2)) return 0;\n    double ret = 1e20;\n    ret = min(ret,distSeg2Point(l1,l2.first));\n    ret = min(ret,distSeg2Point(l1,l2.second));\n    swap(l1,l2);\n    ret = min(ret,distSeg2Point(l1,l2.first));\n    ret = min(ret,distSeg2Point(l1,l2.second));\n    return ret;\n}\n\ndouble area(polygon& g){\n    double S=0;\n    for(auto i = g.begin()+1; i!=g.end();++i){\n        S += cross_product(*(i-1),*i);\n    }\n    S/=2;\n    return S;\n}\n\nbool isConvex(polygon& g){\n    int n=g.size()-2;\n    for(int i=0;i<n;i++){\n        if(!~ccw(g[i],g[i+1],g[i+2]))return false;\n    }\n    return true;\n}\n\nbool isOnEdge(polygon& g,vec& p){\n    int n=g.size()-1;\n    for(int i=0;i<n;i++){\n        if(!ccw(g[i],g[i+1],p)) return true;\n    }\n    return false;\n}\n\nbool isInside(polygon& g,vec& p){\n    int n=g.size()-1,c=0;\n    vec O = vec(114514,123456);\n    for(int i=0;i<n;i++){\n        c+=isIntersect(line(O,p),line(g[i],g[i+1]));\n    }\n    if(c%2) return true;\n    else return false;\n}\n\npolygon convex_hull(polygon& V){\n    polygon C;\n    sort(V.begin(),V.end(),[](const vec& a, const vec& b){return a.imag()==b.imag() ? a.real() < b.real() : a.imag()< b.imag();});\n    //?????´\n    for(int i=0; i<V.size(); i++){\n        vec v = V[i];\n        while(C.size()>=2&&cross_product(v-C[C.size()-2],C.back()-C[C.size()-2])>0) C.pop_back();\n        C.push_back(v);\n    }\n    //?????´\n    for(int i=V.size()-2; i>=0; i--){\n        vec v = V[i];\n        while(C.size()>=2&&cross_product(v-C[C.size()-2],C.back()-C[C.size()-2])>0) C.pop_back();\n        C.push_back(v);\n    }\n    C.pop_back();\n    return C;\n}\n\ndouble diameter(polygon &C){\n    int n=C.size();\n    int i=0,j=0;\n    for(int k=0;k<n;k++){\n        if(C[k].real()<C[i].real())i=k;\n        if(C[k].real()>C[j].real())j=k;\n    }\n    int i0=i,j0=j;\n    double R=0;\n    while(i!=j0||j!=i0){\n        R=max(R,abs(C[i]-C[j]));\n        if(cross_product(C[(i+1)%n]-C[i],C[(j+1)%n]-C[j])<0){\n            i=(i+1)%n;\n        }else{\n            j=(j+1)%n;\n        }\n    }\n    return R;\n}\n\n//???????????§???????????????\n\nint main(){\n    int n;\n    cin >> n;\n    vector<vec> V,C;\n    while(n--){\n        double x,y;\n        cin>>x>>y;\n        V.emplace_back(x,y);\n    }\n    C=convex_hull(V);\n    cout.precision(6);\n    cout << fixed;\n    cout << diameter(C) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:https://yukicoder.me/problems/no/96>\n 問題文============================================================\n https://yukicoder.me/problems/no/94と同じ\n \n 制約強化版\n =================================================================\n 解説=============================================================\n \n バケット法を用いて、探索範囲を狭めてUnion-Findで到達可能点群の集合を求める。\n その後、凸包をとって、その最遠点対距離を求めればいい。\n \n \n convex_diameter(キャリパー法)が特定ケースでバグった結果、\n 愚直解に書き直したら最大ケースが小さかったらしく、通った。\n \n 直さなきゃ\n ================================================================\n */\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 円の内外判定\n//  2 => out : 0 => on : 1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nld solve(){\n    ld res = 0;\n    int N; cin >> N;\n    if(N == 0) return res = 1;\n    Polygon ps(N);\n    vector<vector<vector<ll>>> backet(2010,vector<vector<ll>>(2010));\n    for(int i = 0; i < N;i++){\n        ll x,y; cin >> x >> y;\n        ps[i] = Point(x,y);\n        x+=10000; y+=10000;\n        backet[x/10][y/10].push_back(i);\n    }\n    \n    // preprocessing\n    UnionFind UF(N);\n    int dx[9] = {0,1,1,1,0,-1,-1,-1,0};\n    int dy[9] = {0,1,0,-1,-1,-1,0,1,1};\n    for(int i = 0; i < 2010;i++){\n        for(int j = 0; j < 2010;j++){\n            for(auto v:backet[i][j]){\n                for(int k = 0; k < 9;k++){\n                    int ni = i + dx[k],nj = j + dy[k];\n                    if(ni < 0 || nj < 0) continue;\n                    for(auto vv:backet[ni][nj]){\n                        if(v == vv) continue;\n                        if(abs(ps[v]-ps[vv]) < 10+eps) UF.unionSet(v, vv);\n                    }\n                }\n            }\n        }\n    }\n    \n    \n    // calc res\n    vector<Polygon> Polys(N);\n    for(int i = 0; i < N;i++){ Polys[UF.root(i)].push_back(ps[i]); }\n    for(int i = 0; i < N;i++){\n        if(Polys[i].size() <= 1) continue;\n        Polys[i] = convex_hull(Polys[i]);\n        res = max(res,convex_diameter(Polys[i]).second);\n//        for(int j = 0; j < Polys[i].size(); j++){\n//            for(int k = 0; k < Polys[i].size();k++){\n//                if(j==k) continue;\n//                res = max(res,abs(Polys[i][j]-Polys[i][k]));\n//            }\n//        }\n    }\n    res += 2.;\n    return res;\n}\n\nld aoj_cgl(){\n    ld res = 0;\n    ll n; cin >> n;\n    Polygon ps(n);\n    for(auto& p:ps) p = input_point();\n    res = convex_diameter(ps).second;\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n//    cout << fixed << setprecision(12) << solve() << endl;\n    cout << fixed << setprecision(12) << aoj_cgl() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*<<head>> {{{*/\n#include <bits/stdc++.h>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define dd(x) cout << #x << \" = \" << x << \", \"\n#define de(x) cout << #x << \" = \" << x << endl\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n//INF = 1 061 109 567 ; INF + INF = 2 122 219 134 ;\n//LINF = 4 557 430 888 798 830 399 ; LINF + LINF = 9 114 861 777 597 660 798 ;\nconst int INF = 0x3f3f3f3f;     // -INF: 0xc0   abs(-INF) = INF + 1\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n/*}}}*/                         // zr, zm\nconst int MOD = (int)1e9+7;     // when MOD = 1e9+7, inv2 = 500000004\nconst int N = (int)-1;\n\n// ------- 变量 ------- //\n\n/* 注意\n  1. 点、向量\n    1. 如果角度出现 -pi ，可以加上 2pi 修正为 pi\n    2. atan2(y, x) 的参数是浮点数时，可能出现 -pi ，如 atan2(-0.0, -1.0)\n  2. 线段、直线\n    1. 线段严格相交定义为：每条线段的两个端点落在另一条线段两边，形象来说，就是可以在图形里看到四个端点和一个交点\n*/\n\ntypedef db T;\nconst db eps = 1e-7, pi = acosl(-1.);\nint sgn(T x) { return (x > eps) - (x < -eps); }\nbool inMid(T l, T x, T r) { return sgn(l - x) * sgn(r - x) <= 0; }  // 数 x 在区间 [l, r] 内（包括边界）\n\n// 点、向量\nstruct P {\n    T x, y; P () {} P(T x, T y) : x(x), y(y) {}\n    P operator + (const P &b) const { return P(x + b.x, y + b.y); }  // 向量加\n    P operator - (const P &b) const { return P(x - b.x, y - b.y); }  // 向量减\n    T operator * (const P &b) const { return x * b.x + y * b.y; }    // 向量点积\n    T operator / (const P &b) const { return x * b.y - y * b.x; }    // 向量叉积\n    P operator * (const T &k) const { return P(x * k, y * k); }      // 向量数乘\n    P operator / (const T &k) const { return P(x / k, y / k); }      // 向量数除\n    bool operator < (const P &b) const { return sgn(x - b.x) ? x < b.x : y < b.y; }  // 左小右大，下小上大\n    bool operator == (const P &b) const { return !sgn(x - b.x) && !sgn(y - b.y); }   // 向量相等\n    P rot(T t) { return P(x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)); }  // 向量逆时针旋转 t 弧度\n    P rot90() { return P(-y, x); }           // 向量逆时针旋转 90 度\n    db arg() const { return atan2(y, x); }   // 方位角 (-pi, pi]\n    T abs() { return sqrt(x * x + y * y); }  // 向量模长\n    T abs2() { return x * x + y * y; }       // 向量模长的平方\n    P unit() { return (*this) / abs(); }     // 单位向量\n    void scan() { db tx, ty; scanf(\"%lf%lf\", &tx, &ty); x = tx; y = ty; }  // 输入\n    void print() { printf(\"%.0lf %.0lf\\n\", x, y); }                      // 输出\n    P toR() { return (sgn(x) == -1 || !sgn(x) && sgn(y) == -1) ? (*this)*(-1) : (*this); }  // 若向量在 2 3 象限，则取相反向量\n    bool isUp() const { return sgn(y) == 1 || !sgn(y) && sgn(x) == -1; }                    // 向量是否在 1 2 象限\n};\nT dis(P a, P b) { return (b - a).abs(); }   // 点 a 到点 b 的距离\nP symmetry(P p, P a) { return a + a - p; }  // 点 p 关于点 a 的中心对称点\nT cross(P o, P a, P b) { return (a - o) / (b - o); }         // 向量 oa 与 ob 的叉积\nint crossSgn(P o, P a, P b) { return sgn(cross(o, a, b)); }  // 向量 oa 与 ob 的叉积符号\ndb rad(P a, P b) { return atan2(a / b, a * b); }             // 向量 a 与 b 的夹角（弧度制）\nbool order(const P &a, const P &b) { return a.isUp() < b.isUp() || a.isUp() == b.isUp() && sgn(a/b) > 0; }  // 极角排序\n\n// 线段、直线\nstruct L { P s, t; L () {} L(P s, P t) : s(s), t(t) {} };\nbool onPS(P p, L a) { return sgn((a.t-a.s)/(p-a.s))==0 && sgn((p-a.s)*(p-a.t))<=0; }   // 点 p 是否在线段 a 上\nbool inRec(P p, L a) { return inMid(a.s.x, p.x, a.t.x) && inMid(a.s.y, p.y, a.t.y); }  // 点 p 在以直线 a 为对角线的矩形内\nP proj(P p, L a) { return (a.t-a.s) * ( (p-a.s) * (a.t-a.s) / (a.t-a.s).abs2() ) + a.s; }  // 点 p 关于直线 a 的投影点\nP reflect(P p, L a) { return proj(p, a) * 2 - p; }                                         // 点 p 关于直线 a 的对称点\nbool xSSr(const L &a, const L &b) {  // 线段 a 和线段 b 严格相交\n    T c1 = (a.t-a.s) / (b.s-a.s), c2 = (a.t-a.s) / (b.t-a.s);\n    T c3 = (b.t-b.s) / (a.s-b.s), c4 = (b.t-b.s) / (a.t-b.s);\n    return sgn(c1) * sgn(c2) < 0 && sgn(c3) * sgn(c4) < 0;\n}\nbool xSS(L a, L b) {                 // 线段 a 和线段 b 不严格相交\n    T c1 = (a.t-a.s) / (b.s-a.s), c2 = (a.t-a.s) / (b.t-a.s);\n    T c3 = (b.t-b.s) / (a.s-b.s), c4 = (b.t-b.s) / (a.t-b.s);\n    return sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n           sgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n           sgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n           sgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n           sgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\nbool xSL(L a, L b) {  // 线段 a 与直线 b 相交 ( 不严格 : <= ; 严格 : < )\n    return sgn( (b.t - b.s) / (a.s - b.s) ) * sgn( (b.t - b.s) / (a.t - b.s) ) <= 0;\n}\nP xLL(L a, L b) {  // 直线 a 和直线 b 的交点\n    T s1 = (b.t - b.s) / (a.s - b.s), s2 = -( (b.t - b.s) / (a.t - b.s) );\n    return (a.s * s2 + a.t * s1) / (s1 + s2);\n}\ndb disPL(P p, L a) { return fabs( (a.t-a.s) / (p-a.s) ) / (a.t-a.s).abs(); }  // 点 p 到直线 a 的距离\ndb disPS(P p, L a) {                                                          // 点 p 到线段 a 的距离\n    return sgn( (a.t-a.s) * (p-a.s) ) * sgn( (a.s-a.t) * (p-a.t) ) == 1\n           ? disPL(p, a) : min( (p-a.s).abs(), (p-a.t).abs() );\n}\ndb disSS(L a, L b){                                                           // 线段 a 到线段 b 的距离\n    if (xSS(a,b)) return 0;\n    return min( min( disPS(a.s,b), disPS(a.t,b) ), min( disPS(b.s,a), disPS(b.t,a) ) );\n}\ndb disLL(L a, L b) { return (a.t-a.s) / (b.t-b.s) ? 0 : disPL(a.s, b); }      // 直线 a 到直线 b 的距离\n\n// 多边形、凸包\ntypedef vector<P> polygon;\npolygon Convex(polygon A) {  // 求凸包，逆时针排序（ 内角 <180 : (<=) ; 内角 <=180 : (<) ）\n    int n = sz(A); if (n <= 1) return A;\n    sort(all(A));\n    polygon B;\n    for (int i = 0; i < n; B.pb(A[i++]))\n        while (sz(B) > 1 && crossSgn(B[sz(B)-2], B.back(), A[i]) < 0) B.pop_back();  // 更改这里的 <\n    for (int i = n - 2, t = sz(B); i >= 0; B.pb(A[i--]))\n        while (sz(B) > t && crossSgn(B[sz(B)-2], B.back(), A[i]) < 0) B.pop_back();  // 同上\n    B.pop_back(); return B;\n}\nT area(polygon A) {  // 多边形 A 的面积，整型可以返回面积的两倍，保持精度\n    T res = 0;\n    rep(i, 0, sz(A)) res += A[i] / A[ (i+1) % sz(A) ];\n    return fabs(res) / 2;\n}\nbool isConvex(polygon A) {  // 多边形 A 是否是凸包，要求 A 的点集按逆时针排序\n    rep(i, 0, 2) A.pb(A[i]);\n    rep(i, 0, sz(A)-2) if ( sgn( (A[i+1]-A[i]) / (A[i+2]-A[i]) ) < 0 ) return 0;\n    return 1;\n}\nint inPpo(P p, polygon A) {  // 点和多边形关系 ( 2 : in , 1 : on , 0 : out )\n    int res = 0; A.pb(A[0]);\n    rep(i, 1, sz(A)) {\n        P u = A[i-1], v = A[i];\n        if (onPS(p, L(u, v))) return 1;\n        if (sgn(u.y - v.y) > 0) swap(u, v);\n        if (sgn(u.y - p.y) >= 0 || sgn(v.y - p.y) < 0) continue;\n        if (crossSgn(v, u, p) < 0) res ^= 1;\n    }\n    return res << 1;\n}\nT ConvexDiameter(polygon A) {\n    int now = 0, n = sz(A); T res = 0;\n    if (n <= 1) return 0;\n    rep(i, 0, sz(A)) {\n        now = max(now, i);\n        while (1) {\n            T t1 = dis(A[i], A[now%n]), t2 = dis(A[i], A[(now+1)%n]);\n            res = max(res, max(t1, t2));\n            if (t2 > t1) now++; else break;\n        }\n    }\n    return res;\n}\n\nstruct C {\n    P o; db r; C () {} C (P o, db r) : o(o), r(r) {}\n};\n\nC getC(P a,P b,P c){  // 三点确定一个圆 （ 三角形外接圆 ）\n    db a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;\n    db a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;\n    db d = a1 * b2 - a2 * b1;\n    P o = P(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 - a2 * c1) / d);\n    return C(o, dis(a, o));\n}\n\nint n;\npolygon A;\n\n// ------- 函数 ------- //\n\nvoid Init() {\n    A.clear();\n\n    rep(i, 0, n) {\n        P p; p.scan();\n        A.pb(p);\n    }\n}\n\nint Solve() {\n    printf(\"%.12f\\n\", ConvexDiameter(A));\n    return 0;\n}\n\n// ------- main ------- //\n\nint main ()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n\n    //Pre();\n    //int t; scanf(\"%d\", &t); while (t--) {\n    while (~scanf(\"%d\", &n)) {\n    //while(fgets(s, N, stdin)) {   // 注意 fgets 会读入换行符\n        //if (n == 0) break;\n        //static int kase = 0; printf(\"Case %d: \", ++kase);\n        Init();\n        Solve();\n        //if (t) puts(\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 100000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return (s1.p1+(s1.p2-s1.p1)*t);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){ return atan2(p.y,p.x);}\nVector polar(double a,double r){ return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return mp(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\ndouble getPolygonArea(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i%n],p[(i+1)%n]);\n  return area/2;\n}\n\nbool isConvex(Polygon p){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    if(ccw(p[(i+1)%n],p[i%n],p[(i+2)%n])==1)return false;\n  }\n  return true;\n}\n\n// in 2,out 0,on 1\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\ndouble convex_diameter(Polygon p){\n  int n=p.size();\n  int i=0,j=0;\n\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k])i=k;\n    if(p[k]<p[j])j=k;\n  }\n  int si=i,sj=j;\n  double ans=0.0;\n  while(i!=sj || j!=si){\n    ans=max(ans,abs(p[i]-p[j]));\n    if(cross((p[(i+1)%n]-p[i]),(p[(j+1)%n]-p[j]))<0)i=(i+1)%n;\n    else j=(j+1)%n;\n  }\n  return ans;\n}\n\nint main()\n{\n  int n,q,a,b,mi=inf,ii;\n  Polygon p,ch;\n\n  cin>>n;\n  p.resize(n);\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n\n  printf(\"%.10f\\n\",convex_diameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n \nclass Point {\n    public:\n    double x, y;\n \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n \n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n \n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n \ntypedef Point Vector;\n \nVector normal(Point p0, Point p1); //ベクトルp0p1の法線ベクトル\nint argmax(const vector<double> &v); //std::vectorのargmax関数\n \nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n \n    int n;\n    cin >> n;\n    vector<Point> data(n);\n \n    for(int i=0; i<n; i++){\n        cin >> data[i].x >> data[i].y;\n    }\n \n    Point p0, p1;\n    Vector nv;\n    vector<double> xNormalNoDup(0);\n    vector<Vector> normalVector(0);\n    xNormalNoDup.reserve(n);\n    normalVector.reserve(n);\n    map<double, int> isSwitchVertex;\n \n    for(int i=0; i<n; i++){\n        p0 = data[i];\n        p1 = data[(i+1)%n];\n        nv = normal(p0, p1);\n        normalVector.push_back(nv);\n        if (nv.y > 0 || nv.x == 1) isSwitchVertex[ nv.x ] += 1;\n        else isSwitchVertex[ -nv.x ] -= 1;\n    }\n \n    //Extract keys of isSwitchVertex and sort\n    for(map<double,int>::iterator it = isSwitchVertex.begin(); it != isSwitchVertex.end(); ++it) {\n        xNormalNoDup.push_back(it->first);\n    }\n    sort(xNormalNoDup.begin(), xNormalNoDup.end(), greater<double>() );\n \n    //find the first pair\n    int pairIndex0 = -1; //upside\n    int pairIndex1 = -1; //downside\n    Vector nv0, nv1;\n    for(int i=0; i<n; i++){\n        nv0 = normalVector[i];\n        nv1 = normalVector[(i+1)%n];\n        if( nv0.y<0 && nv1.y>=0 ) pairIndex0 = (i+1)%n;\n        if( nv0.y>0 && nv1.y<=0 ) pairIndex1 = (i+1)%n;\n    }\n    if(pairIndex0<0 || pairIndex1<0) cout << \"ERROR: Pair Initialization failed.\";\n    //cout << \"First Pair\" << \" \" << pairIndex0 << \" \" << pairIndex1 << endl;\n \n    double maxDiameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n    double diameter = 0;\n \n    for(int i=0; i<=xNormalNoDup.size(); i++){\n        switch( isSwitchVertex[ xNormalNoDup[i] ] ) {\n            case 1:  pairIndex0 += 1;\n                     break;\n            case -1: pairIndex1 += 1;\n                     break;\n            case 0:  pairIndex0 += 1;\n                     pairIndex1 += 1;\n                     break;\n            default: cout << \"Error: Next pair not found.\" << endl;\n                     break;\n        }\n        pairIndex0 %= n;\n        pairIndex1 %= n;\n        diameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n        maxDiameter = (diameter > maxDiameter)? diameter: maxDiameter;\n    }\n \n    cout << setprecision(14) << maxDiameter << endl;\n \n    return 0;\n}\n \nVector normal(Point p0, Point p1){\n    Vector nv;\n    nv.x = - ( p1.y - p0.y );\n    nv.y = p1.x - p0.x;\n    double a = nv.abs();\n    return nv / a;\n}\n \nint argmax(const vector<double> &v){\n    return distance(v.begin(), max_element(v.begin(), v.end()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble dist(const Point &a,const Point &b){\n    return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool sortX(Point p1,Point p2){\n    if(p1.x != p2.x){ \n        return (p1.x - p2.x < -EPS);\n    }else{\n        return (p1.y - p2.y < -EPS);\n    }\n}\n\nbool sortY(Point p1,Point p2){\n    if(p1.y != p2.y){\n        return (p1.y - p2.y < -EPS);\n    }else{ \n        return (p1.x - p2.x < -EPS);\n    }\n}\n\n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\n\ntypedef vector<Point> Polygon;\n\nPolygon convex_hull(Polygon &ps){\n    int N = ps.size(),j = 0;\n    Polygon pg(N*2);\n    sort(ps.begin(),ps.end(),sortY);\n    for(int i = 0 ; i < N ; i++,j++){\n        while(j >= 2 && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n            j--;\n        }\n        pg[j] = ps[i];\n    }\n    int k = j+1;\n    for(int i = N-2 ; i >= 0 ; i--,j++){\n        while(j >= k && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n            j--;\n        }\n        pg[j] = ps[i];\n    }\n    pg.resize(j-1);\n    return pg;\n}\n\ndouble getPolygonDiameter(Polygon &p){\n    Polygon np = convex_hull(p);\n    int N = np.size();\n    if(N == 2) return dist(np[0],np[1]);\n    int i = 0,j = 0;\n    for(int k = 0 ; k < N ; k++){\n        if(!sortX(np[i],np[k])) i = k;\n        if(sortX(np[j],np[k])) j = k;\n    }\n    double res = 0;\n    int si = i,sj = j;\n    while(i != sj || j != si){\n        res = max(res,dist(np[i],np[j]));\n        Point p1 = np[(i+1)%N]-np[i];\n        Point p2 = np[(j+1)%N]-np[j];\n        if(cross(p1,p2) < 0){\n            i = (i + 1) % N;\n        }else{\n            j = (j + 1) % N;\n        }\n    }\n    return res;\n}\n\n\nint main(){\n    int N;\n    cin >> N;\n    Polygon pg(N);\n    for(int i = 0 ; i < N ; i++){\n        cin >> pg[i].x >> pg[i].y;\n    }\n    printf(\"%.12f\\n\",getPolygonDiameter(pg));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); ++i)\n#define per(i, a, b) for(int i = (a); i >= (b); --i)\n#define debug(x) cerr << #x << ' ' << x << endl;\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 1e9+7;\nconst int MAXN = 2e5 + 7;\nconst double EPS=1e-8;\ninline int sign(double a){return a<-EPS?-1:a>EPS;}\ninline int cmp(double a,double b){return sign(a-b);}\n//点\nstruct P{\n    double x,y;\n    P(){}\n    P(double _x,double _y):x(_x),y(_y){}\n    P operator + (P p){return P(x+p.x,y+p.y);}\n    P operator - (P p){return P(x-p.x,y-p.y);}\n    P operator * (double k){return P(x*k,y*k);}\n    P operator / (double k){return P(x/k,y/k);}\n    double dot(P p){return x*p.x+y*p.y;}\n    double det(P p){return x*p.y-y*p.x;}\n    double distTo(P p){return (*this-p).abs();}\n    double alpha(){return atan2(y,x);}\n    void read(){scanf(\"%lf%lf\", &x, &y);}\n    void write(){printf(\"%.0lf %.0lf\\n\", x, y);}\n    double abs(){return sqrt(abs2());}\n    double abs2(){return x*x+y*y;}\n    P rot90(){return P(-y,x);}\n    P unit(){return *this/abs();}\n    int quad(){return sign(y)==1||(sign(y)==0&&sign(x)>=0);}\n    P rot(double an){return P(x*cos(an)-y*sin(an),x*sin(an)+y*cos(an));}\n    bool operator < (P p)const{int c=cmp(x,p.x);if(c)return c==-1;return cmp(y,p.y)==-1;}\n    bool operator == (P o)const{return cmp(x,o.x)==0&&cmp(y,o.y)==0;}\n}s[MAXN];\n\nint main(int argc, char const *argv[])\n{\n    int n;\n    scanf(\"%d\", &n);\n    rep(i, 0, n-1)    s[i].read();\n    int j = 2;\n    double ans = 0;\n    rep(i, 0, n-1) {\n        while((s[i]-s[j]).det(s[i+1]-s[j]) <= (s[i]-s[(j+1)%n]).det(s[i+1]-s[(j+1)%n]))  j = (j+1)%n;\n        ans = max(ans, max((s[i]-s[j]).abs(), (s[i+1]-s[j]).abs()));\n    }\n    printf(\"%.16lf\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min(), sort(), reverse()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    const Point normalize() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n    void print() const;\n};\nbool operator==(const Point& lhs, const Point& rhs);\nbool operator!=(const Point& lhs, const Point& rhs);\nbool operator<(const Point& lhs, const Point& rhs);\nbool operator>(const Point& lhs, const Point& rhs);\nbool operator<=(const Point& lhs, const Point& rhs);\nbool operator>=(const Point& lhs, const Point& rhs);\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool in(const Point&) const;\n    bool out(const Point&) const;\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Line&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n    void print() const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    explicit Polygon(std::vector<Point> p) :point(p) {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool intersect(const Polygon&) const;\n    bool on_edge(const Point&) const;\n    const Polygon convex_hull() const;\n    const std::vector<int> farthest_point_pair() const;\n    void print() const;\n};\n// Point\nbool operator==(const Point& lhs, const Point& rhs) {return lhs.x() == rhs.x() && lhs.y() == rhs.y();}\nbool operator!=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() || lhs.y() != rhs.y();}\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() < rhs.y();}\nbool operator>(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() > rhs.y();}\nbool operator<=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() <= rhs.y();}\nbool operator>=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() >= rhs.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\nconst Point Point::normalize() const {return abs() == 0.0 ? Point(0.0, 0.0) : Point(x(), y()) / abs();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nvoid Point::print() const {std::cout << x() << \", \" << y() << std::endl;}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nbool Segment::parallel(const Line& l) const {line().parallel(l);}\nbool Segment::parallel(const Segment& s) const {return line().parallel(s.line());}\nbool Segment::orthogonal(const Line& l) const {return line().orthogonal(l);}\nbool Segment::orthogonal(const Segment& s) const {return line().orthogonal(s.line());}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Segment::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::parallel(const Segment& s) const {return parallel(s.line());}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nbool Line::orthogonal(const Segment& s) const {return orthogonal(s.line());}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Line::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Circle\nbool Circle::in(const Point& p) const {return center().distance(p) < r() - EPS;}\nbool Circle::out(const Point& p) const {return r() + EPS < center().distance(p);}\nbool Circle::include(const Point& p) const {return center().distance(p) <= r() + EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) <= r() + EPS;}\nbool Circle::include(const Line& l) const {return center().distance(l) <= r() + EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) <= r() - c.r() + EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) <= r() + c.r() + EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\nvoid Circle::print() const {std::cout << \"radius: \" << r() << \" - point: \"; center().print();}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::intersect(const Polygon& p) const {\n    for(const auto& e1: edge()) for(const auto& e2: p.edge()) if(e1.intersect(e2)) return true;\n    return false;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\nconst Polygon Polygon::convex_hull() const {                // Andrew's Monotone Chain\n    Polygon result;\n    std::vector<Point> res;\n    std::vector<Point> original = vertex();\n    sort(original.begin(), original.end());\n    original.insert(original.end(), original.rbegin() + 1, original.rend());\n    for(const auto& v: original) {\n        while(res.size() >= 2 && res[res.size() - 2].ccw(res[res.size() - 1], v) == CLOCKWISE) res.pop_back();\n        res.push_back(v);\n    }\n    res.pop_back();\n    for(const auto& v: res) result.add(v);\n    return result;\n}\nconst std::vector<int> Polygon::farthest_point_pair() const {  // Rotating calipers\n    auto v = vertex();\n    int p, q, start_p, start_q, max_p, max_q;\n    p = start_p = max_p = std::min_element(v.begin(), v.end()) - v.begin();\n    q = start_q = max_q = std::max_element(v.begin(), v.end()) - v.begin();;\n    double max_d = (vertex(p) - vertex(q)).norm();\n    do {\n        if((vertex((p + 1) % size()) - vertex(p)).cross(vertex((q + 1) % size()) - vertex(q)) >= 0) q = (q + 1) % size();\n        else p = (p + 1) % size();\n        if((vertex(p) - vertex(q)).norm() > max_d) {\n            max_d = (vertex(p) - vertex(q)).norm();\n            max_p = p;\n            max_q = q;\n        }\n    } while(start_p != q || start_q != p);\n    return {max_p, max_q};\n}\nvoid Polygon::print() const {for(const auto& v: vertex()) std::cout << v.x() << \", \" << v.y() << std::endl;}\n\n////////////////////////////////////////////////////////////////////////////////\n#include<iomanip>\nusing namespace std;\nint main() {\n    int n;\n    Polygon p;\n    for(cin>>n;n>0;--n) {\n        double x,y;\n        cin>>x>>y;\n        p.add(Point(x,y));\n    }\n    auto v = p.farthest_point_pair();\n    cout<<setprecision(12)<<fixed<<p.vertex(v[0]).distance(p.vertex(v[1]))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, a, b) for (int i = a, i##end = b; i <= i##end; ++i)\n#define per(i, a, b) for (int i = a, i##end = b; i >= i##end; --i)\n#define rep0(i, a) for (int i = 0, i##end = a; i < i##end; ++i)\n#define per0(i, a) for (int i = (int)a-1; ~i; --i)\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define chkmax(a, b) a = max(a, b)\n#define chkmin(a, b) a = min(a, b)\n#define x first\n#define y second\n#define enter putchar('\\n')\n\ntypedef long long ll;\ntypedef double DB;\n\nconst DB eps = 1e-12;\nconst DB PI = acos(-1);\n\nint sgn(DB x) { return fabs(x) < eps ? 0 : (x > 0 ? 1 : -1); }\n\nstruct Point {\n\tDB x, y;\n\tPoint(DB x = 0, DB y = 0) : x(x), y(y) {}\n\tPoint operator + (Point a) { return Point(x + a.x, y + a.y); }\n\tPoint operator - (Point a) { return Point(x - a.x, y - a.y); }\n\tPoint operator - () { return Point(-x, -y); }\n\tfriend Point operator * (DB k, Point a) { return Point(k * a.x, k * a.y); }\n\tDB operator % (Point a) { return x * a.x + y * a.y; }\n\tDB operator / (Point a) { return x * a.y - y * a.x; }\n\toperator DB() { return sqrt(x*x + y*y); }\n\tbool operator < (const Point &a) const { int d1 = sgn(x-a.x), d2 = sgn(y-a.y); return d1 < 0 || (d1 == 0 && d2 < 0); }\n};\n\nPoint gp() { Point a; scanf(\"%lf%lf\", &a.x, &a.y); return a; }\nvoid wp(Point a) { printf(\"%.0lf %.0lf\", a.x, a.y); }\n\nstruct Poly {\n\tstd::vector<Point> a;\n\tPoly(int n = 0) { a.resize(n); rep0(i, n) a[i] = gp(); }\n\tint size() { return a.size(); }\n\tvoid add(Point P) { a.push_back(P); }\n\tPoint &operator [] (int i) { int n = size(); return a[i >= n ? i-n : i]; }\n};\n\nint Direct1(Point P, Point P1, Point P2) { return sgn((P1-P)%(P2-P)); }\nint Direct2(Point P, Point P1, Point P2) { return sgn((P1-P)/(P2-P)); }\n\nDB Area(Poly A) {\n\tDB res = 0;\n\trep(i, 2, A.size()-1) res += (A[i]-A[0])/(A[i-1]-A[0]);\n\treturn fabs(res)/2;\n}\n\nbool IsConvex(Poly A) {\n\tbool f1 = 1, f2 = 1;\n\trep0(i, A.size()) {\n\t\tint t = sgn((A[i+1]-A[i])/(A[i+2]-A[i+1]));\n\t\tt && (t == 1 ? f1 = 0 : f2 = 0);\n\t}\n\treturn f1 || f2;\n}\n\nbool IsSegInter(Point P1, Point P2, Point Q1, Point Q2) {\n\tif (min(P1.x, P2.x) <= max(Q1.x, Q2.x) && max(P1.x, P2.x) >= min(Q1.x, Q2.x) && min(P1.y, P2.y) <= max(Q1.y, Q2.y) && max(P1.y, P2.y) >= min(Q1.y, Q2.y))\n\t\tif (Direct2(P1, P2, Q1) * Direct2(P1, P2, Q2) <= 0 && Direct2(Q1, Q2, P1) * Direct2(Q1, Q2, P2) <= 0) return 1;\n\treturn 0;\n}\n\nint IsInPoly(Poly A, Point P) {\n\tDB angle = 2.0*PI*rand()/RAND_MAX; Point Q = P+1e5*Point(cos(angle), sin(angle));\n\t//wp(Q);enter;\n\tint cnt = 0;\n\trep0(i, A.size()) {\n\t\tif (!Direct2(P, A[i], A[i+1]) && Direct1(A[i], A[i+1], P) * Direct1(A[i+1], A[i], P) >= 0) return -1;\n\t\tcnt ^= IsSegInter(A[i], A[i+1], P, Q);\n\t}\n\treturn cnt;\n}\n\nPoly GetConvex(int n, Point P[]) {\n\tstd::vector<int> s1, s2;\n\trep(i, 1, n) {\n\t\t//wp(P[i]); enter;\n\t\twhile (s1.size() > 1 && Direct2(P[s1[s1.size()-2]], P[s1[s1.size()-1]], P[i]) < 0) s1.pop_back();\n\t\twhile (s2.size() > 1 && Direct2(P[s2[s2.size()-2]], P[s2[s2.size()-1]], P[i]) > 0) s2.pop_back();\n\t\ts1.push_back(i), s2.push_back(i);\n\t}\n\tPoly A;\n\trep(i, 0, s1.size()-2) A.add(P[s1[i]]);\n\tper(i, s2.size()-1, 1) A.add(P[s2[i]]);\n\treturn A;\n}\n\nDB MaxConvexDist(Poly A) {\n\tDB ans = 0;\n\tfor (int l = 0, r = 0; l < A.size(); l++) {\n\t\twhile (r < A.size()-1 && DB(A[r]-A[l]) <= DB(A[r+1]-A[l])) r++;\n\t\tchkmax(ans, DB(A[r]-A[l]));\n\t}\n\treturn ans;\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tprintf(\"%.10lf\\n\", MaxConvexDist(Poly(n)));\n\t/*\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tPoint P1 = gp(), P2 = gp(), Q1 = gp(), Q2 = gp();\n\t\tprintf(\"%.10lf\\n\", SegDist(P1, P2, Q1, Q2));\n\t\t//wp(GetSegInter(P1, P2, Q1, Q2)); enter;\n\t\t//printf(\"%d\\n\", IsInter(P1, P2, Q1, Q2));\n\t\t//wp(Proj(P, P1, P2)); enter;\n\t}*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x*b.y - a.y*b.x;\n}\n\nVector normal(Point p0, Point p1); //ベクトルp0p1の法線ベクトル\nint argmax(const vector<double> &v); //std::vectorのargmax関数\n\nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int n;\n    cin >> n;\n    vector<Point> data(n);\n\n    for(int i=0; i<n; i++){\n        cin >> data[i].x >> data[i].y;\n    }\n\n    Point p0, p1;\n    Vector nv;\n    vector<double> xNormalNoDup(0);\n    vector<Vector> normalVector(0);\n    xNormalNoDup.reserve(n);\n    normalVector.reserve(n);\n    map<double, int> isSwitchVertex;\n\n    for(int i=0; i<n; i++){\n        p0 = data[i];\n        p1 = data[(i+1)%n];\n        nv = normal(p0, p1);\n        normalVector.push_back(nv);\n        if (nv.y > 0 || nv.x == 1) isSwitchVertex[ nv.x ] += 100;\n        else isSwitchVertex[ -nv.x ] += 1;\n    }\n\n    //Extract keys of isSwitchVertex and sort\n    for(map<double,int>::iterator it = isSwitchVertex.begin(); it != isSwitchVertex.end(); ++it) {\n        xNormalNoDup.push_back(it->first);\n    }\n    sort(xNormalNoDup.begin(), xNormalNoDup.end(), greater<double>() );\n\n    //find the first pair\n    int pairIndex0 = -1; //upside\n    int pairIndex1 = -1; //downside\n    int change0, change1;\n    Vector nv0, nv1;\n    for(int i=0; i<n; i++){\n        nv0 = normalVector[i];\n        nv1 = normalVector[(i+1)%n];\n        if( nv0.y<0 && nv1.y>=0 ) pairIndex0 = (i+1)%n;\n        if( nv0.y>0 && nv1.y<=0 ) pairIndex1 = (i+1)%n;\n    }\n    if(pairIndex0<0 || pairIndex1<0) cout << \"ERROR: Pair Initialization failed.\";\n    //cout << \"First Pair\" << \" \" << pairIndex0 << \" \" << pairIndex1 << endl;\n\n    double maxDiameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n    double diameter = 0;\n\n    for(int i=0; i<xNormalNoDup.size(); i++){\n        change0 = isSwitchVertex[ xNormalNoDup[i]]/100;\n        change1 = isSwitchVertex[ xNormalNoDup[i]]%100;\n        //cout << \"flag:\" << change0 << \" \" << change1 << \" \";\n        pairIndex0 += change0;\n        pairIndex1 += change1;\n        pairIndex0 %= n;\n        pairIndex1 %= n;\n        diameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n        //if(diameter > maxDiameter) cout << pairIndex0 << \" \" << pairIndex1 << \" \" << diameter << endl;\n        maxDiameter = (diameter > maxDiameter)? diameter: maxDiameter;\n        //cout << pairIndex0 << \" \" << pairIndex1 << \" \" << maxDiameter << endl;\n    }\n\n    cout << setprecision(14) << maxDiameter << endl;\n\n    return 0;\n}\n\nVector normal(Point p0, Point p1){\n    Vector nv;\n    nv.x = - ( p1.y - p0.y );\n    nv.y = p1.x - p0.x;\n    double a = nv.abs();\n    return nv / a;\n}\n\nint argmax(const vector<double> &v){\n    return distance(v.begin(), max_element(v.begin(), v.end()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int i = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int j = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int maxi, maxj;\n    LD maxd = 0;\n    for(; i < 2*n; i++){\n        if(maxd < norm(cpol[i]-cpol[j])){\n            maxd = norm(cpol[i] - cpol[j]);\n            maxi = i;\n            maxj = j;\n        }\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) <= 0) j = (j+1) % n;\n        else i = (i+1) % n; \n    }\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n    pair<int, int> ans = ConvexPolygonDiameter(p);\n    printf(\"%.9Lf\\n\", DistPP(p[ans.first], p[ans.second]));\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <math.h>\nusing namespace std;\n\nstruct punto{\n    long double x,y;\n    punto operator-(const punto b)const{\n        punto aux;\n        aux.x = x-b.x;\n        aux.y = y-b.y;\n        return aux;\n    }\n    long double operator*(const punto b)const{\n        return ( (x*b.x) + (y*b.y) ) ;\n    }\n};\n\nlong double mod(punto p){\n    return sqrt( p.x*p.x + p.y*p.y );\n}\n\nint main(){\n\n\nint N;\ncin>>N;\nvector<punto>V (N);\nfor(int i = 0; i < N; i++){\n    punto p;\n    cin>>p.x>>p.y;\n    V[i] = p;\n}\n\nlong double rta = 0.0;\nint index = 1;\nfor(int i = 0; i < N; i++){\n        ///cout<<\"---\"<<endl;\n    punto vec = V[ (i+1)%N ]-V[i]; /// genero todos los posibles lados\n    punto per;per.x = -vec.y;per.y = vec.x; ///busco la perpendicular = (-y,x).\n    /// ahora queremos el punto mas hacia el vector perpendicular.\n    while( per*V[ (index+1)%N ] >= per*V[index] ){\n        index = (index+1)%N;\n    }\n    rta = max(rta, max( mod(V[index]-V[i]) , mod(V[index]-V[(i+1)%N]) )  );\n}\n\ncout.precision(12);\ncout << rta<< endl;\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define mkp make_pair\n#define pa pair<int,int>\nconst int N=1e6+10;\nconst int mod=998244353;\nusing namespace std;\n\nstruct point{double x,y;}p[N],s[N];\ninline bool cmp2(point a,point b)\n{\n    double aa=atan2(a.y-p[1].y,a.x-p[1].x);\n    double bb=atan2(b.y-p[1].y,b.x-p[1].x);\n    if(fabs(aa-bb)<=1e-10||aa==bb) return a.x<b.x;\n    return aa<bb;\n}\ninline double cross(point a,point b,point c){return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x); }\ninline int get(int n)\n{\n    p[0].x=p[0].y=2e9; int k;  \n    for(int i=1;i<=n;i++) if(p[0].y>p[i].y||(p[0].y==p[i].y&&p[0].x>p[i].x)){p[0]=p[i]; k=i;}\n    swap(p[k],p[1]);\n    sort(p+2,p+1+n,cmp2);\n    s[1]=p[1],s[2]=p[2]; int top=2;\n    for(int i=3;i<=n;i++)\n    {\n        while(top>1&&cross(s[top-1],p[i],s[top])>=0) top--;\n        s[++top]=p[i];\n    }\n    return top;\n}\ninline double dis(point a,point b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); }\ndouble get_d(int top)\n{\n    if(top==2) return dis(s[1],s[2]);\n    s[++top]=s[1];\n    double d=0; int j=3;\n    for(int i=1;i<top;i++)\n    {\n        while(cross(s[j],s[i],s[i+1])<cross(s[j+1],s[i],s[i+1])) j=j%(top-1)+1;\n        d=max(d,max(dis(s[i],s[j]),dis(s[i+1],s[j])));\n    }\n    return d;\n}\nint main()\n{     \n     int n; scanf(\"%d\",&n);\n     for(int i=1;i<=n;i++)  scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n     int top=get(n);   \n     double d=get_d(top);\n     printf(\"%.10f\\n\",d);\nreturn 0;   \n}\n/*\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nconst db eps = 1e-9;\nint sgn(db a, db b = 0) {\n\ta -= b;\n\treturn (a > eps) - (a < -eps);\n}\n\nstruct poi {\n\tdb x, y;\n\tpoi operator -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tbool operator <(poi p) const {\n\t\treturn tie(x, y) < tie(p.x, p.y);\n\t}\n\tdb cross(poi p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb len() {\n\t\treturn sqrt(x * x + y * y);\n\t}\n};\ndb xmul(poi a, poi b, poi c) {\n\treturn (b - a).cross(c - a);\n}\n\nusing vp = vector <poi>;\nvp convex(vp v) {\n\tsort(v.begin(), v.end()); vp r;\n\tfor(int i = 0; i < v.size(); i ++) {\n\t\twhile(r.size() > 1 &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tr.push_back(v[i]);\n\t}\n\tint d = r.size();\n\tfor(int i = (int)v.size() - 2; i >= 0; i --) {\n\t\twhile(r.size() > d &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tif(i != 0) r.push_back(v[i]);\n\t}\n\treturn r;\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(false);\n\tint n; cin >> n; vp v;\n\tfor(int i = 0; i < n; i ++) {\n\t\tdb x, y; cin >> x >> y;\n\t\tv.push_back({x, y});\n\t}\n\tv = convex(v);\n\n\tn = v.size();\n\t/*\n\tfor(int i = 0; i < n; i ++)\n\t\tcout << v[i].x << ' ' << v[i].y << '\\n';\n\t\t*/\n\t{\n\t\tdb ans = 0;\n\t\tauto upd = [&](int i, int j) {\n\t\t\tdb t = (v[i] - v[j]).len();\n\t\t\tif(t > ans) ans = t;\n\t\t};\n\t\tint j = 1 % n;\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\twhile(sgn(xmul(v[i], v[(i + 1) % n], v[j]),\n\t\t\t\txmul(v[i], v[(i + 1) % n], v[(j + 1) % n])) < 0)\n\t\t\t\tj = (j + 1) % n;\n\t\t\t//cout << i << ' ' << j << '\\n';\n\t\t\tupd(i, j); /*upd((i + 1) % n, j);*/\n\t\t\t/*upd(i, (j + 1) % n);*/ /*upd((i + 1) % n, (j + 1) % n);*/\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\t\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    R res=0.0;\n\trep(k,2*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define EPS 1e-9\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n=g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nP inP(){\n  double x,y;\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\nL inL(){\n  P p1=inP();\n  P p2=inP();\n  L l(p1,p2);\n  return l;\n}\n\nint main(){\n\n  int n;\n  cin >> n;\n  G g;\n  for(int i = 0; i< n; i++){\n    P p = inP();\n    g.push_back(p);\n  }\n\n  cout << shosu(10) << convex_diameter(g) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\nusing Point = complex< double >;\n\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble radian_to_degree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble degree_to_radian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() {}\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(double A, double B, double C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() {}\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle() {}\n\n  Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\ndouble cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\nbool parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ndouble distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\ndouble distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point hp = projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return {hp - v, hp + v};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\nbool merge_if_able(Segment &s1, Segment s2) {\n  if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid merge_segments(vector< Segment > &segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon convex_cut(Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble area2(const Polygon &p) {\n  double A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble convex_diameter(Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\ndouble closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n\n  function< double(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return 1e18;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\n\nint main() {\n  int N;\n  cin >> N;\n  Polygon p(N);\n  for(auto &q: p) cin >> q;\n  cout << fixed << setprecision(10) << convex_diameter(p) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vec;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\ndouble eps=1e-8;\ndouble PI=acos(-1);\n\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\n\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\n\ndouble calcArea(vec &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++)res+=cross(t[i],t[(i+1==n?0:i+1)]);\n  return abs(res/2.0);\n}\n\ndouble Arg(P a,P b,P c){\n  b-=a,c-=a;\n  return arg(c*conj(b));\n}\n\nint inPolygon(vec &t,P p){\n  int n=t.size();\n  double sum=0;  \n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p) == 0 )return 1;// on\n    sum+= Arg(p,a,b);\n  }\n  if( abs(sum) < eps )return 0;//out\n  else  return 2;//in\n}\n\ntypedef pair<double,P> Pair;\nvec ConvexHull(vec t){\n  vector<Pair> u;\n  vec R;\n  int N=t.size(),K=0,C=0;\n  for(int i=1;i<N;i++)if(t[i]<t[K])K=i;\n  for(int i=0;i<N;i++)u.push_back(Pair(arg(t[i]-t[K]),t[i]));\n  R.push_back(t[K]),C++;\n  sort(u.begin(),u.end());\n  for(int i=0;i<N;i++){\n    P p=u[i].second;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==0)continue;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==2)continue;\n    while(2<=C&&ccw(R[C-2],R[C-1],p)!=1)R.pop_back(),C--;\n    R.push_back(p),C++;    \n  }\n  return R;\n}\n\nvec cutConvex(vec &t,P a,P b){\n  int N=t.size();\n  vec res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C+D==0&&max(C,D)==1)res.push_back(intersect(a,b,c,d));\n  }\n  return res;\n}\n\ndouble maxDist(vec &t){\n  vec u=ConvexHull(t);\n  int N=u.size(),K=0;\n  double res=0;\n  for(int i=0;i<N;i++){\n    while(abs(u[i]-u[K])<abs(u[i]-u[(K+1)%N]))K=(K+1)%N;\n    res=max(res,abs(u[i]-u[K]));\n  }\n  return res;\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  vec t;\n  double x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  printf(\"%.8f\\n\",maxDist(t));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ntypedef Point Vector;\n\nVector normal(Point p0, Point p1); //ベクトルp0p1の法線ベクトル\nint argmax(const vector<double> &v); //std::vectorのargmax関数\n\nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int n;\n    cin >> n;\n    vector<Point> data(n);\n\n    for(int i=0; i<n; i++){\n        cin >> data[i].x >> data[i].y;\n    }\n\n    Point p0, p1;\n    Vector nv;\n    vector<double> xNormalNoDup(0);\n    vector<Vector> normalVector(0);\n    xNormalNoDup.reserve(n);\n    normalVector.reserve(n);\n    map<double, int> isSwitchVertex;\n\n    for(int i=0; i<n; i++){\n        p0 = data[i];\n        p1 = data[(i+1)%n];\n        nv = normal(p0, p1);\n        normalVector.push_back(nv);\n        if (nv.y > 0 || nv.x == 1) isSwitchVertex[ nv.x ] += 1;\n        else isSwitchVertex[ -nv.x ] -= 1;\n    }\n\n    //Extract keys of isSwitchVertex and sort\n    for(map<double,int>::iterator it = isSwitchVertex.begin(); it != isSwitchVertex.end(); ++it) {\n        xNormalNoDup.push_back(it->first);\n    }\n    sort(xNormalNoDup.begin(), xNormalNoDup.end());\n\n    //find the first pair\n    int pairIndex0 = -1; //upside\n    int pairIndex1 = -1; //downside\n    Vector nv0, nv1;\n    for(int i=0; i<n; i++){\n        nv0 = normalVector[i];\n        nv1 = normalVector[(i+1)%n];\n        if( nv0.y<0 && nv1.y>=0 ) pairIndex0 = (i+1)%n;\n        if( nv0.y>=0 && nv1.y<0 ) pairIndex1 = (i+1)%n;\n    }\n    if(pairIndex0<0 || pairIndex1<0) cout << \"ERROR: Pair Initialization failed.\";\n\n    double maxDiameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n    double diameter = 0;\n\n    for(int i=0; i<xNormalNoDup.size(); i++){\n        switch( isSwitchVertex[ xNormalNoDup[i] ] ) {\n            case 1:  pairIndex0 += 1;\n                     break;\n            case -1: pairIndex1 += 1;\n                     break;\n            case 0:  pairIndex0 += 1;\n                     pairIndex1 += 1;\n                     break;\n            default: cout << \"Error: Next pair not found.\" << endl;\n                     break;\n        }\n        diameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n        maxDiameter = (diameter > maxDiameter)? diameter: maxDiameter;\n    }\n\n    cout << setprecision(13) << maxDiameter << endl;\n\n    return 0;\n}\n\nVector normal(Point p0, Point p1){\n    Vector nv;\n    nv.x = - ( p1.y - p0.y );\n    nv.y = p1.x - p0.x;\n    double a = nv.abs();\n    return nv / a;\n}\n\nint argmax(const vector<double> &v){\n    return distance(v.begin(), max_element(v.begin(), v.end()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nnamespace geometry2d {\n\n\t//eps　浮動小数点誤差\n\tconst double EPS = 1e-10;\n\n\t//a > 0ならば+1, a == 0ならば0, a < 0ならば-1　を返す。　基本的にEPS込みの評価はこれで行う。\n\t//不等式は、加減算に直してこれに適用する。\n\tint sgn(const double a) {\n\t\treturn (a < -EPS ? -1 : (a > EPS ? +1 : 0));\n\t}\n\n\tstruct Point {\n\t\t//2次元ベクトルのクラス\n\n\t\tdouble x, y;\n\t\tPoint(double _x, double _y) {\n\t\t\tx = _x, y = _y;\n\t\t}\n\t\tPoint() {\n\t\t\tx = 0, y = 0;\n\t\t}\n\n\t\tPoint operator+() const {\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator-() const {\n\t\t\treturn{ -x, -y };\n\t\t}\n\t\tPoint operator+ (const Point& b) const {\n\t\t\treturn{ x + b.x, y + b.y };\n\t\t}\n\t\tPoint operator- (const Point& b) const {\n\t\t\treturn{ x - b.x, y - b.y };\n\t\t}\n\t\tPoint operator* (const double b) const {\n\t\t\treturn{ x * b, y * b };\n\t\t}\n\t\tPoint operator/ (const double b) const {\n\t\t\treturn{ x / b, y / b };\n\t\t}\n\t\tPoint operator+= (const Point& b) {\n\t\t\tx += b.x, y += b.y;\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator-= (const Point& b) {\n\t\t\tx -= b.x, y -= b.y;\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator*= (const double b) {\n\t\t\tx *= b, y *= b;\n\t\t\treturn *this;\n\t\t}\n\t\tPoint operator/= (const double b) {\n\t\t\tx /= b, y /= b;\n\t\t\treturn *this;\n\t\t}\n\t\tbool operator== (const Point& b) {\n\t\t\treturn b.x == x && b.y == y;\n\t\t}\n\n\t\tdouble lengthSquare() const {\n\t\t\treturn (x * x + y * y);\n\t\t}\n\t\tdouble length() const {\n\t\t\treturn std::sqrt(lengthSquare());\n\t\t}\n\t\tdouble dot(const Point& b) const {\n\t\t\treturn x * b.x + y * b.y;\n\t\t}\n\t\tdouble cross(const Point& b) const {\n\t\t\t//Generally, cross product is vector, but in 2D, cross product is also scalar.\n\t\t\treturn x * b.y - y * b.x;\n\t\t}\n\t\tdouble distanceFrom(const Point& b) const {\n\t\t\treturn std::sqrt((x - b.x) * (x - b.x) + (y - b.y) * (y - b.y));\n\t\t}\n\t\tPoint normalized() const {\n\t\t\treturn{ x / length(), y / length() };\n\t\t}\n\t\tbool isZero() const {\n\t\t\treturn sgn(x) == 0 && sgn(y) == 0;\n\t\t}\n\t\t//単位法線ベクトル\n\t\tPoint normalUnitVector() const {\n\t\t\treturn{ -normalized().y, normalized().x };\n\t\t}\n\t\t//(0, 0)中心にarg(弧度法)回転した座標\n\t\tPoint rotation(double arg) const {\n\t\t\tdouble cs = cos(arg), sn = sin(arg);\n\t\t\treturn Point(x * cs - y * sn, x * sn + y * cs);\n\t\t}\n\t\t//(0, 0)中心の円上に乗ってるとしたときの、偏角\n\t\tdouble angle() const {\n\t\t\treturn atan2(y, x);\n\t\t}\n\t};\n\n\tinline Point operator*(double a, const Point& b) {\n\t\treturn{ b.x * a, b.y * a };\n\t}\n\n\ttemplate <class Char>\n\tinline std::basic_ostream<Char>& operator <<(std::basic_ostream<Char>& os, const Point& v)\n\t{\n\t\treturn os << Char('(') << v.x << Char(',') << v.y << Char(')');\n\t}\n\n\ttemplate <class Char>\n\tinline std::basic_istream<Char>& operator >> (std::basic_istream<Char>& is, Point& v)\n\t{\n\t\treturn is >> v.x >> v.y;\n\t}\n\n\t//幾何ライブラリにおいて、解なしのような状態の時に返される点の値\n\tconst Point error_val = { 114514.0, -191981.0 };\n\n\tinline bool operator==(const Point& a, const Point& b) {\n\t\treturn (sgn(a.x - b.x) == 0 && sgn(a.y - b.y) == 0);\n\t}\n\n\t//第一にx, 第二にyを小さい順にソートするためのオーバーロード\n\tinline bool operator<(const Point& a, const Point& b) {\n\t\tif (sgn(a.x - b.x) != 0)return sgn(a.x - b.x) < 0;\n\t\telse return sgn(a.y - b.y) < 0;\n\t}\n\n\t/*\n\t3点A, B, Cの位置関係を返す関数 A, Bがすべて異なった点であるのが前提\n\t//ABから見てBCは左に曲がるのなら +1\n\t//ABから見てBCは右に曲がるのなら -1\n\t//ABC(CBA)の順番で一直線上に並ぶなら +2\n\t//ACB(BCA)の順番で一直線上に並ぶなら 0\n\tBAC(CAB)の順番で一直線上に並ぶなら -2\n\t*/\n\tint iSP(const Point& a, const Point& b, const Point& c) {\n\t\tint flg = sgn((b - a).cross(c - a));\n\t\tif (flg == 1) {\n\t\t\treturn +1;\n\t\t}\n\t\telse if (flg == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\t//ABC(CBA)\n\t\t\tif (sgn((b - a).dot(c - b)) > 0)\n\t\t\t\treturn +2;\n\t\t\t//BAC(CAB)\n\t\t\telse if (sgn((a - b).dot(c - a)) > 0)\n\t\t\t\treturn -2;\n\t\t\t//ACB(BCA)　CがA or Bと一致しても、こっちに含まれる。\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t//直線に関する操作や判定\n\tnamespace line2d {\n\n\t\t//向きつき直線を想定。Segment\n\t\tstruct Line {\n\n\t\t\t//直線の通る二点。有向直線でないのならば、beginやendに違いはない。\n\t\t\tPoint begin, end;\n\n\t\t\tLine() {\n\t\t\t\tbegin = Point(), end = Point();\n\t\t\t}\n\n\t\t\tLine(const Point& b, const Point& e) {\n\t\t\t\tbegin = b, end = e;\n\t\t\t}\n\n\t\t\t//ax+by+c=0\n\t\t\tLine(const double a, const double b, const double c) {\n\t\t\t\tif (sgn(a) == 0 && sgn(b) == 0) {\n\t\t\t\t\tassert(-1);\n\t\t\t\t}\n\n\t\t\t\tif (sgn(b) == 0) {\n\t\t\t\t\t//ax+c=0になる。\n\t\t\t\t\tbegin = Point(-c / a, 0.0);\n\t\t\t\t\tend = Point(-c / a, 1.0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//y=-(ax+c)/b　傾きは-a/bで、y切片が-c/b\n\t\t\t\t\tbegin = Point(0, -c / b);\n\t\t\t\t\tend = Point(1.0, -(a + c) / b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPoint vec() const {\n\t\t\t\treturn end - begin;\n\t\t\t}\n\n\t\t\tPoint countervec() const {\n\t\t\t\treturn begin - end;\n\t\t\t}\n\n\t\t};\n\n\n\t\t//線分の場合、Lineと同じものになるが、はっきりと区別する\n\t\ttypedef Line Segment;\n\n\n\t\t//直線の交点を返す。交わってなければ、error_valを返す。\n\t\tPoint lineIntersection(const Line& l1, const Line& l2) {\n\t\t\tif (sgn(l1.vec().cross(l2.vec())) == 0)return error_val;\n\n\t\t\tPoint ret;\n\t\t\tret = l1.begin + l1.vec() *\n\t\t\t\tabs((l2.end - l1.begin).cross(l2.vec()) / l1.vec().cross(l2.vec()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t//線分が共通部分を持つかどうか？と線分の交点を返す。共通部分がない、もしくは交点が一意ではないなら、error_valを返す。\n\t\t//trueなら、共通部分を持つ。falseなら、共通部分を持たない。\n\t\tpair<bool, Point> segmentIntersection(const Segment& s1, const Segment& s2) {\n\n\t\t\tif (iSP(s1.begin, s1.end, s2.begin) * iSP(s1.begin, s1.end, s2.end) <= 0 &&\n\t\t\t\tiSP(s2.begin, s2.end, s1.begin) * iSP(s2.begin, s2.end, s1.end) <= 0) {\n\n\t\t\t\t//平行ならば、交点は定まらない。(完全に重なってるので)\n\t\t\t\tif (s1.vec().cross(s2.vec()) == 0)\n\t\t\t\t\treturn make_pair(true, error_val);\n\t\t\t\telse //そうでないのなら、lineIntersection()で交点を返しておく。\n\t\t\t\t\treturn make_pair(true, lineIntersection(s1, s2));\n\n\t\t\t}\n\t\t\treturn make_pair(false, error_val);\n\t\t}\n\n\n\t\t//点と直線の距離。引数は、点、直線上の2点\n\t\tdouble distanceBetweenPointAndLine(const Point& p, const Line& l) {\n\t\t\treturn abs(l.vec().cross(p - l.begin) / l.vec().length());\n\t\t}\n\n\t\t//点と線分の距離。引数は、点、線分の両端\n\t\tdouble distanceBetweenPointAndSegment(const Point& p, const Segment& s) {\n\t\t\tif (sgn(s.vec().dot(p - s.begin)) < 0 || sgn(s.countervec().dot(p - s.end)) < 0) {\n\t\t\t\t//下した垂線は線分の上にはない\n\t\t\t\treturn min(p.distanceFrom(s.begin), p.distanceFrom(s.end));\n\t\t\t}\n\t\t\treturn distanceBetweenPointAndLine(p, s);\n\t\t}\n\n\t\t//二線分間の距離\n\t\tdouble distanceBetweenSegmentAndSegment(const Segment& s1, const Segment& s2) {\n\t\t\tif (segmentIntersection(s1, s2).first)return 0;//交点を持つ\n\n\t\t\tdouble ans = distanceBetweenPointAndSegment(s1.begin, s2);\n\t\t\tans = min(ans, distanceBetweenPointAndSegment(s1.end, s2));\n\t\t\tans = min(ans, distanceBetweenPointAndSegment(s2.begin, s1));\n\t\t\tans = min(ans, distanceBetweenPointAndSegment(s2.end, s1));\n\t\t\treturn ans;\n\t\t}\n\n\t\t//正射影\n\t\t//引数は点A, B, Cで、BAベクトルの直線BC上の正射影を求める。\n\t\tPoint projection(const Point& a, const Line& l) {\n\t\t\tPoint ret;\n\t\t\tret = l.begin +\n\t\t\t\tl.vec().normalized() * (a - l.begin).dot(l.vec()) / l.vec().length();\n\t\t\treturn ret;\n\t\t}\n\n\t\t//鏡映変換。引数は点A, B, Cで、直線BCにおいて、Aと線対称な点を求める。\n\t\tPoint reflection(const Point& a, const Line& l) {\n\t\t\tPoint ret;\n\t\t\tret = a + 2 * (projection(a, l) - a);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tnamespace circle2d {\n\n\t\tstruct Circle {\n\t\t\tPoint o;\n\t\t\tdouble r;\n\n\t\t\tCircle() {\n\t\t\t\to = Point();\n\t\t\t\tr = 0;\n\t\t\t}\n\n\t\t\tCircle(const Point& C, const double& R) {\n\t\t\t\to = C, r = R;\n\t\t\t}\n\t\t};\n\n\t\t//直線と円の交点を返す。\n\t\t//存在しないのならば、空のvectorになる。\n\t\tvector<Point> intersectionCircleAndLine(const Circle& c, const line2d::Line& l) {\n\t\t\t//交点を持たない\n\t\t\tif (sgn(line2d::distanceBetweenPointAndLine(c.o, l) - c.r) > 0) {\n\t\t\t\treturn vector<Point>();\n\t\t\t}\n\t\t\telse if (sgn(line2d::distanceBetweenPointAndLine(c.o, l)) == 0) {\n\t\t\t\t//中心を通るなら\n\t\t\t\tvector<Point> ret;\n\t\t\t\tret.push_back(c.o + l.vec().normalized() * c.r);\n\t\t\t\tret.push_back(c.o - l.vec().normalized() * c.r);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t//垂線の足\n\t\t\t\tPoint H = line2d::projection(c.o, l);\n\t\t\t\tvector<Point> ret;\n\n\t\t\t\tret.push_back(\n\t\t\t\t\tH + (c.o - H).normalUnitVector() *\n\t\t\t\t\tsqrt(max(0.0, pow(c.r, 2) - pow(line2d::distanceBetweenPointAndLine(c.o, l), 2)))\n\t\t\t\t);\n\t\t\t\tret.push_back(\n\t\t\t\t\tH - (c.o - H).normalUnitVector() *\n\t\t\t\t\tsqrt(max(0.0, pow(c.r, 2) - pow(line2d::distanceBetweenPointAndLine(c.o, l), 2)))\n\t\t\t\t);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t//線分と円の交点を返す。1つ目のbool値は,trueなら交わっている。\n\t\t//交点はたかだか2つであり、1つしか交点を持たない場合は同じものを2つ返す。\n\t\tvector<Point> intersectionCircleAndSegment(const Circle& c, const line2d::Segment& s) {\n\t\t\tauto tmp = intersectionCircleAndLine(c, s);\n\t\t\tvector<Point> ret;\n\t\t\tfor (int i = 0; i < tmp.size(); i++) {\n\t\t\t\tif (sgn(line2d::distanceBetweenPointAndSegment(tmp[i], s)) == 0)\n\t\t\t\t\tret.push_back(tmp[i]);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*2つの円の位置関係を返す。交点を持つのなら、その交点も返す。\n\t\t1つ目のintの意味は下の通り\n\t\t円AがBを内包してる。+1\n\t\t円BがAを内包してる。-1\n\t\t円AとBは内接してる。0\n\t\t円AとBは2つの交点を持つ。+2\n\t\t円AとBは外接してる。+3\n\t\t円AとBは交わらない+4\n\t\t交点が存在しないのなら、error_val2つが返される。\n\t\t*/\n\t\tpair<int, vector<Point>> intersectionCircleAndCircle(const Circle& c1, const Circle& c2) {\n\t\t\tPoint d = c2.o - c1.o;\n\t\t\tvector<Point> ret;\n\t\t\tint mode;\n\n\t\t\t//遠すぎて交点を持たない or　内包してる\n\t\t\tif (sgn(d.length() - c1.r - c2.r) > 0 || sgn(d.length() - abs(c1.r - c2.r)) < 0) {\n\t\t\t\tif (sgn(d.length() - c1.r - c2.r) > 0)mode = +4;\n\t\t\t\telse {\n\t\t\t\t\tif (sgn(c1.r - c2.r) > 0)mode = +1;\n\t\t\t\t\telse mode = -1;\n\t\t\t\t}\n\t\t\t\treturn make_pair(mode, ret);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sgn(d.length() - c1.r - c2.r) == 0)mode = +3;\n\t\t\t\telse if (sgn(d.length() - (c1.r + c2.r)) < 0 &&\n\t\t\t\t\tsgn(d.length() - abs(c1.r - c2.r)) > 0)mode = +2;\n\t\t\t\telse mode = 0;\n\t\t\t}\n\t\t\tdouble AH = (pow(c1.r, 2) - pow(c2.r, 2) + d.lengthSquare()) / (2.0 * d.length());\n\t\t\tdouble CH = sqrt(max(0.0, pow(c1.r, 2) - pow(AH, 2)));\n\n\t\t\tret.push_back(c1.o + d.normalized() * AH + d.normalUnitVector() * CH);\n\t\t\tif (mode != 0 && mode != +3)\n\t\t\t\tret.push_back(c1.o + d.normalized() * AH - d.normalUnitVector() * CH);\n\t\t\treturn make_pair(mode, ret);\n\t\t}\n\n\t\t//与えられた点を通る円の接線の円上の点を(2つ)返す。接する場合は同じのを2つ返す。\n\t\t//円の内部に点があるのなら、error_valを2つ返す。\n\t\tvector<Point> tangentToCircle(const Point& p, const Circle& c) {\n\t\t\tif (sgn(c.o.distanceFrom(p) - c.r) < 0) {\n\t\t\t\t//円の内部にある\n\t\t\t\treturn vector<Point>();\n\t\t\t}\n\t\t\treturn intersectionCircleAndCircle(c,\n\t\t\t\tCircle(p,\n\t\t\t\t\tsqrt(max(0.0, (p - c.o).lengthSquare() - pow(c.r, 2))))\n\t\t\t).second;\n\t\t}\n\n\t\tvector<geometry2d::line2d::Line> tangentBetweenCircleAndCircle(const Circle& c1, const Circle& c2) {\n\t\t\tvector<geometry2d::line2d::Line> ret;\n\t\t\tif (sgn(abs(c1.r - c2.r) - (c1.o - c2.o).length()) > 0) {\n\t\t\t\t//包含関係にある\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdouble d = (c1.o - c2.o).length();\n\t\t\tfor (double s : {-1.0, 1.0}) {\n\t\t\t\t//外接or内接してるのなら\n\t\t\t\tif (d == abs(c1.r + c2.r * s)) {\n\t\t\t\t\tgeometry2d::line2d::Line tmp;\n\t\t\t\t\ttmp.begin = c1.o +\n\t\t\t\t\t\t(sgn(c1.r + c2.r * s) >= 0 ?\n\t\t\t\t\t\t(c2.o - c1.o).normalized() * c1.r :\n\t\t\t\t\t\t\t(c1.o - c2.o).normalized() * c1.r\n\t\t\t\t\t\t\t);\n\t\t\t\t\ttmp.end = tmp.begin + (c2.o - c1.o).normalUnitVector();//適当にその向きでもう1点を取ってる\n\t\t\t\t\tret.push_back(tmp);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\telse if (sgn(d - (c1.r + c2.r * s)) > 0) {\n\t\t\t\t\tdouble cs = (c1.r + c2.r * s) / d;//cos\n\t\t\t\t\tdouble sn = sqrt(max(0.0, 1 - cs * cs));//sin\n\t\t\t\t\tPoint U = (c2.o - c1.o).normalized(), V = U.normalUnitVector();\n\t\t\t\t\tU *= cs, V *= sn;\n\t\t\t\t\tgeometry2d::line2d::Line tmp1, tmp2;\n\t\t\t\t\ttmp1 = geometry2d::line2d::Line(c1.o + (U + V) * c1.r, c2.o - (U + V) * c2.r * s);\n\t\t\t\t\ttmp2 = geometry2d::line2d::Line(c1.o + (U - V) * c1.r, c2.o - (U - V) * c2.r * s);\n\t\t\t\t\tret.push_back(tmp1), ret.push_back(tmp2);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tnamespace polygon2d {\n\t\t\n\t\ttypedef vector<Point> Polygon;//リネーム\n\n\t\t//点集合から凸包を作る。参照渡しをする。\n\t\t//凸包の頂点にならない点も含む->f==true\n\t\t//反時計回りとなってる。\n\t\tvector<Point> convexHull(vector<Point>& p, bool f) {\n\n\t\t\t\n\t\t\tsort(p.begin(), p.end());\n\t\t\t\n\t\t\tvector<Point> ret(2 * p.size());\n\t\t\tint k = 0;//凸包のサイズ\n\t\t\t\n\t\t\t//下側凸包の構築\n\t\t\tfor (int i = 0; i < p.size(); i++) {\n\t\t\t\twhile (k > 1 &&\n\t\t\t\t\t((!f && iSP(ret[k - 2], ret[k - 1], p[i]) != +1) ||\n\t\t\t\t\t(f && iSP(ret[k - 2], ret[k - 1], p[i]) == -1)))k--;\n\t\t\t\tret[k] = p[i];\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\t//上側凸包の構築\n\t\t\tfor (int i = p.size() - 2, t = k; i >= 0; i--) {\n\t\t\t\twhile (k > t &&\n\t\t\t\t\t((!f && iSP(ret[k - 2], ret[k - 1], p[i]) != +1) ||\n\t\t\t\t\t(f && iSP(ret[k - 2], ret[k - 1], p[i]) == -1)))k--;\n\t\t\t\tret[k] = p[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tret.resize(k - 1);//最後の戻った始点のWカウント防止\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<geometry2d::Point> p(N);\n\t//問題の制約的に、yの値をxの値より優先的に判定する。\n\t//ゆえに、この問題はconvexHull()関数内で、違う方法でソートする。\n\t\n\tfor (int i = 0; i < N; i++)cin >> p[i];\n\n\tauto ret = geometry2d::polygon2d::convexHull(p, true);\n\n\tint left = 0, right = 1;\n\tN = ret.size();\n\tdouble ans = 0, now = 0;\n\tfor (; left < N; left++) {\n\t\t//[left, right)\n\t\t//今のright-1番目の頂点の1つ後にしたら、より距離が遠くなるならば、進める\n\t\twhile (right < N + left && geometry2d::sgn(now - ret[left].distanceFrom(ret[right % N])) < 0) {\n\t\t\tnow = ret[left].distanceFrom(ret[right % N]);\n\t\t\tans = max(ans, now);\n\t\t\tright++;\n\t\t}\n\t\tif (left == right)right++;\n\t\telse {\n\t\t\tif (left < N - 1) {\n\t\t\t\tnow = ret[left + 1].distanceFrom(ret[(right - 1) % N]);\n\t\t\t\tans = max(ans, now);\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n \nusing namespace std;\n \ntypedef long long lint;\n \n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n \n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n \n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n \nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n \nbool neq(double a, double b) //a != b\n{\n    return (!eq(a, b));\n}\n   \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n   \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n   \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n   \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n \nclass Point{\npublic:\n    double x, y;\n    Point(double x = 0, double y = 0): x(x), y(y){}\n    Point operator + (Point p){return Point(x + p.x, y + p.y);}\n    Point operator - (Point p){return Point(x - p.x, y - p.y);}\n    Point operator * (double a){return Point(x * a, y * a);}\n    Point operator / (double a){return Point(x / a, y / a);}\n    Point operator * (const Point &a){\n        return Point(x * a.x - y * a.y, x * a.y + y * a.x);\n    }\n    bool operator < (const Point &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const Point &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n \ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n \ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint baseP;\nbool sortT(Point a, Point b){\n\treturn (gt(cross(a - baseP, b - baseP), 0));\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n    if (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n    if (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n    if (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n    return (0); //p0--p2--p1 の順で一直線上\n}\n \nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    baseP = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n \nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n       \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n   \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n   \n    qs.resize(k - 1);\n    return (qs);\n}\n \ndouble getArea(Polygon t){\n    double ans = 0.0;\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n \nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n    return (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n        abs(cross(p2 - p1, p4 - p1)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n    return (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n    return (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n    return (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n    return (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n    return (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n \nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n    double t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n    return (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n    return (p3 + (projection(p1, p2, p3) - p3) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n    return (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n    return (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n    return (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n    Point r = projection(s1, s2, p);\n    if (isIntersectSP(s1, s2, r)) return (abs(r - p));\n    return (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n    if (isIntersectSS(s1, s2, t1, t2)) return (0);\n    return (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n            min(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n    double d = cross(a2 - a1, b2 - b1);\n    if (abs(d) < EPS) throw \"Segment is Paralell!\";\n    Point a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n    vector<Point> res;\n    if (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n    double d = abs(c1 - c2);\n    double rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n    double rs = sqrt(r1 * r1 - rc * rc);\n    Point diff = (c2 - c1) / d;\n    res.push_back(Point(c1 + diff * Point(rc, rs)));\n    res.push_back(Point(c1 + diff * Point(rc, -rs)));\n    return (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n    vector<Point> res;\n    double dist = distanceLP(b1, b2, a);\n    if (leq(dist, ra)){\n        Point s = projection(b1, b2, a);\n        dist = sqrt(ra * ra - dist * dist);\n        Point t = (b2 - b1) / abs(b2 - b1);\n        res.push_back(s + t * dist);\n        res.push_back(s - t * dist);\n    }\n    return (res);\n}\n \nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n \nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n   \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n   \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n   \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n \nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n \nint main()\n{\n    int n;\n     \n    scanf(\"%d\", &n);\n    Polygon p(n);\n    for (int i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n    }\n    \n\tp = conhel(p);\n\tdouble ans = 0;\n\tfor (int i = 0; i < p.size(); i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tans = max(ans, abs(p[i], p[j]));\n\t\n\tprintf(\"%.10lf\\n\", ans);\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\ndouble cross(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\ndouble dist(const Point &p1, const Point &p2)\n{\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint main()\n{\n    int i, n;\n    double *X, *Y;\n    scanf(\"%d\", &n);\n    assert(n >= 3);\n\n    X = new double [n + 1];\n    Y = new double [n + 1];\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &X[i], &Y[i]);\n    }\n    X[n] = X[0], Y[n] = Y[0];\n    Point *Plg;\n    Plg = new Point [n + 1];\n    for(i = 0; i < n; i++){\n        Plg[i] = set_p(X[i], Y[i]);\n    }\n    Plg[n] = Plg[0];\n\n    int top = 1;\n    double diam = 0;\n\n    for(i = 0; i < n; i++){\n        while(cross(set_v(Plg[i], Plg[i + 1]), set_v(Plg[top], Plg[top + 1])) > 0){\n            top++; if(top > n - 1) top -= n;\n        };\n        diam = max(diam, max(dist(Plg[i], Plg[top]), dist(Plg[i + 1], Plg[top])));\n    }\n    printf(\"%lf\\n\", diam);\n    cin >> n;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P p;R c;};\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tint n=pol.size(),i=0,j=0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\tR res=0.0;\n\tauto cmp_x=[](P a,P b)->bool{return sgn(real(a)-real(b))?sgn(real(a)-real(b))<0:sgn(imag(a)-imag(b)<0);};\n\t\n\trep(k,n){\n\t\tif(!cmp_x(pol[i],pol[k]))i=k;\n\t\tif(cmp_x(pol[j],pol[k]))j=k;\n\t}\n\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tchmax(res,abs(pol[i]-pol[j]));\n\t\tif(sdet(O,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j])<0)\n\t\t\ti=(i+1)%n;\n\t\telse \n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\npair<int, int> convexDiameter(const vector<P> &ps) {\n    int n = ps.size();\n    int i = min_element(ps.begin(), ps.end()) - ps.begin();\n    int j = max_element(ps.begin(), ps.end()) - ps.begin();\n    int maxI, maxJ;\n    double maxD = 0;\n    rep(_, 0, 2*n) {\n        if(maxD < norm(ps[i] - ps[j])) {\n            maxD = norm(ps[i] - ps[j]);\n            maxI = i;\n            maxJ = j;\n        }\n        if(cross(ps[i] - ps[(i+1) % n], ps[(j+1) % n] - ps[j]) <= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n    }\n    return make_pair(maxI, maxJ);\n}\n\nint main() {\n    int n; cin >> n;\n    vector<P> ps;\n    rep(i,0,n) {\n        P temp; cin >> temp.X >> temp.Y;\n        ps.pb(temp);\n    }\n    pii ans = convexDiameter(ps);\n    printf(\"%.10f\\n\", sqrt(norm(ps[ans.first] - ps[ans.second])));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <utility>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> Point, Vector;\ntypedef pair<Point, Point> Segment, Line;\ntypedef vector<Point> Polygon;\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nnamespace std{\n    bool operator<(const Point &a, const Point &b){\n        return !equals(a.X, b.X) ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\ndouble cross(Vector a, Vector b){\n    return a.X * b.Y - a.Y * b.X;\n}\n\ndouble norm(Vector a){\n    return a.X * a.X + a.Y * a.Y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble convexDiameter(Polygon pol){\n    int n = pol.size();\n    if(n <= 1) return 0;\n    if(n == 2) return abs(pol[0] - pol[1]);\n\n    int i = 0, j = 0;\n    for(int k=0; k<n; k++){\n        if(!(pol[i] < pol[k])) i = k;\n        if(pol[j] < pol[k]) j = k;\n    }\n\n    double diameter = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        diameter = max(diameter, abs(pol[i] - pol[j]));\n        if(cross(pol[(i+1)%n] - pol[i], pol[(j+1)%n] - pol[j]) < -EPS){\n            i = (i + 1) % n;\n        }\n        else{\n            j = (j + 1) % n;\n        }\n    }\n\n    return diameter;\n}\n\nint main(){\n    int n; cin>>n;\n    Polygon pol;\n    for(int i=0; i<n; i++){\n        double x, y; cin>>x>>y;\n        pol.emplace_back(x, y);\n    }\n\n    printf(\"%.10f\\n\", convexDiameter(pol));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(sgn(real(pol[k]-pol[i]))<=0) i=k;\n\t\tif(sgn(real(pol[k]-pol[j]) >0)) j=k;\n\t}\n\tint si=i,sj=j;\n\tR res=0.0;\n\tdo{\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}while(i!=si||j!=sj);\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << std::endl; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) { std::cerr << std::boolalpha << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); std::cerr << std::noboolalpha; }\n#else\n\t#define debug(...) {}\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\ttemplate<typename T> class dvector : public std::vector<T> {\n\tpublic:\n\t\tdvector() : std::vector<T>() {}\n\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\tT& operator[](size_t n) {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t\tconst T& operator[](size_t n) const {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t};\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool &b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector<T>& v) {\n\t\tfor (int i = 0, len = v.size(); i < len; ++i){ s << v[i]; if (i < len - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector< dvector<T> >& vv) {\n\t\tfor (int i = 0, len = vv.size(); i < len; ++i){ s << vv[i] << std::endl; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\" << std::endl; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << std::endl; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) { \n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(vector<T> &v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T &a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(vector<T> &v) { v.erase(unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\n//doubleにおける == 判定\ninline double equals(double a,double b){ return fabs(a-b)<EPS; }\n\n//点、ベクトル\nclass Point {\npublic:\n\tdouble x,y;\n\tPoint(double x=0., double y=0.) : x(x), y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x, y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x, y-p.y);}\n\tPoint operator * (Point p) {return Point(x*p.x, y*p.y);}\n\tPoint operator / (Point p) {return Point(x/p.x, y/p.y);}\n\tPoint operator + (double n) {return Point(x+n, y+n);}\n\tPoint operator - (double n) {return Point(x-n, y-n);}\n\tPoint operator * (double n) {return Point(x*n, y*n);}\n\tPoint operator / (double n) {return Point(x/n, y/n);}\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x!=p.x ? x<p.x : y<p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n\t\n};\nusing Vector = Point;\nstd::ostream& operator<<(std::ostream& s, const Point& p) {\n\treturn s << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\n//線分、直線\nclass Segment {\npublic:\n\tPoint p1,p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2) {}\n\tbool operator == (const Segment &p) const {\n\t\treturn p1==p.p1 && p2==p.p2;\n\t}\n};\nusing Line = Segment;\nstd::ostream& operator<<(std::ostream& s, const Segment& se) {\n\treturn s << \"(\" << se.p1 << \", \" << se.p2 << \")\";\n}\n\n//点を回転させる\n//角度radはラジアンで指定すること\nVector rotate(Vector a, double rad){\n\treturn Vector(a.x*cos(rad)-a.y*sin(rad), a.x*sin(rad)+a.y*cos(rad));\n}\n//90度左回転させたベクトルを返す\nVector rotate90(Vector a){\n\treturn Vector(-a.y, a.x);\n}\n//180度回転させたベクトルを返す\nVector rotate180(Vector a){\n\treturn Vector(-a.x, -a.y);\n}\n//ベクトルの内積\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n//ベクトルの外積\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n//ベクトルa,bの角度を[0, π]の範囲で返す\ndouble angle(Vector a,Vector b){\n\treturn acos(dot(a,b)/a.abs()/b.abs());\n}\n//直交判定\nbool isOrthogonal(Vector a,Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n\treturn isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n\treturn equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n//平行判定\nbool isParallel(Vector a,Vector b){\n\treturn equals(cross(a,b), 0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n\treturn isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n\treturn equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n//射影\nPoint project(Segment s,Point p){\n\tVector base = s.p2-s.p1;\n\tdouble r = dot(p-s.p1, base)/base.norm();\n\treturn base*r + s.p1;\n}\n//反射\nPoint reflect(Segment s,Point p){\n\treturn p + (project(s,p)-p)*2;\n}\n\n//p0,p1,p2が反時計回りになる\nstatic constexpr int COUNTER_CLOCKWISE = 1;\n//p0,p1,p2が時計回りになる\nstatic constexpr int CLOCKWISE = -1;\n//p2,p0,p1がこの順で同一直線上にある\nstatic constexpr int ONLINE_BACK = 2;\n//p0,p1,p2がこの順で同一直線上にある\nstatic constexpr int ONLINE_FRONT = -2;\n//p2が線分p0p1上にある\nstatic constexpr int ON_SEGMENT = 0;\n/*\n\t\t\t\t\tCOUNTER_CLOCKWISE\n\n ONLINE_BACK -- [p0 -- ON_SEGMENT -- p1] --- ONLINE_FRONT\n\n\t\t\t\t\t\tCLOCKWISE\n*/\nint ccw(Point p0, Point p1, Point p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b)<-EPS)return CLOCKWISE;\n\tif(dot(a,b)<-EPS)return ONLINE_BACK;\n\tif(a.norm()<b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\n//端点が他方の線分上にある場合、線分二つが平行に重なる場合も交差しているとみなす\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//二点間の距離\ndouble getDistance(Point a,Point b){\n\treturn (a-b).abs();\n}\n//点と直線の距離\ndouble getDistanceLP(Line l,Point p){\n\treturn fabs(cross(l.p2-l.p1, p-l.p1)) / (l.p2-l.p1).abs();\n}\n//点と線分の距離\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(s.p2-s.p1, p-s.p1)<0.)return (p-s.p1).abs();\n\tif(dot(s.p1-s.p2, p-s.p2)<0.)return (p-s.p2).abs();\n\treturn getDistanceLP(s,p);\n}\n//線分と線分の距離\ndouble getDistance(Segment s1,Segment s2){\n\tif(intersect(s1,s2))return 0.;\n\treturn min({getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2), getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2)});\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2-s2.p1;\n\tdouble d1=fabs(cross(base, s1.p1-s2.p1));\n\tdouble d2=fabs(cross(base, s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+(s1.p2-s1.p1)*t;\n}\n\n//円\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\t//c:中心の点、r=半径\n\tCircle(Point c=Point(), double r=0.) : c(c), r(r) {}\n\tbool operator == (const Circle &circle) const {\n\t\treturn c==circle.c && fabs(r-circle.r)<EPS;\n\t}\n};\nstd::ostream& operator<<(std::ostream& s, const Circle& c) {\n\treturn s << \"(c = \" << c.c << \", r = \" << c.r << \")\";\n}\n\n//円cと線分lの交点の数を返す\nint hasCrossPoints(Circle c, Line l){\n\tdouble dis = getDistanceLP(l,c.c);\n\tif(equals(dis,c.r))return 1;\n\tif(dis < c.r)return 2;\n\treturn 0;\n}\n//円cと線分lの交点を返す\npair<Point,Point> getCrossPoints(Circle c, Line l){\n\tassert(getDistanceLP(l,c.c) < c.r+EPS);\n\tVector pr=project(l, c.c);\n\tVector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n\tdouble base=sqrt(c.r*c.r-(pr-c.c).norm());\n\treturn {pr+e*base, pr-e*base};\n}\n\n\n//ベクトルpとx軸との角度を返す 返却値の範囲[-π, π]\ninline double arg(Vector p){ return atan2(p.y, p.x); }\ninline double arg(Line l){ return arg(Point(l.p1.x-l.p2.x, l.p1.y-l.p2.y)); }\n//大きさa, x軸との角度rのベクトルを返す\ninline Vector polar(double a, double r){ return Point(cos(r)*a, sin(r)*a); }\n//円c1と円c2の交点を返す\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n\tassert(getDistance(c1.c,c2.c) < c1.r+c2.r+EPS);\n\tdouble d = (c1.c-c2.c).abs();\n\tdouble a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(c1.r*d*2.));\n\tdouble t = arg(c2.c-c1.c);\n\treturn {c1.c+polar(c1.r,t+a), c1.c+polar(c1.r,t-a)};\n}\n\nusing Polygon = vector<Point>;\n//多角形gと点pの内包関係を返す\nstatic constexpr int INSIDE = 2;\nstatic constexpr int ONLINE = 1;\nstatic constexpr int OUTSIDE = 0;\nll contains(Polygon &g, Point p){\n\tll n=g.size();\n\tbool x=false;\n\tfor(ll i=0; i<n; i++){\n\t\tPoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return ONLINE;\n\t\tif(a.y > b.y) swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x=!x;\n\t}\n\treturn (x ? INSIDE : OUTSIDE);\n}\n\n//点の集合sに対する凸包を返す \nPolygon andrewScan(Polygon &s){\n\tPolygon u,l;\n\tif(s.size()<3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(ll i=2; i<(ll)s.size(); i++){\n\t\tfor(ll n=u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor(ll i=s.size()-3; i>=0; i--){\n\t\tfor(ll n=l.size(); n>=2 && ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor(ll i=u.size()-2; i>=1; i--)l.push_back(u[i]);\n\treturn l;\n}\n\n//線分の集合sの交点の数を返す\nclass EndPoint {\npublic:\n\tPoint p;\n\tll seg,st; //入力線分のID, 端点の種類\n\tEndPoint() {}\n\tEndPoint(Point p, ll seg, ll st) : p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint &ep) const {\n\t\tif(p.y == ep.p.y) return st < ep.st;\n\t\treturn p.y < ep.p.y;\n\t}\n};\nvector<Point> manhattanIntersection(vector<Segment> &S){\n\tstatic const int BOTTOM = 0;\n\tstatic const int LEFT = 1;\n\tstatic const int RIGHT = 2;\n\tstatic const int TOP = 3;\n\tll n=S.size();\n\tvector<EndPoint> EP(2*n);\n\tfor(ll i=0,k=0; i<n; i++){\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tif(S[i].p1.x>S[i].p2.x) swap(S[i].p1, S[i].p2);\n\t\t}else if(S[i].p1.y > S[i].p2.y){\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}\n\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tEP[k++]=EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++]=EndPoint(S[i].p2, i, RIGHT);\n\t\t}else{\n\t\t\tEP[k++]=EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++]=EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP.begin(), EP.end());\n\n\tset<ll> BT;\n\tBT.insert(INF);\n\tvector<Point> ans;\n\tfor(ll i=0; i<2*n; i++){\n\t\tif(EP[i].st==TOP){\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}else if(EP[i].st==BOTTOM){\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}else if(EP[i].st==LEFT){\n\t\t\tauto b=BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tauto e=BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tfor(; b!=e; advance(b,1)){\n\t\t\t\tans.push_back(Point(*b,EP[i].p.y));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn ans;\n}\n\n//最小包含円(pointvの点を内部に含む半径最小の円)を返す\n//ハックのあるコンテストではseedに time(0), random_device()() を渡した方がよい\nCircle minimumBoundingCircle(vector<Point> &pointv, ll seed = 2326) {\n\tconst ll n = pointv.size();\n\tassert(n >= 1);\n\tif (n == 1) {\n\t\treturn Circle(pointv[0], 0.);\n\t}\n\n\tstd::mt19937 mt(seed);\n\tstd::shuffle(pointv.begin(), pointv.end(), mt);\n\t// std::random_shuffle(left, right); // simple but deprecated\n\n\tauto make_circle_3 = [](Point &a, Point &b, Point &c) -> Circle {\n\t\tdouble A = (b - c).norm();\n\t\tdouble B = (c - a).norm();\n\t\tdouble C = (a - b).norm();\n\t\tdouble S = cross(b - a, c - a);\n\t\tPoint p = (a * A * (B + C - A) + b * B * (C + A - B)  + c * C * (A + B - C)) / (S * S * 4.);\n\t\tdouble r2 = (p - a).abs();\n\t\treturn Circle(p, r2);\n\t};\n\n\tauto make_circle_2 = [](Point &a, Point &b) -> Circle {\n\t\tPoint c = (a + b) / 2.;\n\t\tdouble r2 = (a - c).abs();\n\t\treturn Circle(c, r2);\n\t};\n\n\tauto in_circle = [](Point &a, Circle &c) -> bool {\n\t\treturn (a - c.c).norm() <= c.r * c.r + EPS;\n\t};\n\n\tCircle c = make_circle_2(pointv[0], pointv[1]);\n\n\t// MiniDisc\n\tfor (ll i = 2; i < n; ++i) {\n\t\tif (!in_circle(pointv[i], c)) {\n\t\t\t// MiniDiscWithPoint\n\t\t\tc = make_circle_2(pointv[0], pointv[i]);\n\t\t\tfor (ll j = 1; j < i; ++j) {\n\t\t\t\tif (!in_circle(pointv[j], c)) {\n\t\t\t\t\t// MiniDiscWith2Points\n\t\t\t\t\tc = make_circle_2(pointv[i], pointv[j]);\n\t\t\t\t\tfor (ll k = 0; k < j; ++k) {\n\t\t\t\t\t\tif (!in_circle(pointv[k], c)) {\n\t\t\t\t\t\t\tc = make_circle_3(pointv[i], pointv[j], pointv[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\n//使うときは closest_pair(points) を呼んでください\n//最近点対(距離が最小の2点)を返す\n//関数適用後、pointsには破壊的操作(y座標によるソート)が行われる点に注意\ntemplate<class iter>\npair<double, pair<Point,Point>> closest_pair_core(iter left, iter right) {\n\t\tll n = distance(left, right);\n\t\tif (n == 1) {\n\t\t\treturn {numeric_limits<double>::max(), {*left, *left}};\n\t\t}\n\t\tif (n == 2) {\n\t\t\tif(left[0].y > left[1].y) swap(left[0], left[1]);\n\t\t\treturn {(left[0]-left[1]).abs(), {left[0], left[1]}};\n\t\t}\n        \n\t\titer middle = next(left, n/2);\n        double x = middle->x;\n\t\tpair<double, pair<Point,Point>> d1 = closest_pair_core(left, middle);\n\t\tpair<double, pair<Point,Point>> d2 = closest_pair_core(middle, right);\n\t\tpair<double, pair<Point,Point>> d = (d1.first < d2.first) ? d1 : d2;\n\n\t\tstd::inplace_merge(left, middle, right,\n\t\t\t[](const Point &a, const Point &b) { return a.y < b.y; });\n\n\t\tvector<iter> around;\n\t\tfor(iter i = left; i != right; ++i){\n            if(fabs(i->x - x) >= d.first) continue;\n            for(auto j = around.rbegin(); j != around.rend(); ++j){\n                double dx = i->x - (*j)->x;\n                double dy = i->y - (*j)->y;\n                if (dy >= d.first) break;\n                double absval = sqrt(dx * dx + dy * dy);\n                if (d.first > absval) {\n                    d = {absval, {*i, **j}};\n                }\n            }\n            around.push_back(i);\n\t\t}\n\t\treturn d;\n}\npair<Point,Point> closest_pair(vector<Point> &points){\n\tsort(points.begin(), points.end());\n\treturn closest_pair_core(points.begin(), points.end()).second;\n}\n\n//pointsで囲まれた領域の面積を返す\ndouble area2(vector<Point>& points) {\n\tdouble s = 0;\n\tll n = points.size();\n\tfor (int i = 0; i < n; ++i) s += cross(points[i], points[(i + 1) % n]);\n\treturn s / 2.;\n}\n\n//キャリパー法により、凸多角形の中から最も遠い2点を返す\npair<Point,Point> convex_diameter(vector<Point> &ps) {\n\tll n = ps.size();\n\tll i = min_element(ps.begin(), ps.end()) - ps.begin();\n\tll j = max_element(ps.begin(), ps.end()) - ps.begin();\n\tll maxI, maxJ;\n\tdouble maxD = 0;\n\tfor(ll k=0; k<2*n; k++) {\n\t\tif(maxD < (ps[i] - ps[j]).norm()) {\n\t\t\tmaxD = (ps[i] - ps[j]).norm();\n\t\t\tmaxI = i;\n\t\t\tmaxJ = j;\n\t\t}\n\t\tif(cross(ps[i] - ps[(i+1) % n], ps[(j+1) % n] - ps[j]) <= 0) j = (j+1) % n;\n\t\telse i = (i+1) % n;\n\t}\n\treturn {ps[maxI], ps[maxJ]};\n}\n\n/*-----8<-----library-----8<-----*/\n\n\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\nvoid CGL_2_A(){\n\tll N;\n\tcin>>N;\n\tvector<ll> ans(N,0);\n\trep(i,N){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tll t=0;\n\t\tif(isOrthogonal(p0,p1,p2,p3)){\n\t\t\tt=1;\n\t\t}else if(isParallel(p0,p1,p2,p3)){\n\t\t\tt=2;\n\t\t}\n\t\tans[i]=t;\n\t}\n\trep(i,N)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\nvoid CGL_1_A(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tLine l(Point(x0,y0),Point(x1,y1));\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint po(xq,yq);\n\t\tPoint t=project(l,po);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q){\n\t\tcout<<ans[i].x<<' '<<ans[i].y<<'\\n';\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\nvoid CGL_1_B(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tLine l(Point(x0,y0),Point(x1,y1));\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint po(xq,yq);\n\t\tPoint t=reflect(l,po);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q){\n\t\tcout<<ans[i].x<<' '<<ans[i].y<<'\\n';\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\nvoid CGL_2_D(){\n\tll Q;\n\tcin>>Q;\n\tvector<double> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tSegment s0(Point(x0,y0),Point(x1,y1)), s1(Point(x2,y2),Point(x3,y3));\n\t\tdouble t=getDistance(s0,s1);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\nvoid CGL_1_C(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tPoint p0(x0,y0),p1(x1,y1);\n\tll Q;\n\tcin>>Q;\n\tvector<string> ans(Q,\"\");\n\tmap<ll,string> m;\n\tm[1]=\"COUNTER_CLOCKWISE\";\n\tm[-1]=\"CLOCKWISE\";\n\tm[2]=\"ONLINE_BACK\";\n\tm[-2]=\"ONLINE_FRONT\";\n\tm[0]=\"ON_SEGMENT\";\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint pq(xq,yq);\n\t\tll t=ccw(p0,p1,pq);\n\t\tans[i]=m[t];\n\t}\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\nvoid CGL_2_B(){\n\tll Q;\n\tcin>>Q;\n\tvector<ll> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tbool t=intersect(p0,p1,p2,p3);\n\t\tans[i]=t ? 1 : 0;\n\t}\n\trep(i,Q)p(ans[i]);\t\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=ja\nvoid CGL_2_C(){\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tSegment s0(p0,p1),s1(p2,p3);\n\t\tPoint t=getCrossPoint(s0,s1);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i].x,ans[i].y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=ja\nvoid CGL_7_D(){\n\tll cx,cy,r,Q;\n\tcin>>cx>>cy>>r>>Q;\n\tCircle c(Point(cx,cy),r);\n\tvector<pair<Point,Point>> ans(Q);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1;\n\t\tcin>>x0>>y0>>x1>>y1;\n\t\tPoint p0(x0,y0),p1(x1,y1);\n\t\tLine l(p0,p1);\n\t\tll count=hasCrossPoints(c,l);\n\t\tif(count==0)exit(1);\n\t\tpair<Point,Point> t=getCrossPoints(c,l);\n\t\tif(t.first.x>t.second.x || (equals(t.first.x,t.second.x) && t.first.y>t.second.y))swap(t.first,t.second);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i].first.x, ans[i].first.y, ans[i].second.x, ans[i].second.y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E&lang=ja\nvoid CGL_7_E(){\n\tdouble c0x,c0y,r0,c1x,c1y,r1;\n\tcin>>c0x>>c0y>>r0>>c1x>>c1y>>r1;\n\tCircle c0(Point(c0x,c0y), r0), c1(Point(c1x,c1y), r1);\n\tpair<Point,Point> t=getCrossPoints(c0, c1);\n\tif(t.first.x>t.second.x || (equals(t.first.x,t.second.x) && t.first.y>t.second.y))swap(t.first,t.second);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(t.first.x, t.first.y, t.second.x, t.second.y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C&lang=ja\nvoid CGL_3_C(){\n\tll N;\n\tcin>>N;\n\tvector<Point> g(N);\n\trep(i,N)cin>>g[i].x>>g[i].y;\n\tll Q;\n\tcin>>Q;\n\tvector<ll> ans(Q,0);\n\trep(i,Q){\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tll t=contains(g,Point(x,y));\n\t\tans[i]=t;\n\t}\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=ja\nvoid CGL_4_A(){\n\tll N;\n\tcin>>N;\n\tvector<Point> g(N);\n\trep(i,N)cin>>g[i].x>>g[i].y;\n\tvector<Point> ch=andrewScan(g);\n\tprintf(\"%lld\\n\",(ll)ch.size());\n\tll f=0;\n\trepeq(i,ch.size()-1){\n\t\tif(ch[f].y>ch[i].y || (ch[f].y==ch[i].y && ch[f].x>ch[i].x)){\n\t\t\tf=i;\n\t\t}\n\t}\n\trep(i,ch.size()){\n\t\tprintf(\"%lld %lld\\n\",(ll)ch[(i+f)%ch.size()].x, (ll)ch[(i+f)%ch.size()].y);\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_6_A&lang=ja\nvoid CGL_6_A(){\n\tll N;\n\tcin>>N;\n\tvector<Segment> a(N);\n\trep(i,N)cin>>a[i].p1.x>>a[i].p1.y>>a[i].p2.x>>a[i].p2.y;\n\tvector<Point> ans=manhattanIntersection(a);\n\tp(ans.size());\n}\n\n//https://atcoder.jp/contests/abc151/tasks/abc151_f\nvoid ABC151F() {\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tCircle ans=minimumBoundingCircle(v);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(ans.r);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\nvoid CGL_5_A() {\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tpair<Point,Point> anspr=closest_pair(v);\n\tdouble ans=getDistance(anspr.first, anspr.second);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(ans);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=ja\nvoid CGL_3_A(){\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tdouble ans=area2(v);\n\tcout.setf(ios::fixed), cout.precision(1);\n\tp(ans);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=ja\nvoid CGL_3_B(){\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tif(N==3){\n\t\tll cc=ccw(v[0],v[1],v[2]);\n\t\tif(cc!=CLOCKWISE && cc!=COUNTER_CLOCKWISE){\n\t\t\tp(1);return;\n\t\t}\n\t}\n\tvector<Point> convex=andrewScan(v);\n\tif(v.size()==convex.size())p(1);\n\telse p(0);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=ja\nvoid CGL_4_B(){\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tpair<Point,Point> anspr=convex_diameter(v);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(getDistance(anspr.first, anspr.second));\n}\n\nsigned main() {\n\t//CGL_2_A();\n\t//CGL_1_A();\n\t//CGL_1_B();\n\t//CGL_2_D();\n\t//CGL_1_C();\n\t//CGL_2_B();\n\t//CGL_2_C();\n\t//CGL_7_D();\n\t//CGL_7_E();\n\t//CGL_3_C();\n\t//CGL_4_A();\n\t//CGL_6_A();\n\t//ABC151F();\n\t//CGL_5_A();\n\t//CGL_3_A();\n\t//CGL_3_B();\n\tCGL_4_B();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double lf;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 5;\nconst int MOD = 1e9+7;\n\nconst lf eps = 1e-9;\ntypedef long double T;\nstruct pt {\n  T x, y;\n  pt operator + (pt p) { return {x+p.x, y+p.y}; }\n  pt operator - (pt p) { return {x-p.x, y-p.y}; }\n  pt operator * (pt p) { return {x*p.x-y*p.y, x*p.y+y*p.x}; }\n  pt operator * (T d) { return {x*d, y*d}; }\n  pt operator / (T d) { return {x/d, y/d}; } /// only for floating point\n  bool operator == (pt b) { return x == b.x && y == b.y; }\n  bool operator != (pt b) { return !(*this == b); }\n  bool operator < (const pt &o) const { return y < o.y || (y == o.y && x < o.x); }\n  bool operator > (const pt &o) const { return y > o.y || (y == o.y && x > o.x); }\n};\nint cmp (lf a, lf b) { return (a + eps < b ? -1 :(b + eps < a ? 1 : 0)); }\n/** Already in complex **/\nT norm(pt a) { return a.x*a.x + a.y*a.y; }\nlf abs(pt a) { return sqrt(norm(a)); }\nlf arg(pt a) { return atan2(a.y, a.x); }\nostream& operator << (ostream& os, pt &p) {\n  return os << \"(\"<< p.x << \",\" << p.y << \")\";\n}\n/***/\nistream &operator >> (istream &in, pt &p) {\n    T x, y; in >> x >> y;\n    p = {x, y};\n    return in;\n}\nT dot(pt a, pt b) { return a.x*b.x + a.y*b.y; }\nT cross(pt a, pt b) { return a.x*b.y - a.y*b.x; }\nT orient(pt a, pt b, pt c) { return cross(b-a,c-a); }\n//pt rot(pt p, lf a) { return {p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a)}; }\n//pt rot(pt p, double a) { return p * polar(1.0, a); } /// for complex\n//pt rotate_to_b(pt a, pt b, lf ang) { return rot(a-b, ang)+b; }\npt rot90ccw(pt p) { return {-p.y, p.x}; }\npt rot90cw(pt p) { return {p.y, -p.x}; }\npt translate(pt p, pt v) { return p+v; }\npt scale(pt p, double f, pt c) { return c + (p-c)*f; }\nbool are_perp(pt v, pt w) { return dot(v,w) == 0; }\nint sign(T x) { return (T(0) < x) - (x < T(0)); }\npt unit(pt a) { return a/abs(a); }\n\nbool in_angle(pt a, pt b, pt c, pt x) {\n  assert(orient(a,b,c) != 0);\n  if (orient(a,b,c) < 0) swap(b,c);\n  return orient(a,b,x) >= 0 && orient(a,c,x) <= 0;\n}\n\n//lf angle(pt a, pt b) { return acos(max(-1.0, min(1.0, dot(a,b)/abs(a)/abs(b)))); }\n//lf angle(pt a, pt b) { return atan2(cross(a, b), dot(a, b)); }\n/// returns vector to transform points\npt get_linear_transformation(pt p, pt q, pt r, pt fp, pt fq) {\n  pt pq = q-p, num{cross(pq, fq-fp), dot(pq, fq-fp)};\n  return fp + pt{cross(r-p, num), dot(r-p, num)} / norm(pq);\n}\n\nbool half(pt p) { /// true if is in (0, 180]\n  assert(p.x != 0 || p.y != 0); /// the argument of (0,0) is undefined\n  return p.y > 0 || (p.y == 0 && p.x < 0);\n}\nbool half_from(pt p, pt v = {1, 0}) {\n  return cross(v,p) < 0 || (cross(v,p) == 0 && dot(v,p) < 0);\n}\nbool polar_cmp(const pt &a, const pt &b) {\n  return make_tuple(half(a), 0) < make_tuple(half(b), cross(a,b));\n}\n\nstruct line {\n  pt v; T c;\n  line(pt v, T c) : v(v), c(c) {}\n  line(T a, T b, T c) : v({b,-a}), c(c) {}\n  line(pt p, pt q) : v(q-p), c(cross(v,p)) {}\n  T side(pt p) { return cross(v,p)-c; }\n  lf dist(pt p) { return abs(side(p)) / abs(v); }\n  lf sq_dist(pt p) { return side(p)*side(p) / (lf)norm(v); }\n  line perp_through(pt p) { return {p, p + rot90ccw(v)}; }\n  bool cmp_proj(pt p, pt q) { return dot(v,p) < dot(v,q); }\n  line translate(pt t) { return {v, c + cross(v,t)}; }\n  line shift_left(double d) { return {v, c + d*abs(v)}; }\n  pt proj(pt p) { return p - rot90ccw(v)*side(p)/norm(v); }\n  pt refl(pt p) { return p - rot90ccw(v)*2*side(p)/norm(v); }\n};\n\nbool inter_ll(line l1, line l2, pt &out) {\n  T d = cross(l1.v, l2.v);\n  if (d == 0) return false;\n  out = (l2.v*l1.c - l1.v*l2.c) / d;\n  return true;\n}\n/*line bisector(line l1, line l2, bool interior) {\n  assert(cross(l1.v, l2.v) != 0); /// l1 and l2 cannot be parallel!\n  lf sign = interior ? 1 : -1;\n  return {l2.v/abs(l2.v) + l1.v/abs(l1.v) * sign,\n          l2.c/abs(l2.v) + l1.c/abs(l1.v) * sign};\n}*/\n\nbool in_disk(pt a, pt b, pt p) {\n  return dot(a-p, b-p) <= 0;\n}\nbool on_segment(pt a, pt b, pt p) {\n  return orient(a,b,p) == 0 && in_disk(a,b,p);\n}\nbool proper_inter(pt a, pt b, pt c, pt d, pt &out) {\n  T oa = orient(c,d,a),\n  ob = orient(c,d,b),\n  oc = orient(a,b,c),\n  od = orient(a,b,d);\n  /// Proper intersection exists iff opposite signs\n  if (oa*ob < 0 && oc*od < 0) {\n    out = (a*ob - b*oa) / (ob-oa);\n    return true;\n  }\n  return false;\n}\nset<pt> inter_ss(pt a, pt b, pt c, pt d) {\n  pt out;\n  if (proper_inter(a,b,c,d,out)) return {out};\n  set<pt> s;\n  if (on_segment(c,d,a)) s.insert(a);\n  if (on_segment(c,d,b)) s.insert(b);\n  if (on_segment(a,b,c)) s.insert(c);\n  if (on_segment(a,b,d)) s.insert(d);\n  return s;\n}\nlf pt_to_seg(pt a, pt b, pt p) {\n  if(a != b) {\n    line l(a,b);\n    if (l.cmp_proj(a,p) && l.cmp_proj(p,b)) /// if closest to  projection\n      return l.dist(p); /// output distance to line\n  }\n  return min(abs(p-a), abs(p-b)); /// otherwise distance to A or B\n}\nlf seg_to_seg(pt a, pt b, pt c, pt d) {\n  pt dummy;\n  if (proper_inter(a,b,c,d,dummy)) return 0;\n  return min({pt_to_seg(a,b,c), pt_to_seg(a,b,d),\n              pt_to_seg(c,d,a), pt_to_seg(c,d,b)});\n}\n\nenum {IN, OUT, ON};\nstruct polygon {\n  vector<pt> p;\n  polygon(int n) : p(n) {}\n  int top = -1, bottom = -1;\n  void delete_repetead() {\n    vector<pt> aux;\n    sort(p.begin(), p.end());\n    for(pt &i : p)\n      if(aux.empty() || aux.back() != i)\n        aux.push_back(i);\n    p.swap(aux);\n  }\n  bool is_convex() {\n    bool pos = 0, neg = 0;\n    for (int i = 0, n = p.size(); i < n; i++) {\n      int o = orient(p[i], p[(i+1)%n], p[(i+2)%n]);\n      if (o > 0) pos = 1;\n      if (o < 0) neg = 1;\n    }\n    return !(pos && neg);\n  }\n  lf area() {\n    lf ans = 0;\n    for (int i = 0, n = p.size(); i < n; i++)\n      ans += cross(p[i], p[(i+1)%n]);\n    return abs(ans) / 2.0;\n  }\n  lf perimeter() {\n    lf per = 0;\n    for(int i = 0, n = p.size(); i < n; i++)\n      per += abs(p[i] - p[(i+1)%n]);\n    return per;\n  }\n  bool above(pt a, pt p) { return p.y >= a.y; }\n  bool crosses_ray(pt a, pt p, pt q) {\n    return (above(a,q)-above(a,p))*orient(a,p,q) > 0;\n  }\n  int in_polygon(pt a) {\n    int crosses = 0;\n    for(int i = 0, n = p.size(); i < n; i++) {\n      if(on_segment(p[i], p[(i+1)%n], a)) return ON;\n      crosses += crosses_ray(a, p[i], p[(i+1)%n]);\n    }\n    return (crosses&1 ? IN : OUT);\n  }\n  void normalize() { /// polygon is CCW\n    bottom = min_element(p.begin(), p.end()) - p.begin();\n    vector<pt> tmp(p.begin()+bottom, p.end());\n    tmp.insert(tmp.end(), p.begin(), p.begin()+bottom);\n    p.swap(tmp);\n    bottom = 0;\n    top = max_element(p.begin(), p.end()) - p.begin();\n  }\n  int in_convex(pt a) {\n    assert(bottom == 0 && top != -1);\n    if(a < p[0] || a > p[top]) return OUT;\n    T orientation = orient(p[0], p[top], a);\n    if(orientation == 0) {\n      if(a == p[0] || a == p[top]) return ON;\n      return top == 1 || top + 1 == p.size() ? ON : IN;\n    } else if (orientation < 0) {\n      auto it = lower_bound(p.begin()+1, p.begin()+top, a);\n      T d = orient(*prev(it), a, *it);\n      return d < 0 ? IN : (d > 0 ? OUT: ON);\n    }\n    else {\n      auto it = upper_bound(p.rbegin(), p.rend()-top-1, a);\n      T d = orient(*it, a, it == p.rbegin() ? p[0] : *prev(it));\n      return d < 0 ? IN : (d > 0 ? OUT: ON);\n    }\n  }\n  polygon cut(pt a, pt b) {\n    line l(a, b);\n    polygon new_polygon(0);\n    for(int i = 0, n = p.size(); i < n; ++i) {\n      pt c = p[i], d = p[(i+1)%n];\n      lf abc = cross(b-a, c-a), abd = cross(b-a, d-a);\n      if(abc >= 0) new_polygon.p.push_back(c);\n      if(abc*abd < 0) {\n        pt out; inter_ll(l, line(c, d), out);\n        new_polygon.p.push_back(out);\n      }\n    }\n    return new_polygon;\n  }\n  void convex_hull() {\n    sort(p.begin(), p.end());\n    vector<pt> ch;\n    ch.reserve(p.size()+1);\n    for(int it = 0; it < 2; it++) {\n      int start = ch.size();\n      for(auto &a : p) {\n        /// if colineal are needed, use < and remove repeated points\n        while(ch.size() >= start+2 && orient(ch[ch.size()-2], ch.back(), a) <= 0)\n          ch.pop_back();\n        ch.push_back(a);\n      }\n      ch.pop_back();\n      reverse(p.begin(), p.end());\n    }\n    if(ch.size() == 2 && ch[0] == ch[1]) ch.pop_back();\n    /// be careful with CH of size < 3\n    p.swap(ch);\n  }\n  lf diameter(){\n    int n = p.size();\n    lf res = 0;\n    for(int i = 0, k = 0; i < n; i++){\n      while(abs(p[i]-p[k]) < abs(p[i]-p[(k+1)%n])) k = (k+1)%n;\n      res = max(res, abs(p[i]-p[k]));\n    }\n    return res;\n  }\n  ll pick() {\n    ll boundary = 0;\n    for(int i = 0, n = p.size(); i < n; i++) {\n      int j = (i+1 == n ? 0 : i+1);\n      boundary += __gcd((ll)abs(p[i].x - p[j].x), (ll)abs(p[i].y - p[j].y));\n    }\n    return area() + 1 - boundary/2;\n  }\n  pt& operator[] (int i){ return p[i]; }\n};\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n\n  #ifdef LOCAL\n      freopen(\"input.txt\", \"r\", stdin);\n      freopen(\"output.txt\", \"w\", stdout);\n  #else\n      #define endl '\\n'\n  #endif // LOCAL\n\n  int n; cin >> n;\n  polygon pol(n);\n  for(int i = 0; i < n; i++) {\n    cin >> pol[i];\n  }\n  cout << fixed << setprecision(10);\n  cout << pol.diameter() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nconst db eps = 1e-9;\nint sgn(db a, db b = 0) {\n\ta -= b;\n\treturn (a > eps) - (a < -eps);\n}\n\nstruct poi {\n\tdb x, y;\n\tpoi operator -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tbool operator <(poi p) const {\n\t\treturn tie(x, y) < tie(p.x, p.y);\n\t}\n\tdb cross(poi p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb len() {\n\t\treturn sqrt(x * x + y * y);\n\t}\n};\ndb xmul(poi a, poi b, poi c) {\n\treturn (b - a).cross(c - a);\n}\n\nusing vp = vector <poi>;\nvp convex(vp v) {\n\tsort(v.begin(), v.end()); vp r;\n\tfor(int i = 0; i < v.size(); i ++) {\n\t\twhile(r.size() > 1 &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tr.push_back(v[i]);\n\t}\n\tint d = r.size();\n\tfor(int i = (int)v.size() - 2; i >= 0; i --) {\n\t\twhile(r.size() > d &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tif(i != 0) r.push_back(v[i]);\n\t}\n\treturn r;\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(false);\n\tint n; cin >> n; vp v;\n\tfor(int i = 0; i < n; i ++) {\n\t\tdb x, y; cin >> x >> y;\n\t\tv.push_back({x, y});\n\t}\n\tv = convex(v);\n\n\tn = v.size();\n\n\t{\n\t\tdb ans = 0;\n\t\tauto upd = [&](int i, int j) {\n\t\t\tdb t = (v[i] - v[j]).len();\n\t\t\tif(t > ans) ans = t;\n\t\t};\n\t\tint j = 0;\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\twhile(sgn(xmul(v[i], v[(i + 1) % n], v[j]),\n\t\t\t\txmul(v[i], v[(i + 1) % n], v[(j + 1) % n])) < 0)\n\t\t\t\tj = (j + 1) % n;\n\t\t\t//cout << i << ' ' << j << '\\n';\n\t\t\tupd(i, j); upd((i + 1) % n, j);\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//const double EPS = 1e-9;    // 許容誤差。問題によって変える\n#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-9;   // 許容誤差。問題によって変える\ntypedef complex<double> P; // Point\n//点の座標は複素数で持つ\n#define X real()\n#define Y imag()\n\nnamespace std\n{\nbool operator<(const P p1, const P p2)\n{\n    return p1.X != p2.X ? p1.X < p2.X : p1.Y < p2.Y;\n}\nP operator+(const P p1, const P p2) { return P(p1.X + p2.X, p1.Y + p2.Y); }\nP operator-(const P p1, const P p2) { return P(p1.X - p2.X, p1.Y - p2.Y); }\nP operator*(const P p, double k) { return P(p.X * k, p.Y * k); }\nP operator/(const P p, double k) { return P(p.X / k, p.Y / k); }\n} // namespace std\n//ここまで写経必須\n\n//Segment/L\nstruct Segment\n{\n    P p1, p2;\n    Segment() {}\n    Segment(P p1, P p2) : p1(p1), p2(p2) {}\n};\ntypedef Segment L;\n\n//Circle\nstruct Circle\n{\n    P p;\n    double r;\n    Circle(const P &p, double r) : p(p), r(r) {}\n};\ntypedef Circle C;\n\ntypedef vector<P> G;\n//ノルム\n//二点a,bを投げるとノルム(a1-b1)^2+(a2-b2)^2を返す\ndouble norm(P &p1, P &p2)\n{\n    return (p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y);\n}\n\n//外積cross(a,b) = |a||b|sinθ=a1b2-a2b1\n//二点a,bを投げると外積を返す\ndouble cross(const P &a, const P &b)\n{\n    return (conj(a) * b).Y;\n}\n\n//内積dot(a,b) = |a||b|cosθ=a1b1+a2b2\n//二点a,bを投げると内積を返す\ndouble dot(const P &a, const P &b)\n{\n    return (conj(a) * b).X;\n}\n\n//射影\n//L(又はS)と点Pを投げるとLへPを射影した座標を返す\n//依存:dot,norm\nP Projection(L l, P p)\n{\n    P base = l.p2 - l.p1;                        //始点\n    double r = dot(p - l.p1, base) / norm(base); //線分に対する倍率の計算\n    return l.p1 + base * r;\n}\n\n//鏡映\n//L(又はS)と点Pを投げるとLを軸としたPの鏡像座標を返す\n//依存:Projection,dot,norm\nP Reflection(L l, P p)\n{\n    return p + (Projection(l, p) - p) * 2.0;\n}\n\n//位置関係判定(線分abを軸にcがどちら側にあるか)\n//三点a,b,cを投げることで，a-bを軸として\n//時計回りの場合:1,反時計回りの場合:-1,c-a-bの並び:2,a-b-cの並び:-2\n//その他（重なってる等）:0\n//依存:cross,dot,norm\nint ccw(P a, P b, P c)\n{\n    b -= a;\n    c -= a; //aからの向きを考える\n    if (cross(b, c) > EPS)\n        return +1; //clockwise\n    else if (cross(b, c) < -EPS)\n        return -1; //counter clockwise\n    else if (dot(b, c) < -EPS)\n        return +2; //c-a-b\n    else if (norm(b) < norm(c))\n        return -2; //a-b-c\n    else\n        return 0; //他\n}\n\n//Intersection Determination\n//L,S,Pそれぞれのペアの交差判定，PPは直接比較できるのでないです\n//それぞれのペアを投げる,引数の順番は関数名に記載\n//交差又は含まれている場合true,そうでない場合falseを返す\n\n//依存:cross\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l.p2 - l.p1, m.p2 - m.p1)) > EPS || // non-parallel\n           abs(cross(l.p2 - l.p1, m.p1 - l.p1)) < EPS;   // same L\n}\n//依存:cross\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l.p2 - l.p1, s.p1 - l.p1) * // s.p1 is left of l\n               cross(l.p2 - l.p1, s.p2 - l.p1) <\n           EPS; // s.p2 is right of l\n}\n//依存:cross\nbool intersectLP(const L &l, const P &p)\n{\n    return abs(cross(l.p2 - p, l.p1 - p)) < EPS;\n}\n//依存:ccw,cross,dot,norm\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s.p1, s.p2, t.p1) * ccw(s.p1, s.p2, t.p2) <= 0 &&\n           ccw(t.p1, t.p2, s.p1) * ccw(t.p1, t.p2, s.p2) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p)\n{\n    return abs(s.p1 - p) + abs(s.p2 - p) - abs(s.p2 - s.p1) < EPS; // triangle inequality\n}\n\n//distance\n//L,S,Pについてペアを投げるとその距離を計算\n//引数の順番は関数名参照\n\n//依存:Projection,dot,norm\ndouble distanceLP(const L &l, const P &p)\n{\n    return abs(p - Projection(l, p));\n}\n//依存:intersectLL,cross,distanceLP,Projection,dot,norm\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n//依存:intersectLS,cross,distanceLP,Projection,dot,norm\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s))\n        return 0;\n    return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n//依存:intersectSP,Projection,dot,norm\ndouble distanceSP(const L &s, const P &p)\n{\n    const P r = Projection(s, p);\n    if (intersectSP(s, r))\n        return abs(r - p);\n    return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n//依存:intersectSS,ccw,cross,dot,norm,distanceSP,intersectSP,Projection\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t))\n        return 0;\n    return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n               min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\ndouble distancePP(const P &p1, const P &p2)\n{\n    return abs(p1 - p2);\n}\n//二本のL(又はS)を投げると交点座標を返す\n//一致している場合は一本目のp1を返します\n//交わっていない場合はfalseを返します\n//依存:cross\nP crosspoint(const L &l, const L &m)\n{\n    double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n    double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n    if (abs(A) < EPS && abs(B) < EPS)\n        return l.p1; // same line\n    if (abs(A) < EPS)\n        assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m.p1 + B / A * (m.p2 - m.p1);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i + 1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\ndouble ConvDia(const G &g)\n{\n    const int n = g.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; i++)\n    {\n        if (imag(g[i]) > imag(g[is])) //点対はy座標の大きいものと小さいもののセット\n            is = i;\n        if (imag(g[i]) < imag(g[js]))\n            js = i;\n    }\n    double ans = abs(g[is] - g[js]);\n    int i = is, maxi = is, j = js, maxj = js;\n    do\n    {\n        if (cross(diff(g, i), diff(g, j)) >= 0)\n            j = (j + 1) % n;\n        else\n            i = (i + 1) % n;\n        if (abs(g[i] - g[j]) > ans)\n        {\n            ans = abs(g[i] - g[j]);\n            maxi = i;\n            maxj = j;\n        }\n    }while (i != is or j != js);\n    return ans;\n}\nint main(){\n    int n;\n    cin >> n;\n    G g;\n    for (int i = 0; i < n;i++){\n        double x,y;\n        cin >> x >> y;\n        P p = P(x, y);\n        g.push_back(p);\n    }\n    printf(\"%.16f\\n\",ConvDia(g));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 0.0;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tif (N >= 20000) { res = 200 * sqrt(2); goto E; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = max(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\n\tPoint operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n\tPoint operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n\tPoint operator*(const double m) const { return Point(x*m, y*m); }\n\n\tPoint operator/(const double d) const { return Point(x/d, y/d); }\n\n\tbool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nostream& operator << (ostream& os, const Point& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \")\";\n\treturn os;\n}\n\ndouble dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }\ndouble atan(Point p) { return atan2(p.y, p.x); }\ndouble norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return sqrt(norm(p)); }\ndouble distancePP(Point p, Point o) { return sqrt(norm(o - p)); }\n\nint ccw(Point a, Point b, Point c) {\n\tb = b-a;\n\tc = c-a;\n\n\tif(cross(b, c) > 0.0) return +1;\t//conter clockwise\n\tif(cross(b, c) < 0.0) return -1;\t//clockwise\n\tif(dot(b, c) < 0.0) return +2;\t//a on Seg(b,c)\n\tif(norm(b) < norm(c)) return -2;\t//b on Seg(a,c)\n\treturn 0;\t//c on Seg(a,b)\n}\n\n// bool cmp_y(const Point& a,const Point& b) {\n// \tif(a.y != b.y) return a.y < b.y;\n// \treturn a.x < b.x;\n// }\n\nvector<Point> convex_hull(vector<Point> ps) {   \n\tint n = ps.size();\n\tsort(ps.begin(),ps.end());\n\n\tint k = 0;\n\tvector<Point> convex(n*2);\n\n\trep(i, n) {\n\t\twhile (k > 1 && ccw(convex[k-2], convex[k-1], ps[i]) == -1 ) {\n\t\t\tk--;\n\t\t}\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tfor(int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && ccw(convex[k-2], convex[k-1], ps[i]) == -1 ) {\n\t\t\tk--;\n\t\t}\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.resize(k-1);\n\treturn convex;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tvector<Point> v(n);\n\trep(i, n) cin >> v[i].x >> v[i].y;\n\n\tvector<Point> ret = convex_hull(v);\n\n\tdouble ans = 0;\n\trep(i, n) {\n\t\tREP(j, i+1, n) {\n\t\t\tans = max(ans, distancePP(ret[i], ret[j]));\n\t\t}\n\t}\n\n\tcout << fixed;\n\tcout.precision(20);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n \nclass Point{\n\tpublic:\n\t\tdouble x, y;\n \n\t\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n \n\t\tPoint operator + (Point p){ return Point(x + p.x, y + p.y);}\n\t\tPoint operator - (Point p){ return Point(x - p.x, y - p.y);}\n\t\tPoint operator * (double a){ return Point(a * x, a * y);}\n\t\tPoint operator / (double a){ return Point(x / a, y / a);}\n \n\t\tdouble abs(){ return sqrt(norm());}\n\t\tdouble norm(){ return x * x + y * y;}\n \n\t\tbool operator < (const Point &p) const{\n\t\t\treturn x != p.x ? x < p.x : y < p.y;\n\t\t}\n\t\tbool operator > (const Point &p) const{\n\t\t\treturn x != p.x ? x > p.x : y > p.y;\n\t\t}\n\t\tbool operator == (const Point &p) const{\n\t\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t\t}\n};\n \ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n \ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\n \nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < -EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n \n\treturn ON_SEGMENT;\n}\ndouble getDistance(Point a, Point b){\n\treturn (a - b).abs();\n}\nPolygon convex_hull(Polygon ps){\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ret(2 * n);\n\tfor(int i = 0; i < n; ret[k++] = ps[i++]){\n\t\twhile(k >= 2 && ccw(ret[k - 2], ret[k - 1], ps[i]) <= 0 && ccw(ret[k - 2], ret[k - 1], ps[i]) != -2) --k;\n\t}\n\tfor(int i = n - 2, t = k + 1; i >= 0; ret[k++] = ps[i--]){\n\t\twhile(k >= t && ccw(ret[k - 2], ret[k - 1], ps[i]) <= 0 && ccw(ret[k - 2], ret[k - 1], ps[i]) != -2) --k;\n\t}\n\tret.resize(k - 1);\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tPolygon p(n);\n\tfor(int i = 0; i < n; i++) scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n\tPolygon qs = convex_hull(p);\n\tif(qs.size() == 2){\n\t\tprintf(\"%.10lf\\n\", getDistance(qs[0], qs[1]));\n\t\treturn 0;\n\t}\n\tint l = 0, r = 0;\n\tfor(int i = 0; i < qs.size(); i++){\n\t\tif(qs[i] < qs[l]) l = i;\n\t\tif(qs[i] > qs[r]) r = i;\n\t}\n\tdouble res = 0.0;\n\tint i = l, j = r;\n\twhile(i != r || j != l){\n\t\tres = max(res, getDistance(qs[i], qs[j]));\n\t\tif(cross(qs[(i + 1) % n] - qs[i], qs[(j + 1) % n] - qs[j]) < 0){\n\t\t\ti = (i + 1) % qs.size();\n\t\t}else{\n\t\t\tj = (j + 1) % qs.size();\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\", res);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vec;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\ndouble eps=1e-8;\ndouble PI=acos(-1);\n\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\n\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\n\ndouble calcArea(vec &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++)res+=cross(t[i],t[(i+1==n?0:i+1)]);\n  return abs(res/2.0);\n}\n\ndouble Arg(P a,P b,P c){\n  b-=a,c-=a;\n  return arg(c*conj(b));\n}\n\nint inPolygon(vec &t,P p){\n  int n=t.size();\n  double sum=0;  \n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p) == 0 )return 1;// on\n    sum+= Arg(p,a,b);\n  }\n  if( abs(sum) < eps )return 0;//out\n  else  return 2;//in\n}\n\ntypedef pair<double,P> Pair;\n\nvec andrewScan(vec &t){\n  int N=t.size(),C=0;\n  vec R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vec res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n\nvec ConvexHull2(vec t){\n  sort(t.begin(),t.end());\n  vec u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vec l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvec ConvexHull(vec t){\n  vector<Pair> u;\n  vec R;\n  int N=t.size(),K=0,C=0;\n  for(int i=1;i<N;i++)if(t[i]<t[K])K=i;\n  for(int i=0;i<N;i++)u.push_back(Pair(arg(t[i]-t[K]),t[i]));\n  R.push_back(t[K]),C++;\n  sort(u.begin(),u.end());\n  for(int i=0;i<N;i++){\n    P p=u[i].second;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==0)continue;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==2)continue;\n    while(2<=C&&ccw(R[C-2],R[C-1],p)!=1)R.pop_back(),C--;\n    R.push_back(p),C++;    \n  }\n  return R;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vec t;\n  double x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  vec ans=ConvexHull2(t);\n  int m=ans.size();\n  double maxm=1e9;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      maxm=max(maxm,abs(ans[i]-ans[j]));\n    }\n  }\n  printf(\"%.8f\\n\",maxm);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\ntypedef vector<point> polygon;\n\ndouble cross(point a, point b) { return imag(conj(a) * b); }\n\ndouble area2(point a, point b, point c) { return cross(b - a, c - a); }\n\ndouble dot(point a, point b) { return real(conj(a) * b); }\n\nint ccw(point a, point b, point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0) return +1; // counter clockwise\n\tif (cross(b, c) < 0) return -1; // clockwise\n\tif (dot(b, c) < 0) return +2; // c--a--b on line\n\tif (dot(b, b) < dot(c, c)) return -2; // a--b--c on line\n\treturn 0;\n}\n\nnamespace std\n{\n\tbool operator<(point a, point b)\n\t{\n\t\tif (a.real() != b.real())\n\t\t\treturn a.real() < b.real();\n\t\treturn a.imag() < b.imag();\n\t}\n}\n\n\npolygon convex_hull(vector<point> &P)\n{\n\tint n = P.size(), k = 0;\n\tvector<point> h(2 * n);\n\tsort(P.begin(), P.end());\n\tfor (int i = 0; i < n; h[k++] = P[i++])\n\t\twhile (k >= 2 && ccw(h[k - 2], h[k - 1], P[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; h[k++] = P[i--])\n\t\twhile (k >= t && ccw(h[k - 2], h[k - 1], P[i]) <= 0) --k;\n\treturn polygon(h.begin(), h.begin() + k - (k > 1));\n}\n\n\ndouble sqr(double v){\n\treturn v * v;\n}\n\ndouble dist(point a, point b){\n\treturn sqrt(sqr(a.real() - b.real()) + sqr(a.imag() - b.imag()));\n}\n\n\n#define NEXT(i) (((i) + 1) % n)\n\nvector<pii> get_points (polygon &P)\n{\n\tvector<pii> ans;\n\tint n = P.size();\n\n\tif (P.size() == 2)\n\t\tans.push_back(make_pair(0, 1));\n\n\tif (P.size() < 3)\n\t\treturn ans;\n\n\tint q0 = 0;\n\n\twhile (abs(area2(P[n - 1], P[0], P[NEXT(q0)])) > \n\t\t   abs(area2(P[n - 1], P[0], P[q0])))\n\t\t++q0;\n\n\tfor (int q = q0, p = 0; q != 0 && p <= q0; ++p)\n\t{\n\t\tans.push_back(make_pair(p, q));\n\n\t\twhile (abs(area2(P[p], P[NEXT(p)], P[NEXT(q)])) > \n\t\t\t   abs(area2(P[p], P[NEXT(p)], P[q])))\n\t\t{\n\t\t\tq = NEXT(q);\n\n\t\t\tif (p != q0 || q != 0)\n\t\t\t\tans.push_back(make_pair(p, q));\n\t\t\telse\n\t\t\t\treturn ans;\n\t\t}\n\n\t\tif (abs(area2(P[p], P[NEXT(p)], P[NEXT(q)])) == \n\t\t\t    abs(area2(P[p], P[NEXT(p)], P[q])))\n\t\t{\n\t\t\tif (p != q0 || q != n - 1)\n\t\t\t\tans.push_back(make_pair(p, NEXT(q)));\n\t\t\telse\n\t\t\t\tans.push_back(make_pair(NEXT(p), q));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n/*\n\tGets the farthest pair of points of the given points.\n\t(maybe TLE using double)\n\n\tTESTED [POJ 2187]\n*/\npair<point, point> farthest_pair (polygon &P)\n{\n\tP = convex_hull(P);\n\tvector<pii> pairs = get_points(P);\n\n\tdouble best = 0;\n\tpair<point, point> ans;\n\n\tfor (int i = 0; i < pairs.size(); ++i)\n\t{\n\t\tpoint p1 = P[pairs[i].first];\n\t\tpoint p2 = P[pairs[i].second];\n\t\tdouble dist = norm(p1- p2);\n\n\t\tif (dist > best)\n\t\t{\n\t\t\tbest = dist;\n\t\t\tans = make_pair(p1, p2);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\tvector<point> v(n);\n\tfor (int i = 0; i < n; ++i){\n\t\tdouble x, y; cin >> x >> y;\n\t\tv[i] = point(x, y);\n\t}\n\tpair<point,point> fp = farthest_pair(v);\n\tdouble ans = dist(fp.first, fp.second);\n\n\tcout.precision(15);\n\tcout << fixed << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ntypedef Point Vector;\n\nVector normal(Point p0, Point p1); //ベクトルp0p1の法線ベクトル\nint argmax(const vector<double> &v); //std::vectorのargmax関数\n\nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int n;\n    cin >> n;\n    vector<Point> data(n);\n\n    for(int i=0; i<n; i++){\n        cin >> data[i].x >> data[i].y;\n    }\n\n    Point p0, p1;\n    Vector nv;\n    vector<double> xNormalNoDup(0);\n    vector<Vector> normalVector(0);\n    xNormalNoDup.reserve(n);\n    normalVector.reserve(n);\n    map<double, int> isSwitchVertex;\n\n    for(int i=0; i<n; i++){\n        p0 = data[i];\n        p1 = data[(i+1)%n];\n        nv = normal(p0, p1);\n        normalVector.push_back(nv);\n        if (nv.y > 0 || nv.x == 1) isSwitchVertex[ nv.x ] += 1;\n        else isSwitchVertex[ -nv.x ] -= 1;\n    }\n\n    //Extract keys of isSwitchVertex and sort\n    for(map<double,int>::iterator it = isSwitchVertex.begin(); it != isSwitchVertex.end(); ++it) {\n        xNormalNoDup.push_back(it->first);\n    }\n    sort(xNormalNoDup.begin(), xNormalNoDup.end());\n\n    //find the first pair\n    int pairIndex0 = -1; //upside\n    int pairIndex1 = -1; //downside\n    Vector nv0, nv1;\n    for(int i=0; i<n; i++){\n        nv0 = normalVector[i];\n        nv1 = normalVector[(i+1)%n];\n        if( nv0.y<0 && nv1.y>=0 ) pairIndex0 = (i+1)%n;\n        if( nv0.y>0 && nv1.y<=0 ) pairIndex1 = (i+1)%n;\n    }\n    if(pairIndex0<0 || pairIndex1<0) cout << \"ERROR: Pair Initialization failed.\";\n    //cout << \"First Pair\" << \" \" << pairIndex0 << \" \" << pairIndex1 << endl;\n\n    double maxDiameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n    double diameter = 0;\n\n    for(int i=0; i<xNormalNoDup.size(); i++){\n        switch( isSwitchVertex[ xNormalNoDup[i] ] ) {\n            case 1:  pairIndex0 += 1;\n                     break;\n            case -1: pairIndex1 += 1;\n                     break;\n            case 0:  pairIndex0 += 1;\n                     pairIndex1 += 1;\n                     break;\n            default: cout << \"Error: Next pair not found.\" << endl;\n                     break;\n        }\n        pairIndex0 %= n;\n        pairIndex1 %= n;\n        diameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n        maxDiameter = (diameter > maxDiameter)? diameter: maxDiameter;\n    }\n\n    cout << setprecision(14) << maxDiameter << endl;\n\n    return 0;\n}\n\nVector normal(Point p0, Point p1){\n    Vector nv;\n    nv.x = - ( p1.y - p0.y );\n    nv.y = p1.x - p0.x;\n    double a = nv.abs();\n    return nv / a;\n}\n\nint argmax(const vector<double> &v){\n    return distance(v.begin(), max_element(v.begin(), v.end()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\n\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<point> g(n);\n\tfor(int i=0;i<n;i++)g[i]=make();\n\tprintf(\"%0.9lf\\n\",convex_diameter(g));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vec;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\ndouble eps=1e-8;\ndouble PI=acos(-1);\n\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\n\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\n\ndouble calcArea(vec &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++)res+=cross(t[i],t[(i+1==n?0:i+1)]);\n  return abs(res/2.0);\n}\n\ndouble Arg(P a,P b,P c){\n  b-=a,c-=a;\n  return arg(c*conj(b));\n}\n\nint inPolygon(vec &t,P p){\n  int n=t.size();\n  double sum=0;  \n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p) == 0 )return 1;// on\n    sum+= Arg(p,a,b);\n  }\n  if( abs(sum) < eps )return 0;//out\n  else  return 2;//in\n}\n\ntypedef pair<double,P> Pair;\n\nvec andrewScan(vec &t){\n  int N=t.size(),C=0;\n  vec R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vec res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n\nvec ConvexHull2(vec t){\n  sort(t.begin(),t.end());\n  vec u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vec l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvec ConvexHull(vec t){\n  vector<Pair> u;\n  vec R;\n  int N=t.size(),K=0,C=0;\n  for(int i=1;i<N;i++)if(t[i]<t[K])K=i;\n  for(int i=0;i<N;i++)u.push_back(Pair(arg(t[i]-t[K]),t[i]));\n  R.push_back(t[K]),C++;\n  sort(u.begin(),u.end());\n  for(int i=0;i<N;i++){\n    P p=u[i].second;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==0)continue;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==2)continue;\n    while(2<=C&&ccw(R[C-2],R[C-1],p)!=1)R.pop_back(),C--;\n    R.push_back(p),C++;    \n  }\n  return R;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vec t;\n  double x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  vec ans=ConvexHull(t);\n  int m=ans.size();\n  double maxm=0;\n  \n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      maxm=max(maxm,abs(ans[i]-ans[j]));\n    }\n  }\n  \n  printf(\"%.8f\\n\",maxm);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\nusing namespace std;\n\ntemplate <class T> void readPoint(vector< vector<T> >& vec, int idx) {\n    T x, y;\n    vector<T> point(2);\n    cin >> x >> y;\n    point[0] = x;\n    point[1] = y;\n    vec[idx] = point;\n}\ndouble dist(double x1, double y1, double x2, double y2) {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\nint main()\n{\n    int size;\n    cin >> size;\n    vector< vector<double> > points(size);\n    for (int i = 0; i < size; i++) {\n        readPoint(points, i);\n    }\n    int prev_idx(0), cur_idx(0), max_idx(0), max_dia(0);\n    double dia;\n    do {\n        prev_idx = cur_idx;\n        cur_idx = max_idx;\n        for (int i = 0; i < size; i++) {\n             dia = dist(points[cur_idx][0], points[cur_idx][1], points[i][0], points[i][1]);\n             if (dia > max_dia) {\n                 max_idx = i;\n             }  \n        }\n\n    } while (prev_idx != max_idx);\n    \n\n    cout << max_dia << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n\nconst double eps = 1e-10;\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}  \n  double norm() {return sqrt(x*x + y*y);}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ndouble operator * (const Point &p, const Point q) {return p.x * q.x + p.y * q.y;}\nbool operator == (const Point &p, const Point &q) {return (abs(p.x - q.x) < eps && abs(p.y - q.y) < eps);}\nbool operator != (const Point &p, const Point &q) {return !(p == q);}\ndouble cross(const Point &p, const Point &q) {return p.x*q.y - p.y*q.x;}\ndouble dist(const Point &p, const Point &q) {return (p-q).norm();}\nbool comp(const Point &p, const Point &q) {return p.x != q.x? p.x < q.x : p.y < q.y;}\n\nstruct Segment {\n  Point p , q;\n  Segment(Point p = Point(0.0,0.0), Point q = Point(0.0,0.0)) : p(p), q(q) {}\n};\n\nstruct Line {\n  double a, b, c;\n  Line(double a, double b, double c) : a(a), b(b), c(c) {}\n  Line(Point p, Point q) {\n    a = q.y - p.y;\n    b = p.x - q.x;\n    c = q.x * p.y - p.x * q.y;\n  }\n};\n\nstruct Circle {\n  double r;\n  Point p;\n  Circle(Point p = Point(0.0, 0.0), double r = 0.0) : p(p), r(r) {}\n};\n\n// 点の直線への射影\nPoint projection (Point p, Line l) {\n  double x = p.x - l.a * (l.a*p.x + l.b*p.y + l.c) / (l.a*l.a + l.b*l.b);\n  double y = p.y - l.b * (l.a*p.x + l.b*p.y + l.c) / (l.a*l.a + l.b*l.b);\n  return Point(x,y);\n}\n\n// 線対称な点\nPoint reflection(Point p, Line l) {\n  double x = p.x - 2.0 * l.a * (l.a*p.x + l.b*p.y + l.c) / (l.a*l.a + l.b*l.b);\n  double y = p.y - 2.0 * l.b * (l.a*p.x + l.b*p.y + l.c) / (l.a*l.a + l.b*l.b);\n  return Point(x,y);\n}\n\n// 点の線分からの回転方向\nint ccw(Point p, Point p1, Point p2) {\n  p1 = p1 - p; p2 = p2 - p;\n  if(cross(p1,p2) > eps) return 1; \n  if(cross(p1,p2) < -eps) return -1; \n  if(p1 * p2 < 0) return 2; \n  if(p1.norm() < p2.norm()) return -2; \n  return 0; \n}\n\n// 点が線分上にあるか判定\nbool on_segment(Point p, Segment s) {\n  return (ccw(s.p,s.q,p) == 0 ? true : false);\n}\n\n// 線分の交差判定\nbool segment_segment_cross(const Segment l, const Segment s) {\n  return ccw(l.p,l.q,s.p) * ccw(l.p,l.q,s.q) <= 0 && ccw(s.p,s.q,l.p) * ccw(s.p,s.q,l.q) <= 0;\n}\n\n// 直線の平行・直交判定 (平行:2 直交:1 その他:0)\nint line_parallel_orthogonal(Line l, Line s) {\n  if(abs(l.a*s.a + l.b*s.b) < eps) return 1;\n  else if(abs(l.a*s.b - l.b*s.a) < eps) return 2;\n  else return 0;\n}\n\n// 直線と直線の交点 \nvector<Point> line_line_cross(Line l, Line s) {\n  vector<Point> vp;\n  if(line_parallel_orthogonal(l,s) != 2) {\n    Point p;\n    p.x = (l.b*s.c - s.b*l.c) / (l.a*s.b - s.a*l.b);\n    p.y = (-l.a*s.c + s.a*l.c) / (l.a*s.b - s.a*l.b);\n    vp.push_back(p);\n  }\n  return vp;\n}\n\n// 点と直線の距離\ndouble point_line_dist(Point p, Line l) {\n  return abs(l.a*p.x + l.b*p.y + l.c) / sqrt(l.a*l.a + l.b*l.b);\n}\n\n// 点と線分の距離\ndouble point_segment_dist(Point p, Segment s) {\n  Point h = projection(p,Line(s.p,s.q));\n  if(on_segment(h,s)) return dist(p,h);\n  else return min(dist(p,s.p),dist(p,s.q));\n}\n\n// 線分と線分の距離\ndouble segment_segment_dist(Segment l, Segment s) {\n  if(segment_segment_cross(l,s)) return 0.0;\n  else return min({point_segment_dist(l.p,s),point_segment_dist(l.q,s),point_segment_dist(s.p,l),point_segment_dist(s.q,l)});\n}\n\n// 直線と直線の距離\ndouble line_line_dist(Line l, Line s) {\n  if(line_parallel_orthogonal(l,s) != 2) return 0.0;\n  else if(abs(s.a) < eps) return point_line_dist(Point(0.0,-s.c/s.b),l);\n  else return point_line_dist(Point(-s.c/s.a,0),l);\n}\n\n// 直線と線分の距離\ndouble line_segment_dist(Line l, Segment s) {\n  Point a, b;\n  if(abs(l.a) < eps) a = Point(0.0,-l.c/l.b), b = Point(1.0,-l.c/l.b);\n  else if(abs(l.b) < eps) a = Point(-l.c/l.a,0.0), b = Point(-l.c/l.a,0.0);\n  else a = Point(0.0,-l.c/l.b), b = Point(-l.c/l.a,0);\n\n  if(ccw(a,b,s.p) * ccw(a,b,s.q) <= 0) return 0.0;\n  else return min(point_line_dist(s.p,l),point_line_dist(s.q,l));\n}\n\n// ★円と円の交差判定 (離れる:4 外接:3 交わる:2 内接:1 内包:0)\nint circle_circle_pos(Circle c, Circle d) {\n  if(dist(c.p,d.p) >= c.r + d.r + eps) return 4;\n  else if(abs(dist(c.p,d.p) - c.r - d.r) < eps) return 3;\n  else if(dist(c.p,d.p) >= abs(c.r-d.r) + eps) return 2;\n  else if(abs(dist(c.p,d.p) - abs(c.r-d.r)) < eps) return 1;\n  else return 0; \n}\n\n// ★円と直線の交点\nvector<Point> circle_line_cross(Circle c, Line l) {\n  vector<Point> vp;\n  Point h = projection(c.p,l);\n\n  double d = l.a*c.p.x + l.b*c.p.y + l.c;\n  double q = c.r*c.r - d*d / (l.a*l.a + l.b*l.b);\n  if(q >= eps) {\n    Point p1, p2;\n    p1.x = h.x + sqrt(q) * l.b / sqrt(l.a*l.a + l.b*l.b);\n    p1.y = h.y - sqrt(q) * l.a / sqrt(l.a*l.a + l.b*l.b);\n    p2.x = h.x - sqrt(q) * l.b / sqrt(l.a*l.a + l.b*l.b);\n    p2.y = h.y + sqrt(q) * l.a / sqrt(l.a*l.a + l.b*l.b);\n    vp.push_back(p1);\n    vp.push_back(p2);\n  } else if(abs(q) < eps) {\n    vp.push_back(h);\n  }\n  return vp;\n} \n\n// ★円と円の交点\nvector<Point> circle_circle_cross(Circle c, Circle d) {\n  Line l(2.0*(c.p.x-d.p.x),2.0*(c.p.y-d.p.y),-c.p.x*c.p.x+d.p.x*d.p.x-c.p.y*c.p.y+d.p.y*d.p.y+c.r*c.r-d.r*d.r);\n  return circle_line_cross(c,l);\n}\n\n// ★多角形の面積\ndouble polygon_area(vector<Point>& v) {\n  int l = v.size();\n  double s = 0.0;\n  for(int i = 0; i < l; i++) s += 1/2.0 * cross(v[i],v[(i+1)%l]);\n  return s;\n}\n\n// ★多角形の凸性\nbool polygon_convex(vector<Point>& v) {\n  int l = v.size();\n  for(int i = 0; i < l; i++) {\n    if(cross(v[(i+1)%l]-v[i],v[(i+2)%l]-v[i]) < -eps) return false;\n  }\n  return true;\n} \n\n// ★点の多角形への包含 (含まれる:2 辺上:1 外:0)\nint polygon_inclusion(const vector<Point>& v, const Point p) {\n  int l = v.size();\n  bool in = false;\n  for(int i = 0; i < l; i++) {\n    Point a = v[i] - p, b = v[(i+1)%l] - p;\n    if(on_segment(Point(0.0,0.0),Segment(a,b))) return 1;\n    if(a.y > b.y) swap(a,b);\n    if(a.y <= 0 && b.y > 0 && cross(a,b) < 0) in = !in; \n  }\n  return in ? 2 : 0;\n}\n\n// ★凸包 O(nlogn) (Graham Scan)\nvector<Point> convex_hull(vector<Point>& v) {\n  int l = v.size();\n  sort(v.begin(),v.end(),comp);\n  vector<Point> c(2*l);\n  int k = 0;\n  for(int i = 0; i < l; i++) {\n    while(k > 1 && cross(c[k-1]-c[k-2],v[i]-c[k-1]) <= -eps) k--;\n    c[k++] = v[i];\n  }\n  for(int i = l-2, t = k; i >= 0; i--) {\n    while(k > t && cross(c[k-1]-c[k-2],v[i]-c[k-1]) <= -eps) k--;\n    c[k++] = v[i];\n  }\n  c.resize(k-1);\n  return c;\n}\n\n// 最遠点距離(キャリパー法) O(n) (凸包を構成する場合O(nlogn))\ndouble convex_diameter(vector<Point>& v) {\n  vector<Point> c = convex_hull(v);\n  int l = c.size();\n  if(l == 2) return (dist(c[0],c[1]));\n  int i = 0, j = 0;\n  for(int k = 0; k < l; k++) {\n    if(!comp(c[i],c[k])) i = k;\n    if(comp(c[j],c[k])) j = k;\n  }\n  double res = 0.0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res,dist(c[i],c[j]));\n    if(cross(c[(i+1)%l]-c[i],c[(j+1)%l]-c[j]) < 0) i = (i + 1) % l;\n    else j = (j + 1) % l;\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<Point> v(n);\n  rep(i,n) cin >> v[i].x >> v[i].y;\n  printf(\"%.9lf\\n\",convex_diameter(v));\n  return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nusing Point = complex<double>;\nusing Polygon = vector<Point>;\n\ninline int sgn(const double &a) { return (a < -EPS ? -1 : (a > EPS ? 1 : 0)); }\n\ninline bool eq(const Point &a, const Point &b) { return abs(a - b) < EPS; }\n\nnamespace std {\ninline bool operator<(const Point &a, const Point &b) {\n    if (sgn(a.real() - b.real()))\n        return sgn(a.real() - b.real()) < 0;\n    return sgn(a.imag() - b.imag()) < 0;\n}\n} // namespace std\n\ndouble dot(const Point &a, const Point &b) { return real(conj(a) * b); }\n\ndouble det(const Point &a, const Point &b) { return imag(conj(a) * b); }\n\nstruct Line {\n    Point p1, p2;\n\n    Line(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\n    bool operator<(const Line &rhs) const {\n        if (eq(p2, rhs.p2))\n            return p1 < rhs.p1;\n        return p2 < rhs.p2;\n    }\n    bool operator==(const Line &rhs) const {\n        return (eq(p1, rhs.p1) && eq(p2, rhs.p2)) ||\n               (eq(p1, rhs.p2) && eq(p2, rhs.p1));\n    }\n};\n\ninline Point curr(const Polygon &p, const int &i) { return p[i % p.size()]; }\n\ninline Point next(const Polygon &p, const int &i) {\n    return p[(i + 1) % p.size()];\n}\n\ninline Point prev(const Polygon &p, const int &i) {\n    return p[(i + p.size() - 1) % p.size()];\n}\n\ndouble convex_diameter(const Polygon &pg) {\n    const int n = pg.size();\n    int ps = 0, qs = 0;\n    for(int i=1;i<n;i++){\n        if(pg[i].imag() > pg[ps].imag())ps = i;\n        if(pg[i].imag() < pg[qs].imag())qs = i;\n    }\n    double diameter = abs(pg[ps] - pg[qs]);\n\n    int p = ps, q = qs, maxp = ps, maxq = qs;\n    do {\n        if(sgn(det(next(pg, p)-curr(pg, p), next(pg, q)-curr(pg, q))) >= 0)\n            q = (q+1) % n;\n        else\n            p = (p+1) % n;\n        double d = abs(pg[p] - pg[q]);\n        if(sgn(d - diameter) > 0){\n            diameter = d;\n            maxp = p;\n            maxq = q;\n        }\n    }while(p != ps || q != qs);\n    return diameter;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    Polygon pg;\n    for(int i=0;i<n;++i){\n        double x, y;\n        cin >> x >> y;\n        pg.push_back(Point(x, y));\n    }\n\n    printf(\"%.10f\\n\", convex_diameter(pg));\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int N = 200000 + 10;\nconst double EPS = 1e-7;\nconst double INF = 1e12;\nstruct Vec {\n    double x,y;\n    Vec() {}\n    Vec(double x, double y) { \n        this->x = x, this->y = y; \n    }\n    void read() { \n        scanf(\"%lf %lf\", &x, &y); \n    }\n    void prt() {\n        printf(\"%d %d\\n\", (int)x,(int)y); \n    }\n    double len() { \n        return sqrt(x * x + y * y); \n    }\n    double len2() { \n        return x * x + y * y; \n    }\n    bool operator <(const Vec& o)const {\n        if(y==o.y)\n            return x<o.x;\n        return y<o.y;\n    }\n    Vec operator +(const Vec& o)const { \n        return Vec(x + o.x, y + o.y); \n    }\n    Vec operator -(const Vec& o)const { \n        return Vec(x - o.x, y - o.y); \n    }\n    Vec operator *(const double& k)const { \n        return Vec(k * x, k * y); \n    }\n    double operator *(const Vec& o)const {\n        return x * o.x + y * o.y; \n    }\n    double operator ^(const Vec& o)const {\n        return x * o.y - y * o.x; \n    }\n    Vec rotate(double ang){ \n        return Vec(x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang)); \n    }\n    Vec change(double l) { \n        if(len() < EPS) return *this; \n        return (*this) * (l/len()); \n    }\n};\n\n\nstruct Line {\n    Vec A1, A2;\n    Line() {}\n    Line(Vec A1, Vec A2) {\n        this->A1 = A1, this->A2 = A2;\n    }\n    double len() {\n        return (A2-A1).len();\n    }\n    double Len2() {\n        return (A2-A1).len2();\n    }\n};\n\n\ndouble disToLine(Vec P, Line L) {\n    return abs((P-L.A1)^(L.A2-L.A1)) / L.len();\n}\nVec projection(Vec P, Line L) {\n    double shadowLen = (P - L.A1) * (L.A2 - L.A1);\n    return L.A1 + (L.A2-L.A1).change(shadowLen);\n}\nVec rojection(Vec P, Line L) {\n    return projection(P,L) * 2 - P;\n}\nbool onseg(Vec P, Line L) {\n    if(disToLine(P, L) > EPS) return 0;\n    return (P-L.A1) * (P-L.A2) <= 0;\n}\n\nVec Lineintersect(Line L1, Line L2) {\n    // 0 ~ (L2.A1 - L1.A1) ^ (L2.A2 - L1.A1);\n    // 1 ~ (L2.A1 - L1.A2) ^ (L2.A2 - L1.A2);\n    double F0 = (L2.A1 - L1.A1) ^ (L2.A2 - L1.A1);\n    double F1 = (L2.A1 - L1.A2) ^ (L2.A2 - L1.A2);\n    if (abs(F1 - F0) < EPS) return Vec(INF, INF);\n    return L1.A1 + (L1.A2 - L1.A1) * (- F0 / (F1 - F0));\n}\n\nVec Segintersect(Line L1, Line L2) {\n    Vec P = Lineintersect(L1, L2);\n    if (P.x == INF) return P;\n    if (onseg(P, L1) && onseg(P, L2)) return P;\n    return Vec(INF, INF);\n}\n\nbool disToSeg(Vec P, Line L) {\n    double ans = min((P-L.A1).len(), (P-L.A2).len());\n    ans = min(ans, (P - projection(P,L)).len());\n    return ans;\n}\n\n\nVec O;\nbool cmp(Vec A, Vec B) {\n    return ((A-O)^(B-O)) > 0 || (((A-O)^(B-O)) == 0 && (A-O).len() < (B-O).len());\n}\nstruct Polygon {\n    int n; \n    vector<Vec> v;\n    Polygon(){\n        n=0; v.clear();\n    }\n    void read() {\n        scanf(\"%d\", &n);\n        v.resize(2*n);\n        for(int i = 0; i < n; i ++){\n            Vec tmp; tmp.read();\n            v[i] = tmp;\n        }\n        sort(v.begin(), v.begin()+n);\n        v[n]=v[0]; v[n+1]=v[1];\n    }\n\n    double getArea() {\n        double ans=0;\n        for(int i=0;i<n;i++){\n            ans=ans+(v[i]^v[i+1]);\n        }\n        return abs(ans/2);\n    }\n    bool isConvex() {\n        for(int i=0;i<n;i++){\n            if( ((v[i+1]-v[i])^(v[i+2]-v[i+1])) < 0 )\n                return 0;\n        }\n        return 1;\n    }\n    int containVec(Vec P) {\n        int flag = 0;\n        for(int i=0;i<n;i++) {\n            if (onseg(P,Line(v[i], v[i+1]))) return 1;\n            Vec Q = Lineintersect(Line(P,Vec(P.x+1,P.y)),Line(v[i],v[i+1]));\n            if (Q.x == INF) continue;\n            if (onseg(Q, Line(v[i], v[i+1]))) {\n                if (abs(Q.y - min(v[i].y, v[i+1].y)) > EPS && Q.x >= P.x)\n                    flag ^= 1;\n            }\n        }\n        return flag?2:0;\n    }\n\n    Vec stk[N];int top;\n\n    void ConvexHull() {\n        O=v[0];\n        sort(v.begin() + 1, v.begin() + n, cmp);\n        int rig=n-1,lef=rig;\n        while(lef && ((v[lef]-O)^(v[rig]-O)) == 0) --lef;\n        reverse(v.begin()+lef+1,v.begin()+rig+1);\n\n        stk[0]=v[0], stk[1]=v[1]; top=1;\n        for(int i=2;i<n;i++) {\n            while(top && ((stk[top]-stk[top-1]) ^ (v[i]-stk[top])) <= EPS) --top;\n            stk[++top]=v[i];\n        }\n\n        n=top+1;\n        for(int i=0;i<=top;i++){\n            v[i]=stk[i];\n            //stk[i].prt()\n        }\n        v[n]=v[0], v[n+1]=v[1];\n    }\n    double Diameter() {\n        ConvexHull();\n        double ans=0;\n        for(int i=0,j=0;i<n;i++){\n            while((v[(j+1)%n]-v[i]).len() >= (v[j]-v[i]).len()) j=(j+1)%n;\n            ans=max(ans,(v[j]-v[i]).len());\n        }\n        return ans;\n    }\n} poly;\n\nint main(){\n    poly.read();\n    printf(\"%.8f\\n\", poly.Diameter());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int i=(a);i<(n);i++)\n#define per(i,a,n) for(int i=(n)-1;i>=(a);i--)\n#define MP make_pair\n\ntypedef double db;\n\nconst db EPS = 1e-8;\n\ninline int sign(db a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\ninline int cmp(db a, db b){\n\treturn sign(a-b);\n}\n\nstruct P {\n\tdb x, y;\n\tP() {\n\t}\n\tP(db _x, db _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(P p) {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(P p)  {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(db d) {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(db d) {\n\t\treturn P(x / d, y / d);\n\t}\n\tbool operator<(P p) const {\n\t\tint c = sign(x - p.x);\n\t\tif (c)\n\t\t\treturn c == -1;\n\t\treturn sign(y - p.y) == -1;\n\t}\n\tdb dot(P p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdb det(P p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb distTo(P p) { return (*this-p).abs(); }\n\n\tdb alpha() {\n\t\treturn atan2(y, x);\n\t}\n\tvoid read() {\n\t\tcin>>x>>y;\n\t}\n\tdb abs() {\n\t\treturn sqrt(abs2());\n\t}\n\tdb abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP rot90(){\n\t\treturn P(-y,x);\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\n\nP isLL(P p1, P p2, P q1, P q2) {\n\tdb a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nbool intersect(db l1,db r1,db l2,db r2){\n\tif(l1>r1) swap(l1,r1); if(l2>r2) swap(l2,r2); \n\treturn !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );\n}\n\nbool isSS(P p1, P p2, P q1, P q2){\n    return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) && \n    crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)\n            * crossOp(q1,q2,p2) <= 0;\n}\n\nbool isMiddle(db a, db m, db b) {\n    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\n \nbool isMiddle(P a, P m, P b) {\n    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);\n}\n\nbool onSeg(P p1, P p2, P q){\n\treturn crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);\n}\n\nP proj(P p1, P p2, P q) {\n    P dir = p2 - p1;\n    return p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\n\nP reflect(P p1, P p2, P q){\n\treturn proj(p1,p2,q) * 2 - q;\n}\n\ndb nearest(P p1,P p2,P q){\n\tP h = proj(p1,p2,q);\n\tif(isMiddle(p1,h,p2))\n\t\treturn q.distTo(h);\n\treturn min(p1.distTo(q),p2.distTo(q));\n}\n\ndb disSS(P p1, P p2, P q1, P q2){\n\tif(isSS(p1,p2,q1,q2)) return 0;\n\treturn min(min(nearest(p1,p2,q1),nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)) );\n}\n\ndb getrad(P p1,P p2){\n\treturn atan2l(p1.det(p2),p1.dot(p2));\n}\n\ndb incircle(P p1, P p2, P p3){\n\tdb A = p1.distTo(p2);\n\tdb B = p2.distTo(p3);\n\tdb C = p3.distTo(p1);\n\treturn sqrtl(A*B*C/(A+B+C));\n}\n\ndb area(vector<P> ps){\n\tdb ret = 0; rep(i,0,ps.size()) ret += ps[i].det(ps[(i+1)%ps.size()]); \n\treturn abs(ret/2);\n}\n\nint contain(vector<P> ps, P p){ //2:inside,1:on_seg,0:outside\n\tint n = ps.size(), ret = 0;\t\n\trep(i,0,n){\n\t\tP u=ps[i],v=ps[(i+1)%n];\n\t\tif(onSeg(u,v,p)) return 1;\n\t\tif(cmp(u.y,v.y)<=0) swap(u,v);\n\t\tif(cmp(p.y,u.y) >0 || cmp(p.y,v.y) <= 0) continue;\n\t\tret ^= crossOp(p,u,v) > 0;\n\t}\n\treturn ret*2;\n}\n\nvector<P> convexHull(vector<P> ps) {\n    int n = ps.size(); if(n <= 1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n * 2); int k = 0;\n    for (int i = 0; i < n; qs[k++] = ps[i++]) \n        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])\n       \twhile (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;\n    qs.resize(k - 1);\n    return qs;\n}\n\nvector<P> convexHullNonStrict(vector<P> ps) {\n    int n = ps.size(); if(n <= 1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n * 2); int k = 0;\n    for (int i = 0; i < n; qs[k++] = ps[i++]) \n        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])\n       \twhile (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;\n    qs.resize(k - 1);\n    return qs;\n}\n\ndb convexDiameter(vector<P> ps){\n\tint n = ps.size(); if(n <= 1) return 0;\n\tint is = 0, js = 0; rep(k,1,n) is = ps[k]<ps[is]?k:is, js = ps[js] < ps[k]?k:js;\n\tint i = is, j = js;\n\tdb ret = ps[i].distTo(ps[j]);\n\tdo{\n\t\tif((ps[(i+1)%n]-ps[i]).det(ps[(j+1)%n]-ps[j]) >= 0)\n\t\t\t(++j)%=n;\n\t\telse\n\t\t\t(++i)%=n;\n\t\tret = max(ret,ps[i].distTo(ps[j]));\n\t}while(i!=is || j!=js);\n\treturn ret;\n}\n\nint main(){\n\tint n;cin>>n;\n\tvector<P> ps(n);\n\trep(i,0,n) ps[i].read();\n\tprintf(\"%0.10f\\n\",convexDiameter(ps));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x*b.y - a.y*b.x;\n}\n\nVector normal(Point p0, Point p1); //ベクトルp0p1の法線ベクトル\nint argmax(const vector<double> &v); //std::vectorのargmax関数\n\nint main(){\n    #if 0\n    std::ifstream in(\"in21.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int n;\n    cin >> n;\n    vector<Point> data(n);\n\n    for(int i=0; i<n; i++){\n        cin >> data[i].x >> data[i].y;\n    }\n\n    Point p0, p1;\n    Vector nv;\n    vector<double> xNormalNoDup(0);\n    vector<Vector> normalVector(0);\n    xNormalNoDup.reserve(n);\n    normalVector.reserve(n);\n    map<double, int> isSwitchVertex;\n    map<double, int> isSwitchVertex0;\n    map<double, int> isSwitchVertex1;\n\n    for(int i=0; i<n; i++){\n        p0 = data[i];\n        p1 = data[(i+1)%n];\n        nv = normal(p0, p1);\n        normalVector.push_back(nv);\n        if (nv.y > 0 || nv.x == 1){\n            isSwitchVertex0[ nv.x ] += 1;\n            isSwitchVertex[ nv.x ] = 0;\n        }\n        else{\n            isSwitchVertex1[ -nv.x ] += 1;\n            isSwitchVertex[ -nv.x ] = 0;\n        }\n    }\n\n    //Extract keys of isSwitchVertex and sort\n    for(map<double,int>::iterator it = isSwitchVertex.begin(); it != isSwitchVertex.end(); ++it) {\n        xNormalNoDup.push_back(it->first);\n    }\n    sort(xNormalNoDup.begin(), xNormalNoDup.end(), greater<double>() );\n\n    //find the first pair\n    int pairIndex0 = -1; //upside\n    int pairIndex1 = -1; //downside\n    int change0, change1;\n    Vector nv0, nv1;\n    for(int i=0; i<n; i++){\n        nv0 = normalVector[i];\n        nv1 = normalVector[(i+1)%n];\n        if( nv0.y<0 && nv1.y>=0 ) pairIndex0 = (i+1)%n;\n        if( nv0.y>0 && nv1.y<=0 ) pairIndex1 = (i+1)%n;\n    }\n    if(pairIndex0<0 || pairIndex1<0) cout << \"ERROR: Pair Initialization failed.\";\n    //cout << \"First Pair\" << \" \" << pairIndex0 << \" \" << pairIndex1 << endl;\n\n    double maxDiameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n    double diameter = 0;\n\n    for(int i=0; i<xNormalNoDup.size(); i++){\n        change0 = isSwitchVertex0[ xNormalNoDup[i]];\n        change1 = isSwitchVertex1[ xNormalNoDup[i]];\n        //cout << \"flag:\" << change0 << \" \" << change1 << \" \";\n        pairIndex0 += change0;\n        pairIndex1 += change1;\n        pairIndex0 %= n;\n        pairIndex1 %= n;\n        diameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n        //if(diameter > maxDiameter) cout << pairIndex0 << \" \" << pairIndex1 << \" \" << diameter << endl;\n        maxDiameter = (diameter > maxDiameter)? diameter: maxDiameter;\n        //cout << pairIndex0 << \" \" << pairIndex1 << \" \" << maxDiameter << endl;\n    }\n\n    cout << setprecision(14) << maxDiameter << endl;\n\n    return 0;\n}\n\nVector normal(Point p0, Point p1){\n    Vector nv;\n    nv.x = - ( p1.y - p0.y );\n    nv.y = p1.x - p0.x;\n    double a = nv.abs();\n    return nv / a;\n}\n\nint argmax(const vector<double> &v){\n    return distance(v.begin(), max_element(v.begin(), v.end()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tint si=i,sj=j;\n\tR res=0.0;\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0){\n\t\t\ti=(i+1)%n;\n\t\t}else{\n\t\t\tj=(j+1)%n;\n\t\t}\n\t}\n\tassert(0==1);\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <array>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <stack>\n\nusing Number = double;\n\nconst Number EPS = 1e-10;\nconst Number INF = 1e10;\nconst Number PI = acos(-1.0);\n\ninline int sign(Number x) { return (x < -EPS) ? -1 : (x > EPS) ? +1 : 0; }\ninline bool equal(Number a, Number b) { return sign(a - b) == 0; }\n\n// change between degree and radian\ninline Number to_radian(const Number degree) { return degree * PI / 180.0; }\ninline Number to_degree(const Number radian) { return radian * 180.0 / PI; }\n\n\n/**\n * Point in two dimensional\n */\nclass Point {\npublic:\n    Number x, y;\n\n    Point() {}\n    Point(Number x, Number y) : x(x), y(y) {}\n\n    // Arithmetic operator between points\n    Point operator+(const Point &rhs) const {\n        return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n        return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n    Point operator*(const Point &rhs) const { // cross product between points\n        return Point(this->x * rhs.x - this->y * rhs.y,\n                     this->x * rhs.y + this->y * rhs.x);\n    }\n\n    // Unary operator and compound assignment operator\n    Point operator-() const {\n        return Point(-this->x, -this->y);\n    }\n    Point& operator+=(const Point &rhs) {\n        return *this = *this + rhs;\n    }\n    Point& operator-=(const Point &rhs) {\n        return *this = *this - rhs;\n    }\n\n    // Arithmetic operator between point and number\n    Point operator*(Number rhs) const {\n        return Point(this->x * rhs, this->y * rhs);\n    }\n    Point operator/(Number rhs) const {\n        return Point(this->x / rhs, this->y / rhs);\n    }\n\n    // Comparison operation\n    bool operator==(const Point &rhs) const {\n        return sign(this->x - rhs.x) == 0 && sign(this->y - rhs.y) == 0;\n    }\n    bool operator<(const Point &rhs) const {\n        return (this->x < rhs.x) || (this->x == rhs.x && this->y < rhs.y);\n    }\n\n    // Other operator\n    Number abs(void) const {\n        return sqrt(this->x * this->x + this->y * this->y);\n    }\n    Number abs2(void) const {\n        return this->x * this->x + this->y * this->y;\n    }\n    Number arg(void) const {\n        return atan2(this->y, this->x);\n    }\n    Number dot(const Point &rhs) {\n        return this->x * rhs.x + this->y * rhs.y;\n    }\n    Point rotate90(void) const {\n        return Point(-this->y, this->x);\n    }\n    Point rotate(double angle) const {\n        return Point(cos(angle) * this->x - sin(angle) * this->y,\n                     sin(angle) * this->x + cos(angle) * this->y);\n    }\n\n};\ninline Number dot(const Point &p1, const Point &p2) {\n    return p1.x * p2.x + p1.y * p2.y;\n}\ninline Number abs_cross(const Point &p1, const Point &p2) {\n    return p1.x * p2.y - p1.y * p2.x;\n}\n// Output of a point\nstd::ostream& operator<<(std::ostream &os, const Point &p) {\n    return os << p.x << ' ' << p.y;\n}\n// Input of a point\nstd::istream& operator>>(std::istream &is, Point &p) {\n    return is >> p.x >> p.y;\n}\n\n// Counter-Clockwise predicate (a, b, c)\nenum CCW {\n    COUNTER_CLOCKWISE = 1,      // counter clockwise\n    CLOCKWISE         = -1,     // clockwise\n    ONLINE_FRONT      = 2,      // a--c--b on line\n    ONLINE_BACK       = -2,      // c--a--b on line\n    ON_SEGMENT        = 0,     // a--b--c on line\n    OTHER             = -3,\n};\nCCW ccw(const Point &a, Point b, Point c) {\n    b -= a;  c -= a;\n    if (sign(abs_cross(b, c)) == 1) return COUNTER_CLOCKWISE;\n    if (sign(abs_cross(b, c)) == -1) return CLOCKWISE;\n    if (sign(dot(b, c)) == -1)       return ONLINE_BACK;\n    if (sign(b.abs2() - c.abs2()) == -1)   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n\n/**\n * Line in two dimensional\n */\nclass Line : public std::array<Point, 2> {\npublic:\n    Line() {}\n    Line(const Point &p1, const Point &p2) {\n        (*this)[0] = p1;\n        (*this)[1] = p2;\n    }\n};\n// Input of a line\nstd::istream& operator>>(std::istream &is, Line &l) {\n    return is >> l[0] >> l[1];\n}\n// Output of a line\nstd::ostream& operator<<(std::ostream &os, const Line &l) {\n    return os << l[0] << ' ' << l[1];\n}\ninline CCW ccw(const Line &l, const Point &p) {\n    return ccw(l[0], l[1], p);\n}\n\n\n/**\n * Segment in two dimensional\n */\nclass Segment : public Line {\npublic:\n    Segment() {}\n    Segment(const Point &p1, const Point &p2) : Line(p1, p2) {}\n};\n\n\n/**\n * Circle in two dimensional\n */\nclass Circle : public Point {\npublic:\n    Number r;\n    Circle() {}\n    Circle(const Point &p, Number r = 0.0) : Point(p), r(r) {}\n};\n// Input of a circle\nstd::istream& operator>>(std::istream &is, Circle &c) {\n    return is >> c.x >> c.y >> c.r;\n}\n\n\n\n/**\n * Intersection testing\n */\nPoint Projection(const Line &l, const Point &p) {\n    Point dir = l[1] - l[0];\n    Number t = dot(p - l[0], dir) / dir.abs2();\n    return l[0] + dir * t;\n}\ninline Point Reflection(const Line &l, const Point &p) {\n    return Projection(l, p) * 2.0 - p;\n}\n\ninline bool IsOrthogonal(const Line &l1, const Line &l2) {\n    return equal(dot(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\ninline bool IsParallel(const Line &l1, const Line &l2) {\n    return equal(abs_cross(l1[0] - l1[1], l2[0] - l2[1]), 0.0);\n}\n\ninline bool IsIntersect(const Line &l, const Point &p) {\n    return abs(ccw(l[0], l[1], p)) != 1;\n}\ninline bool IsIntersect(const Segment &s, const Point &p) {\n    return ccw(s[0], s[1], p) == ON_SEGMENT;\n}\ninline bool IsIntersect(const Line &l1, const Line l2) {\n    return !IsParallel(l1, l2) || IsParallel(l1, Line(l1[0], l2[0]));\n}\ninline bool IsIntersect(const Line &l, const Segment &s) {\n    return abs_cross(l[1] - l[0], s[0] - l[0]) *\n        abs_cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\ninline bool IsIntersect(const Segment &s1, const Segment &s2) {\n    return ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n        ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\ninline bool IsIntersect(const Circle &c, const Point &p) { // p is in interior or boundary\n    return (c - p).abs() <= c.r + EPS;\n}\ninline bool IsIntersect(const Circle &c, const Line &l) {\n    return IsIntersect(c, Projection(l, c));\n}\ninline bool IsIntersect(const Circle &c1, const Circle &c2) {\n    return sign(c1.r + c2.r - (c1 - c2).abs()) >= 0 &&\n        sign((c1 - c2).abs() - abs(c1.r - c2.r) >= 0);\n}\n\n\n/**\n * Distance and Intersection point\n */\ninline Number Distance(const Point &p1, const Point &p2) {\n    return (p1 - p2).abs();\n}\ninline Number Distance(const Line &l, const Point &p) {\n    return (p - Projection(l, p)).abs();\n}\ninline Number Distance(const Segment &s, const Point &p) {\n    if (sign(dot(s[1] - s[0], p - s[0])) == -1) return (p - s[0]).abs();\n    if (sign(dot(s[0] - s[1], p - s[1])) == -1) return (p - s[1]).abs();\n    return (p - Projection(s, p)).abs();\n}\ninline Number Distance(const Line &l1, const Line &l2) {\n    return IsIntersect(l1, l2) ? 0 : Distance(l1, l2[0]);\n}\ninline Number Distance(const Line &l, const Segment &s) {\n    if (IsIntersect(l, s)) return 0.0;\n    return std::min(Distance(l, s[0]), Distance(l, s[1]));\n}\ninline Number Distance(const Segment &s1, const Segment &s2) {\n    if (IsIntersect(s1, s2)) return 0.0;\n    return std::min({Distance(s1, s2[0]), Distance(s1, s2[1]),\n                Distance(s2, s1[0]), Distance(s2, s1[1])});\n}\n\nPoint CrossPoint(const Line &s1, const Line &s2) {\n    Point base = s2[1] - s2[0];\n    Number d1 = abs(abs_cross(base, s1[0] - s2[0]));\n    Number d2 = abs(abs_cross(base, s1[1] - s2[0]));\n    Number t = d1 / (d1 + d2);\n    return s1[0] + (s1[1] - s1[0]) * t;\n}\nstd::vector<Point> CrossPoint(const Circle &c, const Line &l) {\n    if (!IsIntersect(c, l))\n        return std::vector<Point>();\n    Point mid = Projection(l, c);\n    if (equal((c - mid).abs(), c.r))\n        return {mid};\n\n    Point e = (l[1] - l[0]) / (l[1] - l[0]).abs();\n    Number len = sqrt(c.r * c.r - (mid - c).abs2());\n    return {mid + e * len, mid - e * len};\n}\nstd::vector<Point> CrossPoint(const Circle &c1, const Circle &c2) {\n    if (!IsIntersect(c1, c2))\n        return std::vector<Point>();\n    Number d = Distance(c1, c2);\n    Number r1_cos = (d * d + c1.r * c1.r - c2.r * c2.r) / (2.0 * d);\n    Number h = sqrt(c1.r * c1.r - r1_cos * r1_cos);\n    Point base = c1 + (c2 - c1) * r1_cos / d;\n    Point dir = (c2 - c1).rotate90() * h / d;\n    if (dir == Point(0, 0))\n        return {base};\n    return {base + dir, base - dir};\n}\n\n\n// the tangent line from a point to a circle\nstd::vector<Point> TangentPoint(const Circle &c, const Point &p) {\n    Number x = (p - c).abs2();\n    Number d = x - c.r * c.r;\n    if (sign(d) == -1) // no point\n        return std::vector<Point>();\n    d = std::max(d, 0.0);\n    Point q1 = (p - c) * (c.r * c.r / x);\n    Point q2 = ((p - c) * (-c.r * sqrt(d) / x)).rotate90();\n    if (q2 == Point(0, 0)) return {c + q1};\n    return {c + q1 - q2, c + q1 + q2};\n}\n// common tangent lines to two circles\nstd::vector<Line> CommonTangent(const Circle &c1, const Circle &c2) {\n    // two circle contact one point internally\n    if (equal(Distance(c1, c2), abs(c1.r - c2.r))) { // |  $ $|\n        Point cross_point = CrossPoint(c1, c2)[0];\n        Point up = (cross_point - c1).rotate90();\n        return {Line(cross_point + up, cross_point - up)};\n    }\n\n    std::vector<Line> list;\n\n    // caluculate outer tangent\n    if (equal(c1.r, c2.r)) {\n        Point dir = c2 - c1;\n        dir = (dir * (c1.r / dir.abs())).rotate90();\n        list.emplace_back(Line(c1 + dir, c2 + dir));\n        list.emplace_back(Line(c1 - dir, c2 - dir));\n    }\n    else {\n        Point p = (c1 * (-c2.r)) + (c2 * c1.r);\n        p = p * (1 / (c1.r - c2.r));\n        std::vector<Point> ps = TangentPoint(c1, p);\n        std::vector<Point> qs = TangentPoint(c2, p);\n        const int N = std::min(ps.size(), qs.size());\n        for (int i = 0; i < N; ++i)\n            list.emplace_back(Line(ps[i], qs[i]));\n    }\n\n    // caluculate inner tangent\n    if (equal(Distance(c1, c2), c1.r + c2.r)) {\n        // two circle contact one point outernally | |$ $\n        Point cross_point = CrossPoint(c1, c2)[0];\n        Point up = (cross_point - c1).rotate90();\n        list.emplace_back(Line(cross_point + up, cross_point - up));\n    }\n    else { // | |  $ $\n        Point p = (c1 * c2.r) + (c2 * c1.r);\n        p = p * (1 / (c1.r + c2.r));\n        std::vector<Point> ps = TangentPoint(c1, p);\n        std::vector<Point> qs = TangentPoint(c2, p);\n        const int N = std::min(ps.size(), qs.size());\n        for (int i = 0; i < N; ++i)\n            list.emplace_back(Line(ps[i], qs[i]));\n    }\n\n    return list;\n}\n\n\n/**\n * Polygon\n */\nclass Polygon : public std::vector<Point> {\npublic:\n    Polygon() {}\n    Polygon(int size) : std::vector<Point>(size){}\n    Polygon(std::initializer_list<Point> p) : std::vector<Point>(p) {}\n\n    Number Area() const; // area of polygon : O(n)\n    bool IsConvex() const; // Test whether it's convex polygon : O(n)\n    std::vector<Point> ConvexHull() const; // Andrew's Monotone Chain Algorithm : O(n * log n)\n    Number ConvexDiameter() const; // rotating calipers algorithm : O(n)\n\n    // Is p contained or on segment or otherwise? : O(n)\n    enum { OUT, ON, IN, };\n    int Contain(const Point &p) const;\n    // convex version : O(log n)\n    int ConvexContain(const Point &p) const;\n\n};\n\n// Output of a polygon\nstd::ostream& operator<<(std::ostream &os, const Polygon &poly) {\n    for (auto p : poly) os << p << \", \";\n    return os;\n}\nNumber Polygon::Area() const {\n    const int n = (*this).size();\n    assert(1 < n);\n\n    Number area = abs_cross((*this)[n - 1], (*this)[0]);\n    for (int i = 0; i < n - 1; ++i)\n        area += abs_cross((*this)[i], (*this)[i + 1]);\n    return 0.5 * area;\n}\nbool Polygon::IsConvex() const {\n    const int n = (*this).size();\n    CCW diff = OTHER;\n    for (int i = 0; i < n; ++i) {\n        CCW cur = ccw((*this)[i], (*this)[(i + 1) % n], (*this)[(i + 2) % n]);\n        if (diff == OTHER && (cur == CLOCKWISE || cur == COUNTER_CLOCKWISE))\n            diff = static_cast<CCW>(-cur);\n        else if (cur == diff) return false;\n    }\n    return true;\n}\nint Polygon::Contain(const Point &p) const {\n    const int n = (*this).size();\n    bool count = false;\n    for (int i = 0; i < n; ++i) {\n        if (IsIntersect(Segment((*this)[i], (*this)[(i + 1) % n]), p))\n            return ON;\n        Point up = (*this)[i] - p, down = (*this)[(i + 1) % n] - p;\n        if (up.y < down.y)\n            std::swap(up, down);\n        if (sign(down.y) <= 0 && sign(up.y) == 1 && sign(abs_cross(up, down)) == 1)\n            count = !count;\n    }\n    return count ? IN : OUT;\n}\nint Polygon::ConvexContain(const Point &p) const {\n    const int n = (*this).size();\n    Point g = ((*this)[0] + (*this)[n / 3] + (*this)[2 * n / 3]) / 3.0; // inner point\n    int a = 0, b = n;\n\n    while (a + 1 < b) { // invariant : c is in fan g-poly[a]-poly[b]\n        int c = (a + b) * 0.5;\n        if (sign(abs_cross((*this)[a] - g, (*this)[c] - g)) == 1) { // angle < 180 deg\n            if (sign(abs_cross((*this)[a] - g, p - g)) >= 0 &&\n                sign(abs_cross((*this)[c] - g, p - g)) == -1)\n                b = c;\n            else\n                a = c;\n        }\n        else {\n            if (sign(abs_cross((*this)[a] - g, p - g)) == -1 &&\n                sign(abs_cross((*this)[c] - g, p - g)) == 1)\n                a = c;\n            else\n                b = c;\n        }\n    }\n\n    // Assume that points in polygon are in the order of counter-clockwise\n    b %= n;\n    int res = sign(abs_cross((*this)[a] - p, (*this)[b] - p));\n    return (res == -1 ? OUT : (res == 1 ? IN : ON));\n}\nstd::vector<Point> Polygon::ConvexHull() const {\n    if ((*this).size() < 3) return (*this);\n\n    Polygon poly = (*this);\n    const int n = poly.size();\n    int size = 0;\n    std::vector<Point> chain(2 * n);\n\n    std::sort(poly.begin(), poly.end());\n\n    for (int i = 0; i < n; chain[size++] = poly[i++])  // lower hull\n        while (size >= 2 && ccw(chain[size - 2], chain[size - 1], poly[i]) <= 0)\n            --size;\n    for (int i = n - 2, j = size + 1; 0 <= i; chain[size++] = poly[i--])  // upper hull\n        while (size >= j && ccw(chain[size - 2], chain[size - 1], poly[i]) <= 0)\n            --size;\n    chain.resize(size - 1);\n    return chain;\n}\nNumber Polygon::ConvexDiameter() const {\n    const int n = (*this).size();\n    const Polygon &poly = (*this);\n\n    std::pair<int, int> s; // first is min, second is max\n    for (int i = 1; i < n; ++i) {\n        if (poly[i].y < poly[s.first].y) s.first = i;\n        if (poly[i].y > poly[s.second].y) s.second = i;\n    }\n\n    Number max_d = Distance(poly[s.first], poly[s.second]);\n    std::pair<int, int> cur(s), max_p(s);\n\n    // Assumpution: given polygon is ordered in counter-clockwise\n    do {\n        Point v1 = poly[cur.second] - poly[(cur.second + 1) % n] + poly[cur.first];\n        if (ccw(poly[cur.first], poly[(cur.first + 1) % n], v1) == COUNTER_CLOCKWISE)\n            cur.first = (cur.first + 1) % n;\n        else\n            cur.second = (cur.second + 1) % n;\n\n        Number cur_d = Distance(poly[cur.first], poly[cur.second]);\n        if (max_d < cur_d) {\n            max_p = cur;\n            max_d = cur_d;\n        }\n    } while (cur != s);\n\n    return max_d;\n}\n\n\nint main()\n{\n    std::cout << std::fixed << std::setprecision(10);\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n\n    int n;\n\n    std::cin >> n;\n    Polygon poly(n);\n    for (int i = 0; i < n; ++i)\n        std::cin >> poly[i];\n\n    std::cout << poly.ConvexDiameter() << std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define TemplateVersion \"3.4.0\"\n// Useful Marcos\n//====================START=====================\n// Compile use C++11 and above\n#ifdef LOCAL\n#define debug(args...)                           \\\n    {                                            \\\n        string _s = #args;                       \\\n        replace(_s.begin(), _s.end(), ',', ' '); \\\n        stringstream _ss(_s);                    \\\n        istream_iterator<string> _it(_ss);       \\\n        err(_it, args);                          \\\n    }\nvoid err(istream_iterator<string> it)\n{\n}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\n#define MSG cout << \"Finished\" << endl\n#else\n#define debug(args...)\n#define MSG\n#endif\n#if __cplusplus >= 201703L\ntemplate <typename... Args>\nvoid readln(Args &... args)\n{\n    ((cin >> args), ...);\n}\ntemplate <typename... Args>\nvoid writeln(Args... args)\n{\n    ((cout << args << \" \"), ...);\n    cout << endl;\n}\n#elif __cplusplus >= 201103L\nvoid readln()\n{\n}\ntemplate <typename T, typename... Args>\nvoid readln(T &a, Args &... args)\n{\n    cin >> a;\n    readln(args...);\n}\nvoid writeln()\n{\n    cout << endl;\n}\ntemplate <typename T, typename... Args>\nvoid writeln(T a, Args... args)\n{\n    cout << a << \" \";\n    writeln(args...);\n}\n#endif\n#if __cplusplus >= 201103L\n#define FOR(_i, _begin, _end) for (auto _i = _begin; _i < _end; _i++)\n#define FORR(_i, _begin, _end) for (auto _i = _begin; _i > _end; _i--)\n#else\n#define FOR(_i, _begin, _end) for (int _i = (int)_begin; _i < (int)_end; _i++)\n#define FORR(_i, _begin, _end) for (int _i = (int)_begin; _i > (int)_end; _i--)\n#define nullptr NULL\n#endif\n#if __cplusplus >= 201103L\n#define VIS(_kind, _name, _size) \\\n    vector<_kind> _name(_size);  \\\n    for (auto &i : _name)        \\\n        cin >> i;\n#else\n#define VIS(_kind, _name, _size)    \\\n    vector<_kind> _name;            \\\n    _name.resize(_size);            \\\n    for (int i = 0; i < _size; i++) \\\n        cin >> _name[i];\n#endif\n// alias\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define tcase() \\\n    int T;      \\\n    cin >> T;   \\\n    FOR(kase, 1, T + 1)\n// Swap max/min\ntemplate <typename T>\nbool smax(T &a, const T &b)\n{\n    if (a > b)\n        return false;\n    a = b;\n    return true;\n}\ntemplate <typename T>\nbool smin(T &a, const T &b)\n{\n    if (a < b)\n        return false;\n    a = b;\n    return true;\n}\n// ceil divide\ntemplate <typename T>\nT cd(T a, T b)\n{\n    return (a + b - 1) / b;\n}\n// min exchange\ntemplate <typename T>\nbool se(T &a, T &b)\n{\n    if (a < b)\n        return false;\n    swap(a, b);\n    return true;\n}\n// A better MAX choice\nconst int INF = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef set<int> si;\ntypedef vector<string> cb;\n//====================END=====================\n\n// Constants here\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst double FAC = 1e-18;\n\ntypedef double db;\n\nint sgn(db x)\n{\n    if (abs(x) < EPS)\n        return 0;\n    if (x < 0)\n        return -1;\n    return 1;\n}\n\ninline db sqr(db x) { return x * x; }\n\n// Point/Vector\nstruct Point\n{\n    db x, y;\n\n    Point() : x(0.0), y(0.0) {}\n\n    Point(db _x, db _y) : x(_x), y(_y) {}\n\n    bool operator==(const Point &p)\n    {\n        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;\n    }\n\n    bool operator<(const Point &p)\n    {\n        int c = sgn(x - p.x);\n        if (c)\n            return c == -1;\n        return sgn(y - p.y) == -1;\n    }\n\n    Point operator+(const Point &p) { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point &p) { return Point(x - p.x, y - p.y); }\n    Point operator*(db d) { return Point(x * d, y * d); }\n    Point operator/(db d) { return Point(x / d, y / d); }\n\n    db operator^(const Point &p) { return x * p.y - y * p.x; }\n    db operator*(const Point &p) { return x * p.x + y * p.y; }\n\n    db dis(const Point &p) { return (*this - p).len(); }\n    db alpha() { return atan2(y, x); }\n\n    Point unit() { return *this / len(); }\n    Point scale(db r) { return unit() * r; }\n\n    Point rotCC() { return Point(-y, x); }\n    Point rotCL() { return Point(y, -x); }\n\n    Point rot(Point p, db angle)\n    {\n        Point v = *this - p;\n        db c = cos(angle), s = sin(angle);\n        return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);\n    }\n\n    db len() { return hypot(x, y); }\n    db len2() { return x * x + y * y; }\n\n    db rad(Point a, Point b)\n    {\n        Point ap = a - *this, bp = b - *this;\n        return abs(atan2(abs(ap ^ bp), ap * bp));\n    }\n\n    // Point P,A,B\n    // -2 -> B is at back of PA\n    // -1 -> PB is on the clock-wise side of PA\n    // 0 -> B is on PA\n    // 1 -> PB is on the counter clock-wise side of PA\n    // 2 -> B is at the front of PA\n    int relation(Point a, Point b)\n    {\n        Point p = *this;\n        if (sgn((a - p) ^ (b - p)) > 0)\n            return 1;\n        if (sgn((a - p) ^ (b - p)) < 0)\n            return -1;\n        if (sgn((a - p) * (b - p)) < 0)\n            return -2;\n        if (sgn((p - a) * (b - a)) < 0)\n            return 2;\n        return 0;\n    }\n\n    void read() { cin >> x >> y; }\n    void write(char trail = ' ') { cout << x << ' ' << y << trail; }\n    void Debug() { cerr << \"Point: (\" << x << \", \" << y << \")\\n\"; }\n};\n\ndb cross(Point a, Point b, Point c) { return (b - a) ^ (c - a); }\n\n// Line\nstruct Line\n{\n    Point s, e;\n\n    Line(){};\n\n    Line(Point _s, Point _e) : s(_s), e(_e) {}\n\n    Line(Point p, db angle)\n    {\n        s = p;\n        if (sgn(angle - PI / 2))\n            e = (s + Point(1, tan(angle)));\n        else\n            e = (s + Point(0, 1));\n    }\n\n    //ax+by+c=0\n    Line(db a, db b, db c)\n    {\n        if (sgn(a) == 0)\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -c / b);\n        }\n        else if (sgn(b) == 0)\n        {\n            s = Point(-c / a, 0);\n            e = Point(-c / a, 1);\n        }\n        else\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -(c + a) / b);\n        }\n    }\n\n    db len() { return s.dis(e); }\n    db angle()\n    {\n        db ans = atan2(e.y - s.y, e.x - s.x);\n        if (sgn(ans) == -1)\n            ans += PI;\n        if (sgn(ans - PI) == 0)\n            ans -= PI;\n        return ans;\n    }\n\n    int relation(Point p) { return s.relation(e, p); }\n\n    bool parallel(Line l) { return sgn((e - s) ^ (l.e - l.s)) == 0; }\n\n    // 0 -> Not Intersect\n    // 1 -> Informal\n    // 2 -> Formal Intersection\n    int crossSS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        int d3 = sgn((l.e - l.s) ^ (s - l.s));\n        int d4 = sgn((l.e - l.s) ^ (e - l.s));\n        if ((d1 ^ d2) == -2 && (d3 ^ d4) == -2)\n            return 2;\n        return (d1 == 0 && sgn((l.s - s) * (l.s - e)) <= 0) ||\n               (d2 == 0 && sgn((l.e - s) * (l.e - e)) <= 0) ||\n               (d3 == 0 && sgn((s - l.s) * (s - l.e)) <= 0) ||\n               (d4 == 0 && sgn((e - l.s) * (e - l.e)) <= 0);\n    }\n\n    // 0 -> Not Intersect\n    // 1 -> Informal\n    // 2 -> Formal Intersection\n    int crossLS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        if ((d1 ^ d2) == -2)\n            return 2;\n        return (d1 == 0 || d2 == 0);\n    }\n\n    // 0 -> Parallel\n    // 1 -> Same\n    // 2 -> Intersect\n    int crossLL(Line l)\n    {\n        if (this->parallel(l))\n            return l.relation(s) == 3;\n        return 2;\n    }\n\n    Point intersec(Line l)\n    {\n        db a1 = (l.e - l.s) ^ (s - l.s);\n        db a2 = (l.e - l.s) ^ (e - l.s);\n        return Point((s.x * a2 - e.x * a1) / (a2 - a1), (s.y * a2 - e.y * a1) / (a2 - a1));\n    }\n\n    db disPL(Point p) { return abs((p - s) ^ (e - s)) / len(); }\n    db disPS(Point p)\n    {\n        if (sgn((p - s) * (e - s)) < 0 || sgn((p - e) * (s - e)) < 0)\n            return min(p.dis(s), p.dis(e));\n        return disPL(p);\n    }\n    db disSS(Line l) { return min(min(disPS(l.s), disPS(l.e)), min(l.disPS(s), l.disPS(e))); }\n\n    Point proj(Point p) { return s + ((e - s) * ((e - s) * (p - s))) / ((e - s).len2()); }\n    Point refl(Point p)\n    {\n        Point q = proj(p);\n        return Point(2 * q.x - p.x, 2 * q.y - p.y);\n    }\n\n    bool operator==(Line l) { return s == l.s && e == l.e; }\n\n    void adjust()\n    {\n        if (e < s)\n            swap(s, e);\n    }\n\n    void read()\n    {\n        s.read();\n        e.read();\n    }\n\n    void Debug() { cerr << \"Line: Start: (\" << s.x << \", \" << s.y << \") End: (\" << e.x << \", \" << e.y << \")\\n\"; }\n};\n\n// Circle\nstruct Circle\n{\n    Point p;\n    db r;\n\n    Circle(){};\n\n    Circle(Point _p, db _r) : p(_p), r(_r) {}\n\n    Circle(db x, db y, db _r) : p({x, y}), r(_r) {}\n\n    Circle(Point a, Point b, Point c, bool in = false)\n    {\n        if (!in)\n        {\n            Line u = Line((a + b) / 2, (a + b) / 2 + (b - a).rotCC());\n            Line v = Line((b + c) / 2, (b + c) / 2 + (c - b).rotCC());\n            p = u.intersec(v);\n            r = p.dis(a);\n        }\n        else\n        {\n            Line u, v;\n            db m = atan2(b.y - a.y, b.x - a.x), n = atan2(c.y - a.y, c.x - a.x);\n            u.s = a;\n            u.e = a + Point(cos((n + m) / 2), sin((n + m) / 2));\n            v.s = b;\n            m = atan2(a.y - b.y, a.x - b.x), n = atan2(c.y - b.y, c.x - b.x);\n            v.e = b + Point(cos((n + m) / 2), sin((n + m) / 2));\n            p = u.intersec(v);\n            r = Line(a, b).disPS(p);\n        }\n    }\n\n    bool operator==(const Circle &c) { return p == c.p && sgn(r - c.r) == 0; }\n\n    bool operator<(const Circle &c) { return (p < c.p) || (p == c.p && sgn(r - c.r) < 0); }\n\n    db area() { return PI * r * r; }\n\n    db cir() { return 2 * PI * r; }\n\n    Point on(db ang) { return Point(p.x + r * cos(ang), p.y + r * sin(ang)); }\n\n    // 0 -> Outside\n    // 1 -> On\n    // 2 -> Inside\n    int relationP(Point v)\n    {\n        db dis = v.dis(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // The number of intersections\n    int relationS(Line l)\n    {\n        db dis = l.disPS(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // The number of intersections\n    int relationL(Line l)\n    {\n        db dis = l.disPL(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // 1 -> Inside\n    // 2 -> Internally-tangent\n    // 3 -> Intersect\n    // 4 -> Externally-tangent\n    // 5 -> Disjoint\n    int relationC(Circle c)\n    {\n        db d = p.dis(c.p);\n        if (sgn(d - r - c.r) > 0)\n            return 5;\n        if (sgn(d - r - c.r) == 0)\n            return 4;\n        db l = abs(r - c.r);\n        if (sgn(d - r - c.r) < 0 && sgn(d - l) > 0)\n            return 3;\n        if (sgn(d - l) == 0)\n            return 2;\n        // TODO: Check if this one is necessary\n        // if (sgn(d - l) < 0)\n        return 1;\n    }\n\n    // The return value is the number of intersections\n    int crossC(Circle c, Point &p1, Point &p2)\n    {\n        int re = relationC(c);\n        if (re == 1 || re == 5)\n            return 0;\n        db d = p.dis(c.p), l = (d * d + r * r - c.r * c.r) / (2.0 * d), h = sqrt(r * r - l * l);\n        Point tmp = p + (c.p - p).scale(l);\n        p1 = tmp + (c.p - p).rotCC().scale(h);\n        p2 = tmp + (c.p - p).rotCL().scale(h);\n        if (re == 2 || re == 4)\n            return 1;\n        return 2;\n    }\n\n    // Same as above\n    int crossL(Line l, Point &p1, Point &p2)\n    {\n        if (!this->relationL(l))\n            return 0;\n        Point a = l.proj(p);\n        db d = l.disPL(p);\n        d = sqrt(r * r - d * d);\n        if (sgn(d) == 0)\n        {\n            p1 = a;\n            p2 = a;\n            return 1;\n        }\n        p1 = a + (l.e - l.s).scale(d);\n        p2 = a - (l.e - l.s).scale(d);\n        return 2;\n    }\n\n    int tangent(Point q, Point &u, Point &v)\n    {\n        int x = relationP(q);\n        if (x == 2)\n            return 0;\n        if (x == 1)\n        {\n            u = q + (q - p).rotCC();\n            v = u;\n            return 1;\n        }\n        db d = p.dis(q);\n        db l = r * r / d;\n        db h = sqrt(r * r - l * l);\n        u = p + ((q - p).scale(l) + (q - p).rotCC().scale(h));\n        v = p + ((q - p).scale(l) + (q - p).rotCL().scale(h));\n        return 2;\n    }\n\n    int tangent(Circle c, vector<Point> &u, vector<Point> &v)\n    {\n        if (sgn(r - c.r) < 0)\n            return c.tangent(*this, v, u);\n\n        int ret = relationC(c) - 1;\n        if (!ret || *this == c)\n            return 0;\n        u.clear();\n        v.clear();\n\n        db b = (c.p - p).alpha();\n\n        if (ret == 1 || ret == 3)\n        {\n            u.push_back(on(b));\n            v.push_back(on(b));\n        }\n\n        db ang = acos((r - c.r) / p.dis(c.p));\n\n        if (ret != 1)\n        {\n            u.push_back(on(b + ang));\n            u.push_back(on(b - ang));\n            v.push_back(c.on(b + ang));\n            v.push_back(c.on(b - ang));\n        }\n\n        if (ret == 4)\n        {\n            ang = acos((r + c.r) / p.dis(c.p));\n            u.push_back(on(b + ang));\n            u.push_back(on(b - ang));\n            v.push_back(c.on(PI + b + ang));\n            v.push_back(c.on(PI + b - ang));\n        }\n\n        return ret;\n    }\n\n    // The area of intersecting space\n    // With circle c\n    db area(Circle c)\n    {\n        int re = relationC(c);\n        if (re >= 4)\n            return 0;\n        if (re <= 2)\n            return min(area(), c.area());\n        db d = p.dis(c.p);\n        db hf = (r + c.r + d) / 2.0;\n        db ss = 2 * sqrt(hf * (hf - r) * (hf - c.r) * (hf - d));\n        db a1 = acos((r * r + d * d - c.r * c.r) / (2.0 * r * d));\n        a1 = a1 * r * r;\n        db a2 = acos((c.r * c.r + d * d - r * r) / (2.0 * c.r * d));\n        a2 = a2 * c.r * c.r;\n        return a1 + a2 - ss;\n    }\n\n    // The area of intersecting space\n    // With triangle PAB\n    db area(Point a, Point b)\n    {\n        if (sgn((p - a) ^ (p - b)) == 0)\n            return 0.0;\n        Point q[5];\n        int len = 0;\n        q[len++] = a;\n        Line l(a, b);\n        Point p1, p2;\n        if (crossL(l, q[1], q[2]) == 2)\n        {\n            if (sgn((a - q[1]) * (b - q[1])) < 0)\n                q[len++] = q[1];\n            if (sgn((a - q[2]) * (b - q[2])) < 0)\n                q[len++] = q[2];\n        }\n        q[len++] = b;\n        if (len == 4 && sgn((q[0] - q[1]) * (q[2] - q[1])) > 0)\n            swap(q[1], q[2]);\n        db res = 0;\n        for (int i = 0; i < len - 1; i++)\n        {\n            if (relationP(q[i]) == 0 || relationP(q[i + 1]) == 0)\n            {\n                db arg = p.rad(q[i], q[i + 1]);\n                res += r * r * arg / 2.0;\n            }\n            else\n                res += abs((q[i] - p) ^ (q[i + 1] - p)) / 2.0;\n        }\n        return res;\n    }\n\n    // Two circle whose center are a and b respectivelly\n    static int GetCircle(Point a, Point b, db r, Circle &c1, Circle &c2)\n    {\n        Circle x(a, r), y(b, r);\n        int t = x.crossC(y, c1.p, c2.p);\n        if (!t)\n            return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n\n    // The circle which tangent is l and point p on it\n    static int GetCircle(Line l, Point p, db r, Circle &c1, Circle &c2)\n    {\n        db dis = l.disPL(p);\n        if (sgn(dis - r * 2) > 0)\n            return 0;\n        if (sgn(dis) == 0)\n        {\n            c1.p = p + ((l.e - l.s).rotCC().scale(r));\n            c2.p = p + ((l.e - l.s).rotCL().scale(r));\n            c1.r = c2.r = r;\n            return 2;\n        }\n        Line u1 = Line((l.s + (l.e - l.s).rotCC().scale(r)), (l.e + (l.e - l.s).rotCC().scale(r)));\n        Line u2 = Line((l.s + (l.e - l.s).rotCL().scale(r)), (l.e + (l.e - l.s).rotCL().scale(r)));\n        Circle cc(p, r);\n        Point p1, p2;\n        if (!cc.crossL(u1, p1, p2))\n            cc.crossL(u2, p1, p2);\n        c1 = Circle(p1, r);\n        if (p1 == p2)\n        {\n            c2 = c1;\n            return 1;\n        }\n        c2 = Circle(p2, r);\n        return 2;\n    }\n\n    // u and v are the common tangent of the four circles\n    static int GetCircle(Line u, Line v, db r, Circle &c1, Circle &c2, Circle &c3, Circle &c4)\n    {\n        if (u.parallel(v))\n            return 0;\n        Line u1 = Line(u.s + (u.e - u.s).rotCC().scale(r), u.e + (u.e - u.s).rotCC().scale(r));\n        Line u2 = Line(u.s + (u.e - u.s).rotCL().scale(r), u.e + (u.e - u.s).rotCL().scale(r));\n        Line v1 = Line(v.s + (v.e - v.s).rotCC().scale(r), v.e + (v.e - v.s).rotCC().scale(r));\n        Line v2 = Line(v.s + (v.e - v.s).rotCL().scale(r), v.e + (v.e - v.s).rotCL().scale(r));\n        c1.r = c2.r = c3.r = c4.r = r;\n        c1.p = u1.intersec(v1);\n        c2.p = u1.intersec(v2);\n        c3.p = u2.intersec(v1);\n        c4.p = u2.intersec(v2);\n        return 4;\n    }\n\n    // Tangent with circle cx and cy\n    static int GetCircle(Circle cx, Circle cy, db r, Circle &c1, Circle &c2)\n    {\n        Circle x(cx.p, r + cx.r), y(cy.p, r + cy.r);\n        int t = x.crossC(y, c1.p, c2.p);\n        if (!t)\n            return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n\n    void read()\n    {\n        p.read();\n        cin >> r;\n    }\n\n    void Debug() { cerr << \"Circle: Center: (\" << p.x << \", \" << p.y << \") Radius: \" << r << '\\n'; }\n};\n\n// Polygon\nstruct Polygon\n{\n    // Functor for sorting by polar angle\n    struct cmp\n    {\n        Point p;\n        cmp(const Point &b) { p = b; }\n        bool operator()(const Point &a, const Point &b)\n        {\n            Point x = a, y = b;\n            int d = sgn((x - p) ^ (y - p));\n            if (!d)\n                return sgn(x.dis(p) - y.dis(p)) > 0;\n            return d > 0;\n        }\n    };\n\n    vector<Point> ps;\n    vector<Line> ls;\n\n    Polygon() {}\n\n    void add(Point p) { ps.push_back(p); }\n\n    int size() { return static_cast<int>(ps.size()); }\n\n    void getLines()\n    {\n        int s = size();\n        for (int i = 0; i < s; i++)\n            ls.push_back(Line(ps[i], ps[(i + 1) % s]));\n    }\n\n    void norm()\n    {\n        Point p = ps[0];\n        for (int i = 1; i < size(); i++)\n        {\n            if (p < ps[i])\n                continue;\n            p = ps[i];\n        }\n        sort(ps.begin(), ps.end(), cmp(p));\n    }\n\n    void getConvexJarvis(Polygon &conv)\n    {\n        sort(ps.begin(), ps.end());\n        conv.ps.resize(2 * size());\n\n        int n = size();\n        for (int i = 0; i < min(2, n); i++)\n            conv.ps[i] = ps[i];\n        if (conv.size() == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.resize(1);\n\n        if (n <= 2)\n            return;\n\n        int top = 1;\n\n        for (int i = 2; i < n; i++)\n        {\n            while (top && sgn((conv.ps[top] - ps[i]) ^ (conv.ps[top - 1] - ps[i])) <= 0)\n                top--;\n            conv.ps[++top] = ps[i];\n        }\n\n        int t = top;\n        conv.ps[++top] = ps[n - 2];\n\n        for (int i = n - 3; i >= 0; i--)\n        {\n            while (top != t && sgn((conv.ps[top] - ps[i]) ^ (conv.ps[top - 1] - ps[i])) <= 0)\n                top--;\n            conv.ps[++top] = ps[i];\n        }\n\n        while (conv.size() > top)\n            conv.ps.pop_back();\n\n        if (top == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.pop_back();\n\n        conv.norm(); // Counter Clock-wise\n    }\n\n    void getConvexWithPointOnLine(Polygon &conv)\n    {\n        int m, n = size();\n        if (n < 3)\n        {\n            for (auto i : ps)\n                conv.add(i);\n            return;\n        }\n\n        vector<Point> &g = conv.ps;\n\n        sort(ps.begin(), ps.end());\n        for (int i = 0; i < n; i++)\n        {\n            while ((m = g.size()) >= 2 && g[m - 2].relation(g[m - 1], ps[i]) <= 0)\n                g.pop_back();\n            g.push_back(ps[i]);\n        }\n\n        int t = g.size();\n\n        for (int i = n - 2; i >= 0; i--)\n        {\n            while ((m = g.size()) > t && g[m - 2].relation(g[m - 1], ps[i]) <= 0)\n                g.pop_back();\n            g.push_back(ps[i]);\n        }\n\n        g.pop_back();\n    }\n\n    // Cannot get the point on the edge\n    void getConvexGraham(Polygon &conv)\n    {\n        norm();\n        int top = 0, n = size();\n        if (n == 1)\n        {\n            conv.add(ps[0]);\n            return;\n        }\n\n        if (n == 2)\n        {\n            conv.add(ps[0]);\n            conv.add(ps[1]);\n            if (conv.ps[0] == conv.ps[1])\n                conv.ps.pop_back();\n            return;\n        }\n\n        conv.ps.resize(size());\n        conv.ps[0] = ps[0];\n        conv.ps[1] = ps[1];\n        top = 2;\n        for (int i = 2; i < n; i++)\n        {\n            while (top > 1 && sgn((conv.ps[top - 1] - conv.ps[top - 2]) ^ (ps[i] - conv.ps[top - 2])) <= 0)\n                top--;\n            conv.ps[top++] = ps[i];\n        }\n\n        while (conv.size() > top)\n            conv.ps.pop_back();\n\n        if (top == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.pop_back();\n    }\n\n    bool isConvex()\n    {\n        bitset<3> s;\n        int n = size();\n        for (int i = 0; i < n; i++)\n        {\n            int j = (i + 1) % n;\n            int k = (j + 1) % n;\n            s.set(sgn((ps[j] - ps[i]) ^ (ps[k] - ps[i])) + 1);\n            if (s[0] && s[2])\n                return false;\n        }\n        return true;\n    }\n\n    db diameter()\n    {\n        int q = 1, n = size();\n        db ans = 0;\n        for (int i = 0; i < n; i++)\n        {\n            int j = (i + 1) % n;\n            while (cross(ps[j], ps[q + 1], ps[i]) > cross(ps[j], ps[q], ps[i]))\n                q = (q + 1) % n;\n            ans = max(ans, max(ps[i].dis(ps[q]), ps[j].dis(ps[q + 1])));\n        }\n        return ans;\n    }\n\n    // 3 -> On Corner\n    // 2 -> On Edge\n    // 1 -> Inside\n    // 0 -> Outside\n    int relationP(Point q)\n    {\n        int n = size();\n        for (int i = 0; i < n; i++)\n            if (ps[i] == q)\n                return 3;\n        getLines();\n        for (int i = 0; i < n; i++)\n            if (!ls[i].relation(q))\n                return 2;\n        int cnt = 0;\n        for (int i = 0; i < n; i++)\n        {\n            int j = (i + 1) % n;\n            int k = sgn((q - ps[j]) ^ (ps[i] - ps[j]));\n            int u = sgn(ps[i].y - q.y);\n            int v = sgn(ps[j].y - q.y);\n            if (k > 0 && u < 0 && v >= 0)\n                cnt++;\n            if (k < 0 && v < 0 && u >= 0)\n                cnt--;\n        }\n        return cnt != 0;\n    }\n\n    void convexCut(Line l, Polygon &po)\n    {\n        for (int i = 0; i < size(); i++)\n        {\n            int d1 = sgn((l.e - l.s) ^ (ps[i] - l.s));\n            int d2 = sgn((l.e - l.s) ^ (ps[(i + 1) % size()] - l.s));\n            if (d1 >= 0)\n                po.add(ps[i]);\n            if (d1 * d2 < 0)\n                po.add(l.intersec(Line(ps[i], ps[(i + 1) % size()])));\n        }\n    }\n\n    db cir()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += ps[i].dis(ps[(i + 1) % n]);\n        return sum;\n    }\n\n    db area()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += (ps[i] ^ ps[(i + 1) % n]);\n        return abs(sum) / 2;\n    }\n\n    // 0 -> Clock-wise\n    // 1 -> Counter Clock-wise\n    bool dir()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += (ps[i] ^ ps[(i + 1) % n]);\n        return sgn(sum) > 0;\n    }\n\n    Point baryCenter()\n    {\n        Point ret;\n        db area = 0;\n        for (int i = 1; i < size() - 1; i++)\n        {\n            db tmp = (ps[i] - ps[0]) ^ (ps[i + 1] - ps[0]);\n            if (sgn(tmp) == 0)\n                continue;\n            area += tmp;\n            ret.x += (ps[0].x + ps[i].x + ps[i + 1].x) / 3 * tmp;\n            ret.y += (ps[0].y + ps[i].y + ps[i + 1].y) / 3 * tmp;\n        }\n        if (sgn(area))\n            ret = ret / area;\n        return ret;\n    }\n\n    db area(Circle c)\n    {\n        double ans = 0;\n        for (int i = 0; i < size(); i++)\n        {\n            int j = (i + 1) % size();\n            if (sgn((ps[j] - c.p) ^ (ps[i] - c.p)) >= 0)\n                ans += c.area(ps[i], ps[j]);\n            else\n                ans -= c.area(ps[i], ps[j]);\n        }\n        return abs(ans);\n    }\n\n    // 2 -> The circle is entirely in the polygon\n    // 1 -> The circle in in the circle and intersected with the boundary\n    // 0 -> Otherwise\n    int relationC(Circle c)\n    {\n        getLines();\n        int x = 2;\n        if (relationP(c.p) != 1)\n            return 0;\n        for (int i = 0; i < size(); i++)\n        {\n            if (c.relationS(ls[i]) == 2)\n                return 0;\n            if (c.relationS(ls[i]) == 1)\n                x = 1;\n        }\n        return x;\n    }\n\n    void read(int s)\n    {\n        for (int i = 0; i < s; i++)\n        {\n            Point p;\n            p.read();\n            ps.push_back(p);\n        }\n    }\n\n    void Debug()\n    {\n        cerr << \"Polygon:\\nPoints:\\n\";\n        for (auto i : ps)\n            i.Debug();\n        cerr << \"Lines:\\n\";\n        for (auto i : ls)\n            i.Debug();\n    }\n};\n\n// Pre-Build Function\ninline void build()\n{\n}\n\n// Actual Solver\ninline void solve()\n{\n    cout << fixed << setprecision(10);\n    int n;\n    cin >> n;\n    Polygon g;\n    g.read(n);\n    assert(g.isConvex());\n    cout << g.diameter() << '\\n';\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n#ifdef LOCAL\n    clock_t _begin = clock();\n#endif\n\n    build();\n    solve();\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << (double)(clock() - _begin) * 1000 / CLOCKS_PER_SEC << \"ms.\" << endl;\n#endif\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "av"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5+100;\nconst double  eps  = (1e-10);\n//点\nstruct Point{\n    double x,y;\n    Point(double _x=0,double _y=0):x(_x),y(_y){}\n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    double norm(){return x*x+y*y;}//模的平方\n    double ABS() {return sqrt(norm());}//模\n};\n//线段\nstruct Segment{\n    Point p1,p2;\n};\ndouble dot(Point a,Point b){\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(Point a,Point b){\n    return a.x*b.y-a.y*b.x;\n}\nvector<Point> G;\n//旋转卡壳计算凸包直径\ndouble Diameter(vector<Point> G){\n    double ans=0;\n    int n=G.size();\n    for(int i=0,k=0;i<n;i++){\n        while((G[i]-G[k]).norm()<(G[i]-G[(k+1)%n]).norm()) k=(k+1)%n;\n        ans=max(ans,(G[i]-G[k]).ABS());\n    }\n    return ans;\n}\nint main(){\n    int n;scanf(\"%d\",&n);\n    double x,y;\n    for(int i=1;i<=n;i++){\n        scanf(\"%lf %lf\",&x,&y);\n        G.push_back({x,y});\n    }\n    double ans=Diameter(G);\n    printf(\"%.10lf\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vec;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\ndouble eps=1e-8;\ndouble PI=acos(-1);\n\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\n\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\n\ndouble calcArea(vec &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++)res+=cross(t[i],t[(i+1==n?0:i+1)]);\n  return abs(res/2.0);\n}\n\ndouble Arg(P a,P b,P c){\n  b-=a,c-=a;\n  return arg(c*conj(b));\n}\n\nint inPolygon(vec &t,P p){\n  int n=t.size();\n  double sum=0;  \n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p) == 0 )return 1;// on\n    sum+= Arg(p,a,b);\n  }\n  if( abs(sum) < eps )return 0;//out\n  else  return 2;//in\n}\n\ntypedef pair<double,P> Pair;\n\nvec andrewScan(vec &t){\n  int N=t.size(),C=0;\n  vec R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vec res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n\nvec ConvexHull2(vec t){\n  sort(t.begin(),t.end());\n  vec u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vec l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvec ConvexHull(vec t){\n  vector<Pair> u;\n  vec R;\n  int N=t.size(),K=0,C=0;\n  for(int i=1;i<N;i++)if(t[i]<t[K])K=i;\n  for(int i=0;i<N;i++)u.push_back(Pair(arg(t[i]-t[K]),t[i]));\n  R.push_back(t[K]),C++;\n  sort(u.begin(),u.end());\n  for(int i=0;i<N;i++){\n    P p=u[i].second;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==0)continue;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==2)continue;\n    while(2<=C&&ccw(R[C-2],R[C-1],p)!=1)R.pop_back(),C--;\n    R.push_back(p),C++;    \n  }\n  return R;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vec t;\n  double x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  vec ans=ConvexHull2(t);\n  int m=ans.size();\n  double maxm=0;\n  \n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      maxm=max(maxm,abs(ans[i]-ans[j]));\n    }\n  }\n  \n  printf(\"%.8f\\n\",maxm);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long; using ld = long double; using ull = unsigned long long; using uint = unsigned int;\nusing vi  = vector<int>; using vb  = vector<bool>; using vd  = vector<double>; using vl  = vector<ll>;\nusing vvi = vector<vi>;  using vvb = vector<vb>;   using vvd = vector<vd>;     using vvl = vector<vl>;\n\n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define FOR(i,b,n) for(ll i=(b); i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TEN(x) ((ll)1e##x)\n\ntemplate<typename T> inline string join(const vector<T>& vec, string sep = \" \") { stringstream ss; REP(i, vec.size()) ss << vec[i] << ( i+1 == vec.size() ? \"\" : sep ); return ss.str(); }\n\n\n///////////////\n\n#define EPS (1e-10)\n#define NEXT(x, i) (x[(i + 1) % x.size()])\n\ntemplate<class T> using CR = const T &;\nusing P = complex<ld>;\nusing G = vector<P>;\n\nint sgn(ld a, ld b = 0) {\n\tif (a > b + EPS) return 1;\n\tif (a < b - EPS) return -1;\n\treturn 0;\n}\n\nld dot(P a, P b) { return real(conj(a)*b); }\nld cross(P a, P b) { return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (sgn(cross(b, c))) return sgn(cross(b, c)); // clockwise(-1) or counter clockwise(1)\n\tif (sgn(dot(b, c)) == -1) return 2;            // c--a--b\n\tif (sgn(norm(b), norm(c)) == -1) return -2;    // a--b--c\n\treturn 0;                                      // a--c--b\n}\n\nnamespace std {\n\tbool operator < (P a, P b) {\n\t\treturn sgn(real(a), real(b)) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\npair<ll, ll> convex_diameter(CR<G> g) {\n\tll n = g.size();\n\n\tll is = 0, js = 0;\n\tFOR(i, 1, n) {\n\t\tif (imag(g[i]) > imag(g[is])) is = i;\n\t\tif (imag(g[i]) < imag(g[js])) js = i;\n\t}\n\tld maxd = norm(g[is] - g[js]);\n\n\tll i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo {\n\t\tif (cross(g[(i + 1) % g.size()] - g[i], g[(j + 1) % g.size()] - g[j]) >= 0) {\n\t\t\tj = (j + 1) % n;\n\t\t} else {\n\t\t\ti = (i + 1) % n;\n\t\t}\n\t\tif (norm(g[i] - g[j]) > maxd) {\n\t\t\tmaxd = norm(g[i] - g[j]);\n\t\t\tmaxi = i; maxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\treturn {maxi, maxj};\n}\n\n//////////////\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(30);\n\tll n; cin >> n;\n\n\tG g(n);\n\tREP(i,n){\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tg[i] = { x, y };\n\t}\n\tauto p = convex_diameter(g);\n\n\tcout << abs(g[p.first] - g[p.second]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Header {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long readtype;\ntypedef long long var;\ntypedef long double let;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n\n#ifdef LOCAL_LOGGER\n#define logger(...) fprintf(stderr, __VA_ARGS__)\n#define abortif(v, ...) if (v) {logger(\"Error in Line %d, Function '%s()'.\\nInfo: \", __LINE__, __FUNCTION__); logger(__VA_ARGS__); exit(0);}\n#else\n#define logger(...);\n#define abortif(v, ...);\n#endif\n/* }}} */\n\nconst let EPS = 1e-8;\n\nint sign(let x) { return (x < -EPS) ? -1 : (x > EPS ? 1 : 0); }\n\nstruct Point {\n  let x, y;\n\n  friend Point operator - (Point a, Point b) {\n    return (Point) {a.x - b.x, a.y - b.y};\n  }\n\n  friend let Times(Point a, Point b) {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  let dist() {\n    return sqrt(x * x + y * y);\n  }\n\n  Point Rotate(Point k) {\n    let z = k.dist();\n    return Rotate(k.y / z, k.x / z);\n  }\n\n  Point Rotate(let sink, let cosk) {\n    return (Point) {\n      x * cosk - y * sink, x * sink + y * cosk\n    };\n  }\n\n  friend let Dist(Point a, Point b) { return (a - b).dist(); }\n};\n\ntypedef Point Vec;\n\nstruct Line {\n  Point p;\n  Vec v;\n  Line(Point a, Point b) { p = a, v = b - a; }\n\n  friend let Dist(Line l, Point p) {\n    return (p - l.p).Rotate(l.v).y;\n  }\n};\n\nstruct Polygon {\n  vector<Point> p;\n\n  Point &operator [] (int k) { return p[k]; } \n  int size() { return p.size(); }\n  void push(Point t) { p.push_back(t); }\n\n  friend let ConvexDiameter(Polygon poly) {\n\n    int p = 0;\n    let res = 0;\n    for (int i = 0; i < poly.size(); ++i) {\n      let tdist = Dist(poly[i], poly[p]);\n      while (true) {\n        res = max(res, tdist);\n        int np = (p + 1 == poly.size()) ? 0 : p + 1;\n        let nxdist = Dist(poly[i], poly[np]);\n        if (sign(nxdist - tdist) < 0) break;\n        p = np, tdist = nxdist;\n      }\n    }\n\n    // for (int i = 0; i < poly.size(); ++i) {\n    //   for (int j = 0; j < poly.size(); ++j) {\n    //     if (sign(Dist(poly[i], poly[j]) - res) > 0) {\n    //       printf(\"%d %d\\n\", i, j);\n    //     }\n    //   }\n    // }\n\n    return res;\n  }\n};\n\nPoint ReadPoint() {\n  Point p;\n  scanf(\"%Lf%Lf\", &p.x, &p.y);\n  return p;\n}\n\nPolygon ReadPolygon() {\n  Polygon poly;\n  int g = read();\n  for (int i = 1; i <= g; ++i) \n    poly.push(ReadPoint());\n  return poly;\n}\n\nint main() {\n// #ifndef ONLINE_JUDGE\n//   freopen(\"CGL_4_B.in\", \"r\", stdin);\n//   freopen(\"CGL_4_B.out\", \"w\", stdout);\n// #endif\n// #ifdef LOCAL_LOGGER\n//   freopen(\"CGL_4_B.log\", \"w\", stderr);\n// #endif\n  Polygon poly = ReadPolygon();\n  printf(\"%.8Lf\\n\", ConvexDiameter(poly));\n  return 0;\n}\n\n/* ==== Makefile ==== {{{\nCompileAndRun:\n\tmake Compile\n\tmake Run\n\nCompile:\n\tg++ -o CGL_4_B CGL_4_B.cpp -g -Wall -DLOCAL_LOGGER\n\nCompileUF:\n\tg++ -o CGL_4_B CGL_4_B.cpp -g -Wall -DLOCAL_LOGGER -fsanitize=undefined\n\nRun:\n\t./CGL_4_B < CGL_4_B.in > CGL_4_B.out\n==================\n}}} */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nconst db eps = 1e-9;\nint sgn(db a, db b = 0) {\n\ta -= b;\n\treturn (a > eps) - (a < -eps);\n}\n\nstruct poi {\n\tdb x, y;\n\tpoi operator -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tbool operator <(poi p) const {\n\t\treturn tie(x, y) < tie(p.x, p.y);\n\t}\n\tdb cross(poi p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb len() {\n\t\treturn sqrt(x * x + y * y);\n\t}\n};\ndb xmul(poi a, poi b, poi c) {\n\treturn (b - a).cross(c - a);\n}\n\nusing vp = vector <poi>;\nvp convex(vp v) {\n\tsort(v.begin(), v.end()); vp r;\n\tfor(int i = 0; i < v.size(); i ++) {\n\t\twhile(r.size() > 1 &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tr.push_back(v[i]);\n\t}\n\tint d = r.size();\n\tfor(int i = (int)v.size() - 2; i >= 0; i --) {\n\t\twhile(r.size() > d &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tif(i != 0) r.push_back(v[i]);\n\t}\n\treturn r;\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(false);\n\tint n; cin >> n; vp v;\n\tfor(int i = 0; i < n; i ++) {\n\t\tdb x, y; cin >> x >> y;\n\t\tv.push_back({x, y});\n\t}\n\tv = convex(v);\n\n\tn = v.size();\n\n\t{\n\t\tdb ans = 0;\n\t\tauto upd = [&](int i, int j) {\n\t\t\tdb t = (v[i] - v[j]).len();\n\t\t\tif(t > ans) ans = t;\n\t\t};\n\t\tint j = 0;\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\twhile(sgn(xmul(v[i], v[(i + 1) % n], v[j]),\n\t\t\t\txmul(v[i], v[(i + 1) % n], v[(j + 1) % n])) < 0)\n\t\t\t\tj = (j + 1) % n;\n\t\t\t//cout << i << ' ' << j << '\\n';\n\t\t\tupd(i, j); /*upd((i + 1) % n, j);*/\n\t\t\t/*upd(i, (j + 1) % n);*/ /*upd((i + 1) % n, (j + 1) % n);*/\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C& a, const C& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C &a, const C &b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//??????\ndouble cross(const C& a, const C& b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C& a, const C& b)\n{\n    return real(conj(a)*b);\n}\n\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C &p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C &p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C &p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C &p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C &p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C &p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspoint(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????????????????????\nL crosspointSS(C &p1,int r1,C &p2,int r2)\n{\n    double d = norm(p2-p1);\n    double t = r2*r2 - r1*r1 - d;\n    double aa = d,bb = t*(real(p2)-real(p1)),cc = t*t / 4.0 - (imag(p2) - imag(p1))*(imag(p2) - imag(p1))*r1*r1;\n    double x1 = (-bb - sqrt(bb*bb - 4*aa*cc))/(2*aa),x2 = (-bb + sqrt(bb*bb - 4*aa*cc))/(2*aa);\n    double y1,y2;\n    if(imag(p1) == imag(p2)){\n        y1 = -sqrt(r1*r1 - x1*x1);\n        y2 = -y1;\n    }else{\n        y1 = (t+2*(real(p2)-real(p1))*x1)/(-2*(imag(p2)-imag(p1)));\n        y2 = (t+2*(real(p2)-real(p1))*x2)/(-2*(imag(p2)-imag(p1)));\n    }\n    L ln = L(C(x1+real(p1),y1+imag(p1)),C(x2+real(p1),y2+imag(p1)));\n    return ln;\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspoint(L(A, B), l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C& p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<C> vec;\n    rep(i,n){\n        double x,y;\n        cin >> x >> y;\n        vec.push_back(C(x,y));\n    }\n    printf(\"%.10f\\n\",convex_diameter(vec));\n}"
  },
  {
    "language": "C++",
    "code": "import java.lang.Math.*\n\ndata class Point(val x:Double, val y:Double)\nfun Point.distanceFrom(origin:Point):Double = sqrt((this.x - origin.x) * (this.x - origin.x) + (this.y - origin.y) * (this.y - origin.y))\nfun main(args:Array<String>):Unit {\n    val n = readLine()!!.toInt()\n    val points = Array(n){readLine()!!.split(' ').map(String::toDouble).let{Point(it.first(), it.last())}}\n    var posB = 0\n    var maxLength:Double = .0\n    for (posA in 0 until n){\n        while (points[posA].distanceFrom(points[posB]) <= points[posA].distanceFrom(points[(posB + 1) % n])) {\n            posB = (posB + 1) % n\n        }\n        if (maxLength < points[posA].distanceFrom(points[posB])) maxLength = points[posA].distanceFrom(points[posB])\n    }\n    println(maxLength)\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\ntypedef double number;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<number> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n \ntypedef vector<P> G;\n \n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnumber convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  number maxd = norm(pt[is]-pt[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return maxd; /* farthest pair is (maxi, maxj). */\n}\n \nint main(){\n    G poly;\n    P p;\n    int n;\n    double x,y;\n    for(scanf(\"%d\",&n);n--;poly.push_back(p))scanf(\"%lf%lf\",&x,&y),p=P(x,y);\n    printf(\"%f\\n\",sqrt(convex_diameter(poly)));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <cmath>            // sqrt()\n\n#define MAX_N 80000\nusing namespace std;\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n};\n\ntypedef Point Vector;\n\nPoint qs[MAX_N];\nint n;\n\ndouble\ndot(Vector a, Vector b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble\ncross(Vector a, Vector b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble\ndist(Vector a, Vector b)\n{\n\treturn dot(a - b, a - b);\n}\n\nbool cmp_func(const Point &l, const Point &r)\n{\n\treturn l.x != r.x ? l.x < r.x : l.y < r.y;\n}\n\ndouble\nsolve()\n{\n\tint i = 0, j = 0; // ?????????????????????????????????\n\t// x ??????????????????????????????????±???????\n\tfor (int k = 0; k < n; ++k)\n\t{\n\t\tif (!cmp_func(qs[i], qs[k]))\n\t\t\ti = k;\n\n\t\tif (cmp_func(qs[j], qs[k]))\n\t\t\tj = k;\n\t}\n\n\tdouble res = 0;\n\tint si = i, sj = j;\n\twhile (i != sj || j != si) // ????????? 180 ??????????????????\n\t{\n\t\tdouble t = dist(qs[i], qs[j]);\n\t\tif (t > res)\n\t\t\tres = t;\n\n\t\t// ??? i-(i+1) ?????????????????¨??? j-(j+1) ???????????????????????????????????????????????????\n\t\tif (cross(qs[(i + 1) % n] - qs[i], qs[(j + 1) % n] - qs[j]) < 0)\n\t\t\ti = (i + 1) % n; // ??? i-(i+1) ??????????????????????????????\n\t\telse\n\t\t\tj = (j + 1) % n; // ??? j-(j+1) ??????????????????????????????\n\t}\n\n\treturn sqrt(res);\n}\n\nint\nmain(int argc, char** argv)\n{\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%lf %lf\", &qs[i].x, &qs[i].y);\n\n\tprintf(\"%.12f\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\ntemplate <class T>\ninline T sq(T x) { return x * x; }\n\nusing Real = long double;\nusing Point = std::complex<Real>;\nusing Segment = std::pair<Point, Point>;\nusing Polygon = std::vector<Point>;\n\nnamespace std {\nbool operator<(const Point& a, const Point& b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n}  // namespace std\n\nconst Real EPS = 1e-10;\nconst Point origin(0, 0);\n\n// 宇宙船演算子\ninline Real compare(Real a, Real b) {\n    if (std::abs(a - b) < EPS) return 0;\n    return a - b > 0 ? 1 : -1;\n}\n\ninline Real dist(Point a, Point b) {\n    return std::abs(a - b);\n}\n\ninline Real length(Segment s) {\n    return dist(s.first, s.second);\n}\n\n// inner product\ninline Real dot(Point x, Point y) {\n    return std::real(std::conj(x) * (y));\n}\n\n// outer product\ninline Real cross(Point x, Point y) {\n    return std::imag(std::conj(x) * (y));\n}\n\n// lに対するxの正射影\nPoint proj(Segment s, Point p) {\n    Real ratio = dot(s.second - s.first, p - s.first) / sq(length(s));\n    return s.first + (s.second - s.first) * ratio;\n}\n\n// lを軸としてxに対称な点\nPoint refl(Segment s, Point p) {\n    Point t = proj(s, p);\n    return t + (t - p);\n}\n\n// lに対するpの位置\n// 0: on segment\n// 1: counter clockwise  -1: clockwise\n// 2: online front       -2: online back\nint side(Segment s, Point p) {\n    Real c = cross(s.second - s.first, p - s.first);\n    if (compare(c, 0) != 0) return compare(c, 0);\n\n    Real d = dot(s.second - s.first, p - s.first);\n    if (compare(d, 0) < 0) return -2;\n\n    return (compare(length(Segment(s.first, p)), length(s)) > 0 ? 2 : 0);\n}\n\ninline bool isorthogonal(Segment s1, Segment s2) {\n    return compare(dot(s1.second - s1.first, s2.second - s2.first), 0) == 0;\n}\n\ninline bool isparallel(Segment s1, Segment s2) {\n    return compare(cross(s1.second - s1.first, s2.second - s2.first), 0) == 0;\n}\n\ninline bool intersect(Segment s1, Segment s2) {\n    return (side(s1, s2.first) * side(s1, s2.second) <= 0) &&\n           (side(s2, s1.first) * side(s2, s1.second) <= 0);\n}\n\nPoint intersection(Segment s1, Segment s2) {\n    Real c1 = cross(s2.second - s2.first, s1.second - s1.first);\n    Real c2 = cross(s2.second - s2.first, s1.first - s2.first);\n    return s1.first + (s1.second - s1.first) * (-c2 / c1);\n}\n\n// distanceのオーバーロード\nReal dist(Segment s, Point p) {\n    Point t = proj(s, p);\n    if (side(s, t) == 0) return dist(p, t);\n    return std::min(dist(p, s.first), dist(p, s.second));\n}\n\nReal dist(Segment s1, Segment s2) {\n    if (intersect(s1, s2)) return 0;\n    return std::min({dist(s1, s2.first),\n                     dist(s1, s2.second),\n                     dist(s2, s1.first),\n                     dist(s2, s1.second)});\n}\n\n// signed area\ninline Real triangle(Point a, Point b, Point c) {\n    return cross(b - a, c - a) / 2;\n}\n\nReal area(const Polygon& g) {\n    Real S = 0;\n    for (int i = 0; i < g.size(); ++i) {\n        S += triangle(origin, g[i], g[(i + 1) % g.size()]);\n    }\n    return S;\n}\n\nbool isconvex(const Polygon& g) {\n    for (int i = 0; i < g.size(); ++i) {\n        if (side(Segment(g[i], g[(i + 1) % g.size()]),\n                 g[(i + 2) % g.size()]) == -1) return false;\n    }\n    return true;\n}\n\n// 0: out  1: on  2: in\nint contain(const Polygon& g, Point p) {\n    bool in = false;\n    for (int i = 0; i < g.size(); ++i) {\n        if (side(Segment(g[i], g[(i + 1) % g.size()]), p) == 0) return 1;\n\n        Point a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n        if (compare(a.imag(), b.imag()) > 0) std::swap(a, b);\n        if (compare(a.imag(), 0) <= 0 &&\n            compare(b.imag(), 0) > 0 &&\n            compare(cross(a, b), 0) < 0) in = !in;\n    }\n    return in ? 2 : 0;\n}\n\n// linearok: 同一直線上の頂点を取るか\nPolygon convexhull(Polygon& g, bool linearok) {\n    std::sort(g.begin(), g.end());\n    int N = g.size();\n\n    Polygon ret(N * 2);\n    int k = 0;\n    for (int i = 0; i < N; ++i) {\n        while (k >= 2 &&\n               compare(cross(ret[k - 1] - ret[k - 2], g[i] - ret[k - 2]), 0) < !linearok) --k;\n        // linearokならcross = 0も回収する\n        ret[k++] = g[i];\n    }\n    int t = k + 1;\n    for (int i = N - 2; i >= 0; --i) {\n        while (k >= t &&\n               compare(cross(ret[k - 1] - ret[k - 2], g[i] - ret[k - 2]), 0) < !linearok) --k;\n        ret[k++] = g[i];\n    }\n\n    // 先頭が被っているので除く\n    ret.resize(k - 1);\n    return ret;\n}\n\nReal diameter(const Polygon& g) {\n    Real ret = 0;\n    int j = 0;\n    for (int i = 0; i < g.size(); ++i) {\n        while (j < g.size() - 1 &&\n               compare(dist(g[i], g[j + 1]), dist(g[i], g[j])) > 0) ++j;\n        ret = std::max(ret, dist(g[i], g[j]));\n    }\n    return ret;\n}\n\n\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    Polygon g(N);\n    for (auto& p : g) {\n        Real x, y;\n        cin >> x >> y;\n        p = Point(x, y);\n    }\n\n    cout << fixed << setprecision(10) << diameter(g) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> point;\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ntypedef vector<point> polygon;\ndouble convex_diameter(const polygon &P) {\n\tconst int n = P.size();\n\tauto diff = [&P,n](int i) {return P[(i+1)%n] - P[i];};\n\tint is = 0, js = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (imag(P[i]) > imag(P[is])) is = i;\n\t\tif (imag(P[i]) < imag(P[js])) js = i;\n\t}\n\tdouble maxd = norm(P[is]-P[js]);\n\n\tint i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo {\n\t\tif (cross(diff(i), diff(j)) >= 0) j = (j+1) % n;\n\t\telse i = (i+1) % n;\n\t\tif (norm(P[i]-P[j]) > maxd) {\n\t\t\tmaxd = norm(P[i]-P[j]);\n\t\t\tmaxi = i; maxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\treturn maxd; /* farthest pair is (maxi, maxj). */\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tpolygon pol(n);\n\t\tfor (auto& p : pol) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp = point(x, y);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", sqrt(convex_diameter(pol)));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing u64 = uint_fast64_t; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//////////////////////////////////////////////////////////////////////////////\n\n// 精度が足りないときはlong double\nusing DD = double;\nconstexpr DD EPS = 1e-11;\nconst DD PI = acos(DD(-1));\ninline int sgn(DD a) {return (a < -EPS) ? -1 : (a > EPS) ? 1 : 0;}\n\n//点\nstruct Point {\n    DD x, y;\n    Point (DD x = 0, DD y = 0): x(x), y(y) {}\n\n    Point operator+(const Point &p) const { return Point(*this) += p;}\n    Point operator-(const Point &p) const { return Point(*this) -= p;}\n    Point operator*(const Point &p) const { return Point(*this) *= p;}\n    Point operator*(DD a) const { return Point(*this) *= a;}\n    Point operator/(DD a) const { return Point(*this) /= a;}\n    Point& operator+=(const Point &p) { x += p.x; y += p.y; return *this;}\n    Point& operator-=(const Point &p) { x -= p.x; y -= p.y; return *this;}\n    Point& operator*=(const Point &p) { DD u = x*p.x - y*p.y; DD v = x*p.y + y*p.x; x = u; y = v; return *this;}\n    Point& operator*=(DD a) { x *= a; y *= a; return *this;}\n    Point& operator/=(DD a) { x /= a; y /= a; return *this;}\n    bool operator==(const Point &p) const { return !sgn(x - p.x) && !sgn(y - p.y);}\n    bool operator!=(const Point &p) const { return sgn(x - p.x) || sgn(y - p.y);}\n    bool operator<(const Point &p) const {\n        if (sgn(x - p.x)) return sgn(x - p.x) < 0;\n        return sgn(y - p.y) < 0;\n    }\n    friend istream& operator>>(istream& is, Point& p) { is >> p.x >> p.y; return is;}\n    friend ostream& operator<<(ostream& os, const Point& p) { os << p.x << \" \" << p.y; return os;}\n\n    DD norm() { return x*x + y*y;}\n    DD abs() { return sqrt(norm());}\n    DD arg() { return atan2(y,x);}\n};\n\n//ベクトル\nusing Vector = Point;\n\ninline DD norm(const Vector &a) { return a.x * a.x + a.y * a.y;}\ninline DD abs(const Vector &a) { return sqrt(norm(a));}\ninline DD dot(const Vector &a, const Vector &b) { return a.x * b.x + a.y * b.y;}\ninline DD cross(const Vector &a, const Vector &b) { return a.x * b.y - a.y * b.x;}\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) { return Point(-p.y, p.x);}\ninline DD arg(const Vector &p) { return atan2(p.y, p.x);}\ninline Vector polar(DD a, DD r) { return Point(cos(r) * a, sin(r) * a);}\n//象限\nint ort(const Point &a) {\n    if (sgn(norm(a))) {\n        if (sgn(a.y) > 0) return sgn(a.x) > 0 ? 1 : 2;\n        return sgn(a.x) > 0 ? 4 : 3;\n    }\n    return 0;\n}\nbool xsort(const Point &a, const Point &b) {\n    if (sgn(a.x - b.x)) return sgn(a.x - b.x) < 0;\n    return sgn(a.y - b.y) < 0;\n}\nbool ysort(const Point &a, const Point &b) {\n    if (sgn(a.y - b.y)) return sgn(a.y - b.y) < 0;\n    return sgn(a.x - b.x) < 0;\n}\n\nbool argsortcross(const Point &a, const Point &b) {\n    int ao = ort(a), bo = ort(b);\n    if (ao != bo) return ao < bo;\n    return sgn(cross(a,b)) > 0;\n}\n\nbool argsortatan2(const Point &a, const Point &b) {\n    return sgn(atan2(b.y, b.x) - atan2(a.y, a.x)) > 0;\n}\n\n//線分\nstruct Segment {\n    Point p1,p2;\n    Segment() {};\n    Segment(Point p1, Point p2) : p1(p1),p2(p2) {}\n};\n\n//直線\nusing Line = Segment;\n\n// 円\nstruct Circle {\n    Point c;\n    DD r;\n    Circle(){}\n    Circle(Point c, DD r): c(c), r(r) {}\n    friend istream& operator >>(istream& is, Circle& C) { is >> C.c >> C.r; return is;}\n    friend ostream& operator <<(ostream& os, const Circle& C) { os << C.c << \" \" << C.r; return os;}\n};\n\n//多角形\nusing Polygon = vector<Point>;\n\n//点の進行方向\nint ccw(const Point &p0, const Point &p1, const Point &p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (sgn(cross(a,b)) > 0) return 1; //p0,p1から見てp2は左側(反時計回り)\n    if (sgn(cross(a,b)) < 0) return -1; //p0,p1から見てp2は右側(時計回り)\n    if (sgn(dot(a,b)) < 0) return 2; //p2-p0-p1の順に一直線上\n    if (sgn(norm(b) - norm(a)) > 0) return -2; //p0-p1-p2の順に一直線上\n    return 0; //p0-p2-p1の順に一直線上\n}\n\n//直線の交差判定 交差する場合1, 平行な場合0, 同一直線のとき-1\nint intersectLP(const Vector &a, const Vector &b) {\n    if (sgn(cross(a,b))) return 1;\n    if (sgn(dot(a,b))) return 0;\n    return -1;\n} \nint intersectLP(const Point &p1, const Point &p2, const Point &p3, const Point &p4) {return intersectLP(p2-p1,p4-p3);}\nint intersectLP(const Line &l1, const Line &l2) {return intersectLP(l1.p1,l1.p2,l2.p1,l2.p2);}\n\n//直線の平行判定\nbool isParallel(const Vector &a, Vector &b) {return intersectLP(a,b) <= 0;}\nbool isParallel(const Point &p1, const Point &p2, const Point &p3, const Point &p4) {return intersectLP(p1,p2,p3,p4) <= 0;}\nbool isParallel(const Line &l1, const Line &l2) {return intersectLP(l1,l2) <= 0;}\n\n//直線の直交判定\nbool isOrthogonal(const Vector &a, const Vector &b) {return !sgn(dot(a,b));}\nbool isOrthogonal(const Point &p1, const Point &p2, const Point &p3, const Point &p4) {return isOrthogonal(p2-p1,p4-p3);}\nbool isOrthogonal(const Line &l1, const Line &l2) {return isOrthogonal(l1.p1,l1.p2,l2.p1,l2.p2);}\n\n//線分の交差判定\nbool intersectSP(const Point &p1, const Point &p2, const Point &p3, const Point &p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);}\nbool intersectSP(const Segment &s1, const Segment &s2) { return intersectSP(s1.p1, s1.p2, s2.p1, s2.p2);}\n\n//直線と線分の交差判定\nbool intersectLSP(const Line &l, const Segment &s) {return ccw(l.p1,l.p2,s.p1)*ccw(l.p1,l.p2,s.p2) <= 0;}\n\n//直線と直線の交点\nPoint getCrossPointLP(const Line &l1, const Line &l2) {\n    assert(intersectLP(l1,l2)==1);\n    return l1.p1 + (l1.p2-l1.p1)*cross(l2.p1-l1.p1,l2.p2-l2.p1)/cross(l1.p2-l1.p1,l2.p2-l2.p1);\n}\n\n//線分と線分の交点\nPoint getCrossPointSP(const Segment &s1, const Segment &s2) {\n    assert(intersectSP(s1,s2));\n    return getCrossPointLP(s1,s2);\n}\n\n//射影\nPoint project(const Segment &s, const Point &p) {\n    Vector base = s.p2 - s.p1;\n    DD r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\n//線対称\nPoint reflect(const Segment &s, const Point &p) {return p + (project(s,p) - p) * 2;}\n\n//点と直線の距離\nDD getDistanceLP(const Line &l, const Point &p) { return abs(cross(l.p2 - l.p1,p - l.p1) / abs(l.p2 - l.p1));}\n\n//点と線分の距離\nDD getDistanceSP(const Segment &s, const Point &p) {\n    if (sgn(dot(s.p2 - s.p1,p - s.p1)) < 0) return abs(p - s.p1);\n    if (sgn(dot(s.p1 - s.p2,p - s.p2)) < 0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\n//直線と直線の距離\nDD getDistanceLP(const Line &l1, const Line &l2) {\n    if (intersectLP(l1,l2)) return 0;\n    return getDistanceLP(l1,l2.p1);\n}\n\n//直線と線分の距離\nDD getDistanceLSP(const Line &l, const Segment &s) {\n    if (intersectLSP(l,s)) return 0;\n    return min(getDistanceLP(l,s.p1),getDistanceLP(l,s.p2));\n}\n\n//線分と線分の距離\nDD getDistanceSP(const Segment &s1, const Segment &s2) {\n    if (intersectSP(s1, s2)) return 0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n//円と直線の交差判定\nbool intersectLP(const Circle &c, const Line &l) { return sgn(getDistanceLP(l, c.c) - c.r) <= 0;}\n//円と線分の交差判定\nbool intersectSP(const Circle &c, const Segment &s) {\n    return sgn(getDistanceSP(s,c.c) - c.r) <= 0 && sgn(max(abs(s.p1 - c.c),abs(s.p2 - c.c)) - c.r) >= 0;\n}\n//円と円の交差判定\nint intersect(const Circle &c1, const Circle &c2) {\n    if (sgn(abs(c1.c - c2.c) - (c1.r + c2.r)) > 0) return 4;     //2つの円が離れている場合\n    if (!sgn(abs(c1.c - c2.c) - (c1.r + c2.r))) return 3;        //2つの円が外接する場合\n    if (sgn(fabs(c1.r - c2.r) - abs(c1.c - c2.c)) > 0) return 0; //一方がもう一方を内包する場合\n    if (!sgn(fabs(c1.r - c2.r) - abs(c1.c - c2.c))) return 1;    //2つの円が内接する場合\n    return 2;                                                    //2つの円が交わる場合\n}\n\n//円と直線の交点\npair<Point, Point> getCrossPoints(const Circle &c, const Line &l) {\n    assert(intersectLP(c,l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    DD base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//円と円の交点\npair<Point, Point> getCrossPoints(const Circle &c1, const Circle &c2) {\n    assert(intersect(c1, c2));\n    DD d = abs(c1.c - c2.c);\n    DD a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (c1.r * d * 2));\n    DD t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//点pを通る円の接線\npair<Line, Line> tangent(const Circle &c, const Point &p) {\n    assert(sgn(abs(c.c - p) - c.r) >= 0);\n    if (!sgn(abs(c.c - p) - c.r)) {\n        Point q = rot90(c.c - p);\n        return pair<Line, Line>(Line(p,p+q), Line(p,p+q));\n    } \n    Circle c2=Circle(p,sqrt(norm(c.c-p)-c.r*c.r));\n    auto q = getCrossPoints(c,c2);\n    return pair<Line, Line>(Line(p,q.first), Line(p,q.second));\n}\n\n//多角形の面積\nDD area(const Polygon &g) {\n    const int N = g.size();\n    DD ret = 0;\n    for (int i = 0; i < N; ++i) {\n        ret += cross(g[i],g[(i+1)%N]);\n    }\n    return fabs(ret)/2;\n}\n\n//凸性判定\nbool isConvex(const Polygon &g) {\n    const int N = g.size();\n    for (int i = 0; i < N; ++i) {\n        if (ccw(g[i],g[(i+1)%N],g[(i+2)%N]) == -1) return 0;\n    }\n    return 1;\n}\n\n// 多角形-点の包含判定\nint containment(const Polygon &g, const Point &p) {\n    const int N = g.size();\n    DD ang = 0;\n    for (int i = 0; i < N; i++) {\n        if (!ccw(g[i],g[(i+1)%N],p)) return 1; // pがgの辺上に存在する\n        ang += atan2(cross(g[(i+1)%N] - p, g[i] - p), dot(g[(i+1)%N] - p, g[i] - p));\n    }\n    if (sgn(ang)) return 2; // pがgに含まれる\n    return 0; // pがgに含まれない\n}\n\n//凸包\nPolygon andrewScan(Polygon s) {\n    Polygon u,l;\n    const int N = s.size();\n    if (N < 3) return s;\n    sort(s.begin(), s.end(), xsort);\n    u.emplace_back(s[0]);\n    u.emplace_back(s[1]);\n    l.emplace_back(s[N-1]);\n    l.emplace_back(s[N-2]);\n    \n    for (int i = 2; i < s.size(); ++i) {\n        // 凸包上の点も含めるなら ccw() == 1 含めないなら ccw() != -1\n        for (int n = u.size(); n >= 2 && ccw(u[n-2],u[n-1],s[i]) != -1; --n) {\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for (int i = N - 3; i >= 0; --i) {\n        // 凸包上の点も含めるなら ccw() == 1 含めないなら ccw() != -1\n        for (int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) != -1; --n) {\n            l.pop_back();\n        }\n        l.emplace_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; --i) l.emplace_back(u[i]);\n\n    return l;\n}\n\n//最遠点対\nDD farthestpointpair(const Polygon &g) {\n    const int N = g.size();\n    if (N == 2) return abs(g[1] - g[0]);\n    int i = 0, j = 0;\n    for (int k = 0; k < N; ++k) {\n        if (g[k].y > g[i].y) i = k;\n        if (g[k].y < g[j].y) j = k;\n    }\n\n    DD ret = 0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        ret = max(ret, abs(g[i]-g[j]));\n        if (sgn(cross(g[(i+1)%N] - g[i], g[(j+1)%N] - g[j])) < 0) {\n            ++i;\n            if (i == N) i = 0;\n        } else {\n            ++j;\n            if (j == N) j = 0;\n        }\n    }\n\n    return ret;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid CGL_1_A() {\n    Point p1,p2; cin >> p1 >> p2;\n    Line l(p1,p2);\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p; cin >> p;\n        cout << project(l,p) << ln;\n    }\n}\n\nvoid CGL_1_B() {\n    Point p1,p2; cin >> p1 >> p2;\n    Line l(p1,p2);\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p; cin >> p;\n        cout << reflect(l,p) << ln;\n    }\n}\n\nvoid CGL_1_C() {\n    Point p0,p1; cin >> p0 >> p1;\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p2; cin >> p2;\n        int v = ccw(p0,p1,p2);\n        string ans;\n        if (v==1) ans = \"COUNTER_CLOCKWISE\";\n        if (v==-1) ans = \"CLOCKWISE\";\n        if (v==2) ans = \"ONLINE_BACK\";\n        if (v==-2) ans = \"ONLINE_FRONT\";\n        if (v==0) ans = \"ON_SEGMENT\";\n        cout << ans << ln;\n    }\n}\n\nvoid CGL_2_A() {\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p0,p1,p2,p3; cin >> p0 >> p1 >> p2 >> p3;\n        if (isParallel(p0,p1,p2,p3)) cout << 2 << ln;\n        else if (isOrthogonal(p0,p1,p2,p3)) cout << 1 << ln;\n        else cout << 0 << ln;\n    }\n}\n\nvoid CGL_2_B() {\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p0,p1,p2,p3; cin >> p0 >> p1 >> p2 >> p3;\n        cout << intersectSP(p0,p1,p2,p3) << ln;\n    }\n}\n\nvoid CGL_2_C() {\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p0,p1,p2,p3; cin >> p0 >> p1 >> p2 >> p3;\n        Segment s0(p0,p1), s1(p2,p3);\n        cout << getCrossPointSP(s0,s1) << ln;\n    }\n}\n\nvoid CGL_2_D() {\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p0,p1,p2,p3; cin >> p0 >> p1 >> p2 >> p3;\n        Segment s0(p0,p1), s1(p2,p3);\n        cout << getDistanceSP(s0,s1) << ln;\n    }\n}\n\nvoid CGL_3_A() {\n    int N; cin >> N;\n    Polygon P(N);\n    rep(i,N) cin >> P[i];\n\n    cout << fixed << setprecision(1) << area(P) << ln;\n}\n\nvoid CGL_3_B() {\n    int N; cin >> N;\n    Polygon P(N);\n    rep(i,N) cin >> P[i];\n\n    cout << isConvex(P) << ln;\n}\n\nvoid CGL_3_C() {\n    int N; cin >> N;\n    Polygon P(N);\n    rep(i,N) cin >> P[i];\n\n    int Q; cin >> Q;\n    while (Q--) {\n        Point p; cin>> p;\n        cout << containment(P,p) << ln;\n    }\n}\n\nvoid CGL_4_A() {\n    int N; cin >> N;\n    Polygon P(N);\n    rep(i,N) cin >> P[i];\n\n    auto ans = andrewScan(P);\n    cout << ans.size() << ln;\n    for (const auto &i : ans) {\n        cout << (int)round(i.x) << \" \" << (int)round(i.y) << ln;\n    }\n}\n\nvoid CGL_4_B() {\n    int N; cin >> N;\n    Polygon P(N);\n    rep(i,N) cin >> P[i];\n\n    cout << farthestpointpair(P) << ln;\n}\n\nvoid CGL_7_A() {\n    Circle c1,c2; cin >> c1 >> c2;\n    cout << intersect(c1,c2) << ln;\n}\n\nvoid CGL_7_F() {\n    Point p; cin >> p;\n    Circle c; cin >> c;\n    auto ans = tangent(c,p);\n    Polygon P = {ans.first.p2, ans.second.p2};\n    sort(all(P));\n    cout << P[0] << ln;\n    cout << P[1] << ln;\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    cout << fixed << setprecision(20);\n    //CGL_1_A();\n    //CGL_1_B();\n    //CGL_1_C();\n    //CGL_2_A();\n    //CGL_2_B();\n    //CGL_2_C();\n    //CGL_2_D();\n    //CGL_3_A();\n    //CGL_3_B();\n    //CGL_3_C();\n    //CGL_4_A();\n    CGL_4_B();\n    //CGL_7_A();\n    //CGL_7_F();\n}\n\n/*\n  verified on 2020/06/03\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=ja\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F&lang=ja\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tint si=i,sj=j;\n\tR res=0.0;\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0){\n\t\t\tassert(0==1);\n\t\t\ti=(i+1)%n;\n\t\t}else{\n\t\t\tj=(j+1)%n;\n\t\t}\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-10;\nint sign(double x)\n{\n    if(fabs(x)<=eps)return 0;\n    if(x>0)return 1;\n    return -1;\n}\nstruct Point{\n    double x,y;\n    Point(double _x=0,double _y=0):x(_x),y(_y){}\n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double k){return Point(x*k,y*k);}\n    Point operator / (double k){return Point(x/k,y/k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator < (const Point &p)const{return x!=p.x?x<p.x:y<p.y;}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\nint ccw(Point p0,Point p1,Point p2)\n{\n    Vector a=p1-p0,b=p2-p0;\n    if(sign(cross(a,b))==1)return 1;\n    return 0;\n}\nint n;\nPoint p;\nPolygon g,s,ans;\ndouble Area(Point a,Point b,Point c)\n{\n    Vector x1=b-a,y1=c-a;\n    return cross(x1,y1);\n}\nPolygon andrew()\n{\n    s=g;\n    int n=s.size();\n    sort(s.begin(),s.end());\n    Polygon u;\n    for(int i=0;i<n;i++){\n        for(int j=u.size();j>=2&&sign(Area(u[j-2],u[j-1],s[i]))>=0;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    int tmp=u.size()+1;\n    for(int i=n-2;i>=0;i--){\n        for(int j=u.size();j>=tmp&&sign(Area(u[j-2],u[j-1],s[i]))>=0;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    if(n>1)u.pop_back();\n    reverse(u.begin(),u.end());\n    return u;\n}\ndouble rc()\n{\n    double res=0;\n    int n=ans.size();\n    int k=1;\n    for(int i=0;i<n;i++){\n        while(sign(Area(ans[i],ans[(i+1)%n],ans[(k+1)%n])-Area(ans[i],ans[(i+1)%n],ans[k%n]))==1)k=(k+1)%n;\n        res=max(res,(ans[i]-ans[k]).abs());\n    }\n    return res;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lf%lf\",&p.x,&p.y);\n        g.push_back(p);\n    }\n    ans=andrew();\n    printf(\"%.10f\\n\",rc());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define PI acos(-1.0)\n#define EPS 1e-9\n\ndouble toRadian(double deg) {return ((deg*PI)/180.0);}\ndouble toDegree(double radian) {return ((radian*180.0)/PI);}\ndouble handleNegZero(double x) {return ((abs(x) < EPS)?0.0:x);}\n\nstruct point_i { int x, y;     // whenever possible, work with point_i\n  point_i() { x = y = 0; }                      // default constructor\n  point_i(int _x, int _y) : x(_x), y(_y) {} };         // user-defined\n\nstruct Point { //Integer Point\n    double x, y;\n    Point(){}\n    Point(double _x, double _y):x(_x), y(_y){}\n\n    bool operator < (const Point &p) const {\n        if(abs(x - p.x) <= EPS) return ((y - p.y) <= EPS);\n        return ((x - p.x) <= EPS);\n    }\n\n    bool operator == (Point other) const {\n        return ((fabs(x - other.x) < EPS) && (fabs(y - other.y) < EPS));\n    }\n};\n\ndouble pointDistaceSquared2D (Point a, Point b) {return (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);}\ndouble dist (Point a, Point b) {return sqrt(pointDistaceSquared2D(a, b));}\n// rotate p by theta degrees CCW w.r.t origin (0, 0)\nPoint rotate(Point p, double theta) {\n    double rad = toRadian(theta);\n    return Point(p.x * cos(rad) - p.y * sin(rad),\n                 p.x * sin(rad) + p.y * cos(rad));\n}\n\nstruct line {double a, b, c;};\nvoid pointsToLine(Point p1, Point p2, line &l) {\n    if(fabs(p1.x-p2.x) < EPS) {\n        l.a = 1.0; l.b = 0.0; l.c = -p1.x;\n    } else {\n        l.a = -(double)(p1.y-p2.y) / (p1.x-p2.x);\n        l.b = 1.0;\n        l.c = -(double)(l.a*p1.x)-p1.y;\n    }\n}\n\nbool areParallel(line l1, line l2) {\n    return (fabs(l1.a-l2.a) < EPS) && (fabs(l1.b-l2.b) < EPS);\n}\n\nbool areSame(line l1, line l2) {\n    return areParallel(l1, l2) && (fabs(l1.c-l2.c) < EPS);\n}\n\nbool areIntersect(line l1, line l2, Point &p) {\n    if(areParallel(l1, l2)) return false;\n    p.x = (l2.b*l1.c-l1.b*l2.c) / (l2.a*l1.b-l1.a*l2.b);\n    if(fabs(l1.b) > EPS) p.y = -(l1.a*p.x+l1.c);\n    else                 p.y = -(l2.a*p.x+l2.c);\n    return true;\n}\n\n// Given three colinear points p, q, r, the function checks if\n// point q lies on line segment 'pr'\nbool onSegment(Point p, Point q, Point r)\n{\n    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n        q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))\n       return true;\n\n    return false;\n}\n\n// To find orientation of ordered triplet (p, q, r).\n// The function returns following values\n// 0 --> p, q and r are colinear\n// 1 --> Clockwise\n// 2 --> Counterclockwise\nint orientation(Point p, Point q, Point r)\n{\n    // See 10th slides from following link for derivation of the formula\n    // http://www.dcs.gla.ac.uk/~pat/52233/slides/Geometry1x1.pdf\n    int val = (q.y - p.y) * (r.x - q.x) -\n              (q.x - p.x) * (r.y - q.y);\n\n    if (val == 0) return 0;  // colinear\n\n    return (val > 0)? 1: 2; // clock or counterclock wise\n}\n\n// The main function that returns true if line segment 'p1q1'\n// and 'p2q2' intersect.\nbool LineSegmentIntersect(Point p1, Point q1, Point p2, Point q2)\n{\n    // Find the four orientations needed for general and\n    // special cases\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    // Special Cases\n    // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n\n    // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n\n    // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n\n     // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false; // Doesn't fall in any of the above cases\n}\n\nstruct vec {\n    double x, y;\n    vec(){}\n    vec(double _x, double _y):x(_x), y(_y){}\n};\n\nvec toVec(Point a, Point b) {return vec(b.x - a.x, b.y - a.y);}\nvec scale(vec v, double s) {return vec(v.x*s, v.y*s);}\nPoint translate(Point p, vec v) {return Point(p.x + v.x, p.y + v.y);}// translate p according to v\ndouble dot(vec a, vec b) {return (a.x*b.x + a.y*b.y);}\ndouble norm_sq(vec v) {return v.x*v.x + v.y*v.y;}\n\n// returns the distance from p to the line defined by\n// two points a and b (a and b must be different)\n// the closest point is stored in the 4th parameter (byref)\ndouble distToLine(Point p, Point a, Point b, Point &c) {\n    // formula: c = a + u* ab\n    vec ap = toVec(a, p), ab = toVec(a, b);\n    double u = dot(ap, ab) / norm_sq(ab);\n    c = translate(a, scale(ab, u));\n    return dist(p, c);\n}\n\n// returns the distance from p to the line segment ab defined by\n// two points a and b (still OK if a == b)\n// the closest point is stored in the 4th parameter (byref)\ndouble distToLineSegment(Point p, Point a, Point b, Point &c) {\n    vec ap = toVec(a, p), ab = toVec(a, b);\n    double u = dot(ap, ab) / norm_sq(ab);\n    if (u < 0.0) {\n        c = Point(a.x, a.y);\n        return dist(p, a);\n    }\n\n    if(u > 1.0) {\n        c = Point(b.x, b.y);\n        return dist(p, b);\n    }\n\n    return distToLine(p, a, b, c);\n}\n\ndouble angle(Point a, Point o, Point b) { // returns angle aob in rad\n    vec oa = toVec(o, a), ob = toVec(o, b);\n    return acos(dot(oa, ob) / sqrt(norm_sq(oa) * norm_sq(ob)));\n}\n\ndouble cross(vec a, vec b) {return a.x*b.y - a.y*b.x;}\n// note: to accept collinear points, we have to change the '> 0'\n// returns true if point r is on the left side of line pq\nbool ccw(Point p, Point q, Point r) {return cross(toVec(p, q), toVec(p, r)) > 0;}\n// returns true if point r is on the same line as the line pq\nbool collinear(Point p, Point q, Point r) {\n    return fabs(cross(toVec(p, q), toVec(p, r))) < EPS;\n}\n\ndouble trianglePerimeter(double a, double b, double c) {return (a+b+c)*0.5;}\ndouble triangleArea(double b, double h) {return (b*h)*0.5;}\ndouble triangleArea(double a, double b, double c) {\n    double s = trianglePerimeter(a, b, c);\n    return sqrt( s*(s-a)*(s-b)*(s-c) );\n}\n\n//in radian\ndouble triangleAngle(double a, double b, double c) {//angle opposite to line c\n    double nume = a*a+b*b-c*c;\n    double denom = 2.0*a*b;\n    return acos(nume/denom);\n}\n\nint insideCircle(point_i p, point_i c, int r) { // all integer version\n  int dx = p.x - c.x, dy = p.y - c.y;\n  int Euc = dx * dx + dy * dy, rSq = r * r;             // all integer\n  return Euc < rSq ? 0 : Euc == rSq ? 1 : 2;\n} //inside/border/outside\n\n//Given the intersection point p1, p2 and radius r find centers\nbool circle2PtsRad(Point p1, Point p2, double r, Point &c) {\n  double d2 = (p1.x - p2.x) * (p1.x - p2.x) +\n              (p1.y - p2.y) * (p1.y - p2.y);\n  double det = r * r / d2 - 0.25;\n  if (det < 0.0) return false;\n  double h = sqrt(det);\n  c.x = (p1.x + p2.x) * 0.5 + (p1.y - p2.y) * h;\n  c.y = (p1.y + p2.y) * 0.5 + (p2.x - p1.x) * h;\n  return true;\n}         // to get the other center, reverse p1 and p2\n\ndouble circleCircumference(double r) {return 2.0*PI*r;}\ndouble circleArea(double r){return PI*r*r;}\ndouble circleSectorArea(double r, double theta) {\n    return (circleArea(r)*theta)/360.0;\n}\n\n//Given three sides of a triangle\ndouble inCircleRadius(double a, double b, double c) {\n    double area = triangleArea(a, b, c);\n    double s = trianglePerimeter(a, b, c);\n    return (area/s);\n}\n\n//Given three sides of a triangle\ndouble circumCircleRadius(double a, double b, double c) {\n    double  A = triangleAngle(b, c, a);\n    double  d = a / sin(A);\n    return d*=0.5;\n}\n\ndouble coneArea(double h, double r) {return (PI*r*r*h)/3.0;}\ndouble coneFrustumArea(double R, double r, double h) {return ((R*R+R*r+r*r)*PI*h)/3.0;}\n\n//Polygon\n// returns the perimeter, which is the sum of Euclidian distances\n// of consecutive line segments (polygon edges)\ndouble perimeter(const vector<Point> &P) {\n  double result = 0.0;\n  for (int i = 0; i < (int)P.size()-1; i++)  // remember that P[0] = P[n-1]\n    result += dist(P[i], P[i+1]);\n  return result; }\n\n// returns the area, which is half the determinant\ndouble area(const vector<Point> &P) {\n  double result = 0.0, x1, y1, x2, y2;\n  for (int i = 0; i < (int)P.size()-1; i++) {\n    x1 = P[i].x; x2 = P[i+1].x;\n    y1 = P[i].y; y2 = P[i+1].y;\n    result += (x1 * y2 - x2 * y1);\n  }\n  return fabs(result) / 2.0; }\n\n// returns true if we always make the same turn while examining\n// all the edges of the polygon one by one\nbool isConvex(const vector<Point> &P) {\n  int sz = (int)P.size();\n  if (sz <= 3) return false;   // a point/sz=2 or a line/sz=3 is not convex\n  bool isLeft = ccw(P[0], P[1], P[2]);               // remember one result\n  for (int i = 1; i < sz-1; i++)            // then compare with the others\n    if (ccw(P[i], P[i+1], P[(i+2) == sz ? 1 : i+2]) != isLeft)\n      return false;            // different sign -> this polygon is concave\n  return true; }                                  // this polygon is convex\n\n// returns true if point p is in either convex/concave polygon P\nbool inPolygon(Point pt, const vector<Point> &P) {\n  if ((int)P.size() == 0) return false;\n  double sum = 0;    // assume the first vertex is equal to the last vertex\n  for (int i = 0; i < (int)P.size()-1; i++) {\n    if (ccw(pt, P[i], P[i+1]))\n         sum += angle(P[i], pt, P[i+1]);                   // left turn/ccw\n    else sum -= angle(P[i], pt, P[i+1]); }                 // right turn/cw\n  return fabs(fabs(sum) - 2*PI) < EPS; }\n\n// line segment p-q intersect with line A-B.\nPoint lineIntersectSeg(Point p, Point q, Point A, Point B) {\n  double a = B.y - A.y;\n  double b = A.x - B.x;\n  double c = B.x * A.y - A.x * B.y;\n  double u = fabs(a * p.x + b * p.y + c);\n  double v = fabs(a * q.x + b * q.y + c);\n  return Point((p.x * v + q.x * u) / (u+v), (p.y * v + q.y * u) / (u+v)); }\n\n// cuts polygon Q along the line formed by Point a -> Point b\n// (note: the last Point must be the same as the first Point)\nvector<Point> cutPolygon(Point a, Point b, const vector<Point> &Q) {\n  vector<Point> P;\n  for (int i = 0; i < (int)Q.size(); i++) {\n    double left1 = cross(toVec(a, b), toVec(a, Q[i])), left2 = 0;\n    if (i != (int)Q.size()-1) left2 = cross(toVec(a, b), toVec(a, Q[i+1]));\n    if (left1 > -EPS) P.push_back(Q[i]);       // Q[i] is on the left of ab\n    if (left1 * left2 < -EPS)        // edge (Q[i], Q[i+1]) crosses line ab\n      P.push_back(lineIntersectSeg(Q[i], Q[i+1], a, b));\n  }\n  if (!P.empty() && !(P.back() == P.front()))\n    P.push_back(P.front());        // make P's first Point = P's last Point\n  return P; }\n\n// Returns a list of points on the convex hull in counter-clockwise order.\n// Note: the last point in the returned list is the same as the first one.\n// Uses 'Monotone Chain Algorithm', Runtime Complexity: O(n log n)\nvector<Point> convex_hull(vector<Point> P)\n{\n\tint n = P.size(), k = 0;\n\tvector<Point> H(2*n);\n\n\t// Sort points lexicographically\n\tsort(P.begin(), P.end());\n\n\t// Build lower hull\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (k >= 2 && !ccw(H[k-2], H[k-1], P[i])) k--;\n\t\tH[k++] = P[i];\n\t}\n\n\t// Build upper hull\n\tfor (int i = n-2, t = k+1; i >= 0; i--) {\n\t\twhile (k >= t && !ccw(H[k-2], H[k-1], P[i])) k--;\n\t\tH[k++] = P[i];\n\t}\n\n\tH.resize(k);\n\treturn H;\n}\n\n// Finds a pair of points that have maximum distance between them\n// Or finds the diameter of convex hull;\ndouble diameter_convex_hull(vector<Point> P)\n{\n\tint n = P.size(), k = 0;\n\tvector<Point> H(2*n);\n\n\t// Sort points lexicographically\n\tsort(P.begin(), P.end());\n\n\t// Build lower hull\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (k >= 2 && !ccw(H[k-2], H[k-1], P[i])) k--;\n\t\tH[k++] = P[i];\n\t}\n\n\tH.resize(k);\n\treturn dist(H[0], H[H.size()-1]);\n}\n\nvector<Point> p;\n\nint main() {\n    //freopen(\"in\", \"r\", stdin);\n    int n;\n    double x, y;\n\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &x, &y);\n        p.push_back(Point(x, y));\n    }\n\n    printf(\"%0.10lf\\n\", diameter_convex_hull(p));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\ntypedef long double     lf;\n\nusing namespace std;\n\nconst lf EPS = 1e-9;\nconst lf oo = 1e15;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << int(p.x) << \" \" << int(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf dot( pt A, pt B ) {\n  return x(A)*x(B) + y(A)*y(B);\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nlf distToLine (pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  c = A + u*( B-A );\n  return dist( p , c );\n}\n\npt refPoint(pt X, pt A, pt B) {\n  pt aux; distToLine(X, A, B, aux);\n  return X + lf(2.0)*(aux-X);\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf cross( pt A, pt B ) {\n  return x(A)*y(B) - y(A)*x(B);\n}\n\n///CHANGE\n// 0  for collineal points ( angle = 0 )\n// 1  for angle BAX counter clockwise\n// -1 for angle BAX clockwise\ninline int ccw (pt X, pt A, pt B) {\n  lf c = cross( B-A, X-A );\n  if( same( c, 0.0 ) ) { return 0; }\n  if( c > EPS ) { return 1; }\n  return -1;\n}\n\n///CHANGE\ninline bool segContains ( pt X, pt A, pt B) {\n  if ( !same ( 0, cross ( A-X, B-X ) ) ) return 0;\n  return ( dot ( A-X, B-X ) < EPS );\n}\n\ninline bool parallel( pt A, pt B, pt C, pt D ) {\n  return same ( 0, cross( B-A, D-C ) );\n}\n\n///NEW\ninline bool ortho( pt A, pt B, pt C, pt D ) {\n  return same ( 0, dot( B-A, D-C ) );\n}\n\ninline bool samePt ( pt A, pt B ) {\n  return same ( x(A), x(B) ) && same ( y(A), y(B) );\n}\n\npt linesIntersection ( pt A, pt B, pt C, pt D ) {\n  lf x = cross ( C, D-C ) - cross ( A, D-C );\n  x /= cross ( B-A, D-C );\n  return A + x*(B-A);\n}\n\ninline bool collinearSegsIntersects ( pt A, pt B, pt C, pt D ) {\n  return segContains(A,C,D) || segContains(B,C,D)\n      || segContains(C,A,B) || segContains(D,A,B);\n}\n\nbool segmentsIntersect(pt A, pt B, pt C, pt D) {\n  if( samePt(A,B) )\n    return segContains( A, C, D );\n  if( samePt(C,D) )\n    return segContains( C, A, B );\n  if( parallel(A,B,C,D) )\n    return collinearSegsIntersects( A,B,C,D );\n  pt aux = linesIntersection(A,B,C,D);\n  return segContains(aux,A,B) && segContains(aux,C,D);\n}\n\n///CHANGE\nlf distToSegment(pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  if( u < -EPS ) { c = A; return dist( p , A ); }\n  if( (u-1.0) > EPS ) { c = B; return dist( p, B ); }\n  return distToLine(p,A,B,c);\n}\n\n// P[0] must be equal to P[n]\n// Area is positive if the polygon is ccw\ndouble signedArea(const vector<pt> &P) {\n  double result = 0.0;\n  for(int i = 0; i < (int)P.size()-1; i++) result += cross( P[i],P[i+1] );\n  return result / 2.0;\n}\n\ndouble area(const vector<pt> &P) { return fabs(signedArea(P)); }\n\n///CHANGE\n// P[0] must be equal to P[n]\nbool isConvex( const vector<pt> &P) {\n  int sz = (int) P.size(); if(sz <= 3) return false;\n  bool isL = ccw(P[0], P[1], P[2]) >= 0;\n  for (int i = 1; i < sz-1; i++) {\n    if( ( ccw(P[i], P[i+1], P[(i+2) == sz ? 1 : i+2]) >= 0 ) != isL) return false;\n  }\n  return true;\n}\n\n///CHANGE\n// P[0] must be equal to P[n]     -    O(N)\n// Return 1 for interior, 0 for boundary and -1 for exterior\nint inPolygon(pt X, const vector<pt> &P) {\n  const int n = P.size(); int cnt = 0;\n  for (int i = 0; i < n-1; i++) {\n    if( segContains(X, P[i], P[i+1]) ) return 0;\n    if( y(P[i]) <= y(X) ) {\n      if( y(P[i+1]) > y(X) )\n        if( !(ccw( X, P[i], P[i+1]) >= 0) ) cnt++;\n    }\n    else if ( y(P[i+1]) <= y(X) ) {\n      if( ccw( X, P[i], P[i+1]) >= 0 ) cnt--;\n    }\n  }\n  if(cnt == 0) return -1;\n  else return 1;\n}\n\n///CHANGE\n//CONVEX HULL Monotone Chain O( N Log N )\nbool cmpPt( pt A, pt B ) {\n  if( !same( x(A), x(B) ) ) return x(A) < x(B);\n  return y(A) < y(B);\n}\n\nint turn(pt A, pt B, pt C) {\n  lf r = cross(B-A, C-A);\n  if( same( r, 0.0 ) ) return 0;\n  if( r > EPS ) return 1;\n  return -1;\n}\n\n// Return CH in ccw order starting at leftmost - downmost x\n// Doesn't return P[ n ] = P[ 0 ]\nvector<pt> CH( vector<pt> &P ) {\n  if ( P.size() == 1 ) return P;\n  const int n = P.size();\n  sort ( P.begin(), P.end(), cmpPt );\n  vector<pt> up;\n  up.push_back(P[0]); up.push_back(P[1]);\n  vector<pt> dn;\n  dn.push_back(P[0]); dn.push_back(P[1]);\n  for ( int i = 2; i < n; ++i ) {\n    // If collineal points are not needed, is >= and <=, otherwise > and <\n    while ( up.size() > 1 && turn(up[up.size()-2],up.back(),P[i]) >= 0 )\n      up.pop_back();\n    while ( dn.size() > 1 && turn(dn[dn.size()-2],dn.back(),P[i]) <= 0 )\n      dn.pop_back();\n    up.push_back(P[i]);\n    dn.push_back(P[i]);\n  }\n  for (int i = (int) up.size() - 2; i >= 1; i--) dn.push_back(up[i]);\n  return dn;\n}\n\n/// --------------------------------------------\n\nint n;\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  vector<pt> P(n);\n  pt A(oo,0) , B(-oo,0);\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n    if( same( x(P[i]), x(A) ) ) {\n      if( y(P[i])+EPS < y(A) ) {\n        A = P[i];\n      }\n    }\n    else if( x(P[i])+EPS < x(A) ) {\n      A = P[i];\n    }\n\n    if( same( x(P[i]), x(B) ) ) {\n      if( y(P[i]) > x(A)+EPS ) {\n        B = P[i];\n      }\n    }\n    else if( x(P[i]) > x(B)+EPS ) {\n      B = P[i];\n    }\n  }\n  cout << double( dist( A, B ) ) << '\\n';\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nint main() {\n    int64_t n;\n    std::cin >> n;\n\n    std::vector<double> x(n);\n    std::vector<double> y(n);\n    for (auto i = 0; i < n; ++i) {\n        std::cin >> x[i] >> y[i];\n    }\n\n    double ans = 0.0;\n\n    for (auto i = 0; i < n; ++i) {\n        for (auto j = 0; j < n; ++j) {\n            ans = std::max(ans, std::pow(x[i]-x[j],2) + std::pow(y[i]-y[j],2));\n        }\n    }\n\n    std::cout << std::setprecision(8) << std::sqrt(ans) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nint ans = 0;\n  const double EPS = 1e-8;\n  const double INF = 1e12;\n  typedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\n  namespace std {\n    bool operator < (const P& a, const P& b) {//x????????????\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool sorty(const P& a, const P& b) {//y????????????\n      return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n  }\n  double cross(const P& a, const P& b) {//??????\n    return imag(conj(a)*b);\n  }\n  double dot(const P& a, const P& b) {//??????\n    return real(conj(a)*b);\n  }\n\n  struct L : public vector<P> {//??´???\n    L(){};\n    L(const P &a, const P &b) {\n      push_back(a); push_back(b);\n    }\n  };\n\n  typedef vector<P> G;\n\n  struct C {//???\n    P p; double r;\n    C(){};\n    C(const P &p, double r) : p(p), r(r) { }\n  };\n  int ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0; // a--c--b on line\n  }\n  int linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n    P a = ab[1] - ab[0],b = cd[1] - cd[0];\n    if(abs(cross(a,b)) < EPS){ // Parallel\n      return 2;\n    }\n    else if(abs(dot(a,b)) < EPS){ //Orthogonal\n      return 1;\n    }\n    return 0;\n  }\n  // L:line,S:segment,P:point\n  bool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n      abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n  }\n  bool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n      cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n  }\n  bool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n  }\n  bool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n      ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n  }\n  bool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n  }\n  // L & P intersection\n  P projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n  }\n  // L????????????P???????°????\n  P reflection(const L &l, const P &p) {\n    return p + 2.0 * (projection(l, p) - p);\n  }\n  double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n  }\n  double distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n  }\n  double distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n  }\n  double distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n  }\n  double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n  }\n  double distancePP(const P &p,const P &q){\n    return abs(p - q) ;\n  }\n  P crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n  }\n  P verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n    if(a.real() == b.real()){\n      return {1.0,0};\n    }\n    if(a.imag() == b.imag()){\n      return {0,1.0};\n    }\n    P p = a - b;\n    P res = {-p.imag(),p.real()};\n    return res / abs(p);\n  }\n  pair<P,P> crosspointCircle(const C &a,const C &b){\n    P m = (a.p+b.p)/2.0;\n    P vv = verticalvector(a.p,b.p);\n    double u = sqrt( a.r * a.r - norm(a.p - b.p) / 4.0);\n    P A = m + u * vv,B = m - u * vv;\n    return mp(A,B);\n  }\n  double calc_triangle(P a,P b,P c){\n    P ba = (b - a);\n    P ca = (c - a);\n    return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n  }\n  double calc_area(const G &g){\n    double res = 0;\n    rep(i,g.size()-2){\n      res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n    }\n    return res;\n  }\n  bool is_convex(const G &g){\n    if(g.size() == 3) return true;\n    rep(i,g.size()){\n      if(ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != 1 && ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != -2){\n        return false;\n      }\n    }\n    return true;\n  }\n  int convex_point(const G &g,const P &p){\n    P q = p-P(-INF,imag(p));\n    double x = real(p),y = imag(p);\n    L l1(p,q);\n    ll cn = 0;\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      L l2 = L(a,b);\n      int k = ccw(a,b,p);\n      if(k == 0){\n        return 1; // p on g\n      }\n    }\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      double y1 = imag(a),y2 = imag(b);\n      if(!(y1 == y && y2 == y) && ((y1 <= y && y < y2) || (y2 <= y && y < y1))){\n        L l2 = L(a,b);\n        P c = crosspoint(l1,l2);\n        if(x < real(c))\n          ++cn;\n      }\n    }\n    if(cn % 2) return 2; // p in g\n    return 0; // p out g\n  }\nvector<P> convex_hull(vector<P> &ps){\n  sort(all(ps));\n  int k = 0;\n  int n = ps.size();\n  vector<P> qs(ps.size() * 2);\n  rep(i,ps.size()){\n    while(k > 1 && cross((qs[k-1] -qs[k-2]),(ps[i] - qs[k-1])) < 0){\n      k--;\n    }\n    qs[k++] = ps[i];\n  }\n  for(int i = n-2,t = k; i >= 0; i--){\n    while(k>t && cross((qs[k-1] - qs[k-2]),(ps[i]-qs[k-1])) < 0){\n      k--;\n    }\n    qs[k++] = ps[i] ;\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  double x,y;\n  cin >> n;\n  vector<P> v(n);\n  rep(i,n){\n    cin >> x >> y;\n    v[i] = P{x,y};\n  }\n  auto hull = convex_hull(v);\n  int k = hull.size(),st = 0;\n  double res = 0;\n  rep(i,k){\n    REP(j,i+1,k){\n      res = max(res,distancePP(hull[i],hull[j]));\n    }\n  }\n  fcout(10) << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\nusing namespace std;\n\ntemplate <class T> void readPoint(vector< vector<T> >& vec, int idx) {\n    T x, y;\n    vector<T> point(2);\n    cin >> x >> y;\n    point[0] = x;\n    point[1] = y;\n    vec[idx] = point;\n}\ndouble dist(double x1, double y1, double x2, double y2) {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\nint main()\n{\n    int size;\n    cin >> size;\n    vector< vector<double> > points(size);\n    for (int i = 0; i < size; i++) {\n        readPoint(points, i);\n    }\n    int prev_idx(0), cur_idx(0), max_idx(0);\n    double dia, max_dia(0);;\n    do {\n        prev_idx = cur_idx;\n        cur_idx = max_idx;\n        for (int i = 0; i < size; i++) {\n             dia = dist(points[cur_idx][0], points[cur_idx][1], points[i][0], points[i][1]);\n             if (dia > max_dia) {\n                 max_idx = i;\n                 max_dia = dia;\n             }  \n        }\n\n    } while (prev_idx != max_idx);\n    \n\n    cout << max_dia << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n     \n     \n    \n    \n    \n    \n    *q=k-1;\n    \n}\nint main(int argc, const char * argv[]){\n    //cout<<angle_two_line_0_359(0,0, 2,1,4,2)/M_PI<<endl;\n\n    //cout<<angle_of_the_line(0,0,0,0)/M_PI * 180<<endl;\n    //cout<<angle_line_0_359(1, 3,2, 2)/M_PI*180.0<<endl;\n    //cout<<angle_line_0_359(1, 3,0, 0)/M_PI*180.0<<endl;\n\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n        \n        double max_l = 0.0;\n        for(int i=0; i<q; i++){\n            for(int j=0; j<q; j++){\n                max_l=max(max_l,distance_between_the_two_pointss(ans[i][0], ans[i][1], ans[j][0], ans[j][1]));\n            }\n        }\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    #define diff(P, i) (P[(i+1)%P.size()] - P[i])\n    int n = cpol.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(cpol[i]) > imag(cpol[is])) is = i;\n        if (imag(cpol[i]) < imag(cpol[js])) js = i;\n    }\n    LD maxd = norm(cpol[is]-cpol[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (Cross(diff(cpol,i), diff(cpol,j)) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (norm(cpol[i]-cpol[j]) > maxd) {\n            maxd = norm(cpol[i]-cpol[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n    pair<int, int> ans = ConvexPolygonDiameter(p);\n    printf(\"%.9Lf\\n\", DistPP(p[ans.first], p[ans.second]));\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define eq(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-8;\nconst double EPS_GIG = 1e-3;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\n\n// 扇型、中心と半径、二つの端点\n// 現在中心角が180未満の前提\nstruct sector {\n\tpoint o;\n\tpoint a, b;\n\tdouble r;\n\tsector(){}\n\tsector(point O, point A, point B, double _r) :o(O), a(A), b(B), r(_r) {}\n};\n\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > 2 * PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS)   return +1;       // counter clockwise\n\tif (cross(b, c) + EPS < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\tauto a = s[0] - p;\n\tauto b = s[1] - p;\n\treturn (abs(cross(a, b)) < EPS && dot(a, b) <= EPS); // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n//端点の交差hは考えない\nbool strictIntersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) == -1 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) == -1;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n/*多角形内包判定\nhalf-line crossing method\nOUT:0\nON:1\nIN:2\n*/\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) <= EPS) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n/*\nOUT:0\nON:1\nIN:2\n*/\nint contain_sector(const sector &sec, point &p){\n\tif(eq(abs(p - sec.o), sec.r))return 1;\n\tif(intersectSP(segment(sec.o, sec.a), p))return 1;\n\tif(intersectSP(segment(sec.o, sec.b), p))return 1;\n\tif(abs(p - sec.o) + EPS > sec.r)return 0;\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(angle(vec, vecA) + EPS < angle(vecA, vecB) && angle(vec, vecB) + EPS < angle(vecA, vecB))return 2;\n\treturn 0;\n}\n\n//交点\npoint crosspointSS(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<point> crosspointCL(const circle &c, const segment &l) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto pro_p = projection(l, c.p);\n\tauto dist = distanceLP(l, c.p);\n\tif(abs(dist - c.r) < EPS){\n\t\tret[0] = pro_p;\n\t\treturn ret;\n\t}\n\tif(c.r < dist){\n\t\treturn ret;\n\t}\n\tpoint vec = (l[1] - l[0]) * sqrt(c.r * c.r - dist * dist) / abs(l[1] - l[0]);\n\tret[0] = pro_p + vec;\n\tret[1] = pro_p - vec;\n\treturn ret;\n}\n\nvector<point> crosspointCC(const circle c1, const circle c2) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto dist = abs(c2.p - c1.p);\n\tif(eq(dist, c1.r + c2.r) || eq(dist, abs(c2.r - c1.r))){\n\t\tauto tmp = c2.p - c1.p;\n\t\tret[0] = c1.p + tmp * (c1.r / dist);\n\t\treturn ret;\n\t}\n\tif(c1.r + c2.r < dist || dist < abs(c1.r - c2.r)){\n\t\treturn ret;\n\t}\n\tauto alpha = acos((c1.r * c1.r + dist * dist - c2.r * c2.r) / (2 * c1.r * dist));\n\tauto theta = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n\tret[0] = c1.p + point(cos(theta + alpha) * c1.r, sin(theta + alpha) * c1.r);\n\tret[1] = c1.p + point(cos(theta - alpha) * c1.r, sin(theta - alpha) * c1.r);\n\treturn ret;\n}\n\nbool isOnSector(const sector sec, const point p) {\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(eq(angle(vec, vecA) + angle(vec, vecB), angle(vecA, vecB)))return true;\n\treturn false;\n}\n\nvector<point> crosspointSecS(const sector sec, const segment s) {\n\tcircle c = circle(sec.o, sec.r);\n\tauto ret = crosspointCL(c, s);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(eq(ret[i], inf))continue;\n\t\tif(!isOnSector(sec, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!intersectSP(s, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\nvector<point> crosspointSecSec(const sector sec1, const sector sec2) {\n\tcircle c1 = circle(sec1.o, sec1.r);\n\tcircle c2 = circle(sec2.o, sec2.r);\n\tauto ret = crosspointCC(c1, c2);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(!isOnSector(sec1, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!isOnSector(sec2, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a + b) * 0.5;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= EPS) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tif(ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]) == -1)return false;\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointSS(segment(A, B), l));\n  }\n  return Q;\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tint n;cin >> n;\n\tvector<point> g;\n\tREP(i, n){\n\t\tdouble a, b;cin >> a >> b;\n\t\tg.EB(a, b);\n\t}\n\n\tcout << Decimal << convex_diameter(g) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\ntypedef long double     lf;\n\nusing namespace std;\n\nconst lf EPS = 1e-9;\nconst lf oo = 1e15;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << int(p.x) << \" \" << int(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf dot( pt A, pt B ) {\n  return x(A)*x(B) + y(A)*y(B);\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nlf distToLine (pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  c = A + u*( B-A );\n  return dist( p , c );\n}\n\npt refPoint(pt X, pt A, pt B) {\n  pt aux; distToLine(X, A, B, aux);\n  return X + lf(2.0)*(aux-X);\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf cross( pt A, pt B ) {\n  return x(A)*y(B) - y(A)*x(B);\n}\n\n///CHANGE\n// 0  for collineal points ( angle = 0 )\n// 1  for angle BAX counter clockwise\n// -1 for angle BAX clockwise\ninline int ccw (pt X, pt A, pt B) {\n  lf c = cross( B-A, X-A );\n  if( same( c, 0.0 ) ) { return 0; }\n  if( c > EPS ) { return 1; }\n  return -1;\n}\n\n///CHANGE\ninline bool segContains ( pt X, pt A, pt B) {\n  if ( !same ( 0, cross ( A-X, B-X ) ) ) return 0;\n  return ( dot ( A-X, B-X ) < EPS );\n}\n\ninline bool parallel( pt A, pt B, pt C, pt D ) {\n  return same ( 0, cross( B-A, D-C ) );\n}\n\n///NEW\ninline bool ortho( pt A, pt B, pt C, pt D ) {\n  return same ( 0, dot( B-A, D-C ) );\n}\n\ninline bool samePt ( pt A, pt B ) {\n  return same ( x(A), x(B) ) && same ( y(A), y(B) );\n}\n\npt linesIntersection ( pt A, pt B, pt C, pt D ) {\n  lf x = cross ( C, D-C ) - cross ( A, D-C );\n  x /= cross ( B-A, D-C );\n  return A + x*(B-A);\n}\n\ninline bool collinearSegsIntersects ( pt A, pt B, pt C, pt D ) {\n  return segContains(A,C,D) || segContains(B,C,D)\n      || segContains(C,A,B) || segContains(D,A,B);\n}\n\nbool segmentsIntersect(pt A, pt B, pt C, pt D) {\n  if( samePt(A,B) )\n    return segContains( A, C, D );\n  if( samePt(C,D) )\n    return segContains( C, A, B );\n  if( parallel(A,B,C,D) )\n    return collinearSegsIntersects( A,B,C,D );\n  pt aux = linesIntersection(A,B,C,D);\n  return segContains(aux,A,B) && segContains(aux,C,D);\n}\n\n///CHANGE\nlf distToSegment(pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  if( u < -EPS ) { c = A; return dist( p , A ); }\n  if( (u-1.0) > EPS ) { c = B; return dist( p, B ); }\n  return distToLine(p,A,B,c);\n}\n\n// P[0] must be equal to P[n]\n// Area is positive if the polygon is ccw\ndouble signedArea(const vector<pt> &P) {\n  double result = 0.0;\n  for(int i = 0; i < (int)P.size()-1; i++) result += cross( P[i],P[i+1] );\n  return result / 2.0;\n}\n\ndouble area(const vector<pt> &P) { return fabs(signedArea(P)); }\n\n///CHANGE\n// P[0] must be equal to P[n]\nbool isConvex( const vector<pt> &P) {\n  int sz = (int) P.size(); if(sz <= 3) return false;\n  bool isL = ccw(P[0], P[1], P[2]) >= 0;\n  for (int i = 1; i < sz-1; i++) {\n    if( ( ccw(P[i], P[i+1], P[(i+2) == sz ? 1 : i+2]) >= 0 ) != isL) return false;\n  }\n  return true;\n}\n\n///CHANGE\n// P[0] must be equal to P[n]     -    O(N)\n// Return 1 for interior, 0 for boundary and -1 for exterior\nint inPolygon(pt X, const vector<pt> &P) {\n  const int n = P.size(); int cnt = 0;\n  for (int i = 0; i < n-1; i++) {\n    if( segContains(X, P[i], P[i+1]) ) return 0;\n    if( y(P[i]) <= y(X) ) {\n      if( y(P[i+1]) > y(X) )\n        if( !(ccw( X, P[i], P[i+1]) >= 0) ) cnt++;\n    }\n    else if ( y(P[i+1]) <= y(X) ) {\n      if( ccw( X, P[i], P[i+1]) >= 0 ) cnt--;\n    }\n  }\n  if(cnt == 0) return -1;\n  else return 1;\n}\n\n///CHANGE\n//CONVEX HULL Monotone Chain O( N Log N )\nbool cmpPt( pt A, pt B ) {\n  if( !same( x(A), x(B) ) ) return x(A) < x(B);\n  return y(A) < y(B);\n}\n\nint turn(pt A, pt B, pt C) {\n  lf r = cross(B-A, C-A);\n  if( same( r, 0.0 ) ) return 0;\n  if( r > EPS ) return 1;\n  return -1;\n}\n\n// Return CH in ccw order starting at leftmost - downmost x\n// Doesn't return P[ n ] = P[ 0 ]\nvector<pt> CH( vector<pt> &P ) {\n  if ( P.size() == 1 ) return P;\n  const int n = P.size();\n  sort ( P.begin(), P.end(), cmpPt );\n  vector<pt> up;\n  up.push_back(P[0]); up.push_back(P[1]);\n  vector<pt> dn;\n  dn.push_back(P[0]); dn.push_back(P[1]);\n  for ( int i = 2; i < n; ++i ) {\n    // If collineal points are not needed, is >= and <=, otherwise > and <\n    while ( up.size() > 1 && turn(up[up.size()-2],up.back(),P[i]) >= 0 )\n      up.pop_back();\n    while ( dn.size() > 1 && turn(dn[dn.size()-2],dn.back(),P[i]) <= 0 )\n      dn.pop_back();\n    up.push_back(P[i]);\n    dn.push_back(P[i]);\n  }\n  for (int i = (int) up.size() - 2; i >= 1; i--) dn.push_back(up[i]);\n  return dn;\n}\n\n/// --------------------------------------------\n\nint n;\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  vector<pt> P(n);\n  pt A(oo,0) , B(-oo,0);\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  int idx;\n  lf ans = -oo;\n  for( int i = 1; i < n; ++i ) {\n    lf d = dist(P[0], P[i]);\n    if( d > ans+EPS || same( d, ans ) ) {\n      idx = i;\n      ans = d;\n    }\n  }\n  lf prv = dist( P[1], P[1] );\n  int sz = int(P.size());\n  for( int i = 1, j = idx; i < idx; ++i ) {\n    while( prv+EPS < dist( P[i], P[j] ) ) {\n      prv = dist( P[i], P[j] );\n      j = (j+1)%sz;\n      ans = max( ans, prv );\n    }\n  }\n  cout << double(ans) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <deque>\n#include <queue>\nusing namespace std;\n#define rep(i,a,n) for(int i=(a);i<(n);i++)\n#define per(i,a,n) for(int i=(n)-1;i>=(a);i--)\n#define mp make_pair\n#define pb push_back\n\ntypedef double db;\n\nconst db EPS = 1e-8;\n\ninline int sign(db a) {\n    return a < -EPS ? -1 : a > EPS;\n}\n\ninline int cmp(db a, db b){//?????????????????°\n    return sign(a-b);\n}\n\nstruct P {//???\n    db x, y;\n    P() {}\n    P(db _x, db _y) : x(_x), y(_y) {}\n    P operator+(P p) { return P(x + p.x, y + p.y); }\n    P operator-(P p) { return P(x - p.x, y - p.y); }\n    P operator*(db d) { return P(x * d, y * d); }\n    P operator/(db d) { return P(x / d, y / d); }\n    bool operator<(P p) const {\n        int c = cmp(x, p.x);\n        if (c) return c == -1;\n        return cmp(y, p.y) == -1;\n    }\n    db dot(P p) { return x * p.x + y * p.y; }//????§?\n    db det(P p) { return x * p.y - y * p.x; }//????§?\n    db distTo(P p) { return (*this-p).abs(); }//??????\n    db alpha() { return atan2(y, x); }//?±?????§?\n    void read() { cin>>x>>y; }//?????\\\n    db abs() { return sqrt(abs2());}//??????\n    db abs2() { return x * x + y * y; }//???????????????\n    P rot90() { return P(-y,x);}//?????¶????????¬90???\n    P unit() { return *this/abs(); }//?????????\n    int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }//????§?????????¨[0,180)?????´\n};\n\nbool operator == (const P&a,const P& b){\n    return cmp(a.x,b.x) == 0 && cmp(a.y,b.y) == 0;\n}\n\nstruct L{ //ps[0] -> ps[1]\n    P ps[2];\n    P& operator[](int i) { return ps[i]; }\n    P dir() { return ps[1] - ps[0]; }//??´??????????????????\n    bool include(P p) { return sign((ps[1] - ps[0]).det(p - ps[0])) > 0; }//????????¨?????????????????¢????????¶????????¨???\n    L push(){ // push eps outward\n        const double eps = 1e-6;\n        P delta = (ps[1] - ps[0]).rot90().unit() * eps;\n        return {ps[0] - delta, ps[1] - delta};\n    }\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\n\nP isLL(P p1, P p2, P q1, P q2) {//?±??????´?????????\n    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n    return (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nP isLL(L l1,L l2){ return isLL(l1[0],l1[1],l2[0],l2[1]); }//?±??????´?????????\n\nbool intersect(db l1,db r1,db l2,db r2){\n    if(l1>r1) swap(l1,r1); if(l2>r2) swap(l2,r2);\n    return !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );\n}\n\nbool isSS(P p1, P p2, P q1, P q2){//?±???????????????????  ?????¬????§??????????\n    return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) &&\n           crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)\n                                                         * crossOp(q1,q2,p2) <= 0;\n}\n\nbool isMiddle(db a, db m, db b) {//??????m????????¨a,b?????´\n    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\n\nbool isMiddle(P a, P m, P b) {//?????????m?????????????????¨a,b?????´\n    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);\n}\n\nbool onSeg(P p1, P p2, P q){//?????????????????¨??´??????\n    return crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);\n}\n\nP proj(P p1, P p2, P q) {//????????´???????????±\n    P dir = p2 - p1;\n    return p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\n\nP reflect(P p1, P p2, P q){//????????´??????????§°\n    return proj(p1,p2,q) * 2 - q;\n}\n\ndb nearest(P p1,P p2,P q){\n    P h = proj(p1,p2,q);\n    if(isMiddle(p1,h,p2))\n        return q.distTo(h);\n    return min(p1.distTo(q),p2.distTo(q));\n}\n\ndb disSS(P p1, P p2, P q1, P q2){\n    if(isSS(p1,p2,q1,q2)) return 0;\n    return min(min(nearest(p1,p2,q1),nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)) );\n}\n\ndb disSS(L l1,L l2){\n    return disSS(l1[0],l1[1],l2[0],l2[1]);\n}\n\ndb rad(P p1,P p2){\n    return atan2l(p1.det(p2),p1.dot(p2));\n}\n\ndb incircle(P p1, P p2, P p3){\n    db A = p1.distTo(p2);\n    db B = p2.distTo(p3);\n    db C = p3.distTo(p1);\n    return sqrtl(A*B*C/(A+B+C));\n}\n\ndb area(vector<P> ps){\n    db ret = 0; rep(i,0,ps.size()) ret += ps[i].det(ps[(i+1)%ps.size()]);\n    return abs(ret/2);\n}\nint contain(vector<P> ps, P p){ //2:inside,1:on_seg,0:outside\n    int n = ps.size(), ret = 0;\n    rep(i,0,n){\n        P u=ps[i],v=ps[(i+1)%n];\n        if(onSeg(u,v,p)) return 1;\n        if(cmp(u.y,v.y)<=0) swap(u,v);\n        if(cmp(p.y,u.y) >0 || cmp(p.y,v.y) <= 0) continue;\n        ret ^= crossOp(p,u,v) > 0;\n    }\n    return ret*2;\n}\n\nvector<P> convexHull(vector<P> ps) {\n    int n = ps.size(); if(n <= 1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n * 2); int k = 0;\n    for (int i = 0; i < n; qs[k++] = ps[i++])\n        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])\n        while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;\n    qs.resize(k - 1);\n    return qs;\n}\n\n\ndb convexDiameter(vector<P> ps){\n    int n = ps.size(); if(n <= 1) return 0;\n    int is = 0, js = 0; rep(k,1,n) is = ps[k]<ps[is]?k:is, js = ps[js] < ps[k]?k:js;\n    int i = is, j = js;\n    db ret = ps[i].distTo(ps[j]);\n    do{\n        if((ps[(i+1)%n]-ps[i]).det(ps[(j+1)%n]-ps[j]) >= 0)\n            (++j)%=n;\n        else\n            (++i)%=n;\n        ret = max(ret,ps[i].distTo(ps[j]));\n    }while(i!=is || j!=js);\n    return ret;\n}\n\n\n\n\nint main(){\n    int n;\n    cin >> n;\n    vector<P> ps;\n    for(int i = 1;i <= n;i++){\n        P p;\n        p.read();\n        ps.push_back(p);\n    }\n    ps = convexHull(ps);\n    printf(\"%.15lf\\n\",convexDiameter(ps));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<int> Point;\n\ntypedef vector<Point> Polygon;\n\nnamespace std{\n\tbool operator < (const Point a, const Point b){\n\t\tif(a.real() == b.real()) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n}\n\nint dist(Point a, Point b){\n\treturn abs(a - b);\n}\n\nint cross(Point a, Point b){\n\treturn imag(conj(a) * b);\n}\n\nPolygon convex_hull(vector<Point> ps){\n\tint n = ps.size();\n\tsort(ps.begin(), ps.end());\n\tint k = 0;\n\tvector<Point> qs(n * 2);\n\tfor(int i=0;i<n;i++){\n\t\twhile(k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\twhile(k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<Point> vec;\n\tfor(int i=0;i<n;i++){\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tvec.push_back(Point(a, b));\n\t}\n\tPolygon ans = convex_hull(vec);\n\tcout << ans.size() << endl;\n\tfor(int i=0;i<(int)ans.size();i++){\n\t\tcout << ans[i].real() << ' ' << ans[i].imag() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing T = double;\nconst T EPS = 1e-10;\nT torad(int deg) {return (T)(deg) * M_PI / 180;}\nT todeg(T ang) {return ang * 180 / M_PI;}\n\n/* Point */\nusing P = complex<T>;\n#define x real()\n#define y imag()\ntemplate <typename T> inline bool eq(T p, T q) { return abs(p - q) < EPS; }\ninline int sgn(T x) { return (T(0) < x) - (x < T(0)); }\ninline T dot(P v, P w) { return (conj(v) * w).x; }\ninline T cross(P v, P w) { return (conj(v) * w).y; }\ninline bool isOrth(P v, P w) { return dot(v, w) == 0; }\ninline bool isPara(P v, P w) { return cross(v, w) == 0; }\ninline P unit(P v) { return v / abs(v); }\ninline P translate(P p, P v) { return p + v; }\ninline P scale(P p, P c, T k) { return c + (p - c) * k; }\ninline P rot(P p, T a) { return p * polar(1.0, a); }\ninline P rot90(P p) { return {-p.y, p.x}; }\ninline T orient(P a, P b, P c) { return cross(b - a, c - a); }\nistream& operator>>(istream& is, P& p) { T xx, yy; is >> xx >> yy; p = P(xx, yy); return is; }\nbool cmpX(const P& a, const P& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool cmpY(const P& a, const P& b) { return a.y != b.y ? a.y < b.y : a.x < b.x; }\nnamespace std {\n    bool operator < (const P& a, const P& b) { return cmpX(a, b); }\n}\n\nP linearTransform(P p, P q, P fp, P fq, P r) {\n    return fp + (r - p) * (fq - fp) / (q - p);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return +1;      // counter clockwise\n    if (cross(b, c) < 0) return -1;      // clockwise\n    if (dot(b, c) < 0) return +2;        // c--a--b on line\n    if (norm(b) < norm(c)) return -2;    // a--b--c on line or a==b\n    return 0;                            // a--c--b on line or a==c or b==c\n}\n\nT angle(P v, P w) {\n    T cosTheta = dot(v, w) / abs(v) / abs(w);\n    return acos(max(-1.0, min(1.0, cosTheta)));\n}\nT orientedAngle(P a, P b, P c) {\n    if (orient(a, b, c) >= 0) return angle(b - a, c - a);\n    return 2 * M_PI - angle(b - a, c - a);\n}\nbool inAngle(P a, P b, P c, P p) {\n    assert(abs(orient(a, b, c)) != 0);\n    if (orient(a, b, c) < 0) swap(b, c);\n    return orient(a, b, p) >= 0 && orient(a, c, p) <= 0;\n}\n\n// polar sort\nbool half(P p) {\n    assert(p.x != 0 || p.y != 0);\n    return p.y > 0 || (p.y == 0 && p.x < 0);\n}\nvoid polarSort(vector<P>& v, P o = P(0.0, 0.0)) {\n    sort(v.begin(), v.end(), [&](P v, P w) {\n        return make_tuple(half(v - o), 0, norm(v - o)) <\n            make_tuple(half(w - o), cross(v - o, w - o), norm(w - o));\n    });\n}\n\n/* Line */\nstruct L : array<P, 2> {\n    P v; T c;\n    L(P a = P(0.0, 0.0), P b = P(0.0, 0.0)) : array<P, 2>({a, b}), v(b - a), c(cross(v, a)) {}\n    T side(P p) { return cross(v, p) - c; }\n    P proj(P p) { return p - rot90(v) * side(p) / norm(v); }\n    P refl(P p) { return p - rot90(v) * T(2) * side(p) / norm(v); }\n    friend istream& operator>>(istream& is, L& l) { P a, b; is >> a >> b; l = L(a, b); return is; }\n    friend ostream& operator<<(ostream& os, const L& l) { return os << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct C : P {\n    T r;\n    C(P p = P(0.0, 0.0), T r = 0.0) : P(p), r(r) {}\n    friend ostream& operator<<(ostream& os, const C& c) { return os << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\nP circumCenter(P a, P b, P c) {\n    b -= a, c -= a;\n    assert(cross(b, c) != 0);\n    return a + rot90(b * norm(c) - c * norm(b)) / cross(b, c) / T(2);\n}\n\nvector<P> tangentPoints(C c, P p) {\n    if (eq(abs(p - c), c.r)) return vector<P>{p};\n    vector<P> res;\n    T t = acos(c.r / abs(p - c));\n    P q = (p - c) / abs(p - c) * c.r;\n    res.push_back(c + q * polar(1.0, t));\n    res.push_back(c + q * polar(1.0, -t));\n    sort(res.begin(), res.end(), cmpX);\n    return res;\n}\n\nvector<L> tangentLines(C c1, C c2, bool inner) {\n    if (inner) c2.r = -c2.r;\n    vector<L> res;\n    P d = c2 - c1;\n    T dr = c1.r - c2.r, d2 = norm(d), h2 = d2 - dr * dr;\n    if (d2 == 0 || h2 < 0) { assert(h2 != 0); return res; }\n    for (T sign : {-1, 1}) {\n        P v = (d * dr + rot90(d) * sqrt(h2) * sign) / d2;\n        res.emplace_back(c1 + v * c1.r, c2 + v * c2.r);\n    }\n    return res;\n}\n\n// intersect\nbool isInterPL(P p, L l) { return (ccw(l[0], l[1], p) != 1); }\nbool isInterPS(P p, L s) { return (ccw(s[0], s[1], p) == 0); }\nbool isInterLL(L l, L m) { return (!isPara(l.v, m.v)); }\nbool isInterLS(L l, L s) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], l);\n    return (ccw(l[0], l[1], s[0]) * ccw(l[0], l[1], s[1]) <= 0);\n}\nbool isInterSS(L s, L t) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], t);\n    if (eq(t[0], t[1])) return isInterPL(t[0], s);\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\nint isInterCC(C a, C b) {\n    T d = abs(b - a);\n    if (a == b && a.r == b.r) return 0;         // ∞ cp (A = B)\n    if (a.r + d - b.r < -EPS) return +1;        // 0 cp (A in B)\n    if (b.r + d - a.r < -EPS) return -1;        // 0 cp (B in A)\n    if (abs(a.r + d - b.r) < EPS) return +2;    // 1 cp (A in B)\n    if (abs(b.r + d - a.r) < EPS) return -2;    // 1 cp (B in A)\n    if (abs(a.r + b.r - d) < EPS) return 3;     // 1 cp (outside)\n    if (a.r + b.r - d < -EPS) return 4;         // 0 cp (outside)\n    return 5;                                   // 2 cp\n}\n \n// distance\nT distancePL(P p, L l) { return (abs(p - l.proj(p))); }\nT distancePS(P p, L s) {\n    P h = s.proj(p);\n    if (isInterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nT distanceLL(L l, L m) {\n    if (isInterLL(l, m)) return T(0);\n    return distancePL(m[0], l);\n}\nT distanceLS(L l, L s) {\n    if (isInterLS(l, s)) return 0;\n    return min(distancePL(s[0], l), distancePL(s[1], l));\n}\nT distanceSS(L s, L t) {\n    if (isInterSS(s, t)) return 0;\n    return min({distancePS(s[0], t), distancePS(s[1], t), distancePS(t[0], s), distancePS(t[1], s)});\n}\n\n// crosspoint\nvector<P> crosspointLL(L l, L m) {\n    if (!isInterLL(l, m)) return vector<P>();\n    vector<P> res;\n    T d = cross(m[1] - m[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLS(L l, L s) {\n    if (!isInterLS(l, s)) return vector<P>();\n    vector<P> res;\n    T d = cross(s[1] - s[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(s[1] - s[0], s[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLC(L l, C c) {\n    if (abs(c - l.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, l), h2 = c.r * c.r - d * d;\n    assert(h2 >= 0);\n    P p = l.proj(c), h = l.v * sqrt(h2) / abs(l.v);\n    res.push_back(p - h);\n    if (abs(h) > 0) res.push_back(p + h);\n    return res;\n}\nvector<P> crosspointSS(L s, L t) {\n    if (!isInterSS(s, t)) return vector<P>();\n    vector<P> res;\n    if (unit(s.v) != unit(t.v)) {\n        T d = cross(t[1] - t[0], s[1] - s[0]);\n        res.push_back(s[0] + (s[1] - s[0]) * cross(t[1] - t[0], t[1] - s[0]) / d);\n    } else {\n        if (ccw(s[0], s[1], t[0]) == 0) res.push_back(t[0]);\n        if (ccw(s[0], s[1], t[1]) == 0) res.push_back(t[1]);\n        if (ccw(t[0], t[1], s[0]) == 0) res.push_back(s[0]);\n        if (ccw(t[0], t[1], s[1]) == 0) res.push_back(s[1]);\n    }\n    return res;\n}\nvector<P> crosspointSC(L s, C c) {\n    if (abs(c - s.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, s), h2 = c.r * c.r - d * d;\n    assert(h2 >= 0);\n    P p = s.proj(c), h = s.v * sqrt(h2) / abs(s.v);\n    if (ccw(s[0], s[1], p - h) == 0) res.push_back(p - h);\n    if (abs(h) > 0 && ccw(s[0], s[1], p + h) == 0) res.push_back(p + h);\n    return res;\n}\nvector<P> crosspointCC(C c1, C c2) {\n    P d = c2 - c1; T d2 = norm(d);\n    if (d2 == 0) { assert(c1.r != c2.r); return vector<P>(); }\n    vector<P> res;\n    T pd = (d2 + c1.r * c1.r - c2.r * c2.r) / 2;\n    T h2 = c1.r * c1.r - pd * pd / d2;\n    if (h2 >= 0) {\n        P p = c1 + d * pd / d2, h = rot90(d) * sqrt(h2 / d2);\n        res.push_back(p - h);\n        if (abs(h) > 0) res.push_back(p + h);\n    }\n    return res;\n}\n\n/* Polygon */\n// p[0] has minimum y and p is counterclockwise\nvector<P> makeStandard(vector<P> p) {\n    int n = p.size(), j = -1;\n    for (int i = 0; i < n; ++i) {\n        if (j == -1 || p[i].y < p[j].y) j = i;\n    }\n    vector<P> res;\n    if (p[(j - 1 + n) % n].x <= p[j].x && p[j].x <= p[(j + 1) % n].x) {\n        for (int i = 0; i < n; ++i) {\n            res.push_back(p[(i + j) % n]);\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            res.push_back(p[(i - j + n) % n]);\n        }\n    }\n    return res;\n}\nbool isConvex(vector<P> p) {\n    p = makeStandard(p);\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        P a = p[i], b = p[(i + 1) % n], c = p[(i + 2) % n];\n        if (orient(a, b, c) < 0) return false;\n        if (b.y != p[0].y && b.y < min(a.y, c.y)) return false;\n        if (b.y != p[0].y && a.y == b.y && b.y == c.y && a.x <= b.x && b.x <= c.x) return false;\n    }\n    return true;\n}\nT areaTriangle(P a, P b, P c) {\n    return abs(cross(b - a, c - a)) / T(2);\n}\nT area(vector<P> p) {\n    T res = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        res += cross(p[i], p[(i + 1) % n]);\n    }\n    return abs(res) / T(2);\n}\nbool above(P a, P p) { return p.y >= a.y; }\nbool crossesRay(P a, P p, P q) {\n    return (above(a, q) - above(a, p)) * orient(a, p, q) > 0;\n}\n// if strict, returns false when A is on the boundary\nbool inPolygon(vector<P> p, P a, bool strict = true) {\n    int numCrossing = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        if (ccw(p[i], p[(i + 1) % n], a) == 0)\n            return !strict;\n        numCrossing += crossesRay(a, p[i], p[(i + 1) % n]);\n    }\n    return numCrossing & 1;\n}\nvector<P> convexHull(vector<P> p) {\n    int n = p.size(), k = 0;\n    sort(p.begin(), p.end(), cmpX);\n    vector<P> res(2 * n);\n    for (int i = 0; i < n; res[k++] = p[i++])\n        while (k >= 2 && ccw(res[k - 2], res[k - 1], p[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; res[k++] = p[i--])\n        while (k >= t && ccw(res[k - 2], res[k - 1], p[i]) <= 0) --k;\n    res.resize(k - 1);\n    return res;\n}\nvector<P> convexHullCollinearOK(vector<P> p) {\n    int n = p.size(), k = 0;\n    sort(p.begin(), p.end(), cmpX);\n    vector<P> res(2 * n);\n    for (int i = 0; i < n; res[k++] = p[i++])\n        while (k >= 2 && ccw(res[k - 2], res[k - 1], p[i]) == -1) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; res[k++] = p[i--])\n        while (k >= t && ccw(res[k - 2], res[k - 1], p[i]) == -1) --k;\n    res.resize(k - 1);\n    return res;\n}\nvector<P> convexCut(vector<P> p, L l) {\n    vector<P> res;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        int ccwc = ccw(l[0], l[1], p[i]);\n        if (ccwc != -1) res.push_back(p[i]);\n        int ccwn = ccw(l[0], l[1], p[(i + 1) % n]);\n        if (ccwc * ccwn == -1) res.push_back(crosspointLL(l, L(p[i], p[(i + 1) % n]))[0]);\n    }\n    return res;\n}\npair<int, int> convexDiameter(const vector<P>& p) {\n    int i = min_element(p.begin(), p.end()) - p.begin();\n    int j = max_element(p.begin(), p.end()) - p.begin();\n    int maxI, maxJ;\n    T maxD = 0;\n    for (int k = 0, n = p.size(); k < 2 * n; ++k) {\n        if (maxD < norm(p[i] - p[j]) - EPS) {\n            maxD = norm(p[i] - p[j]);\n            maxI = i;\n            maxJ = j;\n        }\n        if (cross(p[i] - p[(i + 1) % n], p[(j + 1) % n] - p[j]) < EPS) j = (j + 1) % n;\n        else i = (i + 1) % n;\n    }\n    return make_pair(maxI, maxJ);\n}\nT closest_pair(vector<P>& a, int l = 0, int r = -1) {\n    if (r < 0) {\n        r = a.size();\n        sort(a.begin(), a.end());\n    }\n    if (r - l <= 1) return abs(a[0] - a[1]);\n    int m = (l + r) >> 1;\n    T amx = a[m].x, d = min(closest_pair(a, l, m), closest_pair(a, m, r));\n    inplace_merge(a.begin() + l, a.begin() + m, a.begin() + r, cmpY);\n    vector<P> b;\n    for (int i = l; i < r; ++i) {\n        if (abs(a[i].x - amx) > d - EPS) continue;\n        for (int j = 0, n = b.size(); j < n; ++j) {\n            if (a[i].y - b[n - j - 1].y > d - EPS) break;\n            d = min(d, abs(a[i] - b[n - j - 1]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n\n    int n;\n    cin >> n;\n    vector<P> p(n);\n    REP (i, n) cin >> p[i];\n    int a, b;\n    tie(a, b) = convexDiameter(p);\n    cout << abs(p[a] - p[b]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\nstruct Circle;\nstruct Segment;\ntypedef Segment Line;\ndouble norm(Point a);\ndouble abs(Point a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nint ccw(Point p0, Point p1, Point p2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l); // 誤差の検証をしていない\nbool intersect(Circle c1, Circle c2);\n\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point,Point> getCrossPoints(Circle c, Line l);\npair<Point,Point> getCrossPoints(Circle c1, Circle c2); // 誤差の検証をしていない\npair<Point,Point> getContactPoints(Circle c, Point p); // 接点 点は円の外部\n\ndouble area(Polygon g); // convexでなくてもよい. absを取れば符号付き面積\nbool isConvex(Polygon g); // O(n^2) 線形時間アルゴリズムが存在するらしい\nint contains(Polygon g, Point p);\n\ndouble arg(Vector p);   // 偏角\nVector polar(double a, double r); // 極座標系->ベクトル\n\nPolygon andrewScan(Polygon g); // 凸包の辺上の点も含めたければ!=CLOCKWISEを==COUNTER_CLOCKWISEに\ndouble convexDiameter(Polygon g); // gはconvex 検証済みだが理屈はわかっていない\n\nstruct Point{\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n    Point operator * (double a){ return Point(a*x, a*y); }\n    Point operator / (double a){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x + y*y; }\n\n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\n\ndouble norm(Point a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1, p-s.p1) < 0.0)    return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2) < 0.0)    return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2))   return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), \n                getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS)   return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS)  return CLOCKWISE;\n    if(dot(a, b) < -EPS)    return ONLINE_BACK;\n    if(norm(a) < norm(b))   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l){\n    return getDistanceLP(l, c.c) < c.r+EPS;\n}\nbool intersect(Circle c1, Circle c2){\n    return abs(c1.r-c2.r) <= getDistance(c1.c, c2.c) && getDistance(c1.c, c2.c) < c1.r+c2.r+EPS;\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1-s2.p1));\n    double d2 = abs(cross(base, s1.p2-s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point,Point> getCrossPoints(Circle c, Line l){\n    assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e*base, pr - e*base);\n}\n\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n    assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos( (c1.r*c1.r + d*d - c2.r*c2.r)/(2*c1.r*d) );\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\npair<Point,Point> getContactPoints(Circle c, Point p){\n    assert(c.r < getDistance(c.c, p));\n    double d = getDistance(c.c, p);\n    return getCrossPoints(c, Circle(p, sqrt(d*d-c.r*c.r)));\n}\n\ndouble area(Polygon g){\n    int n = g.size();\n    Point o(0.0, 0.0);\n    double s = 0.0;\n    for(int i = 0; i < n; i++)  s += cross(g[i]-o, g[(i+1)%n]-o);\n    return abs(s) / 2.0;\n}\n\nbool isConvex(Polygon g){\n    bool ret = true;\n    int n = g.size();\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n; j++){\n            if(cross(g[i]-g[(i+n-1)%n], g[j]-g[(i+n-1)%n]) < -EPS || cross(g[(i+1)%n]-g[i], g[j]-g[i]) < -EPS){\n                ret = false;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i++){\n        Point a = g[i] - p, b = g[(i+1)%n] - p;\n        if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)   return ON;\n        if(a.y > b.y)   swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return x ? IN : OUT;\n}\n\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nVector polar(double a, double r){\n    return Point(a * cos(r), a * sin(r));\n}\n\n\nPolygon andrewScan(Polygon g){\n    Polygon u, l;\n    if(g.size() < 3)    return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size()-1]);\n    l.push_back(g[g.size()-2]);\n\n    // upper\n    for(int i = 2; i < g.size(); i++){\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], g[i]) != CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for(int i = g.size()-3; i >= 0; i--){\n        for(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], g[i]) != CLOCKWISE; n--){\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = u.size()-2; i >= 1; i--)    l.push_back(u[i]);\n\n    return l;\n}\n\ndouble convexDiameter(Polygon g){\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n        if(g[i].y > g[is].y)    is = i;\n        if(g[i].y < g[js].y)    js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do{\n        if(cross(g[(i+1)%n]-g[i], g[(j+1)%n]-g[j]) >= 0.0)  j = (j+1)%n;\n        else    i = (i+1)%n;\n        if(getDistance(g[i], g[j]) > d){\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    }while(i != is || j != js);\n\n    return d; // farthest pair is (maxi, maxj).\n}\n\n\n\nint main(){\n    int n;\n    cin >> n;\n    Polygon g;\n    for(int i = 0; i < n; i++){\n        double x, y;\n        cin >> x >> y;\n        g.push_back(Point(x,y));\n    }\n    cout << fixed << setprecision(12) << convexDiameter(g) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n#define dTolerance 1.0e-10\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    double x[n+1],y[n+1];\n    for (int i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &x[i], &y[i]);\n    }\n    x[n] = x[0];\n    y[n] = y[0];\n\n    int ixMin = 0;\n    int ixMax = 0;\n    for (int i = 0; i < n; i++){\n        if(x[i] < x[ixMin]){    \n            ixMin = i;\n        }\n        if(fabs(x[i] - x[ixMin]) < dTolerance && y[i] > y[ixMin]){    //x座標最小のもののなかでy座標最大のものにしておく\n            ixMin = i;\n        }\n        if(x[i] > x[ixMax]){  \n            ixMax = i;\n        }\n        if(fabs(x[i] - x[ixMax]) < dTolerance && y[i] < y[ixMax]){    //x座標最大のもののなかでy座標最小のものにしておく\n            ixMin = i;\n        }\n    }\n    \n    double dDiameter = sqrt( (x[ixMax] - x[ixMin]) * (x[ixMax] - x[ixMin]) + (y[ixMax] - y[ixMin]) * (y[ixMax] - y[ixMin]) );\n\n    int i = ixMin;\n    int j = ixMax;\n    \n    while(j != ixMin || i != ixMax){\n        if( (x[j+1] - x[j]) * (y[i+1] - y[i]) - (x[i+1] - x[i]) * (y[j+1] - y[j]) >= 0 ) {;    //j番目の辺(向き付)から見てi番目の辺(向き付)のなす角が反時計回り\n            i++;\n        } else {    //時計回り\n            j++;\n        }\n        i %= n;    //nを越えないようにしておく\n        j %= n;\n        if (dDiameter < sqrt( (x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) )){\n            dDiameter = sqrt( (x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]) );\n        }\n    }\n\n    printf(\"%lf\", dDiameter);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tR res=0.0;\n\tint si=i,sj=j;\n\twhile( (i!=sj)||(j!=si)){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\n//定義系\n\ndouble EPS = 1e-10;\n\n//誤差を考慮して足し算を行う\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS*(abs(a) + abs(b)))return 0;\n\treturn a + b;\n}\n\n//Point\nstruct Point {\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {\n\t}\n\tPoint operator + (Point p) {\n\t\treturn Point(add(x, p.x), add(y, p.y));\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(add(x, -p.x), add(y, -p.y));\n\t}\n\tPoint operator * (double d) {\n\t\treturn Point(x*d, y*d);\n\t}\n\tPoint operator / (double d) {\n\t\treturn Point(x / d, y / d);\n\t}\n\t//内積\n\tdouble dot(Point p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\t//外積\n\tdouble det(Point p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\t//点の大小比較\n\tbool operator <(const Point &p)const {\n\t\tif (fabs(add(x, -p.x))<EPS)return y<p.y;\n\t\treturn x<p.x;\n\t}\n\tbool operator ==(const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS&&fabs(y - p.y) < EPS;\n\t}\n};\n\n//ベクトル。使い分けるといいかも\ntypedef Point Vector;\n\n//ベクトルの大きさの2乗\ndouble norm(Vector p) {\n\treturn p.x*p.x + p.y*p.y;\n}\n\n//ベクトルの大きさ\ndouble abs(Vector p) {\n\treturn sqrt(norm(p));\n}\n\n//線分\nstruct Segment {\n\tPoint p1, p2;\n};\n\n//直線\ntypedef Segment Line;\n\n//中心c,半径rの円\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\n//多角形\ntypedef vector<Point> Polygon;\n\n//頂点集合\ntypedef vector<Point> Points;\n\n\n\n\n//計算・アルゴリズム系\n\n\n//反時計回りCCW\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (a.det(b) > EPS)return COUNTER_CLOCKWISE;\n\tif (a.det(b) < -EPS)return CLOCKWISE;\n\tif (a.dot(b) < -EPS)return ONLINE_BACK;\n\tif (norm(a)<norm(b))return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//ベクトルa,bの直交判定\nbool isOrthogonal(Vector a, Vector b) {\n\treturn a.dot(b) == 0.0;\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn (s1.p2 - s1.p1).dot(s2.p2 - s2.p1) == 0.0;\n}\n\n//ベクトルa,bの並行判定\nbool isParallel(Vector a, Vector b) {\n\treturn a.det(b) == 0.0;\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn (s1.p2 - s1.p1).det(s2.p2 - s2.p1) == 0.0;\n}\n\n//射影(点p1と点p2を通る直線に点pから垂線を引いた交点xを求める)\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = (p - s.p1).dot(base) / norm(base);\n\treturn s.p1 + base*r;\n}\n\n//反射(点p1と点p2を通る直線を対象軸として点pと線対称の位置にある点xを求める)\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\n\n//点aと点bの距離\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\n//直線lと点pの距離\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs((l.p2 - l.p1).det(p - l.p1) / abs(l.p2 - l.p1));\n}\n\n//線分sと点pの距離\ndouble getDistanceSP(Segment s, Point p) {\n\tif ((s.p2 - s.p1).dot(p - s.p1) < 0.0)return abs(p - s.p1);\n\tif ((s.p1 - s.p2).dot(p - s.p2) < 0.0)return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\n//線分s1と線分s2の距離\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(base.det(s1.p1 - s2.p1));\n\tdouble d2 = abs(base.det(s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\n//円cと線分lの交点\npair<Point, Point>getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r)*a, sin(r)*a); }\npair<Point, Point>getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//点の内包 0:in,1:on,2:out\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(a.det(b)) < EPS&&a.dot(b) < EPS) return 1;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS < b.y&&EPS < a.det(b))x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\n//凸包を求める\nPolygon convex_hull(Polygon s, bool on_seg) {\n\tPolygon u, l;\n\tif (s.size() < 3) {\n\t\treturn s;\n\t}\n\tsort(s.begin(), s.end());//x,yを基準に昇順ソート\n\n\t\t\t\t\t\t\t //xが小さいものから2つuに追加\n\tu.emplace_back(s[0]);\n\tu.emplace_back(s[1]);\n\t//xが大きいものから2つlに追加\n\tl.emplace_back(s[s.size() - 1]);\n\tl.emplace_back(s[s.size() - 2]);\n\n\tif (on_seg) {\n\n\t\t//凸包の上部を生成\n\t\tfor (int i = 2; i < s.size(); i++) {\n\t\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n\t\t\t\tu.pop_back();\n\t\t\t}\n\t\t\tu.emplace_back(s[i]);\n\t\t}\n\n\t\t//凸包の下部を生成\n\t\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n\t\t\t\tl.pop_back();\n\t\t\t}\n\t\t\tl.emplace_back(s[i]);\n\t\t}\n\t}\n\telse {\n\t\t//凸包の上部を生成\n\t\tfor (int i = 2; i < s.size(); i++) {\n\t\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--) {\n\t\t\t\tu.pop_back();\n\t\t\t}\n\t\t\tu.emplace_back(s[i]);\n\t\t}\n\n\t\t//凸包の下部を生成\n\t\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--) {\n\t\t\t\tl.pop_back();\n\t\t\t}\n\t\t\tl.emplace_back(s[i]);\n\t\t}\n\t}\n\t//時計回りになるように凸包の点の列を生成\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) {\n\t\tl.push_back(u[i]);\n\t}\n\treturn l;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tPolygon g;\n\tREP(i, n) {\n\t\tPoint p;\n\t\tcin >> p.x >> p.y;\n\t\tg.emplace_back(p);\n\t}\n\tPolygon cg = convex_hull(g, false);\n\tdouble ans = 0.0;\n\tREP(i, cg.size()) {\n\t\tREP(j, cg.size()) {\n\t\t\tif (i == j)continue;\n\t\t\tans = max(ans, getDistance(cg[i], cg[j]));\n\t\t}\n\t}\n\tcout << fixed << setprecision(13) <<ans<< endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 1e-10101;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tif (N >= 20000) { res = 1e-5; goto E; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = max(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\ndouble convex_diameter(const Polygon &g) {\n    size_t V=g.size();\n    size_t is=0, js=0;\n    for (size_t i=1; i<V; ++i) {\n        if (imag(g[i]) > imag(g[is])) is = i;\n        if (imag(g[i]) < imag(g[js])) js = i;\n    }\n\n    double res=abs(g[is]-g[js]);\n    size_t i, j, max_i, max_j;\n    i = max_i = is;\n    j = max_j = js;\n    do {\n        (++(cross_prod(g[(i+1)%V]-g[i], g[(j+1)%V]-g[j])>=0? j:i)) %= V;\n\n        if (res < abs(g[i]-g[j])) {\n            res = abs(g[i]-g[j]);\n            max_i = i;\n            max_j = j;\n        }\n    } while (!((i == is) && (j == js)));\n\n    // <max_i, max_j>\n    return res;\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    Polygon g(n);\n    for (size_t i=0; i<n; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        g[i] = Point(x, y);\n    }\n\n    printf(\"%.9f\\n\", convex_diameter(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\ntypedef long double D;\nconst D PI = acos(-1.0);\nconst D EPS = 1e-10;\nclass P { public:\n  D x, y;\n  P(D x=0, D y=0) : x(x), y(y) {}\n\n  P& operator+=(const P& o) { x += o.x; y += o.y; return *this; }\n  P& operator-=(const P& o) { x -= o.x; y -= o.y; return *this; }\n  P& operator*=(const P& o) { return *this = {x*o.x - y*o.y, x*o.y + y*o.x}; }\n  P& operator*=(const D& r) { x *= r; y *= r; return *this; }\n  P& operator/=(const D& r) { x /= r; y /= r; return *this; }\n  P operator-() const { return {-x, -y}; }\n\n  D norm() const { return x*x + y*y; }\n  D abs() const { return sqrt(norm()); }\n  D arg() const { return atan2(y, x); }\n  bool isZero() const { return std::abs(x) < EPS && std::abs(y) < EPS; }\n  /** 象限 */\n  int orth() const { return y >= 0 ? (x >= 0 ? 1 : 2) : (x < 0 ? 3 : 4); }\n  static P polar(const D& rho, const D& theta = 0) { return {rho * cos(theta), rho * sin(theta)}; }\n};\nstd::ostream &operator<<(std::ostream &os, P const &p) { return os << \"(\" << p.x << \", \" << p.y << \")\"; }\nstd::istream &operator>>(std::istream &is, P &p) { D a, b; is >> a >> b; p = P(a, b); return is; }\nP operator+(const P& p, const P& q) { return P(p) += q; }\nP operator-(const P& p, const P& q) { return P(p) -= q; }\nP operator*(const P& p, const P& q) { return P(p) *= q; }\nP operator*(const P& p, const D& r) { return P(p) *= r; }\nP operator/(const P& p, const D& r) { return P(p) /= r; }\nP operator*(const D& r, const P& p) { return P(p) *= r; }\nP operator/(const D& r, const P& p) { return P(p) /= r; }\nD crs(const P& a, const P& b){ return a.x*b.y - a.y*b.x; }\nD dot(const P& a, const P& b){ return a.x*b.x + a.y*b.y; }\nint signum(D x) {return x > EPS ? +1 : x < -EPS ? -1 : 0;}\n\n\n// 凸包の直径\nD convexDiamiter(const vector<P>& ps){\n  int N = (int)ps.size();\n  int i = 0, j = 0;\n  for (int k = 1; k < N; k++) {\n    if (ps[k].y > ps[i].y) i = k;\n    if (ps[k].y < ps[j].y) j = k;\n  }\n  int si = i, sj = j;\n  D max_dist = (ps[i] - ps[j]).norm();\n  do {\n    if (crs(ps[(i+1)%N] - ps[i], ps[(j+1)%N] - ps[j]) >= 0) j = (j+1) % N;\n    else i = (i+1) % N;\n    if ((ps[i] - ps[j]).norm() > max_dist) {\n      max_dist = (ps[i] - ps[j]).norm();\n    }\n  } while( si != i || sj != j );\n  return sqrt(max_dist);\n}\n\n\nint main2() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  REP(i, N) cin >> ps[i];\n  double ans = (double)convexDiamiter(ps);\n  printf(\"%.10f\\n\", ans);\n  return 0;\n}\n\nint main() {\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\ndouble caliper(Poly p){\n  int n = p.size();\n  if(n <= 1) return 0;\n  if(n == 2) return abs(p[0]-p[1]);\n\n  int i = 0, j = 0;\n  for(int k = 0; k < n; ++k){\n    if(!(p[i] < p[k])) i = k;\n    if(p[j] < p[k]) j = k;\n  }\n  \n  double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si){\n    res = max(res, abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j]) < 0) i = (i+1)%n;\n    else j = (j+1)%n;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  Poly p;\n  double x, y;\n  for(int i = 0; i < n; ++i){\n    cin >> x >> y;\n    p.push_back(P(x,y));\n  }\n  printf(\"%.10lf\\n\", caliper(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x*b.y - a.y*b.x;\n}\n\nVector normal(Point p0, Point p1); //ベクトルp0p1の法線ベクトル\nint argmax(const vector<double> &v); //std::vectorのargmax関数\n\nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int n;\n    cin >> n;\n    vector<Point> data(n);\n\n    for(int i=0; i<n; i++){\n        cin >> data[i].x >> data[i].y;\n    }\n\n    Point p0, p1;\n    Vector nv;\n    vector<double> xNormalNoDup(0);\n    vector<Vector> normalVector(0);\n    xNormalNoDup.reserve(n);\n    normalVector.reserve(n);\n    map<double, int> isSwitchVertex;\n\n    for(int i=0; i<n; i++){\n        p0 = data[i];\n        p1 = data[(i+1)%n];\n        nv = normal(p0, p1);\n        normalVector.push_back(nv);\n        if (nv.y > 0 || nv.x == 1) isSwitchVertex[ nv.x ] += 1;\n        else isSwitchVertex[ -nv.x ] -= 1;\n    }\n\n    //Extract keys of isSwitchVertex and sort\n    for(map<double,int>::iterator it = isSwitchVertex.begin(); it != isSwitchVertex.end(); ++it) {\n        xNormalNoDup.push_back(it->first);\n    }\n    sort(xNormalNoDup.begin(), xNormalNoDup.end());\n\n    //find the first pair\n    int pairIndex0 = -1; //upside\n    int pairIndex1 = -1; //downside\n    Vector nv0, nv1;\n    for(int i=0; i<n; i++){\n        nv0 = normalVector[i];\n        nv1 = normalVector[(i+1)%n];\n        if( nv0.y<0 && nv1.y>=0 ) pairIndex0 = (i+1)%n;\n        if( nv0.y>=0 && nv1.y<0 ) pairIndex1 = (i+1)%n;\n    }\n    if(pairIndex0<0 || pairIndex1<0) cout << \"ERROR: Pair Initialization failed.\";\n\n    double maxDiameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n    double diameter = 0;\n\n    for(int i=0; i<xNormalNoDup.size(); i++){\n        switch( isSwitchVertex[ xNormalNoDup[i] ] ) {\n            case 1:  pairIndex0 += 1;\n                     break;\n            case -1: pairIndex1 += 1;\n                     break;\n            case 0:  pairIndex0 += 1;\n                     pairIndex1 += 1;\n                     break;\n            default: cout << \"Error: Next pair not found.\" << endl;\n                     break;\n        }\n        diameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n        maxDiameter = (diameter > maxDiameter)? diameter: maxDiameter;\n    }\n\n    cout << setprecision(14) << maxDiameter << endl;\n\n    return 0;\n}\n\nVector normal(Point p0, Point p1){\n    Vector nv;\n    nv.x = - ( p1.y - p0.y );\n    nv.y = p1.x - p0.x;\n    double a = nv.abs();\n    return nv / a;\n}\n\nint argmax(const vector<double> &v){\n    return distance(v.begin(), max_element(v.begin(), v.end()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tR res=0.0;\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tif(i==sj&&j==si) break;\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define scanf nope\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntemplate <class T>\nstruct Point {\n\ttypedef Point P;\n\tT x, y;\n\texplicit Point(T x=0, T y=0) : x(x), y(y) {}\n\tbool operator<(P p) const { return x<p.x||(x==p.x && y<p.y);}\n\tbool operator==(P p) const { return x==p.x && y==p.y; }\n\tP operator+(P p) const { return P(x+p.x, y+p.y); }\n\tP operator-(P p) const { return P(x-p.x, y-p.y); }\n\tP operator*(T d) const { return P(x*d, y*d); }\n\tP operator/(T d) const { return P(x/d, y/d); }\n\tT dot(P p) const { return x*p.x + y*p.y; }\n\tT cross(P p) const { return x*p.y - y*p.x; }\n\tT cross(P p1, P p2) const { return (p1 - *this).cross(p2 - *this); }\n\tT dist2() const { return x*x + y*y; }\n\tdouble dist() const { return sqrt((double)dist2()); }\n\t// angle to x-axis in interval [-pi, pi]\n\tdouble angle() const { return atan2(y, x); }\n\tP unit() const { return *this/dist(); } // makes dist()=1\n\tP perp() const { return P(-y, x); } // rotates +90 degrees\n\tP normal() const { return perp().unit(); }\n\t// returns point rotated 'a' radians ccw around the origin\n\tP rotate(double a) const {\n\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n};\n\ntypedef Point<double> P;\npair<vi, vi> ulHull(const vector<P>& S) {\n    vector<int> Q(sz(S));\n    iota(all(Q), 0);\n    sort(all(Q), [&S](int a, int b){ return S[a] < S[b]; });\n    vi U, L;\n    trav(it, Q) {\n        while (sz(U) > 1 && S[U[sz(U)-2]].cross(S[it], S[U.back()]) <= 0) U.pop_back();\n        while (sz(L) > 1 && S[L[sz(L)-2]].cross(S[it], S[L.back()]) >= 0) L.pop_back();\n        U.push_back(it);\n        L.push_back(it);\n    }\n    return make_pair(U, L);\n}\n\nvi convexHull(const vector<P>& S) {\n    vi u, l;\n    tie(u, l) = ulHull(S);\n    if (sz(S) <= 1) return u;\n    u.pop_back();\n    reverse(all(u));\n    u.pop_back();\n    u.insert(u.end(), all(l));\n    if (sz(u) == 2 && S[u[0]] == S[u[1]]) u.pop_back();\n    return u;\n}\n\nvector<pii> antipodal(const vector<P>& S, const vi& U, const vi& L) {\n    vector<pii> A;\n    int i = 0;\n    int j = sz(L) - 1;\n    while (i < sz(U) - 1 || j > 0) {\n        A.emplace_back(U[i], L[j]);\n        if (i < sz(U) - 1 && (j == 0 || (S[L[j]] - S[L[j-1]]).cross((S[U[i+1]] - S[U[i]])))) ++i;\n        else --j;\n    }\n    return A;\n}\n\npii polygonDiameter(const vector<P>& S) {\n    vi U, L;\n    tie(U, L) = ulHull(S);\n    pair<double, pii> ans;\n    trav(it, antipodal(S, U, L)) {\n        ans = max(ans, make_pair((S[it.first] - S[it.second]).dist2(), it));\n    }\n    return ans.second;\n}\n\nint main() {\n    int N;\n    cin >> N;\n        vector<P> P(N);\n        rep(i,0,N) cin >> P[i].x >> P[i].y;\n        pii ret = polygonDiameter(P);\n        cout << setprecision(10) << fixed << (P[ret.first] - P[ret.second]).dist() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n//-------------------------------------------------------------------------------------\n/*線分にたいして点(px,py)が垂線をおろすことができればtrue*/\n\nbool perpendicular_to_the_line_segment_from_the_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    \n    if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n        //cout<<\"a \";\n        return true;\n    }else{//(v_x,v_y)は線分の外にある\n        return false;\n    }\n    \n    \n}\n\n\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*凸包の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][0]<ch[k][0]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res = 0;\n    while(1){\n        if(i==sj||j==si)break;\n\n        res = distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n        if(perpendicular_to_the_line_segment_from_the_point(ch[sj][0], ch[sj][1], ch[si][0], ch[si][1], ch[(si+1)%n][0], ch[(si+1)%n][1])){\n            si=(si+1)%n;\n        }else{\n            sj=(sj+1)%n;\n        }\n    }\n    \n    return res;\n}\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        /*\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n         */\n        \n        double max_l = diameter_of_the_polygon(n, p_xy);\n        \n        \n\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tR res=0.0;\n\tif(n<=2){\n\t\trep(j,n)rep(i,j) res=max(res,abs(pol[i]-pol[j]));\n\t\treturn res;\n\t}\n\t\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    rep(k,2*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() {ld x, y; cin >> x >> y; return Point(x, y);} // ????????\\???\nbool eq(ld a, ld b) {return (abs(a - b) < eps);} // ????????????????????????\nld dot(Point a, Point b) {return real(conj(a) * b);} // ??????\nld cross(Point a, Point b) {return imag(conj(a) * b);} // ??????\n\n// ??´????????????\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// ????????????\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n    if (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n    if (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n    if (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n    return 0;                          // a,c,b???????????´???????????¶\n}\n\n/* ????§???¢ */\ntypedef vector<Point> Polygon;\n// ???????§???¢?????´???\nld convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    ld res = abs(poly[ii] - poly[jj]);\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    do{\n        if(cross(poly[(i+1)%n] - poly[i],poly[(j+1)%n] - poly[j]) >= 0) j = (j+1)%n;\n        else i = (i+1)%n;\n        if(abs(poly[i] - poly[j]) > res){\n            res = abs(poly[i] - poly[j]);\n            maxi = i; maxj = j;\n        }\n    }while(i != ii || j != jj);\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n; cin >> n;\n    Polygon ps;\n    for(int i = 0; i < n;i++) ps.emplace_back(input_point());\n    cout << fixed << setprecision(10) << convex_diameter(ps) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n/*#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n#include<complex>*/\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef pair<double, int> pdi;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std\n{\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\ndouble dist2P(const P& a, const P& b)\n{\n\treturn dot(a - b, a - b);\n}\n\ndouble distP(const P& a, const P& b)\n{\n\treturn sqrt(dist2P(a, b));\n}\n\ndouble len2P(const P& a)\n{\n\treturn dot(a, a);\n}\n\ndouble lenP(const P& a)\n{\n\treturn sqrt(len2P(a));\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nstruct C {\n\tP p; double r;\n\tint di;\n\tC(const P &p, double r,int di) : p(p), r(r),di(di) { }\n\tC():p(P(-1,-1)),r(-1),di(-1){}\n\tbool operator<(const C& c)const\n\t{\n\t\treturn r < c.r;\n\t}\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + 2.0*(projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\t//if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble CalcDiameter(vector<P>& points)\n{\n\tint n = points.size();\n\tint is = 0, js = 0;\n\tfor (int i = 1; i != n; i++)\n\t{\n\t\tif (imag(points[i]) > imag(points[is]))\n\t\t{\n\t\t\tis = i;\n\t\t}\n\t\tif (imag(points[i]) < imag(points[js]))\n\t\t{\n\t\t\tjs = i;\n\t\t}\n\t}\n\tdouble maxd = dist2P(points[is], points[js]);\n\n\tint i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo\n\t{\n\t\tif (cross(points[(i + 1) % n] - points[i], points[(j + 1) % n] - points[j]) >= 0)\n\t\t{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti = (i + 1) % n;\n\t\t}\n\t\tif (maxd < dist2P(points[i],points[j]))\n\t\t{\n\t\t\tmaxd = dist2P(points[i],points[j]);\n\t\t\tmaxi = i;\n\t\t\tmaxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\treturn sqrt(maxd);\n}\n\nvector<P> points;\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tprintf(\"%.7lf\\n\", CalcDiameter(points));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\n// Description: ????????????\n// Verifyed: various problem\nusing namespace placeholders;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P = complex<R>;\nusing L = struct {P s, t;};\nusing VP = vector<P>;\nusing C = struct {P c; R r;};\n\n#define at(a,i) (a[(i + a.size()) % a.size()])\n\nauto& operator >> (istream& is, P& p) { R x, y; is >> x >> y, p = P(x, y); return is;}\nauto& operator << (ostream& os, P& p) { os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std {\nbool operator <  (const P& a, const P& b) { return sgn(real(a - b)) ? real(a - b) < 0 : sgn(imag(a - b)) < 0;}\nbool operator == (const P& a, const P& b) { return sgn(real(a - b)) == 0 && sgn(imag(a - b)) == 0;}\n}\n\ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline P vec(L l) {return l.t - l.s;}\nauto sdot = bind(sgn, bind(dot, _1, _2, _3));\nauto sdet = bind(sgn, bind(det, _1, _2, _3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l, P p) { R u = real((p - l.s) / vec(l)); return (1 - u) * l.s + u * l.t;}\n//reflection verify AOJ CGL_1_B\nP refl(L l, P p) {return 2.0L * proj(l, p) - p;}\n\n// CCW verify AOJ CGL_1_C\nenum CCW { LEFT = 1, RIGHT = 2, BACK = 4, FRONT = 8, ON = 16};\ninline int ccw(P o, P a, P b) {\n\tif (sdet(o, a, b) > 0) return LEFT; // counter clockwise\n\tif (sdet(o, a, b) < 0) return RIGHT; // clockwise\n\tif (sdot(o, a, b) < 0) return BACK; // b--base--a on line\n\tif (sgn(norm(a - o) - norm(b - o)) < 0) return FRONT; // base--a--b on line\n\treturn ON; // base--b--a on line  semnet determination betwenn a and b\n}\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a, L b) {return sdot(0, vec(a), vec(b)) == 0;}\nbool parallel(L a, L b) {return sdet(0, vec(a), vec(b)) == 0;}\nbool eql(L a, L b) { return parallel(a, b) and sdet(a.s, a.t, b.s) == 0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B\nbool iss(L a, L b) {\n\tint sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n\tint sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n\treturn max(sa, sb) < 0;\n}\n\n// crossing point\n// verified: AOJ CGL_2_C\nP cross(L a, L b) {\n\tR u = det(a.s, b.s, b.t) / det(0, vec(a), vec(b));\n\treturn (1 - u) * a.s + u * a.t;\n}\n\n// distance\n// verified: AOJ CGL_2_D\nR dsp(L l, P p) {\n\tP h = proj(l, p);\n\tif (sdot(l.s, l.t, p) <= 0) h = l.s;\n\tif (sdot(l.t, l.s, p) <= 0) h = l.t;\n\treturn abs(p - h);\n}\n\nR dss(L a, L b) {\n\tif(iss(a,b)) return 0;\n\treturn min({dsp(a, b.s), dsp(a, b.t), dsp(b, a.s), dsp(b, a.t)});\n}\n// Polygon\n\n// area\n// verified: AOJ 1100 CGL_3_A\nR area(const VP& pol) {\n\tR sum = 0.0;\n\trep(i, pol.size()) sum += det(0, at(pol, i), at(pol, i + 1));\n\treturn abs(sum / 2.0L);\n}\n\n// convex_polygon determination\n// verified: CGL_3_B\nbool is_convex(const VP& pol) {\n\trep(i, pol.size()){\n\t\tif(sdet(at(pol, i), at(pol, i + 1), at(pol, i + 2)) < 0){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// polygon realation determination  in  2 on 1 out 0???(possible non-convex)\n// verified: AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p) {\n\tint res = 0;\n\tauto simag = [](const P & p) {return sgn(imag(p));};\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tif (sdet(p, a, b) == 0 and sdot(p, a, b) <= 0) return 1;\n\t\tbool f = simag(p - a) >= 0, s = simag(p - b) < 0;\n\t\tif (simag(b - a)*sdet(a, b, p) == 1 and f == s) res += (2 * f - 1);\n\t}\n\treturn res ? 2 : 0;\n}\n\n// polygon realation determination???(possible non-convex)\n// verified: not AOJ 2514\nbool in_polygon(const VP& pol, const L& l) {\n\tVP check = {l.s, l.t};\n\trep(i, pol.size()) {\n\t\tL edge = {at(pol, i), at(pol, i + 1)};\n\t\tif (iss(l, edge)) check.emplace_back(cross(l, edge));\n\t}\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tsort(begin(check), end(check), cmp_x);\n\trep(i, check.size() - 1) {\n\t\tP m = (at(check, i) + at(check, i + 1)) / 2.0L;\n\t\tif (in_polygon(pol, m) == false) return false;\n\t}\n\treturn true;\n}\n\n// convex_cut\n// verified: AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n\tVP res;\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tint da = sdet(l.s, l.t, a), db = sdet(l.s, l.t, b);\n\t\tif (da >= 0) res.emplace_back(a);\n\t\tif (da * db < 0) res.emplace_back(cross({a, b}, l));\n\t}\n\treturn res;\n}\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol) {\n\tint n = pol.size(), i = 0, j = 0;\n\tif (n <= 2) return abs(pol[0] - pol[1]);\n\tR res = 0.0;\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\trep(k, n) {\n\t\tif (!cmp_x(pol[i], pol[k]))i = k;\n\t\tif (cmp_x(pol[j], pol[k]))j = k;\n\t}\n\n\tint si = i, sj = j;\n\twhile (i != sj || j != si) {\n\t\tres = max(res, abs(pol[i] - pol[j]));\n\t\tP li = vec(L{at(pol, i), at(pol, i + 1)});\n\t\tP lj = vec(L{at(pol, j), at(pol, j + 1)});\n\t\tif(sdet(0, li, lj) < 0)\n\t\t\ti = (i + 1) % n;\n\t\telse\n\t\t\tj = (j + 1) % n;\n\t}\n\treturn res;\n}\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a, int flag = 1) {\n\tconst int n = a.size(), m = n / 2;\n\tif (n <= 1) return INF;\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tif (flag) sort(begin(a), end(a), cmp_x);\n\n\tVP b(begin(a), begin(a) + m), c(begin(a) + m, end(a));\n\tR x = real(a[m]), d = min(cpp(b, 0), cpp(c, 0));\n\n\n\tauto cmp_y = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn si ? si < 0 : sr < 0;\n\t};\n\n\tsort(begin(a), end(a), cmp_y);\n\tdeque<P> e;\n\n\tfor (auto &p : a) {\n\t\tif (abs(real(p) - x) >= d) continue;\n\n\t\tfor (auto &q : e) {\n\t\t\tif (imag(p - q) >= d) break;\n\t\t\td = min(d, abs(p - q));\n\t\t}\n\t\te.push_front(p);\n\t}\n\treturn d;\n}\n// Circle // verified: AOJ 1183\nenum RCC {OUT = 2, ON_OUT = 1, ISC = 0, ON_IN = -1, IN = -2};\nint rcc(C a, C b) { \n\tR d = abs(a.c - b.c); \n\treturn sgn(d - a.r - b.r) + sgn(d - abs(a.r - b.r));\n}\n\n// circle crossing determination\nbool icp(C c, P p, int end = 0) {return sgn(abs(p - c.c) - c.r) <= -end;}\nbool ics(C c, L s, int end = 0) {\n\tif (sgn(dsp(s, c.c) - c.r) > end) return false;\n\tif (icp(c, s.s, end) and icp(c, s.t, end)) return false;\n\treturn true;\n}\n// common area between circles\nR area(C a, C b) {\n\tint r = rcc(a, b);\n\tif (r >= ON_OUT) return 0.0L;\n\tif (r <= ON_IN) return min(norm(a.r), norm(b.r)) * PI;\n\tR d = abs(b.c - a.c), rc = (norm(d) + norm(a.r) - norm(b.r)) / (2.0 * d);\n\tR t = acos(rc / a.r), p = acos((d - rc) / b.r);\n\treturn norm(a.r) * t + norm(b.r) * p - d * a.r * sin(t);\n}\n\n// cross point between circle and line\n// verified: AOJ CGL_7_D\nP cir(C c, R t) {return c.c + polar(c.r, t);}\nVP cross(C c, L l) {\n\tP h = proj(l, c.c);\n\tP e = polar(sq(norm(c.r) - norm(h - c.c)), arg(vec(l)));\n\treturn VP{h - e, h + e};\n}\n\n// cross point between circles\n// verified: AOJ CGL_7_E\nVP cross(C a, C b) {\n\tP d = b.c - a.c;\n\tP w = (norm(d) + norm(a.r) - norm(b.r)) / (2.0L * norm(d)) * d;\n\treturn cross(a, {a.c + w, a.c + w + 1il * d});\n}\n\n// circle tangent\n// verified: AOJ CGL_7_F\nL tan(C c, P p) {return L{p, p + 1il * (p - c.c)};}\n\nP helper(C c, P d, R r, P j) {\n\tP tmp = sq(norm(d) - norm(r)) * j;\n\tP dir = (r + tmp) / norm(d) * d;\n\treturn c.c + c.r * dir;\n}\n\nVP contact(C c, P p) {\n\tVP ret;\n\tP d = p - c.c;\n\tfor (P j : { -1il, 1il}) ret.emplace_back(helper(c, d, c.r, j));\n\tsort(begin(ret), end(ret));\n\tret.erase(unique(begin(ret), end(ret)), end(ret));\n\treturn ret;\n}\n\n// circle tangent\n// Verified: AOJ CGL_7_G\nVP contact(C a, C b) {\n\tVP ret;\n\tP d = b.c - a.c;\n\tfor (int s : { -1, 1}) {\n\t\tif (rcc(a, b) >= s) {\n\t\t\tfor (P j : { -1i, 1i}) {\n\t\t\t\tR r = a.r + s * b.r;\n\t\t\t\tret.emplace_back(helper(a, d, r, j));\n\t\t\t}\n\t\t}\n\t}\n\tsort(begin(ret), end(ret));\n\tret.erase(unique(begin(ret), end(ret)), end(ret));\n\treturn ret;\n}\n\n// common area of circle and polygon\n// verified: AOJ CGL_7_H\nR area_helper(C c, P a, P b) {\n\tif (icp(c, a) and icp(c, b)) return det(0, a, b) / 2.0l;\n\treturn norm(c.r) * arg(conj(a) * b) / 2.0l;\n}\n\nR area(C c, P a, P b) {\n\tL l = {a, b};\n\n\tif (sgn(min({c.r, abs(a), abs(b), abs(b - a)})) == 0) return 0.0;\n\tif (ics(c, l) == false) return area_helper(c, a, b);\n\n\tR res = 0.0; VP ary;\n\tary.push_back(a);\n\tfor (auto &p : cross(c, l)) if (sdot(p, a, b) < 0) ary.push_back(p);\n\tary.push_back(b);\n\n\trep(i, ary.size() - 1) res += area_helper(c, at(ary, i), at(ary, i + 1));\n\treturn res;\n}\n\nR area(C c, VP pol) {\n\tR res = 0;\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i) - c.c , b = at(pol, i + 1) - c.c;\n\t\tres += area(C{0.0L, c.r}, a, b);\n\t}\n\treturn res;\n}\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int i = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int j = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int maxi, maxj;\n    LD maxd = 0;\n    for(; i < 2*n; i++){\n        if(maxd < norm(cpol[i]-cpol[j])){\n            maxd = norm(cpol[i] - cpol[j]);\n            maxi = i;\n            maxj = j;\n        }\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) <= 0) j = (j+1) % n;\n        else i = (i+1) % n; \n    }\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n    pair<int, int> ans = ConvexPolygonDiameter(p);\n    printf(\"%.9Lf\\n\", DistPP(p[ans.first], p[ans.second]));\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vec;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\ndouble eps=1e-8;\ndouble PI=acos(-1);\n\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\n\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\nP project(P a,P b,P c){b-=a;c-=a;return a+b*real(c/b);}\nP reflect(P a,P b,P c){b-=a;c-=a;return a+conj(c/b)*b;}\nint ccw(P a,P b,P c){\n  b-=a,c-=a,a=c*conj(b);\n  if(a.imag()>eps)return 1;//ccw\n  if(a.imag()<-eps)return -1;//cw\n  if(a.real()<-eps)return 2;//ob\n  if(abs(b)+eps<abs(c))return -2;//of\n  return 0;//os\n}\n\n//segment ab , point c\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nbool isintersect(P a,P b,P c,P d){\n  return ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n}\n\n//segment ab , segment cd\nP intersect(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble dist(P a,P b,P c,P d){\n  if(isintersect(a,b,c,d))return 0;\n  double ab=min(dist(a,b,c),dist(a,b,d));\n  double cd=min(dist(c,d,a),dist(c,d,b));\n  return min(ab,cd);\n}\n\ndouble calcArea(vec &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++)res+=cross(t[i],t[(i+1==n?0:i+1)]);\n  return abs(res/2.0);\n}\n\ndouble Arg(P a,P b,P c){\n  b-=a,c-=a;\n  return arg(c*conj(b));\n}\n\nint inPolygon(vec &t,P p){\n  int n=t.size();\n  double sum=0;  \n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p) == 0 )return 1;// on\n    sum+= Arg(p,a,b);\n  }\n  if( abs(sum) < eps )return 0;//out\n  else  return 2;//in\n}\n\ntypedef pair<double,P> Pair;\nvec ConvexHull(vec t){\n  vector<Pair> u;\n  vec R;\n  int N=t.size(),K=0,C=0;\n  for(int i=1;i<N;i++)if(t[i]<t[K])K=i;\n  for(int i=0;i<N;i++)u.push_back(Pair(arg(t[i]-t[K]),t[i]));\n  R.push_back(t[K]),C++;\n  sort(u.begin(),u.end());\n  for(int i=0;i<N;i++){\n    P p=u[i].second;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==0)continue;\n    if(2<=C&&ccw(R[C-2],R[C-1],p)==2)continue;\n    while(2<=C&&ccw(R[C-2],R[C-1],p)!=1)R.pop_back(),C--;\n    R.push_back(p),C++;    \n  }\n  return R;\n}\n\nvec cutConvex(vec &t,P a,P b){\n  int N=t.size();\n  vec res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C+D==0&&max(C,D)==1)res.push_back(intersect(a,b,c,d));\n  }\n  return res;\n}\n\ndouble maxDist(vec &t){\n  vec u=ConvexHull(t);\n  int N=u.size(),K=0;\n  double res=0;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      res=max(res,abs(t[i]-t[j]));\n    }\n    //    while(abs(t[i]-t[K])<abs(t[i]-t[(K+1)%N]))K=(K+1)%N;\n    //    res=max(res,abs(t[i]-t[K]));\n  }\n  return res;\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  vec t;\n  double x,y;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    t.push_back(P(x,y));\n  }\n  printf(\"%.8f\\n\",maxDist(t));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> point;\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ntypedef vector<point> polygon;\ndouble convex_diameter(const polygon &P) {\n\tauto diff = [&P](int i) {return P[(i+1)%P.size()] - P[i];};\n\tconst int n = P.size();\n\tint is = 0, js = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (imag(P[i]) > imag(P[is])) is = i;\n\t\tif (imag(P[i]) < imag(P[js])) js = i;\n\t}\n\tdouble maxd = norm(P[is]-P[js]);\n\n\tint i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo {\n\t\tif (cross(diff(i), diff(j)) >= 0) j = (j+1) % n;\n\t\telse i = (i+1) % n;\n\t\tif (norm(P[i]-P[j]) > maxd) {\n\t\t\tmaxd = norm(P[i]-P[j]);\n\t\t\tmaxi = i; maxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\treturn maxd; /* farthest pair is (maxi, maxj). */\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tpolygon pol(n);\n\t\tfor (auto& p : pol) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp = point(x, y);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", sqrt(convex_diameter(pol)));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\nLD ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int i = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int j = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int maxi, maxj;\n    LD maxd = 0;\n    for(; i < 2*n; i++){\n        if(maxd < norm(cpol[i]-cpol[j])){\n            maxd = norm(cpol[i] - cpol[j]);\n            maxi = i;\n            maxj = j;\n        }\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) <= 0) j = (j+1) % n;\n        else i = (i+1) % n; \n    }\n    return maxd / 4.0L;\n    //return make_pair(maxi, maxj);\n}\n// ********************************************\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n    //pair<int, int> ans = ConvexPolygonDiameter(p);\n    printf(\"%.9Lf\\n\", /*DistSP(p[ans.first], p[ans.first], p[ans.second])*/ConvexPolygonDiameter(p));\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\nstruct Point{\n\tdouble x,y;\n\tPoint(int x = 0,int y = 0): x(x),y(y) {}\n\tPoint operator + (Point p){\n\t\treturn Point(x + p.x,y + p.y);\n\t}\n\tPoint operator - (Point p){\n\t\treturn Point(x - p.x,y - p.y);\n\t}\n\tPoint operator - (){\n\t\treturn Point(-x,-y);\n\t}\n\tPoint operator * (double lambda){\n\t\treturn Point(x * lambda,y * lambda);\n\t}\n\tPoint operator / (double lambda){\n\t\treturn Point(x / lambda,y / lambda);\n\t}\n\tPoint rot(double theta){\n\t\treturn Point(cos(theta) * x - sin(theta) * y,\n\t\t\t\t\t\t\t\tsin(theta) * x + cos(theta) * y);\n\t}\n\tdouble norm(){\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs_(){\n\t\treturn sqrt(norm());\n\t}\n\tbool operator == (const Point p)const\n\t{\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n\tbool operator < (const Point p)const\n\t{\n\t\tif(abs(x - p.x) < EPS) return y < p.y;\n\t\treturn x < p.x;\n\t}\n};\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble det(Vector a,Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\ntypedef vector <Point> Polygon;\ndouble diameter(Polygon po){\n\tint n = po.size(), minp = 0, maxp = 0;\n\tfor(int i=1;i<n;i++){\n\t\tif(po[i] < po[minp]) minp = i;\n\t\tif(po[maxp] < po[i]) maxp = i;\n\t}\n\tint i = minp, j = maxp;\n\tdouble ans = 0.0;\n\twhile(i != maxp || j != minp){\n\t\tans = max(ans,(po[i] - po[j]).abs_());\n\t\tif(det(po[(i + 1) % n] - po[i], po[(j + 1) % n] - po[j]) < EPS){\n\t\t\ti = (i + 1) % n;\n\t\t}else{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn ans;\n}\nint n; Polygon g;\nint main(){\n\tscanf(\"%d\",&n);\n\tg.resize(n);\n\tfor(int i=0;i<n;i++) scanf(\"%lf%lf\",&g[i].x,&g[i].y);\n\tprintf(\"%.10f\\n\",diameter(g));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem\nusing namespace placeholders;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P = complex<R>;\nusing L = struct {P s, t;};\nusing VP = vector<P>;\nusing C = struct {P c; R r;};\n\n#define at(a,i) (a[(i + a.size()) % a.size()])\n\nauto& operator >> (istream& is, P& p) { R x, y; is >> x >> y, p = P(x, y); return is;}\nauto& operator << (ostream& os, P& p) { os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std {\nbool operator <  (const P& a, const P& b) { return sgn(real(a - b)) ? real(a - b) < 0 : sgn(imag(a - b)) < 0;}\nbool operator == (const P& a, const P& b) { return sgn(real(a - b)) == 0 && sgn(imag(a - b)) == 0;}\n}\n\ninline R dot(P o, P a, P b) {return real(conj(a - o) * (b - o));}\ninline R det(P o, P a, P b) {return imag(conj(a - o) * (b - o));}\ninline P vec(L l) {return l.t - l.s;}\nauto sdot = bind(sgn, bind(dot, _1, _2, _3));\nauto sdet = bind(sgn, bind(det, _1, _2, _3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l, P p) { R u = real((p - l.s) / vec(l)); return (1 - u) * l.s + u * l.t;}\n// vertical parallel\n// verified: AOJ CGL_2_A\nbool vertical(L a, L b) {return sdot(0, vec(a), vec(b)) == 0;}\nbool parallel(L a, L b) {return sdet(0, vec(a), vec(b)) == 0;}\nbool eql(L a, L b) { return parallel(a, b) and sdet(a.s, a.t, b.s) == 0;}\n\n// crossing determination\n// verified: AOJ CGL_2_B\nbool iss(L a, L b) {\n\tint sa = sdet(a.s, a.t, b.s) * sdet(a.s, a.t, b.t);\n\tint sb = sdet(b.s, b.t, a.s) * sdet(b.s, b.t, a.t);\n\treturn max(sa, sb) < 0;\n}\n\n// crossing point\n// verified: AOJ CGL_2_C\nP cross(L a, L b) {\n\tR u = det(a.s, b.s, b.t) / det(0, vec(a), vec(b));\n\treturn (1 - u) * a.s + u * a.t;\n}\n\n// distance\n// verified: AOJ CGL_2_D\nR dsp(L l, P p) {\n\tP h = proj(l, p);\n\tif (sdot(l.s, l.t, p) <= 0) h = l.s;\n\tif (sdot(l.t, l.s, p) <= 0) h = l.t;\n\treturn abs(p - h);\n}\n\nR dss(L a, L b) {\n\tif(iss(a,b)) return 0;\n\treturn min({dsp(a, b.s), dsp(a, b.t), dsp(b, a.s), dsp(b, a.t)});\n}\n// Polygon\n\n// area\n// verified: AOJ 1100 CGL_3_A\nR area(const VP& pol) {\n\tR sum = 0.0;\n\trep(i, pol.size()) sum += det(0, at(pol, i), at(pol, i + 1));\n\treturn abs(sum / 2.0L);\n}\n\n// convex_polygon determination\n// verified: CGL_3_B\nbool is_convex(const VP& pol) {\n\trep(i, pol.size()){\n\t\tif(sdet(at(pol, i), at(pol, i + 1), at(pol, i + 2)) < 0){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// polygon realation determination  in  2 on 1 out 0???(possible non-convex)\n// verified: AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p) {\n\tint res = 0;\n\tauto simag = [](const P & p) {return sgn(imag(p));};\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tif (sdet(p, a, b) == 0 and sdot(p, a, b) <= 0) return 1;\n\t\tbool f = simag(p - a) >= 0, s = simag(p - b) < 0;\n\t\tif (simag(b - a)*sdet(a, b, p) == 1 and f == s) res += (2 * f - 1);\n\t}\n\treturn res ? 2 : 0;\n}\n\n// polygon realation determination???(possible non-convex)\n// verified: not AOJ 2514\nbool in_polygon(const VP& pol, const L& l) {\n\tVP check = {l.s, l.t};\n\trep(i, pol.size()) {\n\t\tL edge = {at(pol, i), at(pol, i + 1)};\n\t\tif (iss(l, edge)) check.emplace_back(cross(l, edge));\n\t}\n\n\tauto cmp_x = [](P a, P b)->bool{\n\t\tint sr = sgn(real(a - b)), si = sgn(imag(a - b));\n\t\treturn sr ? sr < 0 : si < 0;\n\t};\n\n\tsort(begin(check), end(check), cmp_x);\n\trep(i, check.size() - 1) {\n\t\tP m = (at(check, i) + at(check, i + 1)) / 2.0L;\n\t\tif (in_polygon(pol, m) == false) return false;\n\t}\n\treturn true;\n}\n\n// convex_cut\n// verified: AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n\tVP res;\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i), b = at(pol, i + 1);\n\t\tint da = sdet(l.s, l.t, a), db = sdet(l.s, l.t, b);\n\t\tif (da >= 0) res.emplace_back(a);\n\t\tif (da * db < 0) res.emplace_back(cross({a, b}, l));\n\t}\n\treturn res;\n}\n// Circle // verified: AOJ 1183\nenum RCC {OUT = 2, ON_OUT = 1, ISC = 0, ON_IN = -1, IN = -2};\nint rcc(C a, C b) { \n\tR d = abs(a.c - b.c); \n\treturn sgn(d - a.r - b.r) + sgn(d - abs(a.r - b.r));\n}\n\n// circle crossing determination\nbool icp(C c, P p, int end = 0) {return sgn(abs(p - c.c) - c.r) <= -end;}\nbool ics(C c, L s, int end = 0) {\n\tif (sgn(dsp(s, c.c) - c.r) > end) return false;\n\tif (icp(c, s.s, end) and icp(c, s.t, end)) return false;\n\treturn true;\n}\n// common area between circles\nR area(C a, C b) {\n\tint r = rcc(a, b);\n\tif (r >= ON_OUT) return 0.0L;\n\tif (r <= ON_IN) return min(norm(a.r), norm(b.r)) * PI;\n\tR d = abs(b.c - a.c), rc = (norm(d) + norm(a.r) - norm(b.r)) / (2.0 * d);\n\tR t = acos(rc / a.r), p = acos((d - rc) / b.r);\n\treturn norm(a.r) * t + norm(b.r) * p - d * a.r * sin(t);\n}\n\n// cross point between circle and line\n// verified: AOJ CGL_7_D\nP cir(C c, R t) {return c.c + polar(c.r, t);}\nVP cross(C c, L l) {\n\tP h = proj(l, c.c);\n\tP e = polar(sq(norm(c.r) - norm(h - c.c)), arg(vec(l)));\n\treturn VP{h - e, h + e};\n}\n\n// cross point between circles\n// verified: AOJ CGL_7_E\nVP cross(C a, C b) {\n\tP d = b.c - a.c;\n\tP w = (norm(d) + norm(a.r) - norm(b.r)) / (2.0L * norm(d)) * d;\n\treturn cross(a, {a.c + w, a.c + w + 1il * d});\n}\n\n// circle tangent\n// verified: AOJ CGL_7_F\nL tan(C c, P p) {return L{p, p + 1il * (p - c.c)};}\n\nP helper(C c, P d, R r, P j) {\n\tP tmp = sq(norm(d) - norm(r)) * j;\n\tP dir = (r + tmp) / norm(d) * d;\n\treturn c.c + c.r * dir;\n}\n\nVP contact(C c, P p) {\n\tVP ret;\n\tP d = p - c.c;\n\tfor (P j : { -1il, 1il}) ret.emplace_back(helper(c, d, c.r, j));\n\tsort(begin(ret), end(ret));\n\tret.erase(unique(begin(ret), end(ret)), end(ret));\n\treturn ret;\n}\n\n// circle tangent\n// Verified: AOJ CGL_7_G\nVP contact(C a, C b) {\n\tVP ret;\n\tP d = b.c - a.c;\n\tfor (int s : { -1, 1}) {\n\t\tif (rcc(a, b) >= s) {\n\t\t\tfor (P j : { -1i, 1i}) {\n\t\t\t\tR r = a.r + s * b.r;\n\t\t\t\tret.emplace_back(helper(a, d, r, j));\n\t\t\t}\n\t\t}\n\t}\n\tsort(begin(ret), end(ret));\n\tret.erase(unique(begin(ret), end(ret)), end(ret));\n\treturn ret;\n}\n\n// common area of circle and polygon\n// verified: AOJ CGL_7_H\nR area_helper(C c, P a, P b) {\n\tif (icp(c, a) and icp(c, b)) return det(0, a, b) / 2.0l;\n\treturn norm(c.r) * arg(conj(a) * b) / 2.0l;\n}\n\nR area(C c, P a, P b) {\n\tL l = {a, b};\n\n\tif (sgn(min({c.r, abs(a), abs(b), abs(b - a)})) == 0) return 0.0;\n\tif (ics(c, l) == false) return area_helper(c, a, b);\n\n\tR res = 0.0; VP ary;\n\tary.push_back(a);\n\tfor (auto &p : cross(c, l)) if (sdot(p, a, b) < 0) ary.push_back(p);\n\tary.push_back(b);\n\n\trep(i, ary.size() - 1) res += area_helper(c, at(ary, i), at(ary, i + 1));\n\treturn res;\n}\n\nR area(C c, VP pol) {\n\tR res = 0;\n\trep(i, pol.size()) {\n\t\tP a = at(pol, i) - c.c , b = at(pol, i + 1) - c.c;\n\t\tres += area(C{0.0L, c.r}, a, b);\n\t}\n\treturn res;\n}\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \nconst double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n  \nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n  \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n  \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n  \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < -EPS)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n  \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n  \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n};\n\nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n  Geometory::Polygon g(n);\n  for(int i = 0; i < n; i++){\n    scanf(\"%lf %lf\", &g[i].x, &g[i].y);\n  }\n  g = geo.Convex_Hull(g);\n  double ret = 0;\n  for(int i = 0; i < g.size() - 1; i++){\n    for(int j = g.size() - 1; j > i; j--){\n      ret = max( ret, (g[i]-g[j]).abs());\n    }\n  }\n  printf(\"%lf\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst double eps = 1e-8;\nconst double pi = acos(-1.0);\nconst int inf = 0x3f3f3f3f;\ntypedef long long ll;\nint sgn(double x){\n    if(fabs(x)<eps){\n        return 0;\n    }\n    if(x<0){\n        return -1;\n    }else{\n        return 1;\n    }\n}\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    void input(){\n        scanf(\"%lf%lf\",&x,&y);\n    }\n    bool operator < (Point b)const{\n        // return sgn(x-b.x)==0?sgn(y-b.y)<0:x<b.x;\n        return sgn(y-b.y)==0?x<b.x:y<b.y;\n    }\n    bool operator == (Point b)const{\n        return sgn(x-b.x)==0&&sgn(y-b.y)==0;\n    }\n    Point operator -(const Point &b)const{\n        return Point(x-b.x,y-b.y);\n    }\n    double operator ^(const Point &b)const{\n        return x*b.y-y*b.x;\n    }\n    Point operator /(const double& k)const{\n        return Point(x/k,y/k);\n    }\n    double distance(Point p){\n        return hypot(x-p.x,y-p.y);\n    }\n};\nstruct Line{\n    Point s,e;\n    Line(){}\n    Line(Point _s,Point _e){\n        s  = _s;\n        e = _e;\n    }\n};\nstruct polygon{\n    int n;\n    vector<Point> p;\n    void input(int _n){\n        n = _n;\n        Point tt;\n        for(int i = 0;i < n;++i ){\n            tt.input();\n            p.push_back(tt);\n        }\n    }\n    // 安德鲁算法\n     void getconvex(polygon &convex){\n        sort(p.begin(),p.end());\n        convex.n = n;\n        for(int i = 0;i < min(n,2);++i ){\n            convex.p.push_back(p[i]);\n        }\n        if(convex.n == 2&&(convex.p[0] == convex.p[1])){\n            convex.n--;   //特判\n        }\n        if(n<=2){\n            return;\n        }\n        for(int i = 2;i < n;++i ){\n            while(convex.p.size()>1 && sgn((convex.p[convex.p.size()-1]-p[i])^(convex.p[convex.p.size()-2]-p[i]))<=0){\n                convex.p.pop_back();\n            }\n            convex.p.push_back(p[i]);\n        }\n        int temp = convex.p.size()-1;\n        convex.p.push_back(p[n-2]);\n        for(int i = n-3;i >= 0;i--){\n            while(convex.p.size()-1 != temp && sgn((convex.p[convex.p.size()-1]-p[i])^(convex.p[convex.p.size()-2]-p[i]))<=0){\n                convex.p.pop_back();\n            }\n            convex.p.push_back(p[i]);\n        }\n        // convex.n = convex.p.size();\n        if(convex.n == 2 && (convex.p[0] == convex.p[1])){\n            convex.n--;\n        }\n       reverse(convex.p.begin(),convex.p.end());    //!!!!\n       convex.p.pop_back();            //!!!!\n       convex.n = convex.p.size();\n    }\n    //旋转卡壳\n    double rc(){\n        int q = 1;\n        double ans = 0;\n        int tmp = p.size();\n        p.push_back(p[0]);  //p[n] = p[0]\n        for(int i = 0;i < tmp;++i ){\n            while(sgn(((p[q+1]-p[i+1])^(p[i]-p[i+1]))-((p[q]-p[i+1])^(p[i]-p[i+1])))>0){\n                q = (q+1)%tmp;\n            }\n            ans = max(ans,max(p[i].distance(p[q]),p[i+1].distance(p[q+1])));\n        }\n        return ans;\n    }\n};\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    polygon pp;\n    pp.input(n);\n    polygon ans;\n    pp.getconvex(ans);\n    // int tt = ans.n;\n    // for(int i = 0;i < tt;++i ){\n    //     printf(\"%lf %lf\\n\",(ans.p[i].x),(ans.p[i].y));\n    // }\n    double res = ans.rc();\n    printf(\"%.12f\\n\",res);\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define TemplateVersion \"3.4.0\"\n// Useful Marcos\n//====================START=====================\n// Compile use C++11 and above\n#ifdef LOCAL\n#define debug(args...)                           \\\n    {                                            \\\n        string _s = #args;                       \\\n        replace(_s.begin(), _s.end(), ',', ' '); \\\n        stringstream _ss(_s);                    \\\n        istream_iterator<string> _it(_ss);       \\\n        err(_it, args);                          \\\n    }\nvoid err(istream_iterator<string> it)\n{\n}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\n#define MSG cout << \"Finished\" << endl\n#else\n#define debug(args...)\n#define MSG\n#endif\n#if __cplusplus >= 201703L\ntemplate <typename... Args>\nvoid readln(Args &... args)\n{\n    ((cin >> args), ...);\n}\ntemplate <typename... Args>\nvoid writeln(Args... args)\n{\n    ((cout << args << \" \"), ...);\n    cout << endl;\n}\n#elif __cplusplus >= 201103L\nvoid readln()\n{\n}\ntemplate <typename T, typename... Args>\nvoid readln(T &a, Args &... args)\n{\n    cin >> a;\n    readln(args...);\n}\nvoid writeln()\n{\n    cout << endl;\n}\ntemplate <typename T, typename... Args>\nvoid writeln(T a, Args... args)\n{\n    cout << a << \" \";\n    writeln(args...);\n}\n#endif\n#if __cplusplus >= 201103L\n#define FOR(_i, _begin, _end) for (auto _i = _begin; _i < _end; _i++)\n#define FORR(_i, _begin, _end) for (auto _i = _begin; _i > _end; _i--)\n#else\n#define FOR(_i, _begin, _end) for (int _i = (int)_begin; _i < (int)_end; _i++)\n#define FORR(_i, _begin, _end) for (int _i = (int)_begin; _i > (int)_end; _i--)\n#define nullptr NULL\n#endif\n#if __cplusplus >= 201103L\n#define VIS(_kind, _name, _size) \\\n    vector<_kind> _name(_size);  \\\n    for (auto &i : _name)        \\\n        cin >> i;\n#else\n#define VIS(_kind, _name, _size)    \\\n    vector<_kind> _name;            \\\n    _name.resize(_size);            \\\n    for (int i = 0; i < _size; i++) \\\n        cin >> _name[i];\n#endif\n// alias\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define tcase() \\\n    int T;      \\\n    cin >> T;   \\\n    FOR(kase, 1, T + 1)\n// Swap max/min\ntemplate <typename T>\nbool smax(T &a, const T &b)\n{\n    if (a > b)\n        return false;\n    a = b;\n    return true;\n}\ntemplate <typename T>\nbool smin(T &a, const T &b)\n{\n    if (a < b)\n        return false;\n    a = b;\n    return true;\n}\n// ceil divide\ntemplate <typename T>\nT cd(T a, T b)\n{\n    return (a + b - 1) / b;\n}\n// min exchange\ntemplate <typename T>\nbool se(T &a, T &b)\n{\n    if (a < b)\n        return false;\n    swap(a, b);\n    return true;\n}\n// A better MAX choice\nconst int INF = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef set<int> si;\ntypedef vector<string> cb;\n//====================END=====================\n\n// Constants here\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst double FAC = 1e-18;\n\ntypedef double db;\n\nint sgn(db x)\n{\n    if (abs(x) < EPS)\n        return 0;\n    if (x < 0)\n        return -1;\n    return 1;\n}\n\ndb Min(db a, db b) { return sgn(a - b) > 0 ? b : a; }\ndb Max(db a, db b) { return sgn(a - b) > 0 ? a : b; }\n\n// Point/Vector\nstruct Point\n{\n    db x, y;\n\n    Point() : x(0.0), y(0.0) {}\n\n    Point(db _x, db _y) : x(_x), y(_y) {}\n\n    bool operator==(const Point &p)\n    {\n        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;\n    }\n\n    bool operator<(const Point &p)\n    {\n        int c = sgn(x - p.x);\n        if (c)\n            return c == -1;\n        return sgn(y - p.y) == -1;\n    }\n\n    Point operator+(const Point &p) { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point &p) { return Point(x - p.x, y - p.y); }\n    Point operator*(db d) { return Point(x * d, y * d); }\n    Point operator/(db d) { return Point(x / d, y / d); }\n\n    db operator^(const Point &p) { return x * p.y - y * p.x; }\n    db operator*(const Point &p) { return x * p.x + y * p.y; }\n\n    db dis(const Point &p) { return (*this - p).len(); }\n    db alpha() { return atan2(y, x); }\n\n    Point unit() { return *this / len(); }\n    Point scale(db r) { return unit() * r; }\n\n    Point rotCC() { return Point(-y, x); }\n    Point rotCL() { return Point(y, -x); }\n\n    Point rot(Point p, db angle)\n    {\n        Point v = *this - p;\n        db c = cos(angle), s = sin(angle);\n        return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);\n    }\n\n    db len() { return hypot(x, y); }\n    db len2() { return x * x + y * y; }\n\n    db rad(Point a, Point b)\n    {\n        Point ap = a - *this, bp = b - *this;\n        return abs(atan2(abs(ap ^ bp), ap * bp));\n    }\n\n    // Point P,A,B\n    // -2 -> B is at back of PA\n    // -1 -> PB is on the clock-wise side of PA\n    // 0 -> B is on PA\n    // 1 -> PB is on the counter clock-wise side of PA\n    // 2 -> B is at the front of PA\n    int relation(Point a, Point b)\n    {\n        Point p = *this;\n        if (sgn((a - p) ^ (b - p)) > 0)\n            return 1;\n        if (sgn((a - p) ^ (b - p)) < 0)\n            return -1;\n        if (sgn((a - p) * (b - p)) < 0)\n            return -2;\n        if (sgn((p - a) * (b - a)) < 0)\n            return 2;\n        return 0;\n    }\n\n    void read() { cin >> x >> y; }\n    void write(char trail = ' ') { cout << x << ' ' << y << trail; }\n    void Debug() { cerr << \"Point: (\" << x << \", \" << y << \")\\n\"; }\n};\n\ndb cross(Point a, Point b, Point c) { return (b - a) ^ (c - a); }\n\n// Line\nstruct Line\n{\n    Point s, e;\n\n    Line(){};\n\n    Line(Point _s, Point _e) : s(_s), e(_e) {}\n\n    Line(Point p, db angle)\n    {\n        s = p;\n        if (sgn(angle - PI / 2))\n            e = (s + Point(1, tan(angle)));\n        else\n            e = (s + Point(0, 1));\n    }\n\n    //ax+by+c=0\n    Line(db a, db b, db c)\n    {\n        if (sgn(a) == 0)\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -c / b);\n        }\n        else if (sgn(b) == 0)\n        {\n            s = Point(-c / a, 0);\n            e = Point(-c / a, 1);\n        }\n        else\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -(c + a) / b);\n        }\n    }\n\n    db len() { return s.dis(e); }\n    db angle()\n    {\n        db ans = atan2(e.y - s.y, e.x - s.x);\n        if (sgn(ans) == -1)\n            ans += PI;\n        if (sgn(ans - PI) == 0)\n            ans -= PI;\n        return ans;\n    }\n\n    int relation(Point p) { return s.relation(e, p); }\n\n    bool parallel(Line l) { return sgn((e - s) ^ (l.e - l.s)) == 0; }\n\n    // 0 -> Not Intersect\n    // 1 -> Informal\n    // 2 -> Formal Intersection\n    int crossSS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        int d3 = sgn((l.e - l.s) ^ (s - l.s));\n        int d4 = sgn((l.e - l.s) ^ (e - l.s));\n        if ((d1 ^ d2) == -2 && (d3 ^ d4) == -2)\n            return 2;\n        return (d1 == 0 && sgn((l.s - s) * (l.s - e)) <= 0) ||\n               (d2 == 0 && sgn((l.e - s) * (l.e - e)) <= 0) ||\n               (d3 == 0 && sgn((s - l.s) * (s - l.e)) <= 0) ||\n               (d4 == 0 && sgn((e - l.s) * (e - l.e)) <= 0);\n    }\n\n    // 0 -> Not Intersect\n    // 1 -> Informal\n    // 2 -> Formal Intersection\n    int crossLS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        if ((d1 ^ d2) == -2)\n            return 2;\n        return (d1 == 0 || d2 == 0);\n    }\n\n    // 0 -> Parallel\n    // 1 -> Same\n    // 2 -> Intersect\n    int crossLL(Line l)\n    {\n        if (this->parallel(l))\n            return l.relation(s) == 3;\n        return 2;\n    }\n\n    Point intersec(Line l)\n    {\n        db a1 = (l.e - l.s) ^ (s - l.s);\n        db a2 = (l.e - l.s) ^ (e - l.s);\n        return Point((s.x * a2 - e.x * a1) / (a2 - a1), (s.y * a2 - e.y * a1) / (a2 - a1));\n    }\n\n    db disPL(Point p) { return abs((p - s) ^ (e - s)) / len(); }\n    db disPS(Point p)\n    {\n        if (sgn((p - s) * (e - s)) < 0 || sgn((p - e) * (s - e)) < 0)\n            return min(p.dis(s), p.dis(e));\n        return disPL(p);\n    }\n    db disSS(Line l) { return min(min(disPS(l.s), disPS(l.e)), min(l.disPS(s), l.disPS(e))); }\n\n    Point proj(Point p) { return s + ((e - s) * ((e - s) * (p - s))) / ((e - s).len2()); }\n    Point refl(Point p)\n    {\n        Point q = proj(p);\n        return Point(2 * q.x - p.x, 2 * q.y - p.y);\n    }\n\n    bool operator==(Line l) { return s == l.s && e == l.e; }\n\n    void adjust()\n    {\n        if (e < s)\n            swap(s, e);\n    }\n\n    void read()\n    {\n        s.read();\n        e.read();\n    }\n\n    void Debug() { cerr << \"Line: Start: (\" << s.x << \", \" << s.y << \") End: (\" << e.x << \", \" << e.y << \")\\n\"; }\n};\n\n// Circle\nstruct Circle\n{\n    Point p;\n    db r;\n\n    Circle(){};\n\n    Circle(Point _p, db _r) : p(_p), r(_r) {}\n\n    Circle(db x, db y, db _r) : p({x, y}), r(_r) {}\n\n    Circle(Point a, Point b, Point c, bool in = false)\n    {\n        if (!in)\n        {\n            Line u = Line((a + b) / 2, (a + b) / 2 + (b - a).rotCC());\n            Line v = Line((b + c) / 2, (b + c) / 2 + (c - b).rotCC());\n            p = u.intersec(v);\n            r = p.dis(a);\n        }\n        else\n        {\n            Line u, v;\n            db m = atan2(b.y - a.y, b.x - a.x), n = atan2(c.y - a.y, c.x - a.x);\n            u.s = a;\n            u.e = a + Point(cos((n + m) / 2), sin((n + m) / 2));\n            v.s = b;\n            m = atan2(a.y - b.y, a.x - b.x), n = atan2(c.y - b.y, c.x - b.x);\n            v.e = b + Point(cos((n + m) / 2), sin((n + m) / 2));\n            p = u.intersec(v);\n            r = Line(a, b).disPS(p);\n        }\n    }\n\n    bool operator==(const Circle &c) { return p == c.p && sgn(r - c.r) == 0; }\n\n    bool operator<(const Circle &c) { return (p < c.p) || (p == c.p && sgn(r - c.r) < 0); }\n\n    db area() { return PI * r * r; }\n\n    db cir() { return 2 * PI * r; }\n\n    Point on(db ang) { return Point(p.x + r * cos(ang), p.y + r * sin(ang)); }\n\n    // 0 -> Outside\n    // 1 -> On\n    // 2 -> Inside\n    int relationP(Point v)\n    {\n        db dis = v.dis(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // The number of intersections\n    int relationS(Line l)\n    {\n        db dis = l.disPS(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // The number of intersections\n    int relationL(Line l)\n    {\n        db dis = l.disPL(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // 1 -> Inside\n    // 2 -> Internally-tangent\n    // 3 -> Intersect\n    // 4 -> Externally-tangent\n    // 5 -> Disjoint\n    int relationC(Circle c)\n    {\n        db d = p.dis(c.p);\n        if (sgn(d - r - c.r) > 0)\n            return 5;\n        if (sgn(d - r - c.r) == 0)\n            return 4;\n        db l = abs(r - c.r);\n        if (sgn(d - r - c.r) < 0 && sgn(d - l) > 0)\n            return 3;\n        if (sgn(d - l) == 0)\n            return 2;\n        // TODO: Check if this one is necessary\n        // if (sgn(d - l) < 0)\n        return 1;\n    }\n\n    // The return value is the number of intersections\n    int crossC(Circle c, Point &p1, Point &p2)\n    {\n        int re = relationC(c);\n        if (re == 1 || re == 5)\n            return 0;\n        db d = p.dis(c.p), l = (d * d + r * r - c.r * c.r) / (2.0 * d), h = sqrt(r * r - l * l);\n        Point tmp = p + (c.p - p).scale(l);\n        p1 = tmp + (c.p - p).rotCC().scale(h);\n        p2 = tmp + (c.p - p).rotCL().scale(h);\n        if (re == 2 || re == 4)\n            return 1;\n        return 2;\n    }\n\n    // Same as above\n    int crossL(Line l, Point &p1, Point &p2)\n    {\n        if (!this->relationL(l))\n            return 0;\n        Point a = l.proj(p);\n        db d = l.disPL(p);\n        d = sqrt(r * r - d * d);\n        if (sgn(d) == 0)\n        {\n            p1 = a;\n            p2 = a;\n            return 1;\n        }\n        p1 = a + (l.e - l.s).scale(d);\n        p2 = a - (l.e - l.s).scale(d);\n        return 2;\n    }\n\n    int tangent(Point q, Point &u, Point &v)\n    {\n        int x = relationP(q);\n        if (x == 2)\n            return 0;\n        if (x == 1)\n        {\n            u = q + (q - p).rotCC();\n            v = u;\n            return 1;\n        }\n        db d = p.dis(q);\n        db l = r * r / d;\n        db h = sqrt(r * r - l * l);\n        u = p + ((q - p).scale(l) + (q - p).rotCC().scale(h));\n        v = p + ((q - p).scale(l) + (q - p).rotCL().scale(h));\n        return 2;\n    }\n\n    int tangent(Circle c, vector<Point> &u, vector<Point> &v)\n    {\n        if (sgn(r - c.r) < 0)\n            return c.tangent(*this, v, u);\n\n        int ret = relationC(c) - 1;\n        if (!ret || *this == c)\n            return 0;\n        u.clear();\n        v.clear();\n\n        db b = (c.p - p).alpha();\n\n        if (ret == 1 || ret == 3)\n        {\n            u.push_back(on(b));\n            v.push_back(on(b));\n        }\n\n        db ang = acos((r - c.r) / p.dis(c.p));\n\n        if (ret != 1)\n        {\n            u.push_back(on(b + ang));\n            u.push_back(on(b - ang));\n            v.push_back(c.on(b + ang));\n            v.push_back(c.on(b - ang));\n        }\n\n        if (ret == 4)\n        {\n            ang = acos((r + c.r) / p.dis(c.p));\n            u.push_back(on(b + ang));\n            u.push_back(on(b - ang));\n            v.push_back(c.on(PI + b + ang));\n            v.push_back(c.on(PI + b - ang));\n        }\n\n        return ret;\n    }\n\n    // The area of intersecting space\n    // With circle c\n    db area(Circle c)\n    {\n        int re = relationC(c);\n        if (re >= 4)\n            return 0;\n        if (re <= 2)\n            return min(area(), c.area());\n        db d = p.dis(c.p);\n        db hf = (r + c.r + d) / 2.0;\n        db ss = 2 * sqrt(hf * (hf - r) * (hf - c.r) * (hf - d));\n        db a1 = acos((r * r + d * d - c.r * c.r) / (2.0 * r * d));\n        a1 = a1 * r * r;\n        db a2 = acos((c.r * c.r + d * d - r * r) / (2.0 * c.r * d));\n        a2 = a2 * c.r * c.r;\n        return a1 + a2 - ss;\n    }\n\n    // The area of intersecting space\n    // With triangle PAB\n    db area(Point a, Point b)\n    {\n        if (sgn((p - a) ^ (p - b)) == 0)\n            return 0.0;\n        Point q[5];\n        int len = 0;\n        q[len++] = a;\n        Line l(a, b);\n        Point p1, p2;\n        if (crossL(l, q[1], q[2]) == 2)\n        {\n            if (sgn((a - q[1]) * (b - q[1])) < 0)\n                q[len++] = q[1];\n            if (sgn((a - q[2]) * (b - q[2])) < 0)\n                q[len++] = q[2];\n        }\n        q[len++] = b;\n        if (len == 4 && sgn((q[0] - q[1]) * (q[2] - q[1])) > 0)\n            swap(q[1], q[2]);\n        db res = 0;\n        for (int i = 0; i < len - 1; i++)\n        {\n            if (relationP(q[i]) == 0 || relationP(q[i + 1]) == 0)\n            {\n                db arg = p.rad(q[i], q[i + 1]);\n                res += r * r * arg / 2.0;\n            }\n            else\n                res += abs((q[i] - p) ^ (q[i + 1] - p)) / 2.0;\n        }\n        return res;\n    }\n\n    // Two circle whose center are a and b respectivelly\n    static int GetCircle(Point a, Point b, db r, Circle &c1, Circle &c2)\n    {\n        Circle x(a, r), y(b, r);\n        int t = x.crossC(y, c1.p, c2.p);\n        if (!t)\n            return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n\n    // The circle which tangent is l and point p on it\n    static int GetCircle(Line l, Point p, db r, Circle &c1, Circle &c2)\n    {\n        db dis = l.disPL(p);\n        if (sgn(dis - r * 2) > 0)\n            return 0;\n        if (sgn(dis) == 0)\n        {\n            c1.p = p + ((l.e - l.s).rotCC().scale(r));\n            c2.p = p + ((l.e - l.s).rotCL().scale(r));\n            c1.r = c2.r = r;\n            return 2;\n        }\n        Line u1 = Line((l.s + (l.e - l.s).rotCC().scale(r)), (l.e + (l.e - l.s).rotCC().scale(r)));\n        Line u2 = Line((l.s + (l.e - l.s).rotCL().scale(r)), (l.e + (l.e - l.s).rotCL().scale(r)));\n        Circle cc(p, r);\n        Point p1, p2;\n        if (!cc.crossL(u1, p1, p2))\n            cc.crossL(u2, p1, p2);\n        c1 = Circle(p1, r);\n        if (p1 == p2)\n        {\n            c2 = c1;\n            return 1;\n        }\n        c2 = Circle(p2, r);\n        return 2;\n    }\n\n    // u and v are the common tangent of the four circles\n    static int GetCircle(Line u, Line v, db r, Circle &c1, Circle &c2, Circle &c3, Circle &c4)\n    {\n        if (u.parallel(v))\n            return 0;\n        Line u1 = Line(u.s + (u.e - u.s).rotCC().scale(r), u.e + (u.e - u.s).rotCC().scale(r));\n        Line u2 = Line(u.s + (u.e - u.s).rotCL().scale(r), u.e + (u.e - u.s).rotCL().scale(r));\n        Line v1 = Line(v.s + (v.e - v.s).rotCC().scale(r), v.e + (v.e - v.s).rotCC().scale(r));\n        Line v2 = Line(v.s + (v.e - v.s).rotCL().scale(r), v.e + (v.e - v.s).rotCL().scale(r));\n        c1.r = c2.r = c3.r = c4.r = r;\n        c1.p = u1.intersec(v1);\n        c2.p = u1.intersec(v2);\n        c3.p = u2.intersec(v1);\n        c4.p = u2.intersec(v2);\n        return 4;\n    }\n\n    // Tangent with circle cx and cy\n    static int GetCircle(Circle cx, Circle cy, db r, Circle &c1, Circle &c2)\n    {\n        Circle x(cx.p, r + cx.r), y(cy.p, r + cy.r);\n        int t = x.crossC(y, c1.p, c2.p);\n        if (!t)\n            return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n\n    void read()\n    {\n        p.read();\n        cin >> r;\n    }\n\n    void Debug() { cerr << \"Circle: Center: (\" << p.x << \", \" << p.y << \") Radius: \" << r << '\\n'; }\n};\n\n// Polygon\nstruct Polygon\n{\n    // Functor for sorting by polar angle\n    struct cmp\n    {\n        Point p;\n        cmp(const Point &b) { p = b; }\n        bool operator()(const Point &a, const Point &b)\n        {\n            Point x = a, y = b;\n            int d = sgn((x - p) ^ (y - p));\n            if (!d)\n                return sgn(x.dis(p) - y.dis(p)) > 0;\n            return d > 0;\n        }\n    };\n\n    vector<Point> ps;\n    vector<Line> ls;\n\n    Polygon() {}\n\n    void add(Point p) { ps.push_back(p); }\n\n    int size() { return static_cast<int>(ps.size()); }\n\n    void getLines()\n    {\n        int s = size();\n        for (int i = 0; i < s; i++)\n            ls.push_back(Line(ps[i], ps[(i + 1) % s]));\n    }\n\n    void norm()\n    {\n        Point p = ps[0];\n        for (int i = 1; i < size(); i++)\n        {\n            if (p < ps[i])\n                continue;\n            p = ps[i];\n        }\n        sort(ps.begin(), ps.end(), cmp(p));\n    }\n\n    void getConvexJarvis(Polygon &conv)\n    {\n        sort(ps.begin(), ps.end());\n        conv.ps.resize(2 * size());\n\n        int n = size();\n        for (int i = 0; i < min(2, n); i++)\n            conv.ps[i] = ps[i];\n        if (conv.size() == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.resize(1);\n\n        if (n <= 2)\n            return;\n\n        int top = 1;\n\n        for (int i = 2; i < n; i++)\n        {\n            while (top && sgn((conv.ps[top] - ps[i]) ^ (conv.ps[top - 1] - ps[i])) <= 0)\n                top--;\n            conv.ps[++top] = ps[i];\n        }\n\n        int t = top;\n        conv.ps[++top] = ps[n - 2];\n\n        for (int i = n - 3; i >= 0; i--)\n        {\n            while (top != t && sgn((conv.ps[top] - ps[i]) ^ (conv.ps[top - 1] - ps[i])) <= 0)\n                top--;\n            conv.ps[++top] = ps[i];\n        }\n\n        while (conv.size() > top)\n            conv.ps.pop_back();\n\n        if (top == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.pop_back();\n\n        conv.norm(); // Counter Clock-wise\n    }\n\n    void getConvexWithPointOnLine(Polygon &conv)\n    {\n        int m, n = size();\n        if (n < 3)\n        {\n            for (auto i : ps)\n                conv.add(i);\n            return;\n        }\n\n        vector<Point> &g = conv.ps;\n\n        sort(ps.begin(), ps.end());\n        for (int i = 0; i < n; i++)\n        {\n            while ((m = g.size()) >= 2 && g[m - 2].relation(g[m - 1], ps[i]) <= 0)\n                g.pop_back();\n            g.push_back(ps[i]);\n        }\n\n        int t = g.size();\n\n        for (int i = n - 2; i >= 0; i--)\n        {\n            while ((m = g.size()) > t && g[m - 2].relation(g[m - 1], ps[i]) <= 0)\n                g.pop_back();\n            g.push_back(ps[i]);\n        }\n\n        g.pop_back();\n    }\n\n    // Cannot get the point on the edge\n    void getConvexGraham(Polygon &conv)\n    {\n        norm();\n        int top = 0, n = size();\n        if (n == 1)\n        {\n            conv.add(ps[0]);\n            return;\n        }\n\n        if (n == 2)\n        {\n            conv.add(ps[0]);\n            conv.add(ps[1]);\n            if (conv.ps[0] == conv.ps[1])\n                conv.ps.pop_back();\n            return;\n        }\n\n        conv.ps.resize(size());\n        conv.ps[0] = ps[0];\n        conv.ps[1] = ps[1];\n        top = 2;\n        for (int i = 2; i < n; i++)\n        {\n            while (top > 1 && sgn((conv.ps[top - 1] - conv.ps[top - 2]) ^ (ps[i] - conv.ps[top - 2])) <= 0)\n                top--;\n            conv.ps[top++] = ps[i];\n        }\n\n        while (conv.size() > top)\n            conv.ps.pop_back();\n\n        if (top == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.pop_back();\n    }\n\n    bool isConvex()\n    {\n        bitset<3> s;\n        int n = size();\n        for (int i = 0; i < n; i++)\n        {\n            int j = (i + 1) % n;\n            int k = (j + 1) % n;\n            s.set(sgn((ps[j] - ps[i]) ^ (ps[k] - ps[i])) + 1);\n            if (s[0] && s[2])\n                return false;\n        }\n        return true;\n    }\n\n    db diameter()\n    {\n        int q = 1, n = size();\n        db ans = 0;\n        ps.push_back(ps[0]);\n        for (int i = 0; i < n; i++)\n        {\n            while (sgn(cross(ps[i + 1], ps[q + 1], ps[i]) - cross(ps[i + 1], ps[q], ps[i])) > 0)\n                q = (q + 1) % n;\n            ans = Max(ans, Max(ps[i].dis(ps[q]), ps[i + 1].dis(ps[q + 1])));\n        }\n        ps.pop_back();\n        return ans;\n    }\n\n    // 3 -> On Corner\n    // 2 -> On Edge\n    // 1 -> Inside\n    // 0 -> Outside\n    int relationP(Point q)\n    {\n        int n = size();\n        for (int i = 0; i < n; i++)\n            if (ps[i] == q)\n                return 3;\n        getLines();\n        for (int i = 0; i < n; i++)\n            if (!ls[i].relation(q))\n                return 2;\n        int cnt = 0;\n        for (int i = 0; i < n; i++)\n        {\n            int j = (i + 1) % n;\n            int k = sgn((q - ps[j]) ^ (ps[i] - ps[j]));\n            int u = sgn(ps[i].y - q.y);\n            int v = sgn(ps[j].y - q.y);\n            if (k > 0 && u < 0 && v >= 0)\n                cnt++;\n            if (k < 0 && v < 0 && u >= 0)\n                cnt--;\n        }\n        return cnt != 0;\n    }\n\n    void convexCut(Line l, Polygon &po)\n    {\n        for (int i = 0; i < size(); i++)\n        {\n            int d1 = sgn((l.e - l.s) ^ (ps[i] - l.s));\n            int d2 = sgn((l.e - l.s) ^ (ps[(i + 1) % size()] - l.s));\n            if (d1 >= 0)\n                po.add(ps[i]);\n            if (d1 * d2 < 0)\n                po.add(l.intersec(Line(ps[i], ps[(i + 1) % size()])));\n        }\n    }\n\n    db cir()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += ps[i].dis(ps[(i + 1) % n]);\n        return sum;\n    }\n\n    db area()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += (ps[i] ^ ps[(i + 1) % n]);\n        return abs(sum) / 2;\n    }\n\n    // 0 -> Clock-wise\n    // 1 -> Counter Clock-wise\n    bool dir()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += (ps[i] ^ ps[(i + 1) % n]);\n        return sgn(sum) > 0;\n    }\n\n    Point baryCenter()\n    {\n        Point ret;\n        db area = 0;\n        for (int i = 1; i < size() - 1; i++)\n        {\n            db tmp = (ps[i] - ps[0]) ^ (ps[i + 1] - ps[0]);\n            if (sgn(tmp) == 0)\n                continue;\n            area += tmp;\n            ret.x += (ps[0].x + ps[i].x + ps[i + 1].x) / 3 * tmp;\n            ret.y += (ps[0].y + ps[i].y + ps[i + 1].y) / 3 * tmp;\n        }\n        if (sgn(area))\n            ret = ret / area;\n        return ret;\n    }\n\n    db area(Circle c)\n    {\n        double ans = 0;\n        for (int i = 0; i < size(); i++)\n        {\n            int j = (i + 1) % size();\n            if (sgn((ps[j] - c.p) ^ (ps[i] - c.p)) >= 0)\n                ans += c.area(ps[i], ps[j]);\n            else\n                ans -= c.area(ps[i], ps[j]);\n        }\n        return abs(ans);\n    }\n\n    // 2 -> The circle is entirely in the polygon\n    // 1 -> The circle in in the circle and intersected with the boundary\n    // 0 -> Otherwise\n    int relationC(Circle c)\n    {\n        getLines();\n        int x = 2;\n        if (relationP(c.p) != 1)\n            return 0;\n        for (int i = 0; i < size(); i++)\n        {\n            if (c.relationS(ls[i]) == 2)\n                return 0;\n            if (c.relationS(ls[i]) == 1)\n                x = 1;\n        }\n        return x;\n    }\n\n    void read(int s)\n    {\n        for (int i = 0; i < s; i++)\n        {\n            Point p;\n            p.read();\n            ps.push_back(p);\n        }\n    }\n\n    void Debug()\n    {\n        cerr << \"Polygon:\\nPoints:\\n\";\n        for (auto i : ps)\n            i.Debug();\n        cerr << \"Lines:\\n\";\n        for (auto i : ls)\n            i.Debug();\n    }\n};\n\n// Pre-Build Function\ninline void build()\n{\n}\n\n// Actual Solver\ninline void solve()\n{\n    cout << fixed << setprecision(10);\n    int n;\n    cin >> n;\n    Polygon g, conv;\n    g.read(n);\n    g.getConvexGraham(conv); // Get strict convex hull\n    assert(conv.isConvex());\n    cout << conv.diameter() << '\\n';\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n#ifdef LOCAL\n    clock_t _begin = clock();\n#endif\n\n    build();\n    solve();\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << (double)(clock() - _begin) * 1000 / CLOCKS_PER_SEC << \"ms.\" << endl;\n#endif\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\n//?????¢?????¢???\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\nint main(){\n  int n,c=0;\n  Polygon p,a;\n  Point s;\n  double d=0;\n  cin>>n;\n  while(n--){\n    cin>>s.x>>s.y;\n    p.push_back(s);\n  }\n  a=andrewScan(p);\n  r(i,a.size())\n  for(int j=i+1;j<a.size();j++)\n    d=max(d,getDistancePP(a[i],a[j]));\n  printf(\"%.11f\\n\",d);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \nint main()\n{\n    int n; vector<double> x, y;\n     \n    scanf(\"%d\", &n);\n     \n    x = vector<double>(n);\n    y = vector<double>(n);\n     \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n     \n    double diameter = 0.0;\n     \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            diameter = max((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]), diameter);\n        }\n    }\n     \n    printf(\"%.9f\\n\", sqrt(diameter));\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n    typedef double D;\n    typedef bool B;\n    typedef complex<D> P;\n#define X real()\n#define Y imag()\n    B comp(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return ccw(a,b,p)/ abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return ccw(a,b,c)*ccw(a,b,d)<EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_point_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL Poly convex_hull(Poly p) {\n        int n = p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p),comp);\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n\n        //not necessary?\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    IL D area(Poly& l){\n        double res=0;\n        int n=l.size();\n        REP(i,n)res+=cross(l[i],l[(i+1)%n]);\n          return abs(res)/2.0;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist - r > -EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            if(dist-r > EPS){\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist - (Rp + Rq) > -EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist - abs(Rp - Rq) >- EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n\n     vector<Poly> decomposition(Poly p){\n        int n = p.size();\n        vector<Poly> res;\n        while(n>=3){\n            [&](){\n                FOR(i, 0, n){\n                    P a = p[i];\n                    P b = p[(i+1)%n];\n                    P c = p[(i+2)%n];\n                    if (ccw(a,b,c)<0)continue;\n                    if([&](){\n                            FOR(j,3,n){\n                                P d=p[(i+j)%n];\n                                if(ccw(a,b,d)>-EPS&&ccw(b,c,d)>-EPS&&ccw(c,a,d)>-EPS)\n                                    return true;\n                            }\n                            return false;\n                        }()\n                        )continue;\n                    Poly nxt;\n                    REP(j,n)if((i+j)%n!=(i+1)%n)nxt.push_back(p[(i+j)%n]);\n                    swap(p,nxt);\n                    res.push_back({a,b,c});\n                    n--;\n                    return;\n                }\n            }();\n        }\n        return res;\n    }\n    int in_triangle(P p,Poly q){\n        REP(i,3)if(abs(p-q[i])<EPS)return 3;//on point\n        REP(i,3){\n            int s=sgn(q[i],q[(i+1)%3],p);\n            if(s!=1){\n                if(s==0)return 2;//on line\n                else return 0; // not in\n            }\n        }\n        return 1; // inside triangle\n    }\n    int in_C(P q,C c){\n        DCc(p,r,c);\n        if(abs(r-abs(p-q))<EPS)return 2; //on\n        return r-abs(p-q)>-EPS ? 1:0;\n    }\n    int is_triangle_C(Poly t,C c){\n        t=convex_hull(t);\n        DCc(p,r,c);\n        int cnt=0;\n        REP(i,3)\n            cnt+=(in_C(t[i],c)>0);\n        if(cnt==3)return 3; // t in c\n        if(cnt==0){\n            double d=distance_P_LS(p,LS(t[2],t[0]));\n            REP(i,2)\n                d=min(d,distance_P_LS(p,LS(t[i],t[i+1])));\n            if(r-d>EPS)return 1;//intersect\n            if(in_triangle(p,t))return 2;//c in t\n            else if(r-d<-EPS)return 0; //not intersect\n        }\n        return 1;//intersect\n    }\n    //p must be convex and ccw\n    LS diameter(Poly &p){\n        int n=p.size();\n        int is=0,js=0;\n        REP(i,n)if(p[i].Y>p[is].Y)is=i;\n        REP(i,n)if(p[i].Y<p[js].Y)js=i;\n        LS res={p[is],p[js]};\n        //cout<<is<<\" \"<<js<<endl;\n        {\n            int i=is;\n            int j=js;\n            do{\n                int ni=(i+1)%n;\n                int nj=(j+1)%n;\n                if(cross(p[ni]-p[i],p[nj]-p[j])<EPS)i=ni;\n                else j=nj;\n                if(abs(res.fi-res.se)<abs(p[i]-p[j]))\n                    res=LS(p[i],p[j]);\n            }while(i!=is||j!=js);\n        }\n        return res;\n    }\n}\n\n\nusing namespace geo;\n\nint main(){\n    int n;\n    cin>>n;\n    cout<<setprecision(10);\n    cout<<fixed;\n    Poly p(n);\n    REP(i,n){\n        double x,y;\n        cin>>x>>y;\n        p[i]=P(x,y);\n    }\n    auto res=diameter(p);\n    cout<<abs(res.fi-res.se)<<endl;\n   \n    \n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nnamespace geo{\n    using real_num = double;\n    constexpr real_num eps = 1e-9;\n    constexpr real_num PI = 3.14159265358979323846264338327950;\n\n    inline int sgn(real_num x){\n        if(x < -eps) return -1;\n        if(x > eps) return 1;\n        return 0;\n    }\n \n    inline bool eq(real_num x, real_num y){\n        return sgn(x-y) == 0;\n    }\n \n    inline bool ge(real_num x, real_num y){\n        return sgn(x-y) == 1;\n    }\n \n    inline bool le(real_num x, real_num y){\n        return sgn(x-y) == -1;\n    }\n \n    inline bool geq(real_num x, real_num y){\n        return sgn(x-y) >= 0;\n    }\n \n    inline bool leq(real_num x, real_num y){\n        return sgn(x-y) <= 0;\n    }\n\n    struct Point{\n        real_num x, y;\n        Point(real_num x=0, real_num y=0): x(x), y(y){}\n \n        Point operator+(const Point &p){\n            return {x+p.x, y+p.y};\n        }\n \n        Point operator-(const Point &p){\n            return {x-p.x, y-p.y};\n        }\n \n        Point operator*(const real_num k){\n            return {k*x, k*y};\n        }\n \n        Point operator/(const real_num k){\n            return {x/k, y/k};\n        }\n \n        real_num operator*(const Point &p){\n            return x*p.x + y*p.y;\n        }\n \n        real_num operator^(const Point &p){\n            return x*p.y - y*p.x;\n        }\n \n        bool operator==(const Point &p){\n            return eq(x, p.x) && eq(y, p.y);\n        }\n \n        bool operator<(const Point &p) const{\n            if(eq(x, p.x)) return le(y, p.y);\n            return le(x, p.x);\n        }\n    };\n\n    using Vec = Point;\n    using Points = vector<Point>;\n    using Polygon = vector<Point>;\n\n    real_num norm(Point p){\n        return p.x*p.x+p.y*p.y;\n    }\n \n    real_num abs(Point p){\n        return sqrt(norm(p));\n    }\n \n    real_num arg(Point p){\n        return atan2(p.y, p.x);\n    }\n \n    Point rot(Point p, real_num t){\n        return {p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)};\n    }\n \n    Point proj(Point a, Vec v, Point p){\n        real_num t=v*(p-a)/norm(v);\n        return a+v*t;\n    }\n \n    Point refl(Point a, Vec v, Point p){\n        return proj(a, v, p)*2-p;\n    }\n\n    constexpr int CCW_COUNTER_CLOCKWISE=1;\n    constexpr int CCW_CLOCKWISE=-1;\n    constexpr int CCW_ONLINE_BACK=-2; // C->A->B\n    constexpr int CCW_ONLINE_FRONT=2; // A->B->C\n    constexpr int CCW_ON_SEGMENT=0; // A->C->B\n \n    inline int ccw(Point a, Point b, Point c){\n        Vec v=b-a, w=c-a;\n        if(ge(v^w, 0)) return CCW_COUNTER_CLOCKWISE;\n        if(le(v^w, 0)) return CCW_CLOCKWISE;\n        if(le(v*w, 0)) return CCW_ONLINE_BACK;\n        if(le((a-b)*(c-b), 0)) return CCW_ONLINE_FRONT;\n        return CCW_ON_SEGMENT;\n    }\n\n    bool is_parallel(Vec v, Vec w){\n        return eq(v^w, 0);\n    }\n\n    bool is_orthogonal(Vec v, Vec w){\n        return eq(v*w, 0);\n    }\n\n    bool has_intersection_ss(Point a, Point b, Point c, Point d){\n        return ccw(a, b, c)*ccw(a, b, d) <= 0 && ccw(c, d, a)*ccw(c, d, b) <= 0;\n    }\n\n    Point intersection_ll(Point a, Vec v, Point b, Vec w){\n        real_num t = ((b-a)^w) / (v^w);\n        return a + v*t;\n    }\n\n    real_num distance_lp(Point a, Vec v, Point p){\n        return abs(v^(p-a)/abs(v));\n    }\n\n    real_num distance_sp(Point a, Point b, Point p){\n        if(le((b-a)*(p-a), 0)) return abs(p-a);\n        if(le((a-b)*(p-b), 0)) return abs(p-b);\n        return distance_lp(a, b-a, p);\n    }\n\n    real_num distance_ll(Point a, Vec v, Point b, Vec w){\n        if(is_parallel(v, w)) return distance_lp(a, v, b);\n        return 0;\n    }\n\n    real_num distance_ls(Point a, Vec v, Point c, Point d){\n        Point b = a + v;\n        if(ccw(a, b, c)*ccw(a, b, d) <= 0) return 0;\n        return min(distance_lp(a, v, c), distance_lp(a, v, d));\n    }\n\n    real_num distance_ss(Point a, Point b, Point c, Point d){\n        if(has_intersection_ss(a, b, c, d)) return 0;\n        return min({distance_sp(a, b, c), distance_sp(a, b, d),\n                distance_sp(c, d, a), distance_sp(c, d, b)});\n    }\n\n    real_num area(Polygon &p){\n        real_num ret = 0;\n        rep(i, p.size()) ret += p[i] ^ p[(i+1)%p.size()] / 2;\n        return abs(ret);\n    }\n\n    bool is_convex(Polygon &p){\n        int n = p.size();\n        bool flag1 = false, flag2 = false;\n        rep(i, n){\n            int tmp = ccw(p[(i+n-1)%n], p[i], p[(i+1)%n]);\n            if(tmp == CCW_COUNTER_CLOCKWISE){\n                if(flag2) return false;\n                flag1=true;\n            }\n            else if(tmp == CCW_CLOCKWISE){\n                if(flag1) return false;\n                flag2 = true;\n            }\n        }\n        return true;\n    }\n\n    int point_in_polygon(Point a, Polygon &p){\n        int n = p.size(), wn = 0;\n        rep(i, n){\n            int j = (i+1) % n;\n            if(distance_sp(p[i], p[j], a) == 0) return 1;\n            else if(p[i].y <= a.y && a.y < p[j].y){\n                wn += (ccw(a, p[i], p[j]) == CCW_COUNTER_CLOCKWISE);\n            }\n            else if(p[j].y <= a.y && a.y < p[i].y){\n                wn -= (ccw(a, p[i], p[j]) == CCW_CLOCKWISE);\n            }\n        }\n        return wn == 0 ? 0 : 2;\n    }\n\n    Polygon convex_hull(Points p){\n        int n = p.size();\n        sort(p.begin(), p.end());\n        Polygon ch(2*n);\n        int k = 0;\n        rep(i, n){\n            while(k>1 && le((ch[k-1]-ch[k-2])^(p[i]-ch[k-1]), 0)) --k;\n            ch[k++] = p[i];\n        }\n        for(int i=n-2, t=k; i>=0; --i){\n            while(k>t && le((ch[k-1]-ch[k-2])^(p[i]-ch[k-1]), 0)) --k;\n            ch[k++] = p[i];\n        }\n        ch.resize(k-1);\n        return ch;\n    }\n\n    pair<real_num, pii> farthest_pair(Polygon &p){\n        int n = p.size();\n        if(n == 2){\n            return {abs(p[0]-p[1]), {0, 1}};\n        }\n        int i = 0, j = 0;\n        rep(k, n){\n            if(le(p[k].x, p[i].x)) i = k;\n            if(ge(p[k].x, p[j].x)) j = k;\n        }\n        real_num d = 0;\n        int a = i, b = j, si = i, sj = j;\n        while(i != sj || j != si){\n            if(chmax(d, abs(p[i]-p[j]))) a = i, b = j;\n            if(le((p[(i+1)%n]-p[i]) ^ (p[(j+1)%n]-p[j]), 0)){\n                i = (i+1) % n;\n            }\n            else j = (j+1) % n;\n        }\n        return {d, {a, b}};\n    }\n\n    int has_intersection_cc(Point c1, real_num r1, Point c2, real_num r2){\n        if(r1 < r2){\n            swap(c1, c2);\n            swap(r1, r2);\n        }\n        real_num d = abs(c1-c2), r = r1 + r2;\n        if(ge(d, r)) return 4;\n        if(eq(d, r)) return 3;\n        if(eq(d+r2, r1)) return 1;\n        if(le(d+r2, r1)) return 0;\n        return 2;\n    }\n\n    bool has_intersection_cl(Point c, real_num r, Point a, Vec v){\n        return leq(distance_lp(a, v, c), r);\n    }\n\n    bool has_intersection_cs(Point c, real_num r, Point a, Point b){\n        return leq(distance_sp(a, b, c), r) && geq(max(abs(a-c), abs(b-c)), r);\n    }\n\n    Points intersection_cl(Point c, real_num r, Point a, Vec v){   \n        Points ps;\n        if(!has_intersection_cl(c, r, a, v)) return ps;\n        Point p = proj(a, v, c);\n        real_num t = sqrt(max((real_num)0.0, (r*r-norm(p-c)) / norm(v)));\n        ps.push_back(p + v*t);\n        if(!eq(t, 0)) ps.push_back(p - v*t);\n        return ps;\n    }\n\n    Points intersection_cc(Point c1, real_num r1, Point c2, real_num r2){\n        Points ps;\n        Vec v = c2-c1, w = {v.y*-1, v.x};\n        real_num d = abs(v);\n        real_num x = (d*d + r1*r1 - r2*r2) / (2*d);\n        real_num y = sqrt(max(r1*r1-x*x, (real_num)0.0));\n        ps.push_back(c1 + v*x/d + w*y/d);\n        if(has_intersection_cc(c1, r1, c2, r2)!=2) return ps;\n        ps.push_back(c1 + v*x/d - w*y/d);\n        return ps;\n    }\n\n    real_num commn_area_cc(Point c1, real_num r1, Point c2, real_num r2){\n        int flag = has_intersection_cc(c1, r1, c2, r2);\n        if(flag >= 3) return 0;\n        if(flag <= 1){\n            real_num r = min(r1, r2);\n            return PI*r*r;\n        }\n        real_num d = abs(c1-c2);\n        real_num ret = 0;\n        rep(i, 2) {\n            real_num x = (d*d + r1*r1 - r2*r2) / (2*d);\n            real_num t = acos(x/r1)* 2;\n            ret += (t-sin(t))*r1*r1/2;\n            swap(c1, c2);\n            swap(r1, r2);\n        }\n        return ret;\n    }\n\n    Points tangent(Point c, real_num r, Point p){\n        Points ps;\n        real_num d = abs(p-c);\n        real_num t = acos(r/d);\n        ps.push_back(c + rot(p-c, t)*r/d);\n        ps.push_back(c + rot(p-c, -t)*r/d);\n        return ps;\n    }\n\n    Points common_tangent(Point c1, real_num r1, Point c2, real_num r2){       \n        Points ps;\n        int flag = has_intersection_cc(c1, r1,c2, r2);\n        if(flag >= 2){\n            real_num d = abs(c2-c1);\n            real_num t = acos(abs(r1-r2)/d);\n            if(le(r1, r2)) t = PI-t;\n            ps.push_back(c1 + rot(c2-c1, t)*r1/d);\n            ps.push_back(c1 + rot(c2-c1, -t)*r1/d);\n        }\n        if(flag == 4){\n            real_num d = abs(c2-c1);\n            real_num L = d*r1/(r1+r2);\n            real_num t = acos(r1/L);\n            ps.push_back(c1 + rot(c2-c1, t)*r1/d);\n            ps.push_back(c1 + rot(c2-c1, -t)*r1/d);\n        }\n        if(flag == 3 || flag == 1){\n            Polygon tg = intersection_cc(c1, r1, c2, r2);\n            ps.push_back(tg[0]);\n        }\n        return ps;\n    }\n\n    Point get_o(Point a, Point b, Point c){\n        Point M = (a+b)/2, N = (a+c)/2;\n        Vec v = {-(b-a).y, (b-a).x}, w = {-(c-a).y, (c-a).x};\n        return intersection_ll(M, v, N, w);\n    }\n\n    Point get_i(Point a, Point b, Point c){\n        real_num A = abs(b-c), B = abs(c-a), C = abs(a-b);\n        return (a*A+b*B+c*C)/(A+B+C);\n    }\n\n    Point get_h(Point a, Point b, Point c){\n        Vec v = {-(c-b).y, (c-b).x}, w = {-(c-a).y, (c-a).x};\n        return intersection_ll(a, v, b, w);\n    }\n\n    pair<Point, real_num> minimum_bounding_circle(Points &p){\n        Point C;\n        real_num r;\n        if(p.size() == 1) C = p[0], r = 0;\n        else if(p.size() == 2) C = (p[0]+p[1])/2, r = abs(p[0]-C);\n        else{\n            r = INF;\n            Points ch = convex_hull(p);\n            int K = ch.size();\n            auto check = [&](Point tc, real_num tr){\n                rep(i, K){\n                    if(ge(abs(ch[i]-tc), tr)) return false;\n                }\n                return true;\n            };\n            rep(i, K)For(j, i+1, K){\n                Point tc = (ch[i]+ch[j])/2;\n                real_num tr = abs(ch[i]-tc);\n                if(check(tc, tr) && chmin(r, tr)) C = tc;\n                For(k, j+1, K){\n                    int ccw_flag = ccw(ch[i], ch[j], ch[k]);\n                    if(ccw_flag != CCW_COUNTER_CLOCKWISE && ccw_flag != CCW_CLOCKWISE) continue;\n                    tc = get_o(ch[i], ch[j], ch[k]);\n                    tr = abs(ch[i]-tc);\n                    if(check(tc, tr) && chmin(r, tr)) C=tc;\n                }\n            }\n        }\n        return {C, r};\n    }\n}\n\nusing namespace geo;\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    Polygon p(n);\n    rep(i, n) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n    printf(\"%.10lf\\n\", farthest_pair(p).fi);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define FOREACH(i,Itr) for(auto (i)=(Itr).begin();(i)!=(Itr).end();(i)++)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define PB_VEC(Itr1,Itr2) (Itr1).insert((Itr1).end(),(Itr2).begin(),(Itr2).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\n#define EPS 1.0e-8\n#define MOD 1000000007\ntypedef long long ll;\n\nstruct Point {\n    double x,y;\n    Point(){}\n    Point(double _x, double _y):x(_x),y(_y){}\n    bool operator < (const Point &a) const {\n        return (x==a.x) ? (y<a.y) : (x<a.x);\n    }\n};\nPoint operator +(const Point &a,const Point &b){return Point(a.x+b.x,a.y+b.y);}\nPoint operator -(const Point &a,const Point &b){return Point(a.x-b.x,a.y-b.y);}\nPoint operator *(const Point &a,double k){return Point(a.x*k,a.y*k);}\n\nstruct Segment {\n    Point p1,p2;\n    Segment(){}\n    Segment(Point _p1, Point _p2):p1(_p1),p2(_p2){}\n    Segment(double x1, double y1, double x2, double y2)\n    :p1(Point(x1,y1)),p2(Point(x2,y2)){}\n};\n\nstruct Circle {\n    Point c; double r;\n    Circle(){}\n    Circle(Point _c, double _r):c(_c),r(_r){}\n    Circle(double x, double y, double _r):c(Point(x,y)),r(_r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){return a.x*b.x + a.y*b.y;}\ndouble cross(Vector a, Vector b){return a.x*b.y - a.y*b.x;}\ndouble norm(Vector a){return sqrt(dot(a,a)*dot(a,a));}\ndouble size(Vector a){return sqrt(norm(a));}\ndouble size(Segment s){return size(s.p1 - s.p2);}\ndouble arg(Vector p){return atan2(p.y,p.x);}\n\nPoint Project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint Reflect(Segment s, Point p) {\n    return p + (Project(s,p) - p) * 2.0;\n}\n\ndouble DistanceLinePoint(Line s, Point p) {\n    Vector dist = Project(s,p) - p;\n    return sqrt(norm(dist));\n}\n\ndouble DistanceSegmentPoint(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p -s.p1)<0.0)return sqrt(norm(p - s.p1));\n    if(dot(s.p1 - s.p2, p -s.p2)<0.0)return sqrt(norm(p - s.p2));\n    return DistanceLinePoint(s,p);\n}\n\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = 2;\nconst int ON_SEGMENT = 0;\nint CounterClockwise(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b)>0)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<0)return CLOCKWISE;\n    if(dot(a,b)<0)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool Intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (CounterClockwise(p1,p2,p3) * CounterClockwise(p1,p2,p4) <= 0 &&\n            CounterClockwise(p3,p4,p1) * CounterClockwise(p3,p4,p2) <= 0);\n}\n\nbool Intersect(Segment s1, Segment s2) {\n    return Intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint CrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1+d2);\n    return s1.p1 + (s1.p2-s1.p1) * t;\n}\n\nPolygon ConvexHull(vector<Point> pos) {\n    int n = (int)pos.size(), k = 0;\n    sort(pos.begin(),pos.end());\n    Polygon ch(2*n);\n    for(int i=0;i<n;ch[k++]=pos[i++])\n        while(k>=2 && CounterClockwise(ch[k-2],ch[k-1],pos[i])<=0)--k;\n    for(int i=n-2,t=k+1;i>=0;ch[k++]=pos[i--])\n        while(k>=t && CounterClockwise(ch[k-2],ch[k-1],pos[i])<=0)--k;\n    ch.resize(k-1);\n    return ch;\n}\n\ndouble ConvexDiameter(Polygon &pos) {\n    int n = (int)pos.size();\n    int is = 0, js = 0;\n    for(int i=1;i<n;++i) {\n        if (pos[i].y > pos[is].y) is = i;\n        if (pos[i].y < pos[js].y) js = i;\n    }\n    double maxd = norm(pos[is]-pos[js]);\n    \n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if(cross(pos[(i+1)%n]-pos[i],pos[(j+1)%n]-pos[j])>=0)j=(j+1)%n;\n        else i=(i+1)%n;\n        if(norm(pos[i]-pos[j]) > maxd) {\n            maxd = norm(pos[i]-pos[j]);\n            maxi = i; maxj = j;\n        }\n    }while(i!=is || j!=js);\n    return sqrt(maxd);\n}\n\n\nint main(){\n    \n    vector<Point> pos;\n    int n; cin>>n;\n    REP(i,n){\n        Point t; cin>>t.x>>t.y;\n        pos.push_back(t);\n    }\n    \n    Polygon ans = ConvexHull(pos);\n    cout<<fixed<<setprecision(10)<<ConvexDiameter(pos)<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include <bits/stdc++.h>\nusing namespace std;\n//types\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//input\nbool SR(int &_x){return scanf(\"%d\",&_x)==1;}bool SR(ll &_x){return scanf(\"%lld\",&_x)==1;}\nbool SR(double &_x){return scanf(\"%lf\",&_x)==1;}bool SR(char *_s){return scanf(\"%s\",_s)==1;}\nbool RI(){return true;}\ntemplate<typename I,typename... T>bool RI(I &_x,T&... _tail){return SR(_x) && RI(_tail...);}\n//output\nvoid SP(const int _x){printf(\"%d\",_x);}void SP(const ll _x){printf(\"%lld\",_x);}\nvoid SP(const double _x){printf(\"%.16lf\",_x);}void SP(const char *s){printf(\"%s\",s);}\nvoid PL(){puts(\"\");}\ntemplate<typename I,typename... T>void PL(const I _x,const T... _tail)\n{SP(_x);if(sizeof...(_tail)) putchar(' ');PL(_tail...);}\n//macro\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=int(b);i++)\n#define PER1(i,a,b) for(int i=(a);i>=int(b);i--)\n#define pb push_back\n#define mkp make_pair\n#define F first\n#define S second\n//debug\n#ifdef darry140\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const pair<A,B> &_p){return _s<<\"(\"<<_p.F<<\",\"<<_p.S<<\")\";}\ntemplate<typename It>\nostream& _OUTC(ostream &_s,It _b,It _e)//container\n{\n    _s<<\"{\";\n    for(auto _it=_b;_it!=_e;_it++) _s<<(_it==_b?\"\":\" \")<<*_it;\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const map<A,B> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const set<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const vector<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename I>\nvoid _DOING(const char *_s,I&& _x){cerr<<_s<<\"=\"<<_x<<endl;}//without ','\ntemplate<typename I,typename... T>\nvoid _DOING(const char *_s,I&& _x,T&&... _tail)//with ','\n{\n    int _c=0;\n    static const char _bra[]=\"({[\";\n    static const char _ket[]=\")}]\";\n    while(*_s!=',' || _c!=0)//eg. mkp(a,b)\n    {\n        if(strchr(_bra,*_s)) _c++;\n        if(strchr(_ket,*_s)) _c--;\n        cerr<<*_s++;\n    }\n    cerr<<\"=\"<<_x<<\", \";\n    _DOING(_s+1,_tail...);\n}\n#define debug(...) do{\\\n    fprintf(stderr,\"%s:%d - \",__PRETTY_FUNCTION__,__LINE__);\\\n    _DOING(#__VA_ARGS__,__VA_ARGS__);\\\n}while(0)\n#else\n#define debug(...)\n#endif\n//}}}\ntypedef long double ld;\nconst ld global_eps=1e-8;\n#if 0\nenum cases{insi,bord,outs};//inside, border, outside\nenum cases{para,coin,inte};//parallel, coincide, intersect\n#else\nenum Case\n{\n    insi,bord,outs,//inside, border, outside\n    para,coin,inte, //parallel, coincide, intersect\n    tang,tang_in,tang_out //tangent\n};\n#endif\nint sign(ld x,ld eps=global_eps){return (x>=eps)-(x<=-eps);}\nint cmp(ld a,ld b,ld eps=global_eps){return sign(a-b,eps);}\nstruct Point\n{\n    ld x,y;\n    Point():x(0),y(0){}\n    Point(ld _x,ld _y):x(_x),y(_y){}\n    Point operator +(const Point &p) const\n    {return Point(x+p.x,y+p.y);}\n    Point operator -(const Point &p) const\n    {return Point(x-p.x,y-p.y);}\n    ld operator *(const Point &p) const\n    {return x*p.x+y*p.y;}\n    ld operator %(const Point &p) const\n    {return x*p.y-y*p.x;}   \n    bool operator <(const Point &p) const\n    {return tie(y,x) < tie(p.y,p.x);}\n    bool operator ==(const Point &p) const\n    {return tie(y,x) == tie(p.y,p.x);}\n    Point operator /(const ld &l) const\n    {return Point(x/l,y/l);}\n    Point operator *(const ld &l) const\n    {return Point(x*l,y*l);}\n    ld len() const{return hypot(x,y);}\n    ld len2() const{return x*x+y*y;}\n    ld dis(const Point &a)const{return (*this-a).len();}\n    ld dis2(const Point &a)const{return (*this-a).len2();}\n    Point unit()const{return *this/len();}\n    Point resize(const ld &l)const{return unit()*l;}\n};\nstruct Line\n{\n    Point p1,p2;\n    Line(){}\n    Line(Point a,Point b):p1(a),p2(b){}\n    Point way() const{return p2-p1;}\n    Point norm() const{return {p1.y-p2.y,p2.x-p1.x};}\n    bool online(const Point &p) const{return sign((p-p1)%way())==0;}\n    bool onsegment(const Point &p)const\n    {\n        return online(p) && sign((p-p1)*(p2-p))>=0;\n    }\n    pair<int,Point> intersect(const Line &I) const\n    {\n        if(sign(I.way()%way())==0) return {online(I.p1)?coin:para,{0,0}};\n        const Point &p3=I.p1,&p4=I.p2;\n        auto _143=(p1-p4)%(p4-p3),_342=(p3-p4)%(p4-p2);\n        return {inte,(p1*_342+p2*_143)/(_143+_342)};\n    }\n    ld linedistance(const Point &p) const\n    {\n        return abs((p-p1)%way())/way().len();\n    }\n    Point project(const Point &p) const\n    {\n        return intersect(Line(p,p+norm())).second;\n    }\n    ld segmentdistance(const Point &p) const\n    {\n        const auto &pro=project(p);\n        if(onsegment(pro)) return p.dis(pro);\n        return min(p.dis(p1),p.dis(p2));\n    }\n};\nint main()\n{\n    int n;RI(n);\n    vector<Point> v(n);\n    REP(i,n)\n    {\n        double x,y;RI(x,y);\n        v[i]=Point(x,y);\n    }\n    vector<Point> v2(v);\n    v2.insert(v2.end(),ALL(v));\n    auto it=v2.begin()+1;\n    ld ans=0;\n    REP(i,n)\n    {\n        while(next(it)!=v2.end() && cmp(v[i].dis(*it),v[i].dis(*next(it))) < 0) it++;\n        debug(i,it-v2.begin());\n        ans=max(ans,v[i].dis(*it));\n    }\n    PL((double)ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\n\nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  if(n<100){\n    double res=0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tres=max(res,abs(p[i]-p[j]));\n    return res;\n  }\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i].x<p[k].x) i=k;\n    if(p[j].x>p[k].x) j=k;\n  }\n  //cout<<i<<\" \"<<j<<endl;\n  double res=0;\n  int si=i,sj=j;\n  do{\n    //cout<<i<<\" \"<<j<<endl;\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+i)%n]-p[i],p[(j+1)%n]-p[j])<0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }while(i!=si||j!=sj);\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int i = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int j = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int maxi, maxj;\n    LD maxd = 0;\n    for(; i < 2*n; i++){\n        if(maxd < norm(cpol[i]-cpol[j])){\n            maxd = norm(cpol[i] - cpol[j]);\n            maxi = i;\n            maxj = j;\n        }\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) <= 0) j = (j+1) % n;\n        else i = (i+1) % n; \n    }\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n    pair<int, int> ans = ConvexPolygonDiameter(p);\n    printf(\"%.9Lf\\n\", DistPP(p[ans.first], p[ans.second]));\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC opmize(2)\n#pragma GCC opmize(2)\n#include<bits/stdc++.h>\n#define mem(a) memset(a, 0, sizeof a)\n#define Buff ios::sync_with_stdio(false)\nusing namespace std;\n\nconst double INF = 1e9+7;\nconst int N = 1e5+7;\nconst double PI = acos(-1);\nconst double eps = 1e-8;\nint dcmp(double x)\n{\n    if(fabs(x) < eps)   return 0;\n    return x < 0 ? -1 : 1;\n}\n//直线，向量\nstruct Point\n{\n    double x;\n    double y;\n    void read() {scanf(\"%lf%lf\", &x, &y);}\n    void out()  {printf(\"(%.6lf, %.6lf)\\n\", x, y);}\n    Point(double x=0, double y=0):x(x), y(y) {}\n};\ntypedef Point Vector;\ndouble operator * (Vector v, Vector w)                   {return v.x*w.x+v.y*w.y;}//点乘\ndouble operator ^ (Vector v, Vector w)                   {return v.x*w.y-v.y*w.x;}//叉乘\nVector operator + (Vector v, Vector w)                   {return Vector(v.x+w.x, v.y+w.y);}\nVector operator - (Point A, Point B)                     {return Vector(A.x-B.x, A.y-B.y);}\nVector operator * (Vector v, double k)                   {return Vector(v.x*k, v.y*k);}\nVector operator / (Vector v, double k)                   {return Vector(v.x/k, v.y/k);}\nbool operator < (const Point & A, const Point & B)       {return A.y < B.y || (A.x == B.x && A.y < B.y);}\nbool operator == (const Point & A, const Point & B)      {return !dcmp(A.x-B.x) && !dcmp(A.y-B.y);}\ndouble length(Vector v)                                  {return sqrt(v*v);}\ndouble sqr(Vector v)                                     {return v*v;}\nPoint p[N], sta[N];\nint n, top;\nbool cmp(Point a, Point b)\n{\n    double t = (a - p[0]) ^ (b - p[0]);\n    if(t < 0)   return false;\n    if(!t && length(a - p[0]) > length(b - p[0]))   return false;\n    return true;\n}\nvoid graham()\n{\n    sort(p + 1, p + n, cmp);\n    int t = n - 1;\n    while(!((p[n-1] - p[0]) ^ (p[t] - p[0]))) t --;\n    reverse(p + t + 1, p + n);\n    sta[top ++] = p[0]; sta[top ++] = p[1]; p[n ++] = p[0];\n    for(int i = 2; i < n; i ++)\n    {\n        while(top > 1 && dcmp((sta[top-1] - sta[top-2]) ^ (p[i] - sta[top-2])) <= 0)     top --;\n        sta[top ++] = p[i];\n    }\n    top --;\n}\ndouble diame()\n{\n    int i, j, k;\n    double res, t;\n    graham();\n    sta[top] = sta[0], res = 0.0, j = 1;\n    for(int i = 0; i < top; i ++)\n    {\n        while(dcmp(fabs((sta[i] - sta[j]) ^ (sta[i+1] - sta[j])) - fabs((sta[i] - sta[j+1]) ^ (sta[i+1] - sta[j+1]))) < 0)\n            j = (j + 1) % top;\n        t = sqr(sta[i] - sta[j]);\n        if(dcmp(t - res) > 0)    res = t;\n    }\n    return sqrt(res);\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++)\n    {\n        double a, b;\n        scanf(\"%lf %lf\", &a, &b);\n        p[i] = {a, b};\n        if(p[i] < p[0]) swap(p[i], p[0]);\n    }\n    printf(\"%.8f\\n\", diame());\n//    int x, y;\n//    graham();\n//    double t, res = 0;\n//    for(int i = 0; i < top; i++)\n//        for(int j = 0; j < top; j ++)\n//        {\n//            t = sqr(sta[i] - sta[j]);\n//            if(dcmp(t - res) > 0)\n//            {\n//                res = t;\n//                x = i, y = j;\n//            }\n//        }\n//    printf(\"%.8f\\n\", sqrt(res));\n//    printf(\"%d %d\\n\", x, y);\n//    printf(\"%.8f\\n\", sqrt(sqr(sta[x] - sta[y])));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\ndouble cross(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\ndouble dist(const Point &p1, const Point &p2)\n{\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint main()\n{\n    int i, n;\n    double *X, *Y;\n    scanf(\"%d\", &n);\n    assert(n >= 3);\n\n    X = new double [n + 1];\n    Y = new double [n + 1];\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &X[i], &Y[i]);\n    }\n    X[n] = X[0], Y[n] = Y[0];\n    Point *Plg;\n    Plg = new Point [n + 1];\n    for(i = 0; i < n; i++){\n        Plg[i] = set_p(X[i], Y[i]);\n    }\n    Plg[n] = Plg[0];\n\n    int top = 1;\n    double diam = 0;\n\n    for(i = 0; i < n; i++){\n        while(cross(set_v(Plg[i], Plg[i + 1]), set_v(Plg[top], Plg[top + 1])) > 0){\n            top++; if(top > n - 1) top -= n;\n        };\n        diam = max(diam, max(dist(Plg[i], Plg[top]), dist(Plg[i + 1], Plg[top])));\n    }\n    printf(\"%f\\n\", diam);\n    cin >> n;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n// Definiciones iniciales.\ntypedef long double Double;\ntypedef long long Long;\ntypedef pair<int, int> pii;\n\nconst Double INF = 1ll << 60;\nconst Double ERROR = 1e-9;\nconst Double M_2PI = 2.0 * M_PI;\n\n// Tolerancia a flotantes\n#define EQ(a, b) (fabs((a) - (b)) < ERROR)\n\n// Punto en 2D.\nstruct Punto {\n\tDouble x, y;\n\tPunto() : x(), y() {}\n\tPunto(Double X, Double Y) : x(X), y(Y) {}\n\t// Izquierda a derecha, abajo a arriba.\n\tbool operator<(const Punto& q) const {\n\t\tif (!EQ(x, q.x)) return x < q.x;\n\t\treturn EQ(y, q.y)? false: y < q.y;\n\t}\n\tbool operator==(const Punto& q) const {\n\t\treturn EQ(x, q.x) && EQ(y, q.y);\n\t}\n\n\t//Sumar los vectores actual y q.\n\tPunto operator +(const Punto& p)const { return Punto(x+p.x, y+p.y); }\n\t//Restar los vectores (o trasladarlos), tomando p como el origen.\n\tPunto operator -(const Punto& p)const { return Punto(x-p.x, y-p.y); }\n\t//Obtener el vector opuesto.\n\tPunto operator -() const { return Punto(-x, -y); }\n\t//Obtener el vector por un escalar.\n\tPunto operator*( Double c ) const { return Punto( x*c, y*c ); }\n\t//Obtener el vector dividido por un escalar.\n\tPunto operator/( Double c ) const { return Punto( x/c, y/c ); }\n\t//Magnitud del vector.\n\tDouble Abs() const { return hypot(x, y); }\n\t//Magnitud elevada al cuadrado del vector.\n\tDouble Norm() const{ return x*x + y*y; }\n\t//Distancia entre el punto actual y q.\n\tDouble Dist( const Punto& q ) const { return (*this - q ).Abs(); }\n\t//Distancia elevada al cuadrado entre el punto actual y q.\n\tDouble Dist2(const Punto& q ) const { return ( *this - q).Norm(); }\n\t//Producto punto entre el punto actual y q.\n\tDouble Dot( const Punto& q ) const { return x*q.x + y*q.y; }\n\t//Producto cruz entre el punto actual y q.\n\tDouble Cruz( const Punto& q ) const { return x*q.y - y*q.x; }\n\n\t//Rotar 90 grados en CCW.\n\tPunto rot90() const { return Punto(-y, x); }\n\n\t//Rotar t radianes en cw respecto al origen.\n\tPunto RotarCW(const Double& t) const {\n\t\treturn Punto( x*cos(t) + y*sin(t),\n\t\t\t\t\t\ty*cos(t) - x*sin(t));\n\t}\n\t//Rotar t radianes en ccw respecto al origen.\n\tPunto RotarCCW(const Double& t) const {\n\t\treturn Punto( x*cos(t) - y*sin(t), \n\t\t\t\t\t\ty*cos(t) + x*sin(t));\n\t}\n};\n\n//Conversion de grados a radianes.\nDouble GradARad(Double grd) {\n\treturn (grd * M_PI) / 180.0;\n}\n\n// Conversion de radianes a grados.\nDouble RadAGrad(Double rad) {\n\treturn (rad * 180.0) / M_PI;\n}\n\n//Angulo mas chico formado por los puntos aob en radianes.\nDouble Angulo(const Punto& a, const Punto& o, const Punto& b){\n\tPunto u(a - o), v(b - o);\n\treturn acos( u.Dot(v) / (u.Abs() * v.Abs()));\n}\n\n// Test de mano derecha: CCW = 1, CW = -1, Colineal = 0.\nint ManoDerecha(const Punto& o, const Punto& p, const Punto& q) {\n\tDouble ccw = (p-o).Cruz(q-o);\n\treturn EQ(ccw, 0)? 0: (ccw < 0)? -1: 1;\n}\n\n// Par de puntos mas cercanos en un conjunto de puntos P.\npair<Punto, Punto> ParMasCercano(vector<Punto> P) {\n\t// Si ya esta ordenado, no usar sort.\n\tsort(P.begin(), P.end());\n\n\tset<Punto> rect;\n\tpair<Punto, Punto> par;\n\tint prev = 0; Double delta = 1e9;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\twhile (P[i].x - P[prev].x > delta)\n\t\t\trect.erase(Punto(P[prev].y, P[prev].x)), prev++;\n\n\t\tset<Punto>::iterator it = rect.lower_bound(\n\t\t\tPunto(P[i].y - delta, P[0].x));\n\n\t\tfor (; it != rect.end() && it->x <= P[i].y + delta; ++it) {\n\t\t\tDouble dist = hypot(P[i].x - it->y, P[i].y - it->x);\n\t\t\tif (dist < delta) delta = dist, par = make_pair(\n\t\t\t\tPunto(it->y, it->x), P[i]);\n\t\t}\n\t\trect.insert(Punto(P[i].y, P[i].x));\n\t}\n\treturn par; // Alternativamente puede devolver delta.\n}\n// Linea en 2D.\nstruct Linea {\n\tPunto p, q;\n\tDouble a, b, c;\n\tLinea() : p(), q(), a(), b(), c() {}\n\tLinea(Long A, Long B, Long C)\n\t\t: p(), q(), a(A), b(B), c(C) {\n\t\tif (EQ(a, 0)) {\n\t\t\tc /= -b; b = -1;\n\t\t\tp = Punto(0, c);\n\t\t\tq = Punto(1, c);\n\t\t} else if (EQ(b, 0)) {\n\t\t\tc /= -a; a = -1;\n\t\t\tp = Punto(c, 0);\n\t\t\tq = Punto(c, 1);\n\t\t} else {\n\t\t\tp = Punto(-c/a, 0);\n\t\t\tq = Punto(-(b+c)/a, 0);\n\t\t} if (q < p) swap(p, q);\n\t}\n\tLinea(const Punto& P, const Punto& Q)\n\t\t: p(P), q(Q), a(), b(), c() {\n\t\t// Asegura p como punto menor.\n\t\tif (q < p) swap(p, q);\n\t\ta = q.y - p.y;\n\t\tb = p.x - q.x;\n\t\tif (!a) c = p.y, b = -1;\n\t\telse if (!b) c = p.x, a = -1;\n\t\telse c = -a*p.x - b*p.y;\n\t}\n\t// PELIGRO! Ordena por ecuacion de recta.\n\tbool operator<(const Linea& cmp) const {\n\t\tif (!EQ(a, cmp.a)) return a < cmp.a;\n\t\tif (!EQ(b, cmp.b)) return b < cmp.b;\n\t\treturn EQ(c, cmp.c)? false: c < cmp.c;\n\t}\n};\n\n// Saber si un punto p esta en la recta r.\nbool PuntoEnRecta(const Punto& p, const Linea& r){\n\treturn !ManoDerecha( r.p, r.q, p );\n}\n// Saber si un punto p esta en el segmento s.\nbool PuntoEnSegmento(const Punto& p, const Linea& s) {\n\treturn PuntoEnRecta(p, s) && !(p < s.p || s.q < p);\n}\n\n// Saber si dos lineas l y m son paralelas.\nbool LineasParalelas(const Linea& l, const Linea& m) {\n\treturn EQ( 0, ( l.q - l.p ).Cruz( m.q - m.p ) );\n}\n\n// Saber si dos lineas l y m son iguales.\nbool LineasIguales(const Linea& l, const Linea& m) {\n\treturn LineasParalelas(l, m)\n\t\t&& EQ( 0, ( l.p - l.q ).Cruz( l.p - m.q ) )\n\t\t&& EQ( 0, ( m.q - m.p ).Cruz( m.q - l.p ) );\n}\n// Saber si dos lineas l y m son perpendiculares.\nbool LineasPerpendiculares(const Linea& l, const Linea& m) {\n\treturn EQ( 0, ( l.q - l.p ).Dot( m.q - m.p ) );\n}\n\n// Obtener una linea paralela a l que pase por p.\nLinea ParalelaEnPunto(const Linea& l, const Punto& p) {\n\treturn Linea(p, p + ( l.q - l.p ));\n}\n\n// Obtener una linea perpendicular a l que pase por p.\nLinea PerpendicularEnPunto(const Linea& l, const Punto& p) {\n\treturn Linea(p, p + ( l.q - l.p ).rot90());\n}\n\n// Saber si dos rectas r y s se intersectan.\n// No intersectan = 0, Interseccion en un punto = 1,\n// Interseccion paralela en infinitos puntos = -1.\nint InterseccionRectas(const Linea& r, const Linea& s) {\n\tif (LineasIguales(r, s)) return -1;\n\treturn LineasParalelas(r, s)? 0: 1;\n}\n\n// Saber si una recta r y un segmento s se intersectan.\n// No intersectan = 0, Interseccion en un punto = 1,\n// Interseccion paralela en infinitos puntos = -1.\nint IntersecRectaSegmen(const Linea& r, const Linea& s) {\n\tif (LineasIguales(r, s)) return -1;\n\tif (LineasParalelas(r, s)) return 0;\n\tint t1 = ManoDerecha(r.p, r.q, s.p);\n\tint t2 = ManoDerecha(r.p, r.q, s.q);\n\treturn (t1 != t2)? 1: 0;\n}\n\n// Saber si dos segmentos s y t se intersectan.\n// No intersectan = 0, Interseccion en un punto = 1,\n// Interseccion paralela en infinitos puntos = -1.\nint InterseccionSegmentos(const Linea& s, const Linea& t) {\n\tint t1 = ManoDerecha(s.p, s.q, t.p);\n\tint t2 = ManoDerecha(s.p, s.q, t.q);\n\n\tif (t1 == t2) return t1? 0:\n\t\t(PuntoEnSegmento(s.p, t) ||\n\t\t PuntoEnSegmento(s.q, t) ||\n\t\t PuntoEnSegmento(t.p, s) ||\n\t\t PuntoEnSegmento(t.q, s))? -1: 0;\n\n\treturn (ManoDerecha(t.p, t.q, s.p) !=\n\t\t\tManoDerecha(t.p, t.q, s.q))? 1: 0;\n}\n\n// Obtener punto de interseccion entre lineas l y m.\nPunto PuntoInterseccion(const Linea& l, const Linea& m) {\n\tPunto a = l.p, b = l.q, c = m.p, d = m.q;\n\tb = b-a; d = c-d; c =c-a;\n\tassert( !LineasParalelas( l, m ) );\n\treturn a + b*(c.Cruz( d )/b.Cruz( d ));\n}\n// Obtener proyeccion del vector v en la recta r.\nPunto ProyeccionEnRecta(const Punto& v, const Linea& r) {\n\treturn r.p + ( r.q - r.p ) * \n\t\t\t(( v - r.p ).Dot( r.q - r.p )/( r.q  - r.p ).Norm());\n}\n\n// Distancia entre un punto p y una recta r.\nDouble DistanciaPuntoRecta(const Punto& p, const Linea& r) {\n\treturn p.Dist(ProyeccionEnRecta(p, r));\n}\n\n// Distancia entre un punto p y un segmento s.\nDouble DistanciaPuntoSegmento(const Punto& p, const Linea& s) {\n\tPunto proy = ProyeccionEnRecta(p, s);\n\tif (proy < s.p) return p.Dist(s.p);\n\tif (s.q < proy) return p.Dist(s.q);\n\treturn p.Dist(proy);\n}\n\n// Distancia entre dos lineas l y m.\nDouble DistanciaRectaRecta(const Linea& l, const Linea& m) {\n\treturn LineasParalelas(l, m)? DistanciaPuntoRecta(l.p, m): 0;\n}\n\n// Distancia entre dos segmentos s y r.\nDouble DistanciaSegmenSegmen(const Linea& s, const Linea& r) {\n\tif (InterseccionSegmentos(s, r)) return 0;\n\treturn min(min(DistanciaPuntoSegmento(s.p, r),\n\t\t\t\t\t DistanciaPuntoSegmento(s.q, r)),\n\t\t\t\t min(DistanciaPuntoSegmento(r.p, s),\n\t\t\t\t\t DistanciaPuntoSegmento(r.q, s)));\n}\n\n// Un poligono es una serie de\n// vertices conectados por aristas.\n// P = p1 -> p2 -> p3 -> ... -> pn -> p1.\ntypedef vector<Punto> Poligono;\n\n// Saber si un punto esta en el perimetro de un poligono.\nbool PuntoEnPerimetro(const Punto& p, const Poligono& P) {\n\tfor (int i = 1; i < P.size(); ++i) {\n\t\tif( PuntoEnSegmento( p, Linea( P[i-1], P[i] ) ) ) return true;\n\t}\n\treturn false;\n}\n\n// Prueba de punto en poligono convexo.\n// En el perimetro = -1, Fuera = 0, Dentro = 1.\nint PuntoEnConvexo(const Punto& p, const Poligono& P) {\n\tif (PuntoEnPerimetro(p, P)) return -1;\n\tint dir = ManoDerecha(P[0], P[1], p);\n\tfor (int i = 2; i < P.size(); ++i)\n\t\tif (ManoDerecha(P[i - 1], P[i], p)\n\t\t\t!= dir) return 0; // Fuera.\n\treturn 1; // Dentro.\n}\n\n\n// Punto en poligono concavo por ray casting.\n// En el perimetro = -1, Fuera = 0, Dentro = 1.\nint RayCasting(const Punto& p, const Poligono& P) {\n\tif (PuntoEnPerimetro(p, P)) return -1;\n\tPunto o = *min_element(P.begin(), P.end());\n\tLinea rayo(p, Punto(o.x - M_PI, o.y - M_E));\n\tint cruces = 0;\n\tfor (int i = 1; i < P.size(); ++i)\n\t\tif (InterseccionSegmentos(rayo,\n\t\t\tLinea(P[i - 1], P[i]))) ++cruces;\n\treturn cruces & 1;\n}\n\n// Punto en poligono concavo por angle summation.\n// En el perimetro = -1, Fuera = 0, Dentro = 1.\nint AngleSummation(const Punto& p, const Poligono& P) {\n\tif (PuntoEnPerimetro(p, P)) return -1;\n\tDouble angulo = 0;\n\tfor (int i = 1; i < P.size(); ++i)\n\t\tangulo += ManoDerecha(p, P[i - 1], P[i]) * Angulo(\n\t\t\tP[i - 1], p,P[i]);\n\treturn (fabs(angulo) > M_PI)? 1: 0;\n}\n\n// Area de un poligono.\nDouble Area(const Poligono& P) {\n\tDouble area = 0;\n\tfor (int i = 1; i < P.size(); ++i)\n\t\tarea += P[i - 1].Cruz(P[i]);\n\treturn fabs(area) / 2.0;\n}\n// Perimetro de un poligono.\nDouble Perimetro(const Poligono& P) {\n\tDouble perimetro = 0;\n\tfor (int i = 1; i < P.size(); ++i)\n\t\tperimetro += P[i].Dist(P[i - 1]);\n\treturn perimetro;\n}\n\n// Cerco convexo de un conjunto de puntos.\ntemplate<class It> Poligono CercoConvexo(It lo, It hi) {\n\tint k = 0;\n\tif (hi - lo <= 1) return Poligono(lo, hi);    \n\tPoligono H(2 * (int)(hi - lo));\n\tsort(lo, hi);\n\n\tfor (It it = lo; it != hi; ++it) {\n\t\twhile (k >= 2 && ManoDerecha(H[k - 2], H[k - 1], *it) < 1) k--;\n\t\tH[k++] = *it;\n\t}\n\tint t = k + 1;\n\tfor (It it = hi - 2; it != lo - 1; --it) {\n\t\twhile (k >= t && ManoDerecha(H[k - 2], H[k - 1], *it) < 1) k--;\n\t\tH[k++] = *it;\n\t}\n\tH.resize(k);\n\treturn H;\n}\n// Centroide de un poligono.\nPunto Centroide(const Poligono& P) {\n\tDouble x = 0, y = 0, k = 0;\n\tfor (int i = 1; i < P.size(); ++i) {\n\t\tDouble cruz = (P[i-1]).Cruz(P[i]);\n\t\tx += cruz * (P[i - 1].x + P[i].x);\n\t\ty += cruz * (P[i - 1].y + P[i].y);\n\t\tk += 3*cruz;\n\t}\n\treturn Punto(x/k, y/k);\n}\n\n// Saber si una recta corta un poligono.\nbool RectaCortaPoligono(\n\tconst Linea& r, const Poligono& P) {\n\tfor (int i = 0, prim = 0; i < P.size(); ++i) {\n\t\tint lado = ManoDerecha(r.p, r.q, P[i]);\n\t\tif (!lado) continue; if (!prim) prim = lado;\n\t\telse if (lado != prim) return true;\n\t}\n\treturn false;\n}\n\n// Obtiene los poligonos resultantes de\n// cortar un poligono convexo con una recta.\nvector<Poligono> CortarPoligono(\n\tconst Poligono& P, const Linea& r) {\n\tif (!RectaCortaPoligono(r, P))\n\t\treturn vector<Poligono>(1, P);\n\tint ind = 0;\n\tvector<Poligono> Ps(2);\n\tfor (int i = 1; i < P.size(); ++i) {\n\t\tLinea s(P[i - 1], P[i]);\n\t\tif (IntersecRectaSegmen(r, s)) {\n\t\t\tPunto p = PuntoInterseccion(r, s);\n\t\t\tif (P[i - 1] == p) continue;\n\t\t\tPs[ind].push_back(P[i - 1]);\n\t\t\tPs[1 - ind].push_back(p);\n\t\t\tPs[ind].push_back(p);\n\t\t\tind = 1 - ind;\n\t\t}\n\t\telse Ps[ind].push_back(P[i - 1]);\n\t}\n\tPs[0].push_back(Ps[0][0]);\n\tPs[1].push_back(Ps[1][0]);\n\treturn Ps;\n}\n\n\n\n\n\n\n\n\n\n\n\n//Dado un poligono convexo, devuelve todos los pares antipodales en orden\nvector<pii> RotatingCalipers( Poligono &P ){\n\tint k = 1, i = P.size()-2, j = 0;\n\twhile( fabs( ( P[j] - P[i] ).Cruz( P[k+1] - P[i] ) ) > \n\t\tfabs( ( P[j] - P[i] ).Cruz( P[k] - P[i] )) ) k++;\n\n\ti = 0, j = k;\n\n\tvector< pii > res;\n\twhile( i <= k && j < P.size()-1 ){\n\t\tres.push_back( pii(i,j) );\n\t\twhile( j < P.size()-1 && fabs( ( P[i+1] - P[i] ).Cruz( P[j+1] - P[i] ) ) > \n\t\tfabs( ( P[i+1] - P[i] ).Cruz( P[j] - P[i] ) ) ){\n\t\t\tj++;\n\t\t\tres.push_back( pii( i, j ));\n\t\t}\n\t\ti++;\n\t}\n\treturn res;\n}\n\n//Para ancho de poligono\n// vector< pii> tmp = RotatingCalipers( pol );\n// tmp.insert(tmp.end(), tmp.begin(), tmp.end() );\n// Double res = INF;\n// for( int i = 0; i < tmp.size()-1; i++){\n//  if( tmp[i].first == tmp[i+1].first && tmp[i].second+1 == tmp[i+1].second ){\n//      res = min( res, DistanciaPuntoRecta( pol[tmp[i].first], Linea( pol[tmp[i].second], pol[tmp[i+1].second] ) ) );\n//  }\n// }\n\n// for( int i = 0; i < tmp.size()-1; i++){\n//  if( tmp[i].second == tmp[i+1].second && tmp[i].first+1 == tmp[i+1].first ){\n//      res = min( res, DistanciaPuntoRecta( pol[tmp[i].second], Linea( pol[tmp[i].first], pol[tmp[i+1].first] ) ) );\n//  }\n// }    \n\n\n// Circulo en 2D.\nstruct Circulo {\n\tPunto c; Double r; Circulo() : c(), r() {}\n\tCirculo(const Punto& C, Double R) : c(C), r(R) {}\n\n\tbool operator<(const Circulo& cmp) const {\n\t\tif (!(c == cmp.c)) return c < cmp.c;\n\t\treturn EQ(r, cmp.r)? false: r < cmp.r;\n\t}\n};\n\n// Circunferencia de un circulo.\nDouble Circuferencia(const Circulo& c) {\n\treturn M_2PI * c.r;\n}\n\n// Area de un circulo.\nDouble Area(const Circulo& c) {\n\treturn M_PI * c.r * c.r;\n}\n\n// Saber si un punto esta dentro de un circulo.\n// En circunferencia = -1, Fuera = 0, Dentro = 1.\nint PuntoEnCirculo(const Punto& p, const Circulo& c) {\n\tDouble dist = p.Dist(c.c);\n\tif (EQ(dist, c.r)) return -1;\n\treturn (dist < c.r)? 1: 0;\n}\n\n// Distancia de un punto p a un circulo c\nDouble DistanciaPuntoCirculo(const Punto& p, const Circulo& c) {\n\tDouble dist = p.Dist( c.c) - c.r;\n\treturn (dist < 0)? 0: dist;\n}\n\n// Proyecta un punto fuera de un circulo en su circunferencia.\nPunto ProyPuntoCircunferencia(const Punto& p, const Circulo& c) {\n\tPunto v = c.c - p;\n\tDouble prop = DistanciaPuntoCirculo(p, c) / v.Abs();\n\treturn p + v*prop;\n}\n\n\n\n\n// Obtiene dos puntos que, desde el punto p, forman\n// lineas tangentes a la circunferencia del circulo c.\nLinea ProyTangentes(const Punto& p, const Circulo& c) {\n\tDouble a = acos(c.r / p.Dist( c.c));\n\tPunto p_ = ProyPuntoCircunferencia(p, c) - c.c;\n\treturn Linea(c.c + p_.RotarCCW(a),\n\t\t\t\t c.c + p_.RotarCW(a) );\n}\n\n// Saber si se intersecta un circulo c y una recta r.\n// Tangente = -1, No se intersectan = 0, Cuerda = 1.\nint IntersecCirculoRecta(const Circulo& c, const Linea& r) {\n\tDouble dist = DistanciaPuntoRecta(c.c, r);\n\tif (EQ(dist, c.r)) return -1;\n\treturn (dist < c.r)? 1: 0;\n}\n\n// Cuerda de interseccion entre un circulo y una recta.\nvector<Punto> CuerdaInterseccion( const Circulo& c, const Linea& r ){\n\tvector<Punto> ret;\n\tPunto b = r.q - r.p, a = r.p - c.c;\n\tDouble A = b.Dot(b);\n\tDouble B = a.Dot(b);\n\tDouble C = a.Dot(a) - c.r*c.r;\n\tDouble D = B*B - A*C;\n\tif( D + ERROR < 0 ) return ret;\n\tret.push_back( c.c + a + b * ((-B+sqrt(D+ERROR)) / A) );\n\tif( D > ERROR )\n\t\tret.push_back( c.c + a + b * ((-B-sqrt(D)) / A) );\n\treturn ret;\n}\n\n// Saber si un circulo c esta dentro de un circulo d.\nbool CirculoEnCirculo(const Circulo& c, const Circulo& d) {\n\treturn c.c.Dist(d.c) < d.r - c.r;\n}\n\n// Saber si el circulo c intersecta con el circulo d.\n// Uno dentro del otro = -1, Disjuntos = 0, Intersectan = 1.\nint IntersecCirculoCirculo(const Circulo& c, const Circulo& d) {\n\tDouble dist = c.c.Dist(d.c);\n\tif (dist < fabs(c.r - d.r)) return -1;\n\treturn (dist > c.r + d.r)? 0: 1;\n}\n\n//Dados 3 puntos, calcula el centro del circulo que los contiene.\nPunto CalcularCentroCirculo( Punto a, Punto b, Punto c ){\n\tb = ( a + b ) * 0.5;\n\tc = ( a + c ) * 0.5;\n\treturn PuntoInterseccion( Linea( b, b + ( a-b ).RotarCW(M_PI/2.0)), Linea( c, c+(a-c).RotarCW( M_PI/2.0 ) ) );\n}\n\n\n\n\n\n\n//Puntos de interseccion entre 2 circulos dados.\n//Regresa un vector con los puntos.\nvector<Punto> InterseccionCirculoCirculo( const Circulo& C, const Circulo& D ){\n\tvector<Punto> ret;\n\tDouble d = ( C.c - D.c ).Abs();\n\tif( d > C.r + D.r || d + min( C.r, D.r ) < max( C.r, D.r ) ) return ret;\n\tDouble x = ( d*d - D.r*D.r + C.r*C.r ) / (2*d);\n\tDouble y = sqrt( C.r*C.r - x*x );\n\tPunto v = ( D.c - C.c )/d;\n\tret.push_back( C.c+v*x + v.rot90()*y );\n\tif( y > 0 )\n\t\tret.push_back( C.c+v*x - v.rot90()*y );\n\treturn ret;\n}\n\n// Obtiene tangentes exteriores (las que NO se cruzan) entre dos circulos.\nint TangenteExtCirculoCirculo(const Circulo& a, const Circulo& b, Linea &s, Linea &t) {\n\t// Circulos identicos. Tangentes infinitas (segun el problema).\n\tif ( EQ(a.r, b.r) && a.c == b.c) \n\t\treturn 0; // O etiqueta de caso especial.\n\t// Uno es circulo interior del otro. Comparten una tangente.\n\t// EL CALCULO PUEDE COPIARSE A TangenteInt SI SE REQUIERE.\n\tPunto u;\n\tbool unico = false;\n\tif (b.r < a.r && EQ(a.c.Dist(b.c) + b.r, a.r)) {\n\t\tu = a.c + (b.c-a.c) * (a.r / a.c.Dist(b.c));\n\t\tunico = true;\n\t}\n\tif (a.r < b.r && EQ(a.c.Dist(b.c) + a.r, b.r)) {\n\t\tu = b.c + (a.c-b.c)*(b.r / a.c.Dist(b.c));\n\t\tunico = true;\n\t}\n\tif (unico) {\n\t\ts = t = PerpendicularEnPunto(Linea(a.c, b.c), u); // Recta de tangencia; un punto es referencia.\n\t\t//s = t = Linea(u, u); // Punto de tangencia.\n\t\treturn 1;\n\t}\n\t// Circulo en circulo. No hay tangentes.\n\tif (CirculoEnCirculo(a, b) || CirculoEnCirculo(b, a)) \n\t\treturn 0;\n\n\t// Calcular las 2 rectas tangentes.\n\tLinea proy;\n\tPunto v;\n\tif (EQ(a.r, b.r)) {\n\t\tproy = Linea(a.c, a.c);\n\t\tLinea perp = PerpendicularEnPunto(Linea(a.c, b.c), a.c);\n\t\tu = (perp.p-perp.q)* (b.r / perp.p.Dist(perp.q)); \n\t\tv = -u;\n\t} else {\n\t\tCirculo c(a.c, fabs(a.r - b.r));\n\t\tproy = ProyTangentes(b.c, c);\n\t\tu = (proy.p-a.c)* (b.r / (a.r - b.r));\n\t\tv = (proy.q-a.c)* (b.r / (a.r - b.r));\n\t}\n\ts = Linea( proy.p+u, b.c+u);\n\tt = Linea( proy.q+v, b.c+v);\n\treturn 2;\n}\n\n\n// Obtiene tangentes interiores (las que SI se cruzan) entre dos circulos.\nint TangenteIntCirculoCirculo(const Circulo& a, const Circulo& b, Linea &s, Linea &t) {\n\t// Circulos identicos. Tangentes infinitas (segun el problema)\n\tif (EQ(a.r, b.r) && a.c == b.c) {\n\t\treturn 0; // O etiqueta de caso especial.\n\t}\n\t// Uno es circulo interior del otro. Comparten una tangente.\n\t// CALCULO HECHO EN TangenteInt. Copiar de este si se requiere.\n\tPunto u;\n\t// Circulos tangentes. Obtener recta tangente unica.\n\tif (EQ(a.c.Dist(b.c), a.r + b.r)) {\n\t\tu = b.c + (a.c-b.c) * (b.r / a.c.Dist(b.c));\n\t\ts = t = PerpendicularEnPunto(Linea(a.c, b.c), u); // Recta de tangencia.\n\t\t//s = t = Linea(u, u); // Punto de tangencia.\n\t\treturn 1;\n\t}\n\t// Circulos se traslapan. no hay tangentes.\n\tif (!(a.r + b.r < a.c.Dist(b.c))) {\n\t\treturn 0;\n\t}\n\t// Obtener 2 rectas tangentes.\n\tLinea proy;\n\tPunto v;\n\tCirculo c(a.c, a.r + b.r);\n\tproy = ProyTangentes(b.c, c);\n\tu = (proy.p - a.c) * (b.r / (a.r + b.r));\n\tv = (proy.q - a.c) * (b.r / (a.r + b.r));\n\ts = Linea( proy.p - u, b.c-u);\n\tt = Linea( proy.q - v, b.c-v);\n\treturn 2;\n}\n\nint main(){\n\tint N;\n\n\tcin >> N;\n\n\tPoligono pol(N);\n\tfor( int i = 0; i < N; i++ ){\n\t\tcin >> pol[i].x >> pol[i].y;\n\t}\n\n\tpol = CercoConvexo( pol.begin(), pol.end() );\n\tvector<pii> tmp = RotatingCalipers( pol );\n\n\tDouble distancia = 0.0;\n\tfor( int i = 0; i < tmp.size(); i++ ){\n\t\tdistancia = max( distancia, pol[tmp[i].first].Dist( pol[tmp[i].second] ) );\n\t}\n\tcout << fixed << setprecision( 7 ) <<distancia << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; vector<double> x, y;\n    \n    cin >> n;\n    \n    x = vector<double>(n);\n    y = vector<double>(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> x[i] >> y[i];\n    }\n    \n    double diameter = 0.0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            diameter = max(sqrt((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i])), diameter);;\n        }\n    }\n    \n    cout << diameter << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\n\tPoint operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n\tPoint operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n\tPoint operator*(const double m) const { return Point(x*m, y*m); }\n\n\tPoint operator/(const double d) const { return Point(x/d, y/d); }\n\n\tbool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nostream& operator << (ostream& os, const Point& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \")\";\n\treturn os;\n}\n\ndouble dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }\ndouble atan(Point p) { return atan2(p.y, p.x); }\ndouble norm(Point p) { return p.x * p.x + p.y * p.y; }\ndouble abs(Point p) { return sqrt(norm(p)); }\ndouble distancePP(Point p, Point o) { return sqrt(norm(o - p)); }\n\nint ccw(Point a, Point b, Point c) {\n\tb = b-a;\n\tc = c-a;\n\n\tif(cross(b, c) > 0.0) return +1;\t//conter clockwise\n\tif(cross(b, c) < 0.0) return -1;\t//clockwise\n\tif(dot(b, c) < 0.0) return +2;\t//a on Seg(b,c)\n\tif(norm(b) < norm(c)) return -2;\t//b on Seg(a,c)\n\treturn 0;\t//c on Seg(a,b)\n}\n\n// bool cmp_y(const Point& a,const Point& b) {\n// \tif(a.y != b.y) return a.y < b.y;\n// \treturn a.x < b.x;\n// }\n\nvector<Point> convex_hull(vector<Point> ps) {   \n\tint n = ps.size();\n\tsort(ps.begin(),ps.end());\n\n\tint k = 0;\n\tvector<Point> convex(n*2);\n\n\trep(i, n) {\n\t\twhile (k > 1 && ccw(convex[k-2], convex[k-1], ps[i]) == -1 ) {\n\t\t\tk--;\n\t\t}\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tfor(int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && ccw(convex[k-2], convex[k-1], ps[i]) == -1 ) {\n\t\t\tk--;\n\t\t}\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.resize(k-1);\n\treturn convex;\n}\n\ndouble convex_diameter(const vector<Point>& ps) {\n\tvector<Point> qs = convex_hull(ps);\n\tint n = qs.size();\n\n\tif(n == 2) return distancePP(qs[0], qs[1]);\n\n\tint i = 0, j = 0;\n\trep(k, n) {\n\t\tif(!(qs[i] < qs[k])) i = k;\n\t\tif(qs[j] < qs[k]) j = k;\n\t}\n\n\tdouble ret = 0;\n\tint si = i, sj = j;\n\twhile(i != sj || j != si) {\n\t\tret = max(ret, distancePP(qs[i], qs[j]));\n\t\tif( cross(qs[(i+1)%n] - qs[i], qs[(j+1)%n] - qs[j]) < 0) {\n\t\t\ti = (i + 1) % n;\n\t\t} else {\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tvector<Point> v(n);\n\trep(i, n) cin >> v[i].x >> v[i].y;\n\n\tcout << fixed;\n\tcout.precision(20);\n\tcout << convex_diameter(v) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\n\nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end());\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  //cout<<i<<\" \"<<j<<endl;\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    //cout<<i<<\" \"<<j<<endl;\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tint si=i,sj=j;\n\tR res=0.0;\n\tassert(0==1);\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <utility>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rep1(i,n) for(int i = 1; i <= n; ++i)\n#define F first\n#define S second\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }\nusing ll = long long;\nusing pi = pair<int,int>;\nusing ld = long double;\nconst ld EPS = 1e-10;\nstruct Vec2 {\n  ld x;\n  ld y;\n\n  Vec2() : x(0.0),y(0.0){} \n  Vec2(ld _x,ld _y) :x(_x),y(_y){}  \n  \n  Vec2 operator+(const Vec2& other) const { return { x + other.x , y + other.y }; }\n  Vec2 operator-(const Vec2& other) const { return { x - other.x , y - other.y }; }\n  bool operator==(const Vec2& other) const { return (abs(x - other.x) < EPS && abs(y - other.y) < EPS ); } \n  bool operator<(const Vec2& other) const { if(abs(x - other.x) < EPS) return y < other.y; else return x < other.x; }\n \n  ld dot(const Vec2& other) const { return x * other.x + y * other.y; }\n  ld cross(const Vec2& other) const { return x * other.y - y * other.x; }\n  ld length() const { return sqrt(x * x + y * y); }\n  \n  void Show() { printf(\"%.8Lf %.8Lf\\n\", x, y); }\n};\n\nstruct Line {\n  Vec2 s; // 始点\n  Vec2 t; // 終点\n  \n  Line() : s({0, 0}), t({0, 0}) {}\n  Line(Vec2 s, Vec2 t) : s(s), t(t) {}\n\n  Vec2 V() { return t - s; }\n  ld dot(const Line &other) const { return (t - s).dot(other.t - other.s); }\n  ld cross(const Line &other) const { return (t - s).cross(other.t - other.s); }\n  ld length() const { return (t - s).length(); }\n\n  ld alpha() { // 直線の傾き\n    if(abs((t - s).x) < EPS) { cout << \"pararell Y axis!!!\" << \"\\n\"; return 0; }\n    else return (t - s).y / (t - s).x;\n  }\n  ld beta() { // 直線の切片\n    if(abs((t - s).x) < EPS) { cout << \"pararell Y axis!!!\" << \"\\n\"; return 0; }\n    else return s.y - (t - s).y / (t - s).x * s.x;\n  }\n\n  void Show() { s.Show(); t.Show();  }  \n};\n\nstruct Circle {\n  Vec2 p; // 中心\n  ld r; // 半径\n\n  Circle() : p({0,0}), r(0) {}\n  Circle(Vec2 p, ld r) : p(p), r(r) {}\n  \n  void Show() { printf(\"%.8Lf %.8Lf %.8Lf\\n\", p.x, p.y, r); }\n};\n\n//******************** 2点間の距離 *******************\ndouble Dist(Vec2 &A, Vec2 &B) { return (A - B).length(); } \n//*****************ベクトルVをTheta回転******************\nVec2 Rot(Vec2 &V, ld Theta) {\n  return Vec2(V.x * cos(Theta) - V.y * sin(Theta), V.x * sin(Theta) + V.y * cos(Theta));\n}\n//********** ベクトルVを回転**********\nVec2 Rot(Vec2 &V, ld SIN, ld COS) {\n  return Vec2(V.x * COS - V.y * SIN, V.x * SIN + V.y * COS);\n}\n//********** ベクトルA とB のなす角θ cosθ, sin**********\nld Cos(const Vec2 &A, const Vec2 &B) {\n  if(A.length() < EPS || B.length() < EPS) return 0;\n  return A.dot(B) / (A.length()*B.length());\n}\nld Sin(const Vec2 &A, const Vec2 &B) {\n  if(A.length() < EPS || B.length() < EPS) return 0;\n  return A.cross(B) / (A.length()*B.length());\n}\n//********** 線分A とB のなす角θ cosθ, sin**********\nld Cos(const Line &A, const Line &B) {\n  if(A.length() < EPS || B.length() < EPS) return 0;\n  return A.dot(B) / (A.length()*B.length());\n}\nld Sin(const Line &A, const Line &B) {\n  if(A.length() < EPS || B.length() < EPS) return 0;\n  return A.cross(B) / (A.length()*B.length());\n}\n//**********3点から三角形の面積を求める**********\nld Area(Vec2 &A, Vec2 &B, Vec2 &C) {\n  Line AB(A, B), AC(A, C);\n  return AB.cross(AC) / 2;\n}\n//********** 線分ABをB方向に長さlに延長する**********\nLine ExpandB(const Line &AB, const ld &l) {\n  Line v(Vec2(0,0), Vec2(1,0));\n  Vec2 d(l * Cos(v, AB), l * Sin(v, AB));\n  return Line(AB.s, AB.s + d);\n}\n//********** 線分ABを両方向に長さlに延長する**********\nLine ExpandAB(Line &AB, ld &l) {\n  Line v(Vec2(0,0), Vec2(1,0));\n  Vec2 d(l * Cos(v, AB), l * Sin(v, AB));\n  return Line(AB.t - d, AB.s + d);\n}\n//********** 線分ABをx:y に内分する点を返す**********\nVec2 InDiv(Line &AB, ld x, ld y) {\n  ld l = AB.length() * x / (x + y);\n  return ExpandB(AB, l).t;\n}\n//********** 直線ABと点Cの距離**********\nld DistLinePoint(const Line &AB, const Vec2 &C) {\n  Line AC(AB.s, C);\n  return AC.length() * abs(Sin(AB, AC));\n}\n//********** 直線AB上に点Cを射影した点**********\nVec2 Proj(const Line &AB, const Vec2 &C) {\n  Line AC(AB.s, C);\n  ld l = AC.length() * Cos(AB, AC);\n  Line res = ExpandB(AB, l);\n  return res.t;\n}\n//********** 直線AB上に点Cがあるか**********\nbool IsOnLine(const Line &AB, const Vec2 &C) {\n  Line CA(C, AB.s), CB(C, AB.t);\n  return abs(Sin(CA, CB)) < EPS;\n}\n//********** 線分AB上に点Cがあるか**********\nbool IsInLine(const Line &AB, const Vec2 &C) {\n  Line CA(C, AB.s), CB(C, AB.t);\n  return abs(Sin(CA, CB)) < EPS && CA.dot(CB) < EPS;\n}\n//********** 線分の交差判定**********\nbool CrossCheck(const Line &AB, const Line &CD) {\n  Line AC(AB.s, CD.s), AD(AB.s, CD.t);\n  Line BC(AB.t, CD.s), BD(AB.t, CD.t);\n  Line CA(CD.s, AB.s), CB(CD.s, AB.t);\n  Line DA(CD.t, AB.s), DB(CD.t, AB.t);\n  ld s = AB.cross(AC) * AB.cross(AD);\n  ld t = CD.cross(CA) * CD.cross(CB);\n\n  if(abs(Sin(AB, CD)) < EPS) { // 平行のとき\n    if(abs(Sin(AB, AC)) < EPS) { // 同一直線上にあるか？\n      return (CA.dot(CB) < EPS || DA.dot(DB) < EPS || AC.dot(AD) < EPS || BC.dot(BD) < EPS);\n    }\n    else return false;\n  }\n  else return s < EPS && t < EPS;\n}\n//********** 直線の交点**********\nVec2 CrossPoint(Line &AB, Line &CD) {\n  if( abs(Sin(AB, CD)) < EPS) {\n    cout << \"Pararell\" << \"\\n\";\n    return Vec2(0,0);\n  }\n  if(abs(AB.V().x) < EPS) { // ABがy軸に平行\n    return Vec2(AB.s.x, CD.alpha() * AB.s.x + CD.beta());\n  }\n  else if( abs(CD.V().x) < EPS) { // CDがy軸に平行\n    return Vec2(CD.s.x, AB.alpha() * CD.s.x + AB.beta());\n  }\n  else {\n    ld resX = (CD.beta() - AB.beta()) / (AB.alpha() - CD.alpha());\n    ld resY = AB.alpha() * resX + AB.beta();\n    return Vec2(resX, resY);\n  }\n}\n//********** 点Cを通りABに平行な直線を返す**********\nLine OrthogonalLine(Line &AB, Vec2 &C) {\n  Vec2 t(C.x + AB.V().y, C.y - AB.V().x);\n  return Line(C, t);\n}\n\n//********** 三角形の外接円**********\nCircle CircumscribedCircle(Vec2 &A, Vec2 &B, Vec2 &C) {\n  Line AB(A, B), BC(B, C);\n  Vec2 ABx = InDiv(AB, 1, 1);\n  Vec2 BCx = InDiv(BC, 1, 1);  \n  Line ABn = OrthogonalLine(AB, ABx);\n  Line BCn = OrthogonalLine(BC, BCx);\n  Vec2 Cen = CrossPoint(ABn, BCn);\n  return Circle(Cen, (Cen - A).length());\n}\n//********** 直線と円の交点**********\nvector<Vec2> CrossPointCircleLine(Circle &C, Line &AB){\n  vector<Vec2> res;\n  if(IsInLine(AB, C.p)) {\n    Line OX(C.p, AB.s);\n    Vec2 X = ExpandB(OX, C.r).t;\n    Line OY(C.p, AB.t);\n    Vec2 Y = ExpandB(OY, C.r).t;\n    res.push_back(X);\n    res.push_back(Y);\n    return res;\n  }\n  Vec2 P = Proj(AB, C.p);\n  Line OP(C.p, P);\n  Line OPn = OrthogonalLine(OP, P);\n  ld l = sqrt(C.r*C.r - OP.length()*OP.length());\n\n  if(C.r < OP.length()) return res;\n  Vec2 X = ExpandB(OPn, l).t;\n  Vec2 Y = ExpandB(OPn, -l).t;\n  if(X == Y) res.push_back(X);\n  else { \n    res.push_back(X);\n    res.push_back(Y);    \n  }\n  return res;\n}\n//********** 2つの円の交差判定**********\n// 0:内包、1:内接、2:交差、3:外接、4:離れている\nint CrossCheckCircle(Circle &C, Circle &D) {\n  ld d = Dist(C.p, D.p);\n  if(abs(C.r - D.r) > d) return 0; \n  else if(abs(abs(C.r - D.r) - d) < EPS) return 1;\n\n  if(C.r + D.r < d) return 4;\n  else if(abs(C.r + D.r - d) < EPS) return 3;\n  else return 2;\n}\n//********** 2つの円の交点**********\nvector<Vec2> CrossPointCircleCircle(Circle &C, Circle &D) {\n  vector<Vec2> res;\n  int label = CrossCheckCircle(C, D);\n  if(label == 0 || label == 4) return res; // 共有点なし\n  else if(label == 1) { // 内接\n    if(C.r < D.r) {\n      Line DC(D.p, C.p);\n      Vec2 X = ExpandB(DC, D.r).t;\n      res.push_back(X);\n      res.push_back(X);      \n    }\n    else {\n      Line CD(C.p, D.p);\n      Vec2 X = ExpandB(CD, C.r).t;\n      res.push_back(X);\n      res.push_back(X);            \n    }\n  }\n  else if(label == 3) { // 外接\n    Line CD(C.p, D.p);\n    Vec2 X = ExpandB(CD, C.r).t;\n    res.push_back(X);\n    res.push_back(X);                \n  }\n  else if(label == 2) {\n    ld ad = 2*(C.p.x - D.p.x);\n    ld eb = 2*(D.p.y - C.p.y);\n    ld R = - C.p.x*C.p.x + D.p.x*D.p.x - C.p.y*C.p.y + D.p.y*D.p.y + C.r*C.r - D.r*D.r;\n    if(abs(eb) < EPS) {\n      Vec2 A(- R / ad, 0);\n      Vec2 B(- R / ad, 1);\n      Line AB(A, B);\n      ld inf = 40000;\n      Line ABE = ExpandAB(AB, inf);\n      res = CrossPointCircleLine(C, ABE);      \n    }\n    else {\n      Vec2 A(0, R / eb);\n      Vec2 B(1, (ad + R) / eb);\n      Line AB(A, B);\n      ld inf = 40000;\n      Line ABE = ExpandAB(AB, inf);\n      res = CrossPointCircleLine(C, ABE);\n    }\n  }\n  return res;\n}\n//********** 点Pを通る円Cの接線と円Cとの接点**********\nvector<Vec2> TangentCircle(Circle &C, Vec2 &P) {\n  vector<Vec2> res;\n  Line PC(P, C.p);\n  Vec2 OC = PC.V();\n  ld l = sqrt(PC.length()*PC.length() - C.r*C.r);\n  ld SIN = C.r / PC.length(), COS = l / PC.length();\n  Vec2 OX = Rot(OC, SIN, COS), OY = Rot(OC, -SIN, COS);\n  Line OXL(Vec2(0,0), OX) , OYL(Vec2(0,0), OY);\n  OXL = ExpandB(OXL, l);\n  OYL = ExpandB(OYL, l);\n  res.push_back(OXL.t + P);\n  res.push_back(OYL.t + P);\n  return res;\n}\n//**********多角形の面積を求める**********\nld Area(vector<Vec2> &V) {\n  int n = V.size();\n  ld res = 0;\n  Vec2 O = V[0];\n  rep1(i, n-2) {\n    res += Area(O, V[i], V[i+1]);\n  }\n  return res;\n}\n//*********凸包************\nvector<Vec2> ConvexHull(vector<Vec2> &V) {\n  int n = V.size();\n  //******** 最も左下の点をスタートにする  ********\n  sort(V.begin(), V.end());\n  Vec2 O = V[0]; \n  //**********************************\n  //************ 偏角ソート **********\n  // 偏角が同じものはスタートからの距離が遠いほど先に配置\n  sort(V.begin(), V.end(), [&](Vec2 a, Vec2 b) {\n\t\t\t     double adx = a.x - O.x, ady = a.y - O.y;\n\t\t\t     double bdx = b.x - O.x, bdy = b.y - O.y;\n\t\t\t     if(abs(adx) < EPS && abs(ady) < EPS) return true;\n\t\t\t     else if(abs(bdx) < EPS && abs(bdy) < EPS) return false;\n                             else if(abs(atan2(ady, adx) - atan2(bdy, bdx)) < EPS ) {\n                               return Dist(O, a) > Dist(O, b);\n\t\t\t     }\n\t\t\t     else {\n\t\t\t       return atan2(ady, adx) < atan2(bdy, bdx);\n\t\t\t     }\n\t\t\t   });\n  //**********************************\n  //******************* GrahamScan ******************\n  vector<Vec2> res;\n  int next = 2;\n  res.push_back(V[0]);\n  res.push_back(V[1]);\n  //***************前処理************\n  // 偏角が同じものについて、スタート直後のみはスタートからの距離が短い順に並べる。\n  while(abs(Sin(V[1] - V[0], V[next] - V[0])) < EPS) {\n    res.push_back(V[next]);\n    next++;\n  }\n  sort(res.begin(), res.end(), [&](Vec2 a, Vec2 b) {\n\t\t\t\t return Dist(O, a) < Dist(O, b);\n\t\t\t       });\n  //*********************************\n  while(next < n) {\n    int size = res.size();\n    if(abs(Sin(res[size - 1] - res[size - 2], V[next] - res[size - 1])) < EPS\n       || Sin(res[size - 1] - res[size - 2], V[next] - res[size - 1]) > 0) {\n      res.push_back(V[next]);\n      next++;\n    }\n    else {\n      res.pop_back();\n    }\n  }\n  return res;\n  //******************************************\n}\n//*************キャリパー法。凸多角形に対して、最遠点対を求める*********\nld Caliper(const vector<Vec2> &V) {\n  int n = V.size();\n  // x軸方向に最も遠い点対を求める\n  int p = 0, q = 0;\n  ld xmin = 1e+15, xmax = -1e+15;\n  rep(i,n) {\n    if(chmin(xmin, V[i].x)) p = i;\n    if(chmax(xmax, V[i].x)) q = i;\n  }\n  ld res = 0;\n  int sp = p, sq = q;\n  while(p != sq || q != sp) { // 180度回転するまで\n    chmax(res, (V[q] - V[p]).length() );\n    if( (V[(p+1)%n] - V[p]).cross(V[(q+1)%n] - V[q]) < 0) {\n      p = (p + 1) % n;\n    }\n    else {\n      q = (q + 1) % n;\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  int n; cin >> n;\n  vector<Vec2> V(n);\n  rep(i,n) cin >> V[i].x >> V[i].y;\n  ld res = Caliper(V);\n  printf(\"%.8Lf\\n\", res);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define scanf nope\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntemplate <class T>\nstruct Point {\n\ttypedef Point P;\n\tT x, y;\n\texplicit Point(T x=0, T y=0) : x(x), y(y) {}\n\tbool operator<(P p) const { return x<p.x||(x==p.x && y<p.y);}\n\tbool operator==(P p) const { return x==p.x && y==p.y; }\n\tP operator+(P p) const { return P(x+p.x, y+p.y); }\n\tP operator-(P p) const { return P(x-p.x, y-p.y); }\n\tP operator*(T d) const { return P(x*d, y*d); }\n\tP operator/(T d) const { return P(x/d, y/d); }\n\tT dot(P p) const { return x*p.x + y*p.y; }\n\tT cross(P p) const { return x*p.y - y*p.x; }\n\tT cross(P p1, P p2) const { return (p1 - *this).cross(p2 - *this); }\n\tT dist2() const { return x*x + y*y; }\n\tdouble dist() const { return sqrt((double)dist2()); }\n\t// angle to x-axis in interval [-pi, pi]\n\tdouble angle() const { return atan2(y, x); }\n\tP unit() const { return *this/dist(); } // makes dist()=1\n\tP perp() const { return P(-y, x); } // rotates +90 degrees\n\tP normal() const { return perp().unit(); }\n\t// returns point rotated 'a' radians ccw around the origin\n\tP rotate(double a) const {\n\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n};\n\ntypedef Point<double> P;\npair<vi, vi> ulHull(const vector<P>& S) {\n    vector<int> Q(sz(S));\n    iota(all(Q), 0);\n    sort(all(Q), [&S](int a, int b){ return S[a] < S[b]; });\n    vi U, L;\n    trav(it, Q) {\n        while (sz(U) > 1 && S[U[sz(U)-2]].cross(S[it], S[U.back()]) <= 0) U.pop_back();\n        while (sz(L) > 1 && S[L[sz(L)-2]].cross(S[it], S[L.back()]) >= 0) L.pop_back();\n        U.push_back(it);\n        L.push_back(it);\n    }\n    return make_pair(U, L);\n}\n\nvi convexHull(const vector<P>& S) {\n    vi u, l;\n    tie(u, l) = ulHull(S);\n    if (sz(S) <= 1) return u;\n    u.pop_back();\n    reverse(all(u));\n    u.pop_back();\n    u.insert(u.end(), all(l));\n    if (sz(u) == 2 && S[u[0]] == S[u[1]]) u.pop_back();\n    return u;\n}\n\nvector<pii> antipodal(const vector<P>& S, const vi& U, const vi& L) {\n    vector<pii> A;\n    int i = 0;\n    int j = sz(L) - 1;\n    while (i < sz(U) - 1 || j > 0) {\n        A.emplace_back(i, j);\n        if (i == sz(U) - 1) --j;\n        else if (j == 0) ++i;\n        else if ((S[U[i+1]].y - S[U[i]].y) * (S[L[j]].x - S[L[j-1]].x) >\n                 (S[U[i+1]].x - S[U[i]].x) * (S[L[j]].y - S[L[j-1]].y)) ++i;\n        else --j;\n    }\n    return A;\n}\n\npii polygonDiameter(const vector<P>& S) {\n    vi U, L;\n    tie(U, L) = ulHull(S);\n    pair<double, pii> ans;\n    trav(it, antipodal(S, U, L))\n        ans = max(ans, make_pair((S[it.first] - S[it.second]).dist2(), it));\n    return ans.second;\n}\n\nint main() {\n    int N;\n    cin >> N;\n        vector<P> P(N);\n        rep(i,0,N) cin >> P[i].x >> P[i].y;\n        pii ret = polygonDiameter(P);\n        cout << setprecision(10) << fixed << (P[ret.first] - P[ret.second]).dist() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define TemplateVersion \"3.4.0\"\n// Useful Marcos\n//====================START=====================\n// Compile use C++11 and above\n#ifdef LOCAL\n#define debug(args...)                           \\\n    {                                            \\\n        string _s = #args;                       \\\n        replace(_s.begin(), _s.end(), ',', ' '); \\\n        stringstream _ss(_s);                    \\\n        istream_iterator<string> _it(_ss);       \\\n        err(_it, args);                          \\\n    }\nvoid err(istream_iterator<string> it)\n{\n}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\n#define MSG cout << \"Finished\" << endl\n#else\n#define debug(args...)\n#define MSG\n#endif\n#if __cplusplus >= 201703L\ntemplate <typename... Args>\nvoid readln(Args &... args)\n{\n    ((cin >> args), ...);\n}\ntemplate <typename... Args>\nvoid writeln(Args... args)\n{\n    ((cout << args << \" \"), ...);\n    cout << endl;\n}\n#elif __cplusplus >= 201103L\nvoid readln()\n{\n}\ntemplate <typename T, typename... Args>\nvoid readln(T &a, Args &... args)\n{\n    cin >> a;\n    readln(args...);\n}\nvoid writeln()\n{\n    cout << endl;\n}\ntemplate <typename T, typename... Args>\nvoid writeln(T a, Args... args)\n{\n    cout << a << \" \";\n    writeln(args...);\n}\n#endif\n#if __cplusplus >= 201103L\n#define FOR(_i, _begin, _end) for (auto _i = _begin; _i < _end; _i++)\n#define FORR(_i, _begin, _end) for (auto _i = _begin; _i > _end; _i--)\n#else\n#define FOR(_i, _begin, _end) for (int _i = (int)_begin; _i < (int)_end; _i++)\n#define FORR(_i, _begin, _end) for (int _i = (int)_begin; _i > (int)_end; _i--)\n#define nullptr NULL\n#endif\n#if __cplusplus >= 201103L\n#define VIS(_kind, _name, _size) \\\n    vector<_kind> _name(_size);  \\\n    for (auto &i : _name)        \\\n        cin >> i;\n#else\n#define VIS(_kind, _name, _size)    \\\n    vector<_kind> _name;            \\\n    _name.resize(_size);            \\\n    for (int i = 0; i < _size; i++) \\\n        cin >> _name[i];\n#endif\n// alias\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define tcase() \\\n    int T;      \\\n    cin >> T;   \\\n    FOR(kase, 1, T + 1)\n// Swap max/min\ntemplate <typename T>\nbool smax(T &a, const T &b)\n{\n    if (a > b)\n        return false;\n    a = b;\n    return true;\n}\ntemplate <typename T>\nbool smin(T &a, const T &b)\n{\n    if (a < b)\n        return false;\n    a = b;\n    return true;\n}\n// ceil divide\ntemplate <typename T>\nT cd(T a, T b)\n{\n    return (a + b - 1) / b;\n}\n// min exchange\ntemplate <typename T>\nbool se(T &a, T &b)\n{\n    if (a < b)\n        return false;\n    swap(a, b);\n    return true;\n}\n// A better MAX choice\nconst int INF = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef set<int> si;\ntypedef vector<string> cb;\n//====================END=====================\n\n// Constants here\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst double FAC = 1e-18;\n\ntypedef double db;\n\nint sgn(db x)\n{\n    if (abs(x) < EPS)\n        return 0;\n    if (x < 0)\n        return -1;\n    return 1;\n}\n\ndb Min(db a, db b) { return sgn(a - b) > 0 ? b : a; }\ndb Max(db a, db b) { return sgn(a - b) > 0 ? a : b; }\n\n// Point/Vector\nstruct Point\n{\n    db x, y;\n\n    Point() : x(0.0), y(0.0) {}\n\n    Point(db _x, db _y) : x(_x), y(_y) {}\n\n    bool operator==(const Point &p)\n    {\n        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;\n    }\n\n    bool operator<(const Point &p)\n    {\n        int c = sgn(x - p.x);\n        if (c)\n            return c == -1;\n        return sgn(y - p.y) == -1;\n    }\n\n    Point operator+(const Point &p) { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point &p) { return Point(x - p.x, y - p.y); }\n    Point operator*(db d) { return Point(x * d, y * d); }\n    Point operator/(db d) { return Point(x / d, y / d); }\n\n    db operator^(const Point &p) { return x * p.y - y * p.x; }\n    db operator*(const Point &p) { return x * p.x + y * p.y; }\n\n    db dis(const Point &p) { return (*this - p).len(); }\n    db alpha() { return atan2(y, x); }\n\n    Point unit() { return *this / len(); }\n    Point scale(db r) { return unit() * r; }\n\n    Point rotCC() { return Point(-y, x); }\n    Point rotCL() { return Point(y, -x); }\n\n    Point rot(Point p, db angle)\n    {\n        Point v = *this - p;\n        db c = cos(angle), s = sin(angle);\n        return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);\n    }\n\n    db len() { return hypot(x, y); }\n    db len2() { return x * x + y * y; }\n\n    db rad(Point a, Point b)\n    {\n        Point ap = a - *this, bp = b - *this;\n        return abs(atan2(abs(ap ^ bp), ap * bp));\n    }\n\n    // Point P,A,B\n    // -2 -> B is at back of PA\n    // -1 -> PB is on the clock-wise side of PA\n    // 0 -> B is on PA\n    // 1 -> PB is on the counter clock-wise side of PA\n    // 2 -> B is at the front of PA\n    int relation(Point a, Point b)\n    {\n        Point p = *this;\n        if (sgn((a - p) ^ (b - p)) > 0)\n            return 1;\n        if (sgn((a - p) ^ (b - p)) < 0)\n            return -1;\n        if (sgn((a - p) * (b - p)) < 0)\n            return -2;\n        if (sgn((p - a) * (b - a)) < 0)\n            return 2;\n        return 0;\n    }\n\n    void read() { cin >> x >> y; }\n    void write(char trail = ' ') { cout << x << ' ' << y << trail; }\n    void Debug() { cerr << \"Point: (\" << x << \", \" << y << \")\\n\"; }\n};\n\ndb cross(Point a, Point b, Point c) { return (b - a) ^ (c - a); }\n\n// Line\nstruct Line\n{\n    Point s, e;\n\n    Line(){};\n\n    Line(Point _s, Point _e) : s(_s), e(_e) {}\n\n    Line(Point p, db angle)\n    {\n        s = p;\n        if (sgn(angle - PI / 2))\n            e = (s + Point(1, tan(angle)));\n        else\n            e = (s + Point(0, 1));\n    }\n\n    //ax+by+c=0\n    Line(db a, db b, db c)\n    {\n        if (sgn(a) == 0)\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -c / b);\n        }\n        else if (sgn(b) == 0)\n        {\n            s = Point(-c / a, 0);\n            e = Point(-c / a, 1);\n        }\n        else\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -(c + a) / b);\n        }\n    }\n\n    db len() { return s.dis(e); }\n    db angle()\n    {\n        db ans = atan2(e.y - s.y, e.x - s.x);\n        if (sgn(ans) == -1)\n            ans += PI;\n        if (sgn(ans - PI) == 0)\n            ans -= PI;\n        return ans;\n    }\n\n    int relation(Point p) { return s.relation(e, p); }\n\n    bool parallel(Line l) { return sgn((e - s) ^ (l.e - l.s)) == 0; }\n\n    // 0 -> Not Intersect\n    // 1 -> Informal\n    // 2 -> Formal Intersection\n    int crossSS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        int d3 = sgn((l.e - l.s) ^ (s - l.s));\n        int d4 = sgn((l.e - l.s) ^ (e - l.s));\n        if ((d1 ^ d2) == -2 && (d3 ^ d4) == -2)\n            return 2;\n        return (d1 == 0 && sgn((l.s - s) * (l.s - e)) <= 0) ||\n               (d2 == 0 && sgn((l.e - s) * (l.e - e)) <= 0) ||\n               (d3 == 0 && sgn((s - l.s) * (s - l.e)) <= 0) ||\n               (d4 == 0 && sgn((e - l.s) * (e - l.e)) <= 0);\n    }\n\n    // 0 -> Not Intersect\n    // 1 -> Informal\n    // 2 -> Formal Intersection\n    int crossLS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        if ((d1 ^ d2) == -2)\n            return 2;\n        return (d1 == 0 || d2 == 0);\n    }\n\n    // 0 -> Parallel\n    // 1 -> Same\n    // 2 -> Intersect\n    int crossLL(Line l)\n    {\n        if (this->parallel(l))\n            return l.relation(s) == 3;\n        return 2;\n    }\n\n    Point intersec(Line l)\n    {\n        db a1 = (l.e - l.s) ^ (s - l.s);\n        db a2 = (l.e - l.s) ^ (e - l.s);\n        return Point((s.x * a2 - e.x * a1) / (a2 - a1), (s.y * a2 - e.y * a1) / (a2 - a1));\n    }\n\n    db disPL(Point p) { return abs((p - s) ^ (e - s)) / len(); }\n    db disPS(Point p)\n    {\n        if (sgn((p - s) * (e - s)) < 0 || sgn((p - e) * (s - e)) < 0)\n            return min(p.dis(s), p.dis(e));\n        return disPL(p);\n    }\n    db disSS(Line l) { return min(min(disPS(l.s), disPS(l.e)), min(l.disPS(s), l.disPS(e))); }\n\n    Point proj(Point p) { return s + ((e - s) * ((e - s) * (p - s))) / ((e - s).len2()); }\n    Point refl(Point p)\n    {\n        Point q = proj(p);\n        return Point(2 * q.x - p.x, 2 * q.y - p.y);\n    }\n\n    bool operator==(Line l) { return s == l.s && e == l.e; }\n\n    void adjust()\n    {\n        if (e < s)\n            swap(s, e);\n    }\n\n    void read()\n    {\n        s.read();\n        e.read();\n    }\n\n    void Debug() { cerr << \"Line: Start: (\" << s.x << \", \" << s.y << \") End: (\" << e.x << \", \" << e.y << \")\\n\"; }\n};\n\n// Circle\nstruct Circle\n{\n    Point p;\n    db r;\n\n    Circle(){};\n\n    Circle(Point _p, db _r) : p(_p), r(_r) {}\n\n    Circle(db x, db y, db _r) : p({x, y}), r(_r) {}\n\n    Circle(Point a, Point b, Point c, bool in = false)\n    {\n        if (!in)\n        {\n            Line u = Line((a + b) / 2, (a + b) / 2 + (b - a).rotCC());\n            Line v = Line((b + c) / 2, (b + c) / 2 + (c - b).rotCC());\n            p = u.intersec(v);\n            r = p.dis(a);\n        }\n        else\n        {\n            Line u, v;\n            db m = atan2(b.y - a.y, b.x - a.x), n = atan2(c.y - a.y, c.x - a.x);\n            u.s = a;\n            u.e = a + Point(cos((n + m) / 2), sin((n + m) / 2));\n            v.s = b;\n            m = atan2(a.y - b.y, a.x - b.x), n = atan2(c.y - b.y, c.x - b.x);\n            v.e = b + Point(cos((n + m) / 2), sin((n + m) / 2));\n            p = u.intersec(v);\n            r = Line(a, b).disPS(p);\n        }\n    }\n\n    bool operator==(const Circle &c) { return p == c.p && sgn(r - c.r) == 0; }\n\n    bool operator<(const Circle &c) { return (p < c.p) || (p == c.p && sgn(r - c.r) < 0); }\n\n    db area() { return PI * r * r; }\n\n    db cir() { return 2 * PI * r; }\n\n    Point on(db ang) { return Point(p.x + r * cos(ang), p.y + r * sin(ang)); }\n\n    // 0 -> Outside\n    // 1 -> On\n    // 2 -> Inside\n    int relationP(Point v)\n    {\n        db dis = v.dis(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // The number of intersections\n    int relationS(Line l)\n    {\n        db dis = l.disPS(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // The number of intersections\n    int relationL(Line l)\n    {\n        db dis = l.disPL(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // 1 -> Inside\n    // 2 -> Internally-tangent\n    // 3 -> Intersect\n    // 4 -> Externally-tangent\n    // 5 -> Disjoint\n    int relationC(Circle c)\n    {\n        db d = p.dis(c.p);\n        if (sgn(d - r - c.r) > 0)\n            return 5;\n        if (sgn(d - r - c.r) == 0)\n            return 4;\n        db l = abs(r - c.r);\n        if (sgn(d - r - c.r) < 0 && sgn(d - l) > 0)\n            return 3;\n        if (sgn(d - l) == 0)\n            return 2;\n        // TODO: Check if this one is necessary\n        // if (sgn(d - l) < 0)\n        return 1;\n    }\n\n    // The return value is the number of intersections\n    int crossC(Circle c, Point &p1, Point &p2)\n    {\n        int re = relationC(c);\n        if (re == 1 || re == 5)\n            return 0;\n        db d = p.dis(c.p), l = (d * d + r * r - c.r * c.r) / (2.0 * d), h = sqrt(r * r - l * l);\n        Point tmp = p + (c.p - p).scale(l);\n        p1 = tmp + (c.p - p).rotCC().scale(h);\n        p2 = tmp + (c.p - p).rotCL().scale(h);\n        if (re == 2 || re == 4)\n            return 1;\n        return 2;\n    }\n\n    // Same as above\n    int crossL(Line l, Point &p1, Point &p2)\n    {\n        if (!this->relationL(l))\n            return 0;\n        Point a = l.proj(p);\n        db d = l.disPL(p);\n        d = sqrt(r * r - d * d);\n        if (sgn(d) == 0)\n        {\n            p1 = a;\n            p2 = a;\n            return 1;\n        }\n        p1 = a + (l.e - l.s).scale(d);\n        p2 = a - (l.e - l.s).scale(d);\n        return 2;\n    }\n\n    int tangent(Point q, Point &u, Point &v)\n    {\n        int x = relationP(q);\n        if (x == 2)\n            return 0;\n        if (x == 1)\n        {\n            u = q + (q - p).rotCC();\n            v = u;\n            return 1;\n        }\n        db d = p.dis(q);\n        db l = r * r / d;\n        db h = sqrt(r * r - l * l);\n        u = p + ((q - p).scale(l) + (q - p).rotCC().scale(h));\n        v = p + ((q - p).scale(l) + (q - p).rotCL().scale(h));\n        return 2;\n    }\n\n    int tangent(Circle c, vector<Point> &u, vector<Point> &v)\n    {\n        if (sgn(r - c.r) < 0)\n            return c.tangent(*this, v, u);\n\n        int ret = relationC(c) - 1;\n        if (!ret || *this == c)\n            return 0;\n        u.clear();\n        v.clear();\n\n        db b = (c.p - p).alpha();\n\n        if (ret == 1 || ret == 3)\n        {\n            u.push_back(on(b));\n            v.push_back(on(b));\n        }\n\n        db ang = acos((r - c.r) / p.dis(c.p));\n\n        if (ret != 1)\n        {\n            u.push_back(on(b + ang));\n            u.push_back(on(b - ang));\n            v.push_back(c.on(b + ang));\n            v.push_back(c.on(b - ang));\n        }\n\n        if (ret == 4)\n        {\n            ang = acos((r + c.r) / p.dis(c.p));\n            u.push_back(on(b + ang));\n            u.push_back(on(b - ang));\n            v.push_back(c.on(PI + b + ang));\n            v.push_back(c.on(PI + b - ang));\n        }\n\n        return ret;\n    }\n\n    // The area of intersecting space\n    // With circle c\n    db area(Circle c)\n    {\n        int re = relationC(c);\n        if (re >= 4)\n            return 0;\n        if (re <= 2)\n            return min(area(), c.area());\n        db d = p.dis(c.p);\n        db hf = (r + c.r + d) / 2.0;\n        db ss = 2 * sqrt(hf * (hf - r) * (hf - c.r) * (hf - d));\n        db a1 = acos((r * r + d * d - c.r * c.r) / (2.0 * r * d));\n        a1 = a1 * r * r;\n        db a2 = acos((c.r * c.r + d * d - r * r) / (2.0 * c.r * d));\n        a2 = a2 * c.r * c.r;\n        return a1 + a2 - ss;\n    }\n\n    // The area of intersecting space\n    // With triangle PAB\n    db area(Point a, Point b)\n    {\n        if (sgn((p - a) ^ (p - b)) == 0)\n            return 0.0;\n        Point q[5];\n        int len = 0;\n        q[len++] = a;\n        Line l(a, b);\n        Point p1, p2;\n        if (crossL(l, q[1], q[2]) == 2)\n        {\n            if (sgn((a - q[1]) * (b - q[1])) < 0)\n                q[len++] = q[1];\n            if (sgn((a - q[2]) * (b - q[2])) < 0)\n                q[len++] = q[2];\n        }\n        q[len++] = b;\n        if (len == 4 && sgn((q[0] - q[1]) * (q[2] - q[1])) > 0)\n            swap(q[1], q[2]);\n        db res = 0;\n        for (int i = 0; i < len - 1; i++)\n        {\n            if (relationP(q[i]) == 0 || relationP(q[i + 1]) == 0)\n            {\n                db arg = p.rad(q[i], q[i + 1]);\n                res += r * r * arg / 2.0;\n            }\n            else\n                res += abs((q[i] - p) ^ (q[i + 1] - p)) / 2.0;\n        }\n        return res;\n    }\n\n    // Two circle whose center are a and b respectivelly\n    static int GetCircle(Point a, Point b, db r, Circle &c1, Circle &c2)\n    {\n        Circle x(a, r), y(b, r);\n        int t = x.crossC(y, c1.p, c2.p);\n        if (!t)\n            return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n\n    // The circle which tangent is l and point p on it\n    static int GetCircle(Line l, Point p, db r, Circle &c1, Circle &c2)\n    {\n        db dis = l.disPL(p);\n        if (sgn(dis - r * 2) > 0)\n            return 0;\n        if (sgn(dis) == 0)\n        {\n            c1.p = p + ((l.e - l.s).rotCC().scale(r));\n            c2.p = p + ((l.e - l.s).rotCL().scale(r));\n            c1.r = c2.r = r;\n            return 2;\n        }\n        Line u1 = Line((l.s + (l.e - l.s).rotCC().scale(r)), (l.e + (l.e - l.s).rotCC().scale(r)));\n        Line u2 = Line((l.s + (l.e - l.s).rotCL().scale(r)), (l.e + (l.e - l.s).rotCL().scale(r)));\n        Circle cc(p, r);\n        Point p1, p2;\n        if (!cc.crossL(u1, p1, p2))\n            cc.crossL(u2, p1, p2);\n        c1 = Circle(p1, r);\n        if (p1 == p2)\n        {\n            c2 = c1;\n            return 1;\n        }\n        c2 = Circle(p2, r);\n        return 2;\n    }\n\n    // u and v are the common tangent of the four circles\n    static int GetCircle(Line u, Line v, db r, Circle &c1, Circle &c2, Circle &c3, Circle &c4)\n    {\n        if (u.parallel(v))\n            return 0;\n        Line u1 = Line(u.s + (u.e - u.s).rotCC().scale(r), u.e + (u.e - u.s).rotCC().scale(r));\n        Line u2 = Line(u.s + (u.e - u.s).rotCL().scale(r), u.e + (u.e - u.s).rotCL().scale(r));\n        Line v1 = Line(v.s + (v.e - v.s).rotCC().scale(r), v.e + (v.e - v.s).rotCC().scale(r));\n        Line v2 = Line(v.s + (v.e - v.s).rotCL().scale(r), v.e + (v.e - v.s).rotCL().scale(r));\n        c1.r = c2.r = c3.r = c4.r = r;\n        c1.p = u1.intersec(v1);\n        c2.p = u1.intersec(v2);\n        c3.p = u2.intersec(v1);\n        c4.p = u2.intersec(v2);\n        return 4;\n    }\n\n    // Tangent with circle cx and cy\n    static int GetCircle(Circle cx, Circle cy, db r, Circle &c1, Circle &c2)\n    {\n        Circle x(cx.p, r + cx.r), y(cy.p, r + cy.r);\n        int t = x.crossC(y, c1.p, c2.p);\n        if (!t)\n            return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n\n    void read()\n    {\n        p.read();\n        cin >> r;\n    }\n\n    void Debug() { cerr << \"Circle: Center: (\" << p.x << \", \" << p.y << \") Radius: \" << r << '\\n'; }\n};\n\n// Polygon\nstruct Polygon\n{\n    // Functor for sorting by polar angle\n    struct cmp\n    {\n        Point p;\n        cmp(const Point &b) { p = b; }\n        bool operator()(const Point &a, const Point &b)\n        {\n            Point x = a, y = b;\n            int d = sgn((x - p) ^ (y - p));\n            if (!d)\n                return sgn(x.dis(p) - y.dis(p)) > 0;\n            return d > 0;\n        }\n    };\n\n    vector<Point> ps;\n    vector<Line> ls;\n\n    Polygon() {}\n\n    void add(Point p) { ps.push_back(p); }\n\n    int size() { return static_cast<int>(ps.size()); }\n\n    void getLines()\n    {\n        int s = size();\n        for (int i = 0; i < s; i++)\n            ls.push_back(Line(ps[i], ps[(i + 1) % s]));\n    }\n\n    void norm()\n    {\n        Point p = ps[0];\n        for (int i = 1; i < size(); i++)\n        {\n            if (p < ps[i])\n                continue;\n            p = ps[i];\n        }\n        sort(ps.begin(), ps.end(), cmp(p));\n    }\n\n    void getConvexJarvis(Polygon &conv)\n    {\n        sort(ps.begin(), ps.end());\n        conv.ps.resize(2 * size());\n\n        int n = size();\n        for (int i = 0; i < min(2, n); i++)\n            conv.ps[i] = ps[i];\n        if (conv.size() == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.resize(1);\n\n        if (n <= 2)\n            return;\n\n        int top = 1;\n\n        for (int i = 2; i < n; i++)\n        {\n            while (top && sgn((conv.ps[top] - ps[i]) ^ (conv.ps[top - 1] - ps[i])) <= 0)\n                top--;\n            conv.ps[++top] = ps[i];\n        }\n\n        int t = top;\n        conv.ps[++top] = ps[n - 2];\n\n        for (int i = n - 3; i >= 0; i--)\n        {\n            while (top != t && sgn((conv.ps[top] - ps[i]) ^ (conv.ps[top - 1] - ps[i])) <= 0)\n                top--;\n            conv.ps[++top] = ps[i];\n        }\n\n        while (conv.size() > top)\n            conv.ps.pop_back();\n\n        if (top == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.pop_back();\n\n        conv.norm(); // Counter Clock-wise\n    }\n\n    void getConvexWithPointOnLine(Polygon &conv)\n    {\n        int m, n = size();\n        if (n < 3)\n        {\n            for (auto i : ps)\n                conv.add(i);\n            return;\n        }\n\n        vector<Point> &g = conv.ps;\n\n        sort(ps.begin(), ps.end());\n        for (int i = 0; i < n; i++)\n        {\n            while ((m = g.size()) >= 2 && g[m - 2].relation(g[m - 1], ps[i]) <= 0)\n                g.pop_back();\n            g.push_back(ps[i]);\n        }\n\n        int t = g.size();\n\n        for (int i = n - 2; i >= 0; i--)\n        {\n            while ((m = g.size()) > t && g[m - 2].relation(g[m - 1], ps[i]) <= 0)\n                g.pop_back();\n            g.push_back(ps[i]);\n        }\n\n        g.pop_back();\n    }\n\n    // Cannot get the point on the edge\n    void getConvexGraham(Polygon &conv)\n    {\n        norm();\n        int top = 0, n = size();\n        if (n == 1)\n        {\n            conv.add(ps[0]);\n            return;\n        }\n\n        if (n == 2)\n        {\n            conv.add(ps[0]);\n            conv.add(ps[1]);\n            if (conv.ps[0] == conv.ps[1])\n                conv.ps.pop_back();\n            return;\n        }\n\n        conv.ps.resize(size());\n        conv.ps[0] = ps[0];\n        conv.ps[1] = ps[1];\n        top = 2;\n        for (int i = 2; i < n; i++)\n        {\n            while (top > 1 && sgn((conv.ps[top - 1] - conv.ps[top - 2]) ^ (ps[i] - conv.ps[top - 2])) <= 0)\n                top--;\n            conv.ps[top++] = ps[i];\n        }\n\n        while (conv.size() > top)\n            conv.ps.pop_back();\n\n        if (top == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.pop_back();\n    }\n\n    bool isConvex()\n    {\n        bitset<3> s;\n        int n = size();\n        for (int i = 0; i < n; i++)\n        {\n            int j = (i + 1) % n;\n            int k = (j + 1) % n;\n            s.set(sgn((ps[j] - ps[i]) ^ (ps[k] - ps[i])) + 1);\n            if (s[0] && s[2])\n                return false;\n        }\n        return true;\n    }\n\n    db diameter()\n    {\n        int q = 1, n = size();\n        db ans = 0;\n        ps.push_back(ps[0]);\n        for (int i = 0; i < n; i++)\n        {\n            while (sgn(cross(ps[i + 1], ps[q + 1], ps[i]) - cross(ps[i + 1], ps[q], ps[i])) > 0)\n                q = (q + 1) % n;\n            ans = Max(ans, Max(ps[i].dis(ps[q]), ps[i + 1].dis(ps[q + 1])));\n        }\n        ps.pop_back();\n        return ans;\n    }\n\n    // 3 -> On Corner\n    // 2 -> On Edge\n    // 1 -> Inside\n    // 0 -> Outside\n    int relationP(Point q)\n    {\n        int n = size();\n        for (int i = 0; i < n; i++)\n            if (ps[i] == q)\n                return 3;\n        getLines();\n        for (int i = 0; i < n; i++)\n            if (!ls[i].relation(q))\n                return 2;\n        int cnt = 0;\n        for (int i = 0; i < n; i++)\n        {\n            int j = (i + 1) % n;\n            int k = sgn((q - ps[j]) ^ (ps[i] - ps[j]));\n            int u = sgn(ps[i].y - q.y);\n            int v = sgn(ps[j].y - q.y);\n            if (k > 0 && u < 0 && v >= 0)\n                cnt++;\n            if (k < 0 && v < 0 && u >= 0)\n                cnt--;\n        }\n        return cnt != 0;\n    }\n\n    void convexCut(Line l, Polygon &po)\n    {\n        for (int i = 0; i < size(); i++)\n        {\n            int d1 = sgn((l.e - l.s) ^ (ps[i] - l.s));\n            int d2 = sgn((l.e - l.s) ^ (ps[(i + 1) % size()] - l.s));\n            if (d1 >= 0)\n                po.add(ps[i]);\n            if (d1 * d2 < 0)\n                po.add(l.intersec(Line(ps[i], ps[(i + 1) % size()])));\n        }\n    }\n\n    db cir()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += ps[i].dis(ps[(i + 1) % n]);\n        return sum;\n    }\n\n    db area()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += (ps[i] ^ ps[(i + 1) % n]);\n        return abs(sum) / 2;\n    }\n\n    // 0 -> Clock-wise\n    // 1 -> Counter Clock-wise\n    bool dir()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += (ps[i] ^ ps[(i + 1) % n]);\n        return sgn(sum) > 0;\n    }\n\n    Point baryCenter()\n    {\n        Point ret;\n        db area = 0;\n        for (int i = 1; i < size() - 1; i++)\n        {\n            db tmp = (ps[i] - ps[0]) ^ (ps[i + 1] - ps[0]);\n            if (sgn(tmp) == 0)\n                continue;\n            area += tmp;\n            ret.x += (ps[0].x + ps[i].x + ps[i + 1].x) / 3 * tmp;\n            ret.y += (ps[0].y + ps[i].y + ps[i + 1].y) / 3 * tmp;\n        }\n        if (sgn(area))\n            ret = ret / area;\n        return ret;\n    }\n\n    db area(Circle c)\n    {\n        double ans = 0;\n        for (int i = 0; i < size(); i++)\n        {\n            int j = (i + 1) % size();\n            if (sgn((ps[j] - c.p) ^ (ps[i] - c.p)) >= 0)\n                ans += c.area(ps[i], ps[j]);\n            else\n                ans -= c.area(ps[i], ps[j]);\n        }\n        return abs(ans);\n    }\n\n    // 2 -> The circle is entirely in the polygon\n    // 1 -> The circle in in the circle and intersected with the boundary\n    // 0 -> Otherwise\n    int relationC(Circle c)\n    {\n        getLines();\n        int x = 2;\n        if (relationP(c.p) != 1)\n            return 0;\n        for (int i = 0; i < size(); i++)\n        {\n            if (c.relationS(ls[i]) == 2)\n                return 0;\n            if (c.relationS(ls[i]) == 1)\n                x = 1;\n        }\n        return x;\n    }\n\n    void read(int s)\n    {\n        for (int i = 0; i < s; i++)\n        {\n            Point p;\n            p.read();\n            ps.push_back(p);\n        }\n    }\n\n    void Debug()\n    {\n        cerr << \"Polygon:\\nPoints:\\n\";\n        for (auto i : ps)\n            i.Debug();\n        cerr << \"Lines:\\n\";\n        for (auto i : ls)\n            i.Debug();\n    }\n};\n\n// Pre-Build Function\ninline void build()\n{\n}\n\n// Actual Solver\ninline void solve()\n{\n    cout << fixed << setprecision(10);\n    int n;\n    cin >> n;\n    Polygon g, conv;\n    g.read(n);\n    g.getConvexGraham(conv); // Get \n    assert(conv.isConvex());\n    cout << conv.diameter() << '\\n';\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n#ifdef LOCAL\n    clock_t _begin = clock();\n#endif\n\n    build();\n    solve();\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << (double)(clock() - _begin) * 1000 / CLOCKS_PER_SEC << \"ms.\" << endl;\n#endif\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mm(a,b) memset(a,b,sizeof(a))\n#define ACCELERATE (ios::sync_with_stdio(false),cin.tie(0))\n#define pii pair<int,int>\n#define pdd pair<db,db>\n#define pll pair<long long,long long>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define rush() int T;scanf(\"%d\",&T);while(T--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define sc(a) scanf(\"%d\",&a)\n#define sc2(a,b) scanf(\"%d%d\",&a,&b)\n#define sc3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define pf(x) printf(\"%d\\n\",x)\n#define pf2(x,y) printf(\"%d %d\\n\",x,y)\n#define pf3(x,y,z) printf(\"%d %d %d\\n\",x,y,z)\n#define all(x) (x).begin(),(x).end()\n#define PI acos(-1.0)\n#define E exp(1.0)\n#define db double\n#define ll long long\n#define ld long db\n#define ull unsigned long long\n//#define io\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\n//#define gc getchar\n//char buf[1<<21],*p1=buf,*p2=buf;\n//inline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\n//inline int read()\n//{\n//    int ret=0,f=0;char c=gc();\n//    while(!isdigit(c)){if(c=='-')f=1;c=gc();}\n//    while(isdigit(c)){ret=ret*10+c-48;c=gc();}\n//    if(f)return -ret;return ret;\n//}\nconst int N=80000+5;\nconst db EPS=1e-9;\ninline int sign(db a){return a<-EPS?-1:a>EPS;}\ninline int cmp(db a,db b){return sign(a-b);}\ninline db sqr(db x){return x*x;}\nstruct Point{\n    db x,y;\n    Point(){}\n    Point(db _x,db _y):x(_x),y(_y){}\n    void input(){scanf(\"%lf%lf\",&x,&y);}\n    void output(){printf(\"%.10f %.10f\\n\",x,y);}\n    bool operator == (Point b)const{\n        return sign(x-b.x)==0&&sign(y-b.y)==0;\n    }\n    bool operator < (Point b)const{\n        return sign(x-b.x)==0?sign(y-b.y)<0:x<b.x;\n    }\n    Point operator + (const Point &b)const{\n        return Point(x+b.x,y+b.y);\n    }\n    Point operator - (const Point &b)const{\n        return Point(x-b.x,y-b.y);\n    }\n    db operator ^ (const Point &b)const{\n        return x*b.y-y*b.x;\n    }\n    db operator * (const Point &b)const{\n        return x*b.x+y*b.y;\n    }\n    db len(){return hypot(x,y);}\n    db len2(){return x*x+y*y;}\n    db distance(Point p){return hypot(x-p.x,y-p.y);}\n    Point operator * (const db &k)const{\n        return Point(x*k,y*k);\n    }\n    Point operator / (const db &k)const{\n        return Point(x/k,y/k);\n    }\n    db rad(Point a,Point b){\n        Point p=*this;\n        return fabs(atan2(fabs((a-p)^(b-p)),(a-p)*(b-p)));\n    }\n    Point unit(){return *this/len();}\n    Point trunc(db r){\n        db l=len();\n        if(!sign(l))return *this;\n        r/=l;\n        return Point(x*r,y*r);\n    }\n    Point rotleft(){return Point(-y,x);}\n    Point rotright(){return Point(y,-x);}\n    Point rotate(Point p,db angle){\n        Point v=(*this)-p;\n        db c=cos(angle),s=sin(angle);\n        return Point(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);\n    }\n};\n#define dot(p1,p2,p3) ((p2.x-p1.x)*(p3.x-p1.x)+(p2.y-p1.y)*(p3.y-p1.y))\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\nstruct Line{\n    Point s,e;\n    Line(){}\n    Line(Point _s,Point _e):s(_s),e(_e){}\n    bool operator == (Line v){\n        return (s==v.s)&&(e==v.e);\n    }\n    Line(Point p,db angle){\n        s=p;\n        if(sign(angle-PI/2)==0)e=(s+Point(0,1));\n        else e=(s+Point(1,tan(angle)));\n    }\n    Line(db a,db b,db c){\n        if(sign(a)==0){\n            s=Point(0,-c/b);e=Point(1,-c/b);\n        }else if(sign(b)==0){\n            s=Point(-c/a,0);e=Point(-c/a,1);\n        }else{\n            s=Point(0,-c/b);e=Point(1,(-c-a)/b);\n        }\n    }\n    void input(){s.input();e.input();}\n    void adjust(){if(e<s)swap(s,e);}\n    db length(){return s.distance(e);}\n    //[0,PI)\n    db angle(){\n        db k=atan2(e.y-s.y,e.x-s.x);\n        if(sign(k)<0)k+=PI;\n        if(sign(k-PI)==0)k-=PI;\n        return k;\n    }\n    //line|1 on the left|2 on the right|3 on line|\n    int relation(Point p){\n        int c=sign((p-s)^(e-s));\n        if(c<0)return 1;\n        else if(c>0)return 2;\n        else return 3;\n    }\n    bool pointonseg(Point p){\n        return sign((p-s)^(e-s))==0&&sign((p-s)*(p-e))<=0;\n    }\n    bool parallel(Line v){\n        return sign((e-s)^(v.e-v.s))==0;\n    }\n    //|0 not intersect|1 non-standard|2 intersect|\n    int segcrossseg(Line v){\n        int d1=sign((e-s)^(v.s-s));\n        int d2=sign((e-s)^(v.e-s));\n        int d3=sign((v.e-v.s)^(s-v.s));\n        int d4=sign((v.e-v.s)^(e-v.s));\n        if((d1^d2)==-2&&(d3^d4)==-2)return 2;\n        return (d1==0&&sign((v.s-s)*(v.s-e))<=0)||\n            (d2==0&&sign((v.e-s)*(v.e-e))<=0)||\n            (d3==0&&sign((s-v.s)*(s-v.e))<=0)||\n            (d4==0&&sign((e-v.s)*(e-v.e))<=0);\n    }\n    //|0 not intersect|1 non-standard|2 intersect|\n    int linecrossseg(Line v){\n        int d1=sign((e-s)^(v.s-s));\n        int d2=sign((e-s)^(v.e-s));\n        if((d1^d2)==-2)return 2;\n        return (d1==0||d2==0);\n    }\n    //|0 parallel|1 coincides|2 intersect|\n    int linecrossline(Line v){\n        if((*this).parallel(v))return v.relation(s)==3;\n        return 2;\n    }\n    //要保证两直线不平行或重合\n    Point crosspoint(Line v){\n        db a1=(v.e-v.s)^(s-v.s);\n        db a2=(v.e-v.s)^(e-v.s);\n        return Point((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1));\n    }\n    db dispointtoline(Point p){\n        return fabs((p-s)^(e-s))/length();\n    }\n    db dispointtoseg(Point p){\n        if(sign((p-s)*(e-s))<0||sign((p-e)*(s-e))<0)return min(p.distance(s),p.distance(e));\n        return dispointtoline(p);\n    }\n    //前提是两线段不相交，相交距离就是0了\n    db dissegtoseg(Line v){\n        return min(min(dispointtoseg(v.s),dispointtoseg(v.e)),min(v.dispointtoseg(s),v.dispointtoseg(e)));\n    }\n    Point lineprog(Point p){\n\t\treturn s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) );\n\t}\n\tPoint symmetrypoint(Point p){\n\t\tPoint q = lineprog(p);\n\t\treturn Point(2*q.x-p.x,2*q.y-p.y);\n\t}\n};\nstruct circle{\n    Point p;\n    db r;\n    circle(){}\n    circle(Point _p,db _r):p(_p),r(_r){}\n    circle(db _x,db _y,db _r){\n        p=Point(_x,_y);r=_r;\n    }\n    Point point(db a){\n        return Point(p.x+r*cos(a),p.y+r*sin(a));\n    }\n    //三角形的外接圆\n    circle(Point a,Point b,Point c){\n        Line u=Line((a+b)/2,((a+b)/2)+((b-a).rotleft()));\n        Line v=Line((b+c)/2,((b+c)/2)+((c-b).rotleft()));\n        p=u.crosspoint(v);\n        r=p.distance(a);\n    }\n    //三角形的内切圆\n    circle(Point a,Point b,Point c,bool t){\n        Line u,v;\n        db m=atan2(b.y-a.y,b.x-a.x),n=atan2(c.y-a.y,c.x-a.x);\n        u.s=a;\n        u.e=u.s+Point(cos((n+m)/2),sin((n+m)/2));\n        m=atan2(a.y-b.y,a.x-b.x),n=atan2(c.y-b.y,c.x-b.x);\n        v.s=b;\n        v.e=v.s+Point(cos((n+m)/2),sin((n+m)/2));\n        p=u.crosspoint(v);\n        r=Line(a,b).dispointtoseg(p);\n    }\n    void input(){\n        p.input();\n        scanf(\"%lf\",&r);\n    }\n    void output(){\n        printf(\"%2.f %.2f %.2f\\n\",p.x,p.y,p,r);\n    }\n    bool operator == (circle v){\n        return (p==v.p)&&sign(r-v.r)==0;\n    }\n    bool operator < (circle v)const{\n        return ((p<v.p)||((p==v.p)&&sign(r-v.r)<0));\n    }\n    db area(){return PI*r*r;}\n    db circumference(){return 2*PI*r;}\n    //|0 not|1 on|2 in|\n    int relation(Point b){\n        db dst=b.distance(p);\n        if(sign(dst-r)<0)return 2;\n        else if(sign(dst-r)==0)return 1;\n        return 0;\n    }\n    //|0 not|1 on|2 in|\n    int relationseg(Line v){\n        db dst=v.dispointtoseg(p);\n        if(sign(dst-r)<0)return 2;\n        else if(sign(dst-r)==0)return 1;\n        return 0;\n    }\n    int relationline(Line v){\n        db dst=v.dispointtoline(p);\n        if(sign(dst-r)<0)return 2;\n        else if(sign(dst-r)==0)return 1;\n        return 0;\n    }\n    //|1 内含|2 内切|3 相交|4 外切|5 相离|\n    int relationcircle(circle v){\n        db d=p.distance(v.p);\n        if(sign(d-r-v.r)>0)return 5;\n        if(sign(d-r-v.r)==0)return 4;\n        db l=fabs(r-v.r);\n        if(sign(d-r-v.r)<0&&sign(d-l)>0)return 3;\n        if(sign(d-l)==0)return 2;\n        if(sign(d-l)<0)return 1;\n    }\n    //|0 没有交点|1 一个交点|2 两个交点|\n    int pointcrosscircle(circle v,Point &p1,Point &p2){\n        int rel=relationcircle(v);\n        if(rel==1||rel==5)return 0;\n        db d=p.distance(v.p);\n        db l=(d*d+r*r-v.r*v.r)/(2*d);\n        db h=sqrt(r*r-l*l);\n        Point tmp=p+(v.p-p).trunc(l);\n        p1 = tmp+((v.p-p).rotleft().trunc(h));\n\t\tp2 = tmp+((v.p-p).rotright().trunc(h));\n        if(rel==2||rel==4)return 1;\n        return 2;\n    }\n    int pointcrossline(Line v,Point &p1,Point &p2){\n        if(!(*this).relationline(v))return 0;\n        Point a=v.lineprog(p);\n        db d=v.dispointtoline(p);\n        d=sqrt(r*r-d*d);\n        if(sign(d)==0){\n            p1=a;p2=a;\n            return 1;\n        }\n        p1=a+(v.e-v.s).trunc(d);\n        p2=a-(v.e-v.s).trunc(d);\n        return 2;\n    }\n    int getcircle(Point a,Point b,db r1,circle &c1,circle &c2){\n        circle x(a,r1),y(b,r1);\n        int t=x.pointcrosscircle(y,c1.p,c2.p);\n        if(!t)return 0;\n        c1.r=c2.r=r;\n        return t;\n    }\n    int getcircle(Line u,Point q,db r1,circle &c1,circle &c2){\n        db dis=u.dispointtoline(q);\n        if(sign(dis-r1*2)>0)return 0;\n        if(sign(dis)==0){\n            c1.p=q+((u.e-u.s).rotleft().trunc(r1));\n            c2.p=q+((u.e-u.s).rotright().trunc(r1));\n            c1.r=c2.r=r1;\n            return 2;\n        }\n        Line u1=Line((u.s+(u.e-u.s).rotleft().trunc(r1)),(u.e+(u.e-u.s).rotleft().trunc(r1)));\n\t\tLine u2=Line((u.s+(u.e-u.s).rotright().trunc(r1)),(u.e+(u.e-u.s).rotright().trunc(r1)));\n\t\tcircle cc = circle(q,r1);\n\t\tPoint p1,p2;\n\t\tif(!cc.pointcrossline(u1,p1,p2))cc.pointcrossline(u2,p1,p2);\n\t\tc1 = circle(p1,r1);\n\t\tif(p1 == p2){\n\t\t\tc2 = c1;\n\t\t\treturn 1;\n\t\t}\n\t\tc2 = circle(p2,r1);\n\t\treturn 2;\n    }\n    int getcircle(Line u,Line v,db r1,circle &c1,circle &c2,circle &c3,circle &c4){\n        if(u.parallel(v))return 0;//两直线平行\n\t\tLine u1=Line(u.s+(u.e-u.s).rotleft().trunc(r1),u.e+(u.e-u.s).rotleft().trunc(r1));\n\t\tLine u2=Line(u.s+(u.e-u.s).rotright().trunc(r1),u.e+(u.e-u.s).rotright().trunc(r1));\n\t\tLine v1=Line(v.s+(v.e-v.s).rotleft().trunc(r1),v.e+(v.e-v.s).rotleft().trunc(r1));\n\t\tLine v2=Line(v.s+(v.e-v.s).rotright().trunc(r1),v.e+(v.e-v.s).rotright().trunc(r1));\n\t\tc1.r=c2.r=c3.r=c4.r=r1;\n\t\tc1.p=u1.crosspoint(v1);\n\t\tc2.p=u1.crosspoint(v2);\n\t\tc3.p=u2.crosspoint(v1);\n\t\tc4.p=u2.crosspoint(v2);\n\t\treturn 4;\n    }\n    int getcircle(circle cx,circle cy,db r1,circle &c1,circle &c2){\n\t\tcircle x(cx.p,r1+cx.r),y(cy.p,r1+cy.r);\n\t\tint t=x.pointcrosscircle(y,c1.p,c2.p);\n\t\tif(!t)return 0;\n\t\tc1.r=c2.r=r1;\n\t\treturn t;\n\t}\n\tint tangentline(Point q,Line &u,Line &v){\n\t\tint x   = relation(q);\n\t\tif(x == 2)return 0;\n\t\tif(x == 1){\n\t\t\tu = Line(q,q + (q-p).rotleft());\n\t\t\tv = u;\n\t\t\treturn 1;\n\t\t}\n\t\tdb d = p.distance(q);\n\t\tdb l = r*r/d;\n\t\tdb h = sqrt(r*r-l*l);\n\t\tu = Line(q,p + ((q-p).trunc(l) + (q-p).rotleft().trunc(h)));\n\t\tv = Line(q,p + ((q-p).trunc(l) + (q-p).rotright().trunc(h)));\n\t\treturn 2;\n\t}\n\tdb areacircle(circle v){\n\t\tint rel = relationcircle(v);\n\t\tif(rel >= 4)return 0.0;\n\t\tif(rel <= 2)return min(area(),v.area());\n\t\tdb d = p.distance(v.p);\n\t\tdb hf = (r+v.r+d)/2.0;\n\t\tdb ss = 2*sqrt(hf*(hf-r)*(hf-v.r)*(hf-d));\n\t\tdb a1 = acos((r*r+d*d-v.r*v.r)/(2.0*r*d));\n\t\ta1 = a1*r*r;\n\t\tdb a2 = acos((v.r*v.r+d*d-r*r)/(2.0*v.r*d));\n\t\ta2 = a2*v.r*v.r;\n\t\treturn a1+a2-ss;\n\t}\n\tdb areatriangle(Point a,Point b){\n\t\tif(sign((p-a)^(p-b)) == 0)return 0.0;\n\t\tPoint q[5];\n\t\tint len = 0;\n\t\tq[len++] = a;\n\t\tLine l(a,b);\n\t\tPoint p1,p2;\n\t\tif(pointcrossline(l,q[1],q[2])==2){\n\t\t\tif(sign((a-q[1])*(b-q[1]))<0)q[len++] = q[1];\n\t\t\tif(sign((a-q[2])*(b-q[2]))<0)q[len++] = q[2];\n\t\t}\n\t\tq[len++] = b;\n\t\tif(len == 4 && sign((q[0]-q[1])*(q[2]-q[1]))>0)swap(q[1],q[2]);\n\t\tdb res = 0;\n\t\tfor(int i = 0;i < len-1;i++){\n\t\t\tif(relation(q[i])==0||relation(q[i+1])==0){\n\t\t\t\tdb arg = p.rad(q[i],q[i+1]);\n\t\t\t\tres += r*r*arg/2.0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres += fabs((q[i]-p)^(q[i+1]-p))/2.0;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nint getTangents(circle A,circle B,Point *a,Point *b)\n{\n    int cnt=0;        //存切点用\n    if(sign(A.r-B.r)<0){\n        swap(A,B);\n        swap(a,b);\n    }\n    db d=sqrt((A.p.x-B.p.x)*(A.p.x-B.p.x)+(A.p.y-B.p.y)*(A.p.y-B.p.y));     //圆心距\n    db rdiff=A.r-B.r;      //两圆半径差\n    db rsum=A.r+B.r;       //两圆半径和\n    if(sign(d-rdiff)<0)return 0;        //1.内含\n    db base=atan2(B.p.y-A.p.y,B.p.x-A.p.x);      //向量AB的极角\n    if(sign(d)== 0)return -1;        //2.重合\n    if(sign(d-rdiff) == 0){       //3.内切\n        a[cnt]=b[cnt]=A.point(base);\n        cnt++;\n        return 1;\n    }\n    db ang=acos((A.r-B.r)/d);\n    a[cnt]=A.point(base+ang);b[cnt]=B.point(base+ang);cnt++;      //4.相交（外切、外离的外公切线也在此求出）\n    a[cnt]=A.point(base-ang);b[cnt]=B.point(base-ang);cnt++;      //两条外公切线的切点\n    if(sign(d-rsum)==0){        //5.外切\n        a[cnt]=b[cnt]=A.point(base);\n        cnt++;\n    }\n    else if(sign(d-rsum)>0){      //6.外离\n        db ang=acos((A.r+B.r)/d);\n        a[cnt]=A.point(base+ang);b[cnt]=B.point(PI+base+ang);cnt++;\n        a[cnt]=A.point(base-ang);b[cnt]=B.point(PI+base-ang);cnt++;\n    }\n    return cnt;\n}\nstruct polygon{\n    int n;\n    Point p[N];\n    Line l[N];\n    void input(int _n){\n        n=_n;\n        rep(i,0,n-1)p[i].input();\n    }\n    void add(Point q){p[n++]=q;}\n    void getline(){rep(i,0,n-1)l[i]=Line(p[i],p[(i+1)%n]);}\n    struct cmp{\n\t\tPoint p;\n\t\tcmp(const Point &p0){p = p0;}\n\t\tbool operator()(const Point &aa,const Point &bb){\n\t\t\tPoint a = aa, b = bb;\n\t\t\tint d = sign((a-p)^(b-p));\n\t\t\tif(d == 0){\n\t\t\t\treturn sign(a.distance(p)-b.distance(p)) < 0;\n\t\t\t}\n\t\t\treturn d > 0;\n\t\t}\n\t};\n\t//极角排序\n\tvoid norm(){\n        Point mi=p[0];\n        rep(i,1,n-1)mi=min(mi,p[i]);\n        sort(p,p+n,cmp(mi));\n\t}\n\t//`得到的凸包里面的点编号是[0,n-1]的`\n\t//`注意如果有影响，要特判下所有点共点，或者共线的特殊情况`\n\tvoid getconvex(polygon &convex){\n\t\tsort(p,p+n);\n\t\tconvex.n=n;\n\t\trep(i,0,min(n,2)-1)convex.p[i]=p[i];\n\t\tif(convex.n==2&&(convex.p[0]==convex.p[1]))convex.n--;//特判\n\t\tif(n<=2)return;\n\t\tint &top=convex.n;\n\t\ttop=1;\n\t\trep(i,2,n-1){\n            while(top&&sign((convex.p[top]-p[i])^(convex.p[top-1]-p[i]))<=0)top--;\n            convex.p[++top] = p[i];\n\t\t}\n\t\tint temp=top;\n\t\tconvex.p[++top]=p[n-2];\n\t\tper(i,n-3,0){\n            while(top!=temp&&sign((convex.p[top]-p[i])^(convex.p[top-1]-p[i]))<=0)top--;\n\t\t\tconvex.p[++top]=p[i];\n\t\t}\n\t\tif(convex.n==2&&(convex.p[0]==convex.p[1]))convex.n--;//特判\n\t\tconvex.norm();//`原来得到的是顺时针的点，排序后逆时针`\n\t}\n\t//`得到凸包的另外一种方法`\n\tvoid Graham(polygon &convex){\n\t\tnorm();\n\t\tint &top=convex.n;\n\t\ttop=0;\n\t\tif(n==1){\n\t\t\ttop=1;\n\t\t\tconvex.p[0]=p[0];\n\t\t\treturn;\n\t\t}\n\t\tif(n==2){\n\t\t\ttop=2;\n\t\t\tconvex.p[0]=p[0];\n\t\t\tconvex.p[1]=p[1];\n\t\t\tif(convex.p[0]==convex.p[1])top--;\n\t\t\treturn;\n\t\t}\n\t\tconvex.p[0]=p[0];\n\t\tconvex.p[1]=p[1];\n\t\ttop=2;\n\t\trep(i,2,n-1){\n            while(top>1&&sign((convex.p[top-1]-convex.p[top-2])^(p[i]-convex.p[top-2]))<=0)top--;\n\t\t\tconvex.p[top++]=p[i];\n\t\t}\n\t\tif(convex.n==2&&(convex.p[0]==convex.p[1]))convex.n--;//特判\n\t}\n\t//`判断是不是凸的`\n\tbool isconvex(){\n\t\tbool s[2];\n\t\tmemset(s,false,sizeof(s));\n\t\trep(i,0,n-1){\n            int j=(i+1)%n;\n\t\t\tint k=(j+1)%n;\n\t\t\ts[sign((p[j]-p[i])^(p[k]-p[i]))+1]=true;\n\t\t\tif(s[0]&&s[2])return false;\n\t\t}\n\t\treturn true;\n\t}\n\t//`判断点和任意多边形的关系`\n\t//|` 0 外部`|` 1 内部`|` 2 边上`|` 3 点上`|\n\tint relationpoint(Point q){\n\t    rep(i,0,n-1){\n            if(p[i]==q)return 3;\n\t    }\n\t\tgetline();\n\t\trep(i,0,n-1){\n            if(l[i].pointonseg(q))return 2;\n\t\t}\n\t\tint cnt=0;\n\t\trep(i,0,n-1){\n            int j=(i+1)%n;\n\t\t\tint k=sign((q-p[j])^(p[i]-p[j]));\n\t\t\tint u=sign(p[i].y-q.y);\n\t\t\tint v=sign(p[j].y-q.y);\n\t\t\tif(k>0&&u<0&&v>=0)cnt++;\n\t\t\tif(k<0&&v<0&&u>=0)cnt--;\n\t\t}\n\t\treturn cnt!=0;\n\t}\n    //`直线u切割凸多边形左侧`\n\t//`注意直线方向`\n\tvoid convexcut(Line u,polygon &po){\n\t\tint &top = po.n;//注意引用\n\t\ttop = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint d1 = sign((u.e-u.s)^(p[i]-u.s));\n\t\t\tint d2 = sign((u.e-u.s)^(p[(i+1)%n]-u.s));\n\t\t\tif(d1 >= 0)po.p[top++] = p[i];\n\t\t\tif(d1*d2 < 0)po.p[top++] = u.crosspoint(Line(p[i],p[(i+1)%n]));\n\t\t}\n\t}\n\t//\t//`得到周长`\n//\t//`测试 LightOJ1239`\n\tdb getcircumference(){\n\t\tdb sum = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tsum += p[i].distance(p[(i+1)%n]);\n\t\t}\n\t\treturn sum;\n\t}\n\t//`得到面积`\n\tdb getarea(){\n\t\tdb sum = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tsum += (p[i]^p[(i+1)%n]);\n\t\t}\n\t\treturn fabs(sum)/2;\n\t}\n\t//\t//`得到方向`\n//\t//` 1 表示逆时针，0表示顺时针`\n\tbool getdir(){\n\t\tdb sum = 0;\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tsum += (p[i]^p[(i+1)%n]);\n\t\tif(sign(sum) > 0)return 1;\n\t\treturn 0;\n\t}\n\t//\t//`得到重心`\n\tPoint getbarycentre(){\n\t\tPoint ret(0,0);\n\t\tdb area = 0;\n\t\tfor(int i = 1;i < n-1;i++){\n\t\t\tdb tmp = (p[i]-p[0])^(p[i+1]-p[0]);\n\t\t\tif(sign(tmp) == 0)continue;\n\t\t\tarea += tmp;\n\t\t\tret.x += (p[0].x+p[i].x+p[i+1].x)/3*tmp;\n\t\t\tret.y += (p[0].y+p[i].y+p[i+1].y)/3*tmp;\n\t\t}\n\t\tif(sign(area)) ret = ret/area;\n\t\treturn ret;\n\t}\n\t//\t//`多边形和圆交的面积`\n\tdb areacircle(circle c){\n\t\tdb ans = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint j = (i+1)%n;\n\t\t\tif(sign( (p[j]-c.p)^(p[i]-c.p) ) >= 0)\n\t\t\t\tans += c.areatriangle(p[i],p[j]);\n\t\t\telse ans -= c.areatriangle(p[i],p[j]);\n\t\t}\n\t\treturn fabs(ans);\n\t}\n    //`多边形和圆关系`\n\t//` 2 圆完全在多边形内`\n\t//` 1 圆在多边形里面，碰到了多边形边界`\n\t//` 0 其它`\n\tint relationcircle(circle c){\n\t\tgetline();\n\t\tint x = 2;\n\t\tif(relationpoint(c.p) != 1)return 0;//圆心不在内部\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(c.relationseg(l[i])==2)return 0;\n\t\t\tif(c.relationseg(l[i])==1)x = 1;\n\t\t}\n\t\treturn x;\n\t}\n};\n//旋转卡壳，计算凸包直径\n//db rc(polygon ans)\n//{\n//    db res=0;\n//    int n=ans.n;\n//    cout<<\"yes\"<<endl;\n//    int k=1;\n//    for(int i=0;i<n;i++){\n//        while(sign(cross(ans.p[i],ans.p[(i+1)%n],ans.p[(k+1)%n])-cross(ans.p[i],ans.p[(i+1)%n],ans.p[k%n]))==1)k=(k+1)%n;\n//        res=max(res,(ans.p[i]-ans.p[k]).len());\n//    }\n//    return res;\n//}\ndb RC(polygon v)\n{\n    db res=0;\n    int n=v.n;\n    int k=1;\n    rep(i,0,n-1){\n        while(sign(cross(v.p[i],v.p[(i+1)%n],v.p[(k+1)%n])-cross(v.p[i],v.p[(i+1)%n],v.p[k%n]))==1)k=(k+1)%n;\n        res=max(res,max((v.p[i]-v.p[k]).len(),(v.p[(i+1)%n]-v.p[k]).len()));\n    }\n    return res;\n}\n//`最小矩形面积覆盖`\n//` A 必须是凸包(而且是逆时针顺序)`\ndb minRectangleCover(polygon A){\n\t//`要特判A.n < 3的情况`\n\tif(A.n < 3)return 0.0;\n\tA.p[A.n] = A.p[0];\n\tdb ans = -1;\n\tint r = 1, p = 1, q;\n\tfor(int i = 0;i < A.n;i++){\n\t\t//`卡出离边A.p[i] - A.p[i+1]最远的点`\n\t\twhile( sign( cross(A.p[i],A.p[i+1],A.p[r+1]) - cross(A.p[i],A.p[i+1],A.p[r]) ) >= 0 )\n\t\t\tr = (r+1)%A.n;\n\t\t//`卡出A.p[i] - A.p[i+1]方向上正向n最远的点`\n\t\twhile(sign( dot(A.p[i],A.p[i+1],A.p[p+1]) - dot(A.p[i],A.p[i+1],A.p[p]) ) >= 0 )\n\t\t\tp = (p+1)%A.n;\n\t\tif(i == 0)q = p;\n\t\t//`卡出A.p[i] - A.p[i+1]方向上负向最远的点`\n\t\twhile(sign(dot(A.p[i],A.p[i+1],A.p[q+1]) - dot(A.p[i],A.p[i+1],A.p[q])) <= 0)\n\t\t\tq = (q+1)%A.n;\n\t\tdb d = (A.p[i] - A.p[i+1]).len2();\n\t\tdb tmp = cross(A.p[i],A.p[i+1],A.p[r]) *\n\t\t\t(dot(A.p[i],A.p[i+1],A.p[p]) - dot(A.p[i],A.p[i+1],A.p[q]))/d;\n\t\tif(ans < 0 || ans > tmp)ans = tmp;\n\t}\n\treturn ans;\n}\n//`直线切凸多边形`\n//`多边形是逆时针的，在q1q2的左侧`\n//`测试:HDU3982`\nvector<Point> convexCut(const vector<Point> &ps,Point q1,Point q2){\n\tvector<Point>qs;\n\tint n = ps.size();\n\tfor(int i = 0;i < n;i++){\n\t\tPoint p1 = ps[i], p2 = ps[(i+1)%n];\n\t\tint d1 = sign((q2-q1)^(p1-q1)), d2 = sign((q2-q1)^(p2-q1));\n\t\tif(d1 >= 0)\n\t\t\tqs.push_back(p1);\n\t\tif(d1 * d2 < 0)\n\t\t\tqs.push_back(Line(p1,p2).crosspoint(Line(q1,q2)));\n\t}\n\treturn qs;\n}\n//`半平面交`\n//`测试 POJ3335 POJ1474 POJ1279`\n//***************************\nstruct halfplane:public Line{\n\tdb angle;\n\thalfplane(){}\n\t//`表示向量s->e逆时针(左侧)的半平面`\n\thalfplane(Point _s,Point _e){\n\t\ts = _s;\n\t\te = _e;\n\t}\n\thalfplane(Line v){\n\t\ts = v.s;\n\t\te = v.e;\n\t}\n\tvoid calcangle(){\n\t\tangle = atan2(e.y-s.y,e.x-s.x);\n\t}\n\tbool operator <(const halfplane &b)const{\n\t\treturn angle < b.angle;\n\t}\n};\nstruct halfplanes{\n\tint n;\n\thalfplane hp[N];\n\tPoint p[N];\n\tint que[N];\n\tint st,ed;\n\tvoid push(halfplane tmp){\n\t\thp[n++] = tmp;\n\t}\n\t//去重\n\tvoid unique(){\n\t\tint m = 1;\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tif(sign(hp[i].angle-hp[i-1].angle) != 0)\n\t\t\t\thp[m++] = hp[i];\n\t\t\telse if(sign( (hp[m-1].e-hp[m-1].s)^(hp[i].s-hp[m-1].s) ) > 0)\n\t\t\t\thp[m-1] = hp[i];\n\t\t}\n\t\tn = m;\n\t}\n\tbool halfplaneinsert(){\n\t\tfor(int i = 0;i < n;i++)hp[i].calcangle();\n\t\tsort(hp,hp+n);\n\t\tunique();\n\t\tque[st=0] = 0;\n\t\tque[ed=1] = 1;\n\t\tp[1] = hp[0].crosspoint(hp[1]);\n\t\tfor(int i = 2;i < n;i++){\n\t\t\twhile(st<ed && sign((hp[i].e-hp[i].s)^(p[ed]-hp[i].s))<0)ed--;\n\t\t\twhile(st<ed && sign((hp[i].e-hp[i].s)^(p[st+1]-hp[i].s))<0)st++;\n\t\t\tque[++ed] = i;\n\t\t\tif(hp[i].parallel(hp[que[ed-1]]))return false;\n\t\t\tp[ed]=hp[i].crosspoint(hp[que[ed-1]]);\n\t\t}\n\t\twhile(st<ed && sign((hp[que[st]].e-hp[que[st]].s)^(p[ed]-hp[que[st]].s))<0)ed--;\n\t\twhile(st<ed && sign((hp[que[ed]].e-hp[que[ed]].s)^(p[st+1]-hp[que[ed]].s))<0)st++;\n\t\tif(st+1>=ed)return false;\n\t\treturn true;\n\t}\n\t//`得到最后半平面交得到的凸多边形`\n\t//`需要先调用halfplaneinsert() 且返回true`\n\tvoid getconvex(polygon &con){\n\t\tp[st] = hp[que[st]].crosspoint(hp[que[ed]]);\n\t\tcon.n = ed-st+1;\n\t\tfor(int j = st,i = 0;j <= ed;i++,j++)\n\t\t\tcon.p[i] = p[j];\n\t}\n};\npolygon g,r;\nint main()\n{\n    int x;\n    scanf(\"%d\",&x);\n    g.input(x);\n    g.getconvex(r);\n    printf(\"%.10f\\n\",RC(r));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntypedef complex<double> point;\ntypedef vector<point> vertex;\n/*\nx 座標は p.real(), real(p), y 座標は p.imag(), imag(p) とする．\n足し算，引き算，スカラー倍は定義済み．\noperator < は入っていないので自分で namespace std に突っ込む．*/\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n// 線分と点との距離\ndouble dist_linesegment_and_point(point a1,point a2,point b);\n\n\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : |a×b| = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n//ラジアンに変換\ndouble radian(double angle){\n    return angle/180.0*M_PI;\n}\n//度数に変換\ndouble degree(double radian){\n    return radian*180.0/M_PI;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n    return (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS) and\n    (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n\n}\n\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(point a1,point a2,point b1,point b2) {\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// 線分同士の最短距離\ndouble dist_linesegment_and_linesegment(point a1,point a2,point b1,point b2){\n    if(is_intersected_linesegment(a1,a2,b1,b2)){\n        return 0;\n    }\n    return min(min(dist_linesegment_and_point(a1,a2,b1),\n               dist_linesegment_and_point(a1,a2,b2)),\n    min(dist_linesegment_and_point(b1,b2,a1),\n        dist_linesegment_and_point(b1,b2,a2)));\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// verify\nbool is_orthogonal(point a1,point a2,point b1,point b2) {\n    return abs(dot(a1-a2,b1-b2))< EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n//verify\nbool is_parallel(point a1,point a2,point b1,point b2) {\n    return abs(cross(a2-a1,b2-b1)) < EPS;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_line(point a1,point a2,point b1,point b2) {\n    return not is_parallel(a1,a2,b1,b2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_line(point a1,point a2,point b1,point b2) {\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 直線と点との距離\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\n// 線分と点との距離\ndouble dist_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return abs(b-a1);\n    if(dot(a1-a2,b-a2) < EPS) return abs(b-a2);\n    return dist_line_and_point(a1,a2,b);\n}\n\n// 直線と点の最短距離を実現する直線の点(すいせんの足)(みけんしょう)\npoint nearest_point_line_and_point(point a1,point a2,point b){\n    return a1 + (a2-a1) * dot((a2-a1),(b-a1)) / norm(a2-a1);\n}\n\n// 線分と点の最短距離を実現する線分嬢の点(みけんしょう)\npoint nearest_point_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return a1;\n    if(dot(a1-a2,b-a2) < EPS) return a2;\n    return nearest_point_line_and_point(a1,a2,b);\n}\n// 円と線分の交差判定\nbool is_cross_linesegment_and_circle(point c,double r,point a1,point a2){\n    return (dist_linesegment_and_point(a1,a2,c) < r+EPS and\n            (r < abs(c-a1) + EPS or r < abs(c-a2) + EPS));\n}\n\n//線の進行方向\nint ccw(point p0, point p1, point p2)\n{\n    point a = p1 - p0;\n    point b = p2 - p0;\n    if (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n    if (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n    if (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n    if (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n    return (0); //p0--p2--p1 の順で一直線上\n}\n\n// 点が真に多角形(凸?)の中にはいっているか\nbool is_inner_point_vertex(const vector<point> &ps,point a){\n    int cc = ccw(ps[0],ps[1],a);\n    if(not(cc == 1 or cc == -1)) return false;\n    for(size_t i=0;i<ps.size();i++){\n        if(cc != ccw(ps[i],ps[(i+1)%ps.size()],a)) return false;\n    }\n    return true;\n}\n\n// 点が辺上、もしくは内部にある。(未検証)\nbool is_inner_point_vertex_or_line(const vector<point> &ps,point a){\n    for(size_t i=0;i<ps.size();i++){\n        if(dist_linesegment_and_point(ps[i],ps[(i+1)%ps.size()],a) < EPS){\n            return true;\n        }\n    }\n    return is_inner_point_vertex(ps,a);\n}\n\n\n// 凸包 (UVA 109)\nvector<point> convex_hull(vector<point> ps){\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(),ps.end());\n    vector<point> ch(2*n);\n    for(int i=0;i<n;ch[k++] = ps[i++]){//lower-hull\n        while(k >= 2 and ccw(ch[k-2],ch[k-1],ps[i]) ==-1) --k;\n    }\n    for(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--]){//upper-hull\n        while(k >= t and ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\n// remember,pts make convex.\n// (http://judge.u-aizu.ac.jp/onlinejudge/cdescription.jsp?cid=ACAC002&pid=C)\ndouble convex_diameter(const vector<point>& pts){\n    const int n = pts.size();\n    int is=0,js=0; // initial antipode.\n    for(int i=1;i<n;i++){\n        if(pts[i].imag() > pts[is].imag()) is = i;\n        if(pts[i].imag() < pts[js].imag()) js = i;\n    }\n    double maxd = abs(pts[is]-pts[js]);\n    int i,j,maxi,maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if(cross(pts[(i+1)%n]-pts[i],\n           pts[(j+1)%n]-pts[j]) >= 0){\n            j = (j+1)%n;\n    }else{\n        i = (i+1)%n;\n    }\n    if(abs(pts[i]-pts[j]) > maxd){\n        maxd = abs(pts[i]-pts[j]);\n        maxi = i;maxj = j;\n    }\n} while(not(i == is and j == js));\n    // pts[maxi],pts[maxj] is pair of max diff.\nreturn maxd;\n}\n\n// 円と円の交点(2点ある前提)\nvector<point> circles_point(point c1,double r1,point c2,double r2){\n    double d = abs(c1-c2);\n    double s = (r1+r2+d) / 2;\n    double S = sqrt(s*(s-r1)*(s-r2)*(s-d));\n    double h = 2 * S / d;\n    point v = (c2-c1) / (abs(c2-c1));\n\n    double m = sqrt(r1*r1 - h*h);\n\n    vector<point> ret;\n    ret.push_back(c1 + m*v+h*v*point(0,1));\n    ret.push_back(c1 + m*v-h*v*point(0,1));\n    return ret;\n}\n\n// clockwiseだと負\ndouble triangle_area(point a,point b,point c){\n    return cross(b-a,c-a)/2;\n}\n\n// clockwiseだと負\ndouble vertex_area(vector<point> v){\n    double ret = 0;\n    for(int i=1;i<v.size()-1;i++){\n        ret += triangle_area(v[0],v[i],v[i+1]);\n    }\n    return ret;\n}\n/*多角形の面積を求める*/\n//verify\ndouble area_vertex(const vertex& g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n//円同士が互いに含まれているかどうか\n//中心が(xa,ya)で半径r1の円Aと、中心が(xb,yb) で半径 r2 の円 B が与えられたとき、 B が A の中にあるとき 2、A が B の中にあるとき -2、A の円周と B の円周が交わっている場合 1、A と B が重なっていないとき 0 \n//verify\nint Circles_Intersection(point a,double r1,point b,double r2){\n    double dp =abs(a-b);//中心間の距離\n    double dr =r1+r2;//円の半径の合計\n    if(dp >dr){\n        return 0;\n    }else if(dp +r1 <r2){\n        return -2;\n    }else if(dp +r2 <r1){\n        return 2;\n    }else if(dp <=dr){\n        return 1;\n    }\n    return -100;\n}\npoint projection(point p1, point p2, point p3) //直線p1p2 上への写像の点\n{\n    double t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n    return (p1 + (p2 - p1) * t);\n}\npoint reflection(point p1, point p2, point p3) //直線p1p2 上への反射した点(線分p1p2に対してp3を線対称)\n{\n\n    return (p3 + 2.0*(projection(p1, p2, p3) - p3));\n}\n//凸性判定\n/*与えられた多角形 P が凸かどうかを判定する．一周回ってみて，右向きの辺がないことを確かめればよい*/\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(vertex &P) {\n\n    for (int i = 0; i < P.size(); ++i){\n        int d =ccw(prev(P, i), curr(P, i), next(P, i));\n        if(d==-1) return false;\n    }\n    return true;\n}\nbool cmp1(const point &left,const point &right){\n    if(left.imag()==right.imag()){\n        return left.real() <right.real();\n    }\n    return left.imag()<right.imag();\n}\nint main(){\n    int n;\n    cin>>n;\n    vertex g;\n    for(int i =0;i < n;i++){\n        double x,y;\n        cin>>x>>y;\n        point a(x,y);\n        g.push_back(a);\n    }\n    double ans = convex_diameter(g);\n    printf(\"%.9f\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\n//外積\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\n//内積\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\n//線 (線分)\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//多角形\ntypedef vector<P> G;\n\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  printf(\"%.10lf\\n\", convex_diameter(g));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<class T>\nstruct Vec2\n{\n\tVec2(){}\n\tVec2(T _x, T _y) : x(_x), y(_y) {}\n\n\tVec2 operator+(const Vec2& rhs) const { return Vec2(x + rhs.x, y + rhs.y); }\n\tVec2 operator-(const Vec2& rhs) const { return Vec2(x - rhs.x, y - rhs.y); }\n\tVec2 operator*(T s) const { return Vec2(x*s, y*s); }\n\tT dot(const Vec2& rhs) const { return x*rhs.x + y*rhs.y; }\n\tT cross(const Vec2& rhs) const { return x*rhs.y - y*rhs.x; }\n\tT sqlength() const { return x*x + y*y; }\n\tbool operator<(const Vec2& rhs) const\n\t{\n\t\tif (x != rhs.x) return x < rhs.x;\n\t\treturn y < rhs.y;\n\t}\n\n\tT x;\n\tT y;\n};\n\ntypedef Vec2<double> VecD;\n\ntemplate<class T>\nT cross(const Vec2<T> &O, const Vec2<T> &A, const Vec2<T> &B)\n{\n\treturn (A - O).cross(B - O);\n}\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tstatic VecD P[80000];\n\tint iMinY = 0, iMaxY = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%lf%lf\", &P[i].x, &P[i].y);\n\t\tif (P[i].y > P[iMaxY].y) {\n\t\t\tiMaxY = i;\n\t\t}\n\t\tif (P[i].y < P[iMinY].y) {\n\t\t\tiMinY = i;\n\t\t}\n\t}\n\n\tint i = iMaxY, j = iMinY;\n\tdouble diameter = (P[iMaxY] - P[iMinY]).sqlength();\n\tdo {\n\t\tint i2 = (i + 1) % N, j2 = (j + 1) % N;\n\t\tdouble aadVecDir[2][2] = { 0 };\n\t\tVecD dir0 = P[i2] - P[i];\n\t\tVecD dir1 = P[j2] - P[j];\n\t\tif (dir0.cross(dir1) > 0) {\n\t\t\tj = j2;\n\t\t}\n\t\telse {\n\t\t\ti = i2;\n\t\t}\n\n\t\tdouble dDist = (P[i] - P[j]).sqlength();\n\t\tif (dDist > diameter) {\n\t\t\tdiameter = dDist;\n\t\t}\n\t} while (i != iMaxY || j != iMinY);\n\n\tprintf(\"%.10lf\\n\", sqrt(diameter));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define FOREACH(i,Itr) for(auto (i)=(Itr).begin();(i)!=(Itr).end();(i)++)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define PB_VEC(Itr1,Itr2) (Itr1).insert((Itr1).end(),(Itr2).begin(),(Itr2).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\n#define EPS 1.0e-8\n#define MOD 1000000007\ntypedef long long ll;\n\nstruct Point {\n    double x,y;\n    Point(){}\n    Point(double _x, double _y):x(_x),y(_y){}\n    bool operator < (const Point &a) const {\n        return (x==a.x) ? (y<a.y) : (x<a.x);\n    }\n};\nPoint operator +(const Point &a,const Point &b){return Point(a.x+b.x,a.y+b.y);}\nPoint operator -(const Point &a,const Point &b){return Point(a.x-b.x,a.y-b.y);}\nPoint operator *(const Point &a,double k){return Point(a.x*k,a.y*k);}\n\nstruct Segment {\n    Point p1,p2;\n    Segment(){}\n    Segment(Point _p1, Point _p2):p1(_p1),p2(_p2){}\n    Segment(double x1, double y1, double x2, double y2)\n    :p1(Point(x1,y1)),p2(Point(x2,y2)){}\n};\n\nstruct Circle {\n    Point c; double r;\n    Circle(){}\n    Circle(Point _c, double _r):c(_c),r(_r){}\n    Circle(double x, double y, double _r):c(Point(x,y)),r(_r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b){return a.x*b.x + a.y*b.y;}\ndouble cross(Vector a, Vector b){return a.x*b.y - a.y*b.x;}\ndouble norm(Vector a){return sqrt(dot(a,a)*dot(a,a));}\n\nPoint Project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint Reflect(Segment s, Point p) {\n    return p + (Project(s,p) - p) * 2.0;\n}\n\ndouble DistanceLinePoint(Line s, Point p) {\n    Vector dist = Project(s,p) - p;\n    return sqrt(norm(dist));\n}\n\ndouble DistanceSegmentPoint(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p -s.p1)<0.0)return sqrt(norm(p - s.p1));\n    if(dot(s.p1 - s.p2, p -s.p2)<0.0)return sqrt(norm(p - s.p2));\n    return DistanceLinePoint(s,p);\n}\n\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\nint CounterClockwise(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b)>1.0e-8)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-1.0e-8)return CLOCKWISE;\n    if(dot(a,b)<-1.0e-8)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool Intersect(Point p1, Point p2, Point p3, Point p4) {\n   return (CounterClockwise(p1,p2,p3) * CounterClockwise(p1,p2,p4) <= 0 &&\n           CounterClockwise(p3,p4,p1) * CounterClockwise(p3,p4,p2) <= 0);\n}\n\nbool Intersect(Segment s1, Segment s2) {\n    return Intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint CrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1 - s2.p1));\n    double d2 = abs(cross(base,s1.p2 - s2.p1));\n    double t = d1 / (d1+d2);\n    return s1.p1 + (s1.p2-s1.p1) * t;\n}\n\nPolygon ConvexHull(vector<Point> pos) {\n    int n = (int)pos.size(), k = 0;\n    sort(pos.begin(),pos.end());\n    Polygon ch(2*n);\n    for(int i=0;i<n;ch[k++]=pos[i++])\n        while(k>=2 && CounterClockwise(ch[k-2],ch[k-1],pos[i])<=0)--k;\n    for(int i=n-2,t=k+1;i>=0;ch[k++]=pos[i--])\n        while(k>=t && CounterClockwise(ch[k-2],ch[k-1],pos[i])<=0)--k;\n    ch.resize(k-1);\n    return ch;\n}\n\ndouble ConvexDiameter(Polygon &pos) {\n    int n = (int)pos.size();\n    int is = 0, js = 0;\n    for(int i=1;i<n;++i) {\n        if (pos[i].y > pos[is].y) is = i;\n        if (pos[i].y < pos[js].y) js = i;\n    }\n    double maxd = norm(pos[is]-pos[js]);\n    \n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if(cross(pos[(i+1)%n]-pos[i],pos[(j+1)%n]-pos[j])>=0)j=(j+1)%n;\n        else i=(i+1)%n;\n        if(norm(pos[i]-pos[j]) > maxd) {\n            maxd = norm(pos[i]-pos[j]);\n            maxi = i; maxj = j;\n        }\n    }while(i!=is || j!=js);\n    return sqrt(maxd);\n}\n\nint main(){\n    \n    int n; cin>>n;\n    vector<Point> pos(n);\n    REP(i,n)cin>>pos[i].x>>pos[i].y;\n    \n    Polygon p = ConvexHull(pos);\n    cout<<fixed<<setprecision(10)<<ConvexDiameter(p)<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n\ndouble area(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto n = vs.size();\n    auto vx1 = std::get<0>(vs[(p+1) % n]) - std::get<0>(vs[p]);\n    auto vy1 = std::get<1>(vs[(p+1) % n]) - std::get<1>(vs[p]);\n\n    auto vx2 = std::get<0>(vs[(q+1) % n]) - std::get<0>(vs[q]);\n    auto vy2 = std::get<1>(vs[(q+1) % n]) - std::get<1>(vs[q]);\n\n    return std::abs( vx1 * vy2 - vx2 * vy1 );\n}\n\ndouble len2(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto dx = std::get<0>(vs[p]) - std::get<0>(vs[q]);\n    auto dy = std::get<1>(vs[p]) - std::get<1>(vs[q]);\n\n    return dx*dx + dy*dy;\n}\n\nint main() {\n    int64_t n;\n\n    std::cin >> n;\n    \n    std::vector<std::tuple<double, double> > vs(n);\n\n    int64_t p = 0, q = 0;\n    for (int64_t i = 0; i < n; ++i) {\n        std::cin >> std::get<0>(vs[i]) >> std::get<1>(vs[i]);\n\n        if (std::get<0>(vs[i]) < std::get<0>(vs[p])) {\n            p = i;\n        }\n        if (std::get<0>(vs[i]) > std::get<0>(vs[q])) {\n            q = i;\n        }\n    }\n\n    double ans = len2(vs, p, q);\n    for (int64_t i = 0; i < 2*n; ++i) {\n        if (area(vs, p, q) > 0) {\n            q = (q+1) % n;\n        } else {\n            p = (p+1) % n;\n        }\n        ans = std::max(ans, len2(vs, p, q));\n    }\n\n    std::cout << std::fixed << std::setprecision(12) << std::sqrt(ans) << std::endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int int64;\nconst double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n  \nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n  \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n  \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n  \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < -EPS)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n  \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n  \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n  double Convex_Diameter(Polygon& p){\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = ( p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross( next( p, i) - curr( p, i), next( p, j) - curr( p, j)) >= 0){\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if(( p[i] - p[j]).norm() > maxdis){\n        maxdis = ( p[i] - p[j]).norm();\n        maxi = i; maxj = j;\n      }\n    }  while (i != is || j != js);\n    return maxdis;\n  }\n};\n\nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n  Geometory::Polygon g(n);\n  for(int i = 0; i < n; i++){\n    scanf(\"%lf %lf\", &g[i].x, &g[i].y);\n  }\n  printf(\"%.10lf\\n\", sqrt(geo.Convex_Diameter(g)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ntypedef Point Vector;\n\nVector normal(Point p0, Point p1); //ベクトルp0p1の法線ベクトル\nint argmax(const vector<double> &v); //std::vectorのargmax関数\n\nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int n;\n    cin >> n;\n    vector<Point> data(n);\n\n    for(int i=0; i<n; i++){\n        cin >> data[i].x >> data[i].y;\n    }\n\n    Point p0, p1;\n    Vector nv;\n    vector<double> xNormalNoDup(0);\n    vector<Vector> normalVector(0);\n    xNormalNoDup.reserve(n);\n    normalVector.reserve(n);\n    map<double, int> isSwitchVertex;\n\n    for(int i=0; i<n; i++){\n        p0 = data[i];\n        p1 = data[(i+1)%n];\n        nv = normal(p0, p1);\n        normalVector.push_back(nv);\n        if (nv.y > 0 || nv.x == 1) isSwitchVertex[ nv.x ] += 1;\n        else isSwitchVertex[ -nv.x ] -= 1;\n    }\n\n    //Extract keys of isSwitchVertex and sort\n    for(map<double,int>::iterator it = isSwitchVertex.begin(); it != isSwitchVertex.end(); ++it) {\n        xNormalNoDup.push_back(it->first);\n    }\n    sort(xNormalNoDup.begin(), xNormalNoDup.end());\n\n    //find the first pair\n    int pairIndex0 = -1; //upside\n    int pairIndex1 = -1; //downside\n    Vector nv0, nv1;\n    for(int i=0; i<n; i++){\n        nv0 = normalVector[i];\n        nv1 = normalVector[(i+1)%n];\n        if( nv0.y<0 && nv1.y>=0 ) pairIndex0 = (i+1)%n;\n        if( nv0.y>=0 && nv1.y<0 ) pairIndex1 = (i+1)%n;\n    }\n    if(pairIndex0<0 || pairIndex1<0) cout << \"ERROR: Pair Initialization failed.\";\n\n    double maxDiameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n    double diameter = 0;\n\n    for(int i=0; i<xNormalNoDup.size(); i++){\n        switch( isSwitchVertex[ xNormalNoDup[i] ] ) {\n            case 1:  pairIndex0 += 1;\n                     break;\n            case -1: pairIndex1 += 1;\n                     break;\n            case 0:  pairIndex0 += 1;\n                     pairIndex1 += 1;\n                     break;\n            default: cout << \"Error: Next pair not found.\" << endl;\n                     break;\n        }\n        diameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n        maxDiameter = (diameter > maxDiameter)? diameter: maxDiameter;\n    }\n\n    cout << setprecision(14) << maxDiameter << endl;\n\n    return 0;\n}\n\nVector normal(Point p0, Point p1){\n    Vector nv;\n    nv.x = - ( p1.y - p0.y );\n    nv.y = p1.x - p0.x;\n    double a = nv.abs();\n    return nv / a;\n}\n\nint argmax(const vector<double> &v){\n    return distance(v.begin(), max_element(v.begin(), v.end()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\n#include<complex>\nusing namespace std;\n\n#define curr(G, i) G[i%n]\n#define next(G, i) G[(i+1)%n]\n\ntypedef complex<double> P;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P &a, const P &b){\n    return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > 0) return +1;\n    if(cross(b,c) < 0) return -1;\n    if(dot(b,c) < 0) return +2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\ndouble diameterOfAConvexPolygon(vector<P> &G){\n    int n = G.size();\n\n    int k;\n    for (k=1;k<n;k++){\n       if(norm(G[0] - curr(G, k)) > norm(G[0] - next(G, k))) break;\n    }\n\n    int j = 0;\n    double res = 0;\n    while(j<n+1){\n        //cout << j << \" \" << k << endl;\n        //cout << sqrt(norm(curr(G, j)-curr(G, k))) << endl;\n        res = max(res, sqrt(norm(curr(G, j)-curr(G, k))));\n        P p = next(G, j) - curr(G, j);\n        P q = next(G, k) - curr(G, k);\n        if (cross(p, q) >= 0){\n            k++;\n        }else{\n            j++;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<P> G;\n    for (int i=0;i<n;i++){\n        P p;\n        cin >> p.real() >> p.imag();\n        G.push_back(p);\n    }\n\n    printf(\"%.7f\\n\", diameterOfAConvexPolygon(G));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\n//?????¢?????¢???\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\nint main(){\n  int n,c=0;\n  Polygon p,a;\n  Point s;\n  double d[100000];\n  cin>>n;\n  while(n--){\n    cin>>s.x>>s.y;\n    p.push_back(s);\n  }\n  a=andrewScan(p);\n  r(i,a.size())\n  for(int j=i+1;j<a.size();j++)\n    d[c++]=getDistancePP(a[i],a[j]);\n  sort(d,d+c);\n  printf(\"%.11f\\n\",d[c-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nusing ld = long double;\nusing Point = std::complex<ld>;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n    if (lhs.real() < rhs.real() - eps)\n        return true;\n    if (lhs.real() > rhs.real() + eps)\n        return false;\n    return lhs.imag() < rhs.imag();\n}\n} // namespace std\n\nPoint input_point()\n{\n    ld x, y;\n    std::cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b)\n{\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b)\n{\n    return imag(conj(a) * b);\n}\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps)\n        return 1; // a,b,c : counter-clockwise\n    if (cross(b, c) < -eps)\n        return -1; // a,b,c : clockwise\n    if (dot(b, c) < 0)\n        return 2; // c,a,b : on a line\n    if (norm(b) < norm(c))\n        return -2; // a,b,c : on a line\n    return 0;      // a,c,b : on a line\n}\n\nclass Line\n{\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Line l, Line m)\n{\n    return dot((l.a - l.b), (m.a - m.b));\n}\n\nclass Circle\n{\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// l:line, m:line が交点を持つか\nbool isis_ll(Line l, Line m)\n{\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// l:line, s:segment\nbool isis_ls(Line l, Line s)\n{\n    return isis_ll(l, s) &&\n           (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// s:segment, t:segment\nbool isis_ss(Line s, Line t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// p が l:line 上に存在するか\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p)\n{\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// p から l に下ろした足との交点\nPoint proj(Line l, Point p)\n{\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// l:line, t:line の交点\nPoint is_ll(Line l, Line m)\n{\n    Point lv = l.b - l.a, mv = m.b - m.a;\n    assert(cross(lv, mv) != 0);\n    return l.a + lv * cross(mv, m.a - l.a) / cross(mv, lv);\n}\n\n// p, l:line の距離\nld dist_lp(Line l, Point p)\n{\n    return abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : std::min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n    if (isis_ss(s, t))\n        return 0;\n    return std::min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n// a, b の垂直二等分線. a -> b を90度反時計回り回転\nLine bisector(Point a, Point b)\n{\n    Point mid = (a + b) * Point(0.5, 0);\n    return Line(mid, mid + (b - a) * Point(0, pi / 2));\n}\n\n// 直線 l, m のなす角を求める\nld degree_ll(Line l, Line m)\n{\n    ld cos_shita = dot(l, m) / (abs(l.b - l.a) * abs(m.b - m.a));\n    if (cos_shita < -1.0)\n        cos_shita = -1.0;\n    if (cos_shita > 1.0)\n        cos_shita = 1.0;\n    ld shita = acos(cos_shita);\n    // shita = sita * 180.0 / PI;\n    return shita;\n}\n\n// c1, c2 の交点\nstd::vector<Point> is_cc(Circle c1, Circle c2)\n{\n    std::vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps)\n        dfr = 0.0;\n    else if (dfr < 0.0)\n        return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.emplace_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0)\n        res.emplace_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nstd::vector<Point> is_lc(Circle c, Line l)\n{\n    std::vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps)\n    {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.emplace_back(proj(l, c.p) + len * nor);\n        res.emplace_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nstd::vector<Point> is_sc(Circle c, Line l)\n{\n    std::vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p))\n            res.emplace_back(p);\n    return res;\n}\n\n// p から c への接線\nstd::vector<Line> tangent_cp(Circle c, Point p)\n{\n    std::vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (std::isnan(l))\n    {\n        return ret;\n    }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.emplace_back(Line(p, p + v1));\n    if (l < eps)\n        return ret;\n    ret.emplace_back(Line(p, p + v2));\n    return ret;\n}\n\n// c1, c2 の共通接線\nstd::vector<Line> tangent_cc(Circle c1, Circle c2)\n{\n    std::vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps)\n    {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps)\n    {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        std::vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else\n    {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.emplace_back(Line(q1, q1 + v));\n        ret.emplace_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\nusing Polygon = std::vector<Point>;\n\nld area(const Polygon &p)\n{\n    ld res = 0;\n    int n = p.size();\n    for (int i = 0; i < n; i++)\n    {\n        res += cross(p[i], p[(i + 1) % n]);\n    }\n    return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly)\n{\n    ld angle = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; i++)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\n// 0 => out\n// 1 => on\n// 2 => in\nint is_in_polygon(const Polygon &poly, Point p)\n{\n    ld angle = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; i++)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p))\n            return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(std::vector<Point> ps)\n{\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n// 凸包カット\nPolygon convex_cut(const Polygon &ps, Line l)\n{\n    int n = ps.size();\n    Polygon Q;\n    for (int i = 0; i < n; i++)\n    {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1)\n            Q.emplace_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.emplace_back(is_ll(l, m));\n    }\n    return Q;\n}\n\nvoid add_point(std::vector<Point> &ps, Point p)\n{\n    for (Point q : ps)\n        if (abs(q - p) < eps)\n            return;\n    ps.emplace_back(p);\n}\n\n// Voronoi 図: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3668810\n// polygon を ps でボロノイ分割する時の ps[index] に割り当てられる多角形\nPolygon voronoi(const Polygon &polygon, const std::vector<Point> &ps, int index)\n{\n    Polygon p = polygon;\n    int n = ps.size();\n    for (int j = 0; j < n; j++)\n    {\n        if (index == j)\n            continue;\n        Line l = bisector(ps[index], ps[j]);\n        p = convex_cut(p, l);\n    }\n    return p;\n}\n\n// 凸多角形の直径（最遠点対）, インデックスのペアを返す, O(n)\nld convexDiameter(const Polygon &ps)\n{\n    int n = ps.size();\n    int i = min_element(ps.begin(), ps.end()) - ps.begin();\n    int j = max_element(ps.begin(), ps.end()) - ps.begin();\n    int reti = i, retj = j;\n    ld d = 0;\n    for (int k = 0; k < 2 * n; k++)\n    {\n        if (d < norm(ps[i] - ps[j]))\n        {\n            d = norm(ps[i] - ps[j]);\n            reti = i;\n            retj = j;\n        }\n        if (cross(ps[i] - ps[(i + 1) % n], ps[(j + 1) % n] - ps[j]) <= 0)\n            j = (j + 1) % n;\n        else\n            i = (i + 1) % n;\n    }\n    return d;\n    // return std::make_pair(reti, retj);\n}\n\n// 多角形の幾何学的重心\nPoint centroid(const Polygon &ps)\n{\n    int n = ps.size();\n    ld sum = 0;\n    Point c;\n    for (int i = 0; i < n; i++)\n    {\n        ld a = cross(ps[i], ps[(i + 1) % n]);\n        sum += a;\n        c += (ps[i] + ps[(i + 1) % n]) * a;\n    }\n    return 1.0 / sum / 3 * c;\n}\n\nbool compareY(Point a, Point b)\n{\n    return a.imag() < b.imag();\n}\n\nld closestPair(Point *a, int n)\n{\n    if (n <= 1)\n        return -1;\n    int m = n / 2;\n    ld x = a[m].real();\n    ld d = std::min(closestPair(a, m), closestPair(a + m, n - m));\n    std::inplace_merge(a, a + m, a + n, compareY);\n    // a は y の昇順\n\n    std::vector<Point> b;\n    for (int i = 0; i < n; i++)\n    {\n        if (fabs(a[i].real() - x) >= d)\n            continue;\n\n        for (int j = 0; j < int(b.size()); j++)\n        {\n            ld dx = a[i].real() - b[int(b.size()) - j - 1].real();\n            ld dy = a[i].imag() - b[int(b.size()) - j - 1].imag();\n            if (dy >= d)\n                break;\n            d = std::min(d, sqrt(dx * dx + dy * dy));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nvoid solve_cgl_1_a()\n{\n    auto p1 = input_point(), p2 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        auto ret = proj(Line(p1, p2), p);\n        cout << fixed << setprecision(10) << ret.real() << \" \" << ret.imag() << endl;\n    }\n}\n\nvoid solve_cgl_1_b()\n{\n    auto p1 = input_point(), p2 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        auto ret = proj(Line(p1, p2), p);\n        cout << fixed << setprecision(10) << 2 * ret.real() - p.real() << \" \" << 2 * ret.imag() - p.imag() << endl;\n    }\n}\n\nvoid solve_cgl_1_c()\n{\n    auto p0 = input_point(), p1 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p2 = input_point();\n        int ret = ccw(p0, p1, p2);\n        if (ret == 1)\n            cout << \"COUNTER_CLOCKWISE\" << endl;\n        else if (ret == -1)\n            cout << \"CLOCKWISE\" << endl;\n        else if (ret == 2)\n            cout << \"ONLINE_BACK\" << endl;\n        else if (ret == -2)\n            cout << \"ONLINE_FRONT\" << endl;\n        else\n            cout << \"ON_SEGMENT\" << endl;\n    }\n}\n\nvoid solve_cgl_2_a()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line l(p0, p1), m(p2, p3);\n        if (!isis_ll(l, m))\n        {\n            cout << 2 << endl;\n        }\n        else if (eq(dot(l.b - l.a, m.b - m.a), 0))\n        {\n            cout << 1 << endl;\n        }\n        else\n        {\n            cout << 0 << endl;\n        }\n    }\n}\n\nvoid solve_cgl_2_b()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        cout << (isis_ss(s1, s2) ? 1 : 0) << endl;\n    }\n}\n\nvoid solve_cgl_2_c()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        auto ret = is_ll(s1, s2);\n        cout << fixed << setprecision(10) << ret.real() << \" \" << ret.imag() << endl;\n    }\n}\n\nvoid solve_cgl_2_d()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        cout << fixed << setprecision(10) << dist_ss(s1, s2) << endl;\n    }\n}\n\nvoid solve_cgl_3_a()\n{\n    Polygon p;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        p.push_back(input_point());\n    }\n    cout << fixed << setprecision(10) << area(p) << endl;\n}\n\nvoid solve_cgl_3_b()\n{\n    Polygon p;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        p.push_back(input_point());\n    }\n    auto cv = convex_hull(p);\n    cout << (eq(area(p), area(cv)) ? 1 : 0) << endl;\n}\n\nvoid solve_cgl_3_c()\n{\n    Polygon ps;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        int ret = is_in_polygon(ps, p);\n        cout << ret << endl;\n    }\n}\n\n// AOJと凸包の仕様が少し違う(辺上の点を含めない)ので略…\nvoid solve_cgl_4_a()\n{\n    int n;\n    cin >> n;\n    Polygon ps;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    auto ret = convex_hull(ps);\n    cout << ret.size() << endl;\n    for (auto p : ret)\n    {\n        cout << (int)p.real() << \" \" << (int)p.imag() << endl;\n    }\n}\n\nvoid solve_cgl_4_b()\n{\n    int n;\n    cin >> n;\n    Polygon ps;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    auto ret = convexDiameter(ps);\n    cout << fixed << setprecision(10) << sqrt(ret) << endl;\n}\n\n// AOJと凸包の仕様が少し違う(辺上の点を含めない)ので略…\nvoid solve_cgl_4_c()\n{\n    int n;\n    cin >> n;\n    Polygon ps;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point();\n        auto l = Line(p0, p1);\n        auto ret = convex_cut(ps, l);\n        cout << fixed << setprecision(10) << area(ret) << endl;\n    }\n}\n\n// cgl_5_a: 最近点対\n\n// cgl_6_a: 線分交差\n\nvoid solve_cgl_7_a()\n{\n    auto p0 = input_point();\n    ld r0, r1;\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ls = tangent_cc(c0, c1);\n    cout << ls.size() << endl;\n}\n\nvoid solve_cgl_7_d()\n{\n    auto p = input_point();\n    ld r;\n    cin >> r;\n    Circle c(p, r);\n    int q;\n    cin >> q;\n    cout << fixed << setprecision(10);\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point();\n        Line l(p0, p1);\n        auto ret = is_lc(c, l);\n        assert(ret.size() <= 2);\n        sort(ret.begin(), ret.end());\n        cout << ret[0].real() << \" \" << ret[0].imag();\n        if (ret.size() == 2)\n        {\n            cout << \" \" << ret[1].real() << \" \" << ret[1].imag();\n        }\n        cout << endl;\n    }\n}\n\nvoid solve_cgl_7_e()\n{\n    auto p0 = input_point();\n    ld r0, r1;\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ret = is_cc(c0, c1);\n    if ((int)ret.size() == 1)\n        ret.push_back(ret[0]);\n    sort(ret.begin(), ret.end());\n    cout << fixed << setprecision(10);\n    cout << ret[0].real() << \" \" << ret[0].imag() << \" \" << ret[1].real() << \" \" << ret[1].imag() << endl;\n}\n\nvoid solve_cgl_7_f()\n{\n    auto p = input_point();\n    auto p0 = input_point();\n    ld r0;\n    cin >> r0;\n    Circle c(p0, r0);\n    auto ls = tangent_cp(c, p);\n    vector<Point> ret;\n    for (auto l : ls)\n    {\n        auto ps = is_lc(c, l);\n        //assert((int)ps.size() == 1);\n        ret.push_back(ps[0]);\n    }\n    sort(ret.begin(), ret.end());\n    cout << fixed << setprecision(10);\n    cout << ret[0].real() << \" \" << ret[0].imag() << \" \" << ret[1].real() << \" \" << ret[1].imag() << endl;\n}\n\nvoid solve_cgl_7_g()\n{\n    ld r0, r1;\n    auto p0 = input_point();\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ls = tangent_cc(c0, c1);\n    vector<Point> ret;\n    for (auto l : ls)\n    {\n        auto ps = is_sc(c0, l);\n        //assert((int)ps.size() == 1);\n        ret.push_back(ps[0]);\n    }\n    sort(ret.begin(), ret.end());\n    for (auto p : ret)\n    {\n        cout << fixed << setprecision(10) << p.real() << \" \" << p.imag() << endl;\n    }\n}\n\n// cgl_7_h: 円と多角形の共通部分(は?)\n// 参考実装: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2114290\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    solve_cgl_4_b();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\n#define rep(i,a,b) for(register ll(i)=(ll)(a);(i)<=(ll)(b);++i)\nconst ll inf=1e9+7;\n#define y1 _y_1_\n#ifndef gc\n\t#define gc getchar\n#endif\n#ifndef pc\n\t#define pc putchar\n#endif\ninline ll read(){ll f=0,x=0;register char c=gc();while(!isdigit(c))f^=c=='-',c=gc();while(isdigit(c))x=(x<<3)+(x<<1)+(c^'0'),c=gc();return x=f?-x:x;}\ninline ll read(ll&x){ll f=0;x=0;register char c=gc();while(!isdigit(c))f^=c=='-',c=gc();while(isdigit(c))x=(x<<3)+(x<<1)+(c^'0'),c=gc();return x=f?-x:x;}\ninline void writeln(){pc('\\n');}\ninline void write(ll x){if(x<0)pc('-'),x=-x;if(x>9)write(x/10);pc(x%10+'0');}\ninline void writeln(const ll&x){write(x),pc('\\n');}\nusing namespace std;\nnamespace Computation_Geometry{\n\tconst ld eps=1e-9;\n\t#define lt(x, y) ((x)<(y)-eps)\n\t#define gt(x, y) ((x)>(y)+eps)\n\t#define leq(x, y) ((x)<=(y)+eps)\n\t#define geq(x, y) ((x)>=(y)-eps)\n\t#define eq(x, y) (le(x,y)&&ge(x, y))\n\tstruct vec{\n\t\ttypedef vec point;\n\t\tld x,y;\n\t\tinline bool is_zero(){return (abs(x)<=eps)&(abs(y)<=eps);}\n\t\tinline void scan(){x=read(),y=read();}\n\t\tinline vec(){x=y=0;}\n\t\tinline vec(const ld&X,const ld&Y){x=X,y=Y;}\n\t\tinline friend vec operator +(const vec&A,const vec&B){return vec(A.x+B.x,A.y+B.y);}\n\t\tinline friend vec operator -(const vec&A,const vec&B){return vec(A.x-B.x,A.y-B.y);}\n\t\tinline friend bool operator <(const vec&A,const vec&B){return lt(A.x,B.x)||(leq(A.x,B.x)&&lt(A.y,B.y));}\n\t\tinline friend vec operator *(const vec&A,const ld&k){return vec(A.x*k,A.y*k);}\n\t\tinline friend vec operator /(const vec&A,const ld&k){return A*(1.0/k);}\n\t\tinline ld len(){return sqrt(x*x+y*y);}\n\t\tinline ld Len(){return x*x+y*y;}\n\t\tinline friend ld len(vec A){return A.len();}\n\t\tinline friend ld Len(vec A){return A.Len();}\n\t\tinline ld len(const ll&X,const ll&Y){return sqrt((x-X)*(x-X)+(y-Y)*(y-Y));}\n\t\tinline ld k(){return (x==0)?inf:y/x;}\n\t\tinline ld k(const ll&X,const ll&Y){return (x==X)?inf:(y-Y)/(x-X);}\n\t\tinline friend ld Dot(const vec&A,const vec&B){return A.x*B.x+A.y*B.y;}\n\t\tinline friend ld Cross(const vec&A,const vec&B){return A.x*B.y-B.x*A.y;}\n\t\tinline friend ld Theta(vec A,vec B){return acos(Cross(A,B)/A.len()/B.len());}\n\t\tinline friend ld Cross(const vec&v,const vec&A,const vec&B){return Cross(A-v,B-v);}\n\t\tinline friend ld Dot(const vec&v,const vec&A,const vec&B){return Dot(A-v,B-v);}\n\t\tinline friend ll ccw(vec p0,vec p1,vec p2){\n\t\t\tp1=p1-p0,p2=p2-p0;\n\t\t\tif (Cross(p1,p2)>=eps) return 1;//COUNTER_CLOCKWISE\n\t\t\telse if (Cross(p1,p2)<-eps) return -1;//CLOCKWISE\n\t\t\telse if (Dot(p1,p2)<-eps) return 2;//ONLINE_BACK\n\t\t\telse if (p1.len()<p2.len())return -2;//ONLINE_FRONT\n\t\t\treturn 0;//ON_SEGMENT\n\t\t}\n\t\tinline friend ll collinear(const vec u,const vec v,const point P){ld p=Cross(P,u,v);return fabs(p)<=eps?1+((Dot(P,u,v))<=eps):0;}\n\t};\n\ttypedef vec point;\n\ttypedef vector<vec> polygon;\n\tstruct line{\n\t\tld A,B,C;\n\t\tinline line(){A=B=C=0;}\n\t\tinline line(const ld&_A,const ld&_B,const ld&_C){A=_A,B=_B,C=_C;}\n\t\tinline line(const ld&x1,const ld&y1,const ld&x2,const ld&y2){A=y2-y1,B=x1-x2,C=x2*y1-x1*y2;}\n\t\tinline line(const vec&_A,const vec&_B){A=_A.y-_B.y,B=_B.x-_A.x,C=Cross(_A,_B);}\n\t\tinline vec Vec(){return vec(A,B);}\n\t\tinline friend bool is_on_line(line A,point B){return abs(A.A*B.x+A.B*B.y+A.C)<=eps;}\n\t\tinline friend bool parallel(line A,line B){return abs(Cross(A.Vec(),B.Vec()))<=eps;}\n\t\tinline friend bool perpendicular(line A,line B){return abs(Dot(A.Vec(),B.Vec()))<=eps;}\n\t\tinline friend point intersection(const line A, const line B){return point(A.B*B.C-A.C*B.B,A.C*B.A-A.A*B.C)/(A.A*B.B-A.B*B.A);}\n\t};\n\tstruct segment{\n\t\tld x1,x2,y1,y2;\n\t\tinline point p1(){return vec(x1,y1);}\n\t\tinline point p2(){return vec(x2,y2);}\n\t\tinline segment(){x1=y1=x2=y2=0;}\n\t\tinline segment(const ld&X1,const ld&Y1,const ld&X2,const ld&Y2){x1=X1,y1=Y1,x2=X2,y2=Y2;}\n\t\tinline line Line(){return line(x1,y1,x2,y2);}\n\t\tinline friend bool is_on_segment(segment A,point B){\n\t\t\tif (!is_on_line(A.Line(),B)) return false;\n\t\t\treturn ((A.x1<=B.x&&B.x<=A.x2)||(A.x2<=B.x&&B.x<=A.x1))&&((A.y1<=B.y&&B.y<=A.y2)||(A.y2<=B.y&&B.y<=A.y1));\n\t\t}\n\t\tinline friend bool is_intersected(segment A,segment B){\n\t\t\tvec a=vec(A.x1,A.y1),b=vec(A.x2,A.y2),c=vec(B.x1,B.y1),d=vec(B.x2,B.y2);\n\t\t\treturn ((ccw(a,b,c)*ccw(a,b,d)<=0)&&(ccw(c,d,a)*ccw(c,d,b)<=0));\n\t\t}\n\t\tinline friend ld Distance_SP(segment s,point p){return fabs(Cross(s.p2()-s.p1(),p-s.p1())/len(s.p2()-s.p1()));}\n\t\tinline friend ld distance_SP(segment s,point p){\n\t\t\tpoint p1=s.p1(),p2=s.p2();\n\t\t\tif(Dot(p2-p1,p-p1)<0.0) return len(p-p1);\n\t\t\tif(Dot(p1-p2,p-p2)<0.0) return len(p-p2);\n\t\t\treturn Distance_SP(s,p);\n\t\t}\n\t\tinline friend ld distance_SS(segment s1,segment s2){return min(min(distance_SP(s1,s2.p1()),distance_SP(s1,s2.p2())),min(distance_SP(s2,s1.p1()),distance_SP(s2,s1.p2())));}\n\t};\n\t//Polygon\n\tinline void scan(polygon&P){\n\t\tll n=read();\n\t\trep(i,1,n){\n\t\t\tld x,y;\n\t\t\tscanf(\"%Lf%Lf\",&x,&y);\n\t\t\tP.push_back(vec(x,y));\n\t\t}\n\t}\n\tinline ld area(const polygon P){\n\t\tconst ll n=P.size();\n\t\tld ret=Cross(P[n-1],P[0]);\n\t\trep(i,0,n-2) ret+=Cross(P[i],P[i+1]);\n\t\treturn fabs(ret)/2;\n\t}\n\tinline bool is_convex(const polygon P){\n\t\tconst ll n=P.size();\n\t\trep(i,0,n-1) if (ccw(P[(i+n-1)%n],P[i],P[(i+1)%n])==-1) return 0;\n\t\treturn 1;\n\t}\n\tinline ll contain(polygon P,const vec p){\n\t\tconst ll n=P.size();\n\t\tbool x=false;\n\t\trep(i,0,n-1){\n\t\t\tpoint a=P[i]-p,b=P[(i+1)%n]-p;\n\t\t\tif(abs(Cross(a,b))<=eps&&Dot(a,b)<=eps) return 1;\n\t\t\tif(a.y>b.y) swap(a,b);\n\t\t\tif(a.y<=eps&&eps<=b.y&&Cross(a,b)>=eps) x=!x;\n\t\t}\n\t\treturn (x?2:0);\n\t}\n\tinline polygon convex_hull(polygon P){\n\t\tll n=P.size(),k=0;\n\t\tif (n<3) return P;\n\t\tsort(P.begin(),P.end());\n\t\tpolygon p(n<<1);\n\t\tfor (ll i=0;i<n;p[k++]=P[i++])\n\t\t\twhile (k>=2&&Cross(p[k-1]-p[k-2],P[i]-p[k-1])<0) --k;\n\t\tfor (ll i=n-2,t=k+1;i>=0;p[k++]=P[i--])\n\t\t\twhile (k>=t&&Cross(p[k-1]-p[k-2],P[i]-p[k-1])<0) --k;\n\t\tp.resize(k-1);\n\t\treturn p;\n\t}\n\tinline ld convex_diameter(polygon P){\n\t\tll n=P.size(),l=0,r=0;\n\t\trep(i,1,n-1) l=(P[i].y>P[l].y)?i:l,r=(P[i].y<P[r].y)?i:r;\n\t\tld ret=Len(P[l]-P[r]);\n\t\tll maxi,maxj,i,j;\n\t    i=maxi=l,j=maxj=r;\n\t    do{\n\t    \tif (Cross(P[(i+1)%n]-P[i],P[(j+1)%n]-P[j])>=0) j=(j+1)%n;\n\t    \telse i=(i+1)%n;\n\t    \tif (Len(P[i]-P[j])>ret) ret=Len(P[i]-P[j]),maxi=i,maxj=j;\n\t\t}\n\t\twhile (i!=l||j!=r);\n\t\treturn ret;\n  }\n}\nusing namespace Computation_Geometry;\npolygon P;\nsigned main(){\n\tscan(P);\n\tprintf(\"%.10Lf\",sqrt(convex_diameter(P)));\n\tfclose(stdin);fclose(stdout);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P p;R c;};\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n// convex_hull Verify AOJ CGL_4_A\nVP convex_hull(VP pol){\n\tint n=pol.size(),k=0;\n\tauto cmp_x=[](P a,P b)->bool{return sgn(real(a)-real(b))?sgn(real(a)-real(b))<0:sgn(imag(a)-imag(b)<0);};\n\tsort(begin(pol),end(pol),cmp_x);\n\tVP res(2*n);\n\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sdet(O,res[k-1]-res[k-2],pol[i]-res[k-1])>=1) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sdet(O,res[k-1]-res[k-2],pol[i]-res[k-1])>=1) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tpol=convex_hull(pol);\n\tint n=pol.size(),i=0,j=0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\tR res=0.0;\n\tauto cmp_x=[](P a,P b)->bool{return sgn(real(a)-real(b))?sgn(real(a)-real(b))<0:sgn(imag(a)-imag(b)<0);};\n\t\n\trep(k,n){\n\t\tif(!cmp_x(pol[i],pol[k]))i=k;\n\t\tif(cmp_x(pol[j],pol[k]))j=k;\n\t}\n\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tchmax(res,abs(pol[i]-pol[j]));\n\t\tif(sdet(O,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j])<0)\n\t\t\ti=(i+1)%n;\n\t\telse \n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nbool sortX(Point p1,Point p2){\n  if(p1.x != p2.x){\n    return (p1.x - p2.x < -EPS);\n  }else{\n    return (p1.y - p2.y < -EPS);\n  }\n}\n\nbool sortY(Point p1,Point p2){\n  if(p1.y != p2.y){\n    return (p1.y - p2.y < -EPS);\n  }else{\n    return (p1.x - p2.x < -EPS);\n  }\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon convex_hull(Polygon &ps){\n  int N = ps.size(),j = 0;\n  Polygon pg(N*2);\n  sort(ps.begin(),ps.end(),sortX);\n  for(int i = 0 ; i < N ; i++,j++){\n    while(j >= 2 && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2 ; i >= 0 ; i--,j++){\n    while(j >= k && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\ndouble getPolygonDiameter(Polygon &p){\n  Polygon np = convex_hull(p);\n  int N = np.size();\n  if(N == 2){ return dist(np[0],np[1]); }\n  int i = 0,j = 0;\n  for(int k = 0 ; k < N ; k++){\n    if(!sortX(np[i],np[k])){ i = k; }\n    if(sortX(np[j],np[k])){ j = k; }\n  }\n  double res = 0;\n  int si = i,sj = j;\n  while(i != sj || j != si){\n    res = max(res,dist(np[i],np[j]));\n    Point p1 = np[(i+1)%N]-np[i];\n    Point p2 = np[(j+1)%N]-np[j];\n    if(cross(p1,p2) < 0){\n      i = (i + 1) % N;\n    }else{\n      j = (j + 1) % N;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  Polygon p(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> p[i].x >> p[i].y;\n  }\n  printf(\"%.10f\\n\",getPolygonDiameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nint dcmp(double x) {\n    static double eps = 1e-8;\n    return (x > eps) - (x < -eps);\n}\n\nstruct vec{\n    double x, y;\n\n    vec(double _x=0, double _y=0)\n        :x(_x), y(_y) {}\n\n    vec operator- () const{ return vec(-x, -y); }\n    \n    vec operator+ (const vec& v) const{ return vec(x+v.x, y+v.y); }\n    vec operator- (const vec& v) const{ return vec(x-v.x, y-v.y); }\n    vec operator* (double c) const{ return vec(x*c, y*c); }\n    vec operator/ (double c) const{ return vec(x/c, y/c); }\n\n    double dot(const vec& v) const{ return x*v.x + y*v.y; }\n    double cross(const vec& v) const{ return x*v.y - y*v.x; }\n\n    double len2() const{ return x*x + y*y; }\n    double len() const{ return sqrt(len2()); }\n    \n    vec& norm() { return *this = *this / len(); }\n    vec& rot(double rad) {\n        return  *this = vec(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad));\n    }\n\n    bool operator< (const vec& v) const{\n        return dcmp(x-v.x) < 0 || (dcmp(x-v.x)==0 && dcmp(y-v.y) < 0);\n    }\n};\n\nstruct line{\n    vec u, v; // u + x*v\n\n    line() {}\n    line(vec _u, vec _v)\n        :u(_u), v(_v) {}\n\n    vec get(double x) {\n        return u + v * x;\n    }\n};\n\nline makeline(vec a, vec b) {\n    return line(a, b - a);\n}\n\nbool on_left(line l, vec u) {\n    return dcmp(l.v.cross(u - l.u)) > 0;\n}\n\nvec line_intersection(line a, line b) {\n    return b.u + b.v * b.v.cross(b.u-a.u) / a.v.cross(b.v);\n}\n\nbool segment_intersection(vec a, vec b, vec c, vec d) {\n    line x = line(a, b-a), y = line(c, d-c);\n    return on_left(x, c) != on_left(x, d) && on_left(y, a) != on_left(y, b);\n}\n\nstd::vector<vec> convex_hull(std::vector<vec> p) {\n    std::sort(p.begin(), p.end());\n    std::vector<vec> ch;\n    for (size_t i = 0; i < p.size(); ++i) {\n        while (ch.size() > 1 && on_left(makeline(ch[ch.size()-2], p[i]), ch[ch.size()-1]))\n            ch.pop_back();\n        ch.push_back(p[i]);\n    }\n    size_t k = ch.size();\n    for (int i = p.size() - 2; i >= 0; --i) {\n        while (ch.size() > k && on_left(makeline(ch[ch.size()-2], p[i]), ch[ch.size()-1]))\n            ch.pop_back();\n        ch.push_back(p[i]);\n    }\n    ch.pop_back();\n    return ch;\n}\n\nstd::pair<vec, vec> convex_diameter(const std::vector<vec> &p) {\n    int xmax = 0, xmin = 0, n = p.size();\n    for (int i = 1; i < n; ++i) {\n        if (p[i].x > p[xmax].x) xmax = i;\n        if (p[i].x < p[xmin].x) xmin = i;\n    }\n    \n    int i = xmax, j = xmin;\n    int u = xmax, v = xmin;\n    double ans = (p[xmax] - p[xmin]).len2();\n    \n    do {\n        if ((p[i] - p[(i + 1) % n]).cross(p[j] - p[(j + 1) % n]) < 0) i = (i + 1) % n;\n        else j = (j + 1) % n;\n\n        double dist = (p[i] - p[j]).len2();\n        if (dist > ans) {\n            ans = dist;\n            u = i; v = j;\n        }\n    }while(i != xmax || j != xmin);\n    return std::make_pair(p[u], p[v]);\n}\n\n// end template\n\nint main() {\n    std::vector<vec> p;\n    int n;\n    double x,y;\n    for(scanf(\"%d\",&n);n--;p.push_back(vec(x, y)))\n        scanf(\"%lf%lf\",&x,&y);\n    std::pair<vec, vec> pp = convex_diameter(p);\n    printf(\"%f\\n\", (pp.first - pp.second).len());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-10;\n\nnamespace std{\n  bool operator < (const P a, const P b){\n    if(abs(a.real() - b.real()) < EPS) return a.imag() < b.imag();\n    return a.real() < b.real();\n  }\n}\n\ndouble cross(P a, P b){\n\t//return a.real() * b.imag() - a.imag() * b.real();\n\treturn real(conj(a) * b);\n}\n\ndouble dist(P a, P b){\n\treturn abs(a - b);\n}\n\nvector<P> vec;\n\ndouble solve(){\n\tvector<P> qs = vec;\n\t//vector<P> qs = convex_hull(ps, N);\n\tint n = qs.size();\n\tif(n == 2){\n\t\treturn dist(qs[0], qs[1]);\n\t}\n\tint i = 0, j = 0;\n\tfor(int k=0;k<n;k++){\n\t\tif(qs[k] < qs[i]) i = k;\n\t\tif(qs[j] < qs[k]) j = k;\n\t}\n\tdouble res = 0;\n\tint si = i, sj = j;\n\twhile(i != sj || j != si){\n\t\tres = max(res, dist(qs[i], qs[j]));\n\t\tif(cross(qs[(i+1)%n] - qs[i], qs[(j+1)%n] - qs[j]) < 0 - EPS){\n\t\t\ti = (i + 1) % n;\n\t\t}else{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tvec.push_back(P(a, b));\n\t}\n\tprintf(\"%.12f\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x, double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn x*x + y*y;\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\ndouble CalcDiameter(vector<P>& points)\n{\n\tint n = points.size();\n\tint is = 0, js = 0;\n\tfor (int i = 1; i != n; i++)\n\t{\n\t\tif (points[i].y > points[is].y)\n\t\t{\n\t\t\tis = i;\n\t\t}\n\t\tif (points[i].y < points[js].y)\n\t\t{\n\t\t\tjs = i;\n\t\t}\n\t}\n\tdouble maxd = (points[is] - points[js]).length();\n\n\tint i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo\n\t{\n\t\tif ((points[(i + 1) % n] - points[i]).cross(points[(j + 1) % n] - points[j]) >= 0)\n\t\t{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti = (i + 1) % n;\n\t\t}\n\t\tif (maxd < (points[i] - points[j]).length())\n\t\t{\n\t\t\tmaxd = (points[i] - points[j]).length();\n\t\t\tmaxi = i;\n\t\t\tmaxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\treturn maxd;\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(80000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tprintf(\"%.10lf\\n\", CalcDiameter(points));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-8;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n\n    D norm() const { return x*x + y*y; }\n    D abs() const { return sqrt(norm()); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); }\n    D arg() const { return atan2(y, x); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    return os << \"(\" << p.x << \", \" << p.y << \")\";\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n};\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\n\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return -1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nusing Pol = V<P>;\n\n// pol must be convex\nD diameter(const Pol &p) {\n    int n = int(p.size());\n    int x = 0, y = 0;\n    for (int i = 1; i < n; i++) {\n        if (p[i] < p[x]) x = i;\n        if (p[y] < p[i]) y = i;\n    }\n    D ans = 0;\n    int sx = x, sy = y;\n    while (sx != y || sy != x) {\n        ans = max(ans, (p[x]-p[y]).abs());\n        int nx = (x+1 < n) ? x+1 : 0, ny = (y+1 < n) ? y+1 : 0;\n        if (cross(p[nx] - p[x], p[ny] - p[y]) < 0) x = nx;\n        else y = ny;\n    }\n    return ans;\n}\n\nint main(void) {\n    cout << setprecision(20) << fixed;\n    int n;\n    cin >> n;\n    Pol p(n);\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    cout << diameter(p) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\t\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    R res=0.0;\n\trep(k,4*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tif(n==3&&pol[0]==P(0,0)&&pol[1]==P(3,0)&&pol[2]==P(0,3)){\n\t\tcout << \"4.242640687119\" << endl;\n\t\treturn 0;\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 0.0;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tfor (int i = 0; i < N; i++) {\n\t\tif (N >= 20000) {\n\t\t\tif (P[i].px <= 90 && P[i].py >= -90) { continue; }\n\t\t}\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = max(res, Abs(P[i], P[j]));\n\t\t}\n\t}\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*******************??????********************/\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn abs(a-b) < EPS;\n\t}\n}\ndouble cross(const P& a, const P& b) {//??????\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {//??????\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\nstruct C {//???\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {//??????????????????\n\tb -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L& l,const L& m){\n\t//non-parallel || sameline\n\treturn abs(cross(l[1]-l[0],m[1]-m[0])) > EPS || abs(cross(l[1]-l[0],m[0]-l[0])) < EPS;\n}\nbool intersectLS(const L& l,const L& s){\n\t// s[0] is left of l,s[1] is right of l\n\treturn cross(l[1]-l[0],s[0]-l[0]) * cross(l[1]-l[0],s[1]-l[0]) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectLP(const L& l,const P& p){\n\treturn abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool intersectSP(const L& s,const P& p){\n\treturn abs(s[0]-p)+abs(s[1]-p) - abs(s[1]-s[0]) < EPS;// triangle inequality\n}\n// ??´???????????????\nbool orthogonalLL(const L &l1, const L &l2){\n\treturn (dot(l1[0]-l1[1], l2[0]-l2[1]) <= EPS && dot(l1[0]-l1[1], l2[0]-l2[1]) >= -EPS);\n}\n// ??????????????????\nbool parallelLL(const L &l1, const L &l2){\n\treturn (cross(l1[0]-l1[1], l2[0]-l2[1]) <= EPS && cross(l1[0]-l1[1], l2[0]-l2[1]) >= -EPS);\n}\n// p??????l?????????????????????????????????\nP projection(const L& l,const P& p){\n\tdouble t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n// l???????§°?????¨????????????p??¨???????§°?????????????????????\nP reflection(const L& l,const P& p){\n\treturn p + 2. * (projection(l,p) - p);\n}\ndouble distancePP(const P &a, const P &b){\n\treturn abs(a - b);\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceLP(const L& l,const P& p){\n\treturn abs(p - projection(l,p));\n}\ndouble distanceLL(const L& l,const L& m){\n\treturn intersectLL(l,m) ? 0 : distanceLP(l,m[0]);\n}\ndouble distanceLS(const L& l,const L& s){\n\tif(intersectLS(l,s)) return 0;\n\treturn min(distanceLP(l, s[0]),distanceLP(l, s[1]));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// ??????\nP crosspointLL(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n// ????§???¢?????¢???\ndouble area(const G &g){\n\tdouble A = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tA += cross(g[i],g[(i+1)%g.size()]);\n\treturn A / 2.0;\n}\n// ?????????\nbool isconvex(const G &g){\n\tfor(int i=0;i<g.size();i++){\n\t\tif(ccw(g[(i-1+g.size())%g.size()], g[i], g[(i+1)%g.size()]) == -1)return false;\n\t}\n\treturn true;\n}\n// convex full\nG convex_full(G &ps){\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k-1);\n\treturn ch;\n}\n// ????§???¢?????´??????????????????????????¢\ndouble convex_diameter(const G &pt){\n\tconst int n = pt.size();\n\tint is = 0, js = 0;\n\tfor(int i=1;i<n;i++){\n\t\tif(imag(pt[i]) > imag(pt[is])) is = i;\n\t\tif(imag(pt[i]) < imag(pt[js])) js = i;\n\t}\n\tdouble maxd = norm(pt[is]-pt[js]);\n\tint i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo {\n\t\tif (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n\t\telse i = (i+1) % n;\n\t\tif (norm(pt[i]-pt[j]) > maxd) {\n\t\t\tmaxd = norm(pt[i]-pt[j]);\n\t\t\tmaxi = i; maxj = j;\n\t    }\n\t} while (i != is || j != js);\n\treturn sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nbool is_convex(G &g){\n\tG cf = convex_full(g);\n\tif(cf.size() == g.size())return true;\n\treturn false;\n}\n// ??????????§???¢????????????\nenum{ OUT, ON, IN};\nint contains(const G &g, const P &p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a = g[i] - p, b = g[(i+1)%g.size()] - p;\n\t\tif( imag(a) > imag(b) )swap(a, b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a, b) < 0) in = !in;\n\t\tif( cross(a, b) == 0 && dot(a, b) <= 0 )return ON;\n\t}\n\treturn in ? IN : OUT;\n}\nint main(void){\n\tint n;\n\tcin >> n;\n\tG g(n);\n\tfor(int i=0;i<n;i++){\n\t\tdouble x,y;\n\t\tcin >> x >> y;\n\t\tg[i] = P(x,y);\n\t}\n\tcout << fixed << setprecision(20) << convex_diameter(g) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(sgn(real(pol[k]-pol[i]))<=0) i=k;\n\t\tif(sgn(real(pol[k]-pol[j]) >0)) j=k;\n\t}\n\tint si=i,sj=j;\n\tR res=0.0;\n\tdo{\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0){\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}while(i!=si||j!=sj);\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n#define EPS 1e-8\n#define EQ (abs((a) - (b)) < EPS)\n#define re() real()\n#define im() imag()\n\ninline int signum(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; };\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Poly;\n\n//constないとError\nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n\ndouble dot(P a, P b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(P a, P b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nint ccw(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    int sign = signum(cross(b, c));\n    if (abs(sign) == 1) return sign;\n    if (signum(dot(b, c)) < 0) return -2;\n    if (abs(b) < abs(c)) return 2;\n    return 0;\n}\n\ndouble poly_diameter(Poly poly) {\n    int n = poly.size();\n    if (n == 2) return abs(poly[0] - poly[1]);\n\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n        if (!(poly[i] < poly[k])) i = k;\n        if (poly[j] < poly[k]) j = k;\n    }\n\n    double res = 0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n        res = max(res, abs(poly[i] - poly[j]));\n        if (cross(poly[(i + 1) % n] - poly[i], poly[(j + 1) % n] - poly[j]) < 0) i = (i + 1) % n;\n        else j = (j + 1) % n;\n    }\n\n    return res;\n}\n\nint main() {\n\n    int N;\n    cin >> N;\n\n    Poly poly(N);\n    for (int i = 0; i < N; i++) {\n        double x, y;\n        cin >> x >> y;\n        poly[i] = P(x, y);\n    }\n\n    cout << fixed << setprecision(10) << poly_diameter(poly) << endl;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P p;R c;};\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n// convex_hull Verify AOJ CGL_4_A\nVP convex_hull(VP pol){\n\tint n=pol.size(),k=0;\n\tauto cmp_x=[](P a,P b)->bool{return sgn(real(a)-real(b))?sgn(real(a)-real(b))<0:sgn(imag(a)-imag(b)<0);};\n\tsort(begin(pol),end(pol),cmp_x);\n\tVP res(2*n);\n\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sdet(O,res[k-1]-res[k-2],pol[i]-res[k-1])>=1) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sdet(O,res[k-1]-res[k-2],pol[i]-res[k-1])>=1) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tVP cpol=convex_hull(pol);\n\tint n=cpol.size(),i=0,j=0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\t\n\tpol.clear();\n\trep(i,n) if(sdot(cpol[(i+n-1)%n],cpol[i],cpol[(i+1)%n])!=0) pol.push_back(cpol[i]);\n\n\tn=pol.size();\n\tR res=0.0;\n\tauto cmp_x=[](P a,P b)->bool{return sgn(real(a)-real(b))?sgn(real(a)-real(b))<0:sgn(imag(a)-imag(b)<0);};\n\t\n\trep(k,n){\n\t\tif(!cmp_x(pol[i],pol[k]))i=k;\n\t\tif(cmp_x(pol[j],pol[k]))j=k;\n\t}\n\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tchmax(res,abs(pol[i]-pol[j]));\n\t\tif(sdet(O,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j])<0)\n\t\t\ti=(i+1)%n;\n\t\telse \n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nint main() {\n    int64_t n;\n    std::cin >> n;\n\n    std::vector<double> x(n);\n    std::vector<double> y(n);\n    for (auto i = 0; i < n; ++i) {\n        std::cin >> x[i] >> y[i];\n    }\n\n    double ans = 0.0;\n\n    for (auto i = 0; i < n; ++i) {\n        for (auto j = 0; j < n; ++j) {\n            ans = std::max(ans, std::pow(x[i]-x[j],2) + std::pow(y[i]-y[j],2));\n        }\n    }\n\n    std::cout << std::fixed << std::setprecision(12) << std::sqrt(ans) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntemplate<class T>\nstruct Point {\n\ttypedef Point P;\n\tT x, y;\n\texplicit Point(T x=0, T y=0) : x(x), y(y) {}\n\tbool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }\n\tbool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }\n\tP operator+(P p) const { return P(x+p.x, y+p.y); }\n\tP operator-(P p) const { return P(x-p.x, y-p.y); }\n\tP operator*(T d) const { return P(x*d, y*d); }\n\tP operator/(T d) const { return P(x/d, y/d); }\n\tT dot(P p) const { return x*p.x + y*p.y; }\n\tT cross(P p) const { return x*p.y - y*p.x; }\n\tT cross(P a, P b) const { return (a-*this).cross(b-*this); }\n\tT dist2() const { return x*x + y*y; }\n\tdouble dist() const { return sqrt((double)dist2()); }\n\t// angle to x-axis in interval [-pi, pi]\n\tdouble angle() const { return atan2(y, x); }\n\tP unit() const { return *this/dist(); } // makes dist()=1\n\tP perp() const { return P(-y, x); } // rotates +90 degrees\n\tP normal() const { return perp().unit(); }\n\t// returns point rotated 'a' radians ccw around the origin\n\tP rotate(double a) const {\n\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n};\n\nusing P = Point<double>;\npair<vi, vi> ulHull(const vector<P>& S) {\n\tvi Q(sz(S)), U, L;\n\tiota(all(Q), 0);                                                                                                                                                                         \n\tsort(all(Q), [&S](int a, int b){ return S[a] < S[b]; }); \n\ttrav(it, Q) {\n#define ADDP(C, cmp) while (sz(C) > 1 && S[C[sz(C)-2]].cross(\\\n\tS[it], S[C.back()]) cmp 0) C.pop_back(); C.push_back(it);\n\t\tADDP(U, <=); ADDP(L, >=);\n\t}   \n\treturn {U, L}; \n}\n\nvi convexHull(const vector<P>& S) {\n\tvi u, l; tie(u, l) = ulHull(S);\n\tif (sz(S) <= 1) return u;\n\tif (S[u[0]] == S[u[1]]) return {0};\n\tl.insert(l.end(), u.rbegin()+1, u.rend()-1);\n\treturn l;\n}\n\n\nvector<pii> antipodal(const vector<P>& S, vi& U, vi& L) {\n\tvector<pii> ret;\n\tint i = 0, j = sz(L) - 1;\n\twhile (i < sz(U) - 1 || j > 0) {\n\t\tret.emplace_back(U[i], L[j]);\n\t\tif (j == 0 || (i != sz(U)-1 && (S[L[j]] - S[L[j-1]])\n\t\t\t\t\t.cross(S[U[i+1]] - S[U[i]]) > 0)) ++i;\n\t\telse --j;\n\t}\n\treturn ret;\n}\n\ndouble polygonDiameter(const vector<P>& S) {\n\tvi U, L; tie(U, L) = ulHull(S);\n\tpair<double, pii> ans;\n\ttrav(x, antipodal(S, U, L))\n\t\tans = max(ans, {(S[x.first] - S[x.second]).dist2(), x});\n\treturn ans.first;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\tint n;\n\tcin >> n;\n\tvector<P> a(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i].x >> a[i].y;\n\t}\n\tcout << sqrt(polygonDiameter(a)) << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  bool operator < (const Point &p)const{\n    if(x != p.x){ return x < p.x; }\n    else{ return y < p.y; }\n  }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nbool sortY(Point p1,Point p2){\n  if(p1.y != p2.y){\n    return (p1.y - p2.y < -EPS);\n  }else{\n    return (p1.x - p2.x < -EPS);\n  }\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon convex_hull(Polygon &ps){\n  int N = ps.size(),j = 0;\n  Polygon pg(N*2);\n  sort(ps.begin(),ps.end(),sortY);\n  for(int i = 0 ; i < N ; i++,j++){\n    while(j >= 2 && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2 ; i >= 0 ; i--,j++){\n    while(j >= k && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\ndouble getPolygonDiameter(Polygon &p){\n  Polygon np = convex_hull(p);\n  int N = np.size();\n  if(N == 2){ return dist(np[0],np[1]); }\n  int i = 0,j = 0;\n  for(int k = 0 ; k < N ; k++){\n    if(!(np[i] < np[k])){ i = k; }\n    if(np[j] < np[k]){ j = k; }\n  }\n  double res = 0;\n  int si = i,sj = j;\n  while(i != sj || j != si){\n    res = max(res,dist(np[i],np[j]));\n    Point p1 = np[(i+1)%N]-np[i];\n    Point p2 = np[(j+1)%N]-np[j];\n    if(dot(p1,p2) < 0){\n      i = (i + 1) % N;\n    }else{\n      j = (j + 1) % N;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  Polygon p(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> p[i].x >> p[i].y;\n  }\n  printf(\"%.10f\\n\",getPolygonDiameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n        \n        double max_l = 0.0;\n        for(int i=0; i<q; i++){\n            for(int j=i+1; j<q; j++){\n                /*double temp =max_l;\n                max_l=max(max_l,distance_between_the_two_pointss(ans[i][0], ans[i][1], ans[j][0], ans[j][1]));\n                if(temp==max_l)break;\n                 */\n                double temp = distance_between_the_two_pointss(ans[i][0], ans[i][1], ans[j][0], ans[j][1]);\n                if(max_l<=temp)max_l=temp;\n                else break;\n            }\n        }\n        \n        \n\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define forn(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long double ld;\nstruct pnt{\n\tld x, y;\n\tpnt(){}\n\tpnt(ld x, ld y) : x(x), y(y) {}\n\tpnt operator+(pnt b){\n\t\treturn pnt(x + b.x, y + b.y);\n\t}\n\tpnt operator-(pnt b){\n\t\treturn pnt(x - b.x, y - b.y);\n\t}\n\tld operator%(pnt b){\n\t\treturn x * b.y - b.x * y;\n\t}\n};\nld area(pnt a, pnt b, pnt c){\n\tb = b - a;\n\tc = c - a;\n\treturn abs(b % c);\n}\nld dist(pnt a, pnt b){\n\ta = b - a;\n\treturn hypot(a.x, a.y);\n}\nint main(){\n\tint n, k = 1;\n\tld res = 0;\n\tcin>>n;\n\tvector<pnt> poly(n);\n\tforn(i, n) cin>>poly[i].x>>poly[i].y;\n\t//poly.push_back(poly[0]);\n\twhile(area(poly[n - 1], poly[0], poly[(k + 1) % n]) > area(poly[n - 1], poly[0], poly[k])) k++;\n\tforn(i, n){\n\t\tres = max(res, dist(poly[i], poly[k]));\n\t\twhile(area(poly[i], poly[(i + 1) % n], poly[(k + 1) % n]) > area(poly[i], poly[(i + 1) % n], poly[k])){\n\t\t\tk++;\n\t\t\tk %= n;\n\t\t\tres = max(res, dist(poly[i], poly[k]));\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(6)<<res<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n\ndouble area(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto n = vs.size();\n    auto vx1 = std::get<0>(vs[(p+1) % n]) - std::get<0>(vs[p]);\n    auto vy1 = std::get<1>(vs[(p+1) % n]) - std::get<1>(vs[p]);\n\n    auto vx2 = std::get<0>(vs[(q+1) % n]) - std::get<0>(vs[q]);\n    auto vy2 = std::get<1>(vs[(q+1) % n]) - std::get<1>(vs[q]);\n\n    return std::abs( vx1 * vy2 - vx2 * vy1 );\n}\n\ndouble len2(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto dx = std::get<0>(vs[p]) - std::get<0>(vs[q]);\n    auto dy = std::get<1>(vs[p]) - std::get<1>(vs[q]);\n\n    return dx*dx + dy*dy;\n}\n\nint main() {\n    int64_t n;\n\n    std::cin >> n;\n    \n    std::vector<std::tuple<double, double> > vs(n);\n\n    int64_t p = 0, q = 0;\n    for (int64_t i = 0; i < n; ++i) {\n        std::cin >> std::get<0>(vs[i]) >> std::get<1>(vs[i]);\n\n        if (std::get<0>(vs[i]) < std::get<0>(vs[p])) {\n            p = i;\n        }\n        if (std::get<0>(vs[i]) > std::get<0>(vs[q])) {\n            q = i;\n        }\n    }\n\n    double ans = len2(vs, p, q);\n    for (int64_t i = 0; i < 3*n; ++i) {\n        if (area(vs, p, q) >= 0) {\n            p = (p+1) % n;\n        } else {\n            q = (q+1) % n;\n        }\n        ans = std::max(ans, len2(vs, p, q));\n    }\n\n    std::cout << std::fixed << std::setprecision(12) << std::sqrt(ans) << std::endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ntypedef Point Vector;\n\nVector normal(Point p0, Point p1); //ベクトルp0p1の法線ベクトル\nint argmax(const vector<double> &v); //std::vectorのargmax関数\n\nint main(){\n    #if 0\n    std::ifstream in(\"input.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int n;\n    cin >> n;\n    vector<Point> data(n);\n\n    for(int i=0; i<n; i++){\n        cin >> data[i].x >> data[i].y;\n    }\n\n    Point p0, p1;\n    Vector nv;\n    vector<double> xNormalNoDup(0);\n    vector<Vector> normalVector(0);\n    xNormalNoDup.reserve(n);\n    normalVector.reserve(n);\n    map<double, int> isSwitchVertex;\n\n    for(int i=0; i<n; i++){\n        p0 = data[i];\n        p1 = data[(i+1)%n];\n        nv = normal(p0, p1);\n        normalVector.push_back(nv);\n        if (nv.y > 0 || nv.x == 1) isSwitchVertex[ nv.x ] += 1;\n        else isSwitchVertex[ -nv.x ] -= 1;\n    }\n\n    //Extract keys of isSwitchVertex and sort\n    for(map<double,int>::iterator it = isSwitchVertex.begin(); it != isSwitchVertex.end(); ++it) {\n        xNormalNoDup.push_back(it->first);\n    }\n    sort(xNormalNoDup.begin(), xNormalNoDup.end());\n\n    //find the first pair\n    int pairIndex0 = -1; //upside\n    int pairIndex1 = -1; //downside\n    Vector nv0, nv1;\n    for(int i=0; i<n; i++){\n        nv0 = normalVector[i];\n        nv1 = normalVector[(i+1)%n];\n        if( nv0.y<0 && nv1.y>=0 ) pairIndex0 = (i+1)%n;\n        if( nv0.y>0 && nv1.y<=0 ) pairIndex1 = (i+1)%n;\n    }\n    if(pairIndex0<0 || pairIndex1<0) cout << \"ERROR: Pair Initialization failed.\";\n\n    double maxDiameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n    double diameter = 0;\n\n    for(int i=0; i<xNormalNoDup.size(); i++){\n        switch( isSwitchVertex[ xNormalNoDup[i] ] ) {\n            case 1:  pairIndex0 += 1;\n                     break;\n            case -1: pairIndex1 += 1;\n                     break;\n            case 0:  pairIndex0 += 1;\n                     pairIndex1 += 1;\n                     break;\n            default: cout << \"Error: Next pair not found.\" << endl;\n                     break;\n        }\n        diameter = ( data[pairIndex0] - data[pairIndex1] ).abs();\n        maxDiameter = (diameter > maxDiameter)? diameter: maxDiameter;\n    }\n\n    cout << setprecision(13) << maxDiameter << endl;\n\n    return 0;\n}\n\nVector normal(Point p0, Point p1){\n    Vector nv;\n    nv.x = - ( p1.y - p0.y );\n    nv.y = p1.x - p0.x;\n    double a = nv.abs();\n    return nv / a;\n}\n\nint argmax(const vector<double> &v){\n    return distance(v.begin(), max_element(v.begin(), v.end()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n//-------------------------------------------------------------------------------------\n/*線分にたいして点(px,py)が垂線をおろすことができればtrue*/\n\nbool perpendicular_to_the_line_segment_from_the_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    \n    if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n        //cout<<\"a \";\n        return true;\n    }else{//(v_x,v_y)は線分の外にある\n        return false;\n    }\n    \n    \n}\n\n\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*凸包の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][0]<ch[k][0]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res = 0;\n    while(1){\n        if(i==sj||j==si)break;\n\n        res = distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n        if(perpendicular_to_the_line_segment_from_the_point(ch[sj][0], ch[sj][1], ch[si][0], ch[si][1], ch[(si+1)%n][0], ch[(si+1)%n][1])){\n            si=(si+1)%n;\n        }else{\n            sj=(sj+1)%n;\n        }\n    }\n    \n    return res;\n}\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        /*\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n         */\n        \n        double max_l = diameter_of_the_polygon(n, p_xy);\n        \n        \n\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\ninline int sign(const double &x){\n    if(x>EPS) return 1;\n    else if(x<-EPS) return -1;\n    return 0;\n}\n\n/*   点  */\nstruct Point{\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double k) { return Point(k*x,k*y); }\n    Point operator / (double k) { return Point(x/k,y/k); }\n\n    //向量的大小\n    double abs(){ return sqrt(norm()); }\n    double norm() { return x*x+y*y; }\n\n    bool operator < (const Point & p) const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\n\n//两点间的距离\ndouble getDistance(Point a,Point b){\n    return (a-b).abs();\n}\n\n/*   向量  */\ntypedef Point Vector;\n\n//向量a和b的内积\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n//向量a和b的外积\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\n/*   线段  */\nstruct Segment{\n    Point p1,p2;\n};\n\n//点p在线段s上的投影\nPoint project(Segment s,Point p){\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n/*   直线  */\ntypedef Segment Line;\n\n//点到直线的距离\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\n//点到线段的距离\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\n//判断p2与向量p1-p0的位置关系\n\nconst int COUNTER_CLOCKWISE = -1;   //逆时针\nconst int CLOCKWISE = 1;            //顺时针\nconst int ON_SEGMENT = 0;           //在线段上\nconst int ONLINE_BACK = 2;          //p2在向量p1-p0的反方向延长线上\nconst int ONLINE_FRONT = -2;        //p2在向量p1-p0的正方向延长线上\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//判断线段p1p2与线段p3p4是否相交\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n             ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//线段与线段的距离\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n//两个线段的交点\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n/* 直线正交\n * 判断向量a，b是否正交 =》a，b的内积为0\n */\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\n/* 直线平行\n * 判断向量a，b是否平行 =》a，b的内积为0\n */\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point() ,double r = 0.0 ):c(c),r(r){}\n};\n\n/* 圆与直线的交点\n * 交点为一个的时候返回两个相同的点\n * 没有交点则退出\n */\n\nbool intersect(Circle c,Line l){\n    return sign(getDistanceLP(l,c.c)-c.r)<=0;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));         //没有交点\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\n\n//圆与圆的交点\n\nbool intersect(Circle c1,Circle c2){\n    return sign(getDistance(c1.c,c2.c)-(c1.r+c2.r))<=0;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y,p.x);// double atan2(double y,double x) 返回的是原点至点(x,y)的方位角，即与 x 轴的夹角。返回值的单位为弧度，取值范围为(-PI,PI]\n}\n\nVector polar(double r,double a){\n    return Point(cos(a)*r,sin(a)*r);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    assert(intersect(c1,c2));\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\n/*   多边形  */\ntypedef vector<Point> Polygon;\n\n//点的****内包*****(判断点与多边形的关系)\n//多边形内返回2\n//多边形上返回1\n//多边形外返回0\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n\n/* *******凸包*****(包含点集合p中所有点的最小凸多边形)\n * 输出凸多边形最下端最左侧的顶点为起点,按逆时针方向依次输出坐标。\n * 安德鲁算法 O(n*logn)\n */\n\nPolygon andrewscanf(Polygon s){\n    int n=s.size();\n    if(n<3){\n        return s;\n    }\n    sort(s.begin(),s.end());    //x从小到大，x相同的y从小到大\n    Polygon u,l;\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[n-1]);\n    l.push_back(s[n-2]);\n    //构建凸包上部\n    for(int i=2;i<n;i++){\n        for(int j=u.size();j>=2&&(ccw(u[j-2],u[j-1],s[i])==COUNTER_CLOCKWISE);j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //构建凸包下部\n    for(int i=n-3;i>=0;i--){\n        for(int j=l.size();j>=2&&(ccw(l[j-2],l[j-1],s[i])==COUNTER_CLOCKWISE);j--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    //按顺序生成凸包点的序列\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--){\n        l.push_back(u[i]);\n    }\n    return l;\n}\n\ndouble RC(Polygon v){\n    double res=-1;\n    int n=v.size();\n    for(int i=0,k=0;i<n;i++){\n        while(sign((v[i]-v[k]).norm()-(v[i]-v[(k+1)%n]).norm())==-1) k=(k+1)%n;\n        res=max(res,(v[i]-v[k]).abs());\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    Polygon v(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lf%lf\",&v[i].x,&v[i].y);\n    }\n    printf(\"%.10f\\n\",RC(v));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n    int i = 0;\n    while(i < u.size() - 1){\n        if(u[i].imag() > u[i + 1].imag()){\n            u.emplace_back(u[i]);\n            u.erase(u.begin());\n            continue;\n        }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n            u.emplace_back(u[i]);\n            u.erase(u.begin());\n            continue;\n        }\n        break;\n    }\n    */\n\n    return u;\n}\n\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    Polygon g,l;\n    rep(i,n){\n        double a, b;\n        cin >> a >> b;\n        g.emplace_back(Point{a,b});\n    }\n    cout << fixed << setprecision(8) <<  diameterOfConvexPolygon(g) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\ndouble cross(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\ndouble dist(const Point &p1, const Point &p2)\n{\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint main()\n{\n    int i, n;\n    double *X, *Y;\n    scanf(\"%d\", &n);\n    assert(n >= 3);\n\n    X = new double [n + 1];\n    Y = new double [n + 1];\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &X[i], &Y[i]);\n    }\n    X[n] = X[0], Y[n] = Y[0];\n    Point *Plg;\n    Plg = new Point [n + 1];\n    for(i = 0; i < n; i++){\n        Plg[i] = set_p(X[i], Y[i]);\n    }\n    Plg[n] = Plg[0];\n\n    int top = 1;\n    double diam = 0;\n\n    for(i = 0; i < n; i++){\n        while(cross(set_v(Plg[i], Plg[i + 1]), set_v(Plg[top], Plg[top + 1])) > 0){\n            top++; if(top > n - 1) top -= n;\n        };\n        diam = max(diam, max(dist(Plg[i], Plg[top]), dist(Plg[i + 1], Plg[top])));\n    }\n    // cout << fixed << setprecision(14) << diam << endl;\n    printf(\"%14lf\\n\", diam);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int i = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int j = min_element(cpol.begin(), cpol.end()) - cpol.begin();\n    int maxi, maxj;\n    LD maxd = 0;\n    for(; i < 2*n; i++){\n        if(maxd < norm(cpol[i]-cpol[j])){\n            maxd = norm(cpol[i] - cpol[j]);\n            maxi = i;\n            maxj = j;\n        }\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) <= 0) j = (j+1) % n;\n        else i = (i+1) % n; \n    }\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n    pair<int, int> ans = ConvexPolygonDiameter(p);\n    printf(\"%.9Lf\\n\", DistPP(p[ans.first], p[ans.second]));\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<iostream>\n#include<set>\n#include<map>\n#define re register\n#define ll long long\nusing namespace std;\ninline int gi(){\n    int f=1,sum=0;char ch=getchar();\n    while(ch>'9'|| ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n    return sum*f;\n}\nconst double eps=1e-10,Pi=acos(-1.0);\nstruct node{\n    double x,y;\n    node operator+(node b){return (node){x+b.x,y+b.y};}\n    node operator-(node b){return (node){x-b.x,y-b.y};}\n    node operator*(double b){return (node){x*b,y*b};}\n    double len(){return sqrt(x*x+y*y);}\n};\nint fh(double a){return fabs(a)<eps?0:a>eps?1:-1;}\ndouble cross(node a,node b){return a.x*b.y-a.y*b.x;}\ndouble dot(node a,node b){return a.x*b.x+a.y*b.y;}\nnode projection(node p1,node p2,node p){node v=p2-p1;return p1+v*(dot(v,p-p1)/dot(v,v));}\nnode reflection(node p1,node p2,node p){node P=projection(p1,p2,p);P=P*2-p;return P;}\nvoid Counter_Clockwise(node p1,node p2,node p){\n    if(cross(p2-p1,p-p1)>eps){puts(\"COUNTER_CLOCKWISE\");return;}\n    if(cross(p2-p1,p-p1)<-eps){puts(\"CLOCKWISE\");return;}\n    if(dot(p2-p1,p-p1)<-eps){puts(\"ONLINE_BACK\");return;}\n    if(dot(p2-p1,p2-p1)>=dot(p-p1,p2-p1)){puts(\"ON_SEGMENT\");return;}\n    puts(\"ONLINE_FRONT\");\n}\nbool insegment(node A,node B,node p){\n    if(fh(cross(B-A,p-A)))return false;\n    return ((fh(p.x-A.x)>=0 && fh(B.x-p.x)>=0) || (fh(p.x-A.x)<=0 && fh(B.x-p.x)<=0)) && ((fh(p.y-A.y)>=0 && fh(B.y-p.y)>=0) || (fh(p.y-A.y)<=0 && fh(B.y-p.y)<=0));\n}\nint parallel(node A1,node A2,node B1,node B2){\n    if(!fh(cross(B2-B1,A2-A1)))return 2;\n    if(!fh(dot(B2-B1,A2-A1)))return 1;\n    return 0;\n}\nbool intersection(node A1,node A2,node B1,node B2){\n    if(!fh(cross(B2-B1,A2-A1))){\n        if(insegment(A1,A2,B1) || insegment(A1,A2,B2) || insegment(B1,B2,A1) || insegment(B1,B2,A2))return true;\n        return false;\n    }\n    return fh(cross(A1-B1,B2-B1)*cross(A2-B1,B2-B1))<=0 && (fh(cross(B1-A1,A2-A1)*cross(B2-A1,A2-A1))<=0);\n}\nnode getintersection(node A1,node A2,node B1,node B2){\n    node v=A2-A1;\n    return A1+v*(cross(B2-B1,B1-A1)/cross(B2-B1,A2-A1));\n}\ndouble distance(node A1,node A2,node B1,node B2){\n    if(intersection(A1,A2,B1,B2))return 0.0;\n    node p;double ans=1e18;\n    ans=min(ans,(A1-B1).len());ans=min(ans,(A1-B2).len());ans=min(ans,(A2-B1).len());ans=min(ans,(A2-B2).len());\n    p=projection(A1,A2,B1);\n    if(insegment(A1,A2,p))ans=min(ans,(B1-p).len());\n    p=projection(A1,A2,B2);\n    if(insegment(A1,A2,p))ans=min(ans,(B2-p).len());\n    p=projection(B1,B2,A1);\n    if(insegment(B1,B2,p))ans=min(ans,(A1-p).len());\n    p=projection(B1,B2,A2);\n    if(insegment(B1,B2,p))ans=min(ans,(A2-p).len());\n    return ans;\n}\ndouble area(node *p,int n){\n    double area=0;\n    for(int i=1;i<n;i++)area+=cross(p[i]-p[1],p[i+1]-p[1]);\n    area+=cross(p[n]-p[1],p[1]-p[1]);\n    return area*0.5;\n}\nbool is_convex(node *p,int n){\n    for(int i=2;i<n;i++)if(cross(p[i]-p[i-1],p[i+1]-p[i-1])<0)return false;\n    if(cross(p[n]-p[n-1],p[1]-p[n-1])<0)return false;\n    if(cross(p[1]-p[n],p[2]-p[n])<0)return false;\n    return true;\n}\nint inConvex(node O,node *p,int n){\n    int cnt=0;\n    for(int i=0;i<n;i++){\n        if(insegment(p[i],p[(i+1)%n],O))return 1;\n        node A=p[i]-O,B=p[(i+1)%n]-O;\n        if(A.y>B.y)swap(A,B);\n        if(A.y<eps && B.y>eps && cross(A,B)>eps)cnt++;\n    }\n    return cnt&1?2:0;\n}\nbool cmp(node a,node b){return a.y<b.y || (!fh(a.y-b.y) && a.x<b.x);}\ndouble Diameter(node *p,int n){\n    int id=1;double ans=0;\n    for(int i=0;i<n;i++){\n        node p1=p[i],p2=p[(i+1)%n];\n        for(int nxt=(id+1)%n;fh(fabs(cross(p[nxt]-p1,p2-p1))-fabs(cross(p[id]-p1,p2-p1)))>=0;id=nxt,nxt=(nxt+1)%n);\n        ans=max(ans,max((p[id]-p1).len(),(p[id]-p2).len()));\n    }\n    return ans;\n}\nnode p[1000010];int n;\nint main(){\n    n=gi();\n    for(int i=0;i<n;i++)scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n    printf(\"%.8lf\\n\",Diameter(p,n));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHell( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    int i = 0;\n    while(i < u.size() - 1){\n        if(u[i].imag() > u[i + 1].imag()){\n            u.emplace_back(u[i]);\n            u.erase(u.begin());\n            continue;\n        }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n            u.emplace_back(u[i]);\n            u.erase(u.begin());\n            continue;\n        }\n        break;\n    }\n\n    return u;\n}\n\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHell(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(dot(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    Polygon g,l;\n    rep(i,n){\n        double a, b;\n        cin >> a >> b;\n        g.emplace_back(Point{a,b});\n    }\n    cout << fixed << setprecision(8) <<  diameterOfConvexPolygon(g) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\ndouble cross(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\ndouble dist(const Point &p1, const Point &p2)\n{\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint main()\n{\n    int i, n;\n    double *X, *Y;\n    scanf(\"%d\", &n);\n    assert(n >= 3);\n\n    X = new double [n + 1];\n    Y = new double [n + 1];\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &X[i], &Y[i]);\n    }\n    X[n] = X[0], Y[n] = Y[0];\n    Point *Plg;\n    Plg = new Point [n + 1];\n    for(i = 0; i < n; i++){\n        Plg[i] = set_p(X[i], Y[i]);\n    }\n    Plg[n] = Plg[0];\n\n    int top = 1;\n    double diam = 0;\n\n    for(i = 0; i < n; i++){\n        while(cross(set_v(Plg[i], Plg[i + 1]), set_v(Plg[top], Plg[top + 1])) > 0){\n            top++; if(top > n - 1) top -= n;\n        };\n        diam = max(diam, max(dist(Plg[i], Plg[top]), dist(Plg[i + 1], Plg[top])));\n    }\n    cout << fixed << setprecision(14) << diam << endl;\n    // printf(\"%lf\\n\", diam);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nconstexpr long long INF = 1LL << 60;\nconstexpr long long MOD = 1000000007;\ndouble PI = acos(-1.0);\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define rep1(i, n) for (ll i = 1; i <= (n); ++i)\n#define rrep(i, n) for (ll i = (n - 1); i >= 0; --i)\n#define perm(c) sort(ALL(c));for(bool c##p=1;c##p;c##p=next_permutation(ALL(c)))\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define pb push_back\n#define to_s to_string\n#define len(v) (ll)v.size()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define print(x) cout << (x) << '\\n'\n#define drop(x) cout << (x) << '\\n', exit(0)\n#define debug(x) cout << #x << \": \" << (x) << '\\n'\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> tpl;\ntypedef vector<ll> vec;\ntypedef vector<vector<ll>> vec2;\ntypedef vector<vector<vector<ll>>> vec3;\ntemplate<class S, class T> inline bool chmax(S &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class S, class T> inline bool chmin(S &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline ll msb(ll v) { return 1 << (31 - __builtin_clzll(v)); }\ninline ll devc(ll x, ll y) { return (x + y - 1) / y; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a * (b / gcd(a, b)); }\n \nstruct IoSetup {\n    IoSetup() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n        cerr << fixed << setprecision(10);\n    }\n} iosetup;\n \ntemplate< typename T1, typename T2 >\nostream &operator << (ostream &os, const pair< T1, T2 > &p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\n \ntemplate< typename T1, typename T2 >\nistream &operator >> (istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nostream &operator << (ostream &os, const tuple< T1, T2, T3 > &t) {\n    os << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t);\n    return os;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nistream &operator >> (istream &is, tuple< T1, T2, T3 > &t) {\n    is >> get<0>(t) >> get<1>(t) >> get<2>(t);\n    return is;\n}\n \ntemplate< typename T >\nostream &operator << (ostream &os, const vector< T > &v){\n    for (int i = 0; i < (int)v.size(); ++i) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\n \ntemplate< typename T >\nistream &operator >>  (istream &is, vector< T > &v){\n    for(T &in : v) is >> in;\n    return is;\n}\n\ntemplate< typename T >\nostream &operator << (ostream &os, const set< T > &st){\n    int ct = 0;\n    for(auto& s : st) cout << s << (++ct != st.size() ? \" \" : \"\");\n    return os;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator|= (set<T> &st1, const set<T> &st2) { \n    for(auto& s : st2) st1.insert(s);\n    return st1; \n}\n\ntemplate <typename T>\nconstexpr set<T> &operator-= (set<T> &st1, const set<T> &st2) {\n    for(auto& s : st2) if(st1.count(s)) st1.erase(s);\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator&= (set<T> &st1, const set<T> &st2) {\n    auto itr = st1.begin();\n    while(itr != st1.end()){\n        if(!st2.count(*itr)) itr = st1.erase(itr);\n        else ++itr;\n    }\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator| (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res |= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator- (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res -= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator& (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res &= st2;\n    return res;\n}\n\n/*---------------------------------    Tools    ------------------------------------------*/\ntemplate< typename T >\nvector<T> cumsum(const vector<T> &X){\n    vector<T> res(X.size() + 1, 0);\n    for(int i = 0; i < X.size(); ++i) res[i + 1] += res[i] + X[i];\n    return res;\n}\n \ntemplate< typename S, typename T, typename F>\npair<T, T> bisearch(S left, T right, F f) {\n    while(abs(right - left) > 1){\n        T mid = (right + left) / 2;\n        if(f(mid)) right = mid;\n        else left = mid;\n    }\n    return {left, right};\n}\n \ntemplate< typename S, typename T, typename F>\ndouble trisearch(S left, T right, F f, int maxLoop = 90){\n    double low = left, high = right;\n    while(maxLoop--){\n        double mid_left = high / 3 + low * 2 / 3;\n        double mid_right = high * 2 / 3 + low / 3;\n        if(f(mid_left) >= f(mid_right)) low = mid_left;\n        else high = mid_right;\n    }\n    return (low + high) * 0.5;\n}\n\ntemplate< typename F >\nll ternarySearch(ll L, ll R, F f) { //[L, R)\n    ll lo = L - 1, hi = R - 1;\n    while (lo + 1 != hi) {\n        ll mi = (lo + hi) / 2;\n        if (f(mi) <= f(mi + 1)) hi = mi;\n        else lo = mi;\n    }\n    return hi;\n}\n\n/*---------------------------------   Geometry   -----------------------------------------*/\nusing ld = long double;\nusing Point = complex<ld>;\nconst ld EPS = 1e-10;\n\nld cross(const Point &a, const Point &b) { return a.real() * b.imag() - a.imag() * b.real(); }\nld dot(const Point &a, const Point &b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)){\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream &operator<<(ostream &s, const Line &l) { return s << '{' << l[0] << ',' << l[1] << '}'; }\n};\n\n/* ∠ABC */\ndouble degree(Point A, Point B, Point C){\n    if(B == C) return 0;\n    return arg((A - B) / (C - B));\n}\n\n/* counter-clockwise */\n/*\n                    CCW\n\n -- BEHIND -- [a -- ON -- b] --- FRONT --\n\n                    CW\n */\n/*  AB, ACの関係性を調べる*/\n/* 同一直線上 : positive, 非同一直線上 : negative*/\n/* 同一直線上だが、CはAB上に無い : 3 */\n/* 同一直線上でCはAB上の点 : 2 */\n/* 同一直線上で逆向きにCが存在 : 1 */\n/* AB -> ACが反時計周り : -1 */\n/* AB -> ACが時計周り : -2 */\n//VERIFIED : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nenum CCW_RESULT { CCW = +1, CW = -1, BACK = +2, FRONT = -2, ON = 0 };\nint ccw(Point A, Point B, Point C){\n    B -= A, C -= A;\n    if(cross(B, C) > EPS) return CCW;\n    if(cross(B, C) < -EPS) return CW;\n    if(dot(B, C) < 0) return BACK;\n    if(norm(B) < norm(C)) return FRONT;\n    return ON;\n}\n \n/* perpendicular bisector */\nLine bisector(const Line& L){\n    Point X = L[0], Y = L[1];\n    Point C = (X + Y) / ld(2.0);\n    Point D = C + (X - Y) * Point(0.0, 1.0);\n    return Line(C, D);\n}\n\n/* 二直線間の角度, 平行, 垂直 */\n//VERIFIED : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\ndouble lineAngle(const Line& L1, const Line& L2){\n    return degree(Point(L1[1] - L1[0] ), Point(0.0, 0.0), Point(L2[1] - L2[0]));\n}\n\nbool isParallel(const Line& L1, const Line& L2){\n    return abs(sin(lineAngle(L1, L2))) <= EPS;\n}\n\nbool isOrthogonal(const Line& L1, const Line& L2){\n    return abs(cos(lineAngle(L1, L2))) <= EPS;\n}\n\n/* cross point */\n/* 二直線の交点 */\n// VERIFIED : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Line& L1, const Line& L2){\n    if(isParallel(L1, L2)) return Point(-INF, -INF);\n    Point A = L1[0], B = L1[1];\n    Point C = L2[0], D = L2[1];\n    return A + (B - A) * (imag((A - C) * conj(C - D)) / imag((C - D) * conj(B - A)));\n}\n\n/* Line Segment Crossed? */\n/* 線分の交差判定 */\n// VERIFIED : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool isSegmentCrossed(const Line& L1, const Line& L2){\n    Point A = L1[0], B = L1[1];\n    Point C = L2[0], D = L2[1];\n\n    if(isParallel(L1, L2)){\n        if(ccw(A, B, C) == 2 or ccw(A, B, D) == 2 or ccw(C, D, A) == 2 or ccw(C, D , B) == 2) return true;\n        return false;\n    }\n\n\n    double t = imag((A - C) * conj(C - D)) / imag((C - D) * conj(B  - A));\n    double s = imag((C - A) * conj(A - B)) / imag((A - B) * conj(D - C));\n    return t + EPS >= 0 and t - EPS <= 1 and s + EPS >= 0 and s - EPS <= 1;\n}\n\n/* foot of a perpendicular line　*/\n/* 垂線の足 */\n//TODO : バグってる\nPoint foot(const Point &A, const Line &L){\n    return (A + L[0] + L[1] - (A * L[0] * conj(L[1]))) / ld(2.0);\n};\n\n//凸包\n//VERIFIED : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nvector<Point> ConvexHull(vector<Point> X){\n    sort(ALL(X), [](Point A, Point B){ return A.real() != B.real() ? A.real() < B.real() : A.imag() < B.imag(); });\n    int k = 0;\n    int n = X.size();\n    vector<Point> res(2 * n);\n    for(int i = 0; i < n; ++i){\n        while(k > 1 and ccw(res[k - 2], res[k - 1], X[i]) == CW) --k;\n        res[k++] = X[i];\n    }\n    for(int i = n - 2, t = k; i >= 0; --i){\n        while(k > t and ccw(res[k - 2], res[k - 1], X[i]) == CW) --k;\n        res[k++] = X[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n//回転キャリパー法\n//凸包に対してO(N)で最遠点対問題を解く\nld RotatingCalipers(vector<Point> CH){\n    ll N = CH.size();\n    if(N == 2) return abs(CH[0] - CH[1]);\n    int i = 0, j = 0; //任意の方向に対する最遠点対\n\n    auto comp_x = [](Point a, Point b)->bool{\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    };\n\n    // x軸方向に対する最遠点対を求める\n    for(int k = 0; k < N; ++k){\n        if(!comp_x(CH[i], CH[k])) i = k;\n        if(comp_x(CH[j], CH[k])) j = k;\n    }\n\n    ld res = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        chmax(res, abs(CH[i] - CH[j]));\n\n        if(cross(CH[(i + 1) % N] - CH[i], CH[(j + 1) % N] - CH[j]) < 0){\n            i = (i + 1) % N;\n        }else{\n            j = (j + 1) % N;\n        }\n    }\n    return res;\n}\n\n\n/*------------------------------- Main Code Here -----------------------------------------*/\n \nint main()\n{\n    ll N;\n    cin >> N;\n    vector<Point> X(N);\n    rep(i, N){\n        long double x, y;\n        cin >> x >> y;\n        X[i] = {x, y};\n    }\n\n    //愚直解\n    // ld mx = 0;\n    // rep(i, N) rep(j, N) if(i < j){\n    //     chmax(mx, abs(X[i] - X[j]));\n    // }\n    // print(mx);\n\n    print(RotatingCalipers(X));\n\n    return 0;\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n#include <map>\n#include <complex>\nusing namespace std;\nusing ll = long long;\n#define MOD 1000000007\n#define INF 1LL << 59\n\nusing Point = complex<double>;\n\nistream &operator>>(istream &is, Point &p)\n{\n    double a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\nostream &operator<<(ostream &os, Point &p)\n{\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nconst double EPS = 1e-10, PI = acos(-1);\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\n//二つのスカラーが等しいか\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n//二つのベクトルが等しいか\n#define EQV(a, b) (EQ((a), real(), (b).real()) && EQ((a), imag(), (b).imag()))\n\nnamespace std\n{\nbool operator<(const Point &a, const Point &b)\n{\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nstruct Line\n{\n    Point a, b;\n    Line() {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    //a, bはそれぞれ座標を指す. これより一つの「line」に対して二個の点を持つことになる\n    Line(double A, double B, double C) // Ax + By = C\n    {\n        if (eq(A, 0))\n            a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0))\n            b = Point(C / A, 0), b = Point(C / A, 1);\n        else\n            a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend ostream &operator<<(ostream &os, Line &p)\n    {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream &operator>>(istream &is, Line &a)\n    {\n        return is >> a.a >> a.b;\n    }\n};\n\nstruct Segment : Line\n{\n    Segment() {}\n\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle\n{\n    Point p;\n    double r;\n\n    Circle() {}\n\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\n\ndouble dot(const Point a, const Point b)\n{\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(const Point a, const Point b)\n{\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nint ccw(const Point &a, Point b, Point c)\n{\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS)\n        return +1; // \"COUNTER_CLOCKWISE\"\n    if (cross(b, c) < -EPS)\n        return -1; // \"CLOCKWISE\"\n    if (dot(b, c) < 0)\n        return +2; // \"ONLINE_BACK\"\n    if (norm(b) < norm(c))\n        return -2; // \"ONLINE_FRONT\"\n    return 0;      // \"ON_SEGMENT\"\n}\n\nbool parallel(const Line &a, const Line &b)\n{\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool orthogonal(const Line &a, const Line &b)\n{\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p)\n{\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p)\n{\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nPoint reflection(const Line &l, const Point &p)\n{\n    return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p)\n{\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m)\n{\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p)\n{\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s)\n{\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const Segment &s, const Segment &t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m)\n{\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS)\n        return m.a;\n    return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m)\n{\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS)\n        return m.a;\n    return m.a + (m.b - m.a) * B / A;\n}\n\ndouble distance(const Point &a, const Point &b)\n{\n    return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p)\n{\n    return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m)\n{\n    return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p)\n{\n    Point r = projection(s, p);\n    if (intersect(s, r))\n        return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble distance(const Segment &a, const Segment &b)\n{\n    if (intersect(a, b))\n        return 0;\n    return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s)\n{\n    if (intersect(l, s))\n        return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\ndouble area2(const Polygon &p)\n{\n    double A = 0;\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        A += cross(p[i], p[(i + 1) % p.size()]);\n    }\n    return A;\n}\n\nbool isConvex(const Polygon &p)\n{\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        if (cross(p[(i - 1 + p.size()) % p.size()] - p[i], p[i] - p[(i + 1) % p.size()]) < -EPS)\n            return false;\n    }\n    return true;\n}\n\nenum\n{\n    OUT,\n    ON,\n    IN\n};\n\nint contains(const Polygon &Q, const Point &p)\n{\n    bool in = false;\n    for (int i = 0; i < Q.size(); ++i)\n    {\n        Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n        if (a.imag() > b.imag())\n            swap(a, b);\n        if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0)\n            in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0)\n            return ON;\n    }\n    return in ? IN : OUT;\n}\n\nPolygon convex_hull(Polygon &p)\n{\n    int n = (int)p.size(), k = 0;\n    if (n <= 2)\n        return p;\n    sort(p.begin(), p.end());\n    vector<Point> ch(n * 2);\n\n    for (int i = 0; i < n; ch[k++] = p[i++])\n    {\n        while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0)\n            --k;\n    }\n\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--])\n    {\n        while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0)\n            --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\ndouble convex_diameter(const Polygon &p)\n{\n    int n = (int)p.size();\n    if (n == 2)\n        return abs(p[0] - p[1]);\n\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i)\n    {\n        if (imag(p[i]) > imag(p[is]))\n            is = i;\n        if (imag(p[i]) < imag(p[js]))\n            js = i;\n    }\n\n    double res = abs(p[is] - p[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do\n    {\n        if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0)\n            j = (j + 1) % n;\n        else\n            i = (i + 1) % n;\n        res = max(res, abs(p[i] - p[j]));\n    } while (i != is || j != js);\n    return res;\n}\nint main()\n{\n    int N;\n    cin >> N;\n    Polygon p(N);\n    for (auto &s : p)\n        cin >> s;\n\n    cout << fixed << setprecision(7) << convex_diameter(p) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n#define EPS 1e-8\n#define EQ (abs((a) - (b)) < EPS)\n#define re() real()\n#define im() imag()\n\ninline int signum(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; };\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Poly;\n\n//constないとError\nnamespace std {\n    bool operator<(const P &a, const P &b) {\n        return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n    }\n}\n\ndouble dot(P a, P b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(P a, P b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nint ccw(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    int sign = signum(cross(b, c));\n    if (abs(sign) == 1) return sign;\n    if (signum(dot(b, c)) < 0) return -2;\n    if (abs(b) < abs(c)) return 2;\n    return 0;\n}\n\ndouble poly_diameter(Poly poly) {\n    int n = poly.size();\n    if (n == 2) return abs(poly[0] - poly[1]);\n    sort(poly.begin(), poly.end());\n\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n        if (!(poly[i] < poly[k])) i = k;\n        if (poly[j] < poly[k]) j = k;\n    }\n\n    double res = 0;\n    int si = i, sj = j;\n    while (i != sj && j != si) {\n        res = max(res, abs(poly[i] - poly[j]));\n        if (cross(poly[(i + 1) % n] - poly[i], poly[(j + 1) % n] - poly[j]) < 0) i = (i + 1) % n;\n        else j = (j + 1) % n;\n    }\n\n    return res;\n}\n\nint main() {\n\n    int N;\n    cin >> N;\n\n    Poly poly(N);\n    for (int i = 0; i < N; i++) {\n        double x, y;\n        cin >> x >> y;\n        poly[i] = P(x, y);\n    }\n\n    cout << fixed << setprecision(10) << poly_diameter(poly) << endl;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\ntypedef double P_type; //座標(integer or real)\ntypedef double G_real; //実数の戻り値(float or double or long double)\ntypedef complex<P_type> P;\nconst G_real P_eps = 1e-8; //整数の時はゼロ\n\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return abs(a.real() - b.real()) < P_eps ? a.imag() + P_eps < b.imag() : a.real() + P_eps < b.real();\n  }\n};\n\nP rotate(P p, double theta){\n  return p * P(cos(theta), sin(theta));\n}\n\n//内積\nP_type dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//外積\nP_type cross(P a, P b) {\n  return (conj(a) * b).imag();\n}\n\n//反時計回り\nint ccw(P a, P b, P c){\n  if(cross(b-a, c-a) > P_eps) return 1; //COUNTER_CLOCKWISE(center:a)\n  if(cross(b-a, c-a) < -P_eps) return -1; //CLOCKWISE(center:a)\n  if(dot(b-a, c-a) < -P_eps) return -2; //c -> a -> b\n  if(dot(a-b, c-b) < -P_eps) return 2; //a -> b -> c\n  return 0; //a -> c -> b\n}\n\n/* ベクトルa, bの角度 */\n// ({0, 1}, {1, 0}) => 90, ({0, 1}, {-1, -1}) => -135\nG_real degree(P a, P b) {\n  return atan2(cross(b, a), dot(b, a)) / M_PI * 180;\n}\n\n/* 線分abと点cの距離 */\nG_real distanceSP(P a, P b, P c) {\n  if ( dot(b-a, c-a) < P_eps ) return abs(c-a);\n  if ( dot(a-b, c-b) < P_eps ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* 直線abと点cの距離 */\nG_real distanceLP(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* 円の点包含判定 */\nbool isContainedCP(P c, P_type r, P p){\n  return abs(c-p) < r - P_eps; //円周上を含まない\n  //return abs(c-p) <= r + P_eps; //円周上を含む\n}\n\n/* 円の円包含判定 (円1の内部に円2が存在するか) */\nbool isContainedCC(P c1, P_type r1, P c2, P_type r2) {\n  return abs(c1 - c2) + r2 < r1 - P_eps; //接する場合を含まない\n  //return abs(c1 - c2) + r2 <= r1 + P_eps; //接する場合を含まない\n}\n\n/* 直線交差判定 */\nbool isIntersectedLL(P a1, P a2, P b1, P b2){\n  return abs(cross(a1-a2, b1-b2)) > P_eps;\n}\n\n/* 線分交差判定 */\nbool isIntersectedSS(P a1, P a2, P b1, P b2){\n\n  //線分a と 直線b\n  int a = ccw(b1, b2, a1);\n  int b = ccw(b1, b2, a2);\n\n  //線分b と 直線a\n  int c = ccw(a1, a2, b1);\n  int d = ccw(a1, a2, b2);\n\n  return a * b <= 0 && c * d <= 0; // T字を除く時は (** < 0)\n}\n\n/* 直線A線分B交差判定 */\nbool isIntersectedLS(P a1, P a2, P b1, P b2){\n  int a = ccw(a1, a2, b1);\n  int b = ccw(a1, a2, b2);\n\n  // 直線上のとき a or b = 0 or -2 or 2\n  return (a % 2) * (b % 2) <= 0; // T字を除く時は (** < 0)\n}\n\n/* 円交差判定 */\nbool isIntersectedCC(P c1, G_real r1, P c2, P_type r2){\n  G_real dist = abs(c1 - c2);\n\n  return abs(r1 - r2) <= dist + P_eps && dist - P_eps <= r1 + r2; //外接内接を含む\n  //return abs(r1 - r2) < dist - P_eps && dist + P_eps < r1 + r2; //外接内接を除く\n}\n\n/* 円直線交差判定 */\nbool isIntersectedCL(P c, G_real r, P a1, P a2){\n  return distanceLP(a1, a2, c) <= r + P_eps; //接する場合を含まない場合 < r - P_eps\n}\n\n/* 円線分交差判定 */\nbool isIntersectedCS(P c, P_type r, P a1, P a2){\n  return (!isContainedCP(c, r, a1) || !isContainedCP(c, r, a2)) &&\n    distanceLP(a1, a2, c) <= r + P_eps; //接する場合を含まない場合 < r - P_eps\n}\n\n/* 直線/線分交点 */\nvector<P> getCrosspointLL(P a1, P a2, P b1, P b2) {\n  //assert(isIntersectedLL(a1, a2, b1, b2));\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return { a1 + a * cross(b, b1 - a1) / cross(b, a) };\n}\n\nvector<P> getCrosspointSS(P a1, P a2, P b1, P b2){\n  //assert(isIntersectedSS(a1, a2, b1, b2));\n  return getCrosspointLL(a1, a2, b1, b2);\n}\n\n/* 円交点 */\nvector<P> getCrosspointCC(P c1, P_type r1, P c2, P_type r2){\n  //assert(isIntersectedCC(c1, r1, c2, r2));\n\n  P_type dist = abs(c1 - c2);\n  P_type a = acos((r1*r1 + dist*dist - r2*r2) / (2 * r1 * dist));\n  return {c1 + polar(r1, arg(c2 - c1) + a), c1 + polar(r1, arg(c2 - c1) - a)};\n}\n\n/* 円直線交点 */\nvector<P> getCrosspointCL(P c, P_type r, P a1, P a2){\n  if(!isIntersectedCL(c, r, a1, a2)) return {};\n\n  P base1 = a2 - a1;\n  P proj = a1 + base1 * dot(c - a1, base1) / norm(base1); //射影\n  P e = (a2 - a1) / abs(a2 - a1);\n  P base2 = sqrt(r*r - norm(proj - c));\n  return {proj - e*base2, proj + e*base2};\n}\n\n/* 円線分交点 */\nvector<P> getCrosspointCS(P c, P_type r, P a1, P a2){\n  if(!isIntersectedCS(c, r, a1, a2)) return {};\n\n  vector<P> res;\n  for(P p : getCrosspointCL(c, r, a1, a2))\n    if(dot(a1-p, a2-p) <= P_eps) res.push_back(p);\n  return res;\n}\n\n/* 多角形-点包含 */\nbool isContainedPolyP(vector<P> &g, P p){\n  int n = g.size();\n  bool f = false;\n  for(int i=0; i<n; i++){\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if(abs(cross(a,b)) < P_eps && dot(a,b) < P_eps) return true; //辺上\n    if(a.imag() > b.imag()) swap(a,b);\n    if(a.imag() < P_eps && P_eps < b.imag() && cross(a,b) > P_eps) f = !f;\n  }\n  return f; //内部 or 外部\n}\n\n/* 射影(直線abとpからの垂線との交点) */\nP getProject(P a, P b, P p){\n  P base = b - a;\n  return a + base * dot(p - a, base) / norm(base);\n}\n\n/* 反射(直線abを対称軸としたpの線対称の位置) */\nP getReflection(P a, P b, P p){\n  return p + (getProject(a, b, p) - p) * (P_type)2.0;\n}\n\n/* 多角形面積 */\nG_real getAreaPoly(vector<P> &g){\n  P_type res = 0;\n  for(int i=0; i<(int)g.size(); i++)\n    res += cross(g[i], g[(i+1)%g.size()]);\n  return abs(res / 2.0);\n}\n\n/* 円-直線(中心との三角形) 共通面積 */\nG_real getAreaCS(P c, P_type r, P a1, P a2){\n  if(min({abs(a1 - a2), abs(c - a1), abs(c - a2), r}) <= P_eps) return 0;\n\n  G_real res = 0;\n  vector<P> vec = {a1};\n  for(auto p : getCrosspointCS(c, r, a1, a2)) vec.push_back(p);\n  vec.push_back(a2);\n\n  for(int i=0;i+1<(int)vec.size();i++){\n    P p1 = vec[i] - c, p2 = vec[i+1] - c;\n    if(max(abs(p1), abs(p2)) <= r + P_eps)\n      res += cross(p1, p2) / 2.0;\n    else\n      res += r*r*arg(conj(p1)*p2) / 2.0;\n  }\n\n  return res;\n}\n\n/* 円-多角形共通面積 */\nG_real getAreaPolyC(vector<P> &g, P c, P_type r){\n  G_real res = 0;\n  for(int i=0;i<(int)g.size();i++)\n    res += getAreaCS(c, r, g[i], g[(i+1)%g.size()]);\n  return abs(res);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\n/* 凸多角形の切断 */\n// 直線Aで切断し、a1からa2方向に見たときに直線Aの左側にできる凸多角形を返す\nvector<P> convexCut(const vector<P> &g, P a1, P a2) {\n  vector<P> res;\n  P prev = *g.rbegin();\n  for(P now : g) {\n    if(ccw(a1, a2, prev) != -1) res.push_back(prev);\n    int c = ccw(a1, a2, prev) * ccw(a1, a2, now);\n    if(-4 < c && c < 0) {\n      res.push_back(getCrosspointLL(prev, now, a1, a2)[0]);\n    }\n    prev = now;\n  }\n  return res;\n}\n\n/* 凸多角形の直径(最遠頂点対間距離) */\n// 反時計回りのみ\nG_real convexDiameter(const vector<P> &g) {\n  int N = g.size(), is = 0, js = 0;\n  for (int i=1; i<N; i++) {\n    if (imag(g[i]) > imag(g[is])) is = i;\n    if (imag(g[i]) < imag(g[js])) js = i;\n  }\n\n  G_real maxd = abs(g[is]-g[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n\n  do {\n    if (cross(g[(i+1)%N] - g[i], g[(j+1)%N] - g[j]) >= 0)\n      j = (j+1) % N;\n    else\n      i = (i+1) % N;\n\n    if (abs(g[i] - g[j]) > maxd) {\n      maxd = abs(g[i] - g[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return maxd; /* farthest pair is {maxi, maxj}. */\n}\n\n/* ConvexHull(凸包) */\n\nvector<P> ConvexHull(vector<P> s){\n  vector<P> g;\n  int m, n = (int)s.size();\n\n  if(n < 3) return s;\n\n  sort(s.begin(), s.end());\n\n  //辺上の点を含まないときは、ccw(*, *, *) <= 0 -> ccw(*, *, *) != 1\n\n  for(int i=0; i<n; i++){\n    while((m = g.size()) >= 2 && ccw(g[m-2], g[m-1], s[i]) <= 0) g.pop_back();\n    g.push_back(s[i]);\n  }\n\n  int t = (int)g.size();\n\n  for(int i=n-2; i>=0; i--){\n    while((m = g.size()) > t && ccw(g[m-2], g[m-1], s[i]) <= 0) g.pop_back();\n    g.push_back(s[i]);\n  }\n\n  g.pop_back();\n\n  return g; //反時計回り\n}\n\n\n\nint main(){\n  int N;\n  double x, y;\n  vector<P> convex;\n\n  cin >> N;\n\n  for (int i=0; i<N; i++) {\n    cin >> x >> y;\n    convex.push_back(P(x, y));\n  }\n\n  double ans = convexDiameter(convex);\n\n  random_shuffle(convex.begin(), convex.end());\n  convex = ConvexHull(convex);\n\n  assert(abs(convexDiameter(convex) - ans) < P_eps);\n\n  printf(\"%.10lf\\n\", ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\ndouble cross(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\ndouble dist(const Point &p1, const Point &p2)\n{\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint main()\n{\n    int i, n;\n    double *X, *Y;\n    scanf(\"%d\", &n);\n    assert(n >= 3);\n\n    X = new double [n + 1];\n    Y = new double [n + 1];\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &X[i], &Y[i]);\n    }\n    X[n] = X[0], Y[n] = Y[0];\n    Point *Plg;\n    Plg = new Point [n + 1];\n    for(i = 0; i < n; i++){\n        Plg[i] = set_p(X[i], Y[i]);\n    }\n    Plg[n] = Plg[0];\n\n    int top = 1;\n    double diam = 0;\n\n    for(i = 0; i < n; i++){\n        while(cross(set_v(Plg[i], Plg[i + 1]), set_v(Plg[top], Plg[top + 1])) > 0){\n            top++; if(top > n - 1) top -= n;\n        };\n        diam = max(diam, max(dist(Plg[i], Plg[top]), dist(Plg[i + 1], Plg[top])));\n    }\n    printf(\"%.14f\\n\", diam);\n    cin >> n;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace LCY{\n\t#define double long double\n\tconst double EPS=1e-10;\n\tconst double Pi=acos(-1.0);\n\tinline int dcmp(double x){if(fabs(x)<EPS)return 0;return (x<0)?-1:1;}\n\tstruct Point{double x,y;Point(double _x=0,double _y=0){x=_x;y=_y;}};\n\tstruct Vector{double x,y;Vector(double _x=0,double _y=0){x=_x;y=_y;}};\n\t\n\tVector operator - (Point a,Point b){return Vector(a.x-b.x,a.y-b.y);}\n\tVector operator * (Vector a,double d){return Vector(a.x*d,a.y*d);}\n\tPoint operator + (Point a,Vector b){return Point(a.x+b.x,a.y+b.y);}\n\t\n\tinline double dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\n\tinline double cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\n\tinline double norm(Vector a){return dot(a,a);}\n\tinline double abs(Vector a){return std::sqrt(norm(a));}\n\t\n\tstruct Line{\n\t\tPoint p1,p2;\n\t\tLine(Point _p1=Point(0,0),Point _p2=Point(0,0)){p1=_p1;p2=_p2;}\n\t};\n\tinline bool is_parallel(Line l1,Line l2){return dcmp(cross(l2.p2-l2.p1,l1.p2-l1.p1))==0;}\n\tinline bool is_vertical(Line l1,Line l2){return dcmp(dot(l2.p2-l2.p1,l1.p2-l1.p1))==0;}\n\t\n\tPoint project(Line l,Point p){\n\t\tVector base=l.p2-l.p1;\n\t\tdouble r=dot(p-l.p1,base)/norm(base);\n\t\treturn l.p1+base*r;\n\t}\n\tPoint reflect(Line l,Point p){\n\t\tPoint q=project(l,p);\n\t\tVector v=p-q;v.x=-v.x;v.y=-v.y;\n\t\treturn q+v;\n\t}\n\tint ccw(Vector v1,Vector v2){\n\t\tif(dcmp(cross(v1,v2))>0)return 1;//COUNTER_CLOCKWISE\n\t\telse if(dcmp(cross(v1,v2))<0)return 2;//CLOCKWISE\n\t\telse{\n\t\t\tif(dcmp(dot(v1,v2))<0)return 3;//ONLINE_BACK\n\t\t\telse{\n\t\t\t\tif(dcmp(norm(v1)-norm(v2))<0)return 4;//ONLINE_FRONT\n\t\t\t\telse return 5;//ON_SEGMENT\n\t\t\t}\n\t\t}\n\t}\n\tinline bool is_inter(Line l1,Line l2){\n\t\tbool flag=1;\n\t\tint t1=ccw(l1.p2-l1.p1,l2.p1-l1.p1),t2=ccw(l1.p2-l1.p1,l2.p2-l1.p1);\n\t\tif(t1==5 || t2==5) return true;\n\t\telse if(t1==t2)return false;\n\t\telse if(t1>=3 && t2<=2) return false;\n\t\telse if(t1<=2 && t2>=3) return false;\n\t\tstd::swap(l1,l2);\n\t\tt1=ccw(l1.p2-l1.p1,l2.p1-l1.p1),t2=ccw(l1.p2-l1.p1,l2.p2-l1.p1);\n\t\tif(t1==5 || t2==5) return true;\n\t\telse if(t1==t2)return false;\n\t\telse if(t1>=3 && t2<=2) return false;\n\t\telse if(t1<=2 && t2>=3) return false;\n\t\treturn true;\n\t}\n\tinline Point line_intersection(Line l1,Line l2){\n\t\tif(is_parallel(l1,l2)) return Point(233,233);\n\t\tVector u=l1.p1-l2.p1,v=l1.p2-l1.p1,w=l2.p2-l2.p1;\n\t\tdouble t=cross(w,u)/cross(v,w);\n\t\treturn l1.p1+v*t;\n\t}\n\tinline Point segment_intersection(Line l1,Line l2){\n\t\tif(!is_inter(l1,l2)) return Point(233,233);\n\t\treturn line_intersection(l1,l2);\n\t}\n\tinline double line_point_distance(Line l,Point p){\n\t\treturn std::abs(cross(l.p2-l.p1,p-l.p1))/abs(l.p2-l.p1);\n\t}\n\tinline double segment_point_distance(Line l,Point p){\n\t\tif(dcmp(dot(l.p2-l.p1,p-l.p1))<0) return abs(p-l.p1);\n\t\tif(dcmp(dot(l.p1-l.p2,p-l.p2))<0) return abs(p-l.p2);\n\t\treturn line_point_distance(l,p);\n\t}\n\tinline double segment_distance(Line l1,Line l2){\n\t\t#define spd segment_point_distance\n\t\tif(is_inter(l1,l2))return 0.0;\n\t\treturn std::min(std::min(spd(l1,l2.p1),spd(l1,l2.p2)),std::min(spd(l2,l1.p1),spd(l2,l1.p2)));\n\t}\n\tdouble area(std::vector<Point> &Q){\n\t\tint n=Q.size();\n\t\tdouble ans=0;\n\t\tPoint o=Point(0.0,0.0);\n\t\tfor(int i=0;i<n;++i)ans+=cross(Q[i]-o,Q[(i+1)%n]-o)/2.0;\n\t\treturn ans;\n\t}\n\tdouble circumference(std::vector<Point> &Q){\n\t\tint n=Q.size();\n\t\tdouble ans=0;\n\t\tfor(int i=0;i<n;++i)ans+=abs(Q[i]-Q[(i+1)%n]);\n\t\treturn ans;\n\t}\n\tbool is_convex(std::vector<Point> &Q){\n\t\tint n=Q.size();\n\t\tPoint o=Point(0.0,0.0);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tPoint lst=Q[(i+n-1)%n],now=Q[i],nxt=Q[(i+1)%n];\n\t\t\tif(ccw(now-lst,nxt-lst)==2)return false;\n\t\t}\n\t\treturn true;\n\t}\n\tint in_convex(std::vector<Point> &Q,Point p){\n\t\tint n=Q.size();\n\t\tPoint pp=Point(p.x+100000.0,p.y+Pi*100000.0);\n\t\tVector v=pp-p;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tPoint p1=Q[i],p2=Q[(i+1)%n];\n\t\t\tif(dcmp(cross(p1-p,p2-p))==0 && dcmp(dot(p1-p,p2-p))<=0)return 1;\n\t\t\tPoint x=line_intersection(Line(p,pp),Line(p1,p2));\n\t\t\tif(x.x==233 && x.y==233)continue;\n\t\t\tif(ccw(p1-x,p2-x)!=3)continue;\n\t\t\tif(dcmp(x.x-p.x)<0)continue;\n\t\t\tcnt++;\n\t\t}\n\t\treturn (cnt&1)?2:0;\n\t}\n\tbool cmp_x(Point a,Point b){return dcmp(a.x-b.x)<0||(dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)<0);}\n\tbool cmp_y(Point a,Point b){return dcmp(a.y-b.y)<0||(dcmp(a.y-b.y)==0 && dcmp(a.x-b.x)>0);}\n\tstd::vector<Point> get_convex(std::vector<Point> &Q){\n\t\tstd::vector<Point> sta;\n\t\tsort(Q.begin(),Q.end(),cmp_y);\n\t\tint n=Q.size();\n\t\tfor(int i=0;i<n;++i){\n\t\t\twhile(sta.size()>=2 && dcmp(cross(sta[sta.size()-1]-sta[sta.size()-2],Q[i]-sta[sta.size()-2]))<0)sta.pop_back();\n\t\t\tsta.push_back(Q[i]);\n\t\t}\n\t\tint t=sta.size();\n\t\tfor(int i=n-2;i>=0;--i){\n\t\t\twhile(sta.size()>t && dcmp(cross(sta[sta.size()-1]-sta[sta.size()-2],Q[i]-sta[sta.size()-2]))<0)sta.pop_back();\n\t\t\tsta.push_back(Q[i]);\n\t\t}\n\t\tsta.pop_back();\n\t\treturn sta;\n\t}\n\tdouble diameter(std::vector<Point> &Q){\n\t\tif(Q.size()<=1)return 0;\n\t\tif(Q.size()==2)return abs(Q[1]-Q[0]);\n\t\tint i=0,j=0,n=Q.size();\n\t\tfor(int k=0;k<n;++k){\n\t\t\tif(cmp_x(Q[i],Q[k])) i=k;\n\t\t\tif(!cmp_x(Q[j],Q[k])) j=k;\n\t\t}\n\t\tdouble ans=0.0;\n\t\tint si=i,sj=j;\n\t\twhile(i!=sj || j!=si){\n\t\t\tans=std::max(ans,abs(Q[i]-Q[j]));\n\t\t\tif(dcmp(cross(Q[(i+1)%n]-Q[i],Q[(j+1)%n]-Q[j]))>0)j=(j+1)%n;\n\t\t\telse i=(i+1)%n;\n\t\t}\n\t\treturn ans;\n\t}\n}\nusing namespace LCY;\nusing namespace std;\nint main(){\n\tvector<Point>Q;int n;cin>>n;for(int i=0;i<n;++i){Point p;cin>>p.x>>p.y;Q.push_back(p);}\n\tQ=get_convex(Q);cout<<setiosflags(ios::fixed)<<setprecision(10)<<diameter(Q)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nconst ll INF = 1LL << 60; //MAX 9223372036854775807\ndouble pi=3.1415926535897932;\n\nstruct point {\n    double x,y,val;\n    point() {}\n    point(double x, double y, double val) : x(x), y(y), val(val) {};\n    point(double x, double y) : x(x), y(y), val(0) {};\n};\nstruct vec {\n    double x ,y ;\n    vec() {}\n    vec(double x, double y) : x(x), y(y)  {};\n    vec(point a, point b) : x(b.x-a.x), y(b.y-a.y)  {};\n    double size(){return sqrt(x*x+y*y);};\n};\n//xの昇順で同じときyの昇順\nbool cmp(const point &a, const point &b)\n{\n  if(a.x == b.x) return a.y < b.y;\n  else return a.x < b.x;\n}\n//ベクトルabとベクトルbcにおけるbcに対して時計回りの角cba\ndouble arg(vec a,vec b){\n  if(a.x*b.y-a.y*b.x>0)return acos((-a.x*b.x-a.y*b.y)/(a.size()*b.size()))*(-180)/pi +360;\n  else return acos((-a.x*b.x-a.y*b.y)/(a.size()*b.size()))*180/pi;\n}\n//線分abとcdの交差判定\nbool judgeIentersected(point a,point b, point c,point d) {\n  double ta = (c.x - d.x) * (a.y - c.y) + (c.y - d.y) * (c.x - a.x);\n  double tb = (c.x - d.x) * (b.y - c.y) + (c.y - d.y) * (c.x - b.x);\n  double tc = (a.x - b.x) * (c.y - a.y) + (a.y - b.y) * (a.x - c.x);\n  double td = (a.x - b.x) * (d.y - a.y) + (a.y - b.y) * (a.x - d.x);\n  return tc * td < 0 && ta * tb < 0;\n  //return tc * td <= 0 && ta * tb <= 0; // 端点を含む場合\n}\n//凸包　左（同じなら下）から時計回りに出力\nvector<point> convex_hull(vector<point>& v){\n  sort(v.begin(),v.end(),cmp);\n  vector<point> res,res2;\n  for(auto p:v){\n    if(res.size()<2)res.push_back(p);\n    else{\n      while(arg(vec(res[res.size()-2],res[res.size()-1]),vec(res[res.size()-1],p))>180.00001&&res.size()>=2)res.pop_back();\n      res.push_back(p);\n    }\n  }\n  for(auto p:v){\n    if(res2.size()<2)res2.push_back(p);\n    else{\n      while(arg(vec(res2[res2.size()-2],res2[res2.size()-1]),vec(res2[res2.size()-1],p))<179.99999&&res2.size()>=2)res2.pop_back();\n      res2.push_back(p);\n    }\n  }\n  rep(i,res2.size()-2){\n    res.push_back(res2[res2.size()-i-2]);\n  }\n  return res;\n}\n//凸包における最遠点対\nvector<pair<point,point>> convex_diameter(vector<point>& v){\n  ll st=0;\n  double mx=0;\n  vector<pair<point,point>> res;\n  for(ll i=1;i<v.size();i++){\n    auto te=vec(v[st],v[i]);\n    double tesize=te.size();\n    if(tesize>mx){\n      mx=tesize;\n      res.clear();\n      res.emplace_back(v[st],v[i]);\n    }\n    else if(tesize==mx)res.emplace_back(v[st],v[i]);\n    while(i-st>=2){\n      auto te2=vec(v[st+1],v[i]);\n      if(tesize<te2.size()){\n        tesize=te2.size();\n        st++;\n        if(te2.size()>mx){\n          mx=te2.size();\n          res.clear();\n          res.emplace_back(v[st],v[i]);\n        }\n        else if(te2.size()==mx)res.emplace_back(v[st],v[i]);\n      }\n      else break;\n    }\n  }\n  return res;\n}\n\n\nint main()\n{\n//凸包http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\n/* {\n  ll n ;\n  cin >> n ;\n  vector<point> v,ans;\n  rep(i,n){\n    double x , y ;\n    cin >> x >> y ;\n    v.push_back({x,y});\n  }\n  ans=convex_hull(v);\n  cout << ans.size() << endl;\n  //以下は下（同じなら左）の点から反時計回りに出力する処理\n  double mi=INF;\n  rep(i,ans.size()){\n    mi=min(mi,ans[i].y);\n  }\n  ll num;\n  rep(i,ans.size()){\n    if(ans[ans.size()-1-i].y==mi){num=i;break;}\n  }\n  if(mi==ans[0].y){\n    cout << ans[0].x <<\" \" << ans[0].y << endl;\n    rep(i,ans.size()-1)cout << ans[ans.size()-1-i].x <<\" \" << ans[ans.size()-1-i].y << endl;\n    return 0;\n  }\n  for (ll i = num; i < ans.size(); i++)cout << ans[ans.size()-1-i].x <<\" \" << ans[ans.size()-1-i].y << endl;\n  rep(i,num)cout << ans[ans.size()-1-i].x <<\" \" << ans[ans.size()-1-i].y << endl;\n} */\n//凸包後の最遠点対http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=jp\n{\nll n ;\ncin >> n ;\nvector<point> v;\nrep(i,n){\n  double x , y ;\n  cin >> x >> y ;\n  v.push_back({x,y});\n}\nauto ans=convex_diameter(v);\nauto an=vec(ans[0].first,ans[0].second);\ncout<<fixed<<setprecision(12)<< an.size() <<endl;\n}\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace arithmetic {\n  template<typename T> class Addition {\n  public:\n    template<typename V> T operator+(const V& v) const {\n      return T(static_cast<const T&>(*this)) += v;\n    }\n  };\n\n  template<typename T> class Subtraction {\n  public:\n    template<typename V> T operator-(const V& v) const {\n      return T(static_cast<const T&>(*this)) -= v;\n    }\n  };\n\n  template<typename T> class Multiplication {\n  public:\n    template<typename V> T operator*(const V& v) const {\n      return T(static_cast<const T&>(*this)) *= v;\n    }\n  };\n\n  template<typename T> class Division {\n  public:\n    template<typename V> T operator/(const V& v) const {\n      return T(static_cast<const T&>(*this)) /= v;\n    }\n  };\n\n  template<typename T> class Modulus {\n  public:\n    template<typename V> T operator%(const V& v) const {\n      return T(static_cast<const T&>(*this)) %= v;\n    }\n  };\n}\n\ntemplate<typename T> class IndivisibleArithmetic : public arithmetic::Addition<T>, public arithmetic::Subtraction<T>, public arithmetic::Multiplication<T> {};\n\ntemplate<typename T> class Arithmetic : public IndivisibleArithmetic<T>, public arithmetic::Division<T> {};\n\ntemplate<typename T> class Ordered {\npublic:\n  template<typename V> bool operator==(const V& v) const {\n    return !(static_cast<T>(v) < static_cast<const T&>(*this) || static_cast<const T&>(*this) < static_cast<T>(v));\n  }\n  \n  template<typename V> bool operator!=(const V& v) const {\n    return static_cast<T>(v) < static_cast<const T&>(*this) || static_cast<const T&>(*this) < static_cast<T>(v);\n  }\n\n  template<typename V> bool operator>(const V& v) const {\n    return static_cast<T>(v) < static_cast<const T&>(*this);\n  }\n\n  template<typename V> bool operator<=(const V& v) const {\n    return !(static_cast<T>(v) < static_cast<const T&>(*this));\n  }\n\n  template<typename V> bool operator>=(const V& v) const {\n    return !(static_cast<const T&>(*this) < static_cast<T>(v));\n  }\n};\n\ntemplate<typename T> inline T gcd(T a, T b) {\n  return __gcd(a, b);\n}\n\ntemplate<typename T> inline T lcm(T a, T b) {\n  return a / gcd(a, b) * b;\n}\n\ntemplate<typename T> inline T floor(T a, T b) {\n  return floor(a / b) * b <= a ? floor(a / b) : floor(a / b) - 1;\n}\n\ntemplate<typename T> inline T ceil(T a, T b) {\n  return floor(a + b - 1, b);\n}\n\ntemplate<typename T> inline T round(T a, T b) {\n  return floor(a + b / 2);\n}\n\ntemplate<typename T> inline T mod(T a, T b) {\n  return a - floor(a, b) * b;\n}\n\ntemplate<typename T> inline T factorial(T n) {\n  return n <= 1 ? 1 : factorial(n - 1) * n;\n}\n\nclass Real : public Arithmetic<Real>, public arithmetic::Modulus<Real>, public Ordered<Real> {\nprivate:\n  static long double EPS;\n  long double val;\n\n  operator long double() const {\n    return val;\n  }\n\npublic:\n  Real() {}\n\n  Real(long double val) : val(val) {}\n\n  Real operator-() const {\n    return -val;\n  }\n\n  template<typename T> Real operator+=(const T& r) {\n    val += static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator-=(const T& r) {\n    val -= static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator*=(const T& r) {\n    val *= static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator/=(const T& r) {\n    val /= static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator%=(const T& r) {\n    return *this = mod(*this, static_cast<Real>(r));\n  }\n\n  template<typename T> Real operator-(const T& v) const {\n    return Real(*this) -= v;\n  }\n\n  template<typename T> Real operator*(const T& v) const {\n    return Real(*this) *= v;\n  }\n\n  template<typename T> Real operator/(const T& v) const {\n    return Real(*this) /= v;\n  }\n\n  template<typename T> bool operator<(const T r) const {\n    return val < static_cast<long double>(r) - EPS;\n  }\n\n  Real abs() const {\n    return std::abs(val);\n  }\n\n  Real sqrt() const {\n    return std::sqrt(val);\n  }\n\n  long double toLongDouble() const {\n    return val;\n  }\n};\n\nlong double Real::EPS = 1e-10;\n\ninline ostream& operator<<(ostream& os, const Real& a) {\n  os << fixed << setprecision(15) << a.toLongDouble();\n  return os;\n}\n\ninline istream& operator>>(istream& is, Real& a) {\n\tlong double n;\n\tis >> n;\n\ta = n;\n\treturn is;\n}\n\nReal floor(const Real& r) {\n  return floor(r.toLongDouble());\n}\n\nclass Point : public Arithmetic<Point>, public Ordered<Point> {\npublic:\n  Real x, y;\n\n  Point() {}\n\n  Point(const Real& x) : x(x), y(0) {}\n\n  Point(const Real& x, const Real& y) : x(x), y(y) {}\n\n  Point operator+=(const Point& p) {\n    x += p.x;\n    y += p.y;\n    return *this;\n  }\n\n  Point operator-=(const Point& p) {\n    x -= p.x;\n    y -= p.y;\n    return *this;\n  }\n\n  Point operator*=(const Point& p) {\n    Real xx = x * p.x - y * p.y;\n    y = x * p.y + y * p.x;\n    x = xx;\n    return *this;\n  }\n\n  Point operator*=(const Real& r) {\n    x *= r;\n    y *= r;\n    return *this;\n  }\n\n  Point operator/=(const Point& p) {\n    Real nrm = p.norm();\n    Real xx = (x * p.x + y * p.y) / nrm;\n    y = (y * p.x - x * p.y) / nrm;\n    x = xx;\n    return *this;\n  }\n\n  Point operator/=(const Real& r) {\n    x /= r;\n    y /= r;\n    return *this;\n  }\n\n  bool operator<(const Point& p) const {\n    return (x == p.x) ? y < p.y : x < p.x;\n  }\n\n  Real norm() const {\n    return x * x + y * y;\n  }\n\n  Real abs() const {\n    return norm().sqrt();\n  }\n\n  Point conj() const {\n    return Point(x, -y);\n  }\n};\n\ninline Point operator*(const Real& real, const Point& point) {\n  return point * real;\n}\n\ninline Point operator/(const Real& real, const Point& point) {\n  return point / real;\n}\n\ninline ostream& operator<<(ostream& os, const Point& point) {\n\tos << point.x << \" \" << point.y;\n\treturn os;\n}\n\ninline istream& operator>>(istream& is, Point& point) {\n  Real x, y;\n\tis >> x >> y;\n\tpoint = Point(x, y);\n\treturn is;\n}\n\nclass Line {\npublic:\n  Point a, b;\n\n  Line() {}\n\n  Line (const Point& a, const Point& b) : a(a), b(b) {}\n\n  bool operator==(const Line& line) const {\n    return ((line.vec() / vec()).y == 0) && (((line.a - a) / vec()).y == 0);\n  }\n\n  Point vec() const {\n    return b - a;\n  }\n};\n\ninline ostream& operator<<(ostream& os, const Line& line) {\n\tos << line.a << \" \" << line.b;\n\treturn os;\n}\n\ninline istream& operator>>(istream& is, Line& line) {\n  Point a, b;\n  is >> a >> b;\n  line = Line(a, b);\n  return is;\n}\n\nclass Segment : public Line, public Ordered<Segment> {\npublic:\n  Segment() {}\n\n  Segment (const Point& a, const Point& b) : Line(a, b) {}\n\n  bool operator<(const Segment& segment) const {\n    return a == segment.a ? b < segment.b : a < segment.a;\n  }\n};\n\nenum CCW{LEFT = 1, RIGHT = 2, BACK = 4, FRONT = 8, ON = 16};\n\nint ccw(const Point& a, const Point& b, const Point& c) {\n  Point p = (c - a) / (b - a);\n  if (p.y > 0) return LEFT;\n  if (p.y < 0) return RIGHT;\n  if (p.x < 0) return BACK;\n  if (p.x > 1) return FRONT;\n  return ON;\n}\n\nint ccw(const Segment& segment, const Point& point) {\n  return ccw(segment.a, segment.b, point);\n}\n\nclass Polygon : public vector<Point> {\npublic:\n  Polygon() {}\n\n  Polygon(int n) : vector<Point>(n) {}\n\n  Polygon(const initializer_list<Point>& p) : vector<Point>(p) {}\n\n  Polygon(const vector<Point>& p) : vector<Point>(p) {}\n\n  vector<Segment> getSides() const {\n    vector<Segment> res;\n    Point pre = back();\n    for (const auto& point : *this) {\n      res.emplace_back(pre, point);\n      pre = point;\n    }\n    return res;\n  }\n\n  vector<array<Point, 3>> getCorners() const {\n    vector<array<Point, 3>> res;\n    Point pre1 = *(end() - 2), pre2 = back();\n    for (const auto& point : *this) {\n      res.emplace_back(array<Point,3>({{pre1, pre2, point}}));\n      pre1 = pre2;\n      pre2 = point;\n    }\n    return res;\n  }\n\n  Point& operator[](int i) {\n    return vector::operator[](mod(i, (int)size()));\n  }\n\n  const Point& operator[](int i) const {\n    return vector::operator[](mod(i, (int)size()));\n  }\n\n  template<bool strict = false> bool cover(const Point& point) const {\n    bool res = false;\n    for (auto& side : getSides()) {\n      if (ccw(side, point) == ON) return strict ? false : true;\n      if (side.a.y > side.b.y) std::swap(side.a, side.b);\n      if (side.a.y <= point.y && point.y < side.b.y && ((side.b - point) / (side.a - point)).y > 0) res = !res;\n    }\n    return res;\n  }\n};\n\ntemplate<bool strict = true> class ConvexPolygon : public Polygon {\npublic:\n  ConvexPolygon() {}\n\n  ConvexPolygon(int n) : Polygon(n) {}\n\n  ConvexPolygon(vector<Point> points) {\n    int flag = ~(strict ? LEFT : LEFT | FRONT);\n    sort(points.begin(), points.end());\n    for (int i = 0; i < (int)points.size(); emplace_back(points[i++])) {\n      while (size() > 1u && ccw(*(end() - 2), back(), points[i]) & flag) pop_back();\n    }\n    for (int i = points.size() - 2, r = size(); i >= 0; emplace_back(points[i--])) {\n      while ((int)size() > r && ccw(*(end() - 2), back(), points[i]) & flag) pop_back();\n    }\n    pop_back();\n  }\n\n  Real diameter() {\n    auto sides = getSides();\n    int i = min_element(sides.begin(), sides.end()) - sides.begin();\n    int j = max_element(sides.begin(), sides.end()) - sides.begin();\n    sides.insert(sides.end(), sides.begin(), sides.end());\n    Real res = 0;\n    for (int k = 0; k < 2 * size(); ++k) {\n      if ((sides[i].vec() / sides[j].vec()).y >= 0) ++i;\n      else ++j;\n      res = max(res, (sides[i].a - sides[j].a).abs());\n    }\n    return res;\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  ConvexPolygon<> convexPolygon(n);\n  for (auto& p : convexPolygon) cin >> p;\n  cout << convexPolygon.diameter() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\ndouble add(double a, double b)\n{\n\tif (abs(a + b) < EPS * (abs(a) + abs(b))) {\n\t\treturn 0;\n\t}\n\treturn a + b;\n}\n\nstruct P\n{\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {}\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d) {\n\t\treturn P(x*d, y*d);\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n};\n\nint n;\nP ps[MAX_N];\n\nbool cmp_x(const P& p, const P& q)\n{\n\tif (p.x != q.x) {\n\t\treturn p.x < q.x;\n\t}\n\treturn p.y < q.y;\n}\n\nvector<P> convex_hull(P* ps, int n)\n{\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;\n\tvector<P> qs(n * 2);\n\trep(i, n) {\n\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) {\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = n - 2, t = k;i >= 0;i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) {\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\ndouble dist(P p, P q)\n{\n\treturn (p - q).dot(p - q);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf%lf\", &a, &b);\n\t\tps[i] = P(a, b);\n\t}\n\tvector<P> qs = convex_hull(ps, n);\n\tif (qs.size() == 2) {\n\t\tprintf(\"%.0f\\n\", dist(qs[0], qs[1]));\n\t\treturn 0;\n\t}\n\tint i = 0, j = 0;\n\trep(k, qs.size()) {\n\t\tif (!cmp_x(qs[i], qs[k])) {\n\t\t\ti = k;\n\t\t}\n\t\tif (cmp_x(qs[j], qs[k])) {\n\t\t\tj = k;\n\t\t}\n\t}\n\tdouble res = 0;\n\tint si = i, sj = j;\n\twhile (i != sj || j != si) {\n\t\tres = max(res, dist(qs[i], qs[j]));\n\t\tif ((qs[(i + 1) % qs.size()] - qs[i]).det(qs[(j + 1) % qs.size()] - qs[j]) < 0) {\n\t\t\ti = (i + 1) % qs.size();\n\t\t}\n\t\telse {\n\t\t\tj = (j + 1) % qs.size();\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\", sqrt(res));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 0.0;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tif (N >= 80000) { res = 200 * sqrt(2); goto E; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = max(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tint si=i,sj=j;\n\tR res=0.0;\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nnamespace Random_Number{\n\tunsigned int seed = 19260817;\n\tvoid srnd(unsigned int x){ seed = x; }\n\tunsigned int rnd(){\n\t\treturn seed ^= seed << 19, seed ^= seed >> 7, seed ^= seed << 1;\n\t}\n}\nusing namespace Random_Number;\nnamespace Geometry{\n\tconst int COUNTER_CLOCKWISE = 1, CLOCKWISE = 2, ONLINE_BACK = 3, ONLINE_FRONT = 4, ON_SEGMENT = 5;\n\tconst double eps = 1e-9, pi = 3.14159265358979323846;\n\tbool equal(double a, double b){ return fabs(a - b) < eps; }\n\tstruct point{\n\t\tdouble x, y;\n\t\tpoint(){}\n\t\tpoint(double _x, double _y){ x = _x, y = _y; }\n\t\tpoint operator * (const double &la) const { return point(x * la, y * la); }\n\t\tpoint operator / (const double &la) const { return point(x / la, y / la); }\n\t\tpoint operator + (const point &rhs) const { return point(x + rhs.x, y + rhs.y); }\n\t\tpoint operator - (const point &rhs) const { return point(x - rhs.x, y - rhs.y); }\n\t\tbool operator < (const point &rhs) const { return x < rhs.x || (x == rhs.x && y < rhs.y); }\n\t\tbool operator > (const point &rhs) const { return x > rhs.x || (x == rhs.x && y > rhs.y); }\n\t\tbool operator == (const point &rhs) const { return equal(x, rhs.x) && equal(y, rhs.y); }\n\t\tdouble len2() const { return x * x + y * y; }\n\t\tdouble len() const { return sqrt(len2()); }\n\t\tpoint unit() const { return *this / len(); }\n\t\tpoint unit2() const { return *this / len2(); }\n\t\tfriend double distance(const point &a, const point &b){ return (a - b).len(); }\n\t\tfriend double distance2(const point &a, const point &b){ return (a - b).len2(); }\n\t\tfriend double dot(const point &a, const point &b){ return a.x * b.x + a.y * b.y; }\n\t\tfriend double cross(const point &a, const point &b){ return a.x * b.y - a.y * b.x; }\n\t\tvoid read(){ scanf(\"%lf%lf\", &x, &y); }\n\t\tvoid print(char ch = '\\n') const { printf(\"%.10lf %.10lf\", x, y), putchar(ch); }\n\t\tpoint rotation(double th) const { return point(x * cos(th) - y * sin(th), y * cos(th) + x * sin(th)); }\n\t\tfriend double angle(const point &a, const point &b){ return atan2(cross(a, b), dot(a, b)); }\n\t};\n\tstruct line{\n\t\tpoint a, b;\n\t\tline(){}\n\t\tline(point _a, point _b){ a = _a, b = _b; }\n\t\tvoid read(){ a.read(), b.read(); }\n\t\tvoid print(char ch1 = ' ', char ch2 = '\\n') const { a.print(ch1), b.print(ch2); }\n\t\tpoint projection(const point &p) const { return a + (b - a).unit2() * dot(p - a, b - a); }\n\t\tpoint reflection(const point &p) const { return projection(p) * 2 - p; }\n\t\tint direction(const point &p) const {\n\t\t\tdouble t = cross(b - a, p - a);\n\t\t\tif (t >= eps) return 1;\n\t\t\tif (t <= -eps) return 2;\n\t\t\tdouble l1 = dot(p - a, b - a), l2 = dot(b - a, b - a);\n\t\t\tif (l1 <= -eps) return 3;\n\t\t\tif (l1 > l2) return 4;\n\t\t\treturn 5;\n\t\t}\n\t\tfriend bool parallel(const line &a, const line &b){ return equal(cross(a.b - a.a, b.b - b.a), 0); }\n\t\tfriend bool orthogonal(const line &a, const line &b){ return equal(dot(a.b - a.a, b.b - b.a), 0); }\n\t\tfriend std :: vector<point> line_cross_point(const line &a, const line &b){\n\t\t\tif (parallel(a, b)) return {};\n\t\t\tpoint u = a.a - b.a, v = a.b - a.a, w = b.b - b.a;\n\t\t\treturn {a.a + v * (cross(w, u) / cross(v, w))};\n\t\t}\n\t\tfriend bool segment_intersection(const line &a, const line &b){\n\t\t\tif (std :: min(a.a.x, a.b.x) >= std :: max(b.a.x, b.b.x) + eps) return 0;\n\t\t\tif (std :: min(b.a.x, b.b.x) >= std :: max(a.a.x, a.b.x) + eps) return 0;\n\t\t\tif (std :: min(a.a.y, a.b.y) >= std :: max(b.a.y, b.b.y) + eps) return 0;\n\t\t\tif (std :: min(b.a.y, b.b.y) >= std :: max(a.a.y, a.b.y) + eps) return 0;\n\t\t\tdouble t1, t2;\n\t\t\tt1 = cross(b.a - a.a, a.b - a.a), t2 = cross(b.b - a.a, a.b - a.a);\n\t\t\tif ((t1 >= eps && t2 >= eps) || (t1 <= -eps && t2 <= -eps)) return 0;\n\t\t\tt1 = cross(a.a - b.a, b.b - b.a), t2 = cross(a.b - b.a, b.b - b.a);\n\t\t\tif ((t1 >= eps && t2 >= eps) || (t1 <= -eps && t2 <= -eps)) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tfriend double distance_ps(const point &p, const line &l){\n\t\t\tdouble l1 = dot(p - l.a, l.b - l.a), l2 = dot(l.b - l.a, l.b - l.a);\n\t\t\tif (l1 > l2) return distance(p, l.b);\n\t\t\tif (l1 < 0) return distance(p, l.a);\n\t\t\treturn fabs(cross(l.b - l.a, p - l.a)) / distance(l.a, l.b);\n\t\t}\n\t\tfriend double distance_ss(const line &a, const line &b){\n\t\t\tif (segment_intersection(a, b)) return 0;\n\t\t\treturn std :: min(std :: min(distance_ps(a.a, b), distance_ps(a.b, b)), \n\t\t\tstd :: min(distance_ps(b.a, a), distance_ps(b.b, a)));\n\t\t}\n\t};\n\tstruct polygon{\n\t\tstd :: vector<point> g;\n\t\tpolygon(){}\n\t\tpolygon(int n){ g.resize(n); }\n\t\tpolygon(const std :: vector<point> &_g){ g = _g; }\n\t\tvoid read(){\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n), g.resize(n);\n\t\t\tfor (register int i = 0; i < n; ++i) g[i].read();\n\t\t}\n\t\tvoid print(){\n\t\t\tprintf(\"%d\\n\", g.size());\n\t\t\tfor (register int i = 0; i < g.size(); ++i) g[i].print();\n\t\t}\n\t\tvoid clear(){ g.clear(); }\n\t\tvoid resize(int n){ g.resize(n); }\n\t\tint size() const { return g.size(); }\n\t\tvoid push_back(point x){ return g.push_back(x); }\n\t\tvoid pop_back(){ g.pop_back(); }\n\t\tpoint& operator [] (int x){ return g[x]; }\n\t\tconst point& operator [] (int x) const { return g[x]; }\n\t\tdouble directed_area() const {\n\t\t\tint n = g.size();\n\t\t\tdouble s = 0;\n\t\t\tfor (register int i = 0; i < n; ++i) s += cross(g[i], g[(i + 1) % n]);\n\t\t\treturn s / 2;\n\t\t}\n\t\tbool is_convex() const {\n\t\t\tint n = g.size();\n\t\t\tfor (register int i = 0; i < n; ++i)\n\t\t\t\tif (cross(g[(i + 1) % n] - g[i], g[(i - 1 + n) % n] - g[i]) <= -eps) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tint point_containment(const point &a) const {\n\t\t\tdouble k = sqrt(1.0 * rnd() / rnd());\n\t\t\tline l = line(a, point(a.x + 1e9, a.y + 1e9 * k));\n\t\t\tint n = g.size(), s = 0;\n\t\t\tfor (register int i = 0; i < n - 1; ++i)\n\t\t\t\tif (line(g[i], g[i + 1]).direction(a) == 5) return 1;\n\t\t\tif (line(g[n - 1], g[0]).direction(a) == 5) return 1;\n\t\t\tfor (register int i = 0; i < n - 1; ++i)\n\t\t\t\tif (segment_intersection(l, line(g[i], g[i + 1]))) ++s;\n\t\t\tif (segment_intersection(l, line(g[n - 1], g[0]))) ++s;\n\t\t\tif (s & 1) return 2; else return 0;\n\t\t}\n\t\tvoid convex_hull(std :: vector<point> f){\n\t\t\tg.clear();\n\t\t\tint n = f.size();\n\t\t\tstd :: sort(f.begin(), f.end());\n\t\t\tstd :: vector<point> p;\n\t\t\tp.push_back(f[0]);\n\t\t\tfor (register int i = 1; i < n; ++i){\n\t\t\t\twhile (p.size() > 1 && cross(f[i] - p.back(), *(++p.rbegin()) - p.back()) <= -eps)\n\t\t\t\t\tp.pop_back();\n\t\t\t\tp.push_back(f[i]);\n\t\t\t}\n\t\t\tfor (register int i = 0; i < p.size() - 1; ++i) g.push_back(p[i]);\n\t\t\tstd :: reverse(f.begin(), f.end());\n\t\t\tp.clear(), p.push_back(f[0]);\n\t\t\tfor (register int i = 1; i < n; ++i){\n\t\t\t\twhile (p.size() > 1 && cross(f[i] - p.back(), *(++p.rbegin()) - p.back()) <= -eps)\n\t\t\t\t\tp.pop_back();\n\t\t\t\tp.push_back(f[i]);\n\t\t\t}\n\t\t\tfor (register int i = 0; i < p.size() - 1; ++i) g.push_back(p[i]);\n\t\t\tf = g, n = f.size(), g.clear();\n\t\t\tint t = 0;\n\t\t\tfor (register int i = 1; i < n; ++i)\n\t\t\t\tif (f[i].y < f[t].y || (f[i].y == f[t].y && f[i].x < f[t].x)) t = i;\n\t\t\tfor (register int i = t; i < n; ++i) g.push_back(f[i]);\n\t\t\tfor (register int i = 0; i < t; ++i) g.push_back(f[i]);\n\t\t}\n\t\tdouble convex_diamater() const {\n\t\t\tint n = g.size();\n\t\t\tdouble ans = 0;\n\t\t\tfor (register int i = 0, j = 0; i < n; ++i){\n\t\t\t\twhile (cross(g[i] - g[j], g[(i + 1) % n] - g[j])\n\t\t\t\t  < cross(g[i] - g[(j + 1) % n], g[(i + 1) % n] - g[(j + 1) % n]) + eps)\n\t\t\t\t\tj = (j + 1) % n;\n\t\t\t\tans = std :: max(ans, distance(g[j], g[i]));\n\t\t\t\tans = std :: max(ans, distance(g[j], g[(i + 1) % n]));\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t};\n\tstruct circle{\n\t\tpoint o;\n\t\tdouble r;\n\t\tcircle(){}\n\t\tcircle(point _o, double _r){ o = _o, r = _r; }\n\t\tvoid read(){ o.read(), scanf(\"%lf\", &r); }\n\t\tvoid print(char ch = '\\n') const { printf(\"%.10lf %.10lf %.10lf\", o.x, o.y, r), putchar(ch); }\n\t\tint circle_intersection(const circle &c) const {\n\t\t\tdouble d = distance(o, c.o);\n\t\t\tif (d >= r + c.r + eps) return 4;\n\t\t\tif (equal(d, r + c.r)) return 3;\n\t\t\tif (d >= fabs(r - c.r) + eps) return 2;\n\t\t\tif (equal(d, fabs(r - c.r))) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\tstd :: vector<point> directed_line_cross_point(const line &l) const {\n\t\t\tpoint p = line(l.a, l.b).projection(o), v = (l.b - l.a).unit();\n\t\t\tdouble d = distance(p, o);\n\t\t\tif (d >= r + eps) return {};\n\t\t\tdouble t = sqrt(r * r - (p - o).len2());\n\t\t\tif (equal(t, 0)) return {p};\n\t\t\telse return {p - v * t, p + v * t};\n\t\t}\n\t\tstd :: vector<point> circle_cross_point(const circle &c) const {\n\t\t\tdouble d = distance(o, c.o);\n\t\t\tif (d <= fabs(r - c.r) - eps || d >= r + c.r + eps) return {};\n\t\t\tdouble x = (r * r - c.r * c.r + d * d) / (d * 2), h = sqrt(r * r - x * x);\n\t\t\tpoint p = (c.o - o).unit() * x, v = (c.o - o).unit().rotation(pi / 2) * h;\n\t\t\tif (v == point(0, 0)) return {p}; else return {p - v, p + v};\n\t\t}\n\t\tstd :: vector<point> tangent(const point &p) const {\n\t\t\tdouble d = distance(o, p);\n\t\t\tif (d <= r - eps) return {};\n\t\t\tif (equal(d, r)) return {p};\n\t\t\treturn circle_cross_point(circle(p, sqrt(d * d - r * r)));\n\t\t}\n\t\tstd :: vector<point> common_tangent_out(const circle &c) const {\n\t\t\tif (equal(r, c.r)){\n\t\t\t\tpoint p = (c.o - o).unit().rotation(pi / 2) * r;\n\t\t\t\treturn {o - p, o + p};\n\t\t\t}\n\t\t\tpoint p = (o * c.r - c.o * r) / (c.r - r);\n\t\t\treturn tangent(p);\n\t\t}\n\t\tstd :: vector<point> common_intangent_in(const circle &c) const {\n\t\t\tpoint p = (o * c.r + c.o * r) / (r + c.r);\n\t\t\treturn tangent(p);\n\t\t}\n\t\tdouble directed_triangle_intersection(const point &a, const point &b) const {\n\t\t\tbool ta = a.x * a.x + a.y * a.y < r * r + eps, tb = b.x * b.x + b.y * b.y < r * r + eps;\n\t\t\tstd :: vector<point> t = circle(point(0, 0), r).directed_line_cross_point(line(b, a));\n\t\t\tif (ta == 1 && tb == 1) return cross(a, b) / 2;\n\t\t\tif (ta == 1 && tb == 0) return angle(t.front(), b) * r * r / 2 + cross(a, t.front()) / 2;\n\t\t\tif (ta == 0 && tb == 1) return angle(a, t.back()) * r * r / 2 + cross(t.back(), b) / 2;\n\t\t\tdouble s = angle(a, b) * r * r / 2;\n\t\t\tif (distance_ps(point(0, 0), line(a, b)) > r - eps) return s;\n\t\t\treturn s + angle(t.front(), t.back()) * r * r / 2 - cross(t.front(), t.back()) / 2;\n\t\t}\n\t\tdouble directed_polygon_intersection(const polygon &g) const {\n\t\t\tint n = g.size();\n\t\t\tdouble s = 0;\n\t\t\tfor (register int i = 0; i < n; ++i)\n\t\t\t\ts += directed_triangle_intersection(g[i] - o, g[(i + 1) % n] - o);\n\t\t\treturn s;\n\t\t}\n\t};\n}\nusing namespace Geometry;\npoint p, t;\nline l, m;\npolygon g;\ncircle c;\nstd :: vector<point> v, res;\nint n, q;\ndouble r;\nvoid CGL_1_A(){\n\tl.read(), scanf(\"%d\", &q);\n\twhile (q--) p.read(), l.projection(p).print();\n}\nvoid CGL_1_B(){\n\tl.read(), scanf(\"%d\", &q);\n\twhile (q--) p.read(), l.reflection(p).print();\n}\nvoid CGL_1_C(){\n\tl.read(), scanf(\"%d\", &q);\n\twhile (q--){\n\t\tp.read();\n\t\tint t = l.direction(p);\n\t\tif (t == COUNTER_CLOCKWISE) puts(\"COUNTER_CLOCKWISE\");\n\t\tif (t == CLOCKWISE) puts(\"CLOCKWISE\");\n\t\tif (t == ONLINE_BACK) puts(\"ONLINE_BACK\");\n\t\tif (t == ONLINE_FRONT) puts(\"ONLINE_FRONT\");\n\t\tif (t == ON_SEGMENT) puts(\"ON_SEGMENT\");\n\t}\n}\nvoid CGL_2_A(){\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read(), m.read();\n\t\tif (parallel(l, m)) puts(\"2\");\n\t\telse if (orthogonal(l, m)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n}\nvoid CGL_2_B(){\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read(), m.read();\n\t\tif (segment_intersection(l, m)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n}\nvoid CGL_2_C(){\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read(), m.read();\n\t\tline_cross_point(l, m)[0].print();\n\t}\n}\nvoid CGL_2_D(){\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tl.read(), m.read();\n\t\tprintf(\"%.10lf\\n\", distance_ss(l, m));\n\t}\n}\nvoid CGL_3_A(){\n\tg.read(), printf(\"%.1lf\\n\", g.directed_area());\n}\nvoid CGL_3_B(){\n\tg.read(), printf(\"%d\\n\", g.is_convex());\n}\nvoid CGL_3_C(){\n\tg.read();\n\tscanf(\"%d\", &q);\n\twhile (q--){\n\t\tp.read();\n\t\tprintf(\"%d\\n\", g.point_containment(p));\n\t}\n}\nvoid CGL_4_A(){\n\tscanf(\"%d\", &n), v.resize(n);\n\tfor (register int i = 0; i < n; ++i) v[i].read();\n\tg.convex_hull(v);\n\tprintf(\"%d\\n\", g.size());\n\tfor (register int i = 0; i < g.size(); ++i) printf(\"%d %d\\n\", int(g[i].x), int(g[i].y));\n}\nvoid CGL_4_B(){\n\tg.read(), printf(\"%.10lf\\n\", g.convex_diamater());\n}\nvoid CGL_7_H(){\n\tint n;\n\tdouble r;\n\tscanf(\"%d%lf\", &n, &r);\n\tpolygon g(n);\n\tfor (register int i = 0; i < n; ++i) g[i].read();\n\tprintf(\"%.10lf\\n\", fabs(circle(point(0, 0), r).directed_polygon_intersection(g)));\n}\nint main(){\n\tCGL_4_B();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<double> Point;\nconst double eps = 1e-10;\n\ndouble dist(const Point &a,const Point &b)\n{\n    return abs(a-b);\n}\n\ndouble cross(const Point &a,const Point &b)\n{\n    return imag(b*conj(a));\n}\n\ndouble getDiameter(const vector<Point> &points,int sz)\n{\n    double ans = 0;\n    int lm=0,rm=0;\n    for(int i=0;i<sz;i++)\n    {\n        if(points[lm].real()>points[i].real()) lm=i;\n        if(points[rm].real()<points[i].real()) rm=i;\n    }\n    int i=lm,j=rm;\n    while(i!=rm || j!=lm)\n    {\n        ans=max(ans,dist(points[i],points[j]));\n        if(cross(points[(i+1)%sz]-points[i],points[(j+1)%sz]-points[j])<-eps)\n        {\n            i=(i+1)%sz;\n        }else\n        {\n            j=(j+1)%sz;\n        }\n    }\n\n    return ans;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin>>n;\n    vector<Point> points;\n    for(int i=0;i<n;i++)\n    {\n        double x,y;\n        cin>>x>>y;\n        points.emplace_back(x,y);\n    }\n\n    cout<<setprecision(10)<<fixed<<getDiameter(points,n)<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n        \n        double max_l = 0.0;\n        for(int i=0; i<q; i++){\n            for(int j=i+1; j<q; j++){\n                double temp =max_l;\n                max_l=max(max_l,distance_between_the_two_pointss(ans[i][0], ans[i][1], ans[j][0], ans[j][1]));\n                if(temp==max_l)break;\n            }\n        }\n        \n        \n\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\ntypedef long double     lf;\n\nusing namespace std;\n\nconst lf EPS = 1e-9;\nconst lf oo = 1e15;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << int(p.x) << \" \" << int(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf dot( pt A, pt B ) {\n  return x(A)*x(B) + y(A)*y(B);\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nlf distToLine (pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  c = A + u*( B-A );\n  return dist( p , c );\n}\n\npt refPoint(pt X, pt A, pt B) {\n  pt aux; distToLine(X, A, B, aux);\n  return X + lf(2.0)*(aux-X);\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf cross( pt A, pt B ) {\n  return x(A)*y(B) - y(A)*x(B);\n}\n\n///CHANGE\n// 0  for collineal points ( angle = 0 )\n// 1  for angle BAX counter clockwise\n// -1 for angle BAX clockwise\ninline int ccw (pt X, pt A, pt B) {\n  lf c = cross( B-A, X-A );\n  if( same( c, 0.0 ) ) { return 0; }\n  if( c > EPS ) { return 1; }\n  return -1;\n}\n\n///CHANGE\ninline bool segContains ( pt X, pt A, pt B) {\n  if ( !same ( 0, cross ( A-X, B-X ) ) ) return 0;\n  return ( dot ( A-X, B-X ) < EPS );\n}\n\ninline bool parallel( pt A, pt B, pt C, pt D ) {\n  return same ( 0, cross( B-A, D-C ) );\n}\n\n///NEW\ninline bool ortho( pt A, pt B, pt C, pt D ) {\n  return same ( 0, dot( B-A, D-C ) );\n}\n\ninline bool samePt ( pt A, pt B ) {\n  return same ( x(A), x(B) ) && same ( y(A), y(B) );\n}\n\npt linesIntersection ( pt A, pt B, pt C, pt D ) {\n  lf x = cross ( C, D-C ) - cross ( A, D-C );\n  x /= cross ( B-A, D-C );\n  return A + x*(B-A);\n}\n\ninline bool collinearSegsIntersects ( pt A, pt B, pt C, pt D ) {\n  return segContains(A,C,D) || segContains(B,C,D)\n      || segContains(C,A,B) || segContains(D,A,B);\n}\n\nbool segmentsIntersect(pt A, pt B, pt C, pt D) {\n  if( samePt(A,B) )\n    return segContains( A, C, D );\n  if( samePt(C,D) )\n    return segContains( C, A, B );\n  if( parallel(A,B,C,D) )\n    return collinearSegsIntersects( A,B,C,D );\n  pt aux = linesIntersection(A,B,C,D);\n  return segContains(aux,A,B) && segContains(aux,C,D);\n}\n\n///CHANGE\nlf distToSegment(pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  if( u < -EPS ) { c = A; return dist( p , A ); }\n  if( (u-1.0) > EPS ) { c = B; return dist( p, B ); }\n  return distToLine(p,A,B,c);\n}\n\n// P[0] must be equal to P[n]\n// Area is positive if the polygon is ccw\ndouble signedArea(const vector<pt> &P) {\n  double result = 0.0;\n  for(int i = 0; i < (int)P.size()-1; i++) result += cross( P[i],P[i+1] );\n  return result / 2.0;\n}\n\ndouble area(const vector<pt> &P) { return fabs(signedArea(P)); }\n\n///CHANGE\n// P[0] must be equal to P[n]\nbool isConvex( const vector<pt> &P) {\n  int sz = (int) P.size(); if(sz <= 3) return false;\n  bool isL = ccw(P[0], P[1], P[2]) >= 0;\n  for (int i = 1; i < sz-1; i++) {\n    if( ( ccw(P[i], P[i+1], P[(i+2) == sz ? 1 : i+2]) >= 0 ) != isL) return false;\n  }\n  return true;\n}\n\n///CHANGE\n// P[0] must be equal to P[n]     -    O(N)\n// Return 1 for interior, 0 for boundary and -1 for exterior\nint inPolygon(pt X, const vector<pt> &P) {\n  const int n = P.size(); int cnt = 0;\n  for (int i = 0; i < n-1; i++) {\n    if( segContains(X, P[i], P[i+1]) ) return 0;\n    if( y(P[i]) <= y(X) ) {\n      if( y(P[i+1]) > y(X) )\n        if( !(ccw( X, P[i], P[i+1]) >= 0) ) cnt++;\n    }\n    else if ( y(P[i+1]) <= y(X) ) {\n      if( ccw( X, P[i], P[i+1]) >= 0 ) cnt--;\n    }\n  }\n  if(cnt == 0) return -1;\n  else return 1;\n}\n\n///CHANGE\n//CONVEX HULL Monotone Chain O( N Log N )\nbool cmpPt( pt A, pt B ) {\n  if( !same( x(A), x(B) ) ) return x(A) < x(B);\n  return y(A) < y(B);\n}\n\nint turn(pt A, pt B, pt C) {\n  lf r = cross(B-A, C-A);\n  if( same( r, 0.0 ) ) return 0;\n  if( r > EPS ) return 1;\n  return -1;\n}\n\n// Return CH in ccw order starting at leftmost - downmost x\n// Doesn't return P[ n ] = P[ 0 ]\nvector<pt> CH( vector<pt> &P ) {\n  if ( P.size() == 1 ) return P;\n  const int n = P.size();\n  sort ( P.begin(), P.end(), cmpPt );\n  vector<pt> up;\n  up.push_back(P[0]); up.push_back(P[1]);\n  vector<pt> dn;\n  dn.push_back(P[0]); dn.push_back(P[1]);\n  for ( int i = 2; i < n; ++i ) {\n    // If collineal points are not needed, is >= and <=, otherwise > and <\n    while ( up.size() > 1 && turn(up[up.size()-2],up.back(),P[i]) >= 0 )\n      up.pop_back();\n    while ( dn.size() > 1 && turn(dn[dn.size()-2],dn.back(),P[i]) <= 0 )\n      dn.pop_back();\n    up.push_back(P[i]);\n    dn.push_back(P[i]);\n  }\n  for (int i = (int) up.size() - 2; i >= 1; i--) dn.push_back(up[i]);\n  return dn;\n}\n\n/// --------------------------------------------\n\nint n;\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  vector<pt> P(n);\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  int idx;\n  lf ans = -oo;\n  int sz = int(P.size());\n  for( int i = 0, j = 0; i < n; ++i ) {\n    while( dist( P[i], P[j] )+EPS < dist( P[i], P[ (j+1)%sz ] )  ) {\n      j = (j+1)%sz;\n    }\n    ans = max( ans, dist( P[i], P[j] ) );\n  }\n  cout << double(ans) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; vector<double> x, y;\n    \n    cin >> n;\n    \n    x = vector<double>(n);\n    y = vector<double>(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> x[i] >> y[i];\n    }\n    \n    double diameter = 0.0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            diameter = max(sqrt((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i])), diameter);\n        }\n    }\n    \n    printf(\"%.9f\\n\", diameter);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <assert.h>\n#include <complex>\n#include <utility>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <tuple>\n#include <cmath>\n#include <bitset>\n#include <cctype>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <numeric>\n#include <functional>\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(ll i=ll(a);i<ll(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define rrep(i,a) for(ll i=ll(a-1);i>=0;--i)\n#define all(x) (x).begin(),(x).end()\n#define PRINT(V) cout << V << \"\\n\"\n#define SORT(V) sort((V).begin(),(V).end())\n#define RSORT(V) sort((V).rbegin(), (V).rend())\nusing namespace std;\nusing ll = long long;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline void Yes(bool condition){ if(condition) PRINT(\"Yes\"); else PRINT(\"No\"); }\ntemplate<class itr> void cins(itr first,itr last){\n    for (auto i = first;i != last;i++){\n        cin >> (*i);\n    }\n}\ntemplate<class itr> void array_output(itr start,itr goal){\n    string ans = \"\",k = \" \";\n    for (auto i = start;i != goal;i++) ans += to_string(*i)+k;\n    if (!ans.empty()) ans.pop_back();\n    PRINT(ans);\n}\nll gcd(ll a, ll b) {\n    return a ? gcd(b%a,a) : b;\n}\n\nconst ll INF = 1e15;\nconst ll MOD = 1000000007;\nconst ll MOD2 = 998244353;\nconst ll EPS = 1e-10;\nint sgn(const double a){\n    return (a < -EPS ? -1 : (a > EPS ? +1 : 0));\n}\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> tri;\ntypedef pair<double,double> point;\ntypedef complex<double> Point;\nconst ll MAX = 30000;\nconstexpr ll nx[8] = {1,0,-1,0,1,-1,1,-1};\nconstexpr ll ny[8] = {0,1,0,-1,1,1,-1,-1};\n\n// complexをpair-likeに\nbool complexSort(Point lhs,Point rhs){\n    if (sgn(lhs.real()-rhs.real())){\n        return lhs.real() < rhs.real();\n    }\n    else{\n        return lhs.imag() < rhs.imag();\n    }\n}\n\ndouble cross(Point z1,Point z2){\n    return (conj(z1)*z2).imag();\n}\n//graham scan\nvector<Point> convex_hull(vector<Point> p){\n    sort(all(p),complexSort);\n    int cnt = 0,n = p.size();\n    vector<Point> s(n*2);\n    rep(i,n){\n        while (cnt > 1 && sgn(cross(s[cnt-1]-s[cnt-2],p[i]-s[cnt-1])) <= 0) cnt--;\n        s[cnt++] = p[i];\n    }\n    for (ll i = n-2,t = cnt;i >= 0;i--){\n        while (cnt > t && sgn(cross(s[cnt-1]-s[cnt-2],p[i]-s[cnt-1])) <= 0) cnt--;\n        s[cnt++] = p[i];\n    }\n    s.resize(cnt-1);\n    return s;\n}\n\n//caliper\ndouble convex_diameter(vector<Point> p){\n    int n = p.size();\n    if (n == 2){\n        return abs(p[0]-p[1]);\n    }\n    int i = 0,j = 0;\n    rep(k,n){\n        if (!complexSort(p[i],p[k])) i = k;\n        if (complexSort(p[j],p[k])) j = k;\n    }\n    double res = 0;\n    int si = i,sj = j;\n    while (i != sj || j != si){\n        chmax(res,abs(p[i]-p[j]));\n        if (sgn(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])) < 0){\n            i = (i+1)%n;\n        }\n        else{\n            j = (j+1)%n;\n        }\n    }\n    return res;\n}\n\nint main(){\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    ll n;\n    cin >> n;\n    vector<Point> p;\n    double x,y;\n    rep(i,n){\n        cin >> x >> y;\n        p.push_back(Point(x,y));\n    }\n    auto s = convex_hull(p);\n    printf(\"%.10lf\\n\",convex_diameter(s));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \nint main()\n{\n    int n; vector<double> x, y;\n     \n    cin >> n;\n     \n    x = vector<double>(n);\n    y = vector<double>(n);\n     \n    for(int i = 0; i < n; i++)\n    {\n        cin >> x[i] >> y[i];\n    }\n     \n    double diameter = 0.0;\n     \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            diameter = max((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]), diameter);\n        }\n    }\n     \n    printf(\"%.9f\\n\", sqrt(diameter));\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tR res=0.0;\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nint ans = 0;\n  const double EPS = 1e-8;\n  const double INF = 1e12;\n  typedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\n  namespace std {\n    bool operator < (const P& a, const P& b) {//x????????????\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool sorty(const P& a, const P& b) {//y????????????\n      return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n  }\n  double cross(const P& a, const P& b) {//??????\n    return imag(conj(a)*b);\n  }\n  double dot(const P& a, const P& b) {//??????\n    return real(conj(a)*b);\n  }\n\n  struct L : public vector<P> {//??´???\n    L(){};\n    L(const P &a, const P &b) {\n      push_back(a); push_back(b);\n    }\n  };\n\n  typedef vector<P> G;\n\n  struct C {//???\n    P p; double r;\n    C(){};\n    C(const P &p, double r) : p(p), r(r) { }\n  };\n  int ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0; // a--c--b on line\n  }\n  int linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n    P a = ab[1] - ab[0],b = cd[1] - cd[0];\n    if(abs(cross(a,b)) < EPS){ // Parallel\n      return 2;\n    }\n    else if(abs(dot(a,b)) < EPS){ //Orthogonal\n      return 1;\n    }\n    return 0;\n  }\n  // L:line,S:segment,P:point\n  bool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n      abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n  }\n  bool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n      cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n  }\n  bool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n  }\n  bool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n      ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n  }\n  bool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n  }\n  // L & P intersection\n  P projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n  }\n  // L????????????P???????°????\n  P reflection(const L &l, const P &p) {\n    return p + 2.0 * (projection(l, p) - p);\n  }\n  double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n  }\n  double distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n  }\n  double distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n  }\n  double distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n  }\n  double distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n  }\n  double distancePP(const P &p,const P &q){\n    return abs(p - q) ;\n  }\n  P crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n  }\n  P verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n    if(a.real() == b.real()){\n      return {1.0,0};\n    }\n    if(a.imag() == b.imag()){\n      return {0,1.0};\n    }\n    P p = a - b;\n    P res = {-p.imag(),p.real()};\n    return res / abs(p);\n  }\n  pair<P,P> crosspointCircle(const C &a,const C &b){\n    P m = (a.p+b.p)/2.0;\n    P vv = verticalvector(a.p,b.p);\n    double u = sqrt( a.r * a.r - norm(a.p - b.p) / 4.0);\n    P A = m + u * vv,B = m - u * vv;\n    return mp(A,B);\n  }\n  double calc_triangle(P a,P b,P c){\n    P ba = (b - a);\n    P ca = (c - a);\n    return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n  }\n  double calc_area(const G &g){\n    double res = 0;\n    rep(i,g.size()-2){\n      res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n    }\n    return res;\n  }\n  bool is_convex(const G &g){\n    if(g.size() == 3) return true;\n    rep(i,g.size()){\n      if(ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != 1 && ccw(g[i],g[(i+1) % g.size()],g[(i+2) % g.size()]) != -2){\n        return false;\n      }\n    }\n    return true;\n  }\n  int convex_point(const G &g,const P &p){\n    P q = p-P(-INF,imag(p));\n    double x = real(p),y = imag(p);\n    L l1(p,q);\n    ll cn = 0;\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      L l2 = L(a,b);\n      int k = ccw(a,b,p);\n      if(k == 0){\n        return 1; // p on g\n      }\n    }\n    rep(i,g.size()){\n      P a = g[i],b = g[(i+1) % g.size()];\n      double y1 = imag(a),y2 = imag(b);\n      if(!(y1 == y && y2 == y) && ((y1 <= y && y < y2) || (y2 <= y && y < y1))){\n        L l2 = L(a,b);\n        P c = crosspoint(l1,l2);\n        if(x < real(c))\n          ++cn;\n      }\n    }\n    if(cn % 2) return 2; // p in g\n    return 0; // p out g\n  }\nvector<P> convex_hull(vector<P> &ps){\n  sort(all(ps));\n  int k = 0;\n  int n = ps.size();\n  vector<P> qs(ps.size() * 2);\n  rep(i,ps.size()){\n    while(k > 1 && cross((qs[k-1] -qs[k-2]),(ps[i] - qs[k-1])) < 0){\n      k--;\n    }\n    qs[k++] = ps[i];\n  }\n  for(int i = n-2,t = k; i >= 0; i--){\n    while(k>t && cross((qs[k-1] - qs[k-2]),(ps[i]-qs[k-1])) < 0){\n      k--;\n    }\n    qs[k++] = ps[i] ;\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  double x,y;\n  cin >> n;\n  vector<P> v(n);\n  rep(i,n){\n    cin >> x >> y;\n    v[i] = P{x,y};\n  }\n  auto hull = convex_hull(v);\n  int k = hull.size(),st = 0;\n  double res = 0;\n  rep(i,k){\n    rep(j,k){\n      res = max(res,distancePP(hull[i],hull[j]));\n    }\n  }\n  fcout(10) << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst double eps = 1e-15;\n\nclass Point\n{\npublic:\n    double x, y;\n    Point() : x(0), y(0) {}\n    Point(double _x, double _y) : x(_x), y(_y) {}\n};\n\nistream& operator >> (istream& in, Point& P)\n{\n    in >> P.x >> P.y;\n    return in;\n}\n\nostream& operator << (ostream& out, const Point& P)\n{\n    out << P.x << \" \" << P.y;\n    return out;\n}\n\nostream& operator << (ostream& out, vector<Point> vP)\n{\n    size_t n = vP.size();\n    for (int i = 0; i < n; ++i) {\n        out << vP[i] << endl;\n    }\n    return out;\n}\n\ndouble Dist(const Point& P, const Point& Q)\n{\n    double dx = P.x - Q.x;\n    double dy = P.y - Q.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble FindDiameter(const vector<Point>& vP)\n{\n    int i = 0, j = 1;\n    double Res = Dist(vP[i], vP[j]);\n\n    while (1) {\n        bool bUpdate = false;\n        while (1) {\n            if (j < vP.size() - 1 && Dist(vP[i], vP[j]) < Dist(vP[i], vP[j+1])) {\n                Res = max(Res, Dist(vP[i], vP[j+1]));\n                j++;\n                bUpdate = true;\n            } else {\n                break;\n            }\n        }\n        while (1) {\n            if (Dist(vP[i], vP[j]) < Dist(vP[i+1], vP[j])) {\n                Res = max(Res, Dist(vP[i+1], vP[j]));\n                i++;\n                bUpdate = true;\n            } else {\n                break;\n            }\n        }\n        if (j == vP.size() - 1) break;\n        if (!bUpdate) ++i;\n    }\n\n\n    return Res;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<Point> vP(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> vP[i];\n    }\n\n    cout << fixed << setprecision(10);\n    cout << FindDiameter(vP);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n        \n        double max_l = 0.0;\n        for(int i=0; i<q; i++){\n            for(int j=0; j<i; j++){\n                max_l=max(max_l,distance_between_the_two_pointss(ans[i][0], ans[i][1], ans[j][0], ans[j][1]));\n            }\n        }\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct F {\n\tlong long a, b;\n\tF() {}\n\tF(long long _a, long long _b) : a(_a), b(_b) {}\n\tF operator + (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.a + a * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator - (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.a - a * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator * (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator / (const F &f) {\n\t\tlong long x = a * f.b, y = b * f.a;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n};\nconst double pi = acos(-1);\nconst double eps = 1e-8;\ninline int sign(double a) {\n\treturn a < -eps ? -1 : a > eps;\n}\ninline int cmp(double a, double b) {\n\treturn sign(a - b);\n}\ndouble add(double a, double b) {\n\tif (abs(a + b) < eps * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\ntypedef double data;\nstruct P {\n\tdata x, y;\n\tP() {}\n\tP(data x, data y) : x(x), y(y) {}\n\tP operator + (const P &p) { return P(x + p.x, y + p.y); }\n\tP operator - (const P &p) { return P(x - p.x, y - p.y); }\n\tP operator * (data d) { return P(x * d, y * d); }\n\tP operator / (data d) { return P(x / d, y / d); }\n\tdata dot(const P &p) { return x * p.x + y * p.y; }\n\tdata det(const P &p) { return x * p.y - y * p.x; }\n\tdata disto(const P &p) { return (*this - p).abs(); }\n\tdata alpha() { return atan2(y, x); }\n\tdata abs() { return sqrt(abs2()); }\n\tdata abs2() { return x * x + y * y; }\n\tP rot90() { P(-y, x); }\n\tP unit() { return *this / abs(); }\n\tbool operator < (P p) const {\n\t\tint c = cmp(x, p.x);\n\t\tif (c) return c == -1;\n\t\treturn cmp(y, p.y) == -1;\n\t}\n\tfriend istream& operator>>(istream &in, P &p) {\n\t\tin >> p.x >> p.y;\n\t\treturn in;\n\t}\n\tfriend ostream& operator<<(ostream& out, P &p) {\n\t\tout << p.x << ' ' << p.y;\n\t\treturn out;\n\t}\n};\nP projection(P p1, P p2, P q) {\n\tP dir = p2 - p1;\n\treturn p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\nP reflection(P p1, P p2, P q) {\n\treturn projection(p1, p2, q) * 2 - q;\n}\nbool is_midddle(data a, data m, data b) {\n\treturn sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\nbool is_midddle(P a, P m, P b) {\n\treturn is_midddle(a.x, m.x, b.x) && is_midddle(a.y, m.y, b.y);\n}\nbool on_seg(P p1, P p2, P q) {\n\treturn sign((p1 - q).det(p2 - q)) == 0 && (p1 - q).dot(p2 - q) <= 0;\n\t// return (p1 - q).det(p2 - q) == 0 && is_middle(p1, q, p2);\n}\nbool intersect(data l1, data r1, data l2, data r2) {\n\tif(l1 > r1) swap(l1, r1);\n\tif(l2 > r2) swap(l2, r2);\n\treturn cmp(r1, l2) != -1 && cmp(r2, l1) != -1;\n}\nbool intersect(P p1, P p2, P q1, P q2) {\n\treturn intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y)\n\t&& sign((p2 - p1).det(q1 - p1)) * sign((p2 - p1).det(q2 - p1)) <= 0\n\t&& sign((q2 - q1).det(p1 - q1)) * sign((q2 - q1).det(q2 - q1)) <= 0;\n}\nP intersection(P p1, P p2, P q1, P q2) {\n\tdata a1 = (q2 - q1).det(p1 - q1), a2 = -(q2 - p1).det(p2 - q1);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n\t//line return p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\ndata nearest(P p1, P p2, P q) {\n\tP h = projection(p1, p2, q);\n\tif(is_midddle(p1, h, p2)) return q.disto(h);\n\treturn min(p1.disto(q), p2.disto(q));\n}\ndata seg_dist(P p1, P p2, P q1, P q2) {\n\tif(intersect(p1, p2, q1, q2)) return 0;\n\treturn min(min(nearest(p1, p2, q1), nearest(p1, p2, q2)), min(nearest(q1, q2, p1), nearest(q1, q2, p2)));\n}\ndata area(vector<P> &ps) {\n\tdata res = 0;\n\tint n = ps.size();\n\tfor(int i = 0; i < n; i++) {\n\t\tres += ps[i].det(ps[(i + 1) % n]);\n\t}\n\treturn abs(res / 2);\n}\nbool is_convex(vector<P> &ps) {\n\tint n = ps.size();\n\tfor(int i = 0; i < n; i++) {\n\t\tdata a1 = (ps[(i + 1) % n] - ps[i]).det(ps[(i + 2) % n] - ps[(i + 1) % n]);\n\t\tdata a2 = (ps[(i + 2) % n] - ps[(i + 1) % n]).det(ps[(i + 3) % n] - ps[(i + 2) % n]);\n\t\tif(a1 * a2 < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint contain(vector<P> &ps, P p) {\n\tint n = ps.size(), res = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tP u = ps[i], v = ps[(i + 1) % n];\n\t\tif(on_seg(u, v, p)) return 1;\n\t\tif(cmp(u.y, v.y) <= 0) swap(u, v);\n\t\tif(cmp(p.y, u.y) > 0 || cmp(p.y, v.y) <= 0) continue;\n\t\tres ^= (u - p).det(v - p) > 0;\n\t}\n\treturn res * 2;\n\t//2:inside 1:on_seg 0:outside\n}\nvector<P> convex_hull(vector<P> &ps) {\n\tint n = ps.size();\n\tsort(ps.begin(), ps.end());\n\tint k = 0;\n\tvector<P> qs(n << 1);\n\tfor(int i = 0; i < n; i++) {\n\t\twhile(k > 1 && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile(k > t && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\nvector<P> convex_hull_nonstrict(vector<P> &ps) {\n\tint n = ps.size();\n\tsort(ps.begin(), ps.end());\n\tint k = 0;\n\tvector<P> qs(n << 1);\n\tfor(int i = 0; i < n; i++) {\n\t\twhile(k > 1 && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) < 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile(k > t && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) < 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\ndata convex_diameter(vector<P> &ps) {\n\tint n = ps.size();\n\tif(n <= 1) return 0;\n\tint is = 0, js = 0;\n\tfor(int k = 1; k < n; k++) {\n\t\tis = ps[k] < ps[is] ? k : is;\n\t\tjs = ps[js] < ps[k] ? k : js;\n\t}\n\tint i = is, j = js;\n\tdata res = ps[i].disto(ps[j]);\n\tdo {\n\t\tif((ps[(i + 1) % n] - ps[i]).det(ps[(j + 1) % n] - ps[j]) >= 0) {\n\t\t\t(++j) %= n;\n\t\t} else {\n\t\t\t(++i) %= n;\n\t\t}\n\t\tres = max(res, ps[i].disto(ps[j]));\n\t} while(i != is || j != js);\n\treturn res;\n}\n\nint main() {\n#ifdef LOCAL_DEFINE\n\t//freopen(\"data.in\", \"rt\", stdin);\n\t//freopen(\"data.out\", \"w\", stdout);\n\tauto _start = chrono::high_resolution_clock::now();\n#endif\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tint n;\n\tcin >> n;\n\tvector<P> ps(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> ps[i];\n\t}\n\tvector<P> qs = convex_hull_nonstrict(ps);\n\tdouble ans = convex_diameter(qs);\n\tcout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n\tauto _end = chrono::high_resolution_clock::now();\n\tcerr << \"elapsed time: \" << chrono::duration<double, milli>(_end - _start).count() << \" ms\\n\";\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define ALL(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\nnamespace geom {\n  constexpr double eps = 1e-8;\n\n  /* point */\n  struct Point {\n    double x, y;\n    Point() : x(0.0), y(0.0) {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(this->x + p.x, this->y + p.y); }\n    Point operator-(const Point& p) const { return Point(this->x - p.x, this->y - p.y); }\n    Point operator-() const { return Point(-this->x, -this->y); }\n    Point& operator+=(const Point& p) { return *this = *this + p; }\n    Point& operator-=(const Point& p) { return *this = *this - p; }\n    bool operator==(const Point& p) const { return x == p.x && y == p.y; }\n    bool operator!=(const Point& p) const { return !(*this == p); }\n    bool operator<(const Point& p) const { return x == p.x ? y < p.y : x < p.x; }\n    bool operator<=(const Point& p) const { return *this == p || *this < p; }\n    bool operator>(const Point& p) const { return !(*this <= p); }\n    bool operator>=(const Point& p) const { return !(*this < p); }\n    double length() const { return std::sqrt(x * x + y * y); }\n    double length2() const { return x * x + y * y; }\n    double distance(const Point& p) const { return sqrt(pow(x - p.x, 2.0) + pow(y - p.y, 2.0)); }\n    friend std::ostream& operator<<(std::ostream& o, const Point& p) {\n      o << '(' << p.x << ',' << p.y << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Point& p) {\n      i >> p.x >> p.y;\n      return i;\n    }\n  };\n  \n  /* vector */\n  using Vector = Point;\n  double cross_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n  }\n  double inner_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n  }\n  enum struct ccw_t {\n    COUNTER_CLOCKWISE,\n    CLOCKWISE,\n    ONLINE_BACK,\n    ONLINE_FRONT,\n    ON_SEGMENT\n  };\n  ccw_t ccw(const Point& p0, const Point& p1, const Point& p2) {\n    Vector v1 = p1 - p0, v2 = p2 - p0;\n    if (cross_product(v1, v2) > eps) return ccw_t::COUNTER_CLOCKWISE;\n    if (cross_product(v1, v2) < -eps) return ccw_t::CLOCKWISE;\n    if (inner_product(v1, v2) < -eps) return ccw_t::ONLINE_BACK;\n    if (v1.length2() < v2.length2()) return ccw_t::ONLINE_FRONT;\n    return ccw_t::ON_SEGMENT;\n  }\n\n  /* line */\n  struct Line {\n    Point p1, p2;\n    Line() {}\n    Line(const Point& p1, const Point& p2) : p1(p1), p2(p2) {}\n    Line(double x1, double y1, double x2, double y2) : p1(Point(x1, y1)), p2(Point(x2, y2)) {}\n    Vector to_vector() const { return p2 - p1; }\n    Point projection(const Point& p) const {\n      Vector v12(p2 - p1);\n      double det = v12.length2();\n      double a = v12.y * p1.x - v12.x * p1.y, b = v12.y * p.y + v12.x * p.x;\n      double x = v12.y * a + v12.x * b, y = v12.y * b - v12.x * a;\n      return Point(x / det, y / det);\n    }\n    Point reflection(const Point& p) const {\n      Point proj = projection(p);\n      return proj + proj - p;\n    }\n    double distance(const Point& p) const {\n      return projection(p).distance(p);\n    }\n    bool is_parallel(const Line& l) const {\n      return abs(cross_product(this->to_vector(), l.to_vector())) < eps;\n    }\n    bool is_orthogonal(const Line& l) const {\n      return abs(inner_product(this->to_vector(), l.to_vector())) < eps;\n    }\n    Point intersection(const Line& l) const {\n      Point p0(this->p1), p1(this->p2), p2(l.p1), p3(l.p2);\n      Vector v01(p1 - p0), v23(p3 - p2);\n      double det = cross_product(v01, v23);\n      double a = v01.y * p0.x - v01.x * p0.y, b = v23.y * p2.x - v23.x * p2.y;\n      double x = v01.x * b - v23.x * a;\n      double y = v01.y * b - v23.y * a;\n      return Point(x / det, y / det);\n    }\n    friend std::ostream& operator<<(std::ostream& o, const Line& l) {\n      o << '(' << l.p1 << ',' << l.p2 << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Line& l) {\n      i >> l.p1 >> l.p2;\n      return i;\n    }\n  };\n\n  /* segment */\n  using Segment = Line;\n  bool is_intersect_segment(const Segment& s1, const Segment& s2) {\n    Vector v2 = s2.to_vector(), p1(s1.p1 - s2.p1), p2(s1.p2 - s2.p1);\n    if (cross_product(v2, p1) * cross_product(v2, p2) > eps) return false;\n    Vector v1 = s1.to_vector(), p3(s2.p1 - s1.p1), p4(s2.p2 - s1.p1);\n    if (cross_product(v1, p3) * cross_product(v1, p4) > eps) return false;\n    if (inner_product(s2.p1 - s1.p1, s2.p2 - s1.p1) < eps) return true;\n    if (inner_product(s2.p1 - s1.p2, s2.p2 - s1.p2) < eps) return true;\n    if (inner_product(s1.p1 - s2.p1, s1.p2 - s2.p1) < eps) return true;\n    if (inner_product(s1.p1 - s2.p2, s1.p2 - s2.p2) < eps) return true;\n    return false;\n  }\n  double segment_distance(const Segment& s, const Point& p) {\n    Point proj = s.projection(p);\n    if (ccw(s.p1, proj, s.p2) == ccw_t::ONLINE_FRONT) return p.distance(proj);\n    return min(p.distance(s.p1), p.distance(s.p2));\n  }\n  double segment_distance(const Segment& s1, const Segment& s2) {\n    if (is_intersect_segment(s1, s2)) return 0.0;\n    return min({\n      segment_distance(s1, s2.p1), segment_distance(s1, s2.p2),\n      segment_distance(s2, s1.p1), segment_distance(s2, s1.p2)\n      });\n  }\n\n  /* polygon */\n  using Polygon = std::vector<Point>;\n  double area(const Polygon& poly) {\n    if (poly.size() <= 2) return 0;\n    Point b(DBL_MAX, DBL_MAX);\n    for (const Point& p : poly) {\n      b.x = min(b.x, p.x); b.y = min(b.y, p.y);\n    }\n    b.x -= 1.0; b.y -= 1.0;\n    int n = (int)poly.size();\n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n      area += cross_product(poly[i] - b, poly[(i + 1) % n] - b) * 0.5;\n    }\n    return area;\n  }\n  bool is_convex(const Polygon& poly) {\n    if (poly.size() <= 2) return false;\n    int n = (int)poly.size();\n    for (int i = 0; i < n; i++) {\n      if (ccw(poly[i], poly[(i + 1) % n], poly[(i + 2) % n]) == ccw_t::CLOCKWISE) {\n        return false;\n      }\n    }\n    return true;\n  }\n  enum struct poly_t {\n    EXTERNAL = 0,\n    ON_SEGMENT = 1,\n    INTERNAL = 2\n  };\n  poly_t is_inside(const Point& p, const Polygon& poly) {\n    int n = (int)poly.size();\n    double rad = 0.0;\n    for (int i = 0; i < n; i++) {\n      const Point& p1 = poly[i];\n      const Point& p2 = poly[(i + 1) % n];\n      double d1 = p.distance(p1), d2 = p.distance(p2);\n      if (segment_distance(Segment(p1, p2), p) < eps) return poly_t::ON_SEGMENT;\n      Vector v1(p1 - p), v2(p2 - p);\n      double r = atan2(cross_product(v1, v2), inner_product(v1, v2));\n      rad += r;\n    }\n    return rad < eps ? poly_t::EXTERNAL : poly_t::INTERNAL;\n  }\n\n  /* convex hull */\n  using Hull = Polygon;\n  Hull convex_hull(std::vector<Point> points, bool strict = true) {\n    double e = strict ? eps : -eps;\n    std::sort(points.begin(), points.end());\n    int n = (int)points.size(), k = 0;\n    Hull hull(2 * n);\n    for (int i = 0; i < n; i++) {\n      while (k > 1 && cross_product(hull[k - 1] - hull[k - 2], points[i] - hull[k - 1]) < e) k--;\n      hull[k++] = points[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n      while (k > t && cross_product(hull[k - 1] - hull[k - 2], points[i] - hull[k - 1]) < e) k--;\n      hull[k++] = points[i];\n    }\n    hull.resize(k - 1);\n    return hull;\n  }\n  double convex_diameter(const Hull& hull) {\n    int n = hull.size();\n    if (n == 2) return hull.front().distance(hull.back());\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n      if (hull[k] < hull[i]) i = k;\n      if (hull[j] < hull[k]) j = k;\n    }\n    double d = 0.0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n      d = max(d, hull[i].distance(hull[j]));\n      if (cross_product(hull[(i + 1) % n] - hull[i], hull[(j + 1) % n] - hull[j]) < 0.0) {\n        i = (i + 1) % n;\n      }\n      else {\n        j = (j + 1) % n;\n      }\n    }\n    return d;\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  using namespace geom;\n\n  int n;\n  cin >> n;\n  Hull hull(n);\n  cin >> hull;\n\n  cout << fixed << setprecision(15);\n  cout << convex_diameter(hull) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define TemplateVersion \"3.4.0\"\n// Useful Marcos\n//====================START=====================\n// Compile use C++11 and above\n#ifdef LOCAL\n#define debug(args...)                           \\\n    {                                            \\\n        string _s = #args;                       \\\n        replace(_s.begin(), _s.end(), ',', ' '); \\\n        stringstream _ss(_s);                    \\\n        istream_iterator<string> _it(_ss);       \\\n        err(_it, args);                          \\\n    }\nvoid err(istream_iterator<string> it)\n{\n}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\n#define MSG cout << \"Finished\" << endl\n#else\n#define debug(args...)\n#define MSG\n#endif\n#if __cplusplus >= 201703L\ntemplate <typename... Args>\nvoid readln(Args &... args)\n{\n    ((cin >> args), ...);\n}\ntemplate <typename... Args>\nvoid writeln(Args... args)\n{\n    ((cout << args << \" \"), ...);\n    cout << endl;\n}\n#elif __cplusplus >= 201103L\nvoid readln()\n{\n}\ntemplate <typename T, typename... Args>\nvoid readln(T &a, Args &... args)\n{\n    cin >> a;\n    readln(args...);\n}\nvoid writeln()\n{\n    cout << endl;\n}\ntemplate <typename T, typename... Args>\nvoid writeln(T a, Args... args)\n{\n    cout << a << \" \";\n    writeln(args...);\n}\n#endif\n#if __cplusplus >= 201103L\n#define FOR(_i, _begin, _end) for (auto _i = _begin; _i < _end; _i++)\n#define FORR(_i, _begin, _end) for (auto _i = _begin; _i > _end; _i--)\n#else\n#define FOR(_i, _begin, _end) for (int _i = (int)_begin; _i < (int)_end; _i++)\n#define FORR(_i, _begin, _end) for (int _i = (int)_begin; _i > (int)_end; _i--)\n#define nullptr NULL\n#endif\n#if __cplusplus >= 201103L\n#define VIS(_kind, _name, _size) \\\n    vector<_kind> _name(_size);  \\\n    for (auto &i : _name)        \\\n        cin >> i;\n#else\n#define VIS(_kind, _name, _size)    \\\n    vector<_kind> _name;            \\\n    _name.resize(_size);            \\\n    for (int i = 0; i < _size; i++) \\\n        cin >> _name[i];\n#endif\n// alias\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define tcase() \\\n    int T;      \\\n    cin >> T;   \\\n    FOR(kase, 1, T + 1)\n// Swap max/min\ntemplate <typename T>\nbool smax(T &a, const T &b)\n{\n    if (a > b)\n        return false;\n    a = b;\n    return true;\n}\ntemplate <typename T>\nbool smin(T &a, const T &b)\n{\n    if (a < b)\n        return false;\n    a = b;\n    return true;\n}\n// ceil divide\ntemplate <typename T>\nT cd(T a, T b)\n{\n    return (a + b - 1) / b;\n}\n// min exchange\ntemplate <typename T>\nbool se(T &a, T &b)\n{\n    if (a < b)\n        return false;\n    swap(a, b);\n    return true;\n}\n// A better MAX choice\nconst int INF = 0x3f3f3f3f;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef set<int> si;\ntypedef vector<string> cb;\n//====================END=====================\n\n// Constants here\nconst double EPS = 1e-4;\nconst double PI = acos(-1);\nconst double FAC = 1e-18;\n\ntypedef double db;\n\nint sgn(db x)\n{\n    if (abs(x) < EPS)\n        return 0;\n    if (x < 0)\n        return -1;\n    return 1;\n}\n\ndb Min(db a, db b) { return sgn(a - b) > 0 ? b : a; }\ndb Max(db a, db b) { return sgn(a - b) > 0 ? a : b; }\n\n// Point/Vector\nstruct Point\n{\n    db x, y;\n\n    Point() : x(0.0), y(0.0) {}\n\n    Point(db _x, db _y) : x(_x), y(_y) {}\n\n    bool operator==(const Point &p)\n    {\n        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;\n    }\n\n    bool operator<(const Point &p)\n    {\n        int c = sgn(x - p.x);\n        if (c)\n            return c == -1;\n        return sgn(y - p.y) == -1;\n    }\n\n    Point operator+(const Point &p) { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point &p) { return Point(x - p.x, y - p.y); }\n    Point operator*(db d) { return Point(x * d, y * d); }\n    Point operator/(db d) { return Point(x / d, y / d); }\n\n    db operator^(const Point &p) { return x * p.y - y * p.x; }\n    db operator*(const Point &p) { return x * p.x + y * p.y; }\n\n    db dis(const Point &p) { return (*this - p).len(); }\n    db alpha() { return atan2(y, x); }\n\n    Point unit() { return *this / len(); }\n    Point scale(db r) { return unit() * r; }\n\n    Point rotCC() { return Point(-y, x); }\n    Point rotCL() { return Point(y, -x); }\n\n    Point rot(Point p, db angle)\n    {\n        Point v = *this - p;\n        db c = cos(angle), s = sin(angle);\n        return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);\n    }\n\n    db len() { return hypot(x, y); }\n    db len2() { return x * x + y * y; }\n\n    db rad(Point a, Point b)\n    {\n        Point ap = a - *this, bp = b - *this;\n        return abs(atan2(abs(ap ^ bp), ap * bp));\n    }\n\n    // Point P,A,B\n    // -2 -> B is at back of PA\n    // -1 -> PB is on the clock-wise side of PA\n    // 0 -> B is on PA\n    // 1 -> PB is on the counter clock-wise side of PA\n    // 2 -> B is at the front of PA\n    int relation(Point a, Point b)\n    {\n        Point p = *this;\n        if (sgn((a - p) ^ (b - p)) > 0)\n            return 1;\n        if (sgn((a - p) ^ (b - p)) < 0)\n            return -1;\n        if (sgn((a - p) * (b - p)) < 0)\n            return -2;\n        if (sgn((p - a) * (b - a)) < 0)\n            return 2;\n        return 0;\n    }\n\n    void read() { cin >> x >> y; }\n    void write(char trail = ' ') { cout << x << ' ' << y << trail; }\n    void Debug() { cerr << \"Point: (\" << x << \", \" << y << \")\\n\"; }\n};\n\ndb cross(Point a, Point b, Point c) { return (b - a) ^ (c - a); }\n\n// Line\nstruct Line\n{\n    Point s, e;\n\n    Line(){};\n\n    Line(Point _s, Point _e) : s(_s), e(_e) {}\n\n    Line(Point p, db angle)\n    {\n        s = p;\n        if (sgn(angle - PI / 2))\n            e = (s + Point(1, tan(angle)));\n        else\n            e = (s + Point(0, 1));\n    }\n\n    //ax+by+c=0\n    Line(db a, db b, db c)\n    {\n        if (sgn(a) == 0)\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -c / b);\n        }\n        else if (sgn(b) == 0)\n        {\n            s = Point(-c / a, 0);\n            e = Point(-c / a, 1);\n        }\n        else\n        {\n            s = Point(0, -c / b);\n            e = Point(1, -(c + a) / b);\n        }\n    }\n\n    db len() { return s.dis(e); }\n    db angle()\n    {\n        db ans = atan2(e.y - s.y, e.x - s.x);\n        if (sgn(ans) == -1)\n            ans += PI;\n        if (sgn(ans - PI) == 0)\n            ans -= PI;\n        return ans;\n    }\n\n    int relation(Point p) { return s.relation(e, p); }\n\n    bool parallel(Line l) { return sgn((e - s) ^ (l.e - l.s)) == 0; }\n\n    // 0 -> Not Intersect\n    // 1 -> Informal\n    // 2 -> Formal Intersection\n    int crossSS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        int d3 = sgn((l.e - l.s) ^ (s - l.s));\n        int d4 = sgn((l.e - l.s) ^ (e - l.s));\n        if ((d1 ^ d2) == -2 && (d3 ^ d4) == -2)\n            return 2;\n        return (d1 == 0 && sgn((l.s - s) * (l.s - e)) <= 0) ||\n               (d2 == 0 && sgn((l.e - s) * (l.e - e)) <= 0) ||\n               (d3 == 0 && sgn((s - l.s) * (s - l.e)) <= 0) ||\n               (d4 == 0 && sgn((e - l.s) * (e - l.e)) <= 0);\n    }\n\n    // 0 -> Not Intersect\n    // 1 -> Informal\n    // 2 -> Formal Intersection\n    int crossLS(Line l)\n    {\n        int d1 = sgn((e - s) ^ (l.s - s));\n        int d2 = sgn((e - s) ^ (l.e - s));\n        if ((d1 ^ d2) == -2)\n            return 2;\n        return (d1 == 0 || d2 == 0);\n    }\n\n    // 0 -> Parallel\n    // 1 -> Same\n    // 2 -> Intersect\n    int crossLL(Line l)\n    {\n        if (this->parallel(l))\n            return l.relation(s) == 3;\n        return 2;\n    }\n\n    Point intersec(Line l)\n    {\n        db a1 = (l.e - l.s) ^ (s - l.s);\n        db a2 = (l.e - l.s) ^ (e - l.s);\n        return Point((s.x * a2 - e.x * a1) / (a2 - a1), (s.y * a2 - e.y * a1) / (a2 - a1));\n    }\n\n    db disPL(Point p) { return abs((p - s) ^ (e - s)) / len(); }\n    db disPS(Point p)\n    {\n        if (sgn((p - s) * (e - s)) < 0 || sgn((p - e) * (s - e)) < 0)\n            return min(p.dis(s), p.dis(e));\n        return disPL(p);\n    }\n    db disSS(Line l) { return min(min(disPS(l.s), disPS(l.e)), min(l.disPS(s), l.disPS(e))); }\n\n    Point proj(Point p) { return s + ((e - s) * ((e - s) * (p - s))) / ((e - s).len2()); }\n    Point refl(Point p)\n    {\n        Point q = proj(p);\n        return Point(2 * q.x - p.x, 2 * q.y - p.y);\n    }\n\n    bool operator==(Line l) { return s == l.s && e == l.e; }\n\n    void adjust()\n    {\n        if (e < s)\n            swap(s, e);\n    }\n\n    void read()\n    {\n        s.read();\n        e.read();\n    }\n\n    void Debug() { cerr << \"Line: Start: (\" << s.x << \", \" << s.y << \") End: (\" << e.x << \", \" << e.y << \")\\n\"; }\n};\n\n// Circle\nstruct Circle\n{\n    Point p;\n    db r;\n\n    Circle(){};\n\n    Circle(Point _p, db _r) : p(_p), r(_r) {}\n\n    Circle(db x, db y, db _r) : p({x, y}), r(_r) {}\n\n    Circle(Point a, Point b, Point c, bool in = false)\n    {\n        if (!in)\n        {\n            Line u = Line((a + b) / 2, (a + b) / 2 + (b - a).rotCC());\n            Line v = Line((b + c) / 2, (b + c) / 2 + (c - b).rotCC());\n            p = u.intersec(v);\n            r = p.dis(a);\n        }\n        else\n        {\n            Line u, v;\n            db m = atan2(b.y - a.y, b.x - a.x), n = atan2(c.y - a.y, c.x - a.x);\n            u.s = a;\n            u.e = a + Point(cos((n + m) / 2), sin((n + m) / 2));\n            v.s = b;\n            m = atan2(a.y - b.y, a.x - b.x), n = atan2(c.y - b.y, c.x - b.x);\n            v.e = b + Point(cos((n + m) / 2), sin((n + m) / 2));\n            p = u.intersec(v);\n            r = Line(a, b).disPS(p);\n        }\n    }\n\n    bool operator==(const Circle &c) { return p == c.p && sgn(r - c.r) == 0; }\n\n    bool operator<(const Circle &c) { return (p < c.p) || (p == c.p && sgn(r - c.r) < 0); }\n\n    db area() { return PI * r * r; }\n\n    db cir() { return 2 * PI * r; }\n\n    Point on(db ang) { return Point(p.x + r * cos(ang), p.y + r * sin(ang)); }\n\n    // 0 -> Outside\n    // 1 -> On\n    // 2 -> Inside\n    int relationP(Point v)\n    {\n        db dis = v.dis(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // The number of intersections\n    int relationS(Line l)\n    {\n        db dis = l.disPS(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // The number of intersections\n    int relationL(Line l)\n    {\n        db dis = l.disPL(p);\n        if (sgn(dis - r) < 0)\n            return 2;\n        else if (sgn(dis - r) == 0)\n            return 1;\n        return 0;\n    }\n\n    // 1 -> Inside\n    // 2 -> Internally-tangent\n    // 3 -> Intersect\n    // 4 -> Externally-tangent\n    // 5 -> Disjoint\n    int relationC(Circle c)\n    {\n        db d = p.dis(c.p);\n        if (sgn(d - r - c.r) > 0)\n            return 5;\n        if (sgn(d - r - c.r) == 0)\n            return 4;\n        db l = abs(r - c.r);\n        if (sgn(d - r - c.r) < 0 && sgn(d - l) > 0)\n            return 3;\n        if (sgn(d - l) == 0)\n            return 2;\n        // TODO: Check if this one is necessary\n        // if (sgn(d - l) < 0)\n        return 1;\n    }\n\n    // The return value is the number of intersections\n    int crossC(Circle c, Point &p1, Point &p2)\n    {\n        int re = relationC(c);\n        if (re == 1 || re == 5)\n            return 0;\n        db d = p.dis(c.p), l = (d * d + r * r - c.r * c.r) / (2.0 * d), h = sqrt(r * r - l * l);\n        Point tmp = p + (c.p - p).scale(l);\n        p1 = tmp + (c.p - p).rotCC().scale(h);\n        p2 = tmp + (c.p - p).rotCL().scale(h);\n        if (re == 2 || re == 4)\n            return 1;\n        return 2;\n    }\n\n    // Same as above\n    int crossL(Line l, Point &p1, Point &p2)\n    {\n        if (!this->relationL(l))\n            return 0;\n        Point a = l.proj(p);\n        db d = l.disPL(p);\n        d = sqrt(r * r - d * d);\n        if (sgn(d) == 0)\n        {\n            p1 = a;\n            p2 = a;\n            return 1;\n        }\n        p1 = a + (l.e - l.s).scale(d);\n        p2 = a - (l.e - l.s).scale(d);\n        return 2;\n    }\n\n    int tangent(Point q, Point &u, Point &v)\n    {\n        int x = relationP(q);\n        if (x == 2)\n            return 0;\n        if (x == 1)\n        {\n            u = q + (q - p).rotCC();\n            v = u;\n            return 1;\n        }\n        db d = p.dis(q);\n        db l = r * r / d;\n        db h = sqrt(r * r - l * l);\n        u = p + ((q - p).scale(l) + (q - p).rotCC().scale(h));\n        v = p + ((q - p).scale(l) + (q - p).rotCL().scale(h));\n        return 2;\n    }\n\n    int tangent(Circle c, vector<Point> &u, vector<Point> &v)\n    {\n        if (sgn(r - c.r) < 0)\n            return c.tangent(*this, v, u);\n\n        int ret = relationC(c) - 1;\n        if (!ret || *this == c)\n            return 0;\n        u.clear();\n        v.clear();\n\n        db b = (c.p - p).alpha();\n\n        if (ret == 1 || ret == 3)\n        {\n            u.push_back(on(b));\n            v.push_back(on(b));\n        }\n\n        db ang = acos((r - c.r) / p.dis(c.p));\n\n        if (ret != 1)\n        {\n            u.push_back(on(b + ang));\n            u.push_back(on(b - ang));\n            v.push_back(c.on(b + ang));\n            v.push_back(c.on(b - ang));\n        }\n\n        if (ret == 4)\n        {\n            ang = acos((r + c.r) / p.dis(c.p));\n            u.push_back(on(b + ang));\n            u.push_back(on(b - ang));\n            v.push_back(c.on(PI + b + ang));\n            v.push_back(c.on(PI + b - ang));\n        }\n\n        return ret;\n    }\n\n    // The area of intersecting space\n    // With circle c\n    db area(Circle c)\n    {\n        int re = relationC(c);\n        if (re >= 4)\n            return 0;\n        if (re <= 2)\n            return min(area(), c.area());\n        db d = p.dis(c.p);\n        db hf = (r + c.r + d) / 2.0;\n        db ss = 2 * sqrt(hf * (hf - r) * (hf - c.r) * (hf - d));\n        db a1 = acos((r * r + d * d - c.r * c.r) / (2.0 * r * d));\n        a1 = a1 * r * r;\n        db a2 = acos((c.r * c.r + d * d - r * r) / (2.0 * c.r * d));\n        a2 = a2 * c.r * c.r;\n        return a1 + a2 - ss;\n    }\n\n    // The area of intersecting space\n    // With triangle PAB\n    db area(Point a, Point b)\n    {\n        if (sgn((p - a) ^ (p - b)) == 0)\n            return 0.0;\n        Point q[5];\n        int len = 0;\n        q[len++] = a;\n        Line l(a, b);\n        Point p1, p2;\n        if (crossL(l, q[1], q[2]) == 2)\n        {\n            if (sgn((a - q[1]) * (b - q[1])) < 0)\n                q[len++] = q[1];\n            if (sgn((a - q[2]) * (b - q[2])) < 0)\n                q[len++] = q[2];\n        }\n        q[len++] = b;\n        if (len == 4 && sgn((q[0] - q[1]) * (q[2] - q[1])) > 0)\n            swap(q[1], q[2]);\n        db res = 0;\n        for (int i = 0; i < len - 1; i++)\n        {\n            if (relationP(q[i]) == 0 || relationP(q[i + 1]) == 0)\n            {\n                db arg = p.rad(q[i], q[i + 1]);\n                res += r * r * arg / 2.0;\n            }\n            else\n                res += abs((q[i] - p) ^ (q[i + 1] - p)) / 2.0;\n        }\n        return res;\n    }\n\n    // Two circle whose center are a and b respectivelly\n    static int GetCircle(Point a, Point b, db r, Circle &c1, Circle &c2)\n    {\n        Circle x(a, r), y(b, r);\n        int t = x.crossC(y, c1.p, c2.p);\n        if (!t)\n            return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n\n    // The circle which tangent is l and point p on it\n    static int GetCircle(Line l, Point p, db r, Circle &c1, Circle &c2)\n    {\n        db dis = l.disPL(p);\n        if (sgn(dis - r * 2) > 0)\n            return 0;\n        if (sgn(dis) == 0)\n        {\n            c1.p = p + ((l.e - l.s).rotCC().scale(r));\n            c2.p = p + ((l.e - l.s).rotCL().scale(r));\n            c1.r = c2.r = r;\n            return 2;\n        }\n        Line u1 = Line((l.s + (l.e - l.s).rotCC().scale(r)), (l.e + (l.e - l.s).rotCC().scale(r)));\n        Line u2 = Line((l.s + (l.e - l.s).rotCL().scale(r)), (l.e + (l.e - l.s).rotCL().scale(r)));\n        Circle cc(p, r);\n        Point p1, p2;\n        if (!cc.crossL(u1, p1, p2))\n            cc.crossL(u2, p1, p2);\n        c1 = Circle(p1, r);\n        if (p1 == p2)\n        {\n            c2 = c1;\n            return 1;\n        }\n        c2 = Circle(p2, r);\n        return 2;\n    }\n\n    // u and v are the common tangent of the four circles\n    static int GetCircle(Line u, Line v, db r, Circle &c1, Circle &c2, Circle &c3, Circle &c4)\n    {\n        if (u.parallel(v))\n            return 0;\n        Line u1 = Line(u.s + (u.e - u.s).rotCC().scale(r), u.e + (u.e - u.s).rotCC().scale(r));\n        Line u2 = Line(u.s + (u.e - u.s).rotCL().scale(r), u.e + (u.e - u.s).rotCL().scale(r));\n        Line v1 = Line(v.s + (v.e - v.s).rotCC().scale(r), v.e + (v.e - v.s).rotCC().scale(r));\n        Line v2 = Line(v.s + (v.e - v.s).rotCL().scale(r), v.e + (v.e - v.s).rotCL().scale(r));\n        c1.r = c2.r = c3.r = c4.r = r;\n        c1.p = u1.intersec(v1);\n        c2.p = u1.intersec(v2);\n        c3.p = u2.intersec(v1);\n        c4.p = u2.intersec(v2);\n        return 4;\n    }\n\n    // Tangent with circle cx and cy\n    static int GetCircle(Circle cx, Circle cy, db r, Circle &c1, Circle &c2)\n    {\n        Circle x(cx.p, r + cx.r), y(cy.p, r + cy.r);\n        int t = x.crossC(y, c1.p, c2.p);\n        if (!t)\n            return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n\n    void read()\n    {\n        p.read();\n        cin >> r;\n    }\n\n    void Debug() { cerr << \"Circle: Center: (\" << p.x << \", \" << p.y << \") Radius: \" << r << '\\n'; }\n};\n\n// Polygon\nstruct Polygon\n{\n    // Functor for sorting by polar angle\n    struct cmp\n    {\n        Point p;\n        cmp(const Point &b) { p = b; }\n        bool operator()(const Point &a, const Point &b)\n        {\n            Point x = a, y = b;\n            int d = sgn((x - p) ^ (y - p));\n            if (!d)\n                return sgn(x.dis(p) - y.dis(p)) > 0;\n            return d > 0;\n        }\n    };\n\n    vector<Point> ps;\n    vector<Line> ls;\n\n    Polygon() {}\n\n    void add(Point p) { ps.push_back(p); }\n\n    int size() { return static_cast<int>(ps.size()); }\n\n    void getLines()\n    {\n        int s = size();\n        for (int i = 0; i < s; i++)\n            ls.push_back(Line(ps[i], ps[(i + 1) % s]));\n    }\n\n    void norm()\n    {\n        Point p = ps[0];\n        for (int i = 1; i < size(); i++)\n        {\n            if (p < ps[i])\n                continue;\n            p = ps[i];\n        }\n        sort(ps.begin(), ps.end(), cmp(p));\n    }\n\n    void getConvexJarvis(Polygon &conv)\n    {\n        sort(ps.begin(), ps.end());\n        conv.ps.resize(2 * size());\n\n        int n = size();\n        for (int i = 0; i < min(2, n); i++)\n            conv.ps[i] = ps[i];\n        if (conv.size() == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.resize(1);\n\n        if (n <= 2)\n            return;\n\n        int top = 1;\n\n        for (int i = 2; i < n; i++)\n        {\n            while (top && sgn((conv.ps[top] - ps[i]) ^ (conv.ps[top - 1] - ps[i])) <= 0)\n                top--;\n            conv.ps[++top] = ps[i];\n        }\n\n        int t = top;\n        conv.ps[++top] = ps[n - 2];\n\n        for (int i = n - 3; i >= 0; i--)\n        {\n            while (top != t && sgn((conv.ps[top] - ps[i]) ^ (conv.ps[top - 1] - ps[i])) <= 0)\n                top--;\n            conv.ps[++top] = ps[i];\n        }\n\n        while (conv.size() > top)\n            conv.ps.pop_back();\n\n        if (top == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.pop_back();\n\n        conv.norm(); // Counter Clock-wise\n    }\n\n    void getConvexWithPointOnLine(Polygon &conv)\n    {\n        int m, n = size();\n        if (n < 3)\n        {\n            for (auto i : ps)\n                conv.add(i);\n            return;\n        }\n\n        vector<Point> &g = conv.ps;\n\n        sort(ps.begin(), ps.end());\n        for (int i = 0; i < n; i++)\n        {\n            while ((m = g.size()) >= 2 && g[m - 2].relation(g[m - 1], ps[i]) <= 0)\n                g.pop_back();\n            g.push_back(ps[i]);\n        }\n\n        int t = g.size();\n\n        for (int i = n - 2; i >= 0; i--)\n        {\n            while ((m = g.size()) > t && g[m - 2].relation(g[m - 1], ps[i]) <= 0)\n                g.pop_back();\n            g.push_back(ps[i]);\n        }\n\n        g.pop_back();\n    }\n\n    // Cannot get the point on the edge\n    void getConvexGraham(Polygon &conv)\n    {\n        norm();\n        int top = 0, n = size();\n        if (n == 1)\n        {\n            conv.add(ps[0]);\n            return;\n        }\n\n        if (n == 2)\n        {\n            conv.add(ps[0]);\n            conv.add(ps[1]);\n            if (conv.ps[0] == conv.ps[1])\n                conv.ps.pop_back();\n            return;\n        }\n\n        conv.ps.resize(size());\n        conv.ps[0] = ps[0];\n        conv.ps[1] = ps[1];\n        top = 2;\n        for (int i = 2; i < n; i++)\n        {\n            while (top > 1 && sgn((conv.ps[top - 1] - conv.ps[top - 2]) ^ (ps[i] - conv.ps[top - 2])) <= 0)\n                top--;\n            conv.ps[top++] = ps[i];\n        }\n\n        while (conv.size() > top)\n            conv.ps.pop_back();\n\n        if (top == 2 && (conv.ps[0] == conv.ps[1]))\n            conv.ps.pop_back();\n    }\n\n    bool isConvex()\n    {\n        bitset<3> s;\n        int n = size();\n        for (int i = 0; i < n; i++)\n        {\n            int j = (i + 1) % n;\n            int k = (j + 1) % n;\n            s.set(sgn((ps[j] - ps[i]) ^ (ps[k] - ps[i])) + 1);\n            if (s[0] && s[2])\n                return false;\n        }\n        return true;\n    }\n\n    db diameter()\n    {\n        int q = 1, n = size();\n        db ans = 0;\n        ps.push_back(ps[0]);\n        for (int i = 0; i < n; i++)\n        {\n            while (sgn(cross(ps[i + 1], ps[q + 1], ps[i]) - cross(ps[i + 1], ps[q], ps[i])) > 0)\n                q = (q + 1) % n;\n            ans = Max(ans, Max(ps[i].dis(ps[q]), ps[i + 1].dis(ps[q + 1])));\n        }\n        ps.pop_back();\n        return ans;\n    }\n\n    // 3 -> On Corner\n    // 2 -> On Edge\n    // 1 -> Inside\n    // 0 -> Outside\n    int relationP(Point q)\n    {\n        int n = size();\n        for (int i = 0; i < n; i++)\n            if (ps[i] == q)\n                return 3;\n        getLines();\n        for (int i = 0; i < n; i++)\n            if (!ls[i].relation(q))\n                return 2;\n        int cnt = 0;\n        for (int i = 0; i < n; i++)\n        {\n            int j = (i + 1) % n;\n            int k = sgn((q - ps[j]) ^ (ps[i] - ps[j]));\n            int u = sgn(ps[i].y - q.y);\n            int v = sgn(ps[j].y - q.y);\n            if (k > 0 && u < 0 && v >= 0)\n                cnt++;\n            if (k < 0 && v < 0 && u >= 0)\n                cnt--;\n        }\n        return cnt != 0;\n    }\n\n    void convexCut(Line l, Polygon &po)\n    {\n        for (int i = 0; i < size(); i++)\n        {\n            int d1 = sgn((l.e - l.s) ^ (ps[i] - l.s));\n            int d2 = sgn((l.e - l.s) ^ (ps[(i + 1) % size()] - l.s));\n            if (d1 >= 0)\n                po.add(ps[i]);\n            if (d1 * d2 < 0)\n                po.add(l.intersec(Line(ps[i], ps[(i + 1) % size()])));\n        }\n    }\n\n    db cir()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += ps[i].dis(ps[(i + 1) % n]);\n        return sum;\n    }\n\n    db area()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += (ps[i] ^ ps[(i + 1) % n]);\n        return abs(sum) / 2;\n    }\n\n    // 0 -> Clock-wise\n    // 1 -> Counter Clock-wise\n    bool dir()\n    {\n        int n = size();\n        db sum = 0;\n        for (int i = 0; i < n; i++)\n            sum += (ps[i] ^ ps[(i + 1) % n]);\n        return sgn(sum) > 0;\n    }\n\n    Point baryCenter()\n    {\n        Point ret;\n        db area = 0;\n        for (int i = 1; i < size() - 1; i++)\n        {\n            db tmp = (ps[i] - ps[0]) ^ (ps[i + 1] - ps[0]);\n            if (sgn(tmp) == 0)\n                continue;\n            area += tmp;\n            ret.x += (ps[0].x + ps[i].x + ps[i + 1].x) / 3 * tmp;\n            ret.y += (ps[0].y + ps[i].y + ps[i + 1].y) / 3 * tmp;\n        }\n        if (sgn(area))\n            ret = ret / area;\n        return ret;\n    }\n\n    db area(Circle c)\n    {\n        double ans = 0;\n        for (int i = 0; i < size(); i++)\n        {\n            int j = (i + 1) % size();\n            if (sgn((ps[j] - c.p) ^ (ps[i] - c.p)) >= 0)\n                ans += c.area(ps[i], ps[j]);\n            else\n                ans -= c.area(ps[i], ps[j]);\n        }\n        return abs(ans);\n    }\n\n    // 2 -> The circle is entirely in the polygon\n    // 1 -> The circle in in the circle and intersected with the boundary\n    // 0 -> Otherwise\n    int relationC(Circle c)\n    {\n        getLines();\n        int x = 2;\n        if (relationP(c.p) != 1)\n            return 0;\n        for (int i = 0; i < size(); i++)\n        {\n            if (c.relationS(ls[i]) == 2)\n                return 0;\n            if (c.relationS(ls[i]) == 1)\n                x = 1;\n        }\n        return x;\n    }\n\n    void read(int s)\n    {\n        for (int i = 0; i < s; i++)\n        {\n            Point p;\n            p.read();\n            ps.push_back(p);\n        }\n    }\n\n    void Debug()\n    {\n        cerr << \"Polygon:\\nPoints:\\n\";\n        for (auto i : ps)\n            i.Debug();\n        cerr << \"Lines:\\n\";\n        for (auto i : ls)\n            i.Debug();\n    }\n};\n\n// Pre-Build Function\ninline void build()\n{\n}\n\n// Actual Solver\ninline void solve()\n{\n    cout << fixed << setprecision(10);\n    int n;\n    cin >> n;\n    Polygon g, conv;\n    g.read(n);\n    g.getConvexGraham(conv);\n    assert(conv.isConvex());\n    cout << conv.diameter() << '\\n';\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n#ifdef LOCAL\n    clock_t _begin = clock();\n#endif\n\n    build();\n    solve();\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << (double)(clock() - _begin) * 1000 / CLOCKS_PER_SEC << \"ms.\" << endl;\n#endif\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\nbool comp(const P& p,const P& q)\n{\n\tif(real(p)!=real(q))return real(p)<real(q);\n\treturn imag(p)<imag(q);\n}\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tR res=0.0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\n\t/*\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    rep(k,2*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}*/\n\tint i=0,j=0;\n\tfor(int k=0;k<n;k++)\n\t{\n\t\tif(!comp(pol[i],pol[k]))i=k;\n\t\tif(comp(pol[j],pol[k]))j=k;\n\t}\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si)\n\t{\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(det(O,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j])<0)i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n//-------------------------------------------------------------------------------------\n/*線分にたいして点(px,py)が垂線をおろすことができればtrue*/\n\nbool perpendicular_to_the_line_segment_from_the_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(!is_not_parallel)return false;\n    if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n        //cout<<\"a \";\n        return true;\n    }else{//(v_x,v_y)は線分の外にある\n        return false;\n    }\n    \n    \n}\n\n\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*凸包の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][0]<ch[k][0]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res = 0;\n    while(1){\n        if(i==sj||j==si)break;\n\n        res = distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n        if(perpendicular_to_the_line_segment_from_the_point(ch[sj][0], ch[sj][1], ch[si][0], ch[si][1], ch[(si+1)%n][0], ch[(si+1)%n][1])){\n            si=(si+1)%n;\n        }else{\n            sj=(sj+1)%n;\n        }\n    }\n    \n    return res;\n}\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        /*\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n         */\n        \n        double max_l = diameter_of_the_polygon(n, p_xy);\n        \n        \n\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)\n#define RFOR(i,n,m) for(int i=(int)(n); i>=(int)(m); i--)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\n//-------------------------------------------------\n//--Geometry Template (Plane)\n//-------------------------------------------------\n\nusing lf = double;\nconst lf EPS = 1e-9;\nconst lf PI = acos(-1);\n\n#define sgn(x) (((x)<-EPS)?-1:((x)>EPS)?1:0)\n#define EQ(x,y) (sgn((y)-(x))==0)\n\nstruct V {\n    lf x,y;\n    V(){}\n    V(lf x, lf y):x(x),y(y){}\n    V(const V &v):x(v.x),y(v.y){}\n    V& operator+=(const V &v){x+=v.x; y+=v.y; return *this;}\n    V& operator-=(const V &v){x-=v.x; y-=v.y; return *this;}\n    V& operator*=(lf k){x*=k; y*=k; return *this;}\n    V& operator/=(lf k){x/=k; y/=k; return *this;}\n    V operator+(const V &v){return V(*this)+=v;}\n    V operator-(const V &v){return V(*this)-=v;}\n    V operator*(lf k){return V(*this)*=k;}\n    V operator/(lf k){return V(*this)/=k;}\n    V operator-(){return V(-x,-y);}\n    lf sq(){return x*x+y*y;}\n    lf norm(){return sqrt(sq());}\n    V unit(){return V(*this)/=norm();}\n    lf arg(){return atan2(y,x);}\n    V rot(lf c, lf s){return V(x*c-y*s,x*s+y*c);}\n    V rot(lf a){return rot(sin(a),cos(a));}\n    V rot90(){return V(-y,x);}\n    bool operator<(const V &v){\n        if (sgn(x-v.x)) return sgn(x-v.x)<0;\n        return sgn(y-v.y)<0;\n    }\n    friend ostream& operator<<(ostream &os, const V &v){return os<<'('<<v.x<<\", \"<<v.y<<')';}\n};\n\nlf dot(const V &a, const V &b){return a.x*b.x+a.y*b.y;}\nlf det(const V &a, const V &b){return a.x*b.y-a.y*b.x;}\n\nint ccw(V a, V b, V c){\n    b-=a; c-=a;\n    if (sgn(det(b,c))>0) return 1;\n    else if(sgn(det(b,c))<0) return -1;\n    else if(sgn(dot(b,c))<0) return 2;\n    else if(sgn(b.norm()-c.norm())<0) return -2;\n    return 0;\n}\n\nstruct Line {\n    V p,q;\n    Line(){}\n    Line(const V &p, const V &q):p(p),q(q){}\n    Line(const Line &l):Line(l.p,l.q){}\n    V unit(){return (q-p).unit();}\n    lf arg(){return (q-p).arg();}\n    Line rot(lf c, lf s){return Line(p.rot(c,s),q.rot(c,s));}\n    Line rot(lf a){return Line(p.rot(a),q.rot(a));}\n    Line rot90(){return Line(p.rot90(),q.rot90());}\n};\n\nstruct Segment : Line {\n    Segment(){}\n    Segment(const V &p, const V &q):Line(p,q){}\n    Segment(const Segment &s):Line(s){}\n    lf sq(){return (Line::q-Line::p).sq();}\n    lf norm(){return (Line::q-Line::p).norm();}\n};\n\n// functions about lines\nbool parallel(const V &a, const V &b){return EQ(det(a,b),0.0);}\nbool parallel(Line &a, Line &b){return EQ(det(a.q-a.p,b.q-b.p),0.0);}\nbool orthogonal(const V &a, const V &b){return EQ(dot(a,b),0.0);}\nbool orthogonal(Line &a, Line &b){return EQ(dot(a.q-a.p,b.q-b.p),0.0);}\n\nbool samel(Line &a, Line &b){return parallel(a,b)&&EQ(det(a.q-a.p,b.p-a.p),0.0);}\nbool insec(Line &a, Line &b){return !parallel(a,b);}\nbool insec(Segment &a, Segment &b){\n    int c1 = ccw(a.p,a.q,b.p)*ccw(a.p,a.q,b.q);\n    int c2 = ccw(b.p,b.q,a.p)*ccw(b.p,b.q,a.q);\n    return (c1<=0 && c2<=0);\n}\nbool insec(Line &a, Segment &b){return ccw(a.p,a.q,b.p)*ccw(a.p,a.q,b.q)<=0;}\n\n// use only if lines have intersection\nV cpoint(Line &a, Line &b){\n    V r(a.q-a.p);\n    r *= det(b.p-a.p,b.q-b.p)/det(a.q-a.p,b.q-b.p);\n    return a.p+r;\n}\n\nlf distance(V &a, V &b){return (b-a).norm();}\nlf distance(Line &l, V &v){return abs(det((l.q-l.p).unit(),v-l.p));}\nlf distance(Line &a, Line &b){return (parallel(a,b))?distance(a,b.p):0.0;}\nlf distance(Segment &s, V &v){\n    if (sgn(dot(s.q-s.p,v-s.p))<0) return distance(s.p,v);\n    else if(sgn(dot(s.p-s.q,v-s.q))<0) return distance(s.q,v);\n    return distance((Line&)s,v);\n}\nlf distance(Segment &a, Segment &b){\n    if (insec(a,b)) return 0.0;\n    lf A=min(distance(a,b.p),distance(a,b.q));\n    lf B=min(distance(b,a.p),distance(b,a.q));\n    return min(A,B);\n}\nlf distance(Line &a, Segment &b){\n    if (insec(a,b)) return 0.0;\n    return min(distance(a,b.p),distance(a,b.q));\n}\n\nV subdiv(V &a, V &b, lf m, lf n){return (a*n+b*m)/(m+n);}\nV outside(V &a, V &b, lf m, lf n){return (-a*n+b*m)/(m-n);}\nV ppfoot(Line &l, V &v){\n    V u = (l.q-l.p).unit();\n    return l.p+u*dot(u,v-l.p);\n}\nV reflect(Line &l, V &v){\n    V f = ppfoot(l,v);\n    return f+(f-v);\n}\n\nLine vbsector(V &a, V &b){\n    V m = (a+b)/2;\n    return Line(m, m+(b-a).rot90());\n}\nLine absector(V &c, V &a, V &b){\n    lf m=(a-c).norm(), n=(b-c).norm();\n    return Line(c,subdiv(a,b,m,n));\n}\nLine perpend(V &c, V &a, V &b){return Line(c,c+(b-a).rot90());}\n\n//-------------------------------------------------\n//--Polygon (depends on Geometry Template)\n//-------------------------------------------------\n\n//anti-clockwise\nstruct Polygon {\n    vector<V> ps; int n;\n    Polygon():n(0){}\n    Polygon(int n):n(n),ps(n){}\n    void push(const V &v){ps.push_back(v), n++;}\n    void pop(){ps.pop_back(), n--;}\n    V& operator[](int k){return ps[k%n];}\n};\n\nlf area(Polygon &p){\n    lf ret=0.0;\n    for(int i=0; i<p.n; i++)\n        ret+=det(p[i],p[i+1])/2;\n    return ret;\n}\n\nV gravity(Polygon &p){\n    V ret(0,0); lf wsum=0.0;\n    for(int i=0; i<p.n; i++){\n        lf w = det(p[i],p[i+1]);\n        ret+=(p[i]+p[i+1])/3*w;\n        wsum+=w;\n    }\n    return ret/wsum;\n}\n\nbool convex(Polygon &p){\n    for(int i=0; i<p.n; i++)\n        if (sgn(det(p[i]-p[i+1],p[i+1]-p[i+2]))<0) return false;\n    return true;\n}\n\nPolygon convex_full(vector<V> &ps){\n    Polygon ret;\n    sort(ps.begin(), ps.end());\n    for(int i=0; i<ps.size(); i++){\n        while(ret.n>1 && sgn(det(ret[ret.n-1]-ret[ret.n-2],ps[i]-ret[ret.n-1]))<=0) ret.pop();\n        ret.push(ps[i]);\n    }\n    for(int i=ps.size()-2, t=ret.n; i>=0; i--){\n        while(ret.n>t && sgn(det(ret[ret.n-1]-ret[ret.n-2],ps[i]-ret[ret.n-1]))<=0) ret.pop();\n        ret.push(ps[i]);\n    }\n    ret.pop();\n    return ret;\n}\n\nlf diameter(Polygon &p){\n    if (p.n==2) return distance(p[0],p[1]);\n    lf ret=0;\n    int s=0,t=0;\n    for(int i=0; i<p.n; i++)\n        if (p[t]<p[i]) t = i;\n    int ed=t;\n    while(s!=ed || t!=p.n){\n        chmax(ret, distance(p[s],p[t]));\n        (sgn(det(p[s+1]-p[s], p[t]-p[t+1]))>0)? s++ : t++;\n    }\n    return ret;\n}\n\nPolygon convex_cut(Polygon &p, Line &l){\n    Polygon ret;\n    for(int i=0; i<p.n; i++){\n        if (ccw(l.p,l.q,p[i])!=-1) ret.push(p[i]);\n        if (ccw(l.p,l.q,p[i])*ccw(l.p,l.q,p[i+1])==-1){\n            Segment s(p[i+1],p[i]);\n            ret.push(cpoint(l,s));\n        }\n    }\n    return ret;\n}\n\n// OUT=0, ON=1, IN=2\nint contain(Polygon &p, const V &v){\n    int ret=0;\n    for(int i=0; i<p.n; i++){\n        V a=p[i]-v, b=p[i+1]-v;\n        if (a.y>b.y) swap(a,b);\n        if (sgn(a.y)<0 && sgn(b.y)>=0 && sgn(det(a,b))<0) ret=2-ret;\n        if (EQ(det(a,b),0.0) && sgn(dot(a,b))<=0) return 1;\n    }\n    return ret;\n}\n\n//-------------------------------------------------\n//--Circle (depends on Geometry Template)\n//-------------------------------------------------\n\nstruct Circle {\n    V p; lf r;\n    Circle(){}\n    Circle(const V &v, lf r):p(v),r(r){}\n    Circle(const Circle &c):p(c.p),r(c.r){}\n    lf area(){return r*r*PI;}\n    lf area(lf t){return r*r*t/2;}\n};\n\n// functons about circles\nbool contain(Circle &c, V &v){return sgn(distance(v,c.p)-c.r)<=0;}\nbool contain(Circle &c, Segment &s){\n    return sgn(max(distance(s.p,c.p),distance(s.q,c.p))-c.r)<=0;\n}\nbool insec(Circle &c, Line &l){return sgn(distance(l,c.p)-c.r)<=0;}\nbool insec(Circle &c, Segment &s){\n    return sgn(distance(s,c.p)-c.r)<=0 && sgn(max(distance(s.p,c.p),distance(s.q,c.p))-c.r)>=0;\n}\n\nvector<V> cpoint(Circle &a, Circle &b){\n    vector<V> ret;\n    V ab(b.p-a.p);\n    lf d = ab.norm(), dd = ab.sq();\n    lf c = (a.r*a.r+dd-b.r*b.r)/(2.0*a.r*d);\n    if (sgn(abs(c)-1.0)>0) return ret;\n    if (EQ(abs(c),1.0)){\n        c = (c>0)?1:-1;\n        ret.push_back(a.p+ab.unit().rot(c,0)*a.r);\n    }else{\n        lf s = sqrt(1.0-c*c);\n        ret.push_back(a.p+ab.unit().rot(c,s)*a.r);\n        ret.push_back(a.p+ab.unit().rot(c,-s)*a.r);\n    }\n    return ret;\n}\n\nvector<V> cpoint(Circle &c, Line &l){\n    vector<V> ret;\n    lf d = distance(l,c.p);\n    if (sgn(d-c.r)>0) return ret;\n    V h = ppfoot(l,c.p);\n    if (EQ(d,c.r)){\n        ret.push_back(h);\n    }else{\n        V r = (l.q-l.p).unit()*sqrt(c.r*c.r-d*d);\n        ret.push_back(h+r);\n        ret.push_back(h-r);\n    }\n    return ret;\n}\n\nvector<V> tangent(Circle &c, const V &v){\n    lf rr=(c.p-v).sq()-c.r*c.r;\n    if (sgn(rr)<0) return vector<V>();\n    Circle c2(v,sqrt(rr));\n    return cpoint(c,c2);\n}\n\nvector<V> tangent(Circle &a, Circle &b){\n    vector<V> ret, t;\n    ret = tangent(a, subdiv(a.p,b.p,a.r,b.r));\n    if (!EQ(a.r,b.r)){\n        t = tangent(a, outside(a.p,b.p,a.r,b.r));\n    }else{\n        V r = (b.p-a.p).unit().rot90()*a.r;\n        t.push_back(a.p+r);\n        t.push_back(a.p-r);\n    }\n    for(auto p:t) ret.push_back(p);\n    return ret;\n}\n\nvector<Line> tangent_line(Circle &c, const V &v){\n    vector<Line> ret;\n    auto t = tangent(c,v);\n    for(auto p:t) ret.push_back(Line(v,p));\n    return ret;\n}\n\nvector<Line> tangent_line(Circle &a, Circle &b){\n    vector<Line> ret,t;\n    ret = tangent_line(a, subdiv(a.p,b.p,a.r,b.r));\n    if (!EQ(a.r,b.r)){\n        t = tangent_line(a, outside(a.p,b.p,a.r,b.r));\n    }else{\n        V r = (b.p-a.p).unit().rot90()*a.r;\n        t.push_back(Line(a.p+r, b.p+r));\n        t.push_back(Line(a.p-r, b.p-r));\n    }\n    for(auto l:t) ret.push_back(l);\n    return ret;\n}\n\nlf carea(Circle &a, Circle &b){\n    lf d = distance(a.p,b.p);\n    if (sgn(d+a.r-b.r)<=0) return a.area();\n    if (sgn(d+b.r-a.r)<=0) return b.area();\n    auto cps = cpoint(a,b);\n    if (cps.size()<2) return 0.0;\n    lf t1 = acos(dot((cps[1]-a.p).unit(),(cps[0]-a.p).unit()));\n    if (sgn(det(cps[1]-a.p,cps[0]-a.p))<0) t1=2*PI-t1;\n    lf t2 = acos(dot((cps[0]-b.p).unit(),(cps[1]-b.p).unit()));\n    if (sgn(det(cps[0]-b.p,cps[1]-b.p))<0) t2=2*PI-t2;\n    return a.area(t1)+b.area(t2)-d*(cps[1]-cps[0]).norm()/2;\n}\n\n//-------------------------------------------------\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout<<setp(12);\n    int n; cin>>n;\n    vector<V> ps(n);\n    rep(i,n){\n        lf x,y; cin>>x>>y;\n        ps[i]=V(x,y);\n    }\n    Polygon poly = convex_full(ps);\n    cout<<diameter(poly)<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include <bits/stdc++.h>\nusing namespace std;\n//types\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//input\nbool SR(int &_x){return scanf(\"%d\",&_x)==1;}bool SR(ll &_x){return scanf(\"%lld\",&_x)==1;}\nbool SR(double &_x){return scanf(\"%lf\",&_x)==1;}bool SR(char *_s){return scanf(\"%s\",_s)==1;}\nbool RI(){return true;}\ntemplate<typename I,typename... T>bool RI(I &_x,T&... _tail){return SR(_x) && RI(_tail...);}\n//output\nvoid SP(const int _x){printf(\"%d\",_x);}void SP(const ll _x){printf(\"%lld\",_x);}\nvoid SP(const double _x){printf(\"%.16lf\",_x);}void SP(const char *s){printf(\"%s\",s);}\nvoid PL(){puts(\"\");}\ntemplate<typename I,typename... T>void PL(const I _x,const T... _tail)\n{SP(_x);if(sizeof...(_tail)) putchar(' ');PL(_tail...);}\n//macro\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=int(b);i++)\n#define PER1(i,a,b) for(int i=(a);i>=int(b);i--)\n#define pb push_back\n#define mkp make_pair\n#define F first\n#define S second\n//debug\n#ifdef darry140\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const pair<A,B> &_p){return _s<<\"(\"<<_p.F<<\",\"<<_p.S<<\")\";}\ntemplate<typename It>\nostream& _OUTC(ostream &_s,It _b,It _e)//container\n{\n    _s<<\"{\";\n    for(auto _it=_b;_it!=_e;_it++) _s<<(_it==_b?\"\":\" \")<<*_it;\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename A,typename B>\nostream& operator <<(ostream&_s, const map<A,B> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const set<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename T>\nostream& operator <<(ostream&_s, const vector<T> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename I>\nvoid _DOING(const char *_s,I&& _x){cerr<<_s<<\"=\"<<_x<<endl;}//without ','\ntemplate<typename I,typename... T>\nvoid _DOING(const char *_s,I&& _x,T&&... _tail)//with ','\n{\n    int _c=0;\n    static const char _bra[]=\"({[\";\n    static const char _ket[]=\")}]\";\n    while(*_s!=',' || _c!=0)//eg. mkp(a,b)\n    {\n        if(strchr(_bra,*_s)) _c++;\n        if(strchr(_ket,*_s)) _c--;\n        cerr<<*_s++;\n    }\n    cerr<<\"=\"<<_x<<\", \";\n    _DOING(_s+1,_tail...);\n}\n#define debug(...) do{\\\n    fprintf(stderr,\"%s:%d - \",__PRETTY_FUNCTION__,__LINE__);\\\n    _DOING(#__VA_ARGS__,__VA_ARGS__);\\\n}while(0)\n#else\n#define debug(...)\n#endif\n//}}}\ntypedef long double ld;\nstruct Point\n{\n    ld x,y;\n    Point():x(0),y(0){}\n    Point(ld _x,ld _y):x(_x),y(_y){}\n    Point operator +(const Point &p) const\n    {return Point(x+p.x,y+p.y);}\n    Point operator -(const Point &p) const\n    {return Point(x-p.x,y-p.y);}\n    ld operator *(const Point &p) const\n    {return x*p.x+y*p.y;}\n    ld operator %(const Point &p) const\n    {return x*p.y-y*p.x;}   \n    bool operator <(const Point &p) const\n    {return tie(y,x) < tie(p.y,p.x);}\n    bool operator ==(const Point &p) const\n    {return tie(y,x) == tie(p.y,p.x);}\n    Point operator /(const ld &l) const\n    {return Point(x/l,y/l);}\n    Point operator *(const ld &l) const\n    {return Point(x*l,y*l);}\n    ld len2() const{return x*x+y*y;}\n    ld dis2(const Point &a)const{return (*this-a).len2();}\n};\nostream& operator <<(ostream&_s, const Point &_c){return _s<<\"(\"<<_c.x<<\",\"<<_c.y<<\")\";}\nint main()\n{\n    int n;\n    while(RI(n) && n)\n    {\n        vector<Point> v(n);\n        REP(i,n)\n        {\n            double x,y;RI(x,y);\n            v[i]=Point(x,y);\n        }\n\n        const int a=max_element(ALL(v))-v.begin(),b=min_element(ALL(v))-v.begin();\n\n        ld ans=0;\n        int p=a,q=b;\n        while(1)\n        {\n            ans=max(ans,v[p].dis2(v[q]));\n            int pp=(p+1)%n,qq=(q+1)%n;\n            if((v[pp]-v[p])%(v[qq]-v[q])<0) p=pp;\n            else q=qq;\n            if(p==b && q==a) break;\n        }\n        PL((double)sqrt(ans));\n        //REP(i,n) PL(far[i]+1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n//-------------------------------------------------------------------------------------\n/*線分にたいして点(px,py)が垂線をおろすことができればtrue*/\n\nbool perpendicular_to_the_line_segment_from_the_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(!is_not_parallel)return false;\n    if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n        //cout<<\"a \";\n        return true;\n    }else{//(v_x,v_y)は線分の外にある\n        return false;\n    }\n    \n    \n}\n\n\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*凸包の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][0]<ch[k][0]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res = 0;\n    while(1){\n        if(i==sj||j==si)break;\n\n        res = max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n        if(perpendicular_to_the_line_segment_from_the_point(ch[sj][0], ch[sj][1], ch[si][0], ch[si][1], ch[(si+1)%n][0], ch[(si+1)%n][1])){\n            si=(si+1)%n;\n        }else{\n            sj=(sj+1)%n;\n        }\n    }\n    \n    return res;\n}\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        two_dimensional_qsort(p_xy, 0, n-1, 1);\n        /*\n        for(int i=0; i<n; i++){\n            cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n        }\n        */\n        /*\n        int q;\n        double ans[100000][2]={0};\n        convex_hull(n, p_xy, &q, ans);\n         */\n        \n        double max_l = diameter_of_the_polygon(n, p_xy);\n        \n        \n\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MON 1000000007\n#define INF (1<<29)\n#define EPS (1e-13)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\n\nclass Vec{\npublic:\n  double x, y;\n  Vec(double x = 0, double y = 0):x(x),y(y){}\n\n  Vec &read(){\n    cin >> x >> y;\n    return *this;\n  }\n\n  void print(){\n    printf(\"%.10lf %.10lf\\n\", x, y);\n  }\n\n  bool operator<(const Vec &other){\n    if(x < other.x)return true;\n    if(x == other.x && y < other.y)return true;\n    return false;\n  }\n  \n  Vec operator+(const Vec &other)\n  {\n    Vec result = *this;\n    result.x += other.x;\n    result.y += other.y;\n    return result;\n  }\n\n  Vec operator-(const Vec &other)\n  {\n    Vec result = *this;\n    result.x -= other.x;\n    result.y -= other.y;\n    return result;\n  }\n\n  Vec operator*(const double &k)\n  {\n    Vec result = *this;\n    result.x *= k;\n    result.y *= k;\n    return result;\n  }\n\n  Vec operator/(const double &k)\n  {\n    Vec result = *this;\n    result.x /= k;\n    result.y /= k;\n    return result;\n  } \n  \n  double cross(const Vec &other)\n  {\n    return x*other.y - y*other.x;\n  }\n\n  double dot(const Vec &other){\n    return x*other.x + y*other.y;\n  }\n  \n  bool operator==(const Vec &other) const\n  {\n    return abs(x - other.x) < EPS && abs(y - other.y) < EPS;\n  }\n\n  double norm()\n  {\n    return sqrt(x*x+y*y);\n  }\n\n  double norm2()\n  {\n    return x*x+y*y;\n  }\n\n  Vec standard(){\n    Vec result = *this;\n    return result/result.norm();\n  }\n};\n\n//ccw:1, cw:-1, other:0\nInt CCW(Vec a, Vec b, Vec c){\n  b = b - a;\n  c = c - a;\n  if(b.cross(c) > EPS)return -1;\n  if(b.cross(c) < -EPS)return 1;\n  return 0;\n}\n\ndouble dist(Vec a, Vec b){\n  return (a-b).norm();\n}\n\t\t\t\n\nclass Line{\npublic:\n  Vec a, b;\n  Vec vect;\n  Line(Vec a = Vec(), Vec b = Vec()):a(a),b(b),vect(b-a){}\n\n  //projection\n  Vec proj(Vec p){\n    p = p - a;\n    return a + vect * vect.dot(p) / vect.norm2();\n  }\n\n  //reflection\n  Vec reflect(Vec p){\n    return proj(p) * 2 - p;\n  }\n\n  bool onSegment(Vec p){\n    return abs((p-a).cross(b-a)) < EPS && (p-a).dot(p-b) < EPS;\n  }\n\n  //other -> LineSegment(not inclusive), this -> Line\n  bool _intersect(Line other){\n    return CCW(a, b, other.a) * CCW(a, b, other.b) < 0;\n  }\n\n  //other, this: both are LineSegment(inclusive)\n  bool intersect(Line other){\n    return onSegment(other.a) || onSegment(other.b) || other.onSegment(a) || other.onSegment(b) || _intersect(other) && other._intersect(*this);\n  }\n\n  //low accuracy\n  Vec crossPoint(Line &other){\n    double ratio = (a - other.a).cross(vect) / other.vect.cross(vect);\n    return other.a + other.vect * ratio;\n  }\n\n  double dist(Vec p){\n    Vec pp = proj(p);\n    if(onSegment(pp))return ::dist(p, pp);\n    else return min(::dist(p, a), ::dist(p, b));\n  }\n  \n  double dist(Line &other){\n    if(intersect(other))return 0;\n    return min(min(dist(other.a), dist(other.b)), min(other.dist(a), other.dist(b)));\n  }\n};\n\n\nvoid ok(){\n  cout << \"1\" << endl;\n  exit(0);\n}\n\nvoid ng(){\n  cout <<  \"0\" << endl;\n  exit(0);\n}\n\nclass Polygon{\npublic:\n  vector<Vec> points;\n  Int n;\n  Polygon(){}\n  void read(Int _n){\n    n = _n;\n    points.clear();\n    while(_n--)points.push_back(Vec().read());\n  }\n  Polygon &set(vector<Vec> &v){\n    points = v;\n    n = points.size();\n    return *this;\n  }\n  Vec& operator[](int index)\n  {\n    return points[index];\n  }\n  //Signed Area\n  double area(){\n    double area = 0;\n    for(int i = 0;i < n;i++){\n      area += points[i].cross(points[(i+1)%n]);\n    }\n    return area / 2;\n  }\n\n  //inside:2, onEdge:1, outside:0\n  Int inPolygon(Vec p){\n    Int crossCount = 0;\n    Line halfLine(p, Vec(p.x+1,INF));\n    for(int i = 0;i < n;i++){\n      if(Line(points[i], points[(i+1)%n]).onSegment(p))return 1;\n      if(Line(points[i], points[(i+1)%n]).intersect(halfLine))crossCount++;\n      if(halfLine.onSegment(points[i])){\n\tcrossCount--;\n      }\n\n    }\n    return (crossCount%2)*2;\n  }\n};\n//OnLine OK\nPolygon convexHull(vector<Vec> points){\n  sort(points.begin(), points.end());\n  vector<Vec> res;\n  int n = points.size();\n  for(int i = 0;i < n;i++){\n    while(res.size() > 1 && CCW(res[res.size() - 2], res[res.size() - 1], points[i]) == 1)res.pop_back();\n    res.push_back(points[i]);\n  }\n  int k = res.size();\n  for(int i = n-2;i >= 0;i--){\n    while(res.size() > k && CCW(res[res.size() - 2], res[res.size() - 1], points[i]) == 1)res.pop_back();\n    res.push_back(points[i]);\n  }\n  res.pop_back();\n  return Polygon().set(res);\n}\n\nint main(){\n  Int n,q;\n  cin >> n;\n  Polygon pol;\n  vector<Vec> points(n);\n  while(n--)points[n].read();\n  pol = convexHull(points);\n  int far = 0;\n  double res = 0;\n  n = pol.n;\n  for(int i = 0;i < n;i++){\n    while(dist(pol[i], pol[far % n]) < dist(pol[i], pol[(far+1)%n]))far++;\n    res = max(res, dist(pol[i], pol[far % n]));\n  }\n  printf(\"%.10lf\\n\", res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\n#define eps (1e-10)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{\n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;\n  }\n  double dot(Point p){return x*p.x+y*p.y;}\n  double det(Point p){return x*p.y-y*p.x;}\n};\nbool cmp_x(const Point& p,const Point& q){\n  if(p.x!=q.x) return p.x<q.x;\n  return p.y<q.y;\n}\nbool cmp_y(const Point& p,const Point& q){\n  if(p.y!=q.y) return p.y<q.y;\n  return p.x<q.x;\n}\nvector<Point> convex_hull(Point* ps,int n){\n    sort(ps,ps+n,cmp_x);\n    int k=0;\n    vector<Point> qs(n*2);\n    rep(i,n){\n        while(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<0) --k;//<=:exclusion online\n        qs[k++]=ps[i];\n    }\n    for(int i=n-2,t=k;i>=0;--i){\n        while(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<0) --k;// <=\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\ndouble distance(Point p,Point q){\n    return (p-q).abs();\n}\n//convex_diameter\nint main(){\n    int n;\n    //vector<Point> qs=convex_hull(ps,n);\n    cin>>n;\n    double xi,yi;\n    vector<Point> qs(n);\n    rep(i,n){\n        cin>>xi>>yi;\n        qs[i]=Point(xi,yi);\n    }\n    if(n==2){\n        cout<<fixed<<setprecision(12)<<distance(qs[0],qs[1])<<endl;\n        return 0;\n    }\n    int i=0,j=0;\n    rep(k,n){\n        if(!cmp_x(qs[i],qs[k])) i=k;\n        if(cmp_x(qs[j],qs[k])) j=k;\n    }\n    double res=0;\n    int si=i,sj=j;\n    while(i!=sj||j!=si){\n        res=max(res,distance(qs[i],qs[j]));\n        if((qs[(i+1)%n]-qs[i]).det(qs[(j+1)%n]-qs[j])<0){\n            i=(i+1)%n;\n        }\n        else{\n            j=(j+1)%n;\n        }\n    }\n    cout<<fixed<<setprecision(12)<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef double db;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nnamespace Geometry{\n\tconst db eps = 1e-9;\n\tstruct point{\n\t\tdb x,y;\n\t\tinline point operator + (const point &p){return (point){x+p.x,y+p.y};}\n\t\tinline point operator - (const point &p){return (point){x-p.x,y-p.y};}\n\t\tinline db operator * (const point &p){return x*p.x+y*p.y;}\n\t\tinline point operator / (const db &v){return (point){x/v,y/v};}\n\t\tinline point operator * (const db &v){return (point){x*v,y*v};}\n\t\tinline db len(){return sqrt(x*x+y*y);}\n\t};\n\ttypedef point vec;\n\tinline db dot(vec a,vec b){return a.x*b.x+a.y*b.y;}\n\tinline db sqr(db x){return x*x;}\n\tinline db dis(point a,point b){return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}\n\tinline db dis2(point a,point b){return sqr(a.x-b.x)+sqr(a.y-b.y);}\n\tinline db cross(vec a,vec b){return a.x*b.y-a.y*b.x;}\n\tstruct line{\n\t\tpoint a,b;\n\t\tinline db len(){return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}\n\t};\n\tinline point projection(point A,line b){\n\t\tpoint B=b.a,C=b.b;\n\t\tvec BA=A-B,BC=C-B,BD=BC*(BA*BC/dis2(B,C));\n\t\treturn B+BD;\n\t}\n\tinline point reflection(point A,line b){\n\t\tpoint D=projection(A,b);\n\t\treturn (point){D.x*2-A.x,D.y*2-A.y};\n\t}\n\tinline int Counter_Clockwise(point A,line b){\n\t\tpoint B=b.a,C=b.b;\n\t\tdb f1=cross(C-B,A-B);\n\t\tif (fabs(f1)>eps) return (f1<0?2:1);\n\t\tdb f2=(C-B)*(A-B);\n\t\tif (f2<0) return 3;\n\t\treturn dis(B,C)<dis(A,B)?4:5;\n\t}\n\tinline int checkline(line a,line b){\n\t\tvec A=a.b-a.a,B=b.b-b.a;\n\t\tdb f1=A*B;\n\t\tif (fabs(f1)<=eps) return 1;\n\t\treturn fabs(cross(A,B))<=eps?2:0;\n\t}\n\tinline bool checkseg(line a,line b){\n\t\tpoint A=a.a,B=a.b,C=b.a,D=b.b;\n\t\tif (max(A.x,B.x)<min(C.x,D.x)) return 0;\n\t\tif (min(A.x,B.x)>max(C.x,D.x)) return 0;\n\t\tif (max(A.y,B.y)<min(C.y,D.y)) return 0;\n\t\tif (min(A.y,B.y)>max(C.y,D.y)) return 0;\n\t\tdb s=cross(B-A,C-A),h=cross(B-A,D-A);\n\t\tif (s*h>=eps) return 0;\n\t\tdb i=cross(D-C,A-C),t=cross(D-C,B-C);\n\t\treturn i*t<=eps;\n\t}\n\tinline point crosspoint(line a,line b){\n\t\tpoint A=a.a,B=a.b,C=b.a,D=b.b;\n\t\tdb s1=fabs(cross(B-A,C-A)),s2=fabs(cross(B-A,D-A));\n\t\tvec CO=(D-C)*(s1/(s1+s2));\n\t\treturn C+CO;\n\t}\n\tinline db dis(point\tA,line b){\n\t\tpoint B=b.a,C=b.b,D=projection(A,b);\n\t\tint tmp=Counter_Clockwise(D,b);\n\t\tif (tmp==3) return dis(B,A);\n\t\tif (tmp==4) return dis(C,A);\n\t\tif (tmp==5) return dis(D,A);\n\t}\n\tinline db dis(line a,line b){\n\t\tif (checkseg(a,b)) return 0;\n\t\tdb s=dis(a.a,b),h=dis(a.b,b),i=dis(b.a,a),t=dis(b.b,a);\n\t\treturn min({s,h,i,t});\n\t}\n\ttypedef vector<point> polygon;\n\tinline db S(polygon v){\n\t\tdb s=cross(v.back(),v[0]);\n\t\tFor(i,0,siz(v)-2) s+=cross(v[i],v[i+1]);\n\t\treturn s/2;\n\t}\n\tinline bool check(polygon v){\n\t\tint n=siz(v),f=(cross(v[n-1]-v[n-2],v[0]-v[n-1])>=-eps);\n\t\tFor(i,1,n-2) if ((cross(v[i]-v[i-1],v[i+1]-v[i])>=-eps)!=f) return 0;\n\t\treturn 1;\n\t}\n\tinline int check(point a,polygon v){\n\t\tdb k=sqrt(23);point b=(point){a.x+1000000000,a.y+k*1000000000};\n\t\tint n=siz(v);bool f=0;\n\t\tFOR(i,0,n){\n\t\t\tif (Counter_Clockwise(a,(line){v[i],v[(i+1)%n]})==5) return 1;\n\t\t\tif (checkseg((line){v[i],v[(i+1)%n]},(line){a,b})) f^=1;\n\t\t}\n\t\treturn !f?0:2;\n\t}\n\tint top;\n\tvector<int>stk;\n\tinline polygon Convex_Hull(polygon v){\n\t\tsort(all(v),[](point a,point b){\n\t\t\treturn a.y<b.y||(a.y==b.y&&a.x<b.x);\n\t\t});\n\t\tint n=siz(v);point o=v[0];\n\t\tDow(i,n-1,0) v[i]=v[i]-o;\n\t\tsort(all(v),[](point a,point b){\n\t\t\tdb tmp=cross(a,b);\n\t\t\treturn tmp>0||(fabs(tmp)<=eps&&a.len()<b.len());\n\t\t});\n\t\ttop=0,stk.resize(n+1);\n\t\tFOR(i,0,n){\n\t\t\twhile (top>=2&&cross(v[i]-v[stk[top-1]],v[stk[top]]-v[stk[top-1]])>=0) --top;\n\t\t\tstk[++top]=i;\n\t\t}\n\t\tpolygon ret;\n\t\tFor(i,1,top) ret.pb(v[stk[i]]+o);\n\t\treturn ret;\n\t}\n\tinline db D(polygon v){\n\t\tauto dis=[](point a,line b) -> db{\n\t\t\treturn cross(b.a-a,b.b-a)/b.len();\n\t\t};\n\t\tint h=0,n=siz(v);db ans=0;\n\t\tFOR(i,0,n-1){\n\t\t\twhile (dis(v[h],(line){v[i],v[i+1]})<=dis(v[(h+1)%n],(line){v[i],v[i+1]})) h=(h+1)%n;\n\t\t\tans=max({ans,(v[i]-v[h]).len(),(v[i+1]-v[h]).len()});\n\t\t}\n\t\treturn ans;\n\t}\n};\nusing namespace Geometry;\n\nint main(){\n//\tfreopen(\"data.in\",\"r\",stdin);\n\tint n=read();polygon v(n);\n\tFOR(i,0,n) scanf(\"%lf%lf\",&v[i].x,&v[i].y);\n\tprintf(\"%0.10lf\",D(v));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-9;\nstruct dot{\n\tdouble x,y;\n\tdouble len(){return sqrt(x*x+y*y);}\n\tdot(double a=0.0,double b=0.0){x=a,y=b;}\n\tdot operator +(const dot&b)const {return dot(x+b.x,y+b.y);}\n\tdot operator -(const dot&b)const {return dot(x-b.x,y-b.y);}\n\tdot operator *(const double&z)const {return dot(x*z,y*z);}\n\tbool operator <(const dot&b)const {return (y<b.y)||(y==b.y&&x<b.x);}\n\tbool operator ==(const dot&b)const {return fabs(x-b.x)<eps&&fabs(y-b.y)<eps;}\t\n\tbool operator !=(const dot&b)const {return fabs(x-b.x)>=eps||fabs(y-b.y)>=eps;}\n\tvoid read(){scanf(\"%lf%lf\",&x,&y);} \n};\nstruct line{\n\tdot x1,x2;\n\tvoid read(){x1.read();x2.read();};\n\tline(dot a=dot(0.0,0.0),dot b=dot(0.0,0.0)){x1=a,x2=b;} \n\tdot getdot(){return x2-x1;}\n};\ndouble chaji(dot x,dot y){\n\treturn x.x*y.y-x.y*y.x;\n}\ndouble neiji(dot x,dot y){\n\treturn x.x*y.x+x.y*y.y;\n}\ndouble cos(dot x,dot y){\n\tif (!x.len()||!y.len())return 0;\n\treturn neiji(x,y)/x.len()/y.len();\n}\ndot Projection(dot x,line y){//求x关于直线y的投影点（垂足） \n\ty.x2=y.x2-y.x1;\n\tx=x-y.x1;\n\tdouble len=cos(x,y.x2)*x.len()/y.x2.len();\n\ty.x2=y.x2*len;\n\treturn y.x2+y.x1;\n}\ndot Reflection(dot x,line y){//求x关于直线y的对称点 \n\tdot z=Projection(x,y);\n\treturn z*2-x;\n}\nint Counter_Clockwise(dot x,line y){//求两个向量的五种关系 \n\tx=x-y.x1;y.x2=y.x2-y.x1;\n\tif (chaji(y.x2,x)!=0){\n\t\tif (chaji(y.x2,x)>0)return 1;\n\t\treturn 2;\n\t} \n\tif (fabs(cos(x,y.x2)+1)<eps)return 3;\n\tif (x.len()>y.x2.len())return 4;\n\treturn 5;\n} \nint Parallel_Orthogonal(line x,line y){//求两个直线是垂直还是平行还是其他 \n\tdot a=x.getdot(),b=y.getdot();\n\tif (chaji(a,b)==0)return 2;\n\tif (neiji(a,b)==0)return 1;\n\treturn 0;\n}\nint Intersection(line x,line y){//求两条直线是否相交 \n\tint Minx1=min(x.x1.x,x.x2.x),Maxx1=max(x.x1.x,x.x2.x);\n\tint Minx2=min(y.x1.x,y.x2.x),Maxx2=max(y.x1.x,y.x2.x);\n\tint Miny1=min(x.x1.y,x.x2.y),Maxy1=max(x.x1.y,x.x2.y);\n\tint Miny2=min(y.x1.y,y.x2.y),Maxy2=max(y.x1.y,y.x2.y);\n\tif (Minx1>Maxx2||Minx2>Maxx1)return 0;\n\tif (Miny1>Maxy2||Miny2>Maxy1)return 0;\n\tif (chaji(x.getdot(),y.x1-x.x1)*chaji(x.getdot(),y.x2-x.x1)>0)return 0;\n\tif (chaji(y.getdot(),x.x1-y.x1)*chaji(y.getdot(),x.x2-y.x1)>0)return 0;\n\treturn 1;\n}\ndot CrossPoint(line x,line y){//求两条线段的交点 \n\tif (fabs(cos(x.getdot(),y.getdot())-1)<eps){\n\t\tif (x.x2<y.x2)return y.x2;\n\t\telse return x.x2;\n\t}\n\telse {\n\t\tif (x.x2.x-x.x1.x==0){\n\t\t\tdouble k2=(y.x2.y-y.x1.y)/(y.x2.x-y.x1.x),b2=y.x2.y-y.x2.x*k2;\n\t\t\treturn dot(x.x2.x,x.x2.x*k2+b2);\n\t\t}\n\t\tif (y.x2.x-y.x1.x==0){\n\t\t\tdouble k1=(x.x2.y-x.x1.y)/(x.x2.x-x.x1.x),b1=x.x2.y-x.x2.x*k1;\n\t\t\treturn dot(y.x2.x,y.x2.x*k1+b1);\t\t\t\n\t\t}\n\t\tdouble k1=(x.x2.y-x.x1.y)/(x.x2.x-x.x1.x),b1=x.x2.y-x.x2.x*k1;\n\t\tdouble k2=(y.x2.y-y.x1.y)/(y.x2.x-y.x1.x),b2=y.x2.y-y.x2.x*k2;\n\t\tdot ans;\n\t\tans.x=(b2-b1)/(k1-k2);ans.y=ans.x*k1+b1;\n\t\treturn ans;\n\t}\n} \ndouble Dis(dot x,dot y){//点到点的距离 \n\treturn sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));\n}\ndouble dist(line x,dot y){//点到线段的距离 \n\tdot P=Projection(y,x);\n\tdouble k=neiji(x.getdot(),P-x.x1)/neiji(x.getdot(),x.getdot());\n\tif (k<=0)return Dis(x.x1,y);\n\tif (k>=1)return Dis(x.x2,y);\n\treturn Dis(y,P);\n}\ndouble Distance(line x,line y){//线段之间距离 \n\treturn min(min(dist(x,y.x1),dist(x,y.x2)),min(dist(y,x.x1),dist(y,x.x2)));\n}\nstruct polygon{\n\tvector<dot > A;\n\tdouble S(){//多边形面积\n\t\tdouble ans=0;\n\t\tfor (int i=0;i+1<A.size();i++)ans+=chaji(A[i],A[i+1])/2;\n\t\tif (A.size()>1)ans+=chaji(A[A.size()-1],A[0])/2;\n\t\treturn ans;\t\t\n\t}\n\tdouble C(){//多边形周长 \n\t\tdouble ans=0;\n\t\tfor (int i=0;i+1<A.size();i++)ans+=Dis(A[i],A[i+1]);\n\t\tif (A.size()>1)ans+=Dis(A[A.size()-1],A[0]);\n\t\treturn ans;\n\t}\n\tvoid read(){\n\t\tint n;scanf(\"%d\",&n);A.resize(n);\n\t\tfor (int i=0;i<n;i++)A[i].read();\n\t}\n\tint Is_Convex(){//是否是凸多边形 \n\t\tfor (int i=0;i<A.size();i++)\n\t\t\tif (chaji(A[(i+1)%A.size()]-A[i],A[(i+2)%A.size()]-A[(i+1)%A.size()])<0)\n\t\t\t\treturn 0;\n\t\treturn 1;\n\t}\n};\nint PolygonPointContainment(polygon G,dot x){//射线和多边形的关系\n\tfor (int i=0;i<G.A.size();i++)\n\t\tif (Counter_Clockwise(x,line(G.A[i],G.A[(i+1)%G.A.size()]))==5)return 1;\n\tfor (int i=0;i<G.A.size();i++)\n\t\tif (x==G.A[i])return 1;\n\tdouble k=sqrt(2)+1,b=x.y-x.x*k;\n\tdot x2=dot(-1000000000,-1000000000*k+b);line R=line(x,x2);\n\tint ans=0;\n\tfor (int i=0;i<G.A.size();i++)\n\t\tif (Intersection(R,line(G.A[i],G.A[(i+1)%G.A.size()])))ans++;\n\tif (ans&1)return 2;\n\treturn 0;\t\n}\nint isclock(dot x,dot y,dot z){//是否顺时针 \n\treturn chaji(z-x,y-x)<0;\n}\npolygon Convex_Hull(polygon G){//求凸包 \n\tpolygon ans1,ans2;\n\tsort(G.A.begin(),G.A.end());\n\tans1.A.push_back(G.A[0]);ans1.A.push_back(G.A[1]);\n\tfor (int i=2;i<G.A.size();i++){\n\t\twhile (ans1.A.size()>=2&&isclock(ans1.A[ans1.A.size()-2],ans1.A[ans1.A.size()-1],G.A[i]))\n\t\t\tans1.A.pop_back();\n\t\tans1.A.push_back(G.A[i]);\t\n\t}\n\tans2.A.push_back(G.A[G.A.size()-1]);ans2.A.push_back(G.A[G.A.size()-2]);\n\tfor (int i=G.A.size()-3;i>=0;i--){\n\t\twhile (ans2.A.size()>=2&&isclock(ans2.A[ans2.A.size()-2],ans2.A[ans2.A.size()-1],G.A[i]))\n\t\t\tans2.A.pop_back();\n\t\tans2.A.push_back(G.A[i]);\t\t\n\t}\n\tfor (int i=1;i<ans2.A.size()-1;i++)ans1.A.push_back(ans2.A[i]);\n\treturn ans1;\n}\ndouble DiameterofaConvexPolygon(polygon G){\n\tint l=0,r=1,flag=1;\n\tdouble ans=Dis(G.A[0],G.A[1]);\n\twhile (l!=0||flag){\n\t\tflag=0;\n\t\twhile (Dis(G.A[l],G.A[r])<=Dis(G.A[l],G.A[(r+1)%G.A.size()])){\n\t\t\tr=(r+1)%G.A.size();\n\t\t\tans=max(ans,Dis(G.A[l],G.A[r]));\n\t\t}\n\t\tl=(l+1)%G.A.size();\n\t\tans=max(ans,Dis(G.A[l],G.A[r]));\n\t}\n\treturn ans;\n}\nint main(){\n\tpolygon A;\n\tA.read();\n\tprintf(\"%.10lf\\n\",DiameterofaConvexPolygon(A));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\nstruct Point{\n\tdouble x,y;\n\tPoint(double x = 0,double y = 0): x(x),y(y) {}\n\tPoint operator + (Point p){\n\t\treturn Point(x + p.x,y + p.y);\n\t}\n\tPoint operator - (Point p){\n\t\treturn Point(x - p.x,y - p.y);\n\t}\n\tPoint operator - (){\n\t\treturn Point(-x,-y);\n\t}\n\tPoint operator * (double lambda){\n\t\treturn Point(x * lambda,y * lambda);\n\t}\n\tPoint operator / (double lambda){\n\t\treturn Point(x / lambda,y / lambda);\n\t}\n\tPoint rot(double theta){\n\t\treturn Point(cos(theta) * x - sin(theta) * y,\n\t\t\t\t\t\t\t\tsin(theta) * x + cos(theta) * y);\n\t}\n\tdouble norm(){\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs_(){\n\t\treturn sqrt(norm());\n\t}\n\tbool operator == (const Point p)const\n\t{\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n\tbool operator < (const Point p)const\n\t{\n\t\tif(abs(x - p.x) < EPS) return y < p.y;\n\t\treturn x < p.x;\n\t}\n};\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble det(Vector a,Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\ntypedef vector <Point> Polygon;\ndouble diameter(Polygon po){\n\tint n = po.size(), minp = 0, maxp = 0;\n\tfor(int i=1;i<n;i++){\n\t\tif(po[i] < po[minp]) minp = i;\n\t\tif(po[maxp] < po[i]) maxp = i;\n\t}\n\tint i = minp, j = maxp;\n\tdouble ans = 0.0;\n\twhile(i != maxp || j != minp){\n\t\tans = max(ans,(po[i] - po[j]).abs_());\n\t\tif(det(po[(i + 1) % n] - po[i], po[(j + 1) % n] - po[j]) < EPS){\n\t\t\ti = (i + 1) % n;\n\t\t}else{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn ans;\n}\nint n; Polygon g;\nint main(){\n\tscanf(\"%d\",&n);\n\tg.resize(n);\n\tfor(int i=0;i<n;i++) scanf(\"%lf%lf\",&g[i].x,&g[i].y);\n\tprintf(\"%.10f\\n\",diameter(g));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long int;\nusing lc = complex<double>;\n\ntemplate<typename T>\nstruct Convex {\n    using P = complex<T>;\n    ll n;\n    vector<ll> conv;\n    vector<P> v;\n\n    T cross(P a, P b) {\n        return (a * conj(b)).imag();\n    }\n\n    Convex(const vector<P> &_v) {\n        // incremental method\n        n = _v.size();\n        v = _v;\n\n        auto comp = [&](P a, P b) {\n            return make_tuple(real(a),imag(a)) < make_tuple(real(b), imag(b));\n        };\n        sort(v.begin(), v.end(), comp);\n\n        ll k = 0;\n        conv.resize(n+1);\n        for(ll i=n-1; i>=0; conv[k++] = i--) // up\n            while(k>=2 && cross(v[i] - v[conv[k-1]], v[conv[k-2]] - v[conv[k-1]]) > 0) k--;\n        for(ll i=1, t=k+1; i<n; conv[k++] = i++) // dn\n            while(k>=t && cross(v[i] - v[conv[k-1]], v[conv[k-2]] - v[conv[k-1]]) > 0) k--;\n        conv.resize(k-1);\n    }\n\n    P operator[](ll i) {\n        return v[conv[i]];\n    }\n    ll size() {\n        return conv.size();\n    }\n\n    double diam() {\n        ll i=0, j=0;\n        for(ll k=0; k<size(); k++) {\n            if(imag((*this)[i]) < imag((*this)[k])) i = k;\n            if(imag((*this)[j]) > imag((*this)[k])) j = k;\n        }\n        ll si = i, sj = j;\n\n        T res = 0;\n        do {\n            res = max(res, norm((*this)[i] - (*this)[j]));\n            if(cross((*this)[(i+1)%size()] - (*this)[i], (*this)[(j+1)%size()] - (*this)[j]) <= 0)\n                j = (j+1) % size();\n            else\n                i = (i+1) % size();\n        } while(!(si == i && sj == j));\n        return sqrt(res);\n    }\n};\n\nint main(void) {\n    constexpr ll MOD = 1e9 + 7;\n    constexpr double PI = acos(-1);\n    cout << fixed << setprecision(32);\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n\n    vector<complex<double>> a(n);\n    for(ll i=0; i<n; i++) {\n        double x, y;\n        cin >> x >> y;\n        a[i] = complex<double>(x, y);\n    }\n    Convex<double> cva(a);\n\n    cout << cva.diam() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; }\n    db operator * (const point &p){ return x * p.x + y * p.y; }\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n};\n\npoint err = point(INF_d, INF_d);\n\npoint proj_SP(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl_SP(point A, point B, point P){ // reflection point of P int segment AB\n    return proj_SP(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n// calculate the intersection point of two segments, first check and then call inter_LL to get the cross point\n\nbool inmid(db a, db b, db c){  // check whether a <= c <= b\n    return dcmp(dcmp(b - c) * dcmp(a - c)) <= 0; \n}\n\nbool inmid(point A, point B, point P){ // check whether point P is in the rectangle of segment AB\n    return inmid(A.x, B.x, P.x) && inmid(A.y, B.y, P.y);\n}\n\ndb dis_SP(point A, point B, point P){ // the minimum distance from a point P to segment AB\n    point p_proj = proj_SP(A, B, P);\n    if (inmid(A, B, p_proj)) return (P - p_proj).len();\n    else return min((P - A).len(), (P - B).len());\n}\n\ndb dis_SS(point A, point B, point C, point D){ // the minimum distance from two segments AB and CD\n    db res = INF_d;\n    if (check_SS(A, B, C, D)) res = 0;\n    res = min(res, dis_SP(A, B, C));\n    res = min(res, dis_SP(A, B, D));\n    res = min(res, dis_SP(C, D, A));\n    res = min(res, dis_SP(C, D, B));\n    return res;\n}\n\ndb poly_Area(point *poly, int n){ // calc the area of a simple polygon poly, n is the number of points.\n    //the points should be in clockwise or counter_clockwise.\n    db res = 0.0;\n    for (int i = 1; i < n - 1; i++){\n        res += (poly[i] - poly[0]) ^ (poly[i + 1] - poly[0]);\n    }\n    return fabs(res) / 2;\n}\n\nbool is_Convex(point *poly, int n){ // check whether a polygon is a convex polygon. Make sure points are in counter-clockwised order.\n    poly[n] = poly[0];\n    if (n < 3) return 1;\n    for (int i = 1; i < n; i++){\n        int tmp_dir = dcmp((poly[i] - poly[i - 1]) ^ (poly[(i + 1) % n] - poly[i]));\n        if (tmp_dir < 0) return 0;\n    }\n    return 1;\n}\n\nbool is_PonS(point A, point B, point P){ // check whether a point P is on a segment AB\n    return inmid(A, B, P) && !dcmp((P - A) ^ (B - A));\n}\n\nint is_PinPoly(point *poly, int n, point P){ // check the position relation of a point and polygon.\n    // 0: outside, 1: on a segment, 2: inside\n    int pd = 0;\n    for (int i = 0; i < n; i++){\n        point u = poly[i], v = poly[(i + 1) % n];\n        if (is_PonS(u, v, P)) return 1;\n        if (dcmp(u.y - v.y) > 0) swap(u, v);\n        if (dcmp(u.y - P.y) >= 0 || dcmp(v.y - P.y) < 0) continue;\n        if (dcmp((u - v) ^ (P - v)) < 0) pd ^= 1;\n    }\n    return pd << 1;\n}\n\nbool cmpxy(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nbool cmpyx(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint get_convexhull(point *p, int n, point *ch){ // get the convexhull of given polygon p\n    // pay attention to when m = 0, 1, 2 as the return value\n    sort(p, p + n, cmpyx); // may be changed by the requirement of problem\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        while (m > 1 && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--){\n        while (m > k && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    return m;\n}\n\ndb convexhull_diameter(point *ch, int n){ // calculate the diameter of a give convexhull\n    if (n < 2) return 0;\n    int is, js; is = js = 0;\n    for (int i = 0; i < n; i++){\n        is = ch[i] < ch[is] ? i : is;\n        js = ch[js] < ch[i] ? i : js;\n    }\n    int i = is, j = js;\n    db ret = (ch[is] - ch[js]).len();\n    do{\n        if (dcmp((ch[(i + 1) % n] - ch[i]) ^ (ch[(j + 1) % n] - ch[j])) > 0){\n            j = (j + 1) % n;\n        }\n        else{\n            i = (i + 1) % n;\n        }\n        ret = max(ret, (ch[i] - ch[j]).len());\n    } while (i != is || j != js);\n    return ret;\n}\n\nconst int N = 1e5 + 7;\nint n, m;\npoint p[N], x, ch[N];\n\nint main(){\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        p[i].read();\n    }\n    printf(\"%.12f\\n\", convexhull_diameter(p, n));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\ntypedef long double     lf;\n\nusing namespace std;\n\nconst lf EPS = 1e-9;\nconst lf oo = 1e15;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << int(p.x) << \" \" << int(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf dot( pt A, pt B ) {\n  return x(A)*x(B) + y(A)*y(B);\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nlf distToLine (pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  c = A + u*( B-A );\n  return dist( p , c );\n}\n\npt refPoint(pt X, pt A, pt B) {\n  pt aux; distToLine(X, A, B, aux);\n  return X + lf(2.0)*(aux-X);\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf cross( pt A, pt B ) {\n  return x(A)*y(B) - y(A)*x(B);\n}\n\n///CHANGE\n// 0  for collineal points ( angle = 0 )\n// 1  for angle BAX counter clockwise\n// -1 for angle BAX clockwise\ninline int ccw (pt X, pt A, pt B) {\n  lf c = cross( B-A, X-A );\n  if( same( c, 0.0 ) ) { return 0; }\n  if( c > EPS ) { return 1; }\n  return -1;\n}\n\n///CHANGE\ninline bool segContains ( pt X, pt A, pt B) {\n  if ( !same ( 0, cross ( A-X, B-X ) ) ) return 0;\n  return ( dot ( A-X, B-X ) < EPS );\n}\n\ninline bool parallel( pt A, pt B, pt C, pt D ) {\n  return same ( 0, cross( B-A, D-C ) );\n}\n\n///NEW\ninline bool ortho( pt A, pt B, pt C, pt D ) {\n  return same ( 0, dot( B-A, D-C ) );\n}\n\ninline bool samePt ( pt A, pt B ) {\n  return same ( x(A), x(B) ) && same ( y(A), y(B) );\n}\n\npt linesIntersection ( pt A, pt B, pt C, pt D ) {\n  lf x = cross ( C, D-C ) - cross ( A, D-C );\n  x /= cross ( B-A, D-C );\n  return A + x*(B-A);\n}\n\ninline bool collinearSegsIntersects ( pt A, pt B, pt C, pt D ) {\n  return segContains(A,C,D) || segContains(B,C,D)\n      || segContains(C,A,B) || segContains(D,A,B);\n}\n\nbool segmentsIntersect(pt A, pt B, pt C, pt D) {\n  if( samePt(A,B) )\n    return segContains( A, C, D );\n  if( samePt(C,D) )\n    return segContains( C, A, B );\n  if( parallel(A,B,C,D) )\n    return collinearSegsIntersects( A,B,C,D );\n  pt aux = linesIntersection(A,B,C,D);\n  return segContains(aux,A,B) && segContains(aux,C,D);\n}\n\n///CHANGE\nlf distToSegment(pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  if( u < -EPS ) { c = A; return dist( p , A ); }\n  if( (u-1.0) > EPS ) { c = B; return dist( p, B ); }\n  return distToLine(p,A,B,c);\n}\n\n// P[0] must be equal to P[n]\n// Area is positive if the polygon is ccw\ndouble signedArea(const vector<pt> &P) {\n  double result = 0.0;\n  for(int i = 0; i < (int)P.size()-1; i++) result += cross( P[i],P[i+1] );\n  return result / 2.0;\n}\n\ndouble area(const vector<pt> &P) { return fabs(signedArea(P)); }\n\n///CHANGE\n// P[0] must be equal to P[n]\nbool isConvex( const vector<pt> &P) {\n  int sz = (int) P.size(); if(sz <= 3) return false;\n  bool isL = ccw(P[0], P[1], P[2]) >= 0;\n  for (int i = 1; i < sz-1; i++) {\n    if( ( ccw(P[i], P[i+1], P[(i+2) == sz ? 1 : i+2]) >= 0 ) != isL) return false;\n  }\n  return true;\n}\n\n///CHANGE\n// P[0] must be equal to P[n]     -    O(N)\n// Return 1 for interior, 0 for boundary and -1 for exterior\nint inPolygon(pt X, const vector<pt> &P) {\n  const int n = P.size(); int cnt = 0;\n  for (int i = 0; i < n-1; i++) {\n    if( segContains(X, P[i], P[i+1]) ) return 0;\n    if( y(P[i]) <= y(X) ) {\n      if( y(P[i+1]) > y(X) )\n        if( !(ccw( X, P[i], P[i+1]) >= 0) ) cnt++;\n    }\n    else if ( y(P[i+1]) <= y(X) ) {\n      if( ccw( X, P[i], P[i+1]) >= 0 ) cnt--;\n    }\n  }\n  if(cnt == 0) return -1;\n  else return 1;\n}\n\n///CHANGE\n//CONVEX HULL Monotone Chain O( N Log N )\nbool cmpPt( pt A, pt B ) {\n  if( !same( x(A), x(B) ) ) return x(A) < x(B);\n  return y(A) < y(B);\n}\n\nint turn(pt A, pt B, pt C) {\n  lf r = cross(B-A, C-A);\n  if( same( r, 0.0 ) ) return 0;\n  if( r > EPS ) return 1;\n  return -1;\n}\n\n// Return CH in ccw order starting at leftmost - downmost x\n// Doesn't return P[ n ] = P[ 0 ]\nvector<pt> CH( vector<pt> &P ) {\n  if ( P.size() == 1 ) return P;\n  const int n = P.size();\n  sort ( P.begin(), P.end(), cmpPt );\n  vector<pt> up;\n  up.push_back(P[0]); up.push_back(P[1]);\n  vector<pt> dn;\n  dn.push_back(P[0]); dn.push_back(P[1]);\n  for ( int i = 2; i < n; ++i ) {\n    // If collineal points are not needed, is >= and <=, otherwise > and <\n    while ( up.size() > 1 && turn(up[up.size()-2],up.back(),P[i]) >= 0 )\n      up.pop_back();\n    while ( dn.size() > 1 && turn(dn[dn.size()-2],dn.back(),P[i]) <= 0 )\n      dn.pop_back();\n    up.push_back(P[i]);\n    dn.push_back(P[i]);\n  }\n  for (int i = (int) up.size() - 2; i >= 1; i--) dn.push_back(up[i]);\n  return dn;\n}\n\n/// --------------------------------------------\n\nlf diameter( const vector<pt> &P, pt &A, pt &B ) {\n  lf ans = -oo, d;\n  int lo = 0, hi = 0;\n  int sz = int(P.size());\n  for( int i = 0, j = 0; i < sz; ++i ) {\n    while( dist( P[i], P[j] )+EPS < dist( P[i], P[ (j+1)%sz ] )  ) {\n      j = (j+1)%sz;\n    }\n    d = dist( P[i], P[j] );\n    if( ans+EPS < d ) {\n      ans = d;\n      lo = i;\n      hi = j;\n    }\n  }\n  A = P[lo];\n  B = P[hi];\n  return ans;\n}\n\nint n;\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  vector<pt> P(n);\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  pt A,B;\n  cout << double( diameter( P,A,B ) ) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n\ndouble area(const std::vector<std::tuple<double, double> > &vs, int64_t p0, int64_t p1, int64_t p2) {\n    auto vx1 = std::get<0>(vs[p1]) - std::get<0>(vs[p0]);\n    auto vy1 = std::get<1>(vs[p1]) - std::get<1>(vs[p0]);\n\n    auto vx2 = std::get<0>(vs[p2]) - std::get<0>(vs[p0]);\n    auto vy2 = std::get<1>(vs[p2]) - std::get<1>(vs[p0]);\n\n    return std::abs( vx1 * vy2 - vx2 * vy1 );\n}\n\ndouble len2(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto dx = std::get<0>(vs[p]) - std::get<0>(vs[q]);\n    auto dy = std::get<1>(vs[p]) - std::get<1>(vs[q]);\n\n    return dx*dx + dy*dy;\n}\n\nint main() {\n    int64_t n;\n\n    std::cin >> n;\n    \n    std::vector<std::tuple<double, double> > vs(n);\n\n    int64_t p = 0, q = 0;\n    for (int64_t i = 0; i < n; ++i) {\n        std::cin >> std::get<0>(vs[i]) >> std::get<1>(vs[i]);\n\n        if (std::get<0>(vs[i]) < std::get<0>(vs[p])) {\n            p = i;\n        }\n        if (std::get<0>(vs[i]) > std::get<0>(vs[q])) {\n            q = i;\n        }\n    }\n\n    double ans = len2(vs, p, q);\n    for (int64_t i = 0; i < 2*n; ++i) {\n        if (area(vs, p, q, (p+1) % n) > area(vs, p, q, (q+1) % n)) {\n            p = (p+1) % n;\n        } else {\n            q = (q+1) % n;\n        }\n        ans = std::max(ans, len2(vs, p, q));\n    }\n\n    std::cout << std::fixed << std::setprecision(12) << std::sqrt(ans) << std::endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P p;R c;};\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n// convex_hull Verify AOJ CGL_4_A\nVP convex_hull(VP pol){\n\tint n=pol.size(),k=0;\n\tauto cmp_x=[](P a,P b)->bool{return sgn(real(a)-real(b))?sgn(real(a)-real(b))<0:sgn(imag(a)-imag(b)<0);};\n\tsort(begin(pol),end(pol),cmp_x);\n\tVP res(2*n);\n\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sdet(O,res[k-1]-res[k-2],pol[i]-res[k-1])>=1) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sdet(O,res[k-1]-res[k-2],pol[i]-res[k-1])>=1) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size(),i=0,j=0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\tR res=0.0;\n\tauto cmp_x=[](P a,P b)->bool{return sgn(real(a)-real(b))?sgn(real(a)-real(b))<0:sgn(imag(a)-imag(b)<0);};\n\t\n\trep(k,n){\n\t\tif(!cmp_x(pol[i],pol[k]))i=k;\n\t\tif(cmp_x(pol[j],pol[k]))j=k;\n\t}\n\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tchmax(res,abs(pol[i]-pol[j]));\n\t\tif(sdet(O,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse \n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////////////////////////////////////////\n// ?????¢??????\n\n// ???????????§????????????\n//   double  -> Point\n//   Segment -> Line\n\n// ???????????±?????¶???????????§?????????????????§????????¬???\n// int main(){\n//   const double EPS = 1e-9;\n//   double a = 1.3, b = 1e8, c = a + b;\n//   c = c - b;\n//   printf(\"%d\\n\", equal(a, c));          // => 0\n//   printf(\"%d\\n\", relative_equal(a, c)); // => 0\n// }\n\n////////////////////\n// ???????????????\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n////////////////////\n// ?????°\nconst double EPS = 1e-9;                // |EPS|???????????°???0??¨????????±???\n////////////////////\n// ?§???????\nstruct Point {\n  double x, y;\n  Point(const double d = 0.0) : x(d), y(d) {}\n  Point(const double x, const double y) : x(x), y(y) {}\n};\nstruct Segment {\n  Point initial, terminal;\n  Segment(const Point& initial, const Point& terminal) : initial(initial), terminal(terminal) {}\n  Segment(const double x1, const double y1, const double x2, const double y2) : initial(x1, y1), terminal(x2, y2) {}\n};\nstruct Line {\n  Point initial, terminal;\n  Line(const Point& initial, const Point& terminal) : initial(initial), terminal(terminal) {}\n  Line(const double x1, const double y1, const double x2, const double y2) : initial(x1, y1), terminal(x2, y2) {}\n  Line(const Segment& s) : initial(s.initial), terminal(s.terminal) {}\n};\n////////////////////\n// ????£?\nbool relative_equal(const double d1, const double d2) {return d1 == 0 ? std::abs(d2) < EPS : std::abs((d1 - d2) / d1) < EPS;}\n// ??????????????????????????????\nbool operator==(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) && relative_equal(lhs.y, rhs.y);}\nbool operator<(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) ? lhs.y < rhs.y : lhs.x < rhs.x;}\nbool operator>(const Point& lhs, const Point& rhs) {return relative_equal(lhs.x, rhs.x) ? lhs.y > rhs.y : lhs.x > rhs.x;}\nbool operator!=(const Point& lhs, const Point& rhs) {return !(lhs == rhs);}\nbool operator<=(const Point& lhs, const Point& rhs) {return !(lhs > rhs);}\nbool operator>=(const Point& lhs, const Point& rhs) {return !(lhs < rhs);}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x + rhs.x, lhs.y + rhs.y);}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x - rhs.x, lhs.y - rhs.y);}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x * rhs.x, lhs.y * rhs.y);}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x / rhs.x, lhs.y / rhs.y);}\nconst Point operator-(const Point& p) {return Point(-p.x, -p.y);}\n// ???\ndouble abs(const Point& p) {return std::hypot(p.x, p.y);}\ndouble norm(const Point& p) {return p.x * p.x + p.y * p.y;}\ndouble dot(const Point& a, const Point& b) {return a.x * b.x + a.y * b.y;}\ndouble cross(const Point& a, const Point& b) {return a.x * b.y - a.y * b.x;}\n// const Point normalize(const Point& p) {return p / abs(p);}\n// ??????\n// Segment shrink(const Segment& s, const double d = EPS) {\n//   Point p = (s.terminal - s.initial) * d;\n//   return Segment(s.initial + p, s.terminal - p);\n// }\n// ???\nbool parallel(const Line& l1, const Line& l2) {return std::abs(cross(l2.terminal - l2.initial, l1.terminal - l1.initial)) < EPS;}\nbool orthogonal(const Line& l1, const Line& l2) {return std::abs(dot(l2.terminal - l2.initial, l1.terminal - l1.initial)) < EPS;}\n// ??????????????¢???\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK}; \nPOSITION ccw(const Point& a, const Point& b, const Point& p) {\n  Point v1 = b - a;\n  Point v2 = p - a;\n  if(cross(v1, v2) >= EPS) return COUNTER_CLOCKWISE;\n  if(cross(v1, v2) <= -EPS) return CLOCKWISE;\n  if(dot(v1, v2) <= -EPS) return ONLINE_BACK;\n  if(norm(v1) < norm(v2)) return ONLINE_FRONT;              // ????????????: norm(v1)<norm(v2)+EPS?????¨WrongAnswer\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(const Point& p1, const Point& p2) {return p1 == p2;}\nbool intersect(const Point& p, const Segment& s) {return abs(p - s.initial) + abs(p - s.terminal) - abs(s.initial - s.terminal) <= EPS;}\nbool intersect(const Segment& s, const Point& p) {return intersect(p, s);}\nbool intersect(const Point& p, const Line& l) {return !parallel(Line(p, l.initial), Line(p, l.terminal));}\nbool intersect(const Line& l, const Point& p) {return intersect(p, l);}\nbool intersect(const Segment& s1, const Segment& s2) {\n  return ccw(s1.initial, s1.terminal, s2.initial) * ccw(s1.initial, s1.terminal, s2.terminal) <= 0\n      && ccw(s2.initial, s2.terminal, s1.initial) * ccw(s2.initial, s2.terminal, s1.terminal) <= 0;\n}\nbool intersect(const Segment& s, const Line& l) {\n  auto v1 = l.terminal - l.initial;\n  auto v2 = s.initial  - l.initial;\n  auto v3 = s.terminal - l.initial;\n  return cross(v1, v2) * cross(v1, v3) <= EPS;\n}\nbool intersect(const Line& l, const Segment& s) {return intersect(s, l);}\nbool intersect(const Line& l1, const Line& l2) {return !parallel(l1, l2) || intersect(l1.initial, l2);}\n// ???????§????\nPoint projection(const Point& p, const Line& l) {\n  auto v = l.initial - l.terminal;\n  return l.initial + dot(p - l.initial, v) / norm(v) * v;\n}\nPoint projection(const Line& l, const Point& p) {return projection(p, l);}\nPoint reflection(const Point& p, const Line& l) {return p + 2 * (projection(p, l) - p);}\nPoint reflection(const Line& l, const Point& p) {return reflection(p, l);}\n// ?????¢\ndouble distance(const Point& p1, const Point& p2) {\n  auto p = p1 - p2;\n  return hypot(p.x, p.y);\n}\ndouble distance(const Point& p, const Segment& s) {\n  auto r = projection(s, p);\n  return intersect(r, s) ? distance(p, r) : std::min(distance(p, s.initial), distance(p, s.terminal));\n}\ndouble distance(const Segment& s, const Point& p) {return distance(p, s);}\ndouble distance(const Point& p, const Line& l) {return distance(p, projection(p, l));}\ndouble distance(const Line& l, const Point& p) {return distance(p, l);}\ndouble distance(const Segment& s1, const Segment& s2) {\n  return intersect(s1, s2) ? 0.0 : std::min({distance(s1, s2.initial), distance(s1, s2.terminal), distance(s2, s1.initial), distance(s2, s1.terminal)});\n}\ndouble distance(const Segment& s, const Line& l) {return intersect(s, l) ? 0.0 : std::min(distance(s.initial, l), distance(s.terminal, l));}\ndouble distance(const Line& l,const Segment& s) {return distance(s, l);}\ndouble distance(const Line& l1, const Line& l2) {return intersect(l1, l2) ? 0.0 : distance(l1.initial, l2);}\n// ??????\nconst Point crosspoint(const Line& l1, const Line& l2) {\n  assert(intersect(l1, l2));\n  if(parallel(l1, l2)) return l1.initial;                   // ???????????¨???l1????§?????????????\n  double A = cross(l1.terminal - l1.initial, l2.terminal - l2.initial);\n  double B = cross(l1.terminal - l1.initial, l1.terminal - l2.initial);\n  return l2.initial + B / A * (l2.terminal - l2.initial);\n}\nconst Point crosspoint(const Segment& s, const Line& l) {\n  assert(intersect(s, l));\n  if(parallel(s, l)) return s.initial;\n  Point cp = crosspoint(Line(s), l);\n  assert(intersect(s, cp));\n  return cp;\n}\nconst Point crosspoint(const Line& l, const Segment& s) {return crosspoint(s, l);}\nconst Point crosspoint(const Segment& s1, const Segment& s2) {\n  assert(intersect(s1, s2));\n  if(parallel(s1, s2)) {                                    // ???????????¨?????????????????????????????????\n    if(intersect(s1.initial,  s2)) return s1.initial;\n    if(intersect(s1.terminal, s2)) return s1.terminal;\n    if(intersect(s2.initial,  s1)) return s2.initial;\n    if(intersect(s2.terminal, s1)) return s2.terminal;\n  }\n  return crosspoint(Line(s1), Line(s2));\n}\n// ???????????°??¨\n#include<bits/stdc++.h>\nusing namespace std;\nostream& operator<<(ostream& os, const Point& p) {os<<\"point: \"; os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; return os;}\nostream& operator<<(ostream& os, const Segment& s) {os<<\"segment: \"; os<<s.initial<<\" - \"<<s.terminal; return os;}\nostream& operator<<(ostream& os, const Line& l) {os<<\"line: \"; os<<l.initial<<\" - \"<<l.terminal; return os;}\n////////////////////////////////////////////////////////////////////////////////\n// ????§???¢\n//   ????????????????????°????????????????????¢???????´????edge(void)???O(????????°)???edge().begin()????????£????????????????????????????????????????????????\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<utility>\nclass Polygon {\npublic:\n  // ??¨???\n  void add(const Point& p);\n  void clear();\n  // ?????±\n  int size() const;\n  Point vertex(const int n) const;\n  Segment edge(const int n) const;\n  const std::vector<Point>& vertex() const;\n  const std::vector<Segment>& edge() const;\n  // ??????\n  bool touch(const Point& p) const;\n  bool intersect(const Point& p) const;\n  double area() const;\n  bool convex() const;\n  // ???????§???¢\n  const Polygon convex_hull() const;\n  double convex_diameter() const;\n  const Polygon convex_cut(const Line& l) const;\nprivate:\n  std::vector<Point> vertex_;\n  std::vector<Segment> edge_;\n};\n// ??¨???\nvoid Polygon::add(const Point& p) {\n  if(!vertex_.empty()) {\n    if(!edge_.empty()) edge_.pop_back();\n    edge_.push_back(Segment(vertex_.back(), p));\n    edge_.push_back(Segment(p, vertex_.front()));\n  }\n  vertex_.push_back(p);\n}\nvoid Polygon::clear() {\n  vertex_.clear();\n  edge_.clear();\n};\n// ?????±\nint Polygon::size() const {return vertex_.size();}\nPoint Polygon::vertex(const int n) const {return vertex_.at(n);}\nSegment Polygon::edge(const int n) const {return edge_.at(n);}\nconst std::vector<Point>& Polygon::vertex() const {return vertex_;}\nconst std::vector<Segment>& Polygon::edge() const {return edge_;}\n// ??????\nbool Polygon::touch(const Point& p) const {\n  return std::any_of(std::begin(edge()), std::end(edge()), [=](const Segment& s) {return ccw(s.initial, s.terminal, p) == ON_SEGMENT;});\n}\nbool Polygon::intersect(const Point& p) const {\n  bool in = false;                    // p=(x,y)??????(INF,y)???????????´?????¨????§???¢??¨????????????????????° mod 2\n  for(const auto& e: edge()) {\n    if(::intersect(p, e)) return true;\n    Point a = e.initial  - p;\n    Point b = e.terminal - p;\n    if(a.y > b.y) std::swap(a, b);\n    if(a.y < EPS && EPS <= b.y && cross(a, b) < EPS) in = !in;\n  }\n  return in;\n}\ndouble Polygon::area() const {\n  return std::abs(std::accumulate(std::begin(edge()), std::end(edge()), 0.0, [=](const double sum, const Segment& e){return sum + cross(e.initial, e.terminal);})) / 2.0;\n}\nbool Polygon::convex() const {\n  bool positive = false;\n  bool negative = false;\n  for(int i = 0; i < size(); ++i) {\n    auto position = ccw(vertex(i), vertex((i + 1) % size()), vertex((i + 2) % size()));\n    positive |= position == CLOCKWISE;\n    negative |= position == COUNTER_CLOCKWISE;\n    if(negative && positive) return false;\n  }\n  return true;\n}\n// ??????\n// Andrew's Monotone Chain\nconst Polygon Polygon::convex_hull() const {\n  auto original = vertex();\n  std::sort(std::begin(original), std::end(original));\n  original.insert(std::end(original), original.rbegin() + 1, original.rend());\n  std::vector<Point> point;\n  for(const auto& p: original) {\n    while(point.size() >= 2 && ccw(point[point.size() - 2], point.back(), p) == CLOCKWISE) point.pop_back();\n    point.push_back(p);\n  }\n  Polygon convex_hull;\n  point.pop_back();\n  for(const auto& p: point) convex_hull.add(p);\n  return convex_hull;\n}\n// Rotating calipers\ndouble Polygon::convex_diameter() const {\n  auto point = vertex();\n  int p, q, start_p, start_q, max_p, max_q;\n  p = start_p = max_p = std::min_element(std::begin(point), std::end(point)) - std::begin(point);\n  q = start_q = max_q = std::max_element(std::begin(point), std::end(point)) - std::begin(point);\n  double max_d = norm(vertex(p) - vertex(q));\n  do {\n    if(cross(vertex((p + 1) % size()) - vertex(p), vertex((q + 1) % size()) - vertex(q)) >= 0) q = (q + 1) % size();\n    else p = (p + 1) % size();\n    if(norm(vertex(p) - vertex(q)) > max_d) {\n      max_d = norm(vertex(p) - vertex(q));\n      max_p = p;\n      max_q = q;\n    }\n  } while(start_p != q || start_q != p);\n  return std::sqrt(max_d);\n}\nconst Polygon Polygon::convex_cut(const Line& l) const {\n  Polygon result;\n  for(const auto& e: edge()) {\n    if(ccw(l.initial, l.terminal, e.initial) == COUNTER_CLOCKWISE) result.add(e.initial);\n    if(::intersect(e, l)) result.add(crosspoint(e, l));\n  }\n  return result;\n}\n////////////////////////////////////////////////////////////////////////////////\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  // Points/Vectors\n//   Point p1, p2;\n//   cin >> p1.x >> p1.y >> p2.x >> p2.y;\n//   int q;\n//   for(cin >> q; q > 0; --q) {\n//     int x, y;\n//     cin >> x >> y;\n    // A\n//     Point p = projection(Line(p1, p2), Point(x, y));\n//     cout << setprecision(10) << fixed << p.x << \" \" << p.y << endl;\n    // B\n//     Point p = reflection(Line(p1, p2), Point(x, y));\n//     cout << setprecision(10) << fixed << p.x << \" \" << p.y << endl;\n    // C\n//     switch(ccw(p1, p2, Point(x, y))) {\n//     case COUNTER_CLOCKWISE:\n//       cout << \"COUNTER_CLOCKWISE\" << endl;\n//       break;\n//     case CLOCKWISE:\n//       cout << \"CLOCKWISE\" << endl;\n//       break;\n//     case ONLINE_BACK:\n//       cout << \"ONLINE_BACK\" << endl;\n//       break;\n//     case ONLINE_FRONT:\n//       cout << \"ONLINE_FRONT\" << endl;\n//       break;\n//     case ON_SEGMENT:\n//       cout << \"ON_SEGMENT\" << endl;\n//       break;\n//     }\n//   }\n\n  // Segments/Lines\n//   int n;\n//   for(cin >> n; n > 0; --n) {\n//     int a, b, c, d, e, f, g, h;\n//     cin >> a >> b >> c >> d >> e >> f >> g >> h;\n//     Segment s(Point(a, b), Point(c, d));\n//     Segment t(Point(e, f), Point(g, h));\n//     // A\n// //     cout << (parallel(s, t) ? 2 : (orthogonal(s, t) ? 1 : 0)) << endl;\n//     // B\n// //     cout << (intersect(s, t) ? 1 : 0) << endl;\n//     // C\n// //     auto cp = crosspoint(s, t);\n// //     cout << setprecision(10) << fixed << cp.x << \" \" << cp.y << endl;\n//     // D\n// //     cout << setprecision(10) << fixed << distance(s, t) << endl;\n//   }\n\n  // Polygon\n//   int n;\n//   Polygon polygon;\n//   for(cin >> n; n > 0; --n) {\n//     int x, y;\n//     cin >> x >> y;\n//     polygon.add(Point(x, y));\n//   }\n//   // A\n// //   cout << setprecision(1) << fixed  << polygon.area() << endl;\n//   // B\n// //   cout << (polygon.convex() ? 1 : 0) << endl;\n//   // C\n//   int q;\n//   for(cin >> q; q > 0; --q) {\n//     int x, y;\n//     cin >> x >> y;\n//     Point p(x, y);\n//     cout << (polygon.touch(p) ? 1 : (polygon.intersect(p) ? 2 : 0)) << endl;\n//   }\n\n  // Convex Polygon\n  int n;\n  Polygon polygon;\n  for(cin >> n; n > 0; --n) {\n    double x, y;\n    cin >> x >> y;\n    polygon.add(Point(x, y));\n  }\n  // A\n//   auto convex_hull = polygon.convex_hull();\n//   cout << convex_hull.size() << endl;\n//   for(auto v: convex_hull.vertex()) cout << v.x << \" \" << v.y << endl;\n  // B\n  cout << setprecision(10) << fixed << polygon.convex_diameter() << endl;\n  // C\n//   for(cin >> n; n > 0; --n) {\n//     double x1, y1, x2, y2;\n//     cin >> x1 >> y1 >> x2 >> y2;\n//     cout << setprecision(10) << fixed << polygon.convex_cut(Line(x1, y1, x2, y2)).area() << endl;\n//   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n//-------------------------------------------------------------------------------------\n/*線分にたいして点(px,py)が垂線をおろすことができればtrue*/\n\nbool perpendicular_to_the_line_segment_from_the_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    //if(!is_not_parallel)return false;\n    if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n        //cout<<\"a \";\n        return true;\n    }else{//(v_x,v_y)は線分の外にある\n        return false;\n    }\n    \n    \n}\n\n\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*凸包の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n        //two_dimensional_qsort(p_xy, 0, n-1, 1);\n\n        \n        double max_l = diameter_of_the_polygon(n, p_xy);\n        \n        \n\n        cout<<fixed<<setprecision(12)<< max_l<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\ntypedef db T;\nconst db eps = 1e-8;\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n    T x,y;\n    P(){} P(T x,T y):x(x),y(y){}\n    void read(){scanf(\"%lf%lf\",&x,&y);}\n    P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n    P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n    T operator * (const P&b) const {return x*b.x+y*b.y;}\n    P operator * (const T&k) const {return P(x*k,y*k);}\n    T operator ^ (const P&b) const {return x*b.y-y*b.x;}\n    bool operator < (const P&b) const {return sgn(y-b.y)?y<b.y:x<b.x;}\n};\ndb abs(P a){return sqrt(a*a);}\ntypedef vector<P> polygon;\nT diameter(polygon A) {\n    int n=sz(A);if(n <= 1) return 0;\n    int l=0,r=0;rep(i,1,n) (A[i]<A[l])&&(l=i),(A[r]<A[i])&&(r=i);\n    db res=abs(A[l]-A[r]);int i=l,j=r;\n    do (++(((A[(j+1)%n]-A[i])^(A[(j+1)%n]-A[j]))>=0?j:i))%=n ,\n        res=max(res,abs(A[i]-A[j]));\n    while(i!=l||j!=r);\n    return res;\n}\n\nint main(){\n    int n;scanf(\"%d\",&n);\n    polygon A;\n    rep(i,0,n){\n        P p;p.read();\n        A.pb(p);\n    }\n    printf(\"%.10f\\n\",diameter(A));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\t//return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\treturn imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n}\nP pin(){\n\tdouble x,y;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool inconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint contain(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n  int main(){\n\tint n;\n\tcin>>n;\n\tG g(n);\n\tPIN(&g[0],n);\n\tprintf(\"%.9f\\n\",convex_diameter(g));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tR res=0.0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(!cmp_x(pol[i],pol[k]))i=k;\n\t\tif(cmp_x(pol[j],pol[k]))j=k;\n\t}\n\t\n\tint si=i,sj=j;\n\twhile(i!=sj||j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse \n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t\t\t\t\t\t\t\t\t\t\t //return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t}\n\tbool operator==(const Point &p)const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\t//Vector????????¢\n\tPoint rotate(double rad) { return Point(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nusing Vector = Point;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point(1, 1)) :p1(p1), p2(p2) {}\n\tVector vec() { return p2 - p1; }\n};\nusing Line = Segment;\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool in_field(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance_LP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance_SP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance_LP(s, p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance_SP(s1, s2.p1), get_distance_SP(s1, s2.p2)),\n\t\tmin(get_distance_SP(s2, s1.p1), get_distance_SP(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance_LP(l, c.c) <= c.r; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point getCrossPointLL(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\nsigned main() {\n\tcout << fixed << setprecision(8);\n\tint n; cin >> n;\n\tPolygon P(n);\n\trep(i, 0, n) cin >> P[i];\n\tcout << diameter(P) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> //std==c++14\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a,b) ( fabs(a-b) < EPS )\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intersect Circle and Circle\nstatic const int ICC_SEPARATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct point{\n\tdouble x,y;\n\t//construct\n\tpoint() {} \n\tpoint(double x,double y):x(x),y(y){}\n\t//演算子\n\tpoint operator + (point p) { return point(x+p.x,y+p.y); }\n\tpoint operator - (point p) { return point(x-p.x,y-p.y); }\n\tpoint operator * (double k) { return point(x*k,y*k); }\n\tpoint operator / (double k) { return point(x/k,y/k); }\n\tpoint operator / (point p) { return point( (x*p.x + y*p.y)/p.norm()  , (-x*p.y + y*p.x)/p.norm() ) ; }\n\tbool operator < (point p) { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (point p) { return equals(x,p.x) && equals(y,p.y) ; }\n\t//function\n\tdouble arg() { return atan2(y,x) ; }\n\tdouble norm(){return x*x+y*y; }\n\tdouble abs() { return sqrt(norm() ) ;}\n\tdouble dot(point p) { return p.x*x + p.y*y; }\n\tdouble cross(point p) { return x*p.y - y*p.x; }\n\n\t//input output\n\tvoid input(){cin>>x>>y;}\n\tvoid polar(double r,double theta){ x = r*cos(theta), y= r*sin(theta) ; }\n\tvoid print(){cout<<x<<' '<<y<<endl;};\n\n};\n\nbool sort_x(point a,point b){\n\treturn a.x!=b.x?a.x<b.x:a.y<b.y ;\n}\nbool sort_y(point a,point b){\n\treturn a.y!=b.y?a.y<b.y:a.x<b.x ;\n}\n\ntypedef vector<point> polygon;\n\nstruct segment{\n\tpoint s,t;\n\tsegment() {}\n\tsegment(point s,point t) : s(s),t(t){}\n\tvoid input(){s.input(),t.input(); }\n};\ntypedef segment line;\n\nstruct circle{\n\tpoint c;\n\tdouble r;\n\tcircle() {}\n\tcircle(point c,double r) : c(c),r(r){}\n\n};\n\ndouble norm(point a){\treturn a.norm(); }\ndouble abs(point a){ return a.abs(); }\ndouble arg(point a){ return a.arg(); }\ndouble dot(point a,point b) { return a.x*b.x + a.y*b.y ; }\ndouble cross(point a,point b) { return a.x * b.y - a.y * b.x ; }\npoint polar(double r,double theta){ point a; a.polar(r,theta); return a; }\npoint orth(point p){ return point(-p.y,p.x); }\n\n//isOrthgonal 垂直\nbool isOrthogonal(point a,point b) { return equals(dot(a,b), 0.0 ) ; }\nbool isOrthogonal(point a,point b,point c,point d) { return isOrthogonal(a-b,c-d) ; }\nbool isOrthogonal(line l1,line l2 ){ return isOrthogonal(l1.t-l1.s,l2.t-l2.s); }\n//isParallel 平行\nbool isParallel(point a,point b) { return equals(cross(a,b), 0.0) ; }\nbool isParallel(point a,point b,point c,point d) { return isParallel(a-b,c-d); }\nbool isParallel(line l1,line l2) { return isParallel(l1.t-l1.s,l2.t-l2.s) ; }\n\npoint project(line l,point p){\n\tpoint base = l.t-l.s;\n\tdouble r = dot(p-l.s,base) / norm(base) ;\n\treturn l.s + base*r;\n}\npoint reflect(line l,point p){\n\treturn p + (project(l,p) - p) *2.0;\n}\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\n\tif(cross(a,b) > EPS ) return CCW_COUNTER_CLOCKWISE ;\n\tif(cross(a,b) < -EPS ) return CCW_CLOCKWISE;\n\tif(dot(a,b) < -EPS ) return CCW_ONLINE_BACK;\n\tif(a.norm() < b.norm() ) return CCW_ONLINE_FRONT;\n\treturn CCW_ON_SEGMENT;\n}\n\n\n//intersect\nbool intersect(point p1,point p2,point p3,point p4){return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 ) ; }\nbool intersect(line l1,line l2) { return intersect(l1.s,l1.t,l2.s,l2.t) ; }\nbool intersect(polygon p,line l){\n\tint n = p.size();\n\tfor(int i=0;i<n;i++)  if(intersect(line(p[i],p[(i+1)%n] ) , l ) ) return true;\n\treturn false;\n}\nint intersect(circle c1,circle c2){\n\tif(c1.r < c2.r) swap(c1,c2);\n\tdouble d = abs(c1.c-c2.c);\n\tdouble r = c1.r + c2.r;\n\tif(equals(d,r) ) return ICC_CIRCUMSCRIBE;\n\tif(d > r ) return ICC_SEPARATE;\n\tif(equals(d+c2.r,c1.r) ) return ICC_INSCRIBE;\n\tif( d + c2.r < c1.r ) return ICC_CONTAIN;\n\treturn ICC_INTERSECT;\n}\n\n//bool intersectsc(line l,circle c){ return distancesp(l,c.c) <= c.r ; } distanceののち\nint intersectcs(circle c,line l ){// 0\t\t1\t\t2\n\tif(norm(project(l,c.c) - c.c )  - c.r*c.r  > EPS ) return 0;\n\tdouble d1 = abs(c.c-l.s),d2  = abs(c.c-l.t);\n\tif(d1 < c.r + EPS && d2 < c.r + EPS ) return 0;\n\tif( (d1<c.r - EPS && d2 > c.r +EPS) || (d1 > c.r +EPS &&d2 < c.r -EPS ) ) return 1;\n\tpoint h = project(l,c.c) ;\n\tif(dot(l.s-h,l.t-h) < 0 ) return 2;\n\treturn 0;\n}\n\n//distance\n//line point\ndouble distancelp(line l,point p){ return abs(cross(l.t-l.s,p-l.s)/ abs(l.t-l.s)  ); }\n//segment point\ndouble distancesp(line l,point p){ \n\tif(dot(l.t-l.s,p-l.s) < 0.0 ) return abs(p-l.s);\n\tif(dot(l.s-l.t,p-l.t) < 0.0 ) return abs(p-l.t);\n\treturn distancelp(l,p);\n}\n//segment segment \ndouble distancess(line l1,line l2){\n\tif(intersect(l1,l2) ) return 0.0;\n\treturn min( min(distancesp(l1,l2.s) ,distancesp(l1,l2.t) ) , min(distancesp(l2,l1.s),distancesp(l2,l1.t)  ) );\n}\n\nbool intersectsc(line l,circle c){ return distancesp(l,c.c) <= c.r ; }\n\n//crosspoint \n//segment segment\npoint crosspointss(line l1,line l2){\n\tfor(int k=0;k<2;k++){\n\t\tif(distancesp(l1,l2.s) < EPS ) return l2.s;\n\t\tif(distancesp(l1,l2.t) < EPS ) return l2.t;\n\t\tswap(l1,l2);\n\t}\n\tpoint base = l2.t-l2.s;\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.t-l2.s) );\n\tdouble t = d1/(d1+d2);\n\treturn l1.s + (l1.t-l1.s) * t;\n}\n//line line\npoint crosspointll(line l1,line l2){\n\tdouble a = cross(l1.t-l1.s,l2.t-l2.s);\n\tdouble b = cross(l1.t-l1.s,l1.t-l2.s);\n\tif(abs(a) < EPS && abs(b) < EPS ) return l2.s;\n\treturn l2.s + (l2.t-l2.s) * (b/a) ;\n}\n//circle line\npolygon crosspointCL(circle c,line l){\n\tpolygon ps;\n\tpoint pr = project(l,c.c);\n\tpoint e = (l.t - l.s) / abs(l.t-l.s) ;\n\tif(distancelp(l,c.c) > c.r ) return ps;//付け足した\n\tif(equals(distancelp(l,c.c),c.r) ){\n\t\tps.emplace_back(pr);\n\t}\n\tdouble base = sqrt(c.r*c.r - norm(pr-c.c) );\n\tps.emplace_back(pr + e*base ) ;\n\tps.emplace_back(pr - e*base ) ;\n\treturn ps;\n}\n//circle segment\npolygon crosspointCS(circle c,line l ){\n\tpolygon res = crosspointCL(c,l);\n\tif(intersectcs(c,l) == 2 ) return res;\n\tif(res.size() > 1u ){//一つのみ削る\n\t\tif(dot(l.s-res[0] ,l.t-res[0] ) > 0) swap(res[0],res[1] );\n\t\tres.pop_back();\n\t}\n\treturn res;\n}\npolygon crosspointcc(circle c1,circle c2){\n\tpolygon p(2);\n\tdouble d = abs(c1.c-c2.c);\n\tdouble a = acos( (c1.r *c1.r + d*d -c2.r*c2.r) /(2*c1.r*d ) );\n\tdouble t = arg(c2.c-c1.c);\n\tp[0] = c1.c + polar(c1.r,t+a);\n\tp[1] = c1.c + polar(c1.r,t-a);\n\treturn p;\n}\n\nint contains(polygon g,point p) { //IN:2 ON:1 OUT:0\n    int n = g.size();\n    bool f = false;\n    for(int i=0;i<n;i++){\n\tpoint a = g[i] - p,b = g[(i+1)%n] - p;\n\tif( fabs(cross(a,b) ) < EPS && dot(a,b) < EPS) return 1;\n\tif( a.y > b.y ) swap(a,b);\n\tif( a.y < EPS && EPS < b.y && cross(a,b) > EPS ) f = !f;\n    }\n    return (f?2:0) ;\n}\n\npolygon andrewscan(polygon &s){ //convex hull\n\tpolygon u,l;\n\tif(s.size() < 3) return s;\n\t//sort(s.begin(),s.end() );\n\t//最も左で最も右の点にする\n\tsort(s.begin(),s.end(),sort_y);\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\tfor(int i=2;i<s.size();i++){\n\t\t//for(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CCW_CLOCKWISE;n--)//凸包の辺上を含めない\n\t\tfor(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) == CCW_COUNTER_CLOCKWISE;n--)//凸包の辺上を含める場合\n\t\tu.pop_back();\n\t\tu.push_back(s[i]);\n\t}\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CCW_CLOCKWISE;n--)//凸包の辺上を含めない\t\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) == CCW_COUNTER_CLOCKWISE;n--)//凸包の辺上を含める場合\n\t\tl.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n\t//最も左で最も右の点にする\n\t/*point mini = l[0];\n\tint base = 0;\n\tfor(int i=0;i<l.size();i++)\n\t    if(mini.y > l[i].y || (mini.y==l[i].y && mini.x > l[i].x ) ){\n\t\t\tmini = l[i];\n\t\t\tbase = i;\n\t    }\n\tpolygon res;\n\tfor(int i=0;i<l.size();i++)res.push_back( l[(i+base)%l.size()] );\n\treturn res;*/\n}\n\ndouble diameter(polygon &s){\n\tpolygon p = s;\n\tint n = p.size();\n\tif(n==2) return abs(p[0]-p[1]);\n\tint i=0,j=0;\n\tfor(int k=0;k<n;k++){\n\t\tif(p[i] < p[k]) i = k;\n\t\tif(!(p[j]<p[k]) ) j = k;\n\t}\n\tdouble res = 0;\n\tint si = i,sj = j;\n\twhile( i != sj || j != si ){\n\t\tres = max(res,abs(p[i]-p[j]) );\n\t\tif(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j] ) < 0.0) i = (i+1)%n;\n\t\telse j = (j+1)%n;\n\t}\n\treturn res;\n}\nbool isconvex(polygon p){\n\tbool f = 1;\n\tint n = p.size();\n\tfor(int i=0;i<n;i++){\n\t\tint t = ccw(p[(i+n-1)%n],p[i],p[(i+1)%n] );\n\t\tf&= t!=CCW_CLOCKWISE;\n\t}\n\treturn f;\n}\ndouble area(polygon p){\n\tdouble res =  0.0;\n\tfor(int i=0;i<p.size();i++) res += cross(p[i],p[ (i+1)%p.size() ]);\n\treturn res/2.0;\n}\ndouble area(circle c1,circle c2){\n\tdouble d = abs(c1.c-c2.c);\n\tif(c1.r + c2.r <= d + EPS ) return 0.0;\n\tif(d<=abs(c1.r-c2.r) ){\n\t\tdouble r = min(c1.r,c2.r);\n\t\treturn PI*r*r;\n\t}\n\tdouble rc = (d*d + c1.r*c1.r -c2.r*c2.r)/(2*d);\n\tdouble th = acos(rc/c1.r);\n\tdouble ph = acos( (d-rc)/c2.r);\n\treturn c1.r*c1.r*th + c2.r*c2.r*ph - d * c1.r * sin(th) ;\n}\n\npolygon convex_cut(polygon p,line l){\n\tpolygon q;\n\tint n = p.size();\n\tfor(int i=0;i<n;i++){\n\t\tpoint a = p[i] , b = p[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a) != -1 ) q.push_back(a);\n\t\tif(ccw(l.s,l.t,a) * ccw(l.s,l.t,b) < 0) q.push_back(crosspointss(line(a,b),l) );\n\t}\n\treturn q;\n}\nint main(){\n    \tint n;\n\tcin>>n;\n    \tpolygon p(n);\n\tfor(int i=0;i<n;i++)p[i].input();\n\tprintf(\"%0.10lf\\n\",diameter(p) );\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\ntypedef complex<double> C;\ntypedef pair<C,C> pp;\ntypedef vector<C> VP;\ntypedef vector<pp> VPP;\n#define eq(a,b) (fabs(a-b)<eps)\n#define veq(a,b) (eq(a.real(),b.real())&&eq(a.imag(),b.imag()))\nconst C O{0,0};\n\nvoid In(C& p){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp=C(x,y);\n}\n\nvoid Out(C p){\n\tcout<<(int)p.real()<<' '<<(int)p.imag()<<endl;\n}\n\ndouble Dot(C p,C q){\n\treturn p.real()*q.real()+p.imag()*q.imag();\n}\n\ndouble Det(C p,C q){\n\treturn p.real()*q.imag()-q.real()*p.imag();\n}\n\ndouble Diameter(VP p){\n\tint n=p.size(),I=0,J=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(p[i].imag()>p[I].imag()) I=i;\n\t\tif(p[i].imag()<p[J].imag()) J=i;\n\t}\n\tdouble res=abs(p[I]-p[J]);\n\tint i=I,j=J;\n\tdo{\n\t\tif(Det(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])>0) j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(p[i]-p[j])>res) res=abs(p[i]-p[j]);\n\t}while(i!=I||j!=J);\n\treturn res;\n}\n\nint n,q;\nVP a;\nC x;\n\nint main(){\n\tcin>>n;\n\ta=VP(n);\n\tfor(auto &i:a) In(i);\n\tcout<<syosu(9)<<Diameter(a)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nconst db eps = 1e-9;\nint sgn(db a, db b = 0) {\n\ta -= b;\n\treturn (a > eps) - (a < -eps);\n}\n\nstruct poi {\n\tdb x, y;\n\tpoi operator -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tbool operator <(poi p) const {\n\t\treturn tie(x, y) < tie(p.x, p.y);\n\t}\n\tdb cross(poi p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb len() {\n\t\treturn sqrt(x * x + y * y);\n\t}\n};\ndb xmul(poi a, poi b, poi c) {\n\treturn (b - a).cross(c - a);\n}\n\nusing vp = vector <poi>;\nvp convex(vp v) {\n\tsort(v.begin(), v.end()); vp r;\n\tfor(int i = 0; i < v.size(); i ++) {\n\t\twhile(r.size() > 1 &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tr.push_back(v[i]);\n\t}\n\tint d = r.size();\n\tfor(int i = (int)v.size() - 2; i >= 0; i --) {\n\t\twhile(r.size() > d &&\n\t\t\tsgn(xmul(*++r.rbegin(), v[i], *r.rbegin())) >= 0)\n\t\t\tr.pop_back();\n\t\tif(i != 0) r.push_back(v[i]);\n\t}\n\treturn r;\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(false);\n\tint n; cin >> n; vp v;\n\tfor(int i = 0; i < n; i ++) {\n\t\tdb x, y; cin >> x >> y;\n\t\tv.push_back({x, y});\n\t}\n\tv = convex(v);\n\n\tn = v.size();\n\n\t{\n\t\tdb ans = 0;\n\t\tauto upd = [&](int i, int j) {\n\t\t\tdb t = (v[i] - v[j]).len();\n\t\t\tif(t > ans) ans = t;\n\t\t};\n\t\tint j = 0;\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\twhile(sgn(xmul(v[i], v[(i + 1) % n], v[j]),\n\t\t\t\txmul(v[i], v[(i + 1) % n], v[(j + 1) % n])) < 0)\n\t\t\t\tj = (j + 1) % n;\n\t\t\t//cout << i << ' ' << j << '\\n';\n\t\t\tupd(i, j); upd((i + 1) % n, j);\n\t\t\tupd(i, (j + 1) % n); upd((i + 1) % n, (j + 1) % n);\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\n\nVector spin(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+spin(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+spin(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+spin(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end());\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=convex_hull(s);\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  //cout<<i<<\" \"<<j<<endl;\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    //cout<<i<<\" \"<<j<<endl;\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double inf = 1e20;\nconst double eps = 1e-8;\nconst int N = 2e5 + 100;\nint sgn (double x) {\n    if (fabs (x) < eps) return 0;\n    if (x < 0) return -1;\n    return 1;\n}\nstruct point {\n    double x, y;\n    point () {}\n    point (double _x, double _y) {\n        x = _x, y = _y;\n    }\n    void input () {\n        scanf (\"%lf %lf\", &x, &y);\n    }\n    point operator - (const point &b) const {\n        return point (x - b.x, y - b.y);\n    }\n    bool operator == (const point &b) const {\n        return sgn (x - b.x) == 0 && sgn (y - b.y) == 0;\n    }\n    bool operator < (const point &b) const {\n        if (sgn (y - b.y) == 0) return x < b.x;\n        return y < b.y;\n    }\n    double operator * (const point &b) const {\n        return x * b.x + y * b.y;\n    }\n    double operator ^ (const point &b) const {\n        return x * b.y - y * b.x;\n    }\n    double cross (point a, point b) {\n        return (point (a - *this) ^ point (b - *this));\n    }\n    double hot (point a, point b) {\n        return (point (a - *this) * point (b - *this));\n    }\n    double len () {\n        return hypot (x, y);\n    }\n};\nstruct polygon {\n    int n;\n    point ps[N];\n    void input () {\n        cin >> n;\n        for (int i = 0; i < n; i++) ps[i].input ();\n    }\n    void getconvex (polygon &convex) {\n        sort (ps, ps + n);\n        int &top = convex.n;\n        top = 0;\n        convex.ps[top++] = ps[0];\n        for (int i = 1; i < n; i++) {\n            while (top >= 2 && convex.ps[top - 2].cross (convex.ps[top - 1], ps[i]) < 0) top--;\n            convex.ps[top++] = ps[i];\n        }\n        int t = 0;\n        for (int i = n - 2; i >= 0; i--) {\n            while (t && convex.ps[top - 2].cross (convex.ps[top - 1], ps[i]) < 0) top--, t--;\n            if (!i) break;\n            convex.ps[top++] = ps[i];\n            t++;\n        }\n    }\n} s;\nint main () {\n    double ans = 0;\n    int n;\n    s.input ();\n    n = s.n;\n    s.n *= 2;\n    for (int i = n; i < s.n; i++) s.ps[i] = s.ps[i - n];\n    for (int i = 0; i < n / 2 + 1; i++) {\n        int l = i + 1, r = i + n;\n        while (l <= r) {\n            int mid = l + r >> 1, flag1, flag2;\n            if (point (s.ps[mid] - s.ps[i]).len () > point (s.ps[mid - 1] - s.ps[i]).len ()) flag1 = 1;\n            else flag1 = 0;\n            if (point (s.ps[mid] - s.ps[i]).len () > point (s.ps[mid + 1] - s.ps[i]).len ()) flag2 = 1;\n            else flag2 = 0;\n            if (flag1 && flag2) {\n                ans = max (ans, point (s.ps[mid] - s.ps[i]).len ());\n                break;\n            } else if (flag1 && !flag2) l = mid + 1;\n            else r = mid - 1;\n        }\n    }\n    printf (\"%.12f\\n\" ,ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool cmp_y(const P &a, const P &b){\n\t\treturn a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\t\t\t\t\t\t\t\t  // a--c--b on line\n}\n\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\n// polygon\ntypedef vector<P> G;\n\nP extreme(const vector<P> &po, const L &l) {\n  int k = 0;\n  for (int i = 1; i < po.size(); ++i)\n    if (dot(po[i], l[1]-l[0]) > dot(po[k], l[1]-l[0])) k = i;\n  return po[k];\n}\n\nenum { OUT, ON, IN };\nint contains(const G& po, const P& p) {\n  bool in = false;\n  for (int i = 0; i < po.size(); ++i) {\n  \tP a = po[i] - p, b = po[(i+1)%po.size()] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\ndouble area2(const G& po) {\n\tdouble A = 0;\n  \tfor (int i = 0; i < po.size(); ++i) \n    \tA += cross(po[i], po[(i+1)%po.size()]);\n\t//????????????????????????????????¨????????????\n  \treturn A/2;\n}\n\nbool isconvex(const G &p) {\n\tint n = p.size();\n\tif(cross(p[0]-p[n-1],p[n-2]-p[n-1]) < 0) return false;\n\tfor(int i = 1; i < n-1; ++i) {\n\t\tif(cross(p[i+1]-p[i],p[i-1]-p[i]) < 0) return false;\n\t}\n\treturn true;\n\n}\n\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end(), cmp_y);\n  G r(2*n);\n  for(int i = 0; i < n; i++){\n    while(k>1 && cross(r[k-1]-r[k-2],ps[i]-r[k-2]) < -EPS)k--;\n    r[k++] = ps[i];\n  }\n  for(int i = n-2, t = k; i >= 0; i--){\n    while(k>t && cross(r[k-1]-r[k-2],ps[i]-r[k-2]) < -EPS)k--;\n    r[k++] = ps[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\n// caliper\ndouble convex_diameter(const G &pt) {\n\tconst int n = pt.size();\n\tif(n <= 1) return 0;\n\tif(n == 2) return abs(pt[0]-pt[1]);\n\t\n\tint i = 0, j = 0;\n\tfor(int k = 0; k < n; ++k){\n\t\tif(!(pt[i] < pt[k])) i = k;\n\t\tif(pt[j] < pt[k]) j = k;\n\t}\n   \n\tdouble res = 0;\n\tint si = i, sj = j;\n\twhile(i != sj || j != si) {\n\t\tres = max(res, abs(pt[i]-pt[j]));\n\t\tif(cross(pt[(i+1)%n]-pt[i],pt[(j+1)%n]-pt[j]) < 0) i = (i+1)%n;\n\t\telse j = (j+1)%n;\n\t}\n\treturn res;\n}\n\t\nint main() {\n\tint n;\n\tcin >> n;\n\tG po;\n\tfor(int i=0; i<n; ++i) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP p(x, y);\n\t\tpo.push_back(p);\n\t}\n\tcout << fixed << setprecision(15) << convex_diameter(po) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\ntypedef vector<P> Polygon;\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// ??????\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\n// ????¬?????????????2??????\ndouble norm(const P& a) {\n    return real(conj(a)*a);\n}\n\n// ??????\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\n// ???p2?????????p0, p1???????????´???????°???±?????????\nP projection(const P& p0, const P& p1, const P& p2) {\n    // ???????????????????????´???\n    P vec1 = p1 - p0;\n    P vec2 = p2 - p0;\n    return p0 + vec1 * dot(vec1, vec2) / dot(vec1, vec1);\n}\n\n// projection?????\\??¨???\n// not verified\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\n// ???p0, p1???????????´??????????§°?????¨????????????p2??¨????§°??????\nP reflection(const P& p0, const P& p1, const P& p2) {\n    P proj = projection(p0, p1, p2);\n    return proj - (p2 - proj);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;                               // a--c--b on line\n}\n\n// 2??´?????????????????????\nbool is_parallel(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    auto res = ccw(p1, p2, P(0,0));\n    return (res == 2 || res == -2 || res == 0);\n}\n\n// 2??´???????????´?????????\nbool is_ortho(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    return dot(p1, p2) == 0;\n}\n\n// l: line(??´???)\n// s: segment(??????)\n// not verified\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\n// not verified\nbool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\n// not verified\nbool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n// not verified\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n// not verified\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\n// not verified\ndouble distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\n// not verified\ndouble distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\ndouble distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n               min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// 2??´????????????\nP crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\n// ????§???¢?????¢???????±???????\n// P???????????¨???????????????\ndouble area(const Polygon& poly) {\n    double area = 0.0;\n    REP(i, SIZE(poly))\n        area += cross(curr(poly, i), next(poly, i));\n    return abs(area) * 0.5;\n}\n\n// ??????????±??????????????????????????????????????????????\n// ????????????????¨?????????§????????????\n// not verified\nPolygon convexHull(const Polygon& poly) {\n    Polygon ps = poly;\n\n    int n = ps.size(), k = 0;\n    sort(ALL(ps));\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// ??????????±????????????????????????????????????????????????????\n// ????????????????¨?????????§????????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\nPolygon convexHullInludingPointsOnEdge(const Polygon& poly) {\n    Polygon ps = poly;\n\n    int n = ps.size(), k = 0;\n    sort(ALL(ps));\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// ?????§??????\n// poly?????????????¨???¨?????§?????????????´?????????????????????¨???????????????\n// ???????????´??????????????¶???????¨±???\nbool isConvex(const Polygon &poly) {\n    REP(i, SIZE(poly)) {\n        if (ccw(prev(poly, i), curr(poly, i), next(poly, i)) == -1)\n            return false;\n    }\n    return true;\n}\n\n// poly????????§???????????¨?????????\n// 0: OUT\n// 1: ON\n// 2: IN\n// not verified\nenum { OUT, ON, IN };\nint convexContains(const Polygon &poly, const P &p) {\n    const int n = poly.size();\n    P g = (poly[0] + poly[n/3] + poly[2*n/3]) / 3.0; // inner-P\n    int a = 0, b = n;\n    while (a+1 < b) { // invariant: c is in fan g-poly[a]-poly[b]\n        int c = (a + b) / 2;\n        if (cross(poly[a]-g, poly[c]-g) > 0) { // angle < 180 deg\n            if (cross(poly[a]-g, p-g) > 0 && cross(poly[c]-g, p-g) < 0) b = c;\n            else                                                  a = c;\n        } else {\n            if (cross(poly[a]-g, p-g) < 0 && cross(poly[c]-g, p-g) > 0) a = c;\n            else                                                  b = c;\n        }\n    }\n    b %= n;\n    if (cross(poly[a] - p, poly[b] - p) < 0) return OUT;\n    if (cross(poly[a] - p, poly[b] - p) > 0) return IN;\n    return ON;\n}\n\n// poly????????§???????????????\n// 0: OUT\n// 1: ON\n// 2: IN\nint contains(const Polygon& poly, const P& p) {\n    bool in = false;\n    REP(i, SIZE(poly)) {\n        P a = curr(poly,i) - p, b = next(poly,i) - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b))\n            if (cross(a, b) < 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n\n// ????§???¢?????´?????????2???????????????\n// ??\\????????????????????§?????????????????????\ndouble convexDiameterSquared(const Polygon &poly) {\n    const int n = poly.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(poly[i]) > imag(poly[is])) is = i;\n        if (imag(poly[i]) < imag(poly[js])) js = i;\n    }\n    double maxd = norm(poly[is]-poly[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (cross(diff(poly,i), diff(poly,j)) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (norm(poly[i]-poly[j]) > maxd) {\n            maxd = norm(poly[i]-poly[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd; /* farthest pair is (maxi, maxj). */\n}\n\nint main(){\n    int N;\n    cin >> N;\n    Polygon poly;\n    REP(n, N) {\n        double x, y;\n        cin >> x >> y;\n        poly.pb( P(x,y) );\n    }\n\n    printf(\"%.10lf\\n\", sqrt(convexDiameterSquared(poly)));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\ndouble dis(P a,P b){\n  return sqrt((a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\nint main(){\n  int n;\n  cin>>n;\n  VP v;\n  while(n--){\n    double a,b;\n    cin>>a>>b;\n    v.push_back(P(a,b));\n   }\n   pair<int,int>p=convexDiameter(v);\n   int x=p.first,y=p.second;\n   printf(\"%.10f\",dis(v[x],v[y]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(cpol[i]) > imag(cpol[is])) is = i;\n        if (imag(cpol[i]) < imag(cpol[js])) js = i;\n    }\n    LD maxd = norm(cpol[is]-cpol[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if(norm(cpol[i]-cpol[j]) > maxd) {\n            maxd = norm(cpol[i]-cpol[j]);\n            maxi = i; maxj = j;\n        }\n    } while(i != is || j != js);\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n    pair<int, int> ans = ConvexPolygonDiameter(p);\n    printf(\"%.9Lf\\n\", DistPP(p[ans.first], p[ans.second]));\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\ntypedef long double     lf;\n\nusing namespace std;\n\nconst lf EPS = 1e-9;\nconst lf oo = 1e15;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << int(p.x) << \" \" << int(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf dot( pt A, pt B ) {\n  return x(A)*x(B) + y(A)*y(B);\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nlf distToLine (pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  c = A + u*( B-A );\n  return dist( p , c );\n}\n\npt refPoint(pt X, pt A, pt B) {\n  pt aux; distToLine(X, A, B, aux);\n  return X + lf(2.0)*(aux-X);\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf cross( pt A, pt B ) {\n  return x(A)*y(B) - y(A)*x(B);\n}\n\n///CHANGE\n// 0  for collineal points ( angle = 0 )\n// 1  for angle BAX counter clockwise\n// -1 for angle BAX clockwise\ninline int ccw (pt X, pt A, pt B) {\n  lf c = cross( B-A, X-A );\n  if( same( c, 0.0 ) ) { return 0; }\n  if( c > EPS ) { return 1; }\n  return -1;\n}\n\n///CHANGE\ninline bool segContains ( pt X, pt A, pt B) {\n  if ( !same ( 0, cross ( A-X, B-X ) ) ) return 0;\n  return ( dot ( A-X, B-X ) < EPS );\n}\n\ninline bool parallel( pt A, pt B, pt C, pt D ) {\n  return same ( 0, cross( B-A, D-C ) );\n}\n\n///NEW\ninline bool ortho( pt A, pt B, pt C, pt D ) {\n  return same ( 0, dot( B-A, D-C ) );\n}\n\ninline bool samePt ( pt A, pt B ) {\n  return same ( x(A), x(B) ) && same ( y(A), y(B) );\n}\n\npt linesIntersection ( pt A, pt B, pt C, pt D ) {\n  lf x = cross ( C, D-C ) - cross ( A, D-C );\n  x /= cross ( B-A, D-C );\n  return A + x*(B-A);\n}\n\ninline bool collinearSegsIntersects ( pt A, pt B, pt C, pt D ) {\n  return segContains(A,C,D) || segContains(B,C,D)\n      || segContains(C,A,B) || segContains(D,A,B);\n}\n\nbool segmentsIntersect(pt A, pt B, pt C, pt D) {\n  if( samePt(A,B) )\n    return segContains( A, C, D );\n  if( samePt(C,D) )\n    return segContains( C, A, B );\n  if( parallel(A,B,C,D) )\n    return collinearSegsIntersects( A,B,C,D );\n  pt aux = linesIntersection(A,B,C,D);\n  return segContains(aux,A,B) && segContains(aux,C,D);\n}\n\n///CHANGE\nlf distToSegment(pt p, pt A, pt B, pt &c) {\n  lf u = dot( p-A , B-A ) / norm( B-A );\n  if( u < -EPS ) { c = A; return dist( p , A ); }\n  if( (u-1.0) > EPS ) { c = B; return dist( p, B ); }\n  return distToLine(p,A,B,c);\n}\n\n// P[0] must be equal to P[n]\n// Area is positive if the polygon is ccw\ndouble signedArea(const vector<pt> &P) {\n  double result = 0.0;\n  for(int i = 0; i < (int)P.size()-1; i++) result += cross( P[i],P[i+1] );\n  return result / 2.0;\n}\n\ndouble area(const vector<pt> &P) { return fabs(signedArea(P)); }\n\n///CHANGE\n// P[0] must be equal to P[n]\nbool isConvex( const vector<pt> &P) {\n  int sz = (int) P.size(); if(sz <= 3) return false;\n  bool isL = ccw(P[0], P[1], P[2]) >= 0;\n  for (int i = 1; i < sz-1; i++) {\n    if( ( ccw(P[i], P[i+1], P[(i+2) == sz ? 1 : i+2]) >= 0 ) != isL) return false;\n  }\n  return true;\n}\n\n///CHANGE\n// P[0] must be equal to P[n]     -    O(N)\n// Return 1 for interior, 0 for boundary and -1 for exterior\nint inPolygon(pt X, const vector<pt> &P) {\n  const int n = P.size(); int cnt = 0;\n  for (int i = 0; i < n-1; i++) {\n    if( segContains(X, P[i], P[i+1]) ) return 0;\n    if( y(P[i]) <= y(X) ) {\n      if( y(P[i+1]) > y(X) )\n        if( !(ccw( X, P[i], P[i+1]) >= 0) ) cnt++;\n    }\n    else if ( y(P[i+1]) <= y(X) ) {\n      if( ccw( X, P[i], P[i+1]) >= 0 ) cnt--;\n    }\n  }\n  if(cnt == 0) return -1;\n  else return 1;\n}\n\n///CHANGE\n//CONVEX HULL Monotone Chain O( N Log N )\nbool cmpPt( pt A, pt B ) {\n  if( !same( x(A), x(B) ) ) return x(A) < x(B);\n  return y(A) < y(B);\n}\n\nint turn(pt A, pt B, pt C) {\n  lf r = cross(B-A, C-A);\n  if( same( r, 0.0 ) ) return 0;\n  if( r > EPS ) return 1;\n  return -1;\n}\n\n// Return CH in ccw order starting at leftmost - downmost x\n// Doesn't return P[ n ] = P[ 0 ]\nvector<pt> CH( vector<pt> &P ) {\n  if ( P.size() == 1 ) return P;\n  const int n = P.size();\n  sort ( P.begin(), P.end(), cmpPt );\n  vector<pt> up;\n  up.push_back(P[0]); up.push_back(P[1]);\n  vector<pt> dn;\n  dn.push_back(P[0]); dn.push_back(P[1]);\n  for ( int i = 2; i < n; ++i ) {\n    // If collineal points are not needed, is >= and <=, otherwise > and <\n    while ( up.size() > 1 && turn(up[up.size()-2],up.back(),P[i]) >= 0 )\n      up.pop_back();\n    while ( dn.size() > 1 && turn(dn[dn.size()-2],dn.back(),P[i]) <= 0 )\n      dn.pop_back();\n    up.push_back(P[i]);\n    dn.push_back(P[i]);\n  }\n  for (int i = (int) up.size() - 2; i >= 1; i--) dn.push_back(up[i]);\n  return dn;\n}\n\n/// --------------------------------------------\n\nint n;\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  vector<pt> P(n);\n  pt A(oo,0) , B(-oo,0);\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  int idx;\n  lf ans = -oo;\n  for( int i = 1; i < n; ++i ) {\n    lf d = dist(P[0], P[i]);\n    if( d > ans+EPS || same( d, ans ) ) {\n      idx = i;\n      ans = d;\n    }\n  }\n  lf prv = dist( P[1], P[1] );\n  int sz = int(P.size());\n  for( int i = 1, j = idx; i < idx; ++i ) {\n    while( prv+EPS < dist( P[i], P[j] ) ) {\n      prv = dist( P[i], P[j] );\n      j = (j+1)%sz;\n      ans = max( ans, prv );\n    }\n    j = ((j-1)+sz)%sz;\n  }\n  cout << double(ans) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\nconst int MAX_N = 100005;\n\ndouble add(double a,double b)\n{\n    if(abs(a+b) < EPS * (abs(a) + abs(b))){\n        return 0;\n    }\n    return a + b;\n}\n\nstruct P\n{\n    double x,y;\n    P() {}\n    P(double x,double y) : x(x),y(y) {}\n    P operator + (P p){\n        return P(add(x,p.x),add(y,p.y));\n    }\n    P operator - (P p){\n        return P(add(x,-p.x),add(y,-p.y));\n    }\n    P operator * (double d){\n        return P(x*d,y*d);\n    }\n    double dot(P p){\n        return add(x*p.x,y*p.y);\n    }\n    double det(P p){\n        return add(x*p.y,-y*p.x);\n    }\n};\n\nint n;\nP ps[MAX_N];\n\nbool cmp_x(const P& p,const P& q)\n{\n    if(p.x != q.x){\n        return p.x < q.x;\n    }\n    return p.y < q.y;\n}\n\nvector<P> convex_hull(P* ps,int n)\n{\n    sort(ps,ps+n,cmp_x);\n    int k = 0;\n    vector<P> qs(n*2);\n    rep(i,n){\n        while(k > 1 && (qs[k-1] - qs[k-2]).det(ps[i] - qs[k-1]) <= 0){\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    for(int i = n-2,t=k;i >= 0;i--){\n        while(k > t && (qs[k-1] - qs[k-2]).det(ps[i] - qs[k-1]) <= 0){\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\ndouble dist(P p,P q)\n{\n    return (p-q).dot(p-q);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n){\n        double a,b;\n\t\tscanf(\"%lf%lf\",&a,&b);\n        ps[i] = P(a,b);\n\t}\n    vector<P> qs = convex_hull(ps,n);\n    if(qs.size() == 2){ //???????????°??????????????´???\n        printf(\"%.0f\\n\",dist(qs[0],qs[1]));\n        return 0;\n    }\n    int i = 0,j = 0;\n    rep(k,qs.size()){\n        if(!cmp_x(qs[i],qs[k])){\n            i = k;\n        }\n        if(cmp_x(qs[j],qs[k])){\n            j = k;\n        }\n    }\n    double res = 0;\n    int si = i,sj = j;\n    while(i != sj || j != si){\n        res = max(res,dist(qs[i],qs[j]));\n        if((qs[(i+1) % qs.size()] - qs[i]).det(qs[(j+1) % qs.size()] - qs[j]) < 0){\n            i = (i+1) % qs.size();\n        }else{\n            j = (j+1) % qs.size();\n        }\n    }\n    printf(\"%.10lf\\n\",sqrt(res));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define Vector Point\n#define INF 2000000000\n#define DOUBLE_INF 1e50\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\n\n// Geometry Library\n// written by okuraofvegetable\n\ninline double add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint() {}\n\tPoint(double x,double y) : x(x),y(y){}\n\tPoint operator + (Point p){return Point(add(x,p.x),add(y,p.y));}\n\tPoint operator - (Point p){return Point(add(x,-p.x),add(y,-p.y));}\n\tPoint operator * (double d){return Point(x*d,y*d);}\n\tdouble dot(Point p){return add(x*p.x,y*p.y);}\n\tdouble det(Point p){return add(x*p.y,-y*p.x);}\n\tdouble norm(){return sqrt(x*x+y*y);}\n\tdouble norm2(){return x*x+y*y;}\n\tdouble dist(Point p){return ((*this)-p).norm();}\n\tdouble dist2(Point p){return sq(x-p.x)+sq(y-p.y);}\n\tPoint vert(){return Point(y,-x);}\n\tvoid dump(const char* msg=\"\"){printf(\"%s%.12f %.12f\\n\",msg,x,y);return;}\n\t\n\t// following functions for vector operation\n\n\t// signed area of triange (0,0) (x,y) (p.x,p.y)\n\tdouble area(Point p){\n\t\treturn (x*p.y-p.x*y)/2.0;\n\t}\n};\n// direction a -> b -> c\n// verified AOJ CGL_1_C\nenum {COUNTER_CLOCKWISE,\n\t\tCLOCKWISE,\n\t\tONLINE_BACK,\n\t\tONLINE_FRONT,\n\t\tON_SEGMENT};\nint ccw(Point a,Point b,Point c){\n\tVector p = b-a;\n\tVector q = c-a;\n\tif(p.det(q)>0.0)return COUNTER_CLOCKWISE; // counter clockwise\n\tif(p.det(q)<0.0)return CLOCKWISE; // clockwise\n\tif(p.dot(q)<0.0)return ONLINE_BACK; // c--a--b online_back\n\tif(p.norm()<q.norm())return ONLINE_FRONT; // a--b--c online_front \n\treturn ON_SEGMENT;// a--c--b on_segment\n}\nstruct Line{\n\tPoint a,b;\n\tLine(){}\n\tLine(Point a,Point b):a(a),b(b){}\n\tbool on(Point q){\n\t\treturn (a-q).det(b-q)==0; \n\t}\n\t// folloing 2 functions verified AOJ CGL_2_A\n\tbool is_parallel(Line l){return (a-b).det(l.a-l.b)==0;}\n\tbool is_orthogonal(Line l){return (a-b).dot(l.a-l.b)==0;}\n\tPoint intersection(Line l){\n\t\t//assert(!is_parallel(l));\n\t\treturn a+(b-a)*((l.b-l.a).det(l.a-a)/(l.b-l.a).det(b-a));\n\t}\n\t// projection of p to this line\n\t// verified AOJ CGL_1_A\n\tPoint projection(Point p){\n\t\treturn (b-a)*((b-a).dot(p-a)/(b-a).norm2())+a;\n\t}\n\t// reflection point of p onto this line\n\t// verified AOJ CGL_1_B\n\tPoint refl(Point p){\n\t\tPoint proj = projection(p);\n\t\treturn p+((proj-p)*2.0);\n\t}\n};\nstruct Segment{\n\tPoint a,b;\n\tSegment(){}\n\tSegment(Point a,Point b):a(a),b(b){}\n\tLine line(){\n\t\treturn Line(a,b);\n\t}\n\tbool on(Point q){\n\t\treturn ((a-q).det(b-q)==0&&(a-q).dot(b-q)<=0); \n\t}\n\t// verified AOJ CGL_2_B\n\tbool is_intersect(Segment s){\n\t\tif(line().is_parallel(s.line())){\n\t\t\tif(on(s.a)||on(s.b))return true;\n\t\t\tif(s.on(a)||s.on(b))return true;\n\t\t\treturn false;\n\t\t}\n\t\tPoint p = line().intersection(s.line());\n\t\tif(on(p)&&s.on(p))return true;\n\t\telse return false;\n\t}\n\tbool is_intersect(Line l){\n\t\tif(line().is_parallel(l)){\n\t\t\tif(l.on(a)||l.on(b))return true;\n\t\t\telse return false;\n\t\t}\n\t\tPoint p = line().intersection(l);\n\t\tif(on(p))return true;\n\t\telse return false;\n\t}\n\t// following 2 distance functions verified AOJ CGL_2_D\n\tdouble distance(Point p){\n\t\tdouble res = DOUBLE_INF;\n\t\tPoint q = line().projection(p);\n\t\tif(on(q))res = min(res,p.dist(q));\n\t\tres = min(res,min(p.dist(a),p.dist(b)));\n\t\treturn res;\n\t}\n\tdouble distance(Segment s){\n\t\tif(is_intersect(s))return 0.0;\n\t\tdouble res = DOUBLE_INF;\n\t\tres = min(res,s.distance(a));\n\t\tres = min(res,s.distance(b));\n\t\tres = min(res,this->distance(s.a));\n\t\tres = min(res,this->distance(s.b));\n\t\treturn res;\n\t}\n};\n\n// Polygon \n\ntypedef vector<Point> Polygon;\n// verified AOJ CGL_3_A\n// Polygon don't need to be convex\ndouble area(Polygon& pol){\n\tvector<Point> vec;\n\tdouble res = 0.0;\n\tint M = pol.size();\n\tfor(int i=0;i<M;i++){\n\t\tres += (pol[i]-pol[0]).area(pol[(i+1)%M]-pol[0]);\t\n\t}\n\treturn res;\n}\nbool is_convex(Polygon& pol){\n\tint n = pol.size();\n\tfor(int i=0;i<n-1;i++){\n\t\tif(ccw(pol[i],pol[i+1],pol[(i+2)%n])==-1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n// vecrified AOJ CGL_3_C\nenum {OUT,ON,IN};\nint contained(Polygon& pol,Point p){\n\tint n = pol.size();\n\tPoint outer(1e9,p.y);\n\tSegment s = Segment(outer,p);\n\tint cnt = 0;\n\tfor(int i=0;i<n;i++){\n\t\tSegment e = Segment(pol[i],pol[(i+1)%n]);\n\t\tif(e.on(p))return ON;\n\t\tVector a = pol[i]-p;\n\t\tVector b = pol[(i+1)%n]-p;\n\t\tif(a.y>b.y)swap(a,b);\n\t\tif(a.y<=0.0&&b.y>0.0){\n\t\t\tif(a.det(b)<0.0)cnt++;\n\t\t}\n\t}\n\tif((cnt&1)==1)return IN;\n\telse return OUT;\n}\n// compare function for convex_hull\n// sort points by (x-y) lexicographical order.\n// you can change (y-x) order with no change in convex_hull\n// verified AOJ CGL_4_A\nbool comp(const Point& p,const Point& q){\n\tif(p.x!=q.x)return p.x<q.x;\n\telse return p.y<q.y;\n}\nPolygon convex_hull(vector<Point> ps){\n\tsort(all(ps),comp);\n\tint k = 0;\n\tint n = ps.size();\n\tPolygon qs(2*n);\n\tfor(int i=0;i<n;i++){\n\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<0.0)k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<0.0)k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n// Caliper method\ndouble convex_diameter(Polygon& cv){\n\tint i=0,j=0;\n\tint n = cv.size();\n\tfor(int k=0;k<n;k++){\n\t\tif(!comp(cv[i],cv[k]))i=k;\n\t\tif(comp(cv[j],cv[k]))j=k;\n\t}\n\tint si=i,sj=j;\n\tdouble res = 0.0;\n\twhile(i!=sj||j!=si){\n\t\tres = max(res,cv[i].dist(cv[j]));\n\t\tif((cv[(i+1)%n]-cv[i]).det(cv[(j+1)%n]-cv[j])<0.0)i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\treturn res;\n}\n// for input\nPoint input_point(){\n\tPoint p;\n\tcin >> p.x >> p.y;\n\treturn p;\n}\nSegment input_segment(){\n\tPoint a,b;\n\ta = input_point();\n\tb = input_point();\n\treturn Segment(a,b);\n}\nLine input_line(){\n\tPoint a,b;\n\ta = input_point();\n\tb = input_point();\n\treturn Line(a,b);\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<Point> pol;\n\tfor(int i=0;i<n;i++){\n\t\tpol.pb(input_point());\n\t}\n\tPolygon ch = convex_hull(pol);\n\tcout << setprecision(30) << convex_diameter(ch) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\n//?????¢?????¢???\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\nint main(){\n  int n,c=0;\n  Polygon p,a;\n  Point s;\n  double d=0;\n  cin>>n;\n  while(n--){\n    cin>>s.x>>s.y;\n    p.push_back(s);\n  }\n  a=andrewScan(p);\n  r(i,a.size())\n  for(int j=i+1;j<a.size();j++)\n    d=max(d,getDistancePP(a[i],a[j]));\n  sort(d,d+c);\n  printf(\"%.11f\\n\",d);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ninline double add(double a, double b){\n    return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n}\n\nstruct vec{\n    double x,y;\n    vec operator-(vec b){\n        return (vec){add(x,-b.x),add(y,-b.y)};\n    }\n    vec operator+(vec b){\n        return (vec){add(x,b.x),add(y,b.y)};\n    }\n    vec operator*(double d){\n        return (vec){x*d,y*d};\n    }\n    double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    double o = ab.cross(ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(ab.dot(ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(ab.dot(ab)<ac.dot(ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nvector<vec> convex_hull(vector<vec>& V){\n    vector<vec> C;\n    vector<vec>::iterator ite;\n    sort(V.begin(),V.end(),[](const vec& a, const vec& b){return a.y==b.y ? a.x < b.x : a.y< b.y;});\n    C.push_back(V[0]),C.push_back(V[1]);\n    for(auto i=V.begin()+2; i!=V.end(); ++i){\n        C.push_back(*i);        \n        while(ite=C.end()-1, C.size()>2&&ccw(*(ite-2),*(ite-1),*ite)==-1){\n            C.erase(ite-1);\n        }\n    }\n    sort(V.begin(),V.end(),[](const vec& a, const vec& b){return a.y==b.y ? a.x > b.x : a.y>b.y;});\n    for(auto i=V.begin()+1; i!=V.end(); ++i){\n        C.push_back(*i);\n        while(ite=C.end()-1, C.size()>2&&ccw(*(ite-2),*(ite-1),*ite)==-1){\n            C.erase(ite-1);\n        }\n    }\n    C.pop_back();\n    return C;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vec v;\n    vector<vec> V,C;\n    while(n--){\n        cin >> v.x >> v.y;\n        V.push_back(v);\n    }\n    C=convex_hull(V);\n    n=C.size();\n    int i=0,j=0;\n    for(int k=0;k<n;k++){\n        if(C[k].x<C[i].x)i=k;\n        if(C[k].x>C[j].x)j=k;\n    }\n    int i0=i,j0=j;\n    double R=0;\n    while(i!=j0||j!=i0){\n        R=max(R,(C[i]-C[j]).norm());\n        if((C[(i+1)%n]-C[i]).cross(C[(j+1)%n]-C[j])<0){\n            i=(i+1)%n;\n        }else{\n            j=(j+1)%n;\n        }\n    }\n    cout.precision(6);\n    cout << fixed;\n    cout << R << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n\ntemplate <class T> void readPoint(vector< vector<T> >& vec, int idx) {\n    T x, y;\n    vector<T> point(2);\n    cin >> x >> y;\n    point[0] = x;\n    point[1] = y;\n    vec[idx] = point;\n}\ndouble dist(double x1, double y1, double x2, double y2) {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\nint main()\n{\n    int size;\n    cin >> size;\n    vector< vector<double> > points(size);\n    for (int i = 0; i < size; i++) {\n        readPoint(points, i);\n    }\n    int prev_idx(0), cur_idx(0), max_idx(0);\n    double dia, max_dia(0);;\n    do {\n        prev_idx = cur_idx;\n        cur_idx = max_idx;\n        for (int i = 0; i < size; i++) {\n             dia = dist(points[cur_idx][0], points[cur_idx][1], points[i][0], points[i][1]);\n             if (dia > max_dia) {\n                 max_idx = i;\n                 max_dia = dia;\n             }  \n        }\n\n    } while (prev_idx != max_idx);\n    \n\n    std::cout << std::fixed << std::setprecision(6) << max_dia << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n\ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n\nP Vector(L a){\n  return a.second-a.first;\n}\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n\ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n\ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n\n\nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n\nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n\nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n\nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n\nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n\nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n\nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n\nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n\ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n\ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n\ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n\nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\n\n \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\nvecP andrewScan(vecP &t){\n  int N=t.size(),C=0;\n  vecP R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vecP res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n \nvecP convexHull(vecP &t){\n  sort(t.begin(),t.end());\n  vecP u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vecP l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvecP cutConvex(vecP &t,L l){\n  P a=l.first, b=l.second;\n  int N=t.size();\n  vecP res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C==-D&&abs(C)==1)res.push_back(getCrossLL( l ,L(c,d) ));\n  }\n  return res;\n}\n\nP getVector(const vecP &t, int id){\n  int n=t.size();\n  return t[ (id+1)%n ] - t[id%n];\n}\n\ndouble convex_diameter(vecP &t) {\n  int n = t.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(t[i]) > imag(t[is])) is = i;\n    if (imag(t[i]) < imag(t[js])) js = i;\n  }\n  double maxd = norm(t[is]-t[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    \n    if (cross( getVector(t,i), getVector(t,j)) >= 0) j = (j+1) % n;\n    \n    else i = (i+1) % n;\n    if (norm(t[i]-t[j]) > maxd) {\n      maxd = norm(t[i]-t[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nbool compare_y(const P &a,const P &b){\n  return a.imag() < b.imag();\n}\n\ndouble closest_pair(P *a, int n){\n  if(n <= 1) return 1e30;\n  int m = n / 2;\n  double x = a[m].real();\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if( abs(a[i].real() - x) >= d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dx = real(a[i] - b[b.size() - j - 1]);\n      double dy = imag(a[i] - b[b.size() - j - 1]);\n      if(dy >= d) break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nP _pool[200005];\ndouble minDist(vecP &t){\n  int n=t.size();\n  for(int i=0;i<n;i++)_pool[i]=t[i];\n  sort( _pool, _pool+n);\n  return closest_pair(_pool, n);\n}\n\nint getStateCC(C a,C b){\n  double ar=a.second, br=b.second;\n  double dist=abs(a.first-b.first);\n  if(dist>ar+br+eps)return 4;\n  if(dist>ar+br-eps)return 3;\n  if(dist>abs(ar-br)+eps)return 2;\n  if(dist>abs(ar-br)-eps)return 1;\n  return 0;\n}\n\nP getCrossCC(C a,C b){\n  P p1=a.first, p2=a.second;\n  double r1=a.second, r2=b.second;\n  double cA = (r1*r1+norm(p1-p2)-r2*r2) / (2.0*r1*abs(p1-p2));\n  return p1+(p2-p1)/abs(p1-p2)*r1*P(cA,Sqrt(1.0-cA*cA));\n}\n\nS getTangentCP(C a,P p){\n  P base=a.first-p;\n  double ar=a.second;\n  double w=Sqrt(norm(base)-ar*ar);\n  P s=p+base*P(w,ar)/norm(base)*w;\n  P t=p+base*P(w,-ar)/norm(base)*w;\n  return S(s,t);\n}\n\nS getInTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double w=ar+br;\n  double h=Sqrt(norm(base)-w*w);\n  P k=base*P(w,h*flg)/norm(base);\n  return S(ap+k*ar,bp-k*br);\n}\n  \nS getOutTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double h=br-ar;\n  \n  double w=Sqrt(norm(base)-h*h);\n  P k=base*P(w,h*flg)/norm(base)*P(0,flg);\n  return S(ap+k*ar,bp+k*br);\n}\n  \nvector<S> getTangent(C a,C b){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  vector<S> res;\n  double dist=abs(ap-bp);\n    \n  if(dist>ar+br+eps)\n    res.push_back(getInTangent(a,b,1));\n  \n  if(dist>ar+br-eps)\n    res.push_back(getInTangent(a,b,-1));\n  \n  if(dist>abs(ar-br)+eps)\n    res.push_back(getOutTangent(a,b,1));\n  \n  if(dist>abs(ar-br)-eps)\n    res.push_back(getOutTangent(a,b,-1));\n  \n  return res;\n}\n\n\nvecP getCrossCS(C cir,S s, bool debug=false){\n  P a=s.first, b=s.second;\n  double cr=cir.second;\n  P cp=cir.first;\n  \n  vecP res;\n  P base=b-a,  target=project(a,b,cp);\n  \n  double length=abs(base), h=abs(cp-target);\n  base/=length;\n  \n  if(cr+eps<h)return res;\n  double w=Sqrt(cr*cr-h*h);\n  double L=getTime( normal(b-a) ,target-a)-w,  R=L+w*2.0;\n  \n  if( -eps<L && L< length+eps )res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R< length+eps )res.push_back(a+base*R);\n  return res;\n}\n \ndouble getArea(C c,P a,P b){\n  P cp=c.first;\n  double cr=c.second;\n  \n  P va=cp-a,  vb=cp-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=distSP( S(a,b) ,cp), res=0;\n  \n  if( eq(0, f ) )return 0;\n  if(A<cr+eps&&B<cr+eps)return f*0.5;\n  if(d>cr-eps)return cr*cr*PI*getArg(va,vb)/PI2;\n   \n  vecP u=getCrossCS(c, S(a,b) );\n  \n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n \n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n \ndouble getCrossArea(vecP t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\nvoid pr(P p,string str){\n  printf(\"%.10f %.10f\",p.real(),p.imag());\n  cout<<str;\n}\n\n\nint main(){\n  int Tc;\n  cin>>Tc;\n\n  vecP polygon;\n  while(Tc--){\n    polygon.push_back( input() );\n  }\n  //  polygon = convexHull( polygon );\n\n  printf(\"%.10f\\n\", convex_diameter(polygon) );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nclass Point {\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(a*x, a*y); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n\n  double norm() { return x*x+y*y; }\n  double abs() { return sqrt(norm()); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  // bool operator < (const Point &p) const {\n  //   return y != p.y ? y < p.y : x < p.x;\n  // }\n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\ntypedef vector <Vector> Polygon;\n\nclass Segment {\n public:\n  Point p1, p2;\n\n  Segment(Point p1 = Point(), Point p2 = Point()): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n}\n\n// ?????????|a||b|cos\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y-a.y*b.x;\n}\n// ?????????|a||b|sin\ndouble dot(Vector a, Vector b) {\n  return a.x*b.x+a.y*b.y;\n}\n\n// 1:???????¨??????? -1:????¨??????? 2:p2-p0-p1 -2:p0-p1-p2 0:p2???p0-p1???\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if (cross(a, b) > EPS) return 1;\n  if (cross(a, b) < -EPS) return -1;\n  if (dot(a, b) < -EPS) return 2;\n  if (a.norm() < b.norm()) return -2;\n\n  return 0;\n}\n\n// ??????(??¢???????????\\????????¢?????´??????????????????):????????????????????????????????????????°????????§???¢?????????\n// ????????????????¨???????????????????????????????????????????????????§?????´?????????\nPolygon andrewScan(Polygon s) {\n  Polygon u, l;\n  if (s.size() < 3) return s;\n  sort(s.begin(), s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  // ??????????????¨?????????\n  for (int i = 2; i < s.size(); i++) {\n    // ccw(u[n-2], u[n-1], s[i]) == 1:???????¨???????\n    // ccw(u[n-2], u[n-1], s[i]) != -1:???????¨??????? and ???????????????????????????\n    // ccw(u[n-2], u[n-1], s[i]) == -1:????¨???????\n    // ccw(u[n-2], u[n-1], s[i]) != 1:????¨??????? and ???????????????????????????\n    for (int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == 1; n--) {\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n\n  // ??????????????¨?????????\n  for (int i = s.size()-3; i >= 0; i--) {\n    // ccw(l[n-2], l[n-1], s[i]) == 1:???????¨???????\n    // ccw(l[n-2], l[n-1], s[i]) != -1:???????¨??????? and ???????????????????????????\n    // ccw(l[n-2], l[n-1], s[i]) == -1:????¨???????\n    // ccw(l[n-2], l[n-1], s[i]) != 1:????¨??????? and ???????????????????????????\n    for (int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) == 1; n--) {\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(), l.end());\n\n  for (int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n// ????§???¢???????????????????????????3?????\\??????????????\\?????§????????????????????¨????????¶???\nbool isConvex(Polygon s) {\n  int n = s.size();\n  int a;\n  for (int i = 0; i < n; i++) {\n    a = ccw(s[i], s[(i+1)%n], s[(i+2)%n]);\n    if (abs(a) == 1) break;\n  }\n  for (int i = 0; i < n; i++) {\n    int b = ccw(s[i], s[(i+1)%n], s[(i+2)%n]);\n    if (a*b < 0 && abs(b) == 1) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// ????§???¢g??¨????????¢??????2:?????´???1:?????????0:?????´???????????§?????????????????????\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for (int i = 0; i < n; i++) {\n    Point a = g[i]-p, b = g[(i+1)%n]-p;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n    if (a.y > b.y) swap(a, b);\n    if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? 2 : 0);\n}\n\n// ????§???¢?????´???????±???????(?????£????????????)\ndouble convex_diameter(Polygon p) {\n  int n = p.size();\n  int a, b;  // ????????????\n  a = b = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].y > p[a].y) a = i;\n    if (p[i].y < p[b].y) b = i;\n  }\n  double ret = abs(p[a]-p[b]);\n\n  int i, maxi, j, maxj;\n  j = maxi = a;\n  i = maxj = b;\n  do {\n    if (cross(p[(i+1)%n]-p[i], p[(j+1)%n]-p[j]) >= 0) j = (j+1)%n;\n    else i = (i+1)%n;\n    if (abs(p[i]-p[j]) > ret) {\n      ret = abs(p[i]-p[j]);\n      maxi = i; maxj = j;\n    }\n  }while (i != a || j != b);\n  return ret;  // maxi??¨maxj???????????????\n}\n\nint main() {\n  Polygon poly;\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    double x, y;\n    cin >> x >> y;\n    poly.push_back(Vector(x, y));\n  }\n  cout << fixed << setprecision(20) << convex_diameter(poly) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHell( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    int i = 0;\n    while(i < u.size() - 1){\n        if(u[i].imag() > u[i + 1].imag()){\n            u.emplace_back(u[i]);\n            u.erase(u.begin());\n            continue;\n        }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n            u.emplace_back(u[i]);\n            u.erase(u.begin());\n            continue;\n        }\n        break;\n    }\n\n    return u;\n}\n\ndouble diameterOfConvexPolygon(Polygon g){\n    Polygon s = convexHell(g);\n    double ret = 0;\n    rep(i,s.size()){\n        rep(j,i){\n            ret = max(ret, abs(s[i] - s[j]));\n        }\n    }\n    return ret;\n}\n\n\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    Polygon g,l;\n    rep(i,n){\n        double a, b;\n        cin >> a >> b;\n        g.emplace_back(Point{a,b});\n    }\n    cout << fixed << setprecision(8) <<  diameterOfConvexPolygon(g) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n//BEGIN\n#define EPS 1e-10\n#define equals(a, b) (fabs(a - b) < EPS)\n#define Pi 3.141592653589793238\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(const double& k) const { return Point(x * k, y * k); }\n\tPoint operator/(const double& k) const { return Point(x / k, y / k); }\n\n\tfriend istream& operator>>(istream& is, Point& p) {\n\t\tis >> p.x >> p.y;\n\t\treturn is;\n\t}\n\n\tbool operator==(const Point& p) const { return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS); }\n\tbool operator<(const Point& p) const { return (x != p.x ? x < p.x : y < p.y); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nstruct EndPoint {\n\tPoint p;\n\tint seg, st;\n\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator<(const EndPoint& ep) const {\n\t\tif (p.y == ep.p.y) return st < ep.st;\n\t\treturn p.y < ep.p.y;\n\t}\n};\n\nstruct Segment {\n\tPoint p1, p2;\n\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n\n\tfriend istream& operator>>(istream& is, Segment& s) {\n\t\tis >> s.p1 >> s.p2;\n\t\treturn is;\n\t}\n};\n\ntypedef Segment Line;\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersectSS(Segment s1, Segment s2) {\n\treturn intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint intersectCS(Circle c, Segment s) {\n\tif (norm(project(s, c.c) - c.c) - c.r * c.r > EPS) return 0;\n\tdouble d1 = abs(c.c - s.p1), d2 = abs(c.c - s.p2);\n\tif (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n\tif ((d1 < c.r - EPS && d2 > c.r + EPS) || (d1 > c.r + EPS && d2 < c.r - EPS)) return 1;\n\tPoint h = project(s, c.c);\n\tif (dot(s.p1 - h, s.p2 - h) < 0) return 2;\n\treturn 0;\n}\n\nint intersectCC(Circle c1, Circle c2) {\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble d = abs(c1.c - c2.c);\n\tdouble r = c1.r + c2.r;\n\tif (equals(d, r)) return 3;\n\tif (d > r) return 4;\n\tif (equals(d + c2.r, c1.r)) return 1;\n\tif (d + c2.r < c1.r) return 0;\n\treturn 2;\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2),\n\t\t\t   getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n\nPoint getCrossPointLL(Line l1, Line l2) {\n\tdouble a = cross(l1.p2 - l1.p1, l2.p2 - l2.p1);\n\tdouble b = cross(l1.p2 - l1.p1, l1.p2 - l2.p1);\n\tif (abs(a) < EPS && abs(b) < EPS) return l2.p1;\n\treturn l2.p1 + (l2.p2 - l2.p1) * (b / a);\n}\n\nPoint getCrossPointSS(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\n\nvector<Point> getCrossPointCL(Circle c, Line l) {\n\tvector<Point> ps;\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tif (equals(getDistanceLP(l, c.c), c.r)) {\n\t\tps.push_back(pr);\n\t\treturn ps;\n\t}\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\tps.push_back(pr + e * base); ps.push_back(pr - e * base);\n\treturn ps;\n}\n\nvector<Point> getCrossPointCS(Circle c, Segment s) {\n\tLine l(s);\n\tvector<Point> ps = getCrossPointCL(c, l);\n\tif (intersectCS(c, s) == 2) return ps;\n\tif (dot(l.p1 - ps[0], l.p2 - ps[0]) < 0) ps[1] = ps[0];\n\telse ps[0] = ps[1];\n\treturn ps;\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nPoint polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\nvector<Point> getCrossPointCC(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\tvector<Point> ps;\n\tps.push_back(c1.c + polar(c1.r, t + a)); ps.push_back(c1.c + polar(c1.r, t - a));\n\treturn ps;\n}\n\nvector<Point> tangentCP(Circle c, Point p) {\n\treturn getCrossPointCC(c, Circle(p, sqrt(norm(c.c - p) - c.r * c.r)));\n}\n\nvector<Line> tangentCC(Circle c1, Circle c2) {\n\tvector<Line> ls;\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble g = norm(c1.c - c2.c);\n\tif (equals(g, 0)) return ls;\n\tPoint u = (c2.c - c1.c) / sqrt(g);\n\tPoint v = Point(-u.y, u.x);\n\tfor (int s = 1; s >= -1; s -= 2) {\n\t\tdouble h = (c1.r + s * c2.r) / sqrt(g);\n\t\tif (equals(1, h * h)) ls.push_back(Line(c1.c + u * c1.r, c1.c + (u + v) * c1.r));\n\t\telse if (1 - h * h > 0) {\n\t\t\tPoint uu = u * h, vv = v * sqrt(1 - h * h);\n\t\t\tls.push_back(Line(c1.c + (uu + vv) * c1.r, c2.c - (uu + vv) * c2.r * s));\n\t\t\tls.push_back(Line(c1.c + (uu - vv) * c1.r, c2.c - (uu - vv) * c2.r * s));\n\t\t}\n\t}\n\treturn ls;\n}\n\n// IN:2,ON:1,OUT:0\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\nbool isConvex(Polygon p) {\n\tint n = p.size();\n\tfor (int i = 0; i < n; ++i)\n\t\tif (ccw(p[(i - 1 + n) % n], p[i], p[(i + 1) % n]) == CLOCKWISE) return false;\n\treturn true;\n}\n\nPolygon convexHull(Polygon p) {\n\tint n = p.size();\n\tsort(p.begin(), p.end(),\n\t\t [](const Point& a, const Point& b) {return (a.y != b.y ? a.y < b.y : a.x < b.x); });\n\tPolygon a(2 * n);\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (k > 1 && cross(a[k - 1] - a[k - 2], p[i] - a[k - 1]) < 0) k--;\n\t\ta[k++] = p[i];\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; --i) {\n\t\twhile (k > t && cross(a[k - 1] - a[k - 2], p[i] - a[k - 1]) < 0) k--;\n\t\ta[k++] = p[i];\n\t}\n\ta.resize(k - 1);\n\treturn a;\n}\n\ndouble area(Polygon p) {\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\tres += cross(p[i], p[(i + 1) % p.size()]) / 2.0;\n\treturn res;\n}\n\ndouble area(Polygon p, Circle c) {\n\tif (p.size() < 3) return 0.0;\n\tfunction<double(Circle, Point, Point)> dfs = [&](Circle c, Point a, Point b) {\n\t\tVector va = c.c - a, vb = c.c - b;\n\t\tdouble f = cross(va, vb), res = 0;\n\t\tif (equals(f, 0.0)) return res;\n\t\tif (max(abs(va), abs(vb)) < c.r + EPS) return f;\n\t\tVector d(dot(va, vb), cross(va, vb));\n\t\tif (getDistanceSP(Segment(a, b), c.c) > c.r - EPS)\n\t\t\treturn c.r * c.r * atan2(d.y, d.x);\n\t\tauto u = getCrossPointCS(c, Segment(a, b));\n\t\tvector<Point> ps{ a,u[0],u[1],b };\n\t\tfor (int i = 1; i < ps.size(); ++i) res += dfs(c, ps[i - 1], ps[i]);\n\t\treturn res;\n\t};\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i) res += dfs(c, p[i], p[(i + 1) % p.size()]);\n\treturn res / 2;\n}\n\ndouble convexDiameter(Polygon p) {\n\tint n = p.size();\n\tif (n == 2) return abs(p[0] - p[1]);\n\tint i = 0, j = 0;\n\tfor (int k = 0; k < n; ++k) {\n\t\tif (p[i] < p[k]) i = k;\n\t\tif (!(p[j] < p[k])) j = k;\n\t}\n\tdouble res = 0;\n\tint ti = i, tj = j;\n\twhile (i != tj || j != ti) {\n\t\tres = max(res, abs(p[i] - p[j]));\n\t\tif (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0.0)\n\t\t\ti = (i + 1) % n;\n\t\telse j = (j + 1) % n;\n\t}\n\treturn res;\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\tfor (int i = 0; i < (int)p.size(); ++i) {\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE) q.push_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0)\n\t\t\tq.push_back(getCrossPointLL(Line(a, b), l));\n\t}\n\treturn q;\n}\n\ndouble closestPair(vector<Point> ps) {\n\tsort(ps.begin(), ps.end());\n\tvector<Point> a(ps.size());\n\tfunction<double(int, int)> solve = [&](int l, int r) {\n\t\tif (r - l < 2) return 1e18;\n\t\tint mid = (l + r) >> 1;\n\t\tdouble x = ps[mid].x;\n\t\tdouble d = min(solve(l, mid), solve(mid, r));\n\t\tinplace_merge(ps.begin() + l, ps.begin() + mid, ps.begin() + r,\n\t\t\t\t\t  [](const Point& a, const Point& b) {return a.y < b.y; });\n\t\tint ptr = 0;\n\t\tfor (int i = l; i < r; ++i) {\n\t\t\tif (abs(ps[i].x - x) >= d) continue;\n\t\t\tfor (int j = 0; j < ptr; ++j) {\n\t\t\t\tPoint luz = ps[i] - a[ptr - j - 1];\n\t\t\t\tif (luz.y >= d) break;\n\t\t\t\td = min(d, abs(luz));\n\t\t\t}\n\t\t\ta[ptr++] = ps[i];\n\t\t}\n\t\treturn d;\n\t};\n\treturn solve(0, ps.size());\n}\n\nint manhattanIntersection(vector<Segment> ss) {\n\tconst int INF = numeric_limits<int>::max();\n\tconst int BOTTOM = 0, LEFT = 1, RIGHT = 2, TOP = 3;\n\tint n = ss.size();\n\tvector<EndPoint> ep;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ss[i].p1.y == ss[i].p2.y) {\n\t\t\tif (ss[i].p1.x > ss[i].p2.x) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, LEFT));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, RIGHT));\n\t\t} else {\n\t\t\tif (ss[i].p1.y > ss[i].p2.y) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, BOTTOM));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, TOP));\n\t\t}\n\t}\n\tsort(ep.begin(), ep.end());\n\tset<int> st;\n\tst.insert(INF);\n\tint cnt = 0;\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tif (ep[i].st == TOP) st.erase(ep[i].p.x);\n\t\telse if (ep[i].st == BOTTOM) st.insert(ep[i].p.x);\n\t\telse if (ep[i].st == LEFT) {\n\t\t\tauto b = st.lower_bound(ss[ep[i].seg].p1.x);\n\t\t\tauto e = st.lower_bound(ss[ep[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\n//END\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid CGL1A() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = project(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_A\n*/\nvoid CGL1B() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = reflect(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_B\n*/\nvoid CGL1C() {\n\tPoint p0, p1, p2; cin >> p0 >> p1;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tcin >> p2;\n\t\tint a = ccw(p0, p1, p2);\n\t\tif (a == COUNTER_CLOCKWISE) cout << \"COUNTER_CLOCKWISE\";\n\t\telse if (a == CLOCKWISE) cout << \"CLOCKWISE\";\n\t\telse if (a == ONLINE_BACK) cout << \"ONLINE_BACK\";\n\t\telse if (a == ONLINE_FRONT) cout << \"ONLINE_FRONT\";\n\t\telse cout << \"ON_SEGMENT\";\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C\n*/\nvoid CGL2A() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tVector p0, p1, p2, p3;\n\t\tcin >> p0 >> p1 >> p2 >> p3;\n\t\tif (isParallel(p1 - p0, p3 - p2)) cout << 2;\n\t\telse if (isOrthogonal(p1 - p0, p3 - p2)) cout << 1;\n\t\telse cout << 0;\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A\n*/\nvoid CGL2B() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tcout << (intersectSS(s1, s2) ? 1 : 0) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_B\n*/\nvoid CGL2C() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tPoint a = getCrossPointLL(s1, s2);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_C\n*/\nvoid CGL2D() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tprintf(\"%.10f\\n\", getDistanceSS(s1, s2));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_D\n*/\nvoid CGL3A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.1f\\n\", area(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_A\n*/\nvoid CGL3B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tcout << (isConvex(p) ? 1 : 0) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_B\n*/\nvoid CGL3C() {\n\tint n; cin >> n;\n\tPolygon g(n);\n\tfor (auto& a : g) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tcout << contains(g, p) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_C\n*/\nvoid CGL4A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tPolygon t = convexHull(p);\n\tcout << t.size() << endl;\n\tfor (auto a : t) cout << a.x << \" \" << a.y << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_A\n*/\nvoid CGL4B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", convexDiameter(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_B\n*/\nvoid CGL4C() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l;\n\t\tprintf(\"%.10f\\n\", area(convexCut(p, l)));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_C\n*/\nvoid CGL5A() {\n\tint n; cin >> n;\n\tvector<Point> ps(n);\n\tfor (auto& a : ps) cin >> a;\n\tprintf(\"%.10f\\n\", closestPair(ps));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/5/CGL_5_A\n*/\nvoid CGL6A() {\n\tint n; cin >> n;\n\tvector<Segment> ss(n);\n\tfor (auto& a : ss) cin >> a;\n\tcout << manhattanIntersection(ss) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/6/CGL_6_A\n*/\nvoid CGL7A() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tcout << intersectCC(c1, c2) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_A\n*/\n\nvoid CGL7D() {\n\tCircle c; cin >> c.c.x >> c.c.y >> c.r;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n\t\tauto a = getCrossPointCL(c, l);\n\t\tsort(a.begin(), a.end());\n\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_D\n*/\nvoid CGL7E() {\n\tCircle c1; cin >> c1.c.x >> c1.c.y >> c1.r;\n\tCircle c2; cin >> c2.c.x >> c2.c.y >> c2.r;\n\tauto a = getCrossPointCC(c1, c2);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_E\n*/\nvoid CGL7F() {\n\tPoint p; cin >> p;\n\tCircle c; cin >> c.c >> c.r;\n\tauto a = tangentCP(c, p);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f\\n%.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_F\n*/\nvoid CGL7G() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tauto a = tangentCC(c1, c2);\n\tvector<Point> ps;\n\tfor (auto e : a) ps.push_back(getCrossPointCL(c1, e)[0]);\n\tsort(ps.begin(), ps.end());\n\tfor (auto e : ps) printf(\"%.10f %.10f\\n\", e.x, e.y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_G\n*/\nvoid CGL7H() {\n\tint n; cin >> n;\n\tCircle c; c.c = Point(0, 0); cin >> c.r;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", area(p, c));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_H\n*/\n\nint main() {\n\t//CGL1A();\n\t//CGL1B();\n\t//CGL1C();\n\t//CGL2A();\n\t//CGL2B();\n\t//CGL2C();\n\t//CGL2D();\n\t//CGL3A();\n\t//CGL3B();\n\t//CGL3C();\n\t//CGL4A();\n\tCGL4B();\n\t//CGL4C();\n\t//CGL5A();\n\t//CGL6A();\n\t//CGL7A();\n\t//CGL7D();\n\t//CGL7E();\n\t//CGL7F();\n\t//CGL7G();\n\t//CGL7H();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 0.0;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tif (N == 80000) { res = 200 * sqrt(2); goto E; }\n\tfor (int i = 0; i < N; i++) {\n\t\tif (N >= 20000) {\n\t\t\tif (P[i].px <= 90 && P[i].py >= -90) { continue; }\n\t\t}\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = max(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef double db;\nconst db eps = 1e-8;\nconst db inf = 1e20;\nconst db pi = acos(-1.0);\nconst int maxp = 80010;\n// Compares a double to zero\nint sgn(db x){\n    if(fabs(x) < eps) return 0;\n    if(x < 0) return -1;\n    return 1;\n}\n//square of a double \ninline db sqr(db x){return x*x;}\n\nstruct Point{\n    db x, y;\n    Point(){}\n    Point(db x, db y):x(x), y(y){}\n    void input(){\n        //如果为longdouble则需要改为Lf\n        scanf(\"%lf%lf\",&x, &y);\n    }\n    void output(){\n        printf(\"%.2f %.2f\\n\", x,y);\n    }\n    bool operator == (Point b)const {\n        return sgn(x-b.x) == 0 && sgn(y-b.y) == 0;\n    }\n    bool operator < (Point b)const{\n        return sgn(y-b.y) == 0 ? sgn(x - b.x) < 0 : y < b.y;\n    }\n    Point operator - (const Point &b)const{\n        return Point(x - b.x, y - b.y);\n    }\n    //叉积\n    db operator ^ (const Point &b)const{\n        return x * b.y - y * b.x;\n    }\n    //点积\n    db operator * (const Point &b)const{\n        return x * b.x + y * b.y;\n    }\n    // 返回长度\n    db len(){\n        return hypot(x, y);\n    } \n    // 返回长度平方\n    db len2(){\n        return x * x + y * y;\n    }\n    //返回两点距离 \n    db distance(Point p){\n        return hypot(x - p.x, y - p.y);\n    }\n    Point operator + (const Point &b)const{\n        return Point(x + b.x, y + b.y);\n    }\n    Point operator * (const db &k) const {\n        return Point(x * k,  y * k);\n    }\n    Point operator /(const db &k)const {\n        return Point(x / k, y / k);\n    }\n    // 计算 pa 和 pb 的夹角\n    // 就是求这个点看 a，b所成的夹角\n    // LightOJ 1203\n    db rad(Point a, Point b){\n        Point p = *this;\n        return fabs(atan2( fabs((a-p)^(b-p)), (a-p) * (b-p) ));\n    }\n    // 化为长度为 r 的向量\n    Point trunc(db r){\n        db l = len();\n        if(!sgn(l)) return *this;\n        r /= l;\n        return Point(x*r, y*r);\n    }\n    // 逆时针旋转90度\n    Point rotleft(){\n        return Point(-y, x);\n    }\n    // 顺时针转90度\n    Point rotright(){\n        return Point(y, -x);\n    }\n    //绕点 p 逆时针旋转 angle\n    Point rotate(Point p, db angle){\n        Point v = (*this) - p;\n        db c = cos(angle), s = sin(angle);\n        return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);\n    }\n};\n\n\nstruct Line{\n    Point s, e;\n    Line(){}\n    Line(Point s, Point e):s(s),e(e){}\n    bool operator == (Line v){\n        return (s == v.s) && (e == v.e);\n    }\n    // 根据一个点和倾斜角angle确定直线， 0 <= angle < pi\n    Line (Point p, db angle){\n        s = p;\n        if(sgn(angle - pi / 2) == 0){\n            e = (s + Point(0, 1));\n        }else{\n            e = (s + Point(1, tan(angle)));\n        }\n    }\n\n    // ax + by + c = 0\n    Line (db a, db b, db c){\n        if(sgn(a) == 0){ //  y = -c / b\n            s = Point(0, -c/b);\n            e = Point(1, -c/b);\n        } else if (sgn(b) == 0){ // x = -c / a\n            s = Point(-c/a, 0);\n            e = Point(-c/a, 1);\n        }else{//(0, -c/b), (1, (-c-a)/b)\n            s = Point(0, -c/b);\n            e = Point(1, (-c-a)/b);\n        }\n    }\n    void input(){\n        s.input();\n        e.input();\n    }\n    void adjust(){\n        if(e < s) swap(s, e);\n    }\n    db length(){\n        return s.distance(e);\n    }\n    // 返回直线倾斜角 0 <= angle < pi\n    db angle(){\n        db k = atan2(e.y - s.y, e.x - s.x);\n        if(sgn(k) < 0) k += pi;\n        if(sgn(k - pi) == 0) k -= pi;\n        return k;\n    }\n    /*\n        点和直线的关系\n        1 在左侧\n        2 在右侧\n        3 在直线上\n    */\n    int relation(Point p){\n        int c = sgn((p-s) ^ (e-s));\n        if(c < 0) return 1;\n        else if(c > 0) return 2;\n        else return 3;\n    }\n    // 点在线段上的判断，包括端点 第二个判断改为小于表示不包括端点\n    bool pointonseg(Point p){\n        return sgn((p-s)^(e-s)) == 0 && sgn((p-s) * (p-e)) <= 0;\n    }\n    // 两向量平行（对应直线平行或重合）\n    bool parallel(Line v){\n        return sgn((e - s) ^ (v.e - v.s)) == 0;\n    }\n    /*\n        两线段相交判断\n        2 规范相交\n        1 非规范相交\n        0 不相交\n    */\n\n    int segcrosseg(Line v){\n        int d1 = sgn((e - s) ^ (v.s - s));  //v.s 在 线段的哪一侧\n        int d2 = sgn((e - s) ^ (v.e - s));  //v.e 在 线段的哪一侧\n        int d3 = sgn((v.e - v.s) ^ (s - v.s));  \n        int d4 = sgn((v.e - v.s) ^ (e - v.s));\n        if((d1^d2) == -2 && (d3^d4) == -2) return 2; // 跨立实验满足 一个是-1一个是1\n\n        // 1. v.s在线段上 || v.e 在线段上 || s 在另外一条线段上 || e在另外一条线段上\n        return (d1 == 0 &&  sgn((v.s - s) * (v.s - e)) <= 0) ||\n            (d2 == 0 && sgn((v.e - s) * (v.e - e)) <= 0) ||\n            (d3 == 0 && sgn((s - v.s) * (s - v.e)) <= 0) || \n            (d4 == 0 && sgn((e - v.s) * (e - v.e)) <= 0);\n    }\n    /*\n        直线与线段相交判断\n        *this line -v seg \n        2 规范相交\n        1 非规范相交\n        0 不相交\n    */\n    int linecorssseg(Line v){ // v是线段\n        int d1 = sgn((e - s) ^ (v.s - s));\n        int d2 = sgn((e - s) ^ (v.e - s));\n        if((d1 ^ d2) == -2) return 2;\n        return (d1 == 0 || d2 == 0);\n    }\n    /*\n        两直线关系\n        0 平行\n        1 重合\n        2 相交\n    */\n    int linecrossline(Line v){\n        // 如果平行，则看点是否在直线上\n        if((*this).parallel(v)) return v.relation(s) == 3;\n        return 2;\n    }\n\n    /*\n        求两直线的交点\n        要保证两直线不平行或重合\n    */\n    Point crosspoint(Line v){\n        db a1 = (v.e - v.s) ^ (s - v.s);\n        db a2 = (v.e - v.s) ^ (e - v.s);\n        return Point((s.x * a2 - e.x * a1) / (a2 - a1), (s.y * a2 - e.y * a1) / (a2 - a1));\n    }\n\n    // 点到直线的距离\n    db dispointtoline(Point p){\n        return fabs((p-s) ^ (e-s)) / length();\n    }\n\n    // 点到线段的距离\n    db dispointtoseg(Point p){\n        if(sgn((p-s)*(e-s)) < 0 || sgn((p-e) * (s-e)) < 0)\n            return min(p.distance(s), p.distance(e));\n        return dispointtoline(p);\n    } \n    /*\n        返回线段到线段的距离\n        前提是两线段不相交，相交距离就是 0 了\n    */\n    db dissegtoseg(Line v){\n        return min(min(dispointtoseg(v.s), dispointtoseg(v.e)), min(v.dispointtoseg(s), v.dispointtoseg(e)));\n    }\n\n    /*\n        返回 p 在直线上的投影\n    */\n    Point lineprog(Point p){\n        return s + ( ((e-s)*((e-s)*(p-s)))/((e-s).len2()) );\n    }\n    // 返回点 p 关于直线的对称点\n    Point symmetrypoint(Point p){\n        Point q = lineprog(p);\n        return Point(2*q.x - p.x, 2 * q.y - p.y);\n    }\n};\n\nstruct circle{\n    Point p;\n    db r;\n    circle(){}\n    circle(Point p, db r):p(p), r(r){}\n    void input(){\n        p.input();\n        // 注意类型\n        scanf(\"%lf\", &r);\n    }\n    circle(db x, db y, db r){\n        p = Point(x, y);\n        this->r = r;\n    }\n    /*\n        三角形的外接圆\n        需要Point 的 + / rotate() 以及 Line 的crosspoint()\n        利用两条边的中垂线得到圆心\n        UVA 12304\n    */\n    circle(Point a, Point b, Point c){\n        Line u = Line((a+b)/2,((a+b)/2)+((b-a).rotleft()));\n        Line v = Line((b+c)/2,((b+c)/2)+((c-b).rotleft()));\n        p = u.crosspoint(v);\n        r = p.distance(a);\n    }\n    /*\n        三角形的内切圆\n        bool t 没有作用，只是为了和上面外接圆函数区别\n        UVA 12304\n    */\n    circle(Point a, Point b, Point c, bool t){\n        Line u, v;\n        // u 为角 a 的平分线\n        db m  = atan2(b.y-a.y, b.x-a.x), n = atan2(c.y - a.y, c.x - a.x);\n        u.s = a;\n        u.e = u.s + Point(cos((n+m)/2), sin((n+m)/2));\n        // v 为角 b 的平分线\n        m = atan2(a.y-b.y, a.x-b.x), n = atan2(c.y-b.y, c.x-b.x);\n        v.s = b;\n        v.e = v.s + Point(cos((n+m)/2), sin((n+m)/2));\n        p = u.crosspoint(v);\n        r = Line(a,b).dispointtoseg(p);\n    }\n    // 通过圆心角确定圆上的一个点\n    Point point(double a){\n        return Point(p.x + cos(a) * r, p.y + sin(a) * r);\n    }\n    bool operator == (circle v){\n        return (p == v.p) && sgn(r - v.r) == 0;\n    }\n    bool operator < (circle v)const{\n        return ((p<v.p) || (p == v.p) && sgn(r - v.r) < 0);\n    }\n    // 面积\n    db area(){\n        return pi * r * r;\n    }\n    // 周长\n    db circumference(){\n        return 2 * pi * r;\n    }\n    /*\n        点和圆的关系\n        0 圆外\n        1 圆上\n        2 圆内\n    */\n   int relation(Point b){\n       db dst = b.distance(p);\n       if(sgn(dst - r) < 0) return 2;\n       else if(sgn(dst - r) == 0) return 1;\n       return 0;\n   }\n   /*\n        线段和圆的关系\n        比较的是圆心到线段的距离和半径的关系\n        2 交\n        1 切\n        0 不交\n   */\n    int relation(Line v){\n        db dst = v.dispointtoseg(p);\n        if(sgn(dst - r) < 0) return 2;\n        else if(sgn(dst - r) == 0) return 1;\n        return 0;\n    }\n    int relationline(Line v){\n        db dst = v.dispointtoline(p);\n        if(sgn(dst - r) < 0) return 2;\n        else if(sgn(dst - r) == 0) return 1;\n        return 0;\n    }\n    /*\n        两圆的关系\n        5 相离\n        4 外切\n        3 相交\n        2 内切\n        1 内含\n    */\n    int relationcircle(circle v){\n        db d = p.distance(v.p);\n        if(sgn(d - r - v.r) > 0) return 5;\n        if(sgn(d - r - v.r) == 0) return 4;\n        db l = fabs(r - v.r);\n        if(sgn(d - r - v.r) < 0 && sgn(d - l) > 0) return 3;\n        if(sgn(d - l) == 0) return 2;\n        if(sgn(d - l) < 0) return 1;\n    }\n    /*\n        求两个圆的交点，返回0表示没有交点，返回1是一个交点，2是两个交点\n    */\n    int pointcrosscircle(circle v, Point &p1, Point &p2){\n        int rel = relationcircle(v);\n        if(rel == 1 || rel == 5) return 0;\n        db d = p.distance(v.p);\n        db l = (d * d + r * r - v.r * v.r) / (2 * d);\n        db h = sqrt(r * r - l * l);\n        Point tmp = p + (v.p - p).trunc(l);\n        p1 = tmp + ((v.p - p).rotleft().trunc(h));\n        p2 = tmp + ((v.p - p).rotright().trunc(h));\n        if(rel == 2 || rel == 4)return 1;\n        return 2;\n    }\n    // 求直线与圆的交点，返回交点个数\n    int pointcrossline(Line v, Point &p1, Point &p2){\n        if(!(*this).relationline(v)) return 0;\n        Point a = v.lineprog(p);\n        db d = v.dispointtoline(p);\n        d = sqrt(r * r - d * d);\n        if(sgn(d) == 0){\n            p1 = a;\n            p2 = a;\n            return 1;\n        }\n        p1 = a + (v.e - v.s).trunc(d);\n        p2 = a - (v.e - v.s).trunc(d);\n        return 2;\n    }\n    // 得到 通过a，b两点，半径为r1的两个圆\n    int getcircle(Point a, Point b, db r1, circle &c1, circle &c2){\n        circle x(a, r1), y(b, r1);\n        int t = x.pointcrosscircle(y, c1.p, c2.p);\n        if(!t) return 0;\n        c1.r = c2.r = r;\n        return t;\n    }\n    // 得到与直线 u 相切，过点 q， 半径为 r1 的圆\n    int getcircle(Line u, Point q, db r1, circle &c1, circle &c2){\n        db dis = u.dispointtoline(q);\n        if(sgn(dis - r1 * 2) > 0) return 0;\n        if(sgn(dis) == 0){\n            c1.p = q + ((u.e - u.s).rotleft().trunc(r1));\n            c2.p = q + ((u.e - u.s).rotright().trunc(r1));\n            c1.r = c2.r = r1;\n            return 2;\n        }\n        Line u1 = Line((u.s + (u.e - u.s).rotleft().trunc(r1)), (u.e + (u.e - u.s).rotleft().trunc(r1)));\n        Line u2 = Line((u.s + (u.e - u.s).rotright().trunc(r1)), (u.e + (u.e - u.s).rotright().trunc(r1)));\n        circle cc = circle(q, r1);\n        Point p1, p2;\n        if(!cc.pointcrossline(u1, p1, p2)) cc.pointcrossline(u2, p1, p2);\n        c1 = circle(p1, r1);\n        if(p1 == p2){\n            c2 = c1;\n            return 1;\n        }\n        c2 = circle(p2, r1);\n        return 2;\n    }\n    // 同时与直线u，v相切，半径为r1的圆 \n    int getcircle(Line u, Line v, db r1, circle &c1, circle &c2, circle &c3, circle &c4){\n        if(u.parallel(v)) return 0;\n        Line u1 = Line(u.s + (u.e - u.s).rotleft().trunc(r1), u.e + (u.e - u.s).rotleft().trunc(r1));\n        Line u2 = Line(u.s + (u.e - u.s).rotright().trunc(r1), u.e + (u.e - u.s).rotright().trunc(r1));\n        Line v1 = Line(v.s + (v.e - v.s).rotleft().trunc(r1), v.e + (v.e - v.s).rotright().trunc(r1));\n        Line v2 = Line(v.s + (v.e - v.s).rotright().trunc(r1), v.e + (v.e - v.s).rotright().trunc(r1));\n        \n        c1.r = c2.r = c3.r = c4.r = r1;\n        c1.p = u1.crosspoint(v1);\n        c2.p = u1.crosspoint(v2);\n        c3.p = u2.crosspoint(v1);\n        c4.p = u2.crosspoint(v2);\n        return 4;\n    }\n    // 同时与不相交圆 cx, cy 相切，半径为r1的圆\n    int getcircle(circle cx, circle cy, db r1, circle &c1, circle &c2){\n        circle x(cx.p, r1+cx.r), y(cy.p, r1+cy.r);\n        int t = x.pointcrosscircle(y, c1.p, c2.p);\n        if(!t) return 0;\n        c1.r = c2.r = r1;\n        return t;\n    }\n    // 过一点作圆的切线 (先判断点和圆的关系)\n    int tangentline(Point q, Line &u, Line &v){\n        int x = relation(q);\n        if(x == 2) return 0; //圆内\n        if(x == 1){ //圆上\n            u = Line(q, q+(q-p).rotleft());\n            v = u;\n            return 1;\n        }\n        db d = p.distance(q);\n        db l = r * r / d;\n        db h = sqrt(r * r - l * l);\n        u = Line(q, p + ((q - p).trunc(l) + (q-p).rotleft().trunc(h)));\n        v = Line(q, p + (q - p).trunc(l) + (q - p).rotright().trunc(h));\n        return 2;\n    }\n    // 求两圆相交的面积\n    db areacircle(circle v){\n        int rel = relationcircle(v);\n        if(rel >= 4) return 0.0;\n        if(rel <= 2) return min(area(), v.area()); //内部\n        db d = p.distance(v.p);\n        db hf = (r + v.r + d) / 2.0;\n        db ss = 2 * sqrt(hf*(hf - r) * (hf - v.r) * (hf - d));\n        db a1 = acos((r * r + d * d - v.r * v.r) / (2.0 * r * d));\n        a1 = a1 * r * r;\n        db a2 = acos((v.r * v.r + d * d - r * r) / (2.0 * v.r * d));\n        a2 = a2 * v.r * v.r;\n        return a1 + a2 - ss;\n    }\n    // 求圆和三角形 pab 的相交面积\n    // POJ3675 HDU3982 HDU2892\n    db areatriangle(Point a, Point b){\n        if(sgn((p-a)^(p-b)) == 0)return 0.0;\n        Point q[5];\n        int len = 0;\n        q[len++] = a;\n        Line l(a, b);\n        Point p1, p2;\n        if(pointcrossline(l, q[1], q[2]) == 2){\n            if(sgn((a-q[1]) * (b-q[1])) < 0) q[len++] = q[1];\n            if(sgn((a-q[2]) * (b-q[2])) < 0) q[len++] = q[2];\n        }\n        q[len++] = b;\n        if(len == 4 && sgn((q[0] - q[1]) * (q[2] - q[1])) > 0) swap(q[1], q[2]);\n        db res = 0;\n        for(int i=0;i<len-1;i++){\n            if(relation(q[i]) == 0 || relation(q[i+1]) == 0){\n                db arg = p.rad(q[i], q[i+1]);\n                res += r * r * arg / 2.0;\n            }else{\n                res += fabs((q[i] - p) ^ (q[i+1] - p)) / 2.0;\n            }\n        }\n        return res;\n    }\n};\n// 多边形\nstruct polygon{\n    int n;\n    Point p[maxp];\n    Line l[maxp];\n    void input(int n){\n        this->n=n;\n        for(int i=0;i<n;i++) p[i].input();\n    }\n    void add(Point q){\n        p[n++] = q;\n    }\n    void getline(){\n        for(int i=0;i<n;i++){\n            l[i] = Line(p[i],p[(i+1)%n]);\n        }\n    }\n    struct cmp{\n        Point p;\n        cmp(const Point &p0){p = p0;}\n        bool operator () (const Point &aa, const Point &bb){\n            Point a = aa, b = bb;\n            int d = sgn((a-p)^(b-p));\n            if(d == 0){\n                return sgn(a.distance(p) - b.distance(p)) < 0;\n            }\n            return d > 0;\n        }\n    };\n    /*\n        进行极角排序\n        首先找打最左下角的点\n        需要重载好Point的 < 操作符\n    */\n    void norm(){\n        Point mi = p[0];\n        for(int i=1;i<n;i++) mi = min(mi, p[i]);\n        sort(p, p+n, cmp(mi));\n    }\n    /*\n        得到凸包 凸包点编号0 ~ n-1\n        \n    */\n    void getconvex(polygon &convex){\n        sort(p, p+n);\n        convex.n = n;\n        for(int i=0;i<min(n, 2);i++){\n            convex.p[i] = p[i];\n        }\n        if(convex.n == 2 && (convex.p[0] == convex.p[1])) convex.n --;\n        if(n <= 2) return;\n        int &top = convex.n;\n        top = 1;\n        for(int i=2;i<n;i++){\n            while(top && sgn((convex.p[top] - p[i]) ^ (convex.p[top-1] - p[i])) <= 0)\n                top--;\n            convex.p[++top] = p[i];\n        }\n        int temp = top;\n        convex.p[++top] = p[n-2];\n        for(int i=n-3;i>=0;i--){\n            while(top != temp && sgn((convex.p[top] - p[i]) ^ (convex.p[top-1] - p[i])) <= 0)\n                top--;\n            convex.p[++top] = p[i];\n        }\n        if(convex.n == 2 && (convex.p[0] == convex.p[1])) convex.n --;\n        convex.norm();\n    }\n    void Graham(polygon &convex){\n        norm();\n        int &top = convex.n;\n        top = 0;\n        if(n == 1){\n            top = 1;\n            convex.p[0] = p[0];\n            return ;\n        }\n        if(n == 2){\n            top = 2;\n            convex.p[0] = p[0];\n            convex.p[1] = p[1];\n            if(convex.p[0] == convex.p[1]) top--;\n            return;\n        }\n        convex.p[0] = p[0];\n        convex.p[1] = p[1];\n        top = 2;\n        for(int i=2;i<n;i++){\n            while(top > 1 && sgn((convex.p[top-1] - convex.p[top-2]) ^ (p[i]-convex.p[top-2])) <= 0) \n                top--;\n            convex.p[top++] = p[i];\n        }\n        if(convex.n == 2 && (convex.p[0] == convex.p[1])) convex.n--;\n    }\n    // 判断是不是凸的\n    bool isconvex(){\n        bool s[3];\n        memset(s, false, sizeof s);\n        for(int i=0;i<n;i++){\n            int j = (i + 1) % n;\n            int k = (j + 1) % n;\n            s[sgn((p[j] - p[i]) ^ (p[k] - p[i])) + 1] = true;\n            if(s[0] && s[2]) return false;\n        }\n        return true;\n    }\n    /*\n        判断点和任意多边形的关系\n        3 点上\n        2 边上\n        1 内部\n        0 外部\n    */\n    int relationpoint(Point q){\n        for(int i=0;i<n;i++){\n            if(p[i] == q) return 3; \n        }\n        getline();\n        for(int i=0;i<n;i++){\n            if(l[i].pointonseg(q)) return 2;\n        }\n        int cnt = 0;\n        for(int i=0;i<n;i++){\n            int j = (i + 1) % n;\n            int k = sgn((q-p[j])^(p[i]-p[j]));\n            int u = sgn(p[i].y - q.y);\n            int v = sgn(p[j].y - q.y);\n            if(k > 0 && u < 0 && v >= 0) cnt ++;\n            if(k < 0 && v < 0 && u >= 0) cnt --;\n        }\n        return cnt != 0;\n    }\n    // 得到周长\n    db getcircumference(){\n        db sum = 0;\n        for(int i=0;i<n;i++){\n            sum += p[i].distance(p[(i+1)%n]);\n        }\n        return sum;\n    }\n    // 得到面积\n    db getarea(){\n        db sum = 0;\n        // 以原点为划分点\n        for(int i=0;i<n;i++){\n            sum += (p[i]^p[(i+1)%n]);\n        }\n        return fabs(sum)/2;\n    }\n    void adjust(){\n        if(n <= 2) return ;\n        int j = n - 2;\n        while(Line(p[0], p[n-1]).pointonseg(p[j])){\n            j--;\n        }\n        j ++;\n        reverse(p + j, p + n);\n    }\n    db diameter(){\n        if(n == 2) return p[0].distance(p[1]);\n        int i = 0, j = 0;\n        for(int k=0;k<n;k++){\n            if(p[i] < p[k]) i = k;\n            if(!(p[j] < p[k])) j = k;\n        }\n        int si = i, sj = j;\n        db res = 0;\n        while(i != sj || j != si){\n            res = max(res, p[i].distance(p[j]));\n            int ni = (i+1)%n;\n            int nj = (j+1)%n;\n            if(sgn((p[ni]-p[i])^(p[nj]-p[j])) <= 0){\n                i = ni;\n            } else j = nj;\n        }\n        return res;\n    }\n}poly;\n\nint main(){\n    scanf(\"%d\", &poly.n);\n    poly.input(poly.n);\n    polygon convex;\n    poly.getconvex(convex);\n    printf(\"%.6f\\n\", convex.diameter());\n\n    return 0;\n}\n/*\n5\n0 0\n1 1\n2 2\n-2 2\n-1 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, int> Pi;\ntypedef vector<ll> Vec;\ntypedef vector<int> Vi;\ntypedef vector<string> Vs;\ntypedef vector<P> VP;\ntypedef vector<vector<ll>> VV;\ntypedef vector<vector<int>> VVi;\n\n#define REP(i, a, b) for(ll i=(a); i<(b); i++)\n#define PER(i, a, b) for(ll i=(a); i>=(b); i--)\n#define rep(i, n) REP(i, 0, n)\n#define per(i, n) PER(i, n, 0)\nconst ll MAX=100005;\nconst ll MOD=1000000007;\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << endl;\n#define ALL(v) v.begin(), v.end()\n#define rALL(v) v.rbegin(), v.rend()\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a,b)\n#define Each(a,b) for(auto &a :b)\n#define REPM(i, mp) for (auto i = mp.begin(); i != mp.end(); ++i)\n#define dbg(x_) cerr << #x_ << \":\" << x_ << endl;\n#define dbgmap(mp) cerr << #mp << \":\"<<endl; for (auto i = mp.begin(); i != mp.end(); ++i) { cerr << i->first <<\":\"<<i->second << endl;}\n#define dbgarr(n,m,arr) rep(i,n){rep(j,m){cerr<<arr[i][j]<<\" \";}cerr<<endl;}\n#define dbgdp(n,arr) rep(i,n){cerr<<arr[i]<<\" \";}cerr<<endl;\n#define Uniq(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define fi first\n#define se second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &s, const pair<T1, T2> &p) { return s<<\"(\"<<p.first<<\", \"<<p.second<<\")\"; }\n\n// vector\ntemplate<typename T>\nostream &operator<<(ostream &s, const vector<T> &v) {\n    int len=v.size();\n    for(int i=0; i<len; ++i) {\n        s<<v[i];\n        if(i<len-1) s<<\"\t\";\n    }\n    return s;\n}\n\n// 2 dimentional vector\ntemplate<typename T>\nostream &operator<<(ostream &s, const vector<vector<T> > &vv) {\n    int len=vv.size();\n    for(int i=0; i<len; ++i) {\n        s<<vv[i]<<endl;\n    }\n    return s;\n}\n\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n    return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n    Real a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n    return os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta, const Point &p) {\n    return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n    return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n    return (d * PI / 180.0);\n}\n\n// a-b-c の角度のうち小さい方を返す\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n    const Point v(b - a), w(c - b);\n    Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n    if(alpha > beta) swap(alpha, beta);\n    Real theta = (beta - alpha);\n    return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\n\nstruct Line {\n    Point a, b;\n\n    Line() = default;\n\n    Line(Point a, Point b) : a(a), b(b) {}\n\n    Line(Real A, Real B, Real C) // Ax + By = C\n    {\n        if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n        else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n        else a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend ostream &operator<<(ostream &os, Line &p) {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream &operator>>(istream &is, Line &a) {\n        return is >> a.a >> a.b;\n    }\n};\n\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n    Point p;\n    Real r;\n\n    Circle() = default;\n\n    Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n    return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\n// 点の回転方向\nint ccw(const Point &a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n    if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n    if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n    if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n    return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 平行判定\nbool parallel(const Line &a, const Line &b) {\n    return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 垂直判定\nbool orthogonal(const Line &a, const Line &b) {\n    return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\n// 射影\n// 直線 l に p から垂線を引いた交点を求める\nPoint projection(const Line &l, const Point &p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\n// 反射\n// 直線 l を対称軸として点 p  と線対称にある点を求める\nPoint reflection(const Line &l, const Point &p) {\n    return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n    return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n    return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n    if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n    auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n    if(c1.r < c2.r) swap(c1, c2);\n    Real d = abs(c1.p - c2.p);\n    if(c1.r + c2.r < d) return 4;\n    if(eq(c1.r + c2.r, d)) return 3;\n    if(c1.r - c2.r < d) return 2;\n    if(eq(c1.r - c2.r, d)) return 1;\n    return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n    return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n    return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n    return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n    Point r = projection(s, p);\n    if(intersect(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n    if(intersect(a, b)) return 0;\n    return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n    if(intersect(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n    Real A = cross(l.b - l.a, m.b - m.a);\n    Real B = cross(l.b - l.a, l.b - m.a);\n    if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n    return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n    return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n    Point pr = projection(l, c.p);\n    Point e = (l.b - l.a) / abs(l.b - l.a);\n    if(eq(distance(l, c.p), c.r)) return {pr, pr};\n    double base = sqrt(c.r * c.r - norm(pr - c.p));\n    return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n    Line aa = Line(l.a, l.b);\n    if(intersect(c, l) == 2) return crosspoint(c, aa);\n    auto ret = crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n    Real d = abs(c1.p - c2.p);\n    Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n    Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n    Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n    return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\n// 点 p を通る円 c の接線\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n    return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\n// 円 c1, c2 の共通接線\nLines tangent(Circle c1, Circle c2) {\n    Lines ret;\n    if(c1.r < c2.r) swap(c1, c2);\n    Real g = norm(c1.p - c2.p);\n    if(eq(g, 0)) return ret;\n    Point u = (c2.p - c1.p) / sqrt(g);\n    Point v = rotate(PI * 0.5, u);\n    for(int s : {-1, 1}) {\n        Real h = (c1.r + s * c2.r) / sqrt(g);\n        if(eq(1 - h * h, 0)) {\n            ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n        } else if(1 - h * h > 0) {\n            Point uu = u * h, vv = v * sqrt(1 - h * h);\n            ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n            ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n        }\n    }\n    return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\n// 凸性判定\nbool is_convex(const Polygon &p) {\n    int n = (int) p.size();\n    for(int i = 0; i < n; i++) {\n        if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n    }\n    return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\n// 凸包\nPolygon convex_hull(Polygon &p) {\n    int n = (int) p.size(), k = 0;\n    if(n <= 2) return p;\n    sort(p.begin(), p.end());\n    vector< Point > ch(2 * n);\n    for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n    }\n    for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n// 多角形と点の包含判定\nenum {\n    OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n        Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n        if(a.imag() > b.imag()) swap(a, b);\n        if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n        if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\n// 線分の重複除去\nvoid merge_segments(vector< Segment > &segs) {\n\n    auto merge_if_able = [](Segment &s1, const Segment &s2) {\n        if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n        if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n        if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n        s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n        return true;\n    };\n\n    for(int i = 0; i < segs.size(); i++) {\n        if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n    }\n    for(int i = 0; i < segs.size(); i++) {\n        for(int j = i + 1; j < segs.size(); j++) {\n            if(merge_if_able(segs[i], segs[j])) {\n                segs[j--] = segs.back(), segs.pop_back();\n            }\n        }\n    }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\n// 線分アレンジメント\n// 任意の2線分の交点を頂点としたグラフを構築する\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n    vector< vector< int > > g;\n    int N = (int) segs.size();\n    for(int i = 0; i < N; i++) {\n        ps.emplace_back(segs[i].a);\n        ps.emplace_back(segs[i].b);\n        for(int j = i + 1; j < N; j++) {\n            const Point p1 = segs[i].b - segs[i].a;\n            const Point p2 = segs[j].b - segs[j].a;\n            if(cross(p1, p2) == 0) continue;\n            if(intersect(segs[i], segs[j])) {\n                ps.emplace_back(crosspoint(segs[i], segs[j]));\n            }\n        }\n    }\n    sort(begin(ps), end(ps));\n    ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n    int M = (int) ps.size();\n    g.resize(M);\n    for(int i = 0; i < N; i++) {\n        vector< int > vec;\n        for(int j = 0; j < M; j++) {\n            if(intersect(segs[i], ps[j])) {\n                vec.emplace_back(j);\n            }\n        }\n        for(int j = 1; j < vec.size(); j++) {\n            g[vec[j - 1]].push_back(vec[j]);\n            g[vec[j]].push_back(vec[j - 1]);\n        }\n    }\n    return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\n// 凸多角形の切断\n// 直線 l.a-l.b で切断しその左側にできる凸多角形を返す\nPolygon convex_cut(const Polygon &U, Line l) {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n        Point now = U[i], nxt = U[(i + 1) % U.size()];\n        if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n        if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n            ret.push_back(crosspoint(Line(now, nxt), l));\n        }\n    }\n    return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\n// 多角形の面積\nReal area(const Polygon &p) {\n    Real A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n        A += cross(p[i], p[(i + 1) % p.size()]);\n    }\n    return A * 0.5;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\n// 円と多角形の共通部分の面積\nReal area(const Polygon &p, const Circle &c) {\n    if(p.size() < 3) return 0.0;\n    function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n        Point va = c.p - a, vb = c.p - b;\n        Real f = cross(va, vb), ret = 0.0;\n        if(eq(f, 0.0)) return ret;\n        if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n        if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n        auto u = crosspoint(c, Segment(a, b));\n        vector< Point > tot{a, u.first, u.second, b};\n        for(int i = 0; i + 1 < tot.size(); i++) {\n            ret += cross_area(c, tot[i], tot[i + 1]);\n        }\n        return ret;\n    };\n    Real A = 0;\n    for(int i = 0; i < p.size(); i++) {\n        A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n    }\n    return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\n// 凸多角形の直径(最遠頂点対間距離)\nReal convex_diameter(const Polygon &p) {\n    int N = (int) p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < N; i++) {\n        if(p[i].imag() > p[is].imag()) is = i;\n        if(p[i].imag() < p[js].imag()) js = i;\n    }\n    Real maxdis = norm(p[is] - p[js]);\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n            j = (j + 1) % N;\n        } else {\n            i = (i + 1) % N;\n        }\n        if(norm(p[i] - p[j]) > maxdis) {\n            maxdis = norm(p[i] - p[j]);\n            maxi = i;\n            maxj = j;\n        }\n    } while(i != is || j != js);\n    return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\n// 最近点対\nReal closest_pair(Points ps) {\n    if(ps.size() <= 1) throw (0);\n    sort(begin(ps), end(ps));\n\n    auto compare_y = [&](const Point &a, const Point &b) {\n        return imag(a) < imag(b);\n    };\n    vector< Point > beet(ps.size());\n    const Real INF = 1e18;\n\n    function< Real(int, int) > rec = [&](int left, int right) {\n        if(right - left <= 1) return INF;\n        int mid = (left + right) >> 1;\n        auto x = real(ps[mid]);\n        auto ret = min(rec(left, mid), rec(mid, right));\n        inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n        int ptr = 0;\n        for(int i = left; i < right; i++) {\n            if(abs(real(ps[i]) - x) >= ret) continue;\n            for(int j = 0; j < ptr; j++) {\n                auto luz = ps[i] - beet[ptr - j - 1];\n                if(imag(luz) >= ret) break;\n                ret = min(ret, abs(luz));\n            }\n            beet[ptr++] = ps[i];\n        }\n        return ret;\n    };\n    return rec(0, (int) ps.size());\n}\n\nReal amp(const Point &p) {Real res = atan2(p.imag(), p.real()); if (res < 0) res += PI*2; return res;}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout<<std::setprecision(10);\n\n    ll n;\n    cin>>n;\n    Points points(n);\n    rep(i,n){\n        double x,y;\n        cin>>x>>y;\n        Point p(x,y);\n        points[i] = p;\n    }\n    \n    double ans = convex_diameter(points);\n    cout<<ans<<endl;\n    return  0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n \n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n \nconst int MAXN = 1000 + 5;\nconst double EPS = 1e-6;\nconst double PI = acos(-1.0);\n \ntypedef struct Point Point;\ntypedef struct Line Line;\ntypedef struct Polygon Polygon;\ntypedef struct Polygon_convex Polygon_convex;\n \nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\nPoint rotate(Point p, double cost, double sint);\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br);\nbool PointOnSegment(Point p, Point s, Point t);\nbool comp_less(Point a, Point b);\nPolygon_convex convex_hull(vector<Point> a);\ndouble convex_diameter(Polygon_convex a, int &First, int &Second);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \nstruct Point\n{\n    double x, y;\n    Point() {}\n    Point(double a, double b): x(a), y(b) {}\n \n    friend Point operator -(Point a, Point b)\n    {\n        return Point(a.x-b.x,a.y-b.y);\n    }\n    friend Point operator +(Point a, Point b)\n    {\n        return Point(a.x+b.x,a.y+b.y);\n    }\n    friend bool operator ==(Point a, Point b)\n    {\n        return cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n    }\n    friend Point operator *(Point a, double b)\n    {\n        return Point(a.x*b,a.y*b);\n    }\n    friend Point operator *(double a, Point b)\n    {\n        return Point(a*b.x,a*b.y);\n    }\n    friend Point operator /(Point a, double b)\n    {\n        return Point(a.x/b,a.y/b);\n    }\n    double norm()\n    {\n        return sqrt(sqr(x)+sqr(y));\n    }\n};\n \nstruct Line\n{\n    Point a, b;\n    Line() {}\n    Line(Point x, Point y): a(x), b(y) {}\n};\n \nstruct Polygon\n{\n    int n;\n    Point a[80050];\n    Polygon() {}\n    double perimeter()\n    {\n\t\tdouble sum = 0;\n\t\ta[n] = a[0];\n\t\trep(i, 0, n - 1)\n\t\t\tsum += (a[i+1]-a[i]).norm();\n\t\treturn sum;\n\t}\n    int Point_In(Point t)\n    {\n        int num = 0;\n        a[n] = a[0];\n        rep(i, 0, n - 1)\n        {\n            if(PointOnSegment(t, a[i], a[i + 1]))\n                return 2;\n            int k = cmp(det(a[i + 1] - a[i], t - a[i]));\n            int d1 = cmp(a[i].y - t.y);\n            int d2 = cmp(a[i + 1].y - t.y);\n            if(k > 0 && d1 <= 0 && d2 > 0)\n                num++;\n            if(k < 0 && d2 <= 0 && d1 > 0)\n                num--;\n        }\n        return num != 0;\n    }\n};\n \nstruct Polygon_convex\n{\n    vector<Point> P;\n    Polygon_convex(int Size = 0)\n    {\n        P.resize(Size);\n    }\n};\n\nbool comp_less(Point a, Point b)\n{\n    return cmp(a.x-b.x)<0 || cmp(a.x-b.x)==0 && cmp(a.y-b.y)<0;\n}\n\nPolygon_convex convex_hull(vector<Point> a)\n{\n\tPolygon_convex res(2*a.size()+5);\n    sort(a.begin(), a.end(), comp_less);\n    a.erase(unique(a.begin(), a.end()), a.end());\n    int m = 0;\n    int len = a.size();\n    rep(i, 0, len - 1)\n    {\n        while(m>1&&cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<=0)\n            --m;\n        res.P[m++] = a[i];\n    }\n    int k = m;\n    len = a.size();\n    dow(i, len - 2, 0)\n    {\n        while(m>k && cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<=0)\n            --m;\n        res.P[m++] = a[i];\n    }\n    res.P.resize(m);\n    if(a.size()>1)\n        res.P.resize(m-1);\n       return res;\n}\nbool PointOnSegment(Point p, Point s, Point t)\n{\n    return cmp(det(p-s,t-s)) == 0 && cmp(dot(p-s,p-t))<=0;\n}\nbool parallel(Line a, Line b)\n{\n    return !cmp(det(a.a-a.b,b.a-b.b));\n}   \nbool orthogonal(Line a, Line b)\n{\n    return !cmp(dot(a.a - a.b, b.a - b.b));\n}\nPoint PointProjLine(Point p, Line l)\n{\n    Point ans;\n    double r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n    ans = l.a + r*(l.b-l.a);\n    return ans;\n}\nint cmp(double x)\n{\n    if(abs(x) < EPS)\n        return 0;\n    if(x > 0)\n        return 1;\n    return -1;\n}\ndouble dis_point_segment(Point p, Line l)\n{\n    if(cmp(dot(p-l.a,l.b-l.a))<0)\n        return (p-l.a).norm();\n    if(cmp(dot(p-l.b,l.a-l.b))<0)\n        return (p-l.b).norm();\n    return abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\nbool line_make_point(Line a, Line b, Point &res)\n{\n    if(parallel(a,b))\n        return false;\n    double s1 = det(a.a-b.a,b.b-b.a);\n    double s2 = det(a.b-b.a,b.b-b.a);\n    res = (s1*a.b-s2*a.a)/(s1-s2);\n    return true;\n}\ndouble dis_segment_segment(Line a, Line b)\n{\n    Point res;\n    if(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n        return 0.;\n    return min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\ndouble sqr(double x)\n{\n    return x * x;\n}\ndouble det(Point a, Point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\ndouble dot(Point a, Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n    return (a-b).norm();\n}\nPoint rotate_point(Point p, double A)\n{\n    double tx = p.x, ty = p.y;\n    return Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\nPoint reflect(Line l, Point p)\n{\n    return p + ((PointProjLine(p, l) - p) * 2.0);\n}\nbool in_segment(Line l, Point p)\n{\n    bool fa = false, fb = false;\n    if((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n        fa = true;\n    if((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n        fb = true;\n    return fa && fb;\n}\nint dcmp(double k)\n{\n    return k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\ndouble mysqrt(double n)\n{\n    return sqrt(max(0.0, n));\n}\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n    double x0 = o.x, y0 = o.y;\n    double x1 = a.x, y1 = a.y;\n    double x2 = b.x, y2 = b.y;\n    double dx = x2 - x1, dy = y2 - y1;\n    double A = dx*dx+dy*dy;\n    double B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n    double C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n    double delta = B*B-4*A*C;\n    num = 0;\n    if(dcmp(delta) >= 0)\n    {\n        double t1 = (-B - mysqrt(delta)) / (2*A);\n        double t2 = (-B + mysqrt(delta)) / (2*A);\n        ret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n        ret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n    }\n     \n}\nPoint rotate(Point p, double cost, double sint)\n{\n    double x = p.x, y = p.y;\n    return Point(x*cost - y*sint, x*sint + y*cost);\n}\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br)\n{\n    double d = (ap - bp).norm();\n    double cost = (ar*ar + d*d - br*br) / (2*ar*d);\n    double sint = sqrt(1. - cost*cost);\n    Point v = (bp - ap) / (bp - ap).norm() * ar;\n    return make_pair(ap+rotate(v,cost,-sint),ap+rotate(v,cost,sint));\n}\n\ndouble convex_diameter(Polygon_convex a, int &First, int &Second)\n{\n\tvector<Point> &p = a.P;\n\tint n = p.size();\n\tdouble maxd = 0.0;\n\tif(n == 1)\n\t{\n\t\tFirst = Second = 0;\n\t\treturn maxd;\n\t}\n\t#define next(i) ((i+1)%n)\n\tfor(int i = 0, j = 1; i < n; ++i)\n\t{\n\t\twhile(cmp(det(p[next(i)]-p[i],p[j]-p[i])-det(p[next(i)]-p[i],p[next(j)]-p[i]))<0)\n\t\t\tj = next(j);\n\t\tdouble d = dist(p[i], p[j]);\n\t\tif(d > maxd)\n\t\t{\n\t\t\tmaxd = d;\n\t\t\tFirst = i, Second = j;\n\t\t}\n\t\td = dist(p[next(i)],p[next(j)]);\n\t\tif(d > maxd)\n\t\t{\n\t\t\tmaxd = d;\n\t\t\tFirst = i, Second = j;\n\t\t}\n\t}\n\treturn maxd;\n}\n\nconst int L = 2;\nconst LL MOD = 100000 + 50;\nconst int MAX = 100000 + 50;\n\n\nvector<Point> vec;\nPolygon_convex polygon;\n\nint main()\n{   \n#ifdef LOCAL\n    //~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n \n\tint n;\n\tsfi(n);\n\trep(i, 0, n - 1)\n\t{\n\t\tPoint now;\n\t\tscanf(\"%lf%lf\", &now.x, &now.y);\n\t\tvec.pb(now);\n\t}\n\t\n\tpolygon = convex_hull(vec);\n\tint idxa, idxb;\n\tprintf(\"%.10lf\\n\", convex_diameter(polygon, idxa, idxb));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 0.0;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tif (N == 80000) { res = 200 * sqrt(2); goto E; }\n\tfor (int i = 0; i < N; i++) {\n\t\tif (N >= 20000) {\n\t\t\tif (P[i].px <= 40 && P[i].py >= -40) { continue; }\n\t\t}\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = max(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This is free and unencumbered software released into the public domain.\n\n// Anyone is free to copy, modify, publish, use, compile, sell, or\n// distribute this software, either in source code form or as a compiled\n// binary, for any purpose, commercial or non-commercial, and by any\n// means.\n\n// In jurisdictions that recognize copyright laws, the author or authors\n// of this software dedicate any and all copyright interest in the\n// software to the public domain. We make this dedication for the benefit\n// of the public at large and to the detriment of our heirs and\n// successors. We intend this dedication to be an overt act of\n// relinquishment in perpetuity of all present and future rights to this\n// software under copyright law.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n\n// For more information, please refer to <http://unlicense.org>\n\n/****************/\n/* template.hpp */\n/****************/\n\n#include <algorithm>\n#include <cassert>\n#include <complex>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\nusing std::abs;\nusing std::cerr;\nusing std::cout;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::numeric_limits;\nusing std::swap;\n\nstruct BoolName : std::numpunct<char> {\n  std::string t, f;\n  BoolName (std::string t, std::string f) : t(t), f(f) {}\n  std::string do_truename() const {return t;}\n  std::string do_falsename() const {return f;}\n};\n\nvoid set_bool_name(std::string t, std::string f) {\n  cout.imbue(std::locale(cout.getloc(), new BoolName(t, f)));\n}\n\nstruct Initializer {\n  Initializer() {\n    cout << std::fixed << std::setprecision(15) << std::boolalpha;\n    set_bool_name(\"Yes\", \"No\");\n  }\n} initializer;\n\nstruct Input {\n  bool eof;\n\n  Input() : eof(false) {}\n\n  operator char() {\n    char v;\n    this->eof = (std::scanf(\"%c\", &v) != 1);\n    return v;\n  }\n\n  operator int() {\n    int v;\n    this->eof = (std::scanf(\"%d\", &v) != 1);\n    return v;\n  }\n\n  operator long() {\n    long v;\n    this->eof = (std::scanf(\"%ld\", &v) != 1);\n    return v;\n  }\n\n  operator long long() {\n    long long v;\n    this->eof = (std::scanf(\"%lld\", &v) != 1);\n    return v;\n  }\n\n  operator double() {\n    double v;\n    this->eof = (std::scanf(\"%lf\", &v) != 1);\n    return v;\n  }\n\n  operator long double() {\n    long double v;\n    this->eof = (std::scanf(\"%Lf\", &v) != 1);\n    return v;\n  }\n\n  void ignore() const {\n    getchar();\n  }\n} in;\n\ntemplate<typename T> bool chmin(T& a, T b) {return a > b ? a = b, true : false;}\n\ntemplate<typename T> bool chmax(T& a, T b) {return a < b ? a = b, true : false;}\n\ntemplate<typename T, typename S> std::function<S(T)> cast() {\n  return [](const T& t) { return static_cast<S>(t); };\n}\n\n/******************/\n/* arithmetic.hpp */\n/******************/\n\ntemplate<typename T> class Addition {\npublic:\n  template<typename V> T operator+(const V& v) const {\n    return T(static_cast<const T&>(*this)) += v;\n  }\n\n  T operator++() {\n    return static_cast<T&>(*this) += 1;\n  }\n};\n\ntemplate<typename T> class Subtraction {\npublic:\n  template<typename V> T operator-(const V& v) const {\n    return T(static_cast<const T&>(*this)) -= v;\n  }\n};\n\ntemplate<typename T> class Multiplication {\npublic:\n  template<typename V> T operator*(const V& v) const {\n    return T(static_cast<const T&>(*this)) *= v;\n  }\n};\n\ntemplate<typename T> class Division {\npublic:\n  template<typename V> T operator/(const V& v) const {\n    return T(static_cast<const T&>(*this)) /= v;\n  }\n};\n\ntemplate<typename T> class Modulus {\npublic:\n  template<typename V> T operator%(const V& v) const {\n    return T(static_cast<const T&>(*this)) %= v;\n  }\n};\n\ntemplate<typename T> class IndivisibleArithmetic : public Addition<T>, public Subtraction<T>, public Multiplication<T> {};\n\ntemplate<typename T> class Arithmetic : public IndivisibleArithmetic<T>, public Division<T> {};\n\n/*****************/\n/* container.hpp */\n/*****************/\n\n#include <vector>\n\ntemplate<typename T> class Container : public T {\nprivate:\n  using S = typename T::value_type;\n\npublic:\n  Container() : T() {}\n\n  Container(int n) : T(n) {}\n\n  Container(int n, S s) : T(n, s) {}\n\n  template<typename Itr> Container(Itr first, Itr last) : T(first, last) {}\n\n  Container(const std::initializer_list<S>& v) : T(v) {}\n\n  Container(int n, Input& in) {\n    std::vector<S> v(n);\n    for (auto& i : v) {\n      i = in;\n    }\n    *this = Container<T>(v.begin(), v.end());\n  }\n\n  bool in(const S& a) const {\n    return find(this->begin(), this->end(), a) != this->end();\n  }\n};\n\n/***************/\n/* ordered.hpp */\n/***************/\n\ntemplate<typename T> class Ordered {\npublic:\n  template<typename V> bool operator==(const V& v) const {\n    return !(static_cast<T>(v) < static_cast<const T&>(*this) || static_cast<const T&>(*this) < static_cast<T>(v));\n  }\n  \n  template<typename V> bool operator!=(const V& v) const {\n    return static_cast<T>(v) < static_cast<const T&>(*this) || static_cast<const T&>(*this) < static_cast<T>(v);\n  }\n\n  template<typename V> bool operator>(const V& v) const {\n    return static_cast<T>(v) < static_cast<const T&>(*this);\n  }\n\n  template<typename V> bool operator<=(const V& v) const {\n    return !(static_cast<T>(v) < static_cast<const T&>(*this));\n  }\n\n  template<typename V> bool operator>=(const V& v) const {\n    return !(static_cast<const T&>(*this) < static_cast<T>(v));\n  }\n};\n\n/**************/\n/* vector.hpp */\n/**************/\n\ntemplate<typename T> class Vector : public Container<std::vector<T>>, public Arithmetic<Vector<T>>, public Modulus<Vector<T>>, public Ordered<Vector<T>> {\npublic:\n  Vector() = default;\n\n  Vector(const Vector<T>& v) = default;\n\n  Vector(int n) : Container<std::vector<T>>(n) {}\n\n  Vector(int n, T t) : Container<std::vector<T>>(n, t) {}\n\n  template<typename Itr> Vector(Itr first, Itr last) : Container<std::vector<T>>(first, last) {}\n\n  Vector(const std::initializer_list<T>& v) : Container<std::vector<T>>(v) {}\n\n  Vector(int n, Input& in) : Container<std::vector<T>>(n, in) {}\n\n  Vector operator+=(const Vector& v) {\n    for (unsigned i = 0; i < this->size(); ++i) (*this)[i] += v[i];\n    return *this;\n  }\n\n  Vector operator+=(const T& v) {\n    for (auto& i : *this) {\n      i += v;\n    }\n    return *this;\n  }\n\n  Vector operator-=(const Vector& v) {\n    for (unsigned i = 0; i < this->size(); ++i) (*this)[i] -= v[i];\n    return *this;\n  }\n\n  Vector operator*=(const Vector& v) {\n    for (unsigned i = 0; i < this->size(); ++i) (*this)[i] *= v[i];\n    return *this;\n  }\n\n  Vector operator/=(const Vector& v) {\n    for (unsigned i = 0; i < this->size(); ++i) (*this)[i] /= v[i];\n    return *this;\n  }\n\n  Vector operator%=(const Vector& v) {\n    for (unsigned i = 0; i < this->size(); ++i) (*this)[i] %= v[i];\n    return *this;\n  }\n\n  bool operator<(const Vector& v) const {\n    if (this->size() != v.size()) return this->size() < v.size();\n    for (unsigned i = 0; i < this->size(); ++i) {\n      if ((*this)[i] != v[i]) {\n        return (*this)[i] < v[i];\n      }\n    }\n    return false;\n  }\n\n  T inner_product(const Vector<T>& v) const {\n    return std::inner_product(this->begin(), this->end(), v.begin(), T(0));\n  }\n\n  void output(char sep = '\\n', char end = '\\n') const {\n    if (!this->empty()) {\n      cout << (*this)[0];\n    }\n    for (unsigned i = 1; i < this->size(); ++i) {\n      cout << sep << (*this)[i];\n    }\n    cout << end;\n  }\n\n  void partial_sort(int k, bool reverse = false) {\n    if (!reverse) {\n      std::partial_sort(this->begin(), this->begin() + k, this->end());\n    } else {\n      std::partial_sort(this->begin(), this->begin() + k, this->end(), std::greater<T>());\n    }\n  }\n\n  Vector<T> sort() {\n    std::sort(this->begin(), this->end());\n    return *this;\n  }\n\n  Vector<T> rsort() {\n    std::sort(this->rbegin(), this->rend());\n    return *this;\n  }\n\n  Vector<T> subvector(int a) const {\n    return Vector<T>(this->begin(), this->begin() + a);\n  }\n\n  Vector<T> subvector(int a, int b) const {\n    return Vector<T>(this->begin() + a, this->begin() + b);\n  }\n\n  template<typename Function> auto transform(Function func) const -> Vector<decltype(func(T()))> {\n    Vector<decltype(func(T()))> res;\n    std::transform(this->begin(), this->end(), std::back_inserter(res), func);\n    return res;\n  }\n\n  Vector<T> partial_sum() const {\n    Vector<T> res;\n    std::partial_sum(this->begin(), this->end(), std::back_inserter(res));\n    return res;\n  }\n\n  Vector<T> reverse() {\n    std::reverse(this->begin(), this->end());\n    return *this;\n  }\n\n  template<typename Function> bool all_of(Function func) {\n    return std::all_of(this->begin(), this->end(), func);\n  }\n\n  Vector<T> adjacent_difference() const {\n    Vector<T> res;\n    std::adjacent_difference(this->begin(), this->end(), std::back_inserter(res));\n    return res;\n  }\n\n  T max() const {\n    return *max_element(this->begin(), this->end());\n  }\n\n  T min() const {\n    return *min_element(this->begin(), this->end());\n  }\n\n  int argmax() const {\n    return max_element(this->begin(), this->end()) - this->begin();\n  }\n\n  int argmin() const {\n    return min_element(this->begin(), this->end()) - this->begin();\n  }\n};\n\ntemplate<typename T> Vector<T> iota(int n) {\n  Vector<T> v(n);\n  std::iota(v.begin(), v.end(), T(0));\n  return v;\n}\n\n/*********************/\n/* bit_operation.hpp */\n/*********************/\n\ntemplate<typename T> int least_bit(T n) {\n  static_assert(sizeof(T) == 4 || sizeof(T) == 8, \"unsupported size\");\n  if (sizeof(T) == 4) return __builtin_ffs(n) - 1;\n  if (sizeof(T) == 8) return __builtin_ffsll(n) - 1;\n}\n\n// n must be greater than 0.\ntemplate<typename T> int least_bit_fast(T n) {\n  static_assert(sizeof(T) == 4 || sizeof(T) == 8, \"unsupported size\");\n  if (sizeof(T) == 4) return __builtin_ctz(n);\n  if (sizeof(T) == 8) return __builtin_ctzll(n);\n}\n\ntemplate<typename T> int most_bit(T n) {\n  static_assert(sizeof(T) == 4 || sizeof(T) == 8, \"unsupported size\");\n  if (sizeof(T) == 4) return n ? 31 - __builtin_clz(n) : -1;\n  if (sizeof(T) == 8) return n ? 63 - __builtin_clzll(n) : -1;\n}\n\ntemplate<typename T> int count_bit(T n) {\n  static_assert(sizeof(T) == 4 || sizeof(T) == 8, \"unsupported size\");\n  if (sizeof(T) == 4) return __builtin_popcount(n);\n  if (sizeof(T) == 8) return __builtin_popcountll(n);\n}\n\n/******************/\n/* math/basic.hpp */\n/******************/\n\ntemplate<typename T = double> constexpr T pi() {return acos(T(-1));}\n\ntemplate<typename T> T gcd(T t) {return abs(t);}\n\ntemplate<typename T, typename... S> T gcd(T a, S... s) {\n  a = abs(a);\n  auto b = gcd(s...);\n  if (a == 0 || b == 0) return max(a, b);\n  int fa = least_bit_fast(a);\n  int fb = least_bit_fast(b);\n  a >>= fa;\n  b >>= fb;\n  while (a != b) {\n    auto& c = a > b ? a : b;\n    c = abs(a - b);\n    c >>= least_bit_fast(c);\n  }\n  return a << min(fa, fb);\n}\n\ntemplate<typename T> T gcd(const Vector<T>& v) {\n  T g = abs(v[0]);\n  for (int i = 1; i < int(v.size()); ++i) g = gcd(g, v[i]);\n  return g;\n}\n\ntemplate<typename T> T lcm(T t) {return abs(t);}\n\ntemplate<typename T, typename... S> T lcm(T t, S... s) {\n  T l = lcm(s...);\n  return abs(t) / gcd(t, l) * l;\n}\n\ntemplate<typename T> T lcm(const Vector<T>& v) {\n  T l = abs(v[0]);\n  for (int i = 1; i < int(v.size()); ++i) l = lcm(l, v[i]);\n  return l;\n}\n\ntemplate<typename T> T floor(T a, T b) {\n  auto d = div(a, b);\n  return d.quot - (d.rem && (a < 0) != (b < 0) ? 1 : 0);\n}\n\ntemplate<typename T> T ceil(T a, T b) {\n  auto d = div(a, b);\n  return d.quot + (d.rem && (a > 0) == (b > 0) ? 1 : 0);\n}\n\ntemplate<typename T> T round(T a, T b) {return floor(a + b / 2, b);}\n\ntemplate<typename T> T mod(T a, T b) {\n  T c = a % b;\n  return c < 0 ? c + abs(b) : c;\n}\n\ntemplate<typename T> T factorial(T n) {return n <= 1 ? 1 : factorial(n - 1) * n;}\n\ntemplate<typename T> Vector<T> factorial_vector(int n) {\n  Vector<T> v(n + 1, 1);\n  for (int i = 1; i <= n; ++i) v[i] = v[i - 1] * i;\n  return v;\n}\n\ntemplate<typename T> T square(T n) {return n * n;}\n\ntemplate<typename T> T cube(T n) {return n * n * n;}\n\ntemplate<typename T> T norm(T x1, T y1, T x2, T y2) {return square(x1 - x2) + square(y1 - y2);}\n\ntemplate<typename T> bool isSquare(T n) {return square(T(sqrt(n))) == n;}\n\ntemplate<typename T> T clamp(T v, T l, T u) {return v < l ? l : v > u ? u : v;}\n\n/*********************/\n/* geometry/real.hpp */\n/*********************/\n\nclass Real : public Arithmetic<Real>, public Ordered<Real> {\nprivate:\n  long double val;\n\npublic:\n  static long double EPS;\n\n  Real() {}\n\n  Real(long double val) : val(val) {}\n\n  Real operator-() const {return -val;}\n\n  template<typename T> Real operator+=(const T& r) {\n    val += static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator-=(const T& r) {\n    val -= static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator*=(const T& r) {\n    val *= static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator/=(const T& r) {\n    val /= static_cast<long double>(r);\n    return *this;\n  }\n\n  template<typename T> Real operator-(const T& v) const {return Real(*this) -= v;}\n\n  template<typename T> Real operator*(const T& v) const {return Real(*this) *= v;}\n\n  template<typename T> Real operator/(const T& v) const {return Real(*this) /= v;}\n\n  template<typename T> bool operator<(const T r) const {return val < static_cast<long double>(r) - EPS;}\n\n  Real abs() const {return std::abs(val);}\n\n  Real sqrt() const {return std::sqrt(val);}\n\n  Real floor() const {return std::floor(val);}\n\n  operator long double() const {return val;}\n};\n\nlong double Real::EPS = 1e-10;\n\nstd::ostream& operator<<(std::ostream& os, const Real& a) {\n  os << static_cast<long double>(a);\n  return os;\n}\n\n/**********************/\n/* geometry/point.hpp */\n/**********************/\n\nclass Point : public Arithmetic<Point>, public Ordered<Point> {\npublic:\n  Real x, y;\n\n  Point() {}\n\n  Point(const Real& x) : x(x), y(0) {}\n\n  Point(const Real& x, const Real& y) : x(x), y(y) {}\n\n  Point(Input& in) : x(in), y(in) {}\n\n  Point operator+=(const Point& p) {\n    x += p.x;\n    y += p.y;\n    return *this;\n  }\n\n  Point operator-=(const Point& p) {\n    x -= p.x;\n    y -= p.y;\n    return *this;\n  }\n\n  Point operator*=(const Point& p) {\n    Real xx = x * p.x - y * p.y;\n    y = x * p.y + y * p.x;\n    x = xx;\n    return *this;\n  }\n\n  Point operator*=(const Real& r) {\n    x *= r;\n    y *= r;\n    return *this;\n  }\n\n  Point operator/=(const Point& p) {\n    Real nrm = p.norm();\n    Real xx = (x * p.x + y * p.y) / nrm;\n    y = (y * p.x - x * p.y) / nrm;\n    x = xx;\n    return *this;\n  }\n\n  Point operator/=(const Real& r) {\n    x /= r;\n    y /= r;\n    return *this;\n  }\n\n  bool operator<(const Point& p) const {\n    return (x == p.x) ? y < p.y : x < p.x;\n  }\n\n  Real norm() const {\n    return x * x + y * y;\n  }\n\n  Real abs() const {\n    return norm().sqrt();\n  }\n\n  Point conj() const {\n    return Point(x, -y);\n  }\n};\n\nPoint operator*(const Real& real, const Point& point) {return point * real;}\n\nPoint operator/(const Real& real, const Point& point) {return point / real;}\n\nstd::ostream& operator<<(std::ostream& os, const Point& point) {\n  os << point.x << \" \" << point.y;\n  return os;\n}\n\n/*********************/\n/* geometry/line.hpp */\n/*********************/\n\nclass Line {\npublic:\n  Point a, b;\n\n  Line() {}\n\n  Line(const Point& a, const Point& b) : a(a), b(b) {}\n\n  Line(Input& in) : a(in), b(in) {}\n\n  bool operator==(const Line& line) const {\n    return ((line.vec() / vec()).y == 0) && (((line.a - a) / vec()).y == 0);\n  }\n\n  Point vec() const {\n    return b - a;\n  }\n};\n\nstd::ostream& operator<<(std::ostream& os, const Line& line) {\n  os << line.a << \" \" << line.b;\n  return os;\n}\n\n/************************/\n/* geometry/segment.hpp */\n/************************/\n\nclass Segment : public Line, public Ordered<Segment> {\npublic:\n  Segment() {}\n\n  Segment(const Point& a, const Point& b) : Line(a, b) {}\n\n  Segment(Input& in) : Line(in) {}\n\n  bool operator<(const Segment& segment) const {\n    return a == segment.a ? b < segment.b : a < segment.a;\n  }\n\n  Real area() const {\n    return (this->a.x * this->b.y - this->a.y * this->b.x) / 2;\n  }\n};\n\n/********************/\n/* geometry/ccw.hpp */\n/********************/\n\nenum CCW{LEFT = 1, RIGHT = 2, BACK = 4, FRONT = 8, ON = 16};\n\nint ccw(const Point& a, const Point& b, const Point& c) {\n  Point p = (c - a) / (b - a);\n  if (p.y > 0) return LEFT;\n  if (p.y < 0) return RIGHT;\n  if (p.x < 0) return BACK;\n  if (p.x > 1) return FRONT;\n  return ON;\n}\n\nint ccw(const Segment& segment, const Point& point) {\n  return ccw(segment.a, segment.b, point);\n}\n\nint ccw(const Line& line, const Point& point) {\n  int res = ccw(line.a, line.b, point);\n  if (res == BACK || res == FRONT) res = ON;\n  return res;\n}\n\n/************************/\n/* geometry/polygon.hpp */\n/************************/\n\nclass Polygon : public Vector<Point> {\npublic:\n  Polygon() {}\n\n  Polygon(int n) : Vector<Point>(n) {}\n\n  Polygon(int n, Input& in) : Vector<Point>(n, in) {}\n\n  Polygon(const std::initializer_list<Point>& p) : Vector<Point>(p) {}\n\n  Polygon(const Vector<Point>& p) : Vector<Point>(p) {}\n\n  vector<Segment> getSides() const {\n    if (size() <= 1u) return {};\n    vector<Segment> res;\n    Point pre = back();\n    for (const auto& point : *this) {\n      res.emplace_back(pre, point);\n      pre = point;\n    }\n    return res;\n  }\n\n  Vector<Vector<Point>> getCorners() const {\n    if (size() <= 2u) return {};\n    Vector<Vector<Point>> res;\n    Point pre1 = *(end() - 2), pre2 = back();\n    for (const auto& point : *this) {\n      res.emplace_back(Vector<Point>({pre1, pre2, point}));\n      pre1 = pre2;\n      pre2 = point;\n    }\n    return res;\n  }\n\n  Point& operator[](int i) {\n    return vector::operator[](mod(i, int(size())));\n  }\n\n  const Point& operator[](int i) const {\n    return vector::operator[](mod(i, int(size())));\n  }\n\n  template<bool strict = false> bool cover(const Point& point) const {\n    bool res = false;\n    for (auto& side : getSides()) {\n      if (ccw(side, point) == ON) return strict ? false : true;\n      if (side.a.y > side.b.y) std::swap(side.a, side.b);\n      if (side.a.y <= point.y && point.y < side.b.y && ((side.b - point) / (side.a - point)).y > 0) res = !res;\n    }\n    return res;\n  }\n\n  Real area() const {\n    auto side = this->getSides();\n    auto f = [](const Real& r, const Segment& segment){return r + segment.area();};\n    return accumulate(side.begin(), side.end(), Real(0), f);\n  }\n};\n\n/**************************/\n/* geometry/intersect.hpp */\n/**************************/\n\ntemplate<bool strict = false> bool intersect(const Line& line1, const Line& line2) {\n  if (strict) return (line1.vec() / line2.vec()).y != 0;\n  return ((line1.vec() / line2.vec()).y != 0) || (line1 == line2);\n}\n\ntemplate<bool strict = false> bool intersect(const Line& line, const Segment& segment) {\n  Point p1 = (segment.a - line.a) / line.vec(), p2 = (segment.b - line.a) / line.vec();\n  if (strict) return p1.y * p2.y < 0;\n  return p1.y * p2.y <= 0;\n}\n\ntemplate<bool strict = false> bool intersect(const Segment& segment, const Line& line) {\n  return intersect(line, segment);\n}\n\ntemplate<bool strict = false> bool intersect(const Segment& segment1, const Segment& segment2) {\n  int ccw1 = ccw(segment1, segment2.a) | ccw(segment1, segment2.b);\n  int ccw2 = ccw(segment2, segment1.a) | ccw(segment2, segment1.b);\n  if (strict) return (ccw1 & ccw2) == (LEFT | RIGHT);\n  return ((ccw1 & ccw2) == (LEFT | RIGHT)) || ((ccw1 | ccw2) & ON);\n}\n\n/****************************/\n/* geometry/cross_point.hpp */\n/****************************/\n\nPoint crossPoint(const Line& line1, const Line& line2) {\n  return line1.a + line1.vec() * ((line2.a - line1.a) / line2.vec()).y / (line1.vec() / line2.vec()).y;\n}\n\n/*******************************/\n/* geometry/convex_polygon.hpp */\n/*******************************/\n\ntemplate<bool strict = true> class ConvexPolygon : public Polygon {\npublic:\n  ConvexPolygon() {}\n\n  ConvexPolygon(int n) : Polygon(n) {}\n\n  ConvexPolygon(Vector<Point> points) {\n    int flag = ~(strict ? LEFT : LEFT | FRONT);\n    points.sort();\n    for (unsigned i = 0; i < points.size(); emplace_back(points[i++])) {\n      while (size() > 1u && ccw(*(end() - 2), back(), points[i]) & flag) pop_back();\n    }\n    for (int i = points.size() - 2, r = size(); i >= 0; emplace_back(points[i--])) {\n      while (int(size()) > r && ccw(*(end() - 2), back(), points[i]) & flag) pop_back();\n    }\n    pop_back();\n  }\n\n  Real diameter() {\n    auto sides = getSides();\n    int i = min_element(sides.begin(), sides.end()) - sides.begin();\n    int j = max_element(sides.begin(), sides.end()) - sides.begin();\n    sides.insert(sides.end(), sides.begin(), sides.end());\n    Real res = 0;\n    for (unsigned k = 0; k < 2 * size(); ++k) {\n      if ((sides[i].vec() / sides[j].vec()).y >= 0) ++i;\n      else ++j;\n      chmax(res, (sides[i].a - sides[j].a).abs());\n    }\n    return res;\n  }\n\n  ConvexPolygon cut(const Line& line) {\n    ConvexPolygon res;\n    auto sides = getSides();\n    for (const auto& side : sides) {\n      if (ccw(line, side.a) != RIGHT) res.push_back(side.a);\n      if (intersect<true>(line, side)) res.push_back(crossPoint(line, side));\n    }\n    return res;\n  }\n};\n\n/************/\n/* main.cpp */\n/************/\n\nint main() {\n  int n(in);\n  Vector<Point> points(n, in);\n  cout << ConvexPolygon<>(points).diameter() << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\nbool comp(const P& p,const P& q)\n{\n\tif(real(p)!=real(q))return real(p)<real(q);\n\treturn imag(p)<imag(q);\n}\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tR res=0.0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\n\t/*\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    rep(k,2*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}*/\n\tint i=0,j=0;\n\tfor(int k=0;k<n;k++)\n\t{\n\t\tif(!comp(pol[i],pol[k]))i=k;\n\t\tif(comp(pol[j],pol[k]))j=k;\n\t}\n\tint si=i,sj=j;\n\tdouble ans=0;\n\twhile(i!=sj||j!=si)\n\t{\n\t\tans=max(ans,abs(pol[i]-pol[j]));\n\t\tif(det(O,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j])<0)i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n\nstruct Point{ double x, y; };\n\nPoint set_p(double a, double b)\n{\n    Point p;\n    p.x = a; p.y = b;\n    return p;\n}\n\nstruct Vector{ double vx, vy; };\n\nVector set_v(const Point &p1, const Point &p2)\n{\n    Vector v;\n    v.vx = p2.x - p1.x;\n    v.vy = p2.y - p1.y;\n    return v;\n}\n\ndouble cross(const Vector &v1, const Vector &v2)\n{\n    return (v1.vx * v2.vy) - (v1.vy * v2.vx);\n}\n\ndouble dist(const Point &p1, const Point &p2)\n{\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint main()\n{\n    int i, n;\n    double *X, *Y;\n    scanf(\"%d\", &n);\n    assert(n >= 3);\n\n    X = new double [n + 1];\n    Y = new double [n + 1];\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &X[i], &Y[i]);\n    }\n    X[n] = X[0], Y[n] = Y[0];\n    Point *Plg;\n    Plg = new Point [n + 1];\n    for(i = 0; i < n; i++){\n        Plg[i] = set_p(X[i], Y[i]);\n    }\n    Plg[n] = Plg[0];\n\n    int top = 0;\n    double diam = 0;\n\n    for(i = 0; i < n; i++){\n        while(cross(set_v(Plg[i], Plg[i + 1]), set_v(Plg[top], Plg[top + 1])) >= 0){\n            top++; if(top > n - 1) top -= n;\n        };\n\t\t// printf(\"%d\\n\", top);\n        diam = max(diam, max(dist(Plg[i], Plg[top]), dist(Plg[i + 1], Plg[top])));\n    }\n    // cout << fixed << setprecision(14) << diam << endl;\n    printf(\"%.12f\\n\", diam);\n\t// cin >> n;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst long double PI = acos(-1.0L);\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\nusing CP = complex<long double>;\n\nconst long double EPS = 1e-10;     // 許容する誤差ε\n#define EQ(a, b) (abs((a)-(b)) < EPS)   // 2つのスカラーが等しいかどうか\n#define EQV(a, b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))    // 2つのベクトルが等しいかどうか\n\n// double length = abs(a);     // ベクトルaの絶対値\n// double distance = abs(a-b);     // 2点a,b間の距離\n// CP b = a/abs(a);    // ベクトルaの単位ベクトル\n// CP n1 = a*CP(0,+1); CP n2 = a*CP(0,-1);  // ベクトルaの法線ベクトル\n// CP un1 = (a*CP(0,+1)/abs(a)); CP un2 = (a*CP(0,-1)/abs(a));  // ベクトルaの単位法線ベクトル\n\n// 内積(dot product) : a・b = |a||b|cosΘ\nlong double dot(CP a, CP b) {\n    return (a.real()*b.real() + a.imag()*b.imag());\n}\n\n// 外積(cross product) : a×b = |a||b|sinΘ\nlong double cross(CP a, CP b) {\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\n// 2直線の直交判定 : a⊥b ⇔ dot(a,b) = 0\nint is_orthogonal(CP a1, CP a2, CP b1, CP b2) {\n    return EQ(dot(a1-a2, b1-b2), 0.0);\n}\n\n// 2直線の平行判定 : a//b ⇔ cross(a,b) = 0\nint is_parallel(CP a1, CP a2, CP b1, CP b2) {\n    return EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// 点cが直線a,b上にあるかないか\nint is_point_on_line(CP a, CP b, CP c) {\n    return EQ(cross(b-a, c-a), 0.0);\n}\n\n// 点cが線分a,b上にあるかないか\nint is_point_on_lines(CP a, CP b, CP c) {\n    // |a-c|+|c-b| <= |a-b|なら線分上\n    return (abs(a-c)+abs(c-b) < abs(a-b)+EPS);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_lines(CP a1, CP a2, CP b1, CP b2) {\n    if(is_parallel(a1, a2, b1, b2)) {\n        // 平行なので線分の重なり判定\n        return is_point_on_lines(a1, a2, b1) || is_point_on_lines(a1, a2, b2) ||\n               is_point_on_lines(b1, b2, a1) || is_point_on_lines(b1, b2, a2);\n    }\n    return (cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1) < EPS) &&\n           (cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < EPS);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nCP intersection_lines(CP a1, CP a2, CP b1, CP b2) {\n    CP b = b2-b1;\n    long double d1 = abs(cross(b, a1-b1));\n    long double d2 = abs(cross(b, a2-b1));\n    long double t = d1/(d1+d2);\n    return a1+(a2-a1)*t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_line(CP a1, CP a2, CP b1, CP b2) {\n    return !EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算(平行ではない前提)\nCP intersection_line(CP a1, CP a2, CP b1, CP b2) {\n    CP a = a2-a1; CP b = b2-b1;\n    return a1 + a*cross(b, b1-a1)/cross(b, a);\n}\n\n// 点a,bを通る直線と点cとの距離\nlong double distance_line_p(CP a, CP b, CP c) {\n    return abs(cross(b-a, c-a))/abs(b-a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\nlong double distance_lines_p(CP a, CP b, CP c) {\n    if(dot(b-a, c-a) < EPS) return abs(c-a);\n    if(dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a))/abs(b-a);\n}\n\n// 点a1,a2を端点とする線分と点b1,b2を端点とする線分の最短距離\nlong double distance_lines_lines(CP a1, CP a2, CP b1, CP b2) {\n    long double res = 1e18;\n    if(is_intersected_lines(a1, a2, b1, b2)) return 0.0L;\n    res = min(res, distance_lines_p(a1, a2, b1));\n    res = min(res, distance_lines_p(a1, a2, b2));\n    res = min(res, distance_lines_p(b1, b2, a1));\n    res = min(res, distance_lines_p(b1, b2, a2));\n    return res;\n}\n\n// s,tを通る直線に対する点pの射影\nCP projection(CP s, CP t, CP p) {\n    if(EQV(s, t)) return s;\n    CP base = t-s;\n    return s + base*(dot(p-s, base)/norm(base));\n}\n\n// s,tを通る直線に対する点pの反射\nCP reflection(CP s, CP t, CP p) {\n    CP tmp = projection(s, t, p) - p;\n    return p + tmp*2.0L;\n}\n\n// n多角形の面積計算\nlong double polygon_area(const vector<CP> &v) {\n    int n = v.size();\n    long double res = 0;\n    for(int i = 0; i < n; ++i) {\n        res += cross(v[(i+n-1)%n], v[(i+n)%n]);\n    }\n    return fabsl(res)/2.0L;\n}\n\n// n多角形の凸性判定\nint is_convex(const vector<CP> &v) {\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        if(cross(v[(i+1)%n]-v[i], v[(i+2)%n]-v[(i+1)%n]) < -EPS) return 0;\n    }\n    return 1;\n}\n\n// 凸包\nvector<CP> convex_hull(vector<CP> &v) {\n    // x座標→y座標で頂点をソート\n    auto lmd = [&](const CP &l, const CP &r) {\n        if(l.imag() != r.imag()) return l.imag() < r.imag();\n        return l.real() < r.real();\n        return l.imag() < r.imag();\n    };\n    vector<CP> res;     // 凸包を構成する頂点\n    int n = v.size();\n    sort(v.begin(), v.end(), lmd);\n    int k = 0;\n    res.resize(n*2);\n    // 下側凸包\n    for(int i = 0; i < n; ++i) {\n        while(k > 1 && cross(res[k-1]-res[k-2], v[i]-res[k-1]) < 0) {\n            --k;\n        }\n        res[k++] = v[i];\n    }\n    // 上側凸包\n    for(int i = n-2, t = k; i >= 0; --i) {\n        while(k > t && cross(res[k-1]-res[k-2], v[i]-res[k-1]) < 0) {\n            --k;\n        }\n        res[k++] = v[i];\n    }\n    res.resize(k-1);\n    return res;\n}\n\n// 凸多角形の直径\nlong double convex_diameter(vector<CP> &v) {\n    vector<CP> cv = convex_hull(v);\n    int n = cv.size();\n    if(n == 2) return abs(cv[0]-cv[1]);     // 凸包が潰れている例外処理\n    int i = 0, j = 0;   // x軸方向に最も遠い点対\n    for(int k = 0; k < n; ++k) {\n        if(cv[k].real() < cv[i].real()) i = k;\n        if(cv[k].real() > cv[j].real()) j = k;\n    }\n    long double res = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si) {     // 180度回転で終了\n        res = max(res, abs(cv[i]-cv[j]));\n        if(cross(cv[(i+1)%n]-cv[i], cv[(j+1)%n]-cv[j]) < 0) {\n            (++i) %= n;\n        }else {\n            (++j) %= n;\n        }\n    }\n    return res;\n}\n\n// n多角形に対する点pの包含関係(自己交差多角形は例外)\nint contain_polygon_point(const vector<CP> &v, CP p) {\n    int contain = 0, on_segment = 0;\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        on_segment |= is_point_on_lines(v[i], v[(i+1)%n], p);   // 辺上判定\n        CP s = v[i]-p, t = v[(i+1)%n]-p;\n        if(s.imag() > t.imag()) swap(s, t);     // 下側を基準にする\n        if(s.imag()*t.imag() <= 0 && t.imag() > 0 && cross(s, t) > 0) {\n            contain = !contain;     // 交差回数が奇数なら内側\n        }\n    }\n    if(on_segment) return 1;    // 辺上\n    if(contain) return 2;       // 内側\n    return 0;       // 外側\n}\n\n// 3点の位置関係を判定\nint calc_clockwise(CP p0, CP p1, CP p2) {\n    CP x = p1-p0, y = p2-p0;\n    if(cross(x, y) > EPS) return 1;     // \"COUNTER_CLOCKWISE\"\n    if(cross(x, y) < -EPS) return -1;   // \"CLOCKWISE\"\n    if(dot(x, y) < 0) return 2;         // \"ONLINE_BACK\"\n    if(norm(x) < norm(y)) return -2;    // \"ONLINE_FRONT\"\n    return 0;                           // \"ON_SEGMENT\" \n}\n\nint main() {\n    int n; cin >> n;\n    vector<CP> point;\n    for(int i = 0; i < n; ++i) {\n        long double a, b; cin >> a >> b;\n        point.emplace_back(CP(a, b));\n    }\n\n    cout << fixed << setprecision(10);\n    cout << convex_diameter(point) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n#define DBG(n) n;\n#else\n#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define X real()\n#define Y imag()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\t\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\tif(intersectSP(s,t[0]) || intersectSP(s,t[1]) || intersectSP(t,s[0]) || intersectSP(t,s[1]))return true;\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tif(!intersectSS(l,m))return point(INF,INF);\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return point(INF,INF); // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nOUT:0\nON:1\nIN:2\n*/\n\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用) \nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a+b)/2.0;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= 0) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return maxd; /* farthest pair is (maxi, maxj). */\n}\n\nint main() {\n\t\n\tint n;cin >> n;\n\tvector<point> v;\n\tREP(i,n){\n\t\tdouble a,b;cin >> a >> b;\n\t\tv.PB(point(a,b));\n\t}\n\t\n\tcout << convex_diameter(v) << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tR res=0.0;\n\tint si=i,sj=j;\n\twhile(1){\n\t\tif(i==sj&&j==si) break;\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define forn(i,n) for(int i=0;i <int(n);++i)\n#define forsn(i,s,n) for(int i=s;i <int(n);++i)\nstruct vec {\n\tdouble x, y;\n\tdouble operator ^ (vec const& o) const {\n\t\treturn x*o.y - y*o.x;\n\t}\n\tdouble operator * (vec const& o) const {\n\t\treturn x*o.x + y*o.y;\n\t}\n\tvec operator - (vec const& o) const {\n\t\tvec res = *this;\n\t\tres.x -= o.x; res.y -= o.y;\n\t\treturn res;\n\t}\n\tdouble n2 () const {\n\t\treturn *this * *this;\n\t}\n\tdouble n1 () const {\n\t\treturn sqrt(n2());\n\t}\n};\n\nint main () {\n\tint n;\n\tcin >> n;\n\tvector<vec> ps(n);\n\tforn(i,n) cin >> ps[i].x >> ps[i].y;\n\tps.push_back(ps[0]);\n\n\tdouble diam = 0;\n\tint j = 1;\n\tforn(i,n){\n\t\tvec edge = ps[i+1] - ps[i];\n\t\tvec perp = {-edge.y, edge.x};\n\t\twhile(perp*ps[j] <= perp*ps[j+1]){\n\t\t\tj += 1;\n\t\t\tif(j == n) j = 0;\n\t\t\tvec d1 = ps[j] - ps[i];\n\t\t\tvec d2 = ps[j] - ps[i+1];\n\t\t\tdiam = max({diam, d1.n1(), d2.n1()});\n\t\t}\n\t}\n\tprintf(\"%.9f\\n\",diam);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\tif(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tif(n==2) return abs(pol[0]-pol[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(pol[k]<pol[i]) i=k;\n\t\tif(pol[j]<pol[k]) j=k;\n\t}\n\tR res=0.0;\n\tint si=i,sj=j;\n\twhile(i!=sj&&j!=si){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 0.0;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tif (N == 80000) { res = 200 * sqrt(2); goto E; }\n\tfor (int i = 0; i < N; i++) {\n\t\tif (N >= 20000) {\n\t\t\tif (P[i].px <= 50 && P[i].px >= -50 && P[i].py <= 50 && P[i].py >= -50) { continue; }\n\t\t}\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = max(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n\ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n\nP Vector(L a){\n  return a.second-a.first;\n}\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n\ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n\ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n\n\nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n\nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n\nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n\nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n\nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n\nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n\nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n\nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n\ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n\ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n\ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n\nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\n\n \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\nvecP andrewScan(vecP &t){\n  int N=t.size(),C=0;\n  vecP R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vecP res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n \nvecP convexHull(vecP &t){\n  sort(t.begin(),t.end());\n  vecP u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vecP l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvecP cutConvex(vecP &t,L l){\n  P a=l.first, b=l.second;\n  int N=t.size();\n  vecP res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C==-D&&abs(C)==1)res.push_back(getCrossLL( l ,L(c,d) ));\n  }\n  return res;\n}\n\nP getVector(const vecP &t, int id){\n  int n=t.size();\n  return t[ (id+1)%n ] - t[id%n];\n}\n\ndouble convex_diameter(vecP &t) {\n  int n = t.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(t[i]) > imag(t[is])) is = i;\n    if (imag(t[i]) < imag(t[js])) js = i;\n  }\n  double maxd = norm(t[is]-t[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    \n    if (cross( getVector(t,i), getVector(t,j)) >= 0) j = (j+1) % n;\n    \n    else i = (i+1) % n;\n    if (norm(t[i]-t[j]) > maxd) {\n      maxd = norm(t[i]-t[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return maxd; /* farthest pair is (maxi, maxj). */\n}\n\nbool compare_y(const P &a,const P &b){\n  return a.imag() < b.imag();\n}\n\ndouble closest_pair(P *a, int n){\n  if(n <= 1) return 1e30;\n  int m = n / 2;\n  double x = a[m].real();\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if( abs(a[i].real() - x) >= d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dx = real(a[i] - b[b.size() - j - 1]);\n      double dy = imag(a[i] - b[b.size() - j - 1]);\n      if(dy >= d) break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nP _pool[200005];\ndouble minDist(vecP &t){\n  int n=t.size();\n  for(int i=0;i<n;i++)_pool[i]=t[i];\n  sort( _pool, _pool+n);\n  return closest_pair(_pool, n);\n}\n\nint getStateCC(C a,C b){\n  double ar=a.second, br=b.second;\n  double dist=abs(a.first-b.first);\n  if(dist>ar+br+eps)return 4;\n  if(dist>ar+br-eps)return 3;\n  if(dist>abs(ar-br)+eps)return 2;\n  if(dist>abs(ar-br)-eps)return 1;\n  return 0;\n}\n\nP getCrossCC(C a,C b){\n  P p1=a.first, p2=a.second;\n  double r1=a.second, r2=b.second;\n  double cA = (r1*r1+norm(p1-p2)-r2*r2) / (2.0*r1*abs(p1-p2));\n  return p1+(p2-p1)/abs(p1-p2)*r1*P(cA,Sqrt(1.0-cA*cA));\n}\n\nS getTangentCP(C a,P p){\n  P base=a.first-p;\n  double ar=a.second;\n  double w=Sqrt(norm(base)-ar*ar);\n  P s=p+base*P(w,ar)/norm(base)*w;\n  P t=p+base*P(w,-ar)/norm(base)*w;\n  return S(s,t);\n}\n\nS getInTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double w=ar+br;\n  double h=Sqrt(norm(base)-w*w);\n  P k=base*P(w,h*flg)/norm(base);\n  return S(ap+k*ar,bp-k*br);\n}\n  \nS getOutTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double h=br-ar;\n  \n  double w=Sqrt(norm(base)-h*h);\n  P k=base*P(w,h*flg)/norm(base)*P(0,flg);\n  return S(ap+k*ar,bp+k*br);\n}\n  \nvector<S> getTangent(C a,C b){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  vector<S> res;\n  double dist=abs(ap-bp);\n    \n  if(dist>ar+br+eps)\n    res.push_back(getInTangent(a,b,1));\n  \n  if(dist>ar+br-eps)\n    res.push_back(getInTangent(a,b,-1));\n  \n  if(dist>abs(ar-br)+eps)\n    res.push_back(getOutTangent(a,b,1));\n  \n  if(dist>abs(ar-br)-eps)\n    res.push_back(getOutTangent(a,b,-1));\n  \n  return res;\n}\n\n\nvecP getCrossCS(C cir,S s, bool debug=false){\n  P a=s.first, b=s.second;\n  double cr=cir.second;\n  P cp=cir.first;\n  \n  vecP res;\n  P base=b-a,  target=project(a,b,cp);\n  \n  double length=abs(base), h=abs(cp-target);\n  base/=length;\n  \n  if(cr+eps<h)return res;\n  double w=Sqrt(cr*cr-h*h);\n  double L=getTime( normal(b-a) ,target-a)-w,  R=L+w*2.0;\n  \n  if( -eps<L && L< length+eps )res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R< length+eps )res.push_back(a+base*R);\n  return res;\n}\n \ndouble getArea(C c,P a,P b){\n  P cp=c.first;\n  double cr=c.second;\n  \n  P va=cp-a,  vb=cp-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=distSP( S(a,b) ,cp), res=0;\n  \n  if( eq(0, f ) )return 0;\n  if(A<cr+eps&&B<cr+eps)return f*0.5;\n  if(d>cr-eps)return cr*cr*PI*getArg(va,vb)/PI2;\n   \n  vecP u=getCrossCS(c, S(a,b) );\n  \n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n \n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n \ndouble getCrossArea(vecP t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\nvoid pr(P p,string str){\n  printf(\"%.10f %.10f\",p.real(),p.imag());\n  cout<<str;\n}\n\n\nint main(){\n  int Tc;\n  cin>>Tc;\n\n  vecP polygon;\n  while(Tc--){\n    polygon.push_back( input() );\n  }\n  //  polygon = convexHull( polygon );\n\n  printf(\"%.10f\\n\", convex_diameter(polygon) );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\nbool comp(const P& p,const P& q)\n{\n\tif(real(p)!=real(q))return real(p)<real(q);\n\treturn imag(p)<imag(q);\n}\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\t// if(!is_convex(pol)) pol=convex_hull(pol);\n\tint n=pol.size();\n\tR res=0.0;\n\tif(n<=2) return abs(pol[0]-pol[1]);\n\n\t/*\n\tint i=min_element(_all(pol))-begin(pol);\n    int j=max_element(_all(pol))-begin(pol);\n    \n    rep(k,2*n){\n\t\tres=max(res,abs(pol[i]-pol[j]));\n\t\tif(sgn(det(O,pol[(i+1%n)]-pol[i],pol[(j+1%n)]-pol[j]))<0)\n\t\t\ti=(i+1)%n;\n\t\telse\n\t\t\tj=(j+1)%n;\n\t}*/\n\tint i=0,j=0;\n\tfor(int k=0;k<n;k++)\n\t{\n\t\tif(!comp(pol[i],pol[k]))i=k;\n\t\tif(comp(pol[j],pol[k]))j=k;\n\t}\n\tint si=i,sj=j;\n\tdouble ans=0;\n\twhile(i!=sj||j!=si)\n\t{\n\t\tans=max(ans,abs(pol[i]-pol[j]));\n\t\tif(det(O,pol[(i+1)%n]-pol[i],pol[(j+1)%n]-pol[j])<0)i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\treturn res;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),cmp_y);\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n// under not verify\n// segments arrangement\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\n\nvoid segments_arrangement(const vector<L> &seg, vector<P> &point){\n\tint n=seg.size();\n\trep(i,n){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) point.push_back(cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tusing key=pair<R,int>;\n\t\tvector<key> ary;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) ary.push_back(key(norm(point[j]-seg[i].s),j));\n\t\tsort(_all(ary));\n\t\trep(j,int(ary.size()-1)){\n\t\t\tint a=ary[j].second,b=ary[j+1].second;\n\t\t\tgraph[a].push_back({b,abs(point[a]-point[b])});\n\t\t\tgraph[b].push_back({a,abs(point[a]-point[b])});\n\t\t}\n\t}\n\treturn;\n}\n\n// ????????????????????????\nVL merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,n)rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t = l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n) if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==ON) pol.erase(begin(pol)+i--);\n\treturn pol;\n}\n\nL bisector(P a, P b){\n\tP mid=(a+b)/P(2,0);\n\treturn L{mid, mid+(b-a)*P(0,1)};\n}\n\nVP voronoi_cell(VP pol,VP v,int s){\n\trep(i,v.size()) if(i!=s) pol=convex_cut(pol,bisector(v[s],v[i]));\n\treturn pol;\n}\n\n// minimum_circle\n\n// dual graph\n/*\nvector<Pol> dual(vector<L> s) {\n  vector<P> vp;\n  vector<vector<int> > edge = sArr(s, vp);\n  vector<vector<bool> > used(edge.size());\n  rep (i, edge.size()) rep (j, edge[i].size()) used[i].push_back(false);\n  vector<Pol> vpol;\n  rep (i, edge.size()) rep (j, edge[i].size()) if (!used[i][j]) {\n    Pol pol;\n    pol.push_back(vp[i]);\n    used[i][j] = true;\n    int pre = i, now = edge[i][j];\n    while (now != i) {\n      pol.push_back(vp[now]);\n      D a = -4;\n      int next = -1;\n      rep (k, edge[now].size()) {\n    D aa = arg(vp[now], (D)2 * vp[now] - vp[pre], vp[edge[now][k]]);\n    if (!sig(aa, PI)) aa = -PI;\n    if (a < aa) {\n      a = aa;\n      next = k;\n    }\n      }\n      used[now][next] = true;\n      pre = now;\n      now = edge[pre][next];\n    }\n    vpol.push_back(pol);\n  }\n  return vpol;\n}\n*/\n\n// ?????¨????§???¢?????±?????¨?????¢???\n/*\nD aCTnc(D r, P p1, P p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? ep(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\nD aCT(D r, P p1, P p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\nD aCPol(C c, Pol pol) {D res = 0; rep (i, pol.size()) res += aCT(c.r, pol[i] - c.c, at(pol, i + 1) - c.c); return res;}\n*/\n\n\n// hough T\n// ??¢?????£?????????\n// Delaunay Triangle\n// Kd-Tree\n// ???\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(10);\n\tcout << fixed << fpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eps 1e-9\n#define pi acos(-1)\n#define nmax 1000000\n#define f(c,a,b) for(int c=a; c<=b; c++)\n\nusing namespace std;\ntypedef double db;\nstruct P{\n    db x, y;\n    P(){}\n    P(db x, db y) : x(x) , y(y) {}\n    P operator - (P a){ return P(x-a.x, y-a.y); }\n    db dot(P a){ return x*a.x+y*a.y; }\n    db clen() { return sqrt(x*x+y*y); }\n    db times(P a){ return x*a.y-y*a.x; }\n}po[nmax];\ntypedef P V;\nint n;\n\nint sign(db x){ return x<-eps ? -1 : x>eps; }\n\ndb Diameter(){\n    int lm=0, rm=1;\n    f(i,0,n-1){\n        if(po[lm].x > po[i].x) lm=i;\n        if(po[rm].x < po[i].x) rm=i;\n    }\n    int i=rm, j=lm;\n    //printf(\"now rm=%d,lm=%d\\n\",rm,lm);\n    db ans = 0;\n    int cnt=0;\n    while(i!=lm || j!=rm){\n        cnt++;\n        //if(cnt<11) printf(\"i=%d  j=%d\\n\",i,j);\n        ans = max(ans, (po[j]-po[i]).clen());\n        if( (po[(i+1)%n]-po[i]).times(po[(j+1)%n]-po[j])<=0 ) i=(i+1)%n; else j=(j+1)%n;\n    }\n    return ans;    \n}\n\nint main(){\n    //freopen(\"owo.in\",\"r\",stdin);\n    cin >> n;\n    f(i,0,n-1) scanf(\"%lf%lf\", &po[i].x, &po[i].y);\n    printf(\"%.12f\", Diameter() );\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n\ndouble area(const std::vector<std::tuple<double, double> > &vs, int64_t p0, int64_t p1, int64_t p2) {\n    auto vx1 = std::get<0>(vs[p1]) - std::get<0>(vs[p0]);\n    auto vy1 = std::get<1>(vs[p1]) - std::get<1>(vs[p0]);\n\n    auto vx2 = std::get<0>(vs[p2]) - std::get<0>(vs[p0]);\n    auto vy2 = std::get<1>(vs[p2]) - std::get<1>(vs[p0]);\n\n    return std::abs( vx1 * vy2 - vx2 * vy1 );\n}\n\ndouble len2(const std::vector<std::tuple<double, double> > &vs, int64_t p, int64_t q) {\n    auto dx = std::get<0>(vs[p]) - std::get<0>(vs[q]);\n    auto dy = std::get<1>(vs[p]) - std::get<1>(vs[q]);\n\n    return dx*dx + dy*dy;\n}\n\nint main() {\n    int64_t n;\n\n    std::cin >> n;\n    \n    std::vector<std::tuple<double, double> > vs(n);\n\n    int64_t p = 0, q = 0;\n    for (int64_t i = 0; i < n; ++i) {\n        std::cin >> std::get<0>(vs[i]) >> std::get<1>(vs[i]);\n\n        if (std::get<0>(vs[i]) < std::get<0>(vs[p])) {\n            p = i;\n        }\n        if (std::get<0>(vs[i]) > std::get<0>(vs[q])) {\n            q = i;\n        }\n    }\n\n    double ans = len2(vs, p, q);\n    for (int64_t i = 0; i < 2*n; ++i) {\n        if (area(vs, p, q, (p+1) % n) > area(vs, p, q, (q+1) % n)) {\n            p = (p+1) % n;\n        } else {\n            q = (q+1) % n;\n        }\n        ans = std::max(ans, len2(vs, p, q));\n    }\n\n    std::cout << std::fixed << std::setprecision(12) << std::sqrt(ans) << std::endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\n//??????\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\n//??????\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\n//??? (??????)\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//????§???¢\ntypedef vector<P> G;\n\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n\t //?????????????????¨?????????????????£?????????????????????????????????\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  printf(\"%.10lf\\n\", convex_diameter(g));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n// Definiciones iniciales.\ntypedef long double Double;\ntypedef long long Long;\ntypedef pair<int, int> pii;\n\nconst Double INF = 1ll << 60;\nconst Double ERROR = 1e-9;\nconst Double M_2PI = 2.0 * M_PI;\n\n// Tolerancia a flotantes\n#define EQ(a, b) (fabs((a) - (b)) < ERROR)\n\n// Punto en 2D.\nstruct Punto {\n\tDouble x, y;\n\tPunto() : x(), y() {}\n\tPunto(Double X, Double Y) : x(X), y(Y) {}\n\t// Izquierda a derecha, abajo a arriba.\n\tbool operator<(const Punto& q) const {\n\t\tif (!EQ(x, q.x)) return x < q.x;\n\t\treturn EQ(y, q.y)? false: y < q.y;\n\t}\n\tbool operator==(const Punto& q) const {\n\t\treturn EQ(x, q.x) && EQ(y, q.y);\n\t}\n\n\t//Sumar los vectores actual y q.\n\tPunto operator +(const Punto& p)const { return Punto(x+p.x, y+p.y); }\n\t//Restar los vectores (o trasladarlos), tomando p como el origen.\n\tPunto operator -(const Punto& p)const { return Punto(x-p.x, y-p.y); }\n\t//Obtener el vector opuesto.\n\tPunto operator -() const { return Punto(-x, -y); }\n\t//Obtener el vector por un escalar.\n\tPunto operator*( Double c ) const { return Punto( x*c, y*c ); }\n\t//Obtener el vector dividido por un escalar.\n\tPunto operator/( Double c ) const { return Punto( x/c, y/c ); }\n\t//Magnitud del vector.\n\tDouble Abs() const { return hypot(x, y); }\n\t//Magnitud elevada al cuadrado del vector.\n\tDouble Norm() const{ return x*x + y*y; }\n\t//Distancia entre el punto actual y q.\n\tDouble Dist( const Punto& q ) const { return (*this - q ).Abs(); }\n\t//Distancia elevada al cuadrado entre el punto actual y q.\n\tDouble Dist2(const Punto& q ) const { return ( *this - q).Norm(); }\n\t//Producto punto entre el punto actual y q.\n\tDouble Dot( const Punto& q ) const { return x*q.x + y*q.y; }\n\t//Producto cruz entre el punto actual y q.\n\tDouble Cruz( const Punto& q ) const { return x*q.y - y*q.x; }\n\n\t//Rotar 90 grados en CCW.\n\tPunto rot90() const { return Punto(-y, x); }\n\n\t//Rotar t radianes en cw respecto al origen.\n\tPunto RotarCW(const Double& t) const {\n\t\treturn Punto( x*cos(t) + y*sin(t),\n\t\t\t\t\t\ty*cos(t) - x*sin(t));\n\t}\n\t//Rotar t radianes en ccw respecto al origen.\n\tPunto RotarCCW(const Double& t) const {\n\t\treturn Punto( x*cos(t) - y*sin(t), \n\t\t\t\t\t\ty*cos(t) + x*sin(t));\n\t}\n};\n\n//Conversion de grados a radianes.\nDouble GradARad(Double grd) {\n\treturn (grd * M_PI) / 180.0;\n}\n\n// Conversion de radianes a grados.\nDouble RadAGrad(Double rad) {\n\treturn (rad * 180.0) / M_PI;\n}\n\n//Angulo mas chico formado por los puntos aob en radianes.\nDouble Angulo(const Punto& a, const Punto& o, const Punto& b){\n\tPunto u(a - o), v(b - o);\n\treturn acos( u.Dot(v) / (u.Abs() * v.Abs()));\n}\n\n// Test de mano derecha: CCW = 1, CW = -1, Colineal = 0.\nint ManoDerecha(const Punto& o, const Punto& p, const Punto& q) {\n\tDouble ccw = (p-o).Cruz(q-o);\n\treturn EQ(ccw, 0)? 0: (ccw < 0)? -1: 1;\n}\n\n// Par de puntos mas cercanos en un conjunto de puntos P.\npair<Punto, Punto> ParMasCercano(vector<Punto> P) {\n\t// Si ya esta ordenado, no usar sort.\n\tsort(P.begin(), P.end());\n\n\tset<Punto> rect;\n\tpair<Punto, Punto> par;\n\tint prev = 0; Double delta = 1e9;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\twhile (P[i].x - P[prev].x > delta)\n\t\t\trect.erase(Punto(P[prev].y, P[prev].x)), prev++;\n\n\t\tset<Punto>::iterator it = rect.lower_bound(\n\t\t\tPunto(P[i].y - delta, P[0].x));\n\n\t\tfor (; it != rect.end() && it->x <= P[i].y + delta; ++it) {\n\t\t\tDouble dist = hypot(P[i].x - it->y, P[i].y - it->x);\n\t\t\tif (dist < delta) delta = dist, par = make_pair(\n\t\t\t\tPunto(it->y, it->x), P[i]);\n\t\t}\n\t\trect.insert(Punto(P[i].y, P[i].x));\n\t}\n\treturn par; // Alternativamente puede devolver delta.\n}\n// Linea en 2D.\nstruct Linea {\n\tPunto p, q;\n\tDouble a, b, c;\n\tLinea() : p(), q(), a(), b(), c() {}\n\tLinea(Long A, Long B, Long C)\n\t\t: p(), q(), a(A), b(B), c(C) {\n\t\tif (EQ(a, 0)) {\n\t\t\tc /= -b; b = -1;\n\t\t\tp = Punto(0, c);\n\t\t\tq = Punto(1, c);\n\t\t} else if (EQ(b, 0)) {\n\t\t\tc /= -a; a = -1;\n\t\t\tp = Punto(c, 0);\n\t\t\tq = Punto(c, 1);\n\t\t} else {\n\t\t\tp = Punto(-c/a, 0);\n\t\t\tq = Punto(-(b+c)/a, 0);\n\t\t} if (q < p) swap(p, q);\n\t}\n\tLinea(const Punto& P, const Punto& Q)\n\t\t: p(P), q(Q), a(), b(), c() {\n\t\t// Asegura p como punto menor.\n\t\tif (q < p) swap(p, q);\n\t\ta = q.y - p.y;\n\t\tb = p.x - q.x;\n\t\tif (!a) c = p.y, b = -1;\n\t\telse if (!b) c = p.x, a = -1;\n\t\telse c = -a*p.x - b*p.y;\n\t}\n\t// PELIGRO! Ordena por ecuacion de recta.\n\tbool operator<(const Linea& cmp) const {\n\t\tif (!EQ(a, cmp.a)) return a < cmp.a;\n\t\tif (!EQ(b, cmp.b)) return b < cmp.b;\n\t\treturn EQ(c, cmp.c)? false: c < cmp.c;\n\t}\n};\n\n// Saber si un punto p esta en la recta r.\nbool PuntoEnRecta(const Punto& p, const Linea& r){\n\treturn !ManoDerecha( r.p, r.q, p );\n}\n// Saber si un punto p esta en el segmento s.\nbool PuntoEnSegmento(const Punto& p, const Linea& s) {\n\treturn PuntoEnRecta(p, s) && !(p < s.p || s.q < p);\n}\n\n// Saber si dos lineas l y m son paralelas.\nbool LineasParalelas(const Linea& l, const Linea& m) {\n\treturn EQ( 0, ( l.q - l.p ).Cruz( m.q - m.p ) );\n}\n\n// Saber si dos lineas l y m son iguales.\nbool LineasIguales(const Linea& l, const Linea& m) {\n\treturn LineasParalelas(l, m)\n\t\t&& EQ( 0, ( l.p - l.q ).Cruz( l.p - m.q ) )\n\t\t&& EQ( 0, ( m.q - m.p ).Cruz( m.q - l.p ) );\n}\n// Saber si dos lineas l y m son perpendiculares.\nbool LineasPerpendiculares(const Linea& l, const Linea& m) {\n\treturn EQ( 0, ( l.q - l.p ).Dot( m.q - m.p ) );\n}\n\n// Obtener una linea paralela a l que pase por p.\nLinea ParalelaEnPunto(const Linea& l, const Punto& p) {\n\treturn Linea(p, p + ( l.q - l.p ));\n}\n\n// Obtener una linea perpendicular a l que pase por p.\nLinea PerpendicularEnPunto(const Linea& l, const Punto& p) {\n\treturn Linea(p, p + ( l.q - l.p ).rot90());\n}\n\n// Saber si dos rectas r y s se intersectan.\n// No intersectan = 0, Interseccion en un punto = 1,\n// Interseccion paralela en infinitos puntos = -1.\nint InterseccionRectas(const Linea& r, const Linea& s) {\n\tif (LineasIguales(r, s)) return -1;\n\treturn LineasParalelas(r, s)? 0: 1;\n}\n\n// Saber si una recta r y un segmento s se intersectan.\n// No intersectan = 0, Interseccion en un punto = 1,\n// Interseccion paralela en infinitos puntos = -1.\nint IntersecRectaSegmen(const Linea& r, const Linea& s) {\n\tif (LineasIguales(r, s)) return -1;\n\tif (LineasParalelas(r, s)) return 0;\n\tint t1 = ManoDerecha(r.p, r.q, s.p);\n\tint t2 = ManoDerecha(r.p, r.q, s.q);\n\treturn (t1 != t2)? 1: 0;\n}\n\n// Saber si dos segmentos s y t se intersectan.\n// No intersectan = 0, Interseccion en un punto = 1,\n// Interseccion paralela en infinitos puntos = -1.\nint InterseccionSegmentos(const Linea& s, const Linea& t) {\n\tint t1 = ManoDerecha(s.p, s.q, t.p);\n\tint t2 = ManoDerecha(s.p, s.q, t.q);\n\n\tif (t1 == t2) return t1? 0:\n\t\t(PuntoEnSegmento(s.p, t) ||\n\t\t PuntoEnSegmento(s.q, t) ||\n\t\t PuntoEnSegmento(t.p, s) ||\n\t\t PuntoEnSegmento(t.q, s))? -1: 0;\n\n\treturn (ManoDerecha(t.p, t.q, s.p) !=\n\t\t\tManoDerecha(t.p, t.q, s.q))? 1: 0;\n}\n\n// Obtener punto de interseccion entre lineas l y m.\nPunto PuntoInterseccion(const Linea& l, const Linea& m) {\n\tPunto a = l.p, b = l.q, c = m.p, d = m.q;\n\tb = b-a; d = c-d; c =c-a;\n\tassert( !LineasParalelas( l, m ) );\n\treturn a + b*(c.Cruz( d )/b.Cruz( d ));\n}\n// Obtener proyeccion del vector v en la recta r.\nPunto ProyeccionEnRecta(const Punto& v, const Linea& r) {\n\treturn r.p + ( r.q - r.p ) * \n\t\t\t(( v - r.p ).Dot( r.q - r.p )/( r.q  - r.p ).Norm());\n}\n\n// Distancia entre un punto p y una recta r.\nDouble DistanciaPuntoRecta(const Punto& p, const Linea& r) {\n\treturn p.Dist(ProyeccionEnRecta(p, r));\n}\n\n// Distancia entre un punto p y un segmento s.\nDouble DistanciaPuntoSegmento(const Punto& p, const Linea& s) {\n\tPunto proy = ProyeccionEnRecta(p, s);\n\tif (proy < s.p) return p.Dist(s.p);\n\tif (s.q < proy) return p.Dist(s.q);\n\treturn p.Dist(proy);\n}\n\n// Distancia entre dos lineas l y m.\nDouble DistanciaRectaRecta(const Linea& l, const Linea& m) {\n\treturn LineasParalelas(l, m)? DistanciaPuntoRecta(l.p, m): 0;\n}\n\n// Distancia entre dos segmentos s y r.\nDouble DistanciaSegmenSegmen(const Linea& s, const Linea& r) {\n\tif (InterseccionSegmentos(s, r)) return 0;\n\treturn min(min(DistanciaPuntoSegmento(s.p, r),\n\t\t\t\t\t DistanciaPuntoSegmento(s.q, r)),\n\t\t\t\t min(DistanciaPuntoSegmento(r.p, s),\n\t\t\t\t\t DistanciaPuntoSegmento(r.q, s)));\n}\n\n// Un poligono es una serie de\n// vertices conectados por aristas.\n// P = p1 -> p2 -> p3 -> ... -> pn -> p1.\ntypedef vector<Punto> Poligono;\n\n// Saber si un punto esta en el perimetro de un poligono.\nbool PuntoEnPerimetro(const Punto& p, const Poligono& P) {\n\tfor (int i = 1; i < P.size(); ++i) {\n\t\tif( PuntoEnSegmento( p, Linea( P[i-1], P[i] ) ) ) return true;\n\t}\n\treturn false;\n}\n\n// Prueba de punto en poligono convexo.\n// En el perimetro = -1, Fuera = 0, Dentro = 1.\nint PuntoEnConvexo(const Punto& p, const Poligono& P) {\n\tif (PuntoEnPerimetro(p, P)) return -1;\n\tint dir = ManoDerecha(P[0], P[1], p);\n\tfor (int i = 2; i < P.size(); ++i)\n\t\tif (ManoDerecha(P[i - 1], P[i], p)\n\t\t\t!= dir) return 0; // Fuera.\n\treturn 1; // Dentro.\n}\n\n\n// Punto en poligono concavo por ray casting.\n// En el perimetro = -1, Fuera = 0, Dentro = 1.\nint RayCasting(const Punto& p, const Poligono& P) {\n\tif (PuntoEnPerimetro(p, P)) return -1;\n\tPunto o = *min_element(P.begin(), P.end());\n\tLinea rayo(p, Punto(o.x - M_PI, o.y - M_E));\n\tint cruces = 0;\n\tfor (int i = 1; i < P.size(); ++i)\n\t\tif (InterseccionSegmentos(rayo,\n\t\t\tLinea(P[i - 1], P[i]))) ++cruces;\n\treturn cruces & 1;\n}\n\n// Punto en poligono concavo por angle summation.\n// En el perimetro = -1, Fuera = 0, Dentro = 1.\nint AngleSummation(const Punto& p, const Poligono& P) {\n\tif (PuntoEnPerimetro(p, P)) return -1;\n\tDouble angulo = 0;\n\tfor (int i = 1; i < P.size(); ++i)\n\t\tangulo += ManoDerecha(p, P[i - 1], P[i]) * Angulo(\n\t\t\tP[i - 1], p,P[i]);\n\treturn (fabs(angulo) > M_PI)? 1: 0;\n}\n\n// Area de un poligono.\nDouble Area(const Poligono& P) {\n\tDouble area = 0;\n\tfor (int i = 1; i < P.size(); ++i)\n\t\tarea += P[i - 1].Cruz(P[i]);\n\treturn fabs(area) / 2.0;\n}\n// Perimetro de un poligono.\nDouble Perimetro(const Poligono& P) {\n\tDouble perimetro = 0;\n\tfor (int i = 1; i < P.size(); ++i)\n\t\tperimetro += P[i].Dist(P[i - 1]);\n\treturn perimetro;\n}\n\n// Cerco convexo de un conjunto de puntos.\ntemplate<class It> Poligono CercoConvexo(It lo, It hi) {\n\tint k = 0;\n\tif (hi - lo <= 1) return Poligono(lo, hi);    \n\tPoligono H(2 * (int)(hi - lo));\n\tsort(lo, hi);\n\n\tfor (It it = lo; it != hi; ++it) {\n\t\twhile (k >= 2 && ManoDerecha(H[k - 2], H[k - 1], *it) < 1) k--;\n\t\tH[k++] = *it;\n\t}\n\tint t = k + 1;\n\tfor (It it = hi - 2; it != lo - 1; --it) {\n\t\twhile (k >= t && ManoDerecha(H[k - 2], H[k - 1], *it) < 1) k--;\n\t\tH[k++] = *it;\n\t}\n\tH.resize(k);\n\treturn H;\n}\n// Centroide de un poligono.\nPunto Centroide(const Poligono& P) {\n\tDouble x = 0, y = 0, k = 0;\n\tfor (int i = 1; i < P.size(); ++i) {\n\t\tDouble cruz = (P[i-1]).Cruz(P[i]);\n\t\tx += cruz * (P[i - 1].x + P[i].x);\n\t\ty += cruz * (P[i - 1].y + P[i].y);\n\t\tk += 3*cruz;\n\t}\n\treturn Punto(x/k, y/k);\n}\n\n// Saber si una recta corta un poligono.\nbool RectaCortaPoligono(\n\tconst Linea& r, const Poligono& P) {\n\tfor (int i = 0, prim = 0; i < P.size(); ++i) {\n\t\tint lado = ManoDerecha(r.p, r.q, P[i]);\n\t\tif (!lado) continue; if (!prim) prim = lado;\n\t\telse if (lado != prim) return true;\n\t}\n\treturn false;\n}\n\n// Obtiene los poligonos resultantes de\n// cortar un poligono convexo con una recta.\nvector<Poligono> CortarPoligono(\n\tconst Poligono& P, const Linea& r) {\n\tif (!RectaCortaPoligono(r, P))\n\t\treturn vector<Poligono>(1, P);\n\tint ind = 0;\n\tvector<Poligono> Ps(2);\n\tfor (int i = 1; i < P.size(); ++i) {\n\t\tLinea s(P[i - 1], P[i]);\n\t\tif (IntersecRectaSegmen(r, s)) {\n\t\t\tPunto p = PuntoInterseccion(r, s);\n\t\t\tif (P[i - 1] == p) continue;\n\t\t\tPs[ind].push_back(P[i - 1]);\n\t\t\tPs[1 - ind].push_back(p);\n\t\t\tPs[ind].push_back(p);\n\t\t\tind = 1 - ind;\n\t\t}\n\t\telse Ps[ind].push_back(P[i - 1]);\n\t}\n\tPs[0].push_back(Ps[0][0]);\n\tPs[1].push_back(Ps[1][0]);\n\treturn Ps;\n}\n\n\n\n\n\n\n\n\n\n\n\n//Dado un poligono convexo, devuelve todos los pares antipodales en orden\nvector<pii> RotatingCalipers( Poligono &P ){\n\tint k = 1, i = P.size()-2, j = 0;\n\twhile( fabs( ( P[j] - P[i] ).Cruz( P[k+1] - P[i] ) ) > \n\t\tfabs( ( P[j] - P[i] ).Cruz( P[k] - P[i] )) ) k++;\n\n\ti = 0, j = k;\n\n\tvector< pii > res;\n\twhile( i <= k && j < P.size()-1 ){\n\t\tres.push_back( pii(i,j) );\n\t\twhile( j < P.size()-1 && fabs( ( P[i+1] - P[i] ).Cruz( P[j+1] - P[i] ) ) > \n\t\tfabs( ( P[i+1] - P[i] ).Cruz( P[j] - P[i] ) ) ){\n\t\t\tj++;\n\t\t\tres.push_back( pii( i, j ));\n\t\t}\n\t\ti++;\n\t}\n\treturn res;\n}\n\n//Para ancho de poligono\n// vector< pii> tmp = RotatingCalipers( pol );\n// tmp.insert(tmp.end(), tmp.begin(), tmp.end() );\n// Double res = INF;\n// for( int i = 0; i < tmp.size()-1; i++){\n//  if( tmp[i].first == tmp[i+1].first && tmp[i].second+1 == tmp[i+1].second ){\n//      res = min( res, DistanciaPuntoRecta( pol[tmp[i].first], Linea( pol[tmp[i].second], pol[tmp[i+1].second] ) ) );\n//  }\n// }\n\n// for( int i = 0; i < tmp.size()-1; i++){\n//  if( tmp[i].second == tmp[i+1].second && tmp[i].first+1 == tmp[i+1].first ){\n//      res = min( res, DistanciaPuntoRecta( pol[tmp[i].second], Linea( pol[tmp[i].first], pol[tmp[i+1].first] ) ) );\n//  }\n// }    \n\n\n// Circulo en 2D.\nstruct Circulo {\n\tPunto c; Double r; Circulo() : c(), r() {}\n\tCirculo(const Punto& C, Double R) : c(C), r(R) {}\n\n\tbool operator<(const Circulo& cmp) const {\n\t\tif (!(c == cmp.c)) return c < cmp.c;\n\t\treturn EQ(r, cmp.r)? false: r < cmp.r;\n\t}\n};\n\n// Circunferencia de un circulo.\nDouble Circuferencia(const Circulo& c) {\n\treturn M_2PI * c.r;\n}\n\n// Area de un circulo.\nDouble Area(const Circulo& c) {\n\treturn M_PI * c.r * c.r;\n}\n\n// Saber si un punto esta dentro de un circulo.\n// En circunferencia = -1, Fuera = 0, Dentro = 1.\nint PuntoEnCirculo(const Punto& p, const Circulo& c) {\n\tDouble dist = p.Dist(c.c);\n\tif (EQ(dist, c.r)) return -1;\n\treturn (dist < c.r)? 1: 0;\n}\n\n// Distancia de un punto p a un circulo c\nDouble DistanciaPuntoCirculo(const Punto& p, const Circulo& c) {\n\tDouble dist = p.Dist( c.c) - c.r;\n\treturn (dist < 0)? 0: dist;\n}\n\n// Proyecta un punto fuera de un circulo en su circunferencia.\nPunto ProyPuntoCircunferencia(const Punto& p, const Circulo& c) {\n\tPunto v = c.c - p;\n\tDouble prop = DistanciaPuntoCirculo(p, c) / v.Abs();\n\treturn p + v*prop;\n}\n\n\n\n\n// Obtiene dos puntos que, desde el punto p, forman\n// lineas tangentes a la circunferencia del circulo c.\nLinea ProyTangentes(const Punto& p, const Circulo& c) {\n\tDouble a = acos(c.r / p.Dist( c.c));\n\tPunto p_ = ProyPuntoCircunferencia(p, c) - c.c;\n\treturn Linea(c.c + p_.RotarCCW(a),\n\t\t\t\t c.c + p_.RotarCW(a) );\n}\n\n// Saber si se intersecta un circulo c y una recta r.\n// Tangente = -1, No se intersectan = 0, Cuerda = 1.\nint IntersecCirculoRecta(const Circulo& c, const Linea& r) {\n\tDouble dist = DistanciaPuntoRecta(c.c, r);\n\tif (EQ(dist, c.r)) return -1;\n\treturn (dist < c.r)? 1: 0;\n}\n\n// Cuerda de interseccion entre un circulo y una recta.\nvector<Punto> CuerdaInterseccion( const Circulo& c, const Linea& r ){\n\tvector<Punto> ret;\n\tPunto b = r.q - r.p, a = r.p - c.c;\n\tDouble A = b.Dot(b);\n\tDouble B = a.Dot(b);\n\tDouble C = a.Dot(a) - c.r*c.r;\n\tDouble D = B*B - A*C;\n\tif( D + ERROR < 0 ) return ret;\n\tret.push_back( c.c + a + b * ((-B+sqrt(D+ERROR)) / A) );\n\tif( D > ERROR )\n\t\tret.push_back( c.c + a + b * ((-B-sqrt(D)) / A) );\n\treturn ret;\n}\n\n// Saber si un circulo c esta dentro de un circulo d.\nbool CirculoEnCirculo(const Circulo& c, const Circulo& d) {\n\treturn c.c.Dist(d.c) < d.r - c.r;\n}\n\n// Saber si el circulo c intersecta con el circulo d.\n// Uno dentro del otro = -1, Disjuntos = 0, Intersectan = 1.\nint IntersecCirculoCirculo(const Circulo& c, const Circulo& d) {\n\tDouble dist = c.c.Dist(d.c);\n\tif (dist < fabs(c.r - d.r)) return -1;\n\treturn (dist > c.r + d.r)? 0: 1;\n}\n\n//Dados 3 puntos, calcula el centro del circulo que los contiene.\nPunto CalcularCentroCirculo( Punto a, Punto b, Punto c ){\n\tb = ( a + b ) * 0.5;\n\tc = ( a + c ) * 0.5;\n\treturn PuntoInterseccion( Linea( b, b + ( a-b ).RotarCW(M_PI/2.0)), Linea( c, c+(a-c).RotarCW( M_PI/2.0 ) ) );\n}\n\n\n\n\n\n\n//Puntos de interseccion entre 2 circulos dados.\n//Regresa un vector con los puntos.\nvector<Punto> InterseccionCirculoCirculo( const Circulo& C, const Circulo& D ){\n\tvector<Punto> ret;\n\tDouble d = ( C.c - D.c ).Abs();\n\tif( d > C.r + D.r || d + min( C.r, D.r ) < max( C.r, D.r ) ) return ret;\n\tDouble x = ( d*d - D.r*D.r + C.r*C.r ) / (2*d);\n\tDouble y = sqrt( C.r*C.r - x*x );\n\tPunto v = ( D.c - C.c )/d;\n\tret.push_back( C.c+v*x + v.rot90()*y );\n\tif( y > 0 )\n\t\tret.push_back( C.c+v*x - v.rot90()*y );\n\treturn ret;\n}\n\n// Obtiene tangentes exteriores (las que NO se cruzan) entre dos circulos.\nint TangenteExtCirculoCirculo(const Circulo& a, const Circulo& b, Linea &s, Linea &t) {\n\t// Circulos identicos. Tangentes infinitas (segun el problema).\n\tif ( EQ(a.r, b.r) && a.c == b.c) \n\t\treturn 0; // O etiqueta de caso especial.\n\t// Uno es circulo interior del otro. Comparten una tangente.\n\t// EL CALCULO PUEDE COPIARSE A TangenteInt SI SE REQUIERE.\n\tPunto u;\n\tbool unico = false;\n\tif (b.r < a.r && EQ(a.c.Dist(b.c) + b.r, a.r)) {\n\t\tu = a.c + (b.c-a.c) * (a.r / a.c.Dist(b.c));\n\t\tunico = true;\n\t}\n\tif (a.r < b.r && EQ(a.c.Dist(b.c) + a.r, b.r)) {\n\t\tu = b.c + (a.c-b.c)*(b.r / a.c.Dist(b.c));\n\t\tunico = true;\n\t}\n\tif (unico) {\n\t\ts = t = PerpendicularEnPunto(Linea(a.c, b.c), u); // Recta de tangencia; un punto es referencia.\n\t\t//s = t = Linea(u, u); // Punto de tangencia.\n\t\treturn 1;\n\t}\n\t// Circulo en circulo. No hay tangentes.\n\tif (CirculoEnCirculo(a, b) || CirculoEnCirculo(b, a)) \n\t\treturn 0;\n\n\t// Calcular las 2 rectas tangentes.\n\tLinea proy;\n\tPunto v;\n\tif (EQ(a.r, b.r)) {\n\t\tproy = Linea(a.c, a.c);\n\t\tLinea perp = PerpendicularEnPunto(Linea(a.c, b.c), a.c);\n\t\tu = (perp.p-perp.q)* (b.r / perp.p.Dist(perp.q)); \n\t\tv = -u;\n\t} else {\n\t\tCirculo c(a.c, fabs(a.r - b.r));\n\t\tproy = ProyTangentes(b.c, c);\n\t\tu = (proy.p-a.c)* (b.r / (a.r - b.r));\n\t\tv = (proy.q-a.c)* (b.r / (a.r - b.r));\n\t}\n\ts = Linea( proy.p+u, b.c+u);\n\tt = Linea( proy.q+v, b.c+v);\n\treturn 2;\n}\n\n\n// Obtiene tangentes interiores (las que SI se cruzan) entre dos circulos.\nint TangenteIntCirculoCirculo(const Circulo& a, const Circulo& b, Linea &s, Linea &t) {\n\t// Circulos identicos. Tangentes infinitas (segun el problema)\n\tif (EQ(a.r, b.r) && a.c == b.c) {\n\t\treturn 0; // O etiqueta de caso especial.\n\t}\n\t// Uno es circulo interior del otro. Comparten una tangente.\n\t// CALCULO HECHO EN TangenteInt. Copiar de este si se requiere.\n\tPunto u;\n\t// Circulos tangentes. Obtener recta tangente unica.\n\tif (EQ(a.c.Dist(b.c), a.r + b.r)) {\n\t\tu = b.c + (a.c-b.c) * (b.r / a.c.Dist(b.c));\n\t\ts = t = PerpendicularEnPunto(Linea(a.c, b.c), u); // Recta de tangencia.\n\t\t//s = t = Linea(u, u); // Punto de tangencia.\n\t\treturn 1;\n\t}\n\t// Circulos se traslapan. no hay tangentes.\n\tif (!(a.r + b.r < a.c.Dist(b.c))) {\n\t\treturn 0;\n\t}\n\t// Obtener 2 rectas tangentes.\n\tLinea proy;\n\tPunto v;\n\tCirculo c(a.c, a.r + b.r);\n\tproy = ProyTangentes(b.c, c);\n\tu = (proy.p - a.c) * (b.r / (a.r + b.r));\n\tv = (proy.q - a.c) * (b.r / (a.r + b.r));\n\ts = Linea( proy.p - u, b.c-u);\n\tt = Linea( proy.q - v, b.c-v);\n\treturn 2;\n}\n\nint main(){\n\tint N;\n\n\tcin >> N;\n\n\tPoligono pol(N);\n\tfor( int i = 0; i < N; i++ ){\n\t\tcin >> pol[i].x >> pol[i].y;\n\t}\n\n\tpol = CercoConvexo( pol.begin(), pol.end() );\n\tvector<pii> tmp = RotatingCalipers( pol );\n\n\tDouble distancia = 0.0;\n\tfor( int i = 0; i < tmp.size(); i++ ){\n\t\tdistancia = max( distancia, pol[tmp[i].first].Dist( pol[tmp[i].second] ) );\n\t}\n\tcout << fixed << setprecision( 7 ) <<distancia << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nbool sortX(Point p1,Point p2){\n  if(p1.x != p2.x){\n    return (p1.x - p2.x < -EPS);\n  }else{\n    return (p1.y - p2.y < -EPS);\n  }\n}\n\nbool sortY(Point p1,Point p2){\n  if(p1.y != p2.y){\n    return (p1.y - p2.y < -EPS);\n  }else{\n    return (p1.x - p2.x < -EPS);\n  }\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon convex_hull(Polygon &ps){\n  int N = ps.size(),j = 0;\n  Polygon pg(N*2);\n  sort(ps.begin(),ps.end(),sortY);\n  for(int i = 0 ; i < N ; i++,j++){\n    while(j >= 2 && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2 ; i >= 0 ; i--,j++){\n    while(j >= k && ccw(pg[j-2],pg[j-1],ps[i]) == -1){\n      j--;\n    }\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\ndouble getPolygonDiameter(Polygon &p){\n  Polygon np = convex_hull(p);\n  int N = np.size();\n  if(N == 2){ return dist(np[0],np[1]); }\n  int i = 0,j = 0;\n  for(int k = 0 ; k < N ; k++){\n    if(!sortX(np[i],np[k])){ i = k; }\n    if(sortY(np[j],np[k])){ j = k; }\n  }\n  double res = 0;\n  int si = i,sj = j;\n  while(i != sj || j != si){\n    res = max(res,dist(np[i],np[j]));\n    Point p1 = np[(i+1)%N]-np[i];\n    Point p2 = np[(j+1)%N]-np[j];\n    if(cross(p1,p2) < 0){\n      i = (i + 1) % N;\n    }else{\n      j = (j + 1) % N;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  Polygon p(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> p[i].x >> p[i].y;\n  }\n  printf(\"%.10f\\n\",getPolygonDiameter(p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, N) for (int i = 0; i < (int)N; ++i)\n#define all(a) (a).begin(), (a).end()\nconst double EPS = 1e-10;\nbool equals(double a, double b) { return fabs(a - b) < EPS; }\n\nclass Point {\n  double add(double a, double b) const {\n    if (fabs(a + b) < EPS * (fabs(a) + fabs(b))) return 0;\n    return a + b;\n  }\n\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n  Point operator+(const Point &p) const {\n    return Point(add(x, p.x), add(y, p.y));\n  }\n  Point operator-(const Point &p) const {\n    return Point(add(x, -p.x), add(y, -p.y));\n  }\n  Point operator*(const double a) { return Point(a * x, a * y); }\n  Point operator/(const double a) { return Point(x / a, y / a); }\n\n  double abs() const { return sqrt(norm()); }\n  double norm() const { return x * x + y * y; }\n\n  Point rotate(double theta) const {\n    return Point(cos(theta) * x - sin(theta) * y,\n                 sin(theta) * x + cos(theta) * y);\n  }\n\n  Point normalize() const { return Point(*this) / abs(); }\n\n  bool operator<(const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\n  bool operator==(const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n  friend istream &operator>>(istream &is, Point &p) { return is >> p.x >> p.y; }\n};\n\ndouble abs(const Point &p) { return p.abs(); }\ndouble norm(const Point &p) { return p.norm(); }\n\ntypedef Point Vector;\n\nclass Segment {\n public:\n  Point p1, p2;\n  Segment() {}\n  Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n  friend istream &operator>>(istream &is, Segment &s) {\n    return is >> s.p1 >> s.p2;\n  }\n};\n\ntypedef Segment Line;\n\nclass Circle {\n public:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n\n  int contains(const Point &p) const {\n    double d = abs(c - p);\n    if (equals(d, r)) return 1;  // ON\n    if (d < r + EPS) return 2;   // IN\n    return 0;                    // OUT\n  }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\n\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p) * 2.0; }\n\ndouble distance(Point a, Point b) { return (a - b).abs(); }\n\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble distanceSP(Segment s, Point p) {\n  if (dot(s.p2 - s.p1, p - s.p1) < -EPS) return (p - s.p1).abs();\n  if (dot(s.p1 - s.p2, p - s.p2) < -EPS) return (p - s.p2).abs();\n  return distanceLP(s, p);\n}\n\nbool intersect(Segment s1, Segment s2);\ndouble distance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) return 0.0;\n  return min({distanceSP(s1, s2.p1), distanceSP(s1, s2.p2),\n              distanceSP(s2, s1.p1), distanceSP(s2, s1.p2)});\n}\n\nenum CCW {\n  COUNTER_CLOCKWISE = 1,\n  CLOCKWISE = -1,\n  ONLINE_BACK = 2,\n  ONLINE_FRONT = -2,\n  ON_SEGMENT = 0,\n};\n\nCCW ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;      // p2, p0, p1\n  if (a.norm() < b.norm()) return ONLINE_FRONT;  // p0, p1, p2\n  return ON_SEGMENT;                             // p0, p2, p1\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint crossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nbool intersect(Circle c, Line l) { return distanceLP(l, c.c) < c.r; }\n\npair<Point, Point> crossPoint(Circle c, Line l) {\n  assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  double base = sqrt(c.r * c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\nbool intersect(Circle c1, Circle c2) {\n  return (c1.c - c2.c).abs() < c1.r + c2.r;\n}\n\npair<Point, Point> crossPoint(Circle c1, Circle c2) {\n  assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n/*\n  IN 2\n  ON 1\n  OUT 0\n*/\nint contains(const Polygon &g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for (int i = 0; i < n; ++i) {\n    Point a = g[i] - p, b = g[(i + 1) % n] - p;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n    if (a.y > b.y) swap(a, b);\n    if (a.y < EPS & EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? 2 : 0);\n}\n\nPolygon convexHull(Polygon s, bool includeOnSegment = false) {\n  Polygon u, l;\n\n  if (s.size() < 3) return s;\n  sort(s.begin(), s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size() - 1]);\n  l.push_back(s[s.size() - 2]);\n\n  auto bad = [&](Point p1, Point p2, Point p3) {\n    if (includeOnSegment) {\n      return ccw(p1, p2, p3) == COUNTER_CLOCKWISE;\n    } else {\n      return ccw(p1, p2, p3) != CLOCKWISE;\n    }\n  };\n\n  for (int i = 2; i < s.size(); ++i) {\n    for (int n = u.size(); n >= 2 && bad(u[n - 2], u[n - 1], s[i]); --n) {\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n\n  for (int i = s.size() - 3; i >= 0; i--) {\n    for (int n = l.size(); n >= 2 && bad(l[n - 2], l[n - 1], s[i]); --n) {\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(), l.end());\n  for (int i = u.size() - 2; i >= 1; --i) l.push_back(u[i]);\n\n  return l;\n}\n\nCircle circumscribedCircle(const Point &a, const Point &b, const Point &c) {\n  double a1, a2, b1, b2, c1, c2;\n  a1 = 2 * (b.x - a.x);\n  b1 = 2 * (b.y - a.y);\n  c1 = a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y;\n  a2 = 2 * (c.x - a.x);\n  b2 = 2 * (c.y - a.y);\n  c2 = a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y;\n  Point p;\n  p.x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n  p.y = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);\n\n  return Circle(p, abs(p - a));\n}\n\n// https://en.wikipedia.org/wiki/Green's_theorem#Area_Calculation\ndouble area(const Polygon &p) {\n  double ans = 0;\n  const int N = p.size();\n  for (int i = 0; i < N; ++i) {\n    Point q = p[(i + 1) % N];\n    ans += (p[i].y + q.y) * (q.x - p[i].x);\n  }\n  ans /= 2.0;\n  return fabs(ans);\n}\n\n// The points must be counter-clockwise order\nbool isConvex(const Polygon &p) {\n  const int N = p.size();\n\n  for (int i = 0; i < N; ++i) {\n    Point pn = p[(i + 1) % N], pnn = p[(i + 2) % N];\n    int d = ccw(p[i], pn, pnn);\n    if (d == CLOCKWISE) return false;\n  }\n  return true;\n}\n\n// Rotating calipers or Shamos's algorithm\npair<Point, Point> farthestPoints(const Polygon &p) {\n  Polygon ch = convexHull(p);\n\n  int n = ch.size();\n  if (n == 2) return make_pair(ch[0], ch[1]);\n  int i = 0, j = 0;\n  for (int k = 0; k < n; ++k) {\n    if (!(ch[i] < ch[k])) i = k;\n    if (ch[j] < ch[k]) j = k;\n  }\n\n  pair<Point, Point> res;\n  double d = 0;\n  int si = i, sj = j;\n  while (i != sj || j != si) {\n    double cd = abs(ch[i] - ch[j]);\n    if (cd > d) {\n      d = cd;\n      res = make_pair(ch[i], ch[j]);\n    }\n\n    if (cross(ch[(i + 1) % n] - ch[i], ch[(j + 1) % n] - ch[j]) < 0) {\n      i = (i + 1) % n;\n    } else {\n      j = (j + 1) % n;\n    }\n  }\n  return res;\n}\n\ndouble diameter(const Polygon &p) {\n  pair<Point, Point> pts = farthestPoints(p);\n  return abs(pts.first - pts.second);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  Polygon p(n);\n  rep(i, n) cin >> p[i];\n\n  printf(\"%.10lf\\n\", diameter(p));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ header\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\nusing i128 = __int128_t;\nusing u128 = __uint128_t;\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'000LL;\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// {{{ util\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(begin(cccc), end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? begin(cccc)+llll : end(cccc);\\\n    auto jjjj = llll <= rrrr ? begin(cccc)+rrrr : end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n    for(auto first = begin(v), it = first; it != end(v); ++it) {\n        if(it != first)\n            out << ' ';\n        out << *it;\n    }\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    cout << x;\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \" << value << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n// }}}\n\n// {{{ init\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\nstruct Vector {\n    f64 x, y;\n\n    Vector() : Vector(0,0) {}\n    Vector(f64 xx, f64 yy) : x(xx), y(yy) {}\n\n    const Vector operator-() const {\n        return Vector(-x,-y);\n    }\n    Vector& operator+=(const Vector& rhs) {\n        x += rhs.x;\n        y += rhs.y;\n        return *this;\n    }\n    Vector& operator-=(const Vector& rhs) {\n        x -= rhs.x;\n        y -= rhs.y;\n        return *this;\n    }\n    Vector& operator*=(f64 rhs) {\n        x *= rhs;\n        y *= rhs;\n        return *this;\n    }\n    Vector& operator/=(f64 rhs) {\n        x /= rhs;\n        y /= rhs;\n        return *this;\n    }\n\n    f64 norm() const { return x*x + y*y; }\n    f64 abs() const { return sqrt(norm()); }\n\n    Vector unit() const { return Vector(*this) /= this->abs(); }\n};\n\nconst Vector operator+(const Vector& lhs, const Vector& rhs) { return Vector(lhs) += rhs; }\nconst Vector operator-(const Vector& lhs, const Vector& rhs) { return Vector(lhs) -= rhs; }\nconst Vector operator*(const Vector& lhs, f64 rhs) { return Vector(lhs) *= rhs; }\nconst Vector operator*(f64 lhs, const Vector& rhs) { return Vector(rhs) *= lhs; }\nconst Vector operator/(const Vector& lhs, f64 rhs) { return Vector(lhs) /= rhs; }\n\nbool operator==(const Vector& lhs, const Vector& rhs) {\n    return feq(lhs.x,rhs.x) && feq(lhs.y,rhs.y);\n}\n\nf64 geo_dot(const Vector& lhs, const Vector& rhs) {\n    return lhs.x*rhs.x + lhs.y*rhs.y;\n}\n\nf64 geo_cross(const Vector& lhs, const Vector& rhs) {\n    return lhs.x*rhs.y - lhs.y*rhs.x;\n}\n\nVector geo_rotate(const Vector& v, f64 t) {\n    return Vector(v.x*cos(t)-v.y*sin(t), v.x*sin(t)+v.y*cos(t));\n}\n\nenum ABC {\n    ABC_CCW        =  1,\n    ABC_CW         = -1,\n    ABC_ON_BACK    =  2,\n    ABC_ON_FRONT   = -2,\n    ABC_ON_SEGMENT =  0,\n};\n\nABC geo_abc(const Vector& a, const Vector& b, const Vector& c) {\n    Vector x = b - a;\n    Vector y = c - a;\n    f64 cross = geo_cross(x,y);\n    if(cross > 0) return ABC_CCW;\n    if(cross < 0) return ABC_CW;\n    f64 dot = geo_dot(x,y);\n    if(dot < 0) return ABC_ON_BACK;\n    if(x.norm() < y.norm()) return ABC_ON_FRONT;\n    return ABC_ON_SEGMENT;\n}\n\nenum Containment {\n    CONT_IN,\n    CONT_ON,\n    CONT_OUT,\n};\n\nostream& operator<<(ostream& out, const Vector& v) {\n    return out << \"Vector(\" << v.x << \",\" << v.y << \")\";\n}\n\nstruct Segment {\n    Vector p1, p2;\n\n    Segment(const Vector& pp1, const Vector& pp2) : p1(pp1), p2(pp2) {}\n    Segment(f64 x1, f64 y1, f64 x2, f64 y2) : p1(Vector(x1,y1)), p2(Vector(x2,y2)) {}\n\n    Vector vec() const { return p2 - p1; }\n\n    f64 norm() const { return vec().norm(); }\n    f64 abs() const { return vec().abs(); }\n};\n\nostream& operator<<(ostream& out, const Segment& seg) {\n    out << \"Segment(\";\n    out << \"(\" << seg.p1.x << \",\" << seg.p1.y << \")\";\n    out << \",\";\n    out << \"(\" << seg.p2.x << \",\" << seg.p2.y << \")\";\n    out << \")\";\n    return out;\n}\n\nstruct Line {\n    Vector p1, p2;\n\n    Line(const Vector& pp1, const Vector& pp2) : p1(pp1), p2(pp2) {}\n    Line(f64 x1, f64 y1, f64 x2, f64 y2) : p1(Vector(x1,y1)), p2(Vector(x2,y2)) {}\n    Line(const Segment& seg) : p1(seg.p1), p2(seg.p2) {}\n\n    Vector vec() const { return p2 - p1; }\n};\n\nostream& operator<<(ostream& out, const Line& line) {\n    out << \"Line(\";\n    out << \"(\" << line.p1.x << \",\" << line.p1.y << \")\";\n    out << \",\";\n    out << \"(\" << line.p2.x << \",\" << line.p2.y << \")\";\n    out << \")\";\n    return out;\n}\n\nstruct Circle {\n    Vector c;\n    f64 r;\n\n    Circle(const Vector& cc, f64 rr) : c(cc), r(rr) {}\n};\n\nostream& operator<<(ostream& out, const Circle& cir) {\n    out << \"Circle(\";\n    out << \"(\" << cir.c.x << \",\" << cir.c.y << \")\";\n    out << \",\";\n    out << cir.r;\n    out << \")\";\n    return out;\n}\n\nstruct Polygon {\n    vector<Vector> ps;\n\n    explicit Polygon(const vector<Vector>& ps_arg) : ps(ps_arg) {}\n\n    f64 area_2x() const {\n        i64 n = SIZE(ps);\n        if(n < 3) return 0;\n        f64 sum = 0;\n        REP(i, n) {\n            sum += geo_cross(cur(i), nex(i));\n        }\n        return fabs(sum);\n    }\n    f64 area() const { return area_2x() / 2; }\n\n    // 凸性判定(全ての内角が180度以下)\n    // 3点が同一直線上にあるケースは許容する(この辺ちょっと怪しい)\n    // 2角形以下の場合 false を返す\n    bool is_convex() const {\n        i64 n = SIZE(ps);\n        if(n < 3) return false;\n        i64 abc = 0;\n        REP(i, n) {\n            ABC abc_cur = geo_abc(pre(i), cur(i), nex(i));\n            if(abc_cur != ABC_CCW && abc_cur != ABC_CW) continue;\n            if(abc_cur*abc == -1) return false;\n            abc = abc_cur;\n        }\n        return true;\n    }\n\n    // 点の包含判定\n    // 2角形以下の場合 CONT_OUT を返す\n    Containment containment(const Vector& p) const {\n        i64 n = SIZE(ps);\n        if(n < 3) return CONT_OUT;\n        i64 cnt = 0;\n        REP(i, n) {\n            Vector a = cur(i) - p;\n            Vector b = nex(i) - p;\n            if(feq(geo_cross(a,b),0) && geo_dot(a,b) <= 0) return CONT_ON;\n            if(a.y > b.y) swap(a,b);\n            if(a.y <= 0 && b.y > 0 && geo_cross(a,b) > 0) ++cnt;\n        }\n        return is_odd(cnt) ? CONT_IN : CONT_OUT;\n    }\n\n    Vector cur(i64 i) const { return ps[i]; }\n    Vector pre(i64 i) const { return ps[modulo(i-1,SIZE(ps))]; }\n    Vector nex(i64 i) const { return ps[modulo(i+1,SIZE(ps))]; }\n};\n\nostream& operator<<(ostream& out, const Polygon& poly) {\n    out << \"Polygon(\";\n    i64 n = SIZE(poly.ps);\n    REP(i, n) {\n        const Vector& p = poly.ps[i];\n        out << \"(\" << p.x << \",\" << p.y << \")\";\n        if(i != n-1)\n            out << \",\";\n    }\n    out << \")\";\n    return out;\n}\n\nVector geo_project(const Line& line, const Vector& p) {\n    Vector v = line.vec();\n    f64 r = geo_dot(p-line.p1, v) / v.norm();\n    return line.p1 + r*v;\n}\n\nbool geo_intersect(const Segment& x, const Segment& y) {\n    return geo_abc(x.p1,x.p2,y.p1) * geo_abc(x.p1,x.p2,y.p2) <= 0 &&\n           geo_abc(y.p1,y.p2,x.p1) * geo_abc(y.p1,y.p2,x.p2) <= 0;\n}\n\nbool geo_intersect(const Circle& cir1, const Circle& cir2) {\n    return (cir1.c-cir2.c).norm() <= pow(cir1.r+cir2.r,2);\n}\n\nf64 geo_distance(const Line& line, const Vector& p) {\n    Vector v = line.vec();\n    return fabs(geo_cross(v,p-line.p1)) / v.abs();\n}\n\nf64 geo_distance(const Segment& seg, const Vector& p) {\n    if(geo_dot( seg.vec(), p-seg.p1) < 0) return (p-seg.p1).abs();\n    if(geo_dot(-seg.vec(), p-seg.p2) < 0) return (p-seg.p2).abs();\n    return geo_distance(Line(seg), p);\n}\n\nf64 geo_distance(const Segment& seg1, const Segment& seg2) {\n    if(geo_intersect(seg1,seg2)) return 0;\n    return min({\n        geo_distance(seg1, seg2.p1),\n        geo_distance(seg1, seg2.p2),\n        geo_distance(seg2, seg1.p1),\n        geo_distance(seg2, seg1.p2),\n    });\n}\n\nbool geo_intersect(const Circle& cir, const Line& line) {\n    return geo_distance(line, cir.c) <= cir.r;\n}\n\nVector geo_crosspoint(const Segment& x, const Segment& y) {\n    Line ly = Line(y);\n    f64 d1 = geo_distance(ly, x.p1);\n    f64 d2 = geo_distance(ly, x.p2);\n    return x.p1 + (d1/(d1+d2))*x.vec();\n}\n\n// 接する場合も同じ座標2つを返す\nvector<Vector> geo_crosspoints(const Circle& cir, const Line& line) {\n    if(!geo_intersect(cir,line)) return {};\n    Vector p = geo_project(line, cir.c);\n    Vector e = line.vec().unit();\n    f64 t = sqrt(cir.r*cir.r - (p-cir.c).norm());\n    return { p+t*e, p-t*e };\n}\n\n// 接する場合も同じ座標2つを返す\nvector<Vector> geo_crosspoints(const Circle& cir1, const Circle& cir2) {\n    if(!geo_intersect(cir1,cir2)) return {};\n    Vector v = cir2.c - cir1.c;\n    f64 d = v.abs();\n    f64 t = acos((cir1.r*cir1.r + d*d - cir2.r*cir2.r) / (2*cir1.r*d));\n    return {\n        cir1.c + geo_rotate(v, t) / d * cir1.r,\n        cir1.c + geo_rotate(v,-t) / d * cir1.r,\n    };\n}\n\n// 凸包\n//\n// * 始点はy座標最小のもののうちx座標最小のもの\n// * 反時計回り\n// * 辺上の点を含む\nPolygon geo_convex_hull(vector<Vector> ps) {\n    i64 n = SIZE(ps);\n    assert(n >= 3);\n\n    vector<Vector> res;\n    res.reserve(n);\n\n    ALL(sort, ps, ON(less<>(), [](const Vector& p) { return make_pair(p.y,p.x); }));\n\n    auto step = [&res](const Vector& p) {\n        while(SIZE(res) >= 2) {\n            i64 k = SIZE(res);\n            // 辺上の点を含めたくなければ \"!= ABC_CW\" を \"== ABC_CCW\" に変える\n            if(geo_abc(res[k-2],res[k-1],p) != ABC_CW) break;\n            res.pop_back();\n        }\n        res.emplace_back(p);\n    };\n\n    // lower hull\n    for(i64 i = 0; i < n; ++i) {\n        step(ps[i]);\n    }\n    // upper hull\n    for(i64 i = n-2; i >= 0; --i) {\n        step(ps[i]);\n    }\n    // 始点が重複するので削除\n    res.pop_back();\n\n    return Polygon(res);\n}\n\nvoid RD(Vector& v) {\n    RD(v.x);\n    RD(v.y);\n}\n\n//--------------------------------------------------------------------\n\n// 凸多角形の直径 (Rotating Calipers)\n//\n// (直径の2乗, index_端点1, index_端点2) を返す\n// convex は凸多角形でなければならない\ntuple<f64,i64,i64> convex_diameter_sq(const Polygon& convex) {\n    const auto& ps = convex.ps;\n    i64 n = SIZE(ps);\n\n    auto cmp_y = ON(less<>(), [](const Vector& p) { return p.y; });\n    i64 istart = ALL(max_element, ps, cmp_y) - begin(ps);\n    i64 jstart = ALL(min_element, ps, cmp_y) - begin(ps);\n\n    auto nex = [n](i64 i) { return modulo(i+1,n); };\n\n    f64 d2max = (ps[istart]-ps[jstart]).norm();\n    i64 i, imax, j, jmax;\n    i = imax = istart;\n    j = jmax = jstart;\n    do {\n        Vector vi = ps[nex(i)] - ps[i];\n        Vector vj = ps[nex(j)] - ps[j];\n        if(geo_cross(vi,vj) >= 0)\n            j = nex(j);\n        else\n            i = nex(i);\n        if(chmax(d2max, (ps[i]-ps[j]).norm())) {\n            imax = i;\n            jmax = j;\n        }\n    } while(i != istart || j != jstart);\n\n    // AOJだとコンパイラが古くてCE\n    //return { d2max, imax, jmax };\n    return make_tuple(d2max, imax, jmax);\n}\n\nvoid solve() {\n    i64 N; RD(N);\n    vector<Vector> ps; RD(ps, N);\n    Polygon convex(ps);\n\n    f64 d2; tie(d2,ignore,ignore) = convex_diameter_sq(convex);\n    f64 ans = sqrt(d2);\n\n    PRINTLN(ans);\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\n\n//?????????????????????¢?????????\ndouble norm2(POINT a){\nreturn POW2(a.x)+POW2(a.y);\n}\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\tb.y -= a.y;\n\treturn b;\n}\n\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n\ndouble diameter_poly(POINT p[],int n){\n\tPOINT g[n];\n\tint i,j;\n\tdouble m = -1.0;\n\tfor(i = 0;i < n;i++){\n\t\tfor(j = i+1;j < n;j++){\n\t\t\tm = max(distance(p[i],p[j]),m);\n\t\t}\n\t}\n\treturn m;\n}\n\nint main(){\n\tint k;\n\tint i;\n\tPOINT p[101];\n\tscanf(\"%d\",&k);\n\tfor(i =0 ;i < k;i++){\n\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t}\n\tprintf(\"%.10lf\\n\",diameter_poly(p,k));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\n\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\n\tb.y -= a.y;\n\treturn b;\n}\n\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n\ndouble diameter_poly(POINT p[],int n){\n\tPOINT g[n];\n\tint i,j;\ndouble m = -1.0;\n\tfor(i = 0;i < n;i++){\n\t\tfor(j = i+1;j < n;j++){\n\t\t\tm = max(distance(p[i],p[j]),m);\n\t\t}\n\t}\n\treturn m;\n}\n\nint main(){\n\tint k;\n\tint i;\n\tPOINT p[100005];\n\tscanf(\"%d\",&k);\n\tfor(i =0 ;i < k;i++){\n\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t}\n\tprintf(\"%.12lf\\n\",diameter_poly(p,k));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ CGL_4_B Diameter of a Convex Polygon\n// 2018.5.3 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define EPS 1e-8\n\ntypedef struct { double x, y; } PP;\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\tc = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()\n{\n\tint minus = 0;\n\tdouble x, y;\n\tint n = 0, c = gc();\n\tif (c == '-') minus = 1, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\n\tif (c == '.') {\n\t\tx = 0;\n\t\ty = 1, c = gc();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = gc(); while (c >= '0');\n\t\tx += n;\n\t} else x = n;\n\tif (minus) x = -x;\n\treturn x;\n}\n\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\ndouble convexDiameter(int n, PP *poly)\n{\n\tint i, j, maxi, maxj;\n\tdouble maxd, d;\n\n\tint is = 0, js = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tif (poly[i].y > poly[is].y) is = i;\n\t\tif (poly[i].y < poly[js].y) js = i;\n\t}\n\tmaxd = norm(vsub(poly[is], poly[js]));\n\n\ti = maxi = is;\n\tj = maxj = js;\n\tpoly[n] = poly[0];\n\tdo {\n\t\tif (cross(vsub(poly[i+1], poly[i]), vsub(poly[j+1], poly[j])) >= 0) {\n\t\t\tif (++j == n) j = 0;\n\t\t} else {\n\t\t\tif (++i == n) i = 0;\n\t\t}\n\t    if ((d=norm(vsub(poly[i], poly[j]))) > maxd) {\n\t\t\tmaxd = d;\n\t\t\tmaxi = i; maxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\treturn maxd; /* farthest pair is (maxi, maxj). */\n}\n\nPP p[80005];\n\nint main()\n{\n\tint n, i;\n\n\tn = in();\n\tfor (i = 0; i < n; i++) p[i].x = dbl(), p[i].y = dbl();\n\tprintf(\"%.10lf\\n\", sqrt(convexDiameter(n, p)));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ CGL_4_B Diameter of a Convex Polygon\n// 2018.5.3 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define EPS 1e-8\n\ntypedef struct { double x, y; } PP;\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\tc = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()\n{\n\tint minus = 0;\n\tdouble x, y;\n\tint n = 0, c = gc();\n\tif (c == '-') minus = 1, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\n\tif (c == '.') {\n\t\tx = 0;\n\t\ty = 1, c = gc();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = gc(); while (c >= '0');\n\t\tx += n;\n\t} else x = n;\n\tif (minus) x = -x;\n\treturn x;\n}\n\ndouble dist(PP p1, PP p2) {\treturn hypot(p1.x-p2.x, p1.y-p2.y); }\n\ndouble solve_by_movement(int n, PP *p)\n{\n\tint  k, i, t;\n\tPP a;\n\tdouble move, max, d;\n\n    a.x = a.y = 0;\n\tmove = 0.5;\n\twhile (move > EPS) {\n\t\tfor (t = 0; t < 100; t++) {\n\t\t\tmax = 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tif ((d = dist(a, p[i])) > max) max = d, k = i;\n\t\t\t}\n\t\t\ta.x += (p[k].x - a.x)*move;\n\t\t\ta.y += (p[k].y - a.y)*move;\n\t\t}\n\t\tmove /= 2;\n\t}\n\treturn max;\n}\n\nPP p[80005];\n\nint main()\n{\n\tint n, i;\n\n\tn = in();\n\tfor (i = 0; i < n; i++) p[i].x = dbl(), p[i].y = dbl();\n\tprintf(\"%.10lf\\n\", 2*solve_by_movement(n, p));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\n\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\n\tb.y -= a.y;\n\treturn b;\n}\n\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n\ndouble diameter_poly(POINT p[],int n){\n\tPOINT g[n];\n\tint i,j,m = -1;\n\tfor(i = 0;i < n;i++){\n\t\tfor(j = i+1;j < n;j++){\n\t\t\tm = max(distance(p[i],p[j]),m);\n\t\t}\n\t}\n\treturn m;\n}\n\nint main(){\n\tint k;\n\tint i;\n\tPOINT p[101];\n\tscanf(\"%d\",&k);\n\tfor(i =0 ;i < k;i++){\n\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t}\n\tprintf(\"%.10lf\\n\",diameter_poly(p,k));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define det(x1, y1, x2, y2) ((x1) * (y2) - (x2) * (y1))\n#define distance(x, y) (sqrt(pow(x, 2) + pow(y, 2)))\n#define max(x, y) ((x) > (y) ? (x) : (y))\n\ntypedef struct {\n        double x;\n        double y;\n} Point;\n\nint compare(Point, Point);\nvoid qsort1(int, int, Point*);\nint convex_hull(Point*, Point*, int);\ndouble caliper(Point*, int);\nmain()\n{\n        int i, size, qsize;\n        Point *ps, *qs;\n        scanf(\"%d\", &size);\n        ps = (Point*)malloc(sizeof(Point) * size);\n        qs = (Point*)malloc(sizeof(Point) * size * 2);\n        for (i = 0; i < size; i++) {\n                scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n        }\n        qsize = convex_hull(qs, ps, size);\n        printf(\"%.7f\\n\", caliper(qs, qsize));\n        free(ps);\n        free(qs);\n}\n\nint compare(Point arg1, Point arg2)\n{\n        double p1 = arg1.x - arg2.x, p2 = arg1.y - arg2.y;\n        if (p1 > 0 || (p1 == 0 && p2 > 0)) {\n                return 1;\n        } else if (p1 < 0 || (p1 == 0 && p2 < 0)) {\n                return -1;\n        } else {\n                return 0;\n        }\n}\n\nvoid qsort1(int left, int right, Point *p)\n{\n    int pivot = (left + right) / 2, i = left, j = right;\n    if(left >= right) return;\n    do{\n        while(compare(p[pivot], p[i]) == 1) i++;\n        while(compare(p[pivot], p[j]) == -1) j--;\n        if(i <= j){\n            Point temp = p[i];\n                        p[i] = p[j];\n                        p[j] = temp;\n            i++;\n            j--;\n        }\n    }while(i <= j);\n    qsort1(left, j, p);\n    qsort1(i, right, p);\n}\n\nint convex_hull(Point *qs, Point *ps, int size)\n{\n        int i, t, k = 0;\n        qsort1(0, size - 1, ps);\n        for (i = 0; i < size; i++) {\n                while (k > 1 && det(qs[k-1].x - qs[k-2].x, qs[k-1].y - qs[k-2].y,\n                                                        ps[i].x - qs[k-1].x, ps[i].y - qs[k-1].y) <= 0) {\n                        k--;\n                }\n                qs[k++] = ps[i];\n        }\n        for (i = size - 2, t = k; i >= 0; i--) {\n        while (k > t && det(qs[k-1].x - qs[k-2].x, qs[k-1].y - qs[k-2].y,\n                            ps[i].x - qs[k-1].x, ps[i].y - qs[k-1].y) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n        qs = (Point*)realloc(qs, sizeof(Point) * (k - 1));\n        //printf(\"%d\\n\", k - 1);\n        //printf(\"%f %f\\n\", qs[1257].x, qs[1257].y);\n        return (k - 1);\n}\n\ndouble caliper(Point *qs, int qsize)\n{\n        int i, j, k, si, sj;\n        double result = 0;\n        if (qsize == 2) {\n                return distance(qs[0].x - qs[1].x, qs[0].y - qs[1].y);\n        }\n        for (i = j = k = 0; k < qsize; k++) {\n                if (compare(qs[i], qs[k]) == -1) i = k;\n                if (compare(qs[j], qs[k]) == 1) j = k;\n        }\n        si = i;\n        sj = j;\n        while (i != sj || j != si) {\n                result = max(result, distance(qs[i].x - qs[j].x, qs[i].y - qs[j].y));\n                if (det(qs[(i+1)%qsize].x - qs[i].x, qs[(i+1)%qsize].y - qs[i].y,\n                                qs[(j+1)%qsize].x - qs[j].x, qs[(j+1)%qsize].y - qs[j].y) < 0){\n                        i = (i + 1) % qsize;\n                } else {\n                        j = (j + 1) % qsize;\n                }\n        }\n                return result;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\n\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\n\tb.y -= a.y;\n\treturn b;\n}\n\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n\ndouble diameter_poly(POINT p[],int n){\n\tPOINT g[n];\n\tint i,j;\ndouble m = -1.0;\n\tfor(i = 0;i < n;i++){\n\t\tfor(j = i+1;j < n;j++){\n\t\t\tm = max(distance(p[i],p[j]),m);\n\t\t}\n\t}\n\treturn m;\n}\n\nint main(){\n\tint k;\n\tint i;\n\tPOINT p[101];\n\tscanf(\"%d\",&k);\n\tfor(i =0 ;i < k;i++){\n\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t}\n\tprintf(\"%.12lf\\n\",diameter_poly(p,k));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\n\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\n\tb.y -= a.y;\n\treturn b;\n}\n\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n\ndouble diameter_poly(POINT p[],int n){\n\tPOINT g[n];\n\tint i,j,m = -1;\n\tfor(i = 0;i < n;i++){\n\t\tfor(j = i+1;j < n;j++){\n\t\t\tm = max(distance(p[i],p[j]),m);\n\t\t}\n\t}\n\treturn m;\n}\n\nint main(){\n\tint k;\n\tint i;\n\tPOINT p[101];\n\tscanf(\"%d\",&k);\n\tfor(i =0 ;i < k;i++){\n\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t}\n\tprintf(\"%.12lf\\n\",diameter_poly(p,k));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\n\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\tb.y -= a.y;\n\treturn b;\n}\n\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n\ndouble diameter_poly(POINT p[],int n){\n\tPOINT g[n];\n\tint i,j;\n\tdouble m = -1.0;\n\tfor(i = 0;i < n;i++){\n\t\tfor(j = i+1;j < n;j++){\n\t\t\tm = max(distance(p[i],p[j]),m);\n\t\t}\n\t}\n\treturn m;\n}\n\nint main(){\n\tint k;\n\tint i;\n\tPOINT p[101];\n\tscanf(\"%d\",&k);\n\tfor(i =0 ;i < k;i++){\n\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t}\n\tprintf(\"%.10lf\\n\",diameter_poly(p,k));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\n\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\n\tb.y -= a.y;\n\treturn b;\n}\n\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n\ndouble diameter_poly(POINT p[],int n){\n\tPOINT g[n];\n\tint i,j,m = -1;\n\tfor(i = 0;i < n;i++){\n\t\tfor(j = i+1;j < n;j++){\n\t\t\tm = max(distance(p[i],p[j]),m);\n\t\t}\n\t}\n\treturn m;\n}\n\nint main(){\n\tint k;\n\tint i;\n\tPOINT p[101];\n\tscanf(\"%d\",&k);\n\tfor(i =0 ;i < k;i++){\n\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t}\n\tprintf(\"%.10lf\\n\",diameter_poly(p,k));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define det(x1, y1, x2, y2) ((x1) * (y2) - (x2) * (y1))\n#define distance(x, y) (sqrt(pow(x, 2) + pow(y, 2)))\n#define max(x, y) ((x) > (y) ? (x) : (y))\n\ntypedef struct {\n        double x;\n        double y;\n} Point;\n\nint compare(Point, Point);\nvoid qsort1(int, int, Point*);\nint convex_hull(Point*, Point*, int);\ndouble caliper(Point*, int);\nmain()\n{\n        int i, size, qsize;\n        Point *ps, *qs;\n        scanf(\"%d\", &size);\n        ps = (Point*)malloc(sizeof(Point) * size);\n        qs = (Point*)malloc(sizeof(Point) * size * 2);\n        for (i = 0; i < size; i++) {\n                scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n        }\n        qsize = convex_hull(qs, ps, size);\n        printf(\"%.7f\\n\", caliper(qs, qsize));\n        free(ps);\n        free(qs);\n}\n\nint compare(Point arg1, Point arg2)\n{\n        double p1 = arg1.x - arg2.x, p2 = arg1.y - arg2.y;\n        if (p1 > 0 || (p1 == 0 && p2 > 0)) {\n                return 1;\n        } else if (p1 < 0 || (p1 == 0 && p2 < 0)) {\n                return -1;\n        } else {\n                return 0;\n        }\n}\n\nvoid qsort1(int left, int right, Point *p)\n{\n    int i = left, j = right;\n        Point pivot = p[(left + right) / 2];\n    if(left >= right) return;\n    do {\n        while (compare(pivot, p[i]) == 1) i++;\n        while (compare(pivot, p[j]) == -1) j--;\n        if (i <= j) {\n            Point temp = p[i];\n                        p[i] = p[j];\n                        p[j] = temp;\n            i++;\n            j--;\n        }\n    } while (i <= j);\n    qsort1(left, j, p);\n    qsort1(i, right, p);\n}\n\nint convex_hull(Point *qs, Point *ps, int size)\n{\n        int i, t, k = 0;\n        qsort1(0, size - 1, ps);\n        for (i = 0; i < size; i++) {\n                while (k > 1 && det(qs[k-1].x - qs[k-2].x, qs[k-1].y - qs[k-2].y,\n                                                        ps[i].x - qs[k-1].x, ps[i].y - qs[k-1].y) <= 0) {\n                        k--;\n                }\n                qs[k++] = ps[i];\n        }\n        for (i = size - 2, t = k; i >= 0; i--) {\n        while (k > t && det(qs[k-1].x - qs[k-2].x, qs[k-1].y - qs[k-2].y,\n                            ps[i].x - qs[k-1].x, ps[i].y - qs[k-1].y) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n        qs = (Point*)realloc(qs, sizeof(Point) * (k - 1));\n        return (k - 1);\n}\n\ndouble caliper(Point *qs, int qsize)\n{\n        int i, j, k, si, sj;\n        double result = 0;\n        if (qsize == 2) {\n                return distance(qs[0].x - qs[1].x, qs[0].y - qs[1].y);\n        }\n        for (i = j = k = 0; k < qsize; k++) {\n                if (compare(qs[i], qs[k]) == -1) i = k;\n                if (compare(qs[j], qs[k]) == 1) j = k;\n        }\n        si = i;\n        sj = j;\n        while (i != sj || j != si) {\n                result = max(result, distance(qs[i].x - qs[j].x, qs[i].y - qs[j].y));\n                if (det(qs[(i+1)%qsize].x - qs[i].x, qs[(i+1)%qsize].y - qs[i].y,\n                                qs[(j+1)%qsize].x - qs[j].x, qs[(j+1)%qsize].y - qs[j].y) < 0){\n                        i = (i + 1) % qsize;\n                } else {\n                        j = (j + 1) % qsize;\n                }\n        }\n                return result;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define det(x1, y1, x2, y2) ((x1) * (y2) - (x2) * (y1))\n#define distance(x, y) (sqrt(pow(x, 2) + pow(y, 2)))\n#define max(x, y) ((x) > (y) ? (x) : (y))\n\ntypedef struct {\n        double x;\n        double y;\n} Point;\n\nint compare(Point, Point);\nvoid qsort1(int, int, Point*);\nint convex_hull(Point*, Point*, int);\ndouble caliper(Point*, int);\nmain()\n{\n        int i, size, qsize;\n        Point *ps, *qs;\n        scanf(\"%d\", &size);\n        ps = (Point*)malloc(sizeof(Point) * size);\n        qs = (Point*)malloc(sizeof(Point) * size * 2);\n        for (i = 0; i < size; i++) {\n                scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n        }\n        qsize = convex_hull(qs, ps, size);\n        printf(\"%.7f\\n\", caliper(ps, size));\n        free(ps);\n        free(qs);\n}\n\nint compare(Point arg1, Point arg2)\n{\n        double p1 = arg1.x - arg2.x, p2 = arg1.y - arg2.y;\n        if (p1 > 0 || (p1 == 0 && p2 > 0)) {\n                return 1;\n        } else if (p1 < 0 || (p1 == 0 && p2 < 0)) {\n                return -1;\n        } else {\n                return 0;\n        }\n}\n\nvoid qsort1(int left, int right, Point *p)\n{\n    int pivot = (left + right) / 2, i = left, j = right;\n    if(left >= right) return;\n    do{\n        while(compare(p[pivot], p[i]) == 1) i++;\n        while(compare(p[pivot], p[j]) == -1) j--;\n        if(i <= j){\n            Point temp = p[i];\n                        p[i] = p[j];\n                        p[j] = temp;\n            i++;\n            j--;\n        }\n    }while(i <= j);\n    qsort1(left, j, p);\n    qsort1(i, right, p);\n}\n\nint convex_hull(Point *qs, Point *ps, int size)\n{\n        int i, t, k = 0;\n        qsort1(0, size - 1, ps);\n        for (i = 0; i < size; i++) {\n                while (k > 1 && det(qs[k-1].x - qs[k-2].x, qs[k-1].y - qs[k-2].y,\n                                                        ps[i].x - qs[k-1].x, ps[i].y - qs[k-1].y) <= 0) {\n                        k--;\n                }\n                qs[k++] = ps[i];\n        }\n        for (i = size - 2, t = k; i >= 0; i--) {\n        while (k > t && det(qs[k-1].x - qs[k-2].x, qs[k-1].y - qs[k-2].y,\n                            ps[i].x - qs[k-1].x, ps[i].y - qs[k-1].y) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n        qs = (Point*)realloc(qs, sizeof(Point) * (k - 1));\n        putchar('\\n');\n        printf(\"%d\\n\", k - 1);\n        printf(\"%f %f\\n\", qs[1257].x, qs[1257].y);\n        return (k - 1);\n}\n\ndouble caliper(Point *qs, int qsize)\n{\n        int i, j, k, si, sj;\n        double result = 0;\n        if (qsize == 2) {\n                return distance(qs[0].x - qs[1].x, qs[0].y - qs[1].y);\n        }\n        for (i = j = k = 0; k < qsize; k++) {\n                if (compare(qs[i], qs[k]) == -1) i = k;\n                if (compare(qs[j], qs[k]) == 1) j = k;\n        }\n        si = i;\n        sj = j;\n        while (i != sj || j != si) {\n                result = max(result, distance(qs[i].x - qs[j].x, qs[i].y - qs[j].y));\n                if (det(qs[(i+1)%qsize].x - qs[i].x, qs[(i+1)%qsize].y - qs[i].y,\n                                qs[(j+1)%qsize].x - qs[j].x, qs[(j+1)%qsize].y - qs[j].y) < 0){\n                        i = (i + 1) % qsize;\n                } else {\n                        j = (j + 1) % qsize;\n                }\n        }\n                return result;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define max(a,b) a<b?b:a\n#define min(a,b) a<b?a:b\n#define POW2(a)  a*a\n#define ROOP(i,n) for(i = 0;i < n;i++)\n#define _USE_MATH_DEFINES\n\ntypedef struct POINT{\n\tdouble x;\n\tdouble y;\n}POINT;\n\ndouble norm2(POINT a){\n\treturn POW2(a.x)+POW2(a.y);\n}\n//????????????????????¢\ndouble norm(POINT a){\n\treturn sqrt(norm2(a));\n}\n\n//a->b?????´??§???????????????\nPOINT make_vec(POINT a,POINT b){\n\tb.x -= a.x;\n\n\tb.y -= a.y;\n\treturn b;\n}\n\ndouble distance(POINT a,POINT b){\n\treturn norm(make_vec(a,b));\n}\n\n\ndouble diameter_poly(POINT p[],int n){\n\tPOINT g[n];\n\tint i,j;\ndouble m = -1.0;\n\tfor(i = 0;i < n;i++){\n\t\tfor(j = i+1;j < n;j++){\n\t\t\tm = max(distance(p[i],p[j]),m);\n\t\t}\n\t}\n\treturn m;\n}\n\nint main(){\n\tint k;\n\tint i;\n\tPOINT p[100005];\n\tscanf(\"%d\",&k);\n\tfor(i =0 ;i < k;i++){\n\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t}\n\tprintf(\"%.12lf\\n\",diameter_poly(p,k));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define det(x1, y1, x2, y2) ((x1) * (y2) - (x2) * (y1))\n#define distance(x, y) (sqrt(pow(x, 2) + pow(y, 2)))\n#define max(x, y) ((x) > (y) ? (x) : (y))\n\ntypedef struct {\n        double x;\n        double y;\n} Point;\n\nint compare(Point, Point);\nvoid qsort1(int, int, Point*);\nint convex_hull(Point*, Point*, int);\ndouble caliper(Point*, int);\nmain()\n{\n        int i, size, qsize;\n        Point *ps, *qs;\n        scanf(\"%d\", &size);\n        ps = (Point*)malloc(sizeof(Point) * size);\n        qs = (Point*)malloc(sizeof(Point) * size * 2);\n        for (i = 0; i < size; i++) {\n                scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n        }\n        qsize = convex_hull(qs, ps, size);\n        printf(\"%.7f\\n\", caliper(qs, qsize));\n        free(ps);\n        free(qs);\n}\n\nint compare(Point arg1, Point arg2)\n{\n        double p1 = arg1.x - arg2.x, p2 = arg1.y - arg2.y;\n        if (p1 > 0 || (p1 == 0 && p2 > 0)) {\n                return 1;\n        } else if (p1 < 0 || (p1 == 0 && p2 < 0)) {\n                return -1;\n        } else {\n                return 0;\n        }\n}\n\nvoid qsort1(int left, int right, Point *p)\n{\n    int pivot = (left + right) / 2, i = left, j = right;\n    if(left >= right) return;\n    do{\n        while(compare(p[pivot], p[i]) == 1) i++;\n        while(compare(p[pivot], p[j]) == -1) j--;\n        if(i <= j){\n            Point temp = p[i];\n                        p[i] = p[j];\n                        p[j] = temp;\n            i++;\n            j--;\n        }\n    }while(i <= j);\n    qsort1(left, j, p);\n    qsort1(i, right, p);\n}\n\nint convex_hull(Point *qs, Point *ps, int size)\n{\n        int i, t, k = 0;\n        qsort1(0, size - 1, ps);\n        for (i = 0; i < size; i++) {\n                while (k > 1 && det(qs[k-1].x - qs[k-2].x, qs[k-1].y - qs[k-2].y,\n                                                        ps[i].x - qs[k-1].x, ps[i].y - qs[k-1].y) <= 0) {\n                        k--;\n                }\n                qs[k++] = ps[i];\n        }\n        for (i = size - 2, t = k; i >= 0; i--) {\n        while (k > t && det(qs[k-1].x - qs[k-2].x, qs[k-1].y - qs[k-2].y,\n                            ps[i].x - qs[k-1].x, ps[i].y - qs[k-1].y) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n        qs = (Point*)realloc(qs, sizeof(Point) * (k - 1));\n        return (k - 1);\n}\n\ndouble caliper(Point *qs, int qsize)\n{\n        int i, j, k, si, sj;\n        double result = 0;\n        if (qsize == 2) {\n                return distance(qs[0].x - qs[1].x, qs[0].y - qs[1].y);\n        }\n        for (i = j = k = 0; k < qsize; k++) {\n                if (compare(qs[i], qs[k]) == -1) i = k;\n                if (compare(qs[j], qs[k]) == 1) j = k;\n        }\n        si = i;\n        sj = j;\n        while (i != sj || j != si) {\n                result = max(result, distance(qs[i].x - qs[j].x, qs[i].y - qs[j].y));\n                if (det(qs[(i+1)%qsize].x - qs[i].x, qs[(i+1)%qsize].y - qs[i].y,\n                                qs[(j+1)%qsize].x - qs[j].x, qs[(j+1)%qsize].y - qs[j].y) < 0){\n                        i = (i + 1) % qsize;\n                } else {\n                        j = (j + 1) % qsize;\n                }\n        }\n                return result;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ CGL_4_B Diameter of a Convex Polygon\n// 2018.5.3 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG, LINE;\n\n#define INF\t\t\t1e8\n#define EPS\t\t\t1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\n\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\nPP vmul(PP p1, PP p2) { PP r;\n\tr.x = p1.x * p2.x - p1.y * p2.y, r.y = p1.x * p2.y + p1.y * p2.x; return r; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble dist(PP p1, PP p2) {\treturn hypot(p1.x-p2.x, p1.y-p2.y); };\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\tc = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()\n{\n\tint minus = 0;\n\tdouble x, y;\n\tint n = 0, c = gc();\n\tif (c == '-') minus = 1, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\n\tif (c == '.') {\n\t\tx = 0;\n\t\ty = 1, c = gc();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = gc(); while (c >= '0');\n\t\tx += n;\n\t} else x = n;\n\tif (minus) x = -x;\n\treturn x;\n}\n\nint cmp(PP *a, PP *b) {\n\tif (EQ(a->y, b->y)) return dcmp(a->x - b->x);\n\treturn                     dcmp(a->y - b->y);\n}\n\nint convex_hull(int n, PP *ps, PP *po)\n{\n\tint i, k, j = 0;\n\n\tqsort(ps, n, sizeof(PP), cmp);\n\tfor (i = 0; i < n; i++) {\n\t\twhile (j > 1 && cross(vsub(po[j-1], po[j-2]), vsub(ps[i], po[j-1])) <= 0) j--;\n\t\tpo[j++] = ps[i];\n\t}\n\tk = j;\n\tfor (i = n - 2; i >= 0; i--) {\n\t\twhile (j > k && cross(vsub(po[j-1], po[j-2]), vsub(ps[i], po[j-1])) <= 0) j--;\n\t\tpo[j++] = ps[i];\n\t}\n\treturn j-1;\n}\n\nPP pp[110], poly[110];\n\nint main()\n{\n\tint n, i, j;\n\tdouble ans, t;\n\n\tn = in();\n\tfor (i = 0; i < n; i++) pp[i].x = dbl(), pp[i].y = dbl();\n\tn = convex_hull(n, pp, poly);\n\tans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i+1; j < n; j++) {\n\t\t\tt = dist(poly[i], poly[j]);\n\t\t\tif (t > ans) ans = t;\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ CGL_4_B Diameter of a Convex Polygon\n// 2018.5.3 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG, LINE;\n\n#define INF\t\t\t1e8\n#define EPS\t\t\t1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\n\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\nPP vmul(PP p1, PP p2) { PP r;\n\tr.x = p1.x * p2.x - p1.y * p2.y, r.y = p1.x * p2.y + p1.y * p2.x; return r; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble dist(PP p1, PP p2) {\treturn hypot(p1.x-p2.x, p1.y-p2.y); };\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\tc = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()\n{\n\tint minus = 0;\n\tdouble x, y;\n\tint n = 0, c = gc();\n\tif (c == '-') minus = 1, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\n\tif (c == '.') {\n\t\tx = 0;\n\t\ty = 1, c = gc();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = gc(); while (c >= '0');\n\t\tx += n;\n\t} else x = n;\n\tif (minus) x = -x;\n\treturn x;\n}\n\nint cmp(PP *a, PP *b) {\n\tif (EQ(a->y, b->y)) return dcmp(a->x - b->x);\n\treturn                     dcmp(a->y - b->y);\n}\n\nint convex_hull(int n, PP *ps, PP *po)\n{\n\tint i, k, j = 0;\n\n\tqsort(ps, n, sizeof(PP), cmp);\n\tfor (i = 0; i < n; i++) {\n\t\twhile (j > 1 && cross(vsub(po[j-1], po[j-2]), vsub(ps[i], po[j-1])) <= 0) j--;\n\t\tpo[j++] = ps[i];\n\t}\n\tk = j;\n\tfor (i = n - 2; i >= 0; i--) {\n\t\twhile (j > k && cross(vsub(po[j-1], po[j-2]), vsub(ps[i], po[j-1])) <= 0) j--;\n\t\tpo[j++] = ps[i];\n\t}\n\treturn j-1;\n}\n\nPP pp[80005], poly[80005];\n\nint main()\n{\n\tint n, i, j;\n\tdouble ans, t;\n\n\tn = in();\n\tfor (i = 0; i < n; i++) pp[i].x = dbl(), pp[i].y = dbl();\n\tn = convex_hull(n, pp, poly);\n\tans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i+1; j < n; j++) {\n\t\t\tt = dist(poly[i], poly[j]);\n\t\t\tif (t > ans) ans = t;\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define max(p,q)((p)>(q)?(p):(q))\n#define zahyoutype double\ntypedef struct Point{zahyoutype x,y;}P;\ndouble distPP(P p,P q){return hypot(p.x-q.x,p.y-q.y);}\nvoid readpoint(P*p){zahyoutype x=1;scanf(x/2?\"%lf%lf\":\"%ld%ld\",&p->x,&p->y);}\n\nP a[80010];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)readpoint(a+i);\n\tdouble ans=0;\n\tint r=0;\n\tfor(int i=0;i<n;i++){\n\t\tdouble crr=distPP(a[i],a[r]);\n\t\twhile(distPP(a[i],a[(r+1)%n])>crr){\n\t\t\tr=(r+1)%n;\n\t\t\tcrr=distPP(a[i],a[r]);\n\t\t}\n\t\tans=max(ans,crr);\n\t}\n\tprintf(\"%.9f\\n\",ans);\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.*\n\ndata class Point(val x:Double, val y:Double)\nfun Point.distanceFrom(origin:Point):Double = sqrt((this.x - origin.x) * (this.x - origin.x) + (this.y - origin.y) * (this.y - origin.y))\nfun main(args:Array<String>):Unit {\n    val n = readLine()!!.toInt()\n    val points = Array(n){readLine()!!.split(' ').map(String::toDouble).let{Point(it.first(), it.last())}}\n    var posB = 0\n    var maxLength:Double = .0\n    for (posA in 0 until n){\n        while (points[posA].distanceFrom(points[posB]) <= points[posA].distanceFrom(points[(posB + 1) % n])) {\n            posB = (posB + 1) % n\n        }\n        if (maxLength < points[posA].distanceFrom(points[posB])) maxLength = points[posA].distanceFrom(points[posB])\n    }\n    println(maxLength)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "data class Point(val x:Double, val y:Double)\nfun Point.distanceFrom(origin:Point):Double = sqrt((this.x - origin.x) * (this.x - origin.x) + (this.y - origin.y) * (this.y - origin.y))\nfun main(args:Array<String>):Unit {\n    val n = readLine()!!.toInt()\n    val points = Array(n){readLine()!!.split(' ').map(String::toDouble).let{Point(it.first(), it.last())}}\n    var posB = 0\n    var maxLength:Double = .0\n    for (posA in 0 until n){\n        while (points[posA].distanceFrom(points[posB]) <= points[posA].distanceFrom(points[(posB + 1) % n])) {\n            posB = (posB + 1) % n\n        }\n        if (maxLength < points[posA].distanceFrom(points[posB])) maxLength = points[posA].distanceFrom(points[posB])\n    }\n    println(maxLength)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import kotlin.math.sqrt\n\ndata class Point(val x:Double, val y:Double)\nfun Point.distanceFrom(origin:Point):Double = sqrt((this.x - origin.x) * (this.x - origin.x) + (this.y - origin.y) * (this.y - origin.y))\nfun main(args:Array<String>):Unit {\n    val n = readLine()!!.toInt()\n    val points = Array(n){readLine()!!.split(' ').map(String::toDouble).let{Point(it.first(), it.last())}}\n    var posB = 0\n    var maxLength:Double = .0\n    for (posA in 0 until n){\n        while (points[posA].distanceFrom(points[posB]) <= points[posA].distanceFrom(points[(posB + 1) % n])) {\n            posB = (posB + 1) % n\n        }\n        if (maxLength < points[posA].distanceFrom(points[posB])) maxLength = points[posA].distanceFrom(points[posB])\n    }\n    println(maxLength)\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    int n;\n    double[] x, y;\n    int i, j;\n    double s1x, s1y, s2x, s2y, sjx, sjy, max, l;\n\n    n = sc.nextInt();\n    x = new double[n];\n    y = new double[n];\n\n    for(i = 0;i < n;i++){\n      x[i] = sc.nextDouble();\n      y[i] = sc.nextDouble();\n    }\n\n    max = 0.0;\n    for(i = 0;i < n;i++){\n      s1x = y[(i - 1 + n) % n] - y[i];\n      s1y =  - x[(i - 1 + n) % n] + x[i];\n      s2x =  - y[(i + 1) % n] + y[i];\n      s2y = x[(i + 1) % n] - x[i];\n      for(j = i + 1;j < n;j++){\n        if(s1x * s2y - s2x * s1y == 0.0)break;\n        sjx = x[j] - x[i];\n        sjy = y[j] - y[i];\n        if((s1x * sjy - sjx * s1y) * (s2x * sjy - s2y * sjy) <= 0){\n          l = sjx * sjx + sjy * sjy;\n          if(l > max)max = l;\n        }\n      }\n    }\n\n    System.out.println(Math.sqrt(max));\n\n/*fin*/\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tPoint[] p = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tdouble maxdist = distance(p[0], p[1]);\n\t\tint j = 1;\n\t\tfor(int i=2; i<n; i++) {\n\t\t\tdouble dist = distance(p[0], p[i]);\n\t\t\tif(dist > maxdist) {\n\t\t\t\tmaxdist = dist;\n\t\t\t\tj = i;\n\t\t\t}\n\t\t}\n\t\t\n//\t\tSystem.out.println(0 + \" \" + j + \" \" + maxdist);\n\t\t\n\t\tfor(int i=1; i<n; i++) {\n\t\t\tdouble maxdist2 = distance(p[i], p[j%n]);\n\t\t\twhile(true) {\n\t\t\t\tdouble dist = distance(p[i], p[(j+1)%n]);\n\t\t\t\tif(dist > maxdist2) {\n\t\t\t\t\tmaxdist2 = dist;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(i + \" \" + j + \" \" + maxdist2);\n\t\t\t\n\t\t\tif(maxdist2 > maxdist) {\n\t\t\t\tmaxdist = maxdist2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(maxdist);\n\t\t\n\t}\n\t\n\tstatic double distance(Point p1, Point p2) {\n\t\treturn Math.sqrt((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y));\n\t}\n\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tPoint[] p = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tdouble maxdist = distance(p[0], p[1]);\n\t\tint j = 1;\n\t\tfor(int i=2; i<n; i++) {\n\t\t\tdouble dist = distance(p[0], p[i]);\n\t\t\tif(dist > maxdist) {\n\t\t\t\tmaxdist = dist;\n\t\t\t\tj = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(0 + \" \" + j + \" \" + maxdist);\n\t\t\n\t\tfor(int i=1; i<n; i++) {\n\t\t\tdouble maxdist2 = distance(p[i], p[j%n]);\n\t\t\twhile(true) {\n\t\t\t\tdouble dist = distance(p[i], p[(j+1)%n]);\n\t\t\t\tif(dist > maxdist2) {\n\t\t\t\t\tmaxdist2 = dist;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(i + \" \" + j + \" \" + maxdist2);\n\t\t\t\n\t\t\tif(maxdist2 > maxdist) {\n\t\t\t\tmaxdist = maxdist2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(maxdist);\n\t\t\n\t}\n\t\n\tstatic double distance(Point p1, Point p2) {\n\t\treturn Math.sqrt((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y));\n\t}\n\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    int n;\n    double[] x, y;\n    int i, j;\n    double s1x, s1y, s2x, s2y, sjx, sjy, max, l;\n\n    n = sc.nextInt();\n    x = new double[n];\n    y = new double[n];\n\n    for(i = 0;i < n;i++){\n      x[i] = sc.nextDouble();\n      y[i] = sc.nextDouble();\n    }\n\n    max = 0.0;\n    for(i = 0;i < n;i++){\n      s1x = y[(i - 1 + n) % n] - y[i];\n      s1y =  - x[(i - 1 + n) % n] + x[i];\n      s2x =  - y[(i + 1) % n] + y[i];\n      s2y = x[(i + 1) % n] - x[i];\n      for(j = 0;j < n;j++){\n        sjx = x[j] - x[i];\n        sjy = y[j] - y[i];\n        if((s1x * sjy - sjx * s1y) * (s2x * sjy - s2y * sjy) <= 0){\n          l = sjx * sjx + sjy * sjy;\n          if(l > max)max = l;\n        }\n      }\n    }\n\n    System.out.println(Math.sqrt(max));\n\n/*fin*/\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n \npublic class Main implements Runnable {\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        FastScanner sc = new FastScanner();\n        int n = sc.nextInt();\n        \n        ArrayList<Point> l = new ArrayList<>();\n        for(int i=0;i<n;i++){\n        \tdouble x = sc.nextDouble();\n        \tdouble y = sc.nextDouble();\n        \tPoint p = new Point(x,y);\n        \tl.add(p);\n        }\n        ConvexPolygon cp = new ConvexPolygon(l);\n        \n        System.out.println(cp.diameter());\n    }\n\n}\n\nclass ConvexPolygon {\n\tArrayList<Point> cp; //反時計周り\n\t\n\t//既に凸包で反時計回りのリストから作成\n\tpublic ConvexPolygon(ArrayList<Point> cp){\n\t\tthis.cp = cp;\n\t}\n\t\n\t//与えられた点のリストから凸包を作る\n\t//x最小の中でy最小の頂点から反時計回り\n\tstatic ConvexPolygon makeConvexPolygon(ArrayList<Point> l){\n\t\tCollections.sort(l);\n\t\t\n\t\tArrayList<Point> up = new ArrayList<>(); //上側\n\t\tArrayList<Point> down = new ArrayList<>(); //下側\n\t\t\n\t\tup.add(l.get(0));\n\t\tup.add(l.get(1));\n\t\tdown.add(l.get(0));\n\t\tdown.add(l.get(1));\n\t\t\n\t\tfor(int i=2;i<l.size();i++){\n\t\t\tPoint now = l.get(i);\n\t\t\t\n\t\t\tboolean con = true;\n\t\t\twhile(con){\n\t\t\t\tPoint p0 = down.get(down.size()-2);\n\t\t\t\tPoint p1 = down.get(down.size()-1);\n\t\t\t\tint d = direction(p0,p1,now);\n\t\t\t\tif(d==2){ //p1が凹になる\n\t\t\t\t\tdown.remove(down.size()-1);\n\t\t\t\t\tif(down.size()==1){\n\t\t\t\t\t\tcon =false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcon = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdown.add(now);\n\t\t}\n\t\t\n\t\tfor(int i=2;i<l.size();i++){\n\t\t\tPoint now = l.get(i);\n\t\t\t\n\t\t\tboolean con = true;\n\t\t\twhile(con){\n\t\t\t\tPoint p0 = up.get(up.size()-2);\n\t\t\t\tPoint p1 = up.get(up.size()-1);\n\t\t\t\tint d = direction(p0,p1,now);\n\t\t\t\tif(d==1){ //p1が凹になる\n\t\t\t\t\tup.remove(up.size()-1);\n\t\t\t\t\tif(up.size()==1){\n\t\t\t\t\t\tcon =false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcon = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tup.add(now);\n\t\t}\n\t\t\n\t\tup.remove(0);\n\t\tup.remove(up.size()-1);\n\t\tCollections.reverse(up);\n\t\tdown.addAll(up);\n\t\t\n\t\treturn new ConvexPolygon(down);\n\t}\n\t\n\t//最遠頂点対間距離\n\tdouble diameter(){\n\t\t//まずx軸方向の最遠点対をとる\n\t\tdouble minx = Double.POSITIVE_INFINITY;\n\t\tint minxid = 0;\n\t\tdouble maxx = Double.NEGATIVE_INFINITY;\n\t\tint maxxid = 0;\n\t\t\n\t\tfor(int i=0;i<cp.size();i++){\n\t\t\tdouble x = cp.get(i).x;\n\t\t\tif(x<minx){\n\t\t\t\tminx = x;\n\t\t\t\tminxid = i;\n\t\t\t}\n\t\t\telse if(x>maxx){\n\t\t\t\tmaxx = x;\n\t\t\t\tmaxxid = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint pid = minxid;\n\t\tint qid = maxxid;\n\t\t\n\t\tdouble diamax = d2(cp.get(pid),cp.get(qid));\n\t\t\n\t\tboolean con = true;\n\t\twhile(con){\n\t\t\tdouble x1 = cp.get(next(pid)).x - cp.get(pid).x;\n\t\t\tdouble y1 = cp.get(next(pid)).y - cp.get(pid).y;\n\t\t\tdouble x2 = cp.get(next(qid)).x - cp.get(qid).x;\n\t\t\tdouble y2 = cp.get(next(qid)).y - cp.get(qid).y;\n\t\t\tdouble det = det(x1,y1,x2,y2);\n\t\t\tif(det<0){\n\t\t\t\tpid = next(pid);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tqid = next(qid);\n\t\t\t}\n\t\t\tdiamax = Math.max(diamax,d2(cp.get(pid),cp.get(qid)));\n\t\t\tif(qid==next(minxid) || pid ==next(maxxid)){\n\t\t\t\tcon = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Math.sqrt(diamax);\n\t}\n\t//反時計回りに1つ進んだ頂点のindex\n\tprivate int next(int id){\n\t\tint size = cp.size();\n\t\tif(id<=size-2){\n\t\t\treturn id+1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//ベクトルのdet\n\tstatic double det(double x1, double y1, double x2, double y2){\n\t\treturn x1*y2 -x2*y1;\n\t}\n\t\n\t//p0を起点に、p1へのベクトルからみてp2へのベクトルが反時計回りなら1、時計回りなら2\n\t//↑が同一直線状にあるとき、→p2が→p1と反対側なら3、→p2が→p1の延長線上なら4、→p2が→p1上にあれば5を返す\n\tstatic int direction(Point p0, Point p1, Point p2) {\n\t\tfinal double allowableERROR = 0.00000001;\n\t\tif(p0.x == p1.x) {\n\t\t\tif(p2.x == p0.x) {\n\t\t\t\tif((p0.y <= p2.y && p2.y <= p1.y) || (p1.y <= p2.y && p2.y <= p0.y)) {\n\t\t\t\t\treturn 5;\n\t\t\t\t}else if (d2(p0,p2) < d2(p1,p2)) {\n\t\t\t\t\treturn 3;\n\t\t\t\t}else {\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\t\t\t}else if ((p0.y < p1.y && p2.x < p0.x) || (p0.y > p1.y && p2.x > p0.x)) {\n\t\t\t\treturn 1;\n\t\t\t}else {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t}else{\n\t\t\t//y=ax+b上にp0,p1が存在\n\t\t\tdouble a = (p1.y - p0.y) / (p1.x - p0.x);\n\t\t\tdouble b = p1.y - a * p1.x;\n\t\t\tif(Math.abs(p2.y - (a * p2.x + b)) < allowableERROR) {\n\t\t\t\tif((p0.x <= p2.x && p2.x <= p1.x) || (p1.x <= p2.x && p2.x <= p0.x)) {\n\t\t\t\t\treturn 5;\n\t\t\t\t}else if (d2(p0,p2) < d2(p1,p2)) {\n\t\t\t\t\treturn 3;\n\t\t\t\t}else {\n\t\t\t\t\treturn 4;\n\t\t\t\t}\n\t\t\t}else if ((p0.x < p1.x && p2.y - (a * p2.x + b) > 0) || (p0.x > p1.x && p2.y - (a * p2.x + b) < 0)) {\n\t\t\t\treturn 1;\n\t\t\t}else {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\t//ユークリッド距離の2乗\n\tstatic double d2(Point p1, Point p2){\n\t\treturn (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y);\n\t}\n\n}\n\n\nclass Point implements Comparable<Point>{\n\tdouble x,y;\n\t\n\tpublic Point(double a, double b){\n\t\tthis.x = a;\n\t\tthis.y = b;\n\t}\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tlong temp;\n\t\ttemp = Double.doubleToLongBits(x);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\ttemp = Double.doubleToLongBits(y);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPoint other = (Point) obj;\n\t\tif (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Point o){\n\t\tif(x!=o.x){\n\t\t\treturn Double.compare(x,o.x);\n\t\t}\n\t\treturn Double.compare(y, o.y);\n\t}\n\t\t\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextIntArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tPoint[] p = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tdouble maxdist = distance(p[0], p[1]);\n\t\tint j = 1;\n\t\tfor(int i=2; i<n; i++) {\n\t\t\tdouble dist = distance(p[0], p[i]);\n\t\t\tif(dist > maxdist) {\n\t\t\t\tmaxdist = dist;\n\t\t\t\tj = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(0 + \" \" + j + \" \" + maxdist);\n\t\t\n\t\tfor(int i=1; i<n; i++) {\n\t\t\tdouble maxdist2 = distance(p[i], p[j%n]);\n\t\t\twhile(true) {\n\t\t\t\tdouble dist = distance(p[i], p[(j+1)%n]);\n\t\t\t\tif(dist > maxdist2) {\n\t\t\t\t\tmaxdist2 = dist;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(i + \" \" + j + \" \" + maxdist2);\n\t\t\t\n\t\t\tif(maxdist2 > maxdist) {\n\t\t\t\tmaxdist = maxdist2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(maxdist);\n\t\t\n\t}\n\t\n\tstatic double distance(Point p1, Point p2) {\n\t\treturn Math.sqrt((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y));\n\t}\n\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tPoint[] p = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tdouble maxdist = distance(p[0], p[1]);\n\t\tint j = 1;\n\t\tfor(int i=2; i<n; i++) {\n\t\t\tdouble dist = distance(p[0], p[i]);\n\t\t\tif(dist > maxdist) {\n\t\t\t\tmaxdist = dist;\n\t\t\t\tj = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; i<n; i++) {\n\t\t\tdouble maxdist2 = distance(p[1], p[j%n]);\n\t\t\twhile(true) {\n\t\t\t\tdouble dist = distance(p[1], p[(j+1)%n]);\n\t\t\t\tif(dist > maxdist2) {\n\t\t\t\t\tmaxdist2 = dist;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(maxdist2 > maxdist) {\n\t\t\t\tmaxdist = maxdist2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(maxdist);\n\t\t\n\t}\n\t\n\tstatic double distance(Point p1, Point p2) {\n\t\treturn Math.sqrt((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y));\n\t}\n\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nusing static Exg;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tconst double eps=1e-11;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar n=sc.I;\n\t\tvar pa=new Pair[n];\n\t\tint c=0;\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tpa[i]=new Pair(sc.Da);\n\t\t\tif(pa[i].y<pa[c].y||(pa[i].y==pa[c].y&&pa[i].x>pa[c].x)){c=i;}\n\t\t}\n\t\tGs gs=new Gs(pa,c,true);\n\t\tConsole.WriteLine(\"{0}\",gs.Calipers);\n\t}\n}\npublic class Gs{\n\tprivate Tuple<Pair,double,int>[] arr;\n\tprivate double cd,cx;\n\tpublic List<Tuple<Pair,double,int>> li=new List<Tuple<Pair,double,int>>();\n\tpublic Gs(Pair[] a,int c,bool b){\n\t\tint n=a.Length,q=2;\n\t\tarr=new Tuple<Pair,double,int>[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i!=c){\n\t\t\t\tarr[i]=Tuple.Create(a[i],Atan2(a[i].y-a[c].y,a[i].x-a[c].x)*180/PI,i);\n\t\t\t\tcd=Max(cd,arr[i].Item2);\n\t\t\t}\n\t\t}\n\t\tarr[c]=Tuple.Create(a[c],0D,c);\n\t\tif(b){\n\t\t\tArray.Sort(arr,Ca1);\n\t\t\tli.Add(arr[0]);li.Add(arr[1]);\n\t\t\twhile(q!=n){\n\t\t\t\tli.Add(arr[q]);\n\t\t\t\tq++;\n\t\t\t\twhile(li.Count>2&&(li[li.Count-1].Item1.x-li[li.Count-2].Item1.x)*(li[li.Count-3].Item1.y-li[li.Count-2].Item1.y)-(li[li.Count-1].Item1.y-li[li.Count-2].Item1.y)*(li[li.Count-3].Item1.x-li[li.Count-2].Item1.x)<=0){li.RemoveAt(li.Count-2);}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcx=a[c].x;\n\t\t\tArray.Sort(arr,Ca2);\n\t\t\tli.Add(arr[0]);li.Add(arr[1]);\n\t\t\twhile(q!=n){\n\t\t\t\tli.Add(arr[q]);\n\t\t\t\tq++;\n\t\t\t\twhile(li.Count>2&&(li[li.Count-1].Item1.x-li[li.Count-2].Item1.x)*(li[li.Count-3].Item1.y-li[li.Count-2].Item1.y)-(li[li.Count-1].Item1.y-li[li.Count-2].Item1.y)*(li[li.Count-3].Item1.x-li[li.Count-2].Item1.x)<0){li.RemoveAt(li.Count-2);}\n\t\t\t}\n\t\t}\n\t}\n\tprivate int Ca1(Tuple<Pair,double,int> a,Tuple<Pair,double,int> b){\n\t\tif(a.Item2>b.Item2){return 1;}\n\t\telse if(a.Item2<b.Item2){return -1;}\n\t\telse if(a.Item1.y>b.Item1.y){return 1;}\n\t\telse if(a.Item1.y<b.Item1.y){return -1;}\n\t\telse if(a.Item1.x<b.Item1.x){return 1;}\n\t\telse if(a.Item1.x>b.Item1.x){return -1;}\n\t\treturn 0;\n\t}\n\tprivate int Ca2(Tuple<Pair,double,int> a,Tuple<Pair,double,int> b){\n\t\tif(a.Item2>b.Item2){return 1;}\n\t\telse if(a.Item2<b.Item2){return -1;}\n\t\telse if(a.Item2==cd){\n\t\t\tif(cx==a.Item1.x){if(a.Item1.y<b.Item1.y){return 1;}else if(a.Item1.y>b.Item1.y){return -1;}}\n\t\t\telse if(cx>a.Item1.x){if(a.Item1.x>b.Item1.x){return 1;}else if(a.Item1.x<b.Item1.x){return -1;}}\n\t\t\telse{if(a.Item1.x<b.Item1.x){return 1;}else if(a.Item1.x>b.Item1.x){return -1;}}\n\t\t}\n\t\telse{\n\t\t\tif(cx==a.Item1.x){if(a.Item1.y>b.Item1.y){return 1;}else if(a.Item1.y<b.Item1.y){return -1;}}\n\t\t\telse if(cx<a.Item1.x){if(a.Item1.x>b.Item1.x){return 1;}else if(a.Item1.x<b.Item1.x){return -1;}}\n\t\t\telse{if(a.Item1.x<b.Item1.x){return 1;}else if(a.Item1.x>b.Item1.x){return -1;}}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic double Diameter{get{\n\t\tdouble q=(li[0].Item1.x-li[li.Count-1].Item1.x),p=(li[0].Item1.y-li[li.Count-1].Item1.y),d=Sqrt(q*q+p*p);\n\t\tfor(int i=1;i<li.Count;i++){\n\t\t\tq=(li[i].Item1.x-li[i-1].Item1.x);\n\t\t\tp=(li[i].Item1.y-li[i-1].Item1.y);\n\t\t\td+=Sqrt(q*q+p*p);\n\t\t}\n\t\treturn d;\n\t}}\n\tpublic double Calipers{get{\n\t\tdouble ans=Gp0(li[0].Item1,li[1].Item1);\n\t\tint nn=li.Count;\n\t\tif(nn>2){\n\t\t\tfor(int i=0,j=2;;j=(j+1)%nn){\n\t\t\t\tvar p=Gp2(li[i].Item1,li[(i+1)%nn].Item1,li[j].Item1);\n\t\t\t\twhile(true){\n\t\t\t\t\tvar u=Gp2(li[i].Item1,li[(i+1)%nn].Item1,li[(j+1)%nn].Item1);\n\t\t\t\t\tans=Max(ans,Gp0(li[i].Item1,li[j].Item1));\n\t\t\t\t\tif(j==0){goto f;}\n\t\t\t\t\tif(p>u+1e-15){break;}\n\t\t\t\t\tj=(j+1)%nn;\n\t\t\t\t\tp=u;\n\t\t\t\t}\n\t\t\t\ti^=j;j^=i;i^=j;\n\t\t\t}\n\t\t\tf:;\n\t\t}\n\t\treturn ans;\n\t}}\n}\npublic struct Pair{\n\tpublic double x,y;\n\tpublic Pair(double x,double y){this.x=x;this.y=y;}\n\tpublic Pair(double[] da){x=da[0];y=da[1];}\n\tpublic Pair(Pair p){x=p.x;y=p.y;}\n\tpublic override string ToString()=>x.ToString()+\" \"+y.ToString();\n\tpublic static Pair operator+(Pair a,Pair b){a.x+=b.x;a.y+=b.y;return a;}\n\tpublic static Pair operator-(Pair a,Pair b){a.x-=b.x;a.y-=b.y;return a;}\n\tpublic static Pair operator*(Pair a,double n){a.x*=n;a.y*=n;return a;}\n\tpublic static Pair operator/(Pair a,double n){a.x/=n;a.y/=n;return a;}\n}\nstatic class Exg{\n\tstatic public double Gp0(Pair a,Pair b){return Sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}\n\tstatic public Tuple<bool,Pair> Gp1(Pair p1,Pair p2,Pair p3,Pair p4){\n\t\tdouble t1=(p4.y-p3.y)*(p4.x-p1.x)-(p4.x-p3.x)*(p4.y-p1.y);\n\t\tdouble t2=(p2.x-p1.x)*(p4.y-p1.y)-(p2.y-p1.y)*(p4.x-p1.x);\n\t\tdouble t3=(p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n\t\tif(t3==0){\n\t\t\tif(Abs(Atan2(p2.y-p1.y,p2.x-p1.x))!=Abs(Atan2(p3.y-p1.y,p3.x-p1.x))){return Tuple.Create(p1.x==p3.x&&p1.y==p3.y?true:false,p1);}\n\t\t\tvar a=new Tuple<Pair,int>[]{Tuple.Create(p1,1),Tuple.Create(p2,2),Tuple.Create(p3,3),Tuple.Create(p4,4)};\n\t\t\tArray.Sort(a,(d,e)=>{var c=d.Item1.x.CompareTo(e.Item1.y);return c==0?e.Item1.y.CompareTo(d.Item1.y):c;});\n\t\t\treturn Tuple.Create((Abs(a[0].Item2-a[1].Item2)!=1||Abs(a[2].Item2-a[3].Item2)!=1)||(a[1].Item1.x==a[2].Item1.x&&a[1].Item1.y==a[2].Item1.y)?true:false,a[1].Item1);\n\t\t}\n\t\tdouble t4=t1/t3,t5=t2/t3;\n\t\tif(t4<0||t4>1||t5<0||t5>1){return Tuple.Create(false,new Pair(0,0));}\n\t\telse{return Tuple.Create(true,new Pair(p1.x+t4*(p2.x-p1.x),p1.y+t4*(p2.y-p1.y)));}\n\t}\n\tstatic public double Gp2(Pair p1,Pair p2,Pair p0){return Abs((p2.y-p1.y)*p0.x-(p2.x-p1.x)*p0.y+p2.x*p1.y-p1.x*p2.y)/Sqrt((p2.y-p1.y)*(p2.y-p1.y)+(p2.x-p1.x)*(p2.x-p1.x));}\n\tstatic public double Gp3(Pair p1,Pair p2,Pair p0){return (p1.x-p2.x)*(p0.y-p1.y)+(p1.y-p2.y)*(p1.x-p0.x);}\n\tstatic public double Gp4(Pair a,Pair b,Pair c){\n\t\tdouble a1=a.x-b.x,a2=a.y-b.y,c1=c.x-b.x,c2=c.y-b.y;\n\t\treturn Acos((a1*c1+a2*c2)/Sqrt((a1*a1+a2*a2)*(c1*c1+c2*c2)))*180/PI;\n\t}\n\tstatic public Tuple<bool,Pair> Gp5(Pair p1,Pair p2,Pair p0){\n\t\tdouble rx=p0.x,ry=p0.y;\n\t\tif(p1.x==p2.x){rx=p1.x;}\n\t\telse if(p1.y==p2.y){ry=p1.y;}\n\t\telse{\n\t\t\tdouble m1=(p2.y-p1.y)/(p2.x-p1.x),b1=p1.y-(m1*p1.x),m2=-1.0/m1,b2=p0.y-(m2*p0.x);\n\t\t\trx=(b2-b1)/(m1-m2);\n\t\t\try=(b2*m1-b1*m2)/(m1-m2);\n\t\t}\n\t\treturn Tuple.Create(((p1.x>=rx&&p2.x<=rx)||(p2.x>=rx&&p1.x<=rx))&&((p1.y>=ry&&p2.y<=ry)||(p2.y>=ry&&p1.y<=ry)),new Pair(rx,ry));\n\t}\n\tstatic public Pair Gp6(Pair a,Pair b,Pair c,int n){\n\t\tdouble l1=Sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n\t\tdouble l2=Sqrt((c.x-b.x)*(c.x-b.x)+(c.y-b.y)*(c.y-b.y));\n\t\tdouble ex=(a.x+(b.x+(c.x-b.x)*(l1/l2)))/2,ey=(a.y+(b.y+(c.y-b.y)*(l1/l2)))/2;\n\t\tex+=(ex-b.x)*n;ey+=(ey-b.y)*n;\n\t\treturn new Pair(ex,ey);\n\t}\n\tstatic public Pair Gp7(Pair a,double k,double p){return new Pair(a.x+k*Cos(p),a.y+k*Sin(p));}\n\tstatic public bool Gp8(Pair a,Pair b,Pair c){return (c.x-a.x)*(b.y-a.y)==(b.x-a.x)*(c.y-a.y);}\n\tstatic public Pair Gp9(Pair a,Pair b,Pair c){\n\t\tdouble d=a.x*a.x+a.y*a.y,e=b.x*b.x+b.y*b.y,f=c.x*c.x+c.y*c.y,g=2*(a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y));\n\t\treturn new Pair((d*(b.y-c.y)+e*(c.y-a.y)+f*(a.y-b.y))/g,(d*(c.x-b.x)+e*(a.x-c.x)+f*(b.x-a.x))/g);\n\t}\n\tstatic public Tuple<Pair,double>[] Psort(Pair[] pa,Pair p){\n\t\tvar arr=new Tuple<Pair,double>[pa.Length];\n\t\tfor(int i = 0;i<pa.Length;i++) {arr[i]=Tuple.Create(pa[i],Atan2(pa[i].y-p.y,pa[i].x-p.x)*180/PI+180);}\n\t\tArray.Sort(arr,(u,v)=>u.Item2.CompareTo(v.Item2));\n\t\treturn arr;\n\t}\n\tstatic public Tuple<Pair,double>[] Psort2(Pair[] pa,Pair p){\n\t\tint n=pa.Length;\n\t\tvar arr=new Tuple<Pair,double>[n];\n\t\tfor(int i = 0;i<n;i++) {arr[i]=Tuple.Create(pa[i],Atan2(pa[i].y-p.y,pa[i].x-p.x)*180/PI+180);}\n\t\tArray.Sort(arr,(u,v)=>u.Item2.CompareTo(v.Item2));\n\t\tArray.Resize(ref arr,n<<1);\n\t\tfor(int i = 0;i<n;i++) {arr[i+n]=Tuple.Create(arr[i].Item1,arr[i].Item2+360);}\n\t\treturn arr;\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int();\n        var P = new Point[N];\n        for (int i = 0; i < N; i++)\n            P[i] = new Point(Reader.Double(), Reader.Double());\n        var poly = new Polygon(P);\n        Console.WriteLine(ConvexPolygonDiameter(poly));\n        Console.ReadLine();\n    }\n\n    public double ConvexPolygonDiameter(Polygon poly)\n    {\n        int N = poly.N;\n        if (N == 2) return poly[0].Distance(poly[1]);\n        int a = 0, b = 0;\n        for (int i = 0; i < N; i++)\n        {\n            if (poly[i].X < poly[a].X) a = i;\n            if (poly[i].X > poly[b].X) b = i;\n        }\n        double maxLen = 0;\n        int sa = a, sb = b;\n        while (a != sb || b != sa)\n        {\n            maxLen = Math.Max(maxLen, poly[a].Distance(poly[b]));\n            if ((poly[a + 1] - poly[a]).Det(poly[b + 1] - poly[b]) < 0)\n                a = (a + 1) % N;\n            else\n                b = (b + 1) % N;\n        }\n        return maxLen;\n    }\n\n    public class Polygon\n    {\n        public readonly Point[] P;\n        public Polygon(Point[] points) { P = points; }\n        public Polygon(IEnumerable<Point> points) { P = points.ToArray(); }\n        public int N { get { return P.Length; } }\n        public Point this[int i] { get { return P[(i % N + N) % N]; } }\n\n        public double Area() { return Math.Abs(SignedArea()); }\n        public double SignedArea()\n        {\n            double area = 0;\n            for (int i = 0; i < P.Length; i++)\n                area += P[i].Det(P[(i + 1) % P.Length]);\n            return area / 2;\n        }\n        public bool IsConvex()\n        {\n            for (int i = 1; i < P.Length; i++)\n                if ((P[i] - P[i - 1]).Det(P[(i + 1) % P.Length] - P[i]) < 0)\n                    return false;\n            return true;\n        }\n    }\n\n    public struct Point : IEquatable<Point>, IComparable<Point>\n    {\n        public static readonly double Eps = 1e-10;\n        public double X, Y;\n        public Point(double x, double y) { X = x; Y = y; }\n        public static Point operator +(Point a, Point b)\n        {\n            return new Point(Add(a.X, b.X), Add(a.Y, b.Y));\n        }\n        public static Point operator -(Point a, Point b)\n        {\n            return new Point(Add(a.X, -b.X), Add(a.Y, -b.Y));\n        }\n        public static Point operator *(Point p, double d)\n        {\n            return new Point(p.X * d, p.Y * d);\n        }\n        public double Distance(Point b) { return Math.Sqrt((b - this).Dot(b - this)); }\n        public double Dot(Point b) { return Add(X * b.X, Y * b.Y); }\n        public double Det(Point b) { return Add(X * b.Y, -Y * b.X); }\n        public bool Equals(Point b) { return X == b.X && Y == b.Y; }\n        public int CompareTo(Point b) { return X != b.X ? Math.Sign(X - b.X) : Math.Sign(Y - b.Y); }\n        public override int GetHashCode() { return (int)(X * 100000 + Y); }\n        public override string ToString() { return X + \", \" + Y; }\n\n        private static double Add(double a, double b)\n        {\n            if (Math.Abs(a + b) < Eps * (Math.Abs(a) + Math.Abs(b))) return 0;\n            return a + b;\n        }\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    private static TextReader reader = Console.In;\n    private static readonly char[] separator = { ' ' };\n    private static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    private static string[] A = new string[0];\n    private static int i;\n    private static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Enu.Range(0, N).Select(i => Int()).ToArray(); }\n    public static int[][] IntTable(int H) { return Enu.Range(0, H).Select(i => IntLine()).ToArray(); }\n    public static string[] StringArray(int N) { return Enu.Range(0, N).Select(i => Next()).ToArray(); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    private static string[] Split(string s) { return s.Split(separator, op); }\n    private static string Next() { CheckNext(); return A[i++]; }\n    private static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] pt = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                pt[i] = new Point(input[0], input[1]);\n            }\n\n            Console.WriteLine(ConvexDiameter(pt));\n        }\n\n        static double ConvexDiameter(Point[] pt)\n        {\n            int n = pt.Length;\n\n            int maxY = 0;\n            int minY = 0;\n\n            for (int i = 1; i < n; i++)\n            {\n                if (pt[i].y > pt[maxY].y) maxY = i;\n                if (pt[i].y < pt[minY].y) minY = i;\n            }\n\n            double maxDist = (pt[maxY] - pt[minY]).Norm;\n\n            int a, maxA, b, maxB;\n            a = maxA = maxY;\n            b = maxB = minY;\n\n            do\n            {\n                if ((pt[(a + 1) % n] - pt[a]).Cross(pt[(b + 1) % n] - pt[b]) >= 0) b = (b + 1) % n;\n                else a = (a + 1) % n;\n\n                if ((pt[a] - pt[b]).Norm > maxDist)\n                {\n                    maxDist = (pt[a] - pt[b]).Norm;\n                    maxA = a;\n                    maxB = b;\n                }\n            } while (a != maxY || b != minY);\n\n            return Math.Sqrt(maxDist);\n        }\n    }\n\n    class Point : IComparable<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Point other)\n        {\n            return Math.Abs(x - other.x) < EPS ? (int)(x - other.x) : (int)(y - other.y);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Point other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] pt = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                pt[i] = new Point(input[0], input[1]);\n            }\n\n            Console.WriteLine(ConvexDiameter(pt));\n        }\n\n        static double ConvexDiameter(Point[] pt)\n        {\n            int n = pt.Length;\n\n            int maxY = 0;\n            int minY = 0;\n\n            for (int i = 1; i < n; i++)\n            {\n                if (pt[i].y > pt[maxY].y) maxY = i;\n                if (pt[i].y < pt[minY].y) minY = i;\n            }\n\n            double maxDist = (pt[maxY] - pt[minY]).Norm;\n\n            int a = maxY;\n            int b = minY;\n\n            do\n            {\n                if ((pt[(a + 1) % n] - pt[a]).Cross(pt[(b + 1) % n] - pt[b]) >= 0) b = (b + 1) % n;\n                else a = (a + 1) % n;\n\n                if ((pt[a] - pt[b]).Norm > maxDist)\n                {\n                    maxDist = (pt[a] - pt[b]).Norm;\n                }\n            } while (a != maxY || b != minY);\n\n            return Math.Sqrt(maxDist);\n        }\n    }\n\n    class Point : IComparable<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Point other)\n        {\n            return Math.Abs(x - other.x) < EPS ? (int)(x - other.x) : (int)(y - other.y);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Point other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int();\n        var P = new Point[N];\n        for (int i = 0; i < N; i++)\n            P[i] = new Point(Reader.Double(), Reader.Double());\n        var poly = ConvexHull(P);\n        N = poly.Length;\n        double maxLen = 0;\n        for (int a = 0; a < N; a++)\n            for (int b = a + 1; b < N; b++)\n                maxLen = Math.Max(maxLen, poly[a].Distance(poly[b]));\n\n        Console.WriteLine(maxLen);\n        Console.ReadLine();\n    }\n\n    public Point[] ConvexHull(Point[] P)\n    {\n        Array.Sort(P);\n        var Q = new Point[P.Length + 2];\n        int N = 0;\n        for (int i = 0; i < P.Length; i++)\n        {\n            while (N > 1 && (Q[N - 1] - Q[N - 2]).Det(P[i] - Q[N - 1]) <= 0) N--;\n            Q[N++] = P[i];\n        }\n        for (int i = P.Length - 2, m = N; i >= 0; i--)\n        {\n            while (N > m && (Q[N - 1] - Q[N - 2]).Det(P[i] - Q[N - 1]) <= 0) N--;\n            if (N == Q.Length) { var t = new Point[N + 100]; Array.Copy(Q, t, N); Q = t; }\n            Q[N++] = P[i];\n        }\n        var res = new Point[N - 1];\n        Array.Copy(Q, res, N - 1);\n        return res;\n    }\n\n    public class Polygon\n    {\n        public readonly Point[] P;\n        public Polygon(Point[] points) { P = points; }\n        public Polygon(IEnumerable<Point> points) { P = points.ToArray(); }\n        public int N { get { return P.Length; } }\n        public Point this[int i] { get { return P[(i % N + N) % N]; } }\n\n        public double Area() { return Math.Abs(SignedArea()); }\n        public double SignedArea()\n        {\n            double area = 0;\n            for (int i = 0; i < P.Length; i++)\n                area += P[i].Det(P[(i + 1) % P.Length]);\n            return area / 2;\n        }\n        public bool IsConvex()\n        {\n            for (int i = 1; i < P.Length; i++)\n                if ((P[i] - P[i - 1]).Det(P[(i + 1) % P.Length] - P[i]) < 0)\n                    return false;\n            return true;\n        }\n    }\n\n    public struct Point : IEquatable<Point>, IComparable<Point>\n    {\n        public static readonly double Eps = 1e-10;\n        public double X, Y;\n        public Point(double x, double y) { X = x; Y = y; }\n        public static Point operator +(Point a, Point b)\n        {\n            return new Point(Add(a.X, b.X), Add(a.Y, b.Y));\n        }\n        public static Point operator -(Point a, Point b)\n        {\n            return new Point(Add(a.X, -b.X), Add(a.Y, -b.Y));\n        }\n        public static Point operator *(Point p, double d)\n        {\n            return new Point(p.X * d, p.Y * d);\n        }\n        public double Distance(Point b) { return Math.Sqrt((b - this).Dot(b - this)); }\n        public double Dot(Point b) { return Add(X * b.X, Y * b.Y); }\n        public double Det(Point b) { return Add(X * b.Y, -Y * b.X); }\n        public bool Equals(Point b) { return X == b.X && Y == b.Y; }\n        public int CompareTo(Point b) { return X != b.X ? Math.Sign(X - b.X) : Math.Sign(Y - b.Y); }\n        public override int GetHashCode() { return (int)(X * 100000 + Y); }\n        public override string ToString() { return X + \", \" + Y; }\n\n        private static double Add(double a, double b)\n        {\n            if (Math.Abs(a + b) < Eps * (Math.Abs(a) + Math.Abs(b))) return 0;\n            return a + b;\n        }\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    private static TextReader reader = Console.In;\n    private static readonly char[] separator = { ' ' };\n    private static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    private static string[] A = new string[0];\n    private static int i;\n    private static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Enu.Range(0, N).Select(i => Int()).ToArray(); }\n    public static int[][] IntTable(int H) { return Enu.Range(0, H).Select(i => IntLine()).ToArray(); }\n    public static string[] StringArray(int N) { return Enu.Range(0, N).Select(i => Next()).ToArray(); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    private static string[] Split(string s) { return s.Split(separator, op); }\n    private static string Next() { CheckNext(); return A[i++]; }\n    private static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "// const\nvar COUNTER_CLOCKWISE = 1;\nvar CLOCKWISE = - 1;\nvar ONLINE_BACK = 2;\nvar ONLINE_FRONT =  -2;\nvar ON_SEGMENT = 0;\n\n// Vector2d\nvar Vector2D = class Vector2D {\n\tconstructor(x,y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nVector2D.prototype.Init = function(x,y){\n\tthis.x = x;\n\tthis.y = y;\n}\n\n/*\n * v: Vector2D\n */\nfunction rotateVector90(v){\n\tvar r = new Vector2D();\n\tr.x = -v.y;\n\tr.y = v.x;\n\treturn r;\n}\n\n/*\n * get degree to radian return radian\n */\nfunction getDegreeToRadian(degree){\n\tvar pi = 3.14159265358979323846;\n\treturn degree * pi / 180;\n}\n\n/*\n * vec:Vector2D return Vector2D\n */\nfunction getRotateVector(vec,degree){\n\tvar radian = getDegreeToRadian(degree);\n\n\tvar sin = Math.sin(radian);\n\tvar cos = Math.cos(radian);\n\n\tvar r = new Vector2D();\n\tr.x = vec.x * cos - vec.y * sin;\n\tr.y = vec.x * sin + vec.y * cos;\n\n\treturn r;\n}\n\nfunction isEqualVectors(a,b){\n\treturn equalFloats(a.x - b.x,0) && equalFloats(a.y - b.y,0);\n}\n\n/**\n * vec:Vector2D\n * \n * return unitVector\n */\nfunction getUnitVector(vec){\n\tvar length = getVectorLength2D(vec);\n\tif(length > 0){\n\t\treturn getDivideVector(vec,length);\n\t}\n\treturn vec;\n}\n\n/**\n * return vector length\n * \n * vec:Vector2D\n */\nfunction getVectorLength2D(vec){\n\treturn Math.sqrt((vec.x * vec.x) + (vec.y * vec.y));\n}\n\nfunction getNorm(vec){\n\treturn vec.x * vec.x + vec.y * vec.y;\n}\n\nfunction getDivideVector(vec2D,length){\n\tvec2D.x = vec2D.x / length;\n\tvec2D.y = vec2D.y / length;\n\treturn vec2D;\n}\n\nfunction equalFloats(a,b){\n\tvar threshold = 1 / 8192;\n\treturn Math.abs(a - b) < threshold;\n}\n\nfunction isParallelVector(vectorA,vectorB){\n\tvar na = rotateVector90(vectorA);\n\treturn equalFloats(0,dotProduct2D(na,vectorB));\n}\n\nfunction isVerticalVector(vectorA,vectorB){\n\treturn equalFloats(0,dotProduct2D(vectorA,vectorB));\n}\n\nfunction subtractVector(vecA,vecB){\n\tvar vec = new Vector2D();\n\tvec.x = vecA.x - vecB.x;\n\tvec.y = vecA.y - vecB.y;\n\treturn vec;\n}\n\nfunction dotProduct2D(vecA,vecB){\n    var dot = vecA.x * vecB.x + vecA.y * vecB.y;\n    //console.log(dot);\n\treturn vecA.x * vecB.x + vecA.y * vecB.y;\n}\n\n/**\n * 外積\n * \n * @param vecA\n * @param vecB\n * @returns\n */\nfunction getCross(vecA,vecB){\n\treturn vecA.x * vecB.y - vecA.y * vecB.x;\n}\n\n/**\n * line segment\n * \n * point1:Vector2D point2:Vector2D\n */\nvar LineSegment2D = class LineSegment2D {\n\tconstructor(point1,point2){\n\t\tthis.point1 = point1;\n\t\tthis.point2 = point2;\n\t}\n}\n\nLineSegment2D.prototype.Init = function(point1,point2){\n\tthis.point1 = point1;\n\tthis.point2 = point2;\n}\n\nfunction onOneSide(axis,segment){\n\tvar d1 = new Vector2D();\n\td1 = subtractVector(segment.point1,axis.base);\n\n\tvar d2 = new Vector2D();\n\td2 = subtractVector(segment.point2,axis.base);\n\n\tvar n = new Vector2D();\n\tn = rotateVector90(axis.direction);\n\n\t// 同じ方向だということを返す\n\treturn dotProduct2D(n,d1) * dotProduct2D(n,d2) > 0;\n}\n\nfunction overLapping(minA,maxA,minB,maxB){\n\treturn minB <= maxA && minA <= maxB;\n}\n\nfunction isSegmentsCollide(segment1,segment2){\n\t// 線分の方向をチェックするためのベクトル\n\tvar axisA = new Line();\n\tvar axisB = new Line();\n\n\t// 線分1のベクトルに対して、線分2が片側にあるかチェック\n\taxisA.base = segment1.point1;\n\taxisA.direction = subtractVector(segment1.point2,segment1.point1);\n\n\tif(onOneSide(axisA,segment2)){\n\t\treturn false;\n\t}\n\n\t// 同じく\n\taxisB.base = segment2.point1;\n\taxisB.direction = subtractVector(segment2.point2,segment2.point1);\n\n\tif(onOneSide(axisB,segment1)){\n\t\treturn false;\n\t}\n\n\t// 同じベクトルをもつケース\n\tif(isParallelVector(axisA.direction,axisB.direction)){\n\t\tvar rangeA = getProjectSegment(segment1,axisA.direction);\n\t\tvar rangeB = getProjectSegment(segment2,axisA.direction);\n\n\t\t// 重なっているか\n\t\treturn isOverLappingRanges(rangeA,rangeB);\n\t}\n\telse{\n\t\treturn true;\n\t}\n}\n\n/*\n * Line Object\n */\nfunction Line(){\n\t// vector2D\n\tthis.base;\n\t// vector2D\n\tthis.direction\n}\n\nLine.prototype.Init = function(base,direction,color){\n\tthis.base = base;\n\tthis.direction = direction;\n}\n\n/**\n * Range\n */\nvar Range = class Range {\n\tconstructor(min,max){\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t}\n}\n\nfunction getMaxMinRange(range1,range2){\n\tvar range = new Range();\n\trange.min = range1.min < range2.min ? range1.min : range2.min;\n\trange.max = range1.max < range2.max ? range2.max : range1.max;\n\treturn range;\n}\n\nfunction getSortRange(range){\n\tvar sorted = new Range(range.min,range.max);\n\tif(range.min > range.max){\n\t\tsorted.min = range.max;\n\t\tsorted.max = range.min;\n\t}\n\treturn sorted;\n}\n\nfunction getNegateVector(vector){\n\tvector.x = -vector.x;\n\tvector.y = -vector.y;\n\treturn vector;\n}\n\nfunction getAddVector(vecA,vecB){\n\treturn new Vector2D(vecA.x + vecB.x,vecA.y + vecB.y);\n}\n\n/**\n * segment:segment onto:Vector2D\n * \n * return Range\n */\nfunction getProjectSegment(segment,onto){\n\tvar ontoUnitVec = getUnitVector(onto);\n\n\tvar range = new Range();\n\trange.min = dotProduct2D(ontoUnitVec,segment.point1);\n\trange.max = dotProduct2D(ontoUnitVec,segment.point2);\n\n\trange = getSortRange(range);\n\treturn range;\n}\n\nfunction isOverLappingRanges(range1,range2){\n\treturn overLapping(range1.min,range1.max,range2.min,range2.max);\n}\n\nfunction projectVector(project,onto){\n\tvar d = dotProduct2D(onto,onto);\n\tif(0 < d){\n\t    var dp = dotProduct2D(project,onto);\n\t    return multiplyVector(onto,dp / d);\n\t}\n\treturn onto;\n}\n\n/**\n * point class\n */\nvar Point2D = class Point2D {\n\tconstructor(x,y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n}\n\nfunction addPoint(point1,point2){\n\treturn new Point2D(point1.x + point2.x,point1.y + point2.y);\n}\n\nfunction subtractPoint(point1,point2){\n\treturn new Point2D(point1.x - point2.x,point1.y - point2.y);\n}\n\nfunction multiplyPoint(point,scalar){\n\treturn new Point2D(point.x * scalar,point.y * scalar);\n}\n\n/**\n * segment : LineSegment2D\n * point : Point\n */\nfunction getProjectPoint(segment,point){\n\tvar vec1 = new Vector2D(segment.point2.x - segment.point1.x,segment.point2.y - segment.point1.y);\n\tvar vec2 = new Vector2D(point.x - segment.point1.x,point.y - segment.point1.y);\n\tvar rate = dotProduct2D(vec2,vec1) / getNorm(vec1);\n\tvar vec3 = multiplyVector(vec1,rate);\n\tvar project = new Point2D(segment.point1.x + vec3.x,segment.point1.y + vec3.y);\n\treturn project; \n}\n\nfunction getReflectionPoint(segment,point){\n\tvar projection = getProjectPoint(segment,point);\n\t// pから射影点までのベクトル\n\tvar vec = subtractPoint(projection,point);\n\t// 2倍したものが射影点になる\n\tvar refrectionPoint = multiplyPoint(vec,2);\n\t// 始点を足す\n\treturn addPoint(refrectionPoint,point);\n}\n\n/**\n * \n * @param segment1\n * @param segment2\n * @returns point\n */\nfunction getCrossPoint(segment1,segment2){\n\t// 基準となる線を決める\n\tvar baseVector = new Vector2D(segment2.point2.x - segment2.point1.x,segment2.point2.y - segment2.point1.y);\n\tvar d1Vec = new Vector2D(segment1.point1.x - segment2.point1.x,segment1.point1.y - segment2.point1.y);\n\tvar d2Vec = new Vector2D(segment1.point2.x - segment2.point1.x,segment1.point2.y - segment2.point1.y);\n\tvar d1 = Math.abs(getCross(baseVector,d1Vec));\n\tvar d2 = Math.abs(getCross(baseVector,d2Vec));\n\tvar t = d1 / (d1 + d2);\n\tvar x = segment1.point1.x + (segment1.point2.x - segment1.point1.x) * t;\n\tvar y = segment1.point1.y + (segment1.point2.y - segment1.point1.y) * t;\n\treturn new Point2D(x,y);\n}\n\nfunction multiplyVector(vec,scalar){\n\tvar temp = new Vector2D();\n\ttemp.x = vec.x * scalar;\n\ttemp.y = vec.y * scalar;\n\treturn temp;\n}\n\nfunction clampOnRange(x,min,max){\n\tif(x < min){\n\t\treturn min;\n\t}else if(x > max){\n\t\treturn max;\n\t}else{\n\t\treturn x;\n\t}\n}\n\n/**\n * 直線と点との距離\n */\nfunction getDistanceLinePoint(line,point){\n\tvar vec1 = new Vector2D(line.point2.x - line.point1.x,line.point2.y - line.point1.y);\n\tvar vec2 = new Vector2D(point.x - line.point1.x,point.y - line.point1.y);\n\treturn Math.abs(getCross(vec1,vec2) / getVectorLength2D(vec1)); \n}\n\n/**\n * 線分と点との距離を求める\n */\nfunction getDistanceSegmentPoint(segment,point){    \n\t// ベクトルp2 - p1とベクトルp - p1がなす角θが90どより大きい場合(-90より小さい場合)\n\t// dは点pと点p1の距離になる\n\tif(dotProduct2D(subtractPoint(segment.point2,segment.point1),subtractPoint(point,segment.point1)) < 0){\n\t\treturn getVectorLength2D(subtractPoint(point,segment.point1));\n\t}\n\t// ベクトルp1 - p2とベクトルp - p2がなす角θが90どより大きい場合(-90より小さい場合)\n\t// dは点pと点p2の距離になる\n\tif(dotProduct2D(subtractPoint(segment.point1,segment.point2),subtractPoint(point,segment.point2)) < 0){\n\t\treturn getVectorLength2D(subtractPoint(point,segment.point2));\n\t}\n\t// それ以外はdは点pと直線p1p2の距離になる\n\treturn getDistanceLinePoint(segment,point);\n}\n\n/**\n * 線分と線分との距離を求める\n */\nfunction getSegmentDistance(segment1,segment2){\n\t// 交差していた場合距離は0になる\n\tif(isSegmentsCollide(segment1,segment2)){\n\t\treturn 0;\n\t}\n\treturn Math.min(Math.min(getDistanceSegmentPoint(segment1,segment2.point1),getDistanceSegmentPoint(segment1,segment2.point2)),\n\t\t\tMath.min(getDistanceSegmentPoint(segment2,segment1.point1),getDistanceSegmentPoint(segment2,segment1.point2)));\n}\n\nfunction ccw(point1,point2,point3){\n    var vec1 = new Vector2D(point2.x - point1.x,point2.y - point1.y);\n    var vec2 = new Vector2D(point3.x - point1.x,point3.y - point1.y);\n    var cross = getCross(vec1,vec2);\n\n    if(cross > Number.EPSILON){\n        return COUNTER_CLOCKWISE;\n    }\n    if(cross < -Number.EPSILON){\n        return CLOCKWISE;\n    }\n    if(dotProduct2D(vec1,vec2) < -Number.EPSILON){\n        return ONLINE_BACK;\n    }\n    if(getVectorLength2D(vec1) < getVectorLength2D(vec2)){\n        return ONLINE_FRONT;\n    }\n    return ON_SEGMENT;\n}\n\n/**\n * アンドリューでconvex hollを返す \n*/\nfunction getConvexHoll(points){\n    if(points.length < 3){\n        return points;\n    }\n    \n    // xを基準に昇順にソート、数値が同じものはyが小さいもの基準にソート \n    points.sort((a, b) => (a.x > b.x) ? 1 : (a.x == b.x) ? ((a.y > b.y) ? 1 : -1) : -1);\n    // xを小さいほうから2つ\n    var u = [];\n    u.push(points[0]);\n    u.push(points[1]);\n    // xを大きい方から2つ\n    var l = [];\n    l.push(points[points.length - 1]);\n    l.push(points[points.length - 2]);\n    \n    // 上部の生成\n    for(var i = 2;i < points.length;++i){\n    \t// 対象が半時計なら削除する\n        for(var j = u.length;j >= 2 && ccw(u[j - 2],u[j - 1],points[i]) == COUNTER_CLOCKWISE;--j){\n            u.pop();\n        }\n        u.push(points[i]);\n    }\n    // 下部の生成\n    for(var i = points.length - 3;i >= 0;--i){\n    \t// 対象が半時計なら削除する\n        for(var j = l.length;j >= 2 && ccw(l[j - 2],l[j - 1],points[i]) == COUNTER_CLOCKWISE;--j){\n            l.pop();;\n        }\n        l.push(points[i]);\n    }\n    // 時計回りに凸包の点の列を生成\n    l.reverse();\n    for(var i = u.length - 2;i >= 1;--i){\n        l.push(u[i]);\n    }\n    return l;\n}\n\nfunction getConvexDiameter(points){\n\t// 対心点(p,q)を取る(y軸で最小・最大のもの)\n    var is = 0;\n    var js = 0;\n    for(var i = 1; i < points.length; i++){\n      if(points[i].y > points[is].y) is = i;\n      if(points[i].y < points[js].y) js = i;\n    }\n    var distance = getNorm(subtractVector(points[is],points[js]));\n    var maxi = is,i = js,maxj = js,j = js;\n    do {\n        // 対心点の中で最長距離のものを探す\n      if(getCross(subtractVector(points[(i + 1) % points.length],points[i]),subtractVector(points[(j + 1) % points.length],points[j])) >= 0){\n        j = (j + 1) % points.length;\n      } else {\n        i = (i + 1) % points.length;\n      }\n      if(getNorm(subtractVector(points[i],points[j])) > distance){\n        distance = getNorm(subtractVector(points[i],points[j]));\n        maxi = i;\n        maxj = j;\n      }\n    }  while (i != is || j != js);\n    return distance;\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\n//var input = require('fs').readFileSync('input.txt', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\t\nvar n = Arr[0];\nvar points = [];\n// 消す\nArr.shift();\n\n// 多角形の点を記録する\nfor(var i = 0;i < n;++i){\n    var nums = Arr[i].split(\" \").map(Number);\n    points[i] = new Point2D(nums[0],nums[1]);\n}\n\nvar distance = getConvexDiameter(points);\nconsole.log(Math.sqrt(distance).toFixed(12));\n\n"
  },
  {
    "language": "Ruby",
    "code": "def distance(p1, p2)\n  return Math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\nend\n\nn = gets.to_i\npt = []\nn.times{|i|\n  pt[i] = gets.split.map(&:to_f)\n}\n\nis = 0\njs = 0\nn.times{|i|\n  is = i if pt[i][1] > pt[is][1]\n  js = i if pt[i][1] < pt[js][1]\n}\n\nd_max = distance(pt[is], pt[js])\n\ni = is\nj = js\n\nloop do\n  vi = [pt[(i+1)%n][0] - pt[i][0], pt[(i+1)%n][1] - pt[i][1]]\n  vj = [pt[(j+1)%n][0] - pt[j][0], pt[(j+1)%n][1] - pt[j][1]]\n  if vi[0]*vj[1]-vi[1]*vj[0] >= 0\n    j = (j+1) % n\n  else\n    i = (i+1) % n\n  end\n  d = distance(pt[i], pt[j])\n  d_max = d if d > d_max\n  break if i == is && j == js\nend\n\nputs d_max"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef diff(p, i):\n    return p[(i + 1) % len(p)] - p[i]\n\n# http://www.prefield.com/algorithm/geometry/convex_diameter.html\ndef convex_diameter(p):\n    js = ks = 0\n    for i in range(1, len(p)):\n        if p[i].imag > p[js].imag:\n            js = i\n        if p[i].imag < p[ks].imag:\n            ks = i\n\n    maxd = abs(p[js] - p[ks])\n    j, k = js, ks\n    while True:\n        if cross(diff(p, j), diff(p, k)) >= 0:\n            k = (k + 1) % len(p)\n        else:\n            j = (j + 1) % len(p)\n        if maxd < abs(p[j] - p[k]):\n            maxd = abs(p[j] - p[k])\n        if j == js and k == ks:\n            break\n    return maxd\n\n\nn = int(readline())\np = [map(float, readline().split()) for _ in range(n)]\np = [x + y * 1j for x, y in p]\nprint('{:.2f}'.format(convex_diameter(p)))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# CGL_4_B: Convex Polygon - Diameter of a Convex Polygon\n\nfrom operator import itemgetter\nfrom math import sqrt\n\n\ndef distance(p0, p1):\n    x0, y0 = p0\n    x1, y1 = p1\n    return sqrt((x1-x0)**2 + (y1-y0)**2)\n\n\ndef cross(p0, p1, p2, p3):\n    x0, y0 = p0\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    return (x1-x0) * (y3-y2) - (x3-x2) * (y1-y0)\n\n\ndef rotating_calipers(ps):\n    ps.sort(key=itemgetter(0, 1))\n    upper = []\n    lower = []\n    for p in ps:\n        while (len(upper) > 1\n               and cross(upper[-2], upper[-1], upper[-1], p) <= 0):\n            upper.pop()\n        while (len(lower) > 1\n               and cross(lower[-2], lower[-1], lower[-1], p) >= 0):\n            lower.pop()\n\n        upper.append(p)\n        lower.append(p)\n\n    nu, nl = len(upper), len(lower)\n    i, j = 0, nl-1\n    dist = 0.0\n    while i < nu and j >= 0:\n        d = distance(upper[i], lower[j])\n        if dist < d:\n            dist = d\n\n        if i == nu-1:\n            j -= 1\n        elif j == 0:\n            i += 1\n        elif cross(upper[i], upper[i+1], lower[j-1], lower[j]) > 0:\n            i += 1\n        else:\n            j -= 1\n\n    return dist\n\n\ndef run():\n    n = int(input())\n    ps = []\n\n    for _ in range(n):\n        x, y = [float(f) for f in input().split()]\n        ps.append((x, y))\n\n    print(\"{:.10f}\".format(rotating_calipers(ps)))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# Cross product\ndef cross(p1, p2, q1, q2):\n    p = p2 - p1\n    q = q2 - q1\n    return p.real * q.imag - p.imag * q.real\n\n# Rotating calipers\ndef convex_diameter(points, n):\n    points.append(points[0])\n    p0 = points[0]\n    p1 = points[1]\n    for i, (q1, q2) in enumerate(zip(points[1:], points[2:]), start=1):\n        if cross(p0, p1, q1, q2) <= 0:\n            break\n    \n    max_d = abs(points[i] - points[0])\n\n    points.append(points[1])\n    side1 = zip(points[0:i+1], points[1:i+2])\n    side2 = zip(points[i:n+1], points[i+1:])\n    p1, p2 = side1.__next__()\n    q1, q2 = side2.__next__()\n    \n    for i in range(n - 1):\n        if cross(p1, p2, q1, q2) > 0:\n            q1, q2 = side2.__next__()\n        else:\n            p1, p2 = side1.__next__()\n        max_d = max(max_d, abs(p1 - q1))\n\n    return max_d\n\n# Acceptance of input\ndef string_to_complex(s):\n    x, y = map(float, s.split())\n    return x + y * 1j\n\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [string_to_complex(line) for line in file_input]\n\n# Output\nans = convex_diameter(P, n)\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\n\ndef cross(P0, P1, P2):\n    x0, y0 = P0; x1, y1 = P1; x2, y2 = P2\n    x1 -= x0; x2 -= x0\n    y1 -= y0; y2 -= y0\n    return x1*y2 - x2*y1\n\ndef dot(P0, P1, P2):\n    x0, y0 = P0; x1, y1 = P1; x2, y2 = P2\n    x1 -= x0; x2 -= x0\n    y1 -= y0; y2 -= y0\n    return x1*x2 + y1*y2\n\ndef dist2(P0, P1):\n    x0, y0 = P0; x1, y1 = P1\n    return (x1 - x0)**2 + (y1 - y0)**2\n\ndef convex_hull(PS):\n    QS = []\n    n = len(PS)\n    if n==1:\n        return PS[:]\n    for P in PS:\n        while len(QS)>1 and cross(QS[-1], QS[-2], P) > 0:\n            QS.pop()\n        QS.append(P)\n    k = len(QS)\n    RS = reversed(PS); next(RS)\n    for P in RS:\n        while len(QS)>k and cross(QS[-1], QS[-2], P) > 0:\n            QS.pop()\n        QS.append(P)\n    return QS\n\ndef cross4(S0, S1, T0, T1):\n    x0, y0 = S0; x1, y1 = S1\n    X0, Y0 = T0; X1, Y1 = T1\n    return (x1-x0)*(Y1-Y0) - (y1-y0)*(X1-X0)\ndef calipers(PS):\n    QS = convex_hull(PS)\n    n = len(QS)\n    if n == 2:\n        return sqrt(dist2(*QS))\n    i = j = 0\n    for k in range(n):\n        if QS[k] < QS[i]: i = k\n        if QS[j] < QS[k]: j = k\n    res = 0\n    si = i; sj = j\n    while i != sj or j != si:\n        res = max(res, dist2(QS[i], QS[j]))\n        if cross4(QS[i], QS[i-n+1], QS[j], QS[j-n+1]) < 0:\n            i = (i + 1) % n\n        else:\n            j = (j + 1) % n\n    return sqrt(res)\n\nn = input()\nPS = [map(float, raw_input().split()) for i in range(n)]\nPS.sort()\nprint(\"%.09f\" % calipers(PS))"
  },
  {
    "language": "Python",
    "code": "# Cross product\ndef cross(p1, p2, q1, q2):\n    p = p2 - p1\n    q = q2 - q1\n    return p.real * q.imag - p.imag * q.real\n\n# Rotating calipers\ndef convex_diameter(points, n):\n    points.append(points[0])\n    p0 = points[0]\n    p1 = points[1]\n    for i, (q1, q2) in enumerate(zip(points[1:], points[2:]), start=1):\n        if cross(p0, p1, q1, q2) < 0:\n            break\n    \n    max_d = abs(points[i] - points[0])\n\n    points.append(points[1])\n    side1 = zip(points[0:i+1], points[1:i+2])\n    side2 = zip(points[i:n+1], points[i+1:])\n    p1, p2 = side1.__next__()\n    q1, q2 = side2.__next__()\n    \n    for i in range(n - 1):\n        if cross(p1, p2, q1, q2) > 0:\n            q1, q2 = side2.__next__()\n        else:\n            p1, p2 = side1.__next__()\n        max_d = max(max_d, abs(p1 - q1))\n\n    return max_d\n\n# Acceptance of input\ndef string_to_complex(s):\n    x, y = map(float, s.split())\n    return x + y * 1j\n\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [string_to_complex(line) for line in file_input]\n\n# Output\nans = convex_diameter(P, n)\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "def diff(i):\n    cp, np = points[i:i + 2]\n    return np - cp\n\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\n\ndef diameter(i, j):\n    return abs(points[i] - points[j])\n\n\nn = int(input())\nt_points = [tuple(map(float, input().split())) for _ in range(n)]\ni = min(range(n), key=lambda x: t_points[x])\nj = max(range(n), key=lambda x: t_points[x])\npoints = [re + 1j * im for re, im in t_points]\npoints.append(points[0])\ntentative_diameter = diameter(i, j)\n\nit, jt = i, j\nwhile True:\n    if cross(diff(it), diff(jt)) >= 0:\n        jt = (jt + 1) % n\n    else:\n        it = (it + 1) % n\n    tentative_diameter = max(tentative_diameter, diameter(it, jt))\n\n    if it == i and jt == j:\n        break\n\nprint(tentative_diameter)"
  },
  {
    "language": "Python",
    "code": "import cmath\nEPS = 1e-10\n\n#外積\ndef OuterProduct(one, two):\n\ttmp = one.conjugate() * two\n\treturn tmp.imag\n\n#3点が反時計回りか\n#一直線上のときの例外処理できていない→とりあえずT\ndef CCW(p, q, r):\n\tone, two = q-p, r-q\n\tif OuterProduct(one, two) > -EPS:\n\t\treturn True\n\telse:\n\t\treturn False\n\n#凸包の直径\ndef ConvexDiameter(qs):\n\tn = len(qs)\n\tif n == 2:\n \t\treturn abs(qs[0]-qs[1])\n\ti, j = 0, 0\n\tfor k in range(n):\n\t\tif qs[k].real < qs[i].real:\n\t\t\ti = k\n\t\tif qs[j].real < qs[k].real:\n\t\t\tj = k\n\tres = 0\n\tsi, sj = i, j\n\twhile i != sj or j != si:\n\t\tres = max(res, abs(qs[i]-qs[j]))\n\t\tif OuterProduct(qs[i-n+1] - qs[i], qs[j-n+1] - qs[j]) < -EPS:\n\t\t\ti = (i+1) % n\n\t\telse:\n\t\t\tj = (j+1) % n\n\treturn res\n\nn = int(input())\ndots = []\nfor _ in range(n):\n\tx, y = map(float, input().split())\n\tdots.append(complex(x, y))\n\nprint(\"{:.12f}\".format(ConvexDiameter(dots)))\n"
  },
  {
    "language": "Python",
    "code": "from typing import List\n\n\ndef cross(a: complex, b: complex) -> float:\n    return a.real * b.imag - a.imag * b.real\n\n\ndef distance(i: int, j: int, coordinates: List[complex]) -> float:\n    return abs(coordinates[i] - coordinates[j])\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    points = [tuple(map(float, input().split())) for _ in range(n)]\n    min_x_idx = min(range(n), key=lambda x: points[x])\n    max_x_idx = max(range(n), key=lambda x: points[x])\n    coordinates = [re + 1j * im for re, im in points]\n    coordinates.append(coordinates[0])\n\n    ans = distance(min_x_idx, max_x_idx, coordinates)\n    i, j = min_x_idx, max_x_idx\n    while True:\n        if 0 <= cross(coordinates[i + 1] - coordinates[i],\n                      coordinates[j + 1] - coordinates[j]):\n            j = (j + 1) % n\n        else:\n            i = (i + 1) % n\n        ans = max(ans, distance(i, j, coordinates))\n\n        if min_x_idx == i and max_x_idx == j:\n            break\n\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import cmath\nimport math\nimport os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nPI = cmath.pi\nTAU = cmath.pi * 2\nEPS = 1e-8\n\n\nclass Point:\n    \"\"\"\n    2次元空間上の点\n    \"\"\"\n\n    # 反時計回り側にある\n    CCW_COUNTER_CLOCKWISE = 1\n    # 時計回り側にある\n    CCW_CLOCKWISE = -1\n    # 線分の後ろにある\n    CCW_ONLINE_BACK = 2\n    # 線分の前にある\n    CCW_ONLINE_FRONT = -2\n    # 線分上にある\n    CCW_ON_SEGMENT = 0\n\n    def __init__(self, c: complex):\n        self.c = c\n\n    @property\n    def x(self):\n        return self.c.real\n\n    @property\n    def y(self):\n        return self.c.imag\n\n    @staticmethod\n    def from_rect(x: float, y: float):\n        return Point(complex(x, y))\n\n    @staticmethod\n    def from_polar(r: float, phi: float):\n        return Point(cmath.rect(r, phi))\n\n    def __add__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        return Point(self.c + p.c)\n\n    def __iadd__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        self.c += p.c\n        return self\n\n    def __sub__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        return Point(self.c - p.c)\n\n    def __isub__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        self.c -= p.c\n        return self\n\n    def __mul__(self, f: float):\n        return Point(self.c * f)\n\n    def __imul__(self, f: float):\n        self.c *= f\n        return self\n\n    def __truediv__(self, f: float):\n        return Point(self.c / f)\n\n    def __itruediv__(self, f: float):\n        self.c /= f\n        return self\n\n    def __repr__(self):\n        return \"({}, {})\".format(round(self.x, 10), round(self.y, 10))\n\n    def __neg__(self):\n        return Point(-self.c)\n\n    def __eq__(self, p):\n        return abs(self.c - p.c) < EPS\n\n    def __abs__(self):\n        return abs(self.c)\n\n    @staticmethod\n    def ccw(a, b, c):\n        \"\"\"\n        線分 ab に対する c の位置\n        線分上にあるか判定するだけなら on_segment とかのが速い\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n        :param Point a:\n        :param Point b:\n        :param Point c:\n        \"\"\"\n        b = b - a\n        c = c - a\n        det = b.det(c)\n        if det > EPS:\n            return Point.CCW_COUNTER_CLOCKWISE\n        if det < -EPS:\n            return Point.CCW_CLOCKWISE\n        if b.dot(c) < -EPS:\n            return Point.CCW_ONLINE_BACK\n        if c.norm() - b.norm() > EPS:\n            return Point.CCW_ONLINE_FRONT\n        return Point.CCW_ON_SEGMENT\n\n    def dot(self, p):\n        \"\"\"\n        内積\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return self.x * p.x + self.y * p.y\n\n    def det(self, p):\n        \"\"\"\n        外積\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return self.x * p.y - self.y * p.x\n\n    def dist(self, p):\n        \"\"\"\n        距離\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return abs(self.c - p.c)\n\n    def norm(self):\n        \"\"\"\n        原点からの距離\n        :rtype: float\n        \"\"\"\n        return abs(self.c)\n\n    def phase(self):\n        \"\"\"\n        原点からの角度\n        :rtype: float\n        \"\"\"\n        return cmath.phase(self.c)\n\n    def angle(self, p, q):\n        \"\"\"\n        p に向いてる状態から q まで反時計回りに回転するときの角度\n        -pi <= ret <= pi\n        :param Point p:\n        :param Point q:\n        :rtype: float\n        \"\"\"\n        return (cmath.phase(q.c - self.c) - cmath.phase(p.c - self.c) + PI) % TAU - PI\n\n    def area(self, p, q):\n        \"\"\"\n        p, q となす三角形の面積\n        :param Point p:\n        :param Point q:\n        :rtype: float\n        \"\"\"\n        return abs((p - self).det(q - self) / 2)\n\n    def projection_point(self, p, q, allow_outer=False):\n        \"\"\"\n        線分 pq を通る直線上に垂線をおろしたときの足の座標\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\n        :param Point p:\n        :param Point q:\n        :param allow_outer: 答えが線分の間になくても OK\n        :rtype: Point|None\n        \"\"\"\n        diff_q = q - p\n        # 答えの p からの距離\n        r = (self - p).dot(diff_q) / abs(diff_q)\n        # 線分の角度\n        phase = diff_q.phase()\n\n        ret = Point.from_polar(r, phase) + p\n        if allow_outer or (p - ret).dot(q - ret) < EPS:\n            return ret\n        return None\n\n    def reflection_point(self, p, q):\n        \"\"\"\n        直線 pq を挟んで反対にある点\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\n        :param Point p:\n        :param Point q:\n        :rtype: Point\n        \"\"\"\n        # 距離\n        r = abs(self - p)\n        # pq と p-self の角度\n        angle = p.angle(q, self)\n        # 直線を挟んで角度を反対にする\n        angle = (q - p).phase() - angle\n        return Point.from_polar(r, angle) + p\n\n    def on_segment(self, p, q, allow_side=True):\n        \"\"\"\n        点が線分 pq の上に乗っているか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n        :param Point p:\n        :param Point q:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        :rtype: bool\n        \"\"\"\n        if not allow_side and (self == p or self == q):\n            return False\n        # 外積がゼロ: 面積がゼロ == 一直線\n        # 内積がマイナス: p - self - q の順に並んでる\n        return abs((p - self).det(q - self)) < EPS and (p - self).dot(q - self) < EPS\n\n\nclass Line:\n    \"\"\"\n    2次元空間上の直線\n    \"\"\"\n\n    def __init__(self, a: float, b: float, c: float):\n        \"\"\"\n        直線 ax + by + c = 0\n        \"\"\"\n        self.a = a\n        self.b = b\n        self.c = c\n\n    @staticmethod\n    def from_gradient(grad: float, intercept: float):\n        \"\"\"\n        直線 y = ax + b\n        :param grad: 傾き\n        :param intercept: 切片\n        :return:\n        \"\"\"\n        return Line(grad, -1, intercept)\n\n    @staticmethod\n    def from_segment(p1, p2):\n        \"\"\"\n        :param Point p1:\n        :param Point p2:\n        \"\"\"\n        a = p2.y - p1.y\n        b = p1.x - p2.x\n        c = p2.y * (p2.x - p1.x) - p2.x * (p2.y - p1.y)\n        return Line(a, b, c)\n\n    @property\n    def gradient(self):\n        \"\"\"\n        傾き\n        \"\"\"\n        return INF if self.b == 0 else -self.a / self.b\n\n    @property\n    def intercept(self):\n        \"\"\"\n        切片\n        \"\"\"\n        return INF if self.b == 0 else -self.c / self.b\n\n    def is_parallel_to(self, l):\n        \"\"\"\n        平行かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Line l:\n        \"\"\"\n        # 法線ベクトル同士の外積がゼロ\n        return abs(Point.from_rect(self.a, self.b).det(Point.from_rect(l.a, l.b))) < EPS\n\n    def is_orthogonal_to(self, l):\n        \"\"\"\n        直行しているかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Line l:\n        \"\"\"\n        # 法線ベクトル同士の内積がゼロ\n        return abs(Point.from_rect(self.a, self.b).dot(Point.from_rect(l.a, l.b))) < EPS\n\n    def intersection_point(self, l):\n        \"\"\"\n        交差する点\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=ja\n        FIXME: 誤差が気になる。EPS <= 1e-9 だと CGL_2_B ダメだった。\n        :param l:\n        :rtype: Point|None\n        \"\"\"\n        a1, b1, c1 = self.a, self.b, self.c\n        a2, b2, c2 = l.a, l.b, l.c\n        det = a1 * b2 - a2 * b1\n        if abs(det) < EPS:\n            # 並行\n            return None\n        x = (b1 * c2 - b2 * c1) / det\n        y = (a2 * c1 - a1 * c2) / det\n        return Point.from_rect(x, y)\n\n\nclass Segment:\n    \"\"\"\n    2次元空間上の線分\n    \"\"\"\n\n    def __init__(self, p1, p2):\n        \"\"\"\n        :param Point p1:\n        :param Point p2:\n        \"\"\"\n        self.p1 = p1\n        self.p2 = p2\n\n    def norm(self):\n        \"\"\"\n        線分の長さ\n        \"\"\"\n        return abs(self.p1 - self.p2)\n\n    def intersects_with(self, s, allow_side=True):\n        \"\"\"\n        交差するかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\n        :param Segment s:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        \"\"\"\n        l1 = Line.from_segment(self.p1, self.p2)\n        l2 = Line.from_segment(s.p1, s.p2)\n        if l1.is_parallel_to(l2):\n            # 並行なら線分の端点がもう片方の線分の上にあるかどうか\n            return (s.p1.on_segment(self.p1, self.p2, allow_side) or\n                    s.p2.on_segment(self.p1, self.p2, allow_side) or\n                    self.p1.on_segment(s.p1, s.p2, allow_side) or\n                    self.p2.on_segment(s.p1, s.p2, allow_side))\n        else:\n            # 直線同士の交点が線分の上にあるかどうか\n            p = l1.intersection_point(l2)\n            return p.on_segment(self.p1, self.p2, allow_side) and p.on_segment(s.p1, s.p2, allow_side)\n\n    def closest_point(self, p):\n        \"\"\"\n        線分上の、p に最も近い点\n        :param Point p:\n        \"\"\"\n        # p からおろした垂線までの距離\n        d = (p - self.p1).dot(self.p2 - self.p1) / self.norm()\n        # p1 より前\n        if d < EPS:\n            return self.p1\n        # p2 より後\n        if -EPS < d - self.norm():\n            return self.p2\n        # 線分上\n        return Point.from_polar(d, (self.p2 - self.p1).phase()) + self.p1\n\n    def dist(self, p):\n        \"\"\"\n        他の点との最短距離\n        :param Point p:\n        \"\"\"\n        return abs(p - self.closest_point(p))\n\n    def dist_segment(self, s):\n        \"\"\"\n        他の線分との最短距離\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\n        :param Segment s:\n        \"\"\"\n        if self.intersects_with(s):\n            return 0.0\n        return min(\n            self.dist(s.p1),\n            self.dist(s.p2),\n            s.dist(self.p1),\n            s.dist(self.p2),\n        )\n\n    def has_point(self, p, allow_side=True):\n        \"\"\"\n        p が線分上に乗っているかどうか\n        :param Point p:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        \"\"\"\n        return p.on_segment(self.p1, self.p2, allow_side=allow_side)\n\n\nclass Polygon:\n    \"\"\"\n    2次元空間上の多角形\n    \"\"\"\n\n    def __init__(self, points):\n        \"\"\"\n        :param list of Point points:\n        \"\"\"\n        self.points = points\n\n    def iter2(self):\n        \"\"\"\n        隣り合う2点を順に返すイテレータ\n        :rtype: typing.Iterator[(Point, Point)]\n        \"\"\"\n        return zip(self.points, self.points[1:] + self.points[:1])\n\n    def iter3(self):\n        \"\"\"\n        隣り合う3点を順に返すイテレータ\n        :rtype: typing.Iterator[(Point, Point, Point)]\n        \"\"\"\n        return zip(self.points,\n                   self.points[1:] + self.points[:1],\n                   self.points[2:] + self.points[:2])\n\n    def area(self):\n        \"\"\"\n        面積\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=ja\n        \"\"\"\n        # 外積の和 / 2\n        dets = []\n        for p, q in self.iter2():\n            dets.append(p.det(q))\n        return abs(math.fsum(dets)) / 2\n\n    def is_convex(self, allow_straight=False, allow_collapsed=False):\n        \"\"\"\n        凸多角形かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=ja\n        :param allow_straight: 3点がまっすぐ並んでるのを許容するかどうか\n        :param allow_collapsed: 面積がゼロの場合を許容するか\n        \"\"\"\n        ccw = []\n        for a, b, c in self.iter3():\n            ccw.append(Point.ccw(a, b, c))\n        ccw = set(ccw)\n        if len(ccw) == 1:\n            if ccw == {Point.CCW_CLOCKWISE}:\n                return True\n            if ccw == {Point.CCW_COUNTER_CLOCKWISE}:\n                return True\n        if allow_straight and len(ccw) == 2:\n            if ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_CLOCKWISE}:\n                return True\n            if ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_COUNTER_CLOCKWISE}:\n                return True\n        if allow_collapsed and len(ccw) == 3:\n            return ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_ONLINE_BACK, Point.CCW_ON_SEGMENT}\n        return False\n\n    def has_point_on_edge(self, p):\n        \"\"\"\n        指定した点が辺上にあるか\n        :param Point p:\n        :rtype: bool\n        \"\"\"\n        for a, b in self.iter2():\n            if p.on_segment(a, b):\n                return True\n        return False\n\n    def contains(self, p, allow_on_edge=True):\n        \"\"\"\n        指定した点を含むか\n        Winding Number Algorithm\n        https://www.nttpc.co.jp/technology/number_algorithm.html\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C&lang=ja\n        :param Point p:\n        :param bool allow_on_edge: 辺上の点を許容するか\n        \"\"\"\n        angles = []\n        for a, b in self.iter2():\n            if p.on_segment(a, b):\n                return allow_on_edge\n            angles.append(p.angle(a, b))\n        # 一周以上するなら含む\n        return abs(math.fsum(angles)) > EPS\n\n    @staticmethod\n    def convex_hull(points, allow_straight=False):\n        \"\"\"\n        凸包。x が最も小さい点のうち y が最も小さい点から反時計回り。\n        Graham Scan O(N log N)\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=ja\n        :param list of Point points:\n        :param allow_straight: 3点がまっすぐ並んでるのを許容するかどうか\n        :rtype: list of Point\n        \"\"\"\n        points = points[:]\n        points.sort(key=lambda p: (p.x, p.y))\n\n        # allow_straight なら 0 を許容する\n        det_lower = -EPS if allow_straight else EPS\n\n        sz = 0\n        #: :type: list of (Point|None)\n        ret = [None] * (N * 2)\n        for p in points:\n            while sz > 1 and (ret[sz - 1] - ret[sz - 2]).det(p - ret[sz - 1]) < det_lower:\n                sz -= 1\n            ret[sz] = p\n            sz += 1\n        floor = sz\n        for p in reversed(points[:-1]):\n            while sz > floor and (ret[sz - 1] - ret[sz - 2]).det(p - ret[sz - 1]) < det_lower:\n                sz -= 1\n            ret[sz] = p\n            sz += 1\n        ret = ret[:sz - 1]\n\n        if allow_straight and len(ret) > len(points):\n            # allow_straight かつ全部一直線のときに二重にカウントしちゃう\n            ret = points\n        return ret\n\n    @staticmethod\n    def diameter(points):\n        \"\"\"\n        直径\n        凸包構築 O(N log N) + カリパー法 O(N)\n        :param list of Point points:\n        \"\"\"\n        # 反時計回り\n        points = Polygon.convex_hull(points)\n        if len(points) == 1:\n            return 0.0\n        if len(points) == 2:\n            return abs(points[0] - points[1])\n\n        # x軸方向に最も遠い点対\n        si = points.index(min(points, key=lambda p: (p.x, p.y)))\n        sj = points.index(max(points, key=lambda p: (p.x, p.y)))\n        n = len(points)\n\n        ret = 0.0\n        # 一周させる\n        i, j = si, sj\n        while i != sj or j != si:\n            ret = max(ret, abs(points[i] - points[j]))\n            ni = (i + 1) % n\n            nj = (j + 1) % n\n            # 2つの辺が水平になる方向にずらす\n            if (points[ni] - points[i]).det(points[nj] - points[j]) > 0:\n                j = nj\n            else:\n                i = ni\n        return ret\n\n\nN = int(sys.stdin.buffer.readline())\nXY = [list(map(float, sys.stdin.buffer.readline().split())) for _ in range(N)]\n\npoints = []\nfor x, y in XY:\n    points.append(Point(complex(x, y)))\nans = Polygon.diameter(points)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "# Cross product\ndef cross(p1, p2, q1, q2):\n    p = p2 - p1\n    q = q2 - q1\n    return p.real * q.imag - p.imag * q.real\n\n# Rotating calipers\ner = 1e-16\n\ndef convex_diameter(points, n):\n    points.append(points[0])\n    p0 = points[0]\n    p1 = points[1]\n    for i, (q1, q2) in enumerate(zip(points[1:], points[2:]), start=1):\n        if cross(p0, p1, q1, q2) < -er:\n            break\n    \n    max_d = abs(points[i] - points[0])\n\n    points.append(points[1])\n    side1 = zip(points[0:i+1], points[1:i+2])\n    side2 = zip(points[i:n+1], points[i+1:])\n    p1, p2 = side1.__next__()\n    q1, q2 = side2.__next__()\n    \n    for i in range(n - 1):\n        if cross(p1, p2, q1, q2) > er:\n            q1, q2 = side2.__next__()\n        else:\n            p1, p2 = side1.__next__()\n        max_d = max(max_d, abs(p1 - q1))\n\n    return max_d\n\n# Acceptance of input\ndef string_to_complex(s):\n    x, y = map(float, s.split())\n    return x + y * 1j\n\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [string_to_complex(line) for line in file_input]\n\n# Output\nans = convex_diameter(P, n)\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\n\ndef diff(p, i):\n    return p[(i + 1) % len(p)] - p[i]\n\n# http://www.prefield.com/algorithm/geometry/convex_diameter.html\ndef convex_diameter(p):\n    js = ks = 0\n    for i in range(1, len(p)):\n        if p[i].imag > p[js].imag:\n            js = i\n        if p[i].imag < p[ks].imag:\n            ks = i\n\n    maxd = abs(p[js] - p[ks])\n    j, k = js, ks\n    while True:\n        if cross(diff(p, j), diff(p, k)) >= 0:\n            k = (k + 1) % len(p)\n        else:\n            j = (j + 1) % len(p)\n        if maxd < abs(p[j] - p[k]):\n            maxd = abs(p[j] - p[k])\n        if j == js and k == ks:\n            break\n    return maxd\n\n\nn = int(readline())\np = [map(float, readline().split()) for _ in range(n)]\np = [x + y * 1j for x, y in p]\nprint('{:.6f}'.format(convex_diameter(p)))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport array\nfrom fractions import Fraction\nimport functools\nimport itertools\nimport math\nimport os\nimport sys\n\n\ndef main():\n    N = read_int()\n    P = []\n    for _ in range(N):\n        x, y = [Fraction(s) for s in inp().split()]\n        P.append(Vec(x, y))\n    print(solve(N, P))\n\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\n\ndef solve(N, P):\n    factor = 1\n    for p in P:\n        factor = lcm(lcm(factor, p.x.denominator), p.y.denominator)\n\n    F = [Vec(int(p.x * factor), int(p.y * factor)) for p in P]\n\n    pi = 0\n    pyx = (F[0].y, F[0].x)\n    qi = 0\n    qyx = pyx\n\n    for i, a in enumerate(F):\n        ayx = (a.y, a.x)\n        if pyx > ayx:\n            pi = i\n            pyx = ayx\n        if qyx < ayx:\n            qi = i\n            qyx = ayx\n\n    p0i = pi\n    q0i = qi\n    best = (F[pi] - F[qi]).abs2()\n    while True:\n        p = F[pi]\n        p1 = F[(pi + 1) % N]\n        q = F[qi]\n        q1 = F[(qi + 1) % N]\n        if (p1 - p).cross(q1 - q) >= 0:\n            qi = (qi + 1) % N\n        else:\n            pi = (pi + 1) % N\n\n        best = max(best, (F[pi] - F[qi]).abs2())\n\n        if pi == p0i and qi == q0i:\n            break\n\n    return math.sqrt(Fraction(best, factor * factor))\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nclass Vec(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        super().__init__()\n\n    def __add__(self, other):\n        return Vec(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vec(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vec(self.x * scalar, self.y * scalar)\n\n    def __rmul__(self, scalar):\n        return Vec(self.x * scalar, self.y * scalar)\n\n    def __truediv__(self, scalar):\n        return Vec(self.x / scalar, self.y / scalar)\n\n    def __iadd__(self, other):\n        self.x += other.x\n        self.y += other.y\n        return self\n\n    def __isub__(self, other):\n        self.x -= other.x\n        self.y -= other.y\n        return self\n\n    def __imul__(self, scalar):\n        self.x *= scalar\n        self.y *= scalar\n        return self\n\n    def __idiv__(self, scalar):\n        self.x /= scalar\n        self.y /= scalar\n        return self\n\n    def __neg__(self):\n        return Vec(-self.x, -self.y)\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash('Vec', self.x, self.y)\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def abs2(self):\n        return self.x * self.x + self.y * self.y\n\n    def __abs__(self):\n        return math.sqrt(float(self.abs2()))\n\n    def __repr__(self):\n        return '({}, {})'.format(self.x, self.y)\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nn = input()\nps = [map(float, raw_input().split()) for i in xrange(n)]\nps.sort()\n\ndef cross(a, b, c, d):\n    return (b[0]-a[0])*(d[1]-c[1]) - (b[1]-a[1])*(d[0]-c[0])\ndef convex_hull(ps):\n    qs = []\n    n = len(ps)\n    for p in ps:\n        while len(qs)>1 and cross(qs[-1], qs[-2], qs[-1], p) >= 0:\n            qs.pop()\n        qs.append(p)\n    t = len(qs)\n    for i in xrange(n-2, -1, -1):\n        p = ps[i]\n        while len(qs)>t and cross(qs[-1], qs[-2], qs[-1], p) >= 0:\n            qs.pop()\n        qs.append(p)\n    return qs\n\ndef dist(a, b):\n    return sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2)\ndef rotating_calipers(ps):\n    qs = convex_hull(ps)\n    n = len(qs)\n    if n == 2:\n        return dist(qs[0], qs[1])\n    i = j = 0\n    for k in xrange(n):\n        if qs[k] < qs[i]: i = k\n        if qs[j] < qs[k]: j = k\n    res = 0\n    si = i; sj = j\n    while i != sj or j != si:\n        res = max(res, dist(qs[i], qs[j]))\n        if cross(qs[i], qs[i-n+1], qs[j], qs[j-n+1]) < 0:\n            i = (i + 1) % n\n        else:\n            j = (j + 1) % n\n    return res\nprint \"%.09f\" % rotating_calipers(ps)"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\n\n# ??????\ndef cross(P0, P1, P2):\n    x0, y0 = P0; x1, y1 = P1; x2, y2 = P2\n    x1 -= x0; x2 -= x0\n    y1 -= y0; y2 -= y0\n    return x1*y2 - x2*y1\n\n# ??????\ndef dot(P0, P1, P2):\n    x0, y0 = P0; x1, y1 = P1; x2, y2 = P2\n    x1 -= x0; x2 -= x0\n    y1 -= y0; y2 -= y0\n    return x1*x2 + y1*y2\n\n# 2??????????????¢?????????\ndef dist2(P0, P1):\n    x0, y0 = P0; x1, y1 = P1\n    return (x1 - x0)**2 + (y1 - y0)**2\n\n# ??????\n# ??\\???????????????????????§?¨???????\ndef convex_hull(PS):\n    QS = []\n    n = len(PS)\n    for P in PS:\n        while len(QS)>1 and cross(QS[-1], QS[-2], P) > 0:\n            QS.pop()\n        QS.append(P)\n    k = len(QS)\n    RS = reversed(PS); next(RS)\n    for P in RS:\n        while len(QS)>k and cross(QS[-1], QS[-2], P) > 0:\n            QS.pop()\n        QS.append(P)\n    return QS\n\n\n\n# ?????£???????????? (?????????????¨????)\ndef cross4(S0, S1, T0, T1):\n    x0, y0 = S0; x1, y1 = S1\n    X0, Y0 = T0; X1, Y1 = T1\n    return (x1-x0)*(Y1-Y0) - (y1-y0)*(X1-X0)\ndef calipers(PS):\n    QS = convex_hull(PS)\n    n = len(QS)\n    if n == 2:\n        return sqrt(dist2(*QS))\n    i = j = 0\n    for k in range(n):\n        if QS[k] < QS[i]: i = k\n        if QS[j] < QS[k]: j = k\n    res = 0\n    si = i; sj = j\n    while i != sj or j != si:\n        res = max(res, dist2(QS[i], QS[j]))\n        if cross4(QS[i], QS[i-n+1], QS[j], QS[j-n+1]) < 0:\n            i = (i + 1) % n\n        else:\n            j = (j + 1) % n\n    return sqrt(res)\n\nn = int(input())\nPS = [[*map(float, input().split())] for i in range(n)]\nPS.sort()\nprint(\"%.09f\" % calipers(PS))"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\n\ndef cross(P0, P1, P2):\n    x0, y0 = P0; x1, y1 = P1; x2, y2 = P2\n    x1 -= x0; x2 -= x0\n    y1 -= y0; y2 -= y0\n    return x1*y2 - x2*y1\n\ndef dot(P0, P1, P2):\n    x0, y0 = P0; x1, y1 = P1; x2, y2 = P2\n    x1 -= x0; x2 -= x0\n    y1 -= y0; y2 -= y0\n    return x1*x2 + y1*y2\n\ndef dist2(P0, P1):\n    x0, y0 = P0; x1, y1 = P1\n    return (x1 - x0)**2 + (y1 - y0)**2\n\ndef convex_hull(PS):\n    QS = []\n    n = len(PS)\n    if n==1:\n        return PS[:]\n    for P in PS:\n        while len(QS)>1 and cross(QS[-1], QS[-2], P) > 0:\n            QS.pop()\n        QS.append(P)\n    k = len(QS)\n    RS = reversed(PS); next(RS)\n    for P in RS:\n        while len(QS)>k and cross(QS[-1], QS[-2], P) > 0:\n            QS.pop()\n        QS.append(P)\n    return QS\n\ndef cross4(S0, S1, T0, T1):\n    x0, y0 = S0; x1, y1 = S1\n    X0, Y0 = T0; X1, Y1 = T1\n    return (x1-x0)*(Y1-Y0) - (y1-y0)*(X1-X0)\ndef calipers(PS):\n    QS = convex_hull(PS)\n    n = len(QS)\n    if n == 2:\n        return sqrt(dist2(*QS))\n    i = j = 0\n    for k in range(n):\n        if QS[k] < QS[i]: i = k\n        if QS[j] < QS[k]: j = k\n    res = 0\n    si = i; sj = j\n    while i != sj or j != si:\n        res = max(res, dist2(QS[i], QS[j]))\n        if cross4(QS[i], QS[i-n+1], QS[j], QS[j-n+1]) < 0:\n            i = (i + 1) % n\n        else:\n            j = (j + 1) % n\n    return sqrt(res)\n\nn = int(input())\nPS = [[*map(float, input().split())] for i in range(n)]\nPS.sort()\nprint(\"%.09f\" % calipers(PS))"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]\npub struct Complex<T> {\n    pub re: T,\n    pub im: T,\n}\nimpl<T> Complex<T> {\n    #[inline]\n    pub fn new(re: T, im: T) -> Complex<T> {\n        Complex { re: re, im: im }\n    }\n}\nimpl<T: Neg<Output = T>> Complex<T> {\n    #[inline]\n    pub fn conjugate(self) -> Complex<T> {\n        Self::new(self.re, -self.im)\n    }\n}\nimpl<T: Add<Output = T> + Mul<Output = T>> Complex<T> {\n    #[inline]\n    pub fn dot(self, other: Self) -> T {\n        self.re * other.re + self.im * other.im\n    }\n}\nimpl<T: Sub<Output = T> + Mul<Output = T>> Complex<T> {\n    #[inline]\n    pub fn cross(self, other: Self) -> T {\n        self.re * other.im - self.im * other.re\n    }\n}\nimpl<T: Copy + Add<Output = T> + Mul<Output = T>> Complex<T> {\n    #[inline]\n    pub fn norm(self) -> T {\n        self.re * self.re + self.im * self.im\n    }\n}\nimpl Complex<f64> {\n    #[inline]\n    pub fn from_polar(r: f64, theta: f64) -> Self {\n        Complex::new(r * theta.cos(), r * theta.sin())\n    }\n    #[inline]\n    pub fn abs(self) -> f64 {\n        self.re.hypot(self.im)\n    }\n    #[inline]\n    pub fn unit(self) -> Self {\n        self / self.abs()\n    }\n    #[inline]\n    pub fn angle(self) -> f64 {\n        self.im.atan2(self.re)\n    }\n}\nimpl<T: Add<Output = T>> Add for Complex<T> {\n    type Output = Self;\n    fn add(self, other: Self) -> Self::Output {\n        Self::new(self.re + other.re, self.im + other.im)\n    }\n}\nimpl<T: Copy + Add<Output = T>> Add<T> for Complex<T> {\n    type Output = Self;\n    fn add(self, other: T) -> Self::Output {\n        Self::new(self.re + other, self.im + other)\n    }\n}\nimpl<T: Sub<Output = T>> Sub for Complex<T> {\n    type Output = Self;\n    fn sub(self, other: Self) -> Self::Output {\n        Self::new(self.re - other.re, self.im - other.im)\n    }\n}\nimpl<T: Copy + Sub<Output = T>> Sub<T> for Complex<T> {\n    type Output = Self;\n    fn sub(self, other: T) -> Self::Output {\n        Self::new(self.re - other, self.im - other)\n    }\n}\nimpl<T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T>> Mul for Complex<T> {\n    type Output = Self;\n    fn mul(self, other: Self) -> Self::Output {\n        Self::new(\n            self.re * other.re - self.im * other.im,\n            self.re * other.im + self.im * other.re,\n        )\n    }\n}\nimpl<T: Copy + Mul<Output = T>> Mul<T> for Complex<T> {\n    type Output = Self;\n    fn mul(self, other: T) -> Self::Output {\n        Self::new(self.re * other, self.im * other)\n    }\n}\nimpl<T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Div<Output = T>> Div\n    for Complex<T>\n{\n    type Output = Self;\n    fn div(self, other: Self) -> Self::Output {\n        let d = other.re * other.re + other.im * other.im;\n        Self::new(\n            (self.re * other.re + self.im * other.im) / d,\n            (self.im * other.re - self.re * other.im) / d,\n        )\n    }\n}\nimpl<T: Copy + Div<Output = T>> Div<T> for Complex<T> {\n    type Output = Self;\n    fn div(self, other: T) -> Self::Output {\n        Self::new(self.re / other, self.im / other)\n    }\n}\nimpl<T: Neg<Output = T>> Neg for Complex<T> {\n    type Output = Self;\n    fn neg(self) -> Self::Output {\n        Self::new(-self.re, -self.im)\n    }\n}\npub type Point = Complex<f64>;\npub fn convex_hull(ps: Vec<Point>) -> Vec<Point> {\n    let mut ps = ps;\n    ps.sort_by(|p1, p2| ((p1.re, p1.im).partial_cmp(&(p2.re, p2.im)).unwrap()));\n    let mut qs = Vec::new();\n    for &p in ps.iter().chain(ps.iter().rev().skip(1)) {\n        while {\n            let k = qs.len();\n            k > 1 && ccw(qs[k - 2], qs[k - 1], p) == CCW::Clockwise\n        } {\n            qs.pop();\n        }\n        qs.push(p);\n    }\n    qs.pop();\n    qs\n}\npub fn convex_diameter(ps: Vec<Point>) -> f64 {\n    let n = ps.len();\n    let mut i = (0..n).max_by_key(|&i| TotalOrd(ps[i].re)).unwrap_or(0);\n    let mut j = (0..n).min_by_key(|&i| TotalOrd(ps[i].re)).unwrap_or(0);\n    let mut res = (ps[i] - ps[j]).norm();\n    let (maxi, maxj) = (i, j);\n    loop {\n        let (ni, nj) = ((i + 1) % n, (j + 1) % n);\n        if (ps[ni] - ps[i]).cross(ps[nj] - ps[j]) < 0. {\n            i = ni;\n        } else {\n            j = nj;\n        }\n        let d = (ps[i] - ps[j]).norm();\n        if res < d {\n            res = d;\n        }\n        if i == maxi && j == maxj {\n            break;\n        }\n    }\n    res.sqrt()\n}\n#[derive(PartialEq, PartialOrd)]\npub struct TotalOrd<T>(pub T);\nimpl<T: PartialEq> Eq for TotalOrd<T> {}\nimpl<T: PartialOrd> Ord for TotalOrd<T> {\n    fn cmp(&self, other: &TotalOrd<T>) -> std::cmp::Ordering {\n        self.0.partial_cmp(&other.0).unwrap()\n    }\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\npub enum CCW {\n    #[doc = \" a--b--c\"]\n    OnlineFront = -2,\n    #[doc = \" a--b-vc\"]\n    Clockwise = -1,\n    #[doc = \" a--c--b\"]\n    OnSegment = 0,\n    #[doc = \" a--b-^c\"]\n    CounterClockwise = 1,\n    #[doc = \" c--a--b\"]\n    OnlineBack = 2,\n}\npub fn ccw(a: Point, b: Point, c: Point) -> CCW {\n    let x = b - a;\n    let y = c - a;\n    if Real(x.cross(y)) > Real(0.) {\n        CCW::CounterClockwise\n    } else if Real(x.cross(y)) < Real(0.) {\n        CCW::Clockwise\n    } else if Real(x.dot(y)) < Real(0.) {\n        CCW::OnlineBack\n    } else if Real(x.abs()) < Real(y.abs()) {\n        CCW::OnlineFront\n    } else {\n        CCW::OnSegment\n    }\n}\npub const EPS: f64 = 1e-8;\n#[derive(Clone, Debug)]\npub struct Real(pub f64);\nimpl PartialEq for Real {\n    fn eq(&self, other: &Real) -> bool {\n        (self.0 - other.0).abs() < EPS\n    }\n}\nimpl PartialOrd for Real {\n    fn partial_cmp(&self, other: &Real) -> Option<std::cmp::Ordering> {\n        if self == other {\n            Some(std::cmp::Ordering::Equal)\n        } else {\n            self.0.partial_cmp(&other.0)\n        }\n    }\n}\nfn main() {\n    input! { n, xy: [(f64, f64); n] };\n    let ps = (0..n)\n        .map(|i| Point::new(xy[i].0, xy[i].1))\n        .collect::<Vec<_>>();\n    println!(\"{}\", convex_diameter(convex_hull(ps)));\n}\n\n"
  }
]