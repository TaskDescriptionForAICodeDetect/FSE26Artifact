[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start;\n    int end;\n    int satisfaction;\n} Date;\n\nint compare(const void *a, const void *b) {\n    Date *dateA = (Date *)a;\n    Date *dateB = (Date *)b;\n    return dateA->end - dateB->end;\n}\n\nint binarySearch(Date dates[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n    int result = -1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (dates[mid].end <= target) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n\nint maxSatisfaction(Date dates[], int n) {\n    qsort(dates, n, sizeof(Date), compare);\n    int *dp = (int *)malloc(n * sizeof(int));\n    dp[0] = dates[0].satisfaction;\n    for (int i = 1; i < n; i++) {\n        int current = dates[i].satisfaction;\n        int prev = binarySearch(dates, n, dates[i].start);\n        if (prev != -1) {\n            current += dp[prev];\n        }\n        dp[i] = (current > dp[i - 1]) ? current : dp[i - 1];\n    }\n    int result = dp[n - 1];\n    free(dp);\n    return result;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    while (datasets--) {\n        int n;\n        scanf(\"%d\", &n);\n        Date *dates = (Date *)malloc(n * sizeof(Date));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &dates[i].start, &dates[i].end, &dates[i].satisfaction);\n        }\n        printf(\"%d\\n\", maxSatisfaction(dates, n));\n        free(dates);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:25:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Date {\n    int start, end, satisfaction;\n};\n\nbool compareDates(const Date &a, const Date &b) {\n    return a.end < b.end;\n}\n\nint binarySearch(const vector<Date> &dates, int index) {\n    int low = 0, high = index - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (dates[mid].end <= dates[index].start) {\n            if (dates[mid + 1].end <= dates[index].start) {\n                low = mid + 1;\n            } else {\n                return mid;\n            }\n        } else {\n            high = mid - 1;\n        }\n    }\n    return -1;\n}\n\nint maxSatisfaction(vector<Date> &dates) {\n    sort(dates.begin(), dates.end(), compareDates);\n    int n = dates.size();\n    vector<int> dp(n, 0);\n    dp[0] = dates[0].satisfaction;\n    for (int i = 1; i < n; ++i) {\n        int current = dates[i].satisfaction;\n        int l = binarySearch(dates, i);\n        if (l != -1) {\n            current += dp[l];\n        }\n        dp[i] = max(current, dp[i - 1]);\n    }\n    return dp[n - 1];\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    while (datasets--) {\n        int n;\n        cin >> n;\n        vector<Date> dates(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> dates[i].start >> dates[i].end >> dates[i].satisfaction;\n        }\n        cout << maxSatisfaction(dates) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Date {\n    int start, end, satisfaction;\n\n    Date(int start, int end, int satisfaction) {\n        this.start = start;\n        this.end = end;\n        this.satisfaction = satisfaction;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            List<Date> dates = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int start = scanner.nextInt();\n                int end = scanner.nextInt();\n                int satisfaction = scanner.nextInt();\n                dates.add(new Date(start, end, satisfaction));\n            }\n            dates.sort(Comparator.comparingInt(a -> a.end));\n            int[] dp = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                Date current = dates.get(i - 1);\n                int low = 0, high = i - 1;\n                int lastNonOverlapping = -1;\n                while (low <= high) {\n                    int mid = (low + high) / 2;\n                    if (dates.get(mid).end <= current.start) {\n                        lastNonOverlapping = mid;\n                        low = mid + 1;\n                    } else {\n                        high = mid - 1;\n                    }\n                }\n                int include = current.satisfaction;\n                if (lastNonOverlapping != -1) {\n                    include += dp[lastNonOverlapping + 1];\n                }\n                dp[i] = Math.max(dp[i - 1], include);\n            }\n            System.out.println(dp[n]);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:26:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxSatisfaction {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int d = 0; d < datasets; d++) {\n            int n = scanner.nextInt();\n            Date[] dates = new Date[n];\n\n            for (int i = 0; i < n; i++) {\n                int start = scanner.nextInt();\n                int end = scanner.nextInt();\n                int satisfaction = scanner.nextInt();\n                dates[i] = new Date(start, end, satisfaction);\n            }\n\n            Arrays.sort(dates, (a, b) -> a.end - b.end);\n\n            int[] dp = new int[n];\n            dp[0] = dates[0].satisfaction;\n\n            for (int i = 1; i < n; i++) {\n                int satisfaction = dates[i].satisfaction;\n                int lastNonOverlap = binarySearch(dates, i);\n\n                if (lastNonOverlap != -1) {\n                    satisfaction += dp[lastNonOverlap];\n                }\n\n                dp[i] = Math.max(satisfaction, dp[i-1]);\n            }\n\n            System.out.println(dp[n-1]);\n        }\n    }\n\n    static int binarySearch(Date[] dates, int index) {\n        int low = 0, high = index - 1;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (dates[mid].end <= dates[index].start) {\n                if (dates[mid + 1].end <= dates[index].start) {\n                    low = mid + 1;\n                } else {\n                    return mid;\n                }\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return -1;\n    }\n\n    static class Date {\n        int start, end, satisfaction;\n\n        Date(int start, int end, int satisfaction) {\n            this.start = start;\n            this.end = end;\n            this.satisfaction = satisfaction;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:26:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start;\n    int end;\n    int satisfaction;\n} Date;\n\nint compareDate(const void* a, const void* b) {\n    Date* dateA = (Date*)a;\n    Date* dateB = (Date*)b;\n    return dateA->end - dateB->end;\n}\n\nint maxSatisfaction(Date* dates, int n) {\n    qsort(dates, n, sizeof(Date), compareDate);\n    \n    int* dp = malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        dp[i] = dates[i].satisfaction;\n    }\n    \n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (dates[j].end <= dates[i].start) {\n                dp[i] = fmax(dp[i], dp[j] + dates[i].satisfaction);\n            }\n        }\n    }\n    \n    int maxSat = 0;\n    for (int i = 0; i < n; i++) {\n        maxSat = fmax(maxSat, dp[i]);\n    }\n    \n    free(dp);\n    return maxSat;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    for (int d = 0; d < datasets; d++) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        Date* dates = malloc(n * sizeof(Date));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &dates[i].start, &dates[i].end, &dates[i].satisfaction);\n        }\n        \n        int result = maxSatisfaction(dates, n);\n        printf(\"%d\\n\", result);\n        \n        free(dates);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Date {\n    int start, end, satisfaction;\n};\n\nbool compareEnd(const Date& a, const Date& b) {\n    return a.end < b.end;\n}\n\nint maxSatisfaction(vector<Date>& dates) {\n    int n = dates.size();\n    sort(dates.begin(), dates.end(), compareEnd);\n    \n    vector<int> dp(n, 0);\n    dp[0] = dates[0].satisfaction;\n    \n    for (int i = 1; i < n; i++) {\n        int includeSatisfaction = dates[i].satisfaction;\n        int lastNonOverlapping = -1;\n        \n        for (int j = i - 1; j >= 0; j--) {\n            if (dates[j].end <= dates[i].start) {\n                lastNonOverlapping = j;\n                break;\n            }\n        }\n        \n        if (lastNonOverlapping != -1) {\n            includeSatisfaction += dp[lastNonOverlapping];\n        }\n        \n        dp[i] = max(includeSatisfaction, dp[i-1]);\n    }\n    \n    return dp[n-1];\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    \n    while (datasets--) {\n        int n;\n        cin >> n;\n        \n        vector<Date> dates(n);\n        for (int i = 0; i < n; i++) {\n            cin >> dates[i].start >> dates[i].end >> dates[i].satisfaction;\n        }\n        \n        cout << maxSatisfaction(dates) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def maximum_satisfaction(datasets):\n    results = []\n    for dataset in datasets:\n        n = dataset[0]\n        dates = dataset[1:]\n        \n        # Sort dates by their end times\n        dates.sort(key=lambda x: x[1])\n        \n        max_satisfaction = 0\n        last_end_time = 0\n        \n        for start, end, satisfaction in dates:\n            if start >= last_end_time:\n                max_satisfaction += satisfaction\n                last_end_time = end\n        \n        results.append(max_satisfaction)\n    \n    return results\n\n\n# Example usage:\ndatasets = [\n    (3, (1, 3, 50), (3, 5, 20), (6, 8, 30)),\n    (4, (1, 4, 10), (2, 3, 20), (3, 5, 30), (6, 9, 40))\n]\n\nprint(maximum_satisfaction(datasets))",
    "timestamp": "2025-08-13 06:24:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Main {\n\n    static class Date {\n        int start;\n        int end;\n        int satisfaction;\n        \n        public Date(int start, int end, int satisfaction) {\n            this.start = start;\n            this.end = end;\n            this.satisfaction = satisfaction;\n        }\n    }\n    \n    public static int maxSatisfaction(List<Date> dates) {\n        Collections.sort(dates, (d1, d2) -> d1.end - d2.end);\n        \n        int n = dates.size();\n        int[] dp = new int[n];\n        \n        dp[0] = dates.get(0).satisfaction;\n        \n        for (int i = 1; i < n; i++) {\n            int include = dates.get(i).satisfaction;\n            int lastNonConflict = findLastNonConflict(dates, i);\n            if (lastNonConflict != -1) {\n                include += dp[lastNonConflict];\n            }\n            dp[i] = Math.max(dp[i - 1], include);\n        }\n        \n        return dp[n - 1];\n    }\n    \n    private static int findLastNonConflict(List<Date> dates, int i) {\n        for (int j = i - 1; j >= 0; j--) {\n            if (dates.get(j).end <= dates.get(i).start) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        \n        while (datasets-- > 0) {\n            int numOfGuys = scanner.nextInt();\n            List<Date> dates = new ArrayList<>();\n            \n            for (int i = 0; i < numOfGuys; i++) {\n                int start = scanner.nextInt();\n                int end = scanner.nextInt();\n                int satisfaction = scanner.nextInt();\n                dates.add(new Date(start, end, satisfaction));\n            }\n            \n            System.out.println(maxSatisfaction(dates));\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 06:24:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start;\n    int end;\n    int satisfaction;\n} Date;\n\nint cmp(const void *a, const void *b) {\n    Date *date1 = (Date *)a;\n    Date *date2 = (Date *)b;\n    return date1->end - date2->end;\n}\n\nint maxSatisfaction(Date dates[], int n) {\n    if (n == 0) return 0;\n    \n    qsort(dates, n, sizeof(Date), cmp);\n\n    // dp[i] stores the maximum satisfaction possible using dates[0..i]\n    int *dp = (int *)malloc(n * sizeof(int));\n    dp[0] = dates[0].satisfaction;\n\n    for (int i = 1; i < n; i++) {\n        int inclSatisfaction = dates[i].satisfaction;\n        int l = -1;\n        \n        // Find the last non-conflicting date\n        for (int j = i - 1; j >= 0; j--) {\n            if (dates[j].end <= dates[i].start) {\n                l = j;\n                break;\n            }\n        }\n        \n        if (l != -1) {\n            inclSatisfaction += dp[l];\n        }\n        \n        dp[i] = inclSatisfaction > dp[i - 1] ? inclSatisfaction : dp[i - 1];\n    }\n\n    int result = dp[n - 1];\n    free(dp);\n    return result;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        Date *dates = (Date *)malloc(n * sizeof(Date));\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &dates[i].start, &dates[i].end, &dates[i].satisfaction);\n        }\n        \n        printf(\"%d\\n\", maxSatisfaction(dates, n));\n        free(dates);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 06:24:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_satisfaction(n, dates, satisfaction):\n    # Sort dates by end time\n    sorted_dates = sorted(zip(dates, satisfaction), key=lambda x: x[0][1])\n    \n    # Initialize DP table\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        current_date, current_sat = sorted_dates[i-1]\n        \n        # Find last non-overlapping date\n        j = i - 1\n        while j > 0 and sorted_dates[j-1][0][1] > current_date[0]:\n            j -= 1\n        \n        # Max satisfaction either includes or excludes current date\n        dp[i] = max(dp[i-1], dp[j] + current_sat)\n    \n    return dp[n]\n\n# Read input and process datasets\nnum_datasets = int(input())\nfor _ in range(num_datasets):\n    n = int(input())\n    dates = []\n    satisfaction = []\n    \n    for i in range(n):\n        start, end, sat = map(int, input().split())\n        dates.append((start, end))\n        satisfaction.append(sat)\n    \n    result = max_satisfaction(n, dates, satisfaction)\n    print(result)",
    "timestamp": "2025-08-13 06:24:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        n = int(input[ptr])\n        ptr += 1\n        dates = []\n        for _ in range(n):\n            s = int(input[ptr])\n            e = int(input[ptr+1])\n            v = int(input[ptr+2])\n            dates.append((s, e, v))\n            ptr += 3\n        dates.sort(key=lambda x: x[1])\n        dp = [0] * (n + 1)\n        for i in range(1, n+1):\n            s_i, e_i, v_i = dates[i-1]\n            low = 0\n            high = i - 1\n            best_j = -1\n            while low <= high:\n                mid = (low + high) // 2\n                if dates[mid][1] <= s_i:\n                    best_j = mid\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            if best_j != -1:\n                dp[i] = max(dp[i-1], dp[best_j+1] + v_i)\n            else:\n                dp[i] = max(dp[i-1], v_i)\n        print(dp[n])\n\nsolve()",
    "timestamp": "2025-08-13 06:25:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Date {\n    int start;\n    int end;\n    int satisfaction;\n};\n\nbool compareDates(const Date& a, const Date& b) {\n    return a.end < b.end;\n}\n\nint maxSatisfaction(std::vector<Date>& dates) {\n    std::sort(dates.begin(), dates.end(), compareDates);\n    int n = dates.size();\n    std::vector<int> dp(n, 0);\n    \n    dp[0] = dates[0].satisfaction;\n    \n    for (int i = 1; i < n; ++i) {\n        int inclSatisfaction = dates[i].satisfaction;\n        int l = -1;\n        \n        for (int j = i - 1; j >= 0; --j) {\n            if (dates[j].end <= dates[i].start) {\n                l = j;\n                break;\n            }\n        }\n        \n        if (l != -1) {\n            inclSatisfaction += dp[l];\n        }\n        \n        dp[i] = std::max(inclSatisfaction, dp[i - 1]);\n    }\n    \n    return dp[n - 1];\n}\n\nint main() {\n    int numDatasets;\n    std::cin >> numDatasets;\n\n    while (numDatasets--) {\n        int numDates;\n        std::cin >> numDates;\n\n        std::vector<Date> dates(numDates);\n\n        for (int i = 0; i < numDates; ++i) {\n            std::cin >> dates[i].start >> dates[i].end >> dates[i].satisfaction;\n        }\n\n        std::cout << maxSatisfaction(dates) << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:31:54"
  }
]