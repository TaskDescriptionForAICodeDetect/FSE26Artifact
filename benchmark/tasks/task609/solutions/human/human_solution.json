[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(int k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a){return Mint(v)+=a;};\n  Mint operator-(Mint a){return Mint(v)-=a;};\n  Mint operator*(Mint a){return Mint(v)*=a;};\n  Mint operator/(Mint a){return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(int n){\n    if(n+1<=(signed)fact.size()) return;\n    fact.assign(n+1,1);\n    finv.assign(n+1,1);\n    invs.assign(n+1,1);\n    \n    for(int i=1;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(int i=n;i>=1;i--) finv[i-1]=finv[i]*Mint(i);\n    for(int i=1;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(int n,int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,n);\n  }\n\n  static Mint S(int n,int k){\n    Mint res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(int n,int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n\tif(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n\telse dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(int n,int k){\n    Mint res;\n    for(int j=1;j<=k;j++) res+=S(n,j);\n    return res;\n  }\n\n  static Mint montmort(int n){\n    Mint res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    int n=y.size()-1;\n    init(n+1);\n    Mint num(1);\n    for(int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n\n//problemId=DPL_5_L\nsigned main(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",n>=k?Mint<int>::D(n,k)[n-k][k].v:0);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\n#define MK make_pair\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nvector<vector<ll>> dp(2000,vector<ll>(2000,0));\n\nvoid DP(){\n    dp[0][0]=1;\n    for(int i=0;i<2000;i++){\n        for(int t=1;t<2000;t++){\n            if(i-t>=0){\n                dp[i][t]=dp[i][t-1]+dp[i-t][t];\n                dp[i][t]%=MOD;\n            }\n            else{\n                dp[i][t]=dp[i][t-1];\n            }\n        }\n    }\n}\n\nint main(){\n    ll n,k;\n    cin>>n>>k;\n    DP();\n    if(n<k){cout<<0<<endl;}\n    else{cout<<dp[n-k][k]<<endl;}\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long int ll;\nstatic const ll MOD = 1000000007;\n\nint main(){\n\tint n, k;\n\tcin >> n >> k;\n\tvector<vector<ll> > memo(k + 1, vector<ll>(n + 1, 0));\n\tfor(int i = 0; i <= k; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tif(i == 0 && j == 0) memo[i][j] = 1;\n\t\t\telse if(i == 0) continue;\n\t\t\telse{\n\t\t\t\tif(j - i < 0) memo[i][j] = memo[i - 1][j];\n\t\t\t\telse memo[i][j] = memo[i][j - i] + memo[i - 1][j];\n\t\t\t\tmemo[i][j] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (n - k < 0 ? 0 : memo[k][n - k]) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<Int MOD = 1000000007>\nstruct Mod{\n  Int prev=0;\n  vector<Int> fact,inv,finv;\n  Mod(){}\n  Mod(Int n){init(n);}\n  \n  Int pow(Int x,Int n){\n    Int res=1;\n    while(n){\n      if(n&1) (res*=x)%=MOD;\n      (x*=x)%=MOD;\n      n>>=1;\n    }\n    return res;\n  }\n  \n  Int inverse(Int a){\n    return pow(a,MOD-2);\n  }\n  \n  void init(Int n){\n    if(prev>=n) return;\n    prev=n;\n    fact=inv=finv=vector<Int>(n);\n    \n    fact[0]=1;\n    for(Int i=1;i<n;i++)\n      fact[i]=(fact[i-1]*i)%MOD;\n    \n    inv[1]=1;\n    for(Int i=2;i<n;i++)\n      inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    \n    finv[0]=1;\n    for(Int i=1;i<n;i++)\n      finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n  \n  Int comb(Int n,Int k){\n    Int res=1;\n    for(Int i=0;i<k;i++){\n      res*=(n-i)%MOD;\n      res%=MOD;\n      res*=inverse(i+1);\n      res%=MOD;\n    }\n    return res;\n  }\n  \n  //only for prime MOD\n  Int C(Int n,Int k){\n    if(k<0||k>n) return 0;\n    return fact[n]*finv[k]%MOD*finv[n-k]%MOD;\n  }\n\n  Int H(Int n,Int k){\n    return C(n+k-1,n);\n  }\n\n  Int S(Int n,Int k){\n    Int res=0;\n    for(Int i=1;i<=k;i++){\n      Int tmp=C(k,i)*pow(i,n)%MOD;\n      if((k-i)&1) res+=MOD-tmp;\n      else res+=tmp;\n      res%=MOD;\n    }\n    res=res*finv[k]%MOD;\n    return res;\n  }\n  \n  Int B(Int n,Int k){\n    Int res=0;\n    for(Int j=1;j<=k;j++){\n      res+=S(n,j);\n      res%=MOD;\n    }\n    return res;\n  }\n\n  \n  vector<vector<Int> > D(Int n,Int m){\n    vector<vector<Int> > dp(n+1,vector<Int>(m+1,0));\n    dp[0][0]=1;\n    for(Int i=0;i<=n;i++){\n      for(Int j=1;j<=m;j++){\n\tif(i-j>=0) dp[i][j]=(dp[i][j-1]+dp[i-j][j])%MOD;\n\telse dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n  \n  Int montmort(Int n){\n    Int res=0,rinv=1;\n    for(Int k=2;k<=n;k++){\n      rinv=rinv*inverse(k)%MOD;\n      if(k%2) res+MOD-rinv;\n      else res+=rinv;\n      res%=MOD;\n    }\n    for(Int i=1;i<=n;i++) res=res*i%MOD;\n    return res;\n  }\n  \n  // calculate P(t) from given points in [0,N]\n  Int LagrangePolynomial(vector<Int> &y,Int t){\n    Int n=y.size()-1;\n    init(n+1);\n    Int num=1;\n    for(Int i=0;i<=n;i++)\n      num=num*((t-i)%MOD)%MOD;\n    Int res=0;\n    for(Int i=0;i<=n;i++){\n      Int tmp=(y[i]*num%MOD)*inverse((t-i)%MOD)%MOD;\n      tmp=tmp*finv[i]%MOD;\n      tmp=tmp*finv[n-i]%MOD;\n      if((n-i)&1) tmp=MOD-tmp;\n      res=(res+tmp)%MOD;\n    }\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  const Int MOD = 1e9+7;\n  Mod<MOD> mod(2e5);\n  Int n,k;\n  cin>>n>>k;\n  cout<<(n>=k?mod.D(n,k)[n-k][k]:0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long int ll;\nconst ll MOD=1000000007;\n\nll n,k;\nll dp[1001][1001]={};\n\nint main(){\n\tscanf(\"%lld %lld\",&n,&k);\n\tif(n<k) printf(\"0\\n\");\n\telse{\n\t\tdp[0][0]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=k;j++){\n\t\t\t\tdp[i][j]+=dp[i-1][j-1];\n\t\t\t\tif(i>=j)\n\t\t\t\tdp[i][j]+=dp[i-j][j];\n\t\t\t\tdp[i][j]%=MOD;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",dp[n][k]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n \n \n// 素数 p で割ったあまりに関する構造体 (特に p = 1000000007 とすることが多い)\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n \n \n \n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n \n \n// 分割数\ntemplate<class T> struct Partition {\n    vector<vector<T> > P;\n    constexpr Partition(int MAX) noexcept : P(MAX, vector<T>(MAX, 0)) {\n        for (int k = 0; k < MAX; ++k) P[0][k] = 1;\n        for (int n = 1; n < MAX; ++n) {\n            for (int k = 1; k < MAX; ++k) {\n                P[n][k] = P[n][k-1] + (n-k >= 0 ? P[n-k][k] : 0);\n            }\n        }\n    }\n    constexpr T get(int n, int k) {\n        if (n < 0 || k < 0) return 0;\n        return P[n][k];\n    }\n};\n \nint main() {\n    using mint = Fp<1000000007>;\n    Partition<mint> pt(3100);\n    int n, k; cin >> n >> k;\n    cout << pt.get(n-k, k) << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define repp(i, n) rep(i, n)\n#define reppp(i, n) repp(i, n)\n#define rrepp(i, n) rrep(i, n)\n#define repss(i, n) reps(i, n)\n#define repcc(i, n) repc(i, n)\n#define repii(i, a, b) repi(i, a, b)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n\nusing namespace std;\n\nusing i32 = int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline u64 xorshift() { static u64 x = 88172645463325252ull; x = x ^ (x << 7); return x = x ^ (x >> 9); }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\ntemplate <typename T, typename S> istream& operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\ntemplate <typename T, typename S> ostream& operator<<(ostream &os, pair<T, S> &p) { os << p.first << ' ' << p.second; return os; }\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n  ModInt(): x(0) {}\n  ModInt(i64 a) { x = a % mod; if (x < 0) x += mod; }\n  ModInt &operator+=(ModInt that) { x = (x + that.x) % mod; return *this; }\n  ModInt &operator-=(ModInt that) { x = (x + mod - that.x) % mod; return *this; }\n  ModInt &operator*=(ModInt that) { x = (i64) x * that.x % mod; return *this; }\n  ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n  ModInt operator-() { return ModInt(-this->x); }\n  friend ostream& operator<<(ostream &os, ModInt m) { return os << m.x; }\n  ModInt inverse() {\n    int a = x, b = mod, u = 1, v = 0;\n    while (b) { int t = a / b; a -= t * b; u -= t * v; swap(a, b); swap(u, v); }\n    return ModInt(u);\n  }\n  #define op(o, p) ModInt operator o(ModInt that) { return ModInt(*this) p that; }\n    op(+, +=) op(-, -=) op(*, *=) op(/, /=)\n  #undef op\n  #define op(o) bool operator o(ModInt that) const { return x o that.x; }\n    op(==) op(!=) op(<) op(<=) op(>) op(>=)\n  #undef op\n};\n\nusing mint = ModInt<1000000007>;\n\nmint dp[1010][1010];\nbool fl[1010][1010];\nmint P(int n, int k) {\n  if (n < 0) return 0;\n  if (fl[n][k]) return dp[n][k];\n  fl[n][k] = true;\n  mint ret = 0;\n  if (n == 0 && k == 0) ret = 1;\n  else if (k == 0) ret = 0;\n  else if (n == 0) ret = 1;\n  else ret = P(n, k - 1) + P(n - k, k);\n  return dp[n][k] = ret;\n}\n\nvoid solve() {\n  int n, k; cin >> n >> k;\n  cout << P(n - k, k) << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \nll m=1e9+7;\nll dp[1002][1002];\n\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  n-=k;\n  dp[0][0]=1;\n  for(int i=0;i<=n;i++)\n    for(int j=0;j<=k;j++){\n      if(j)dp[i][j]+=dp[i][j-1];\n      if((i||j)&&i-j>=0)dp[i][j]+=dp[i-j][j];\n      dp[i][j]%=m;\n    }\n  \n  cout<<dp[n][k]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconstexpr long long MOD = 1'000'000'007;\n\nclass binomial_coefficients {\n\tlong long MAX_VAL;\n\tvector<long long> fac, mmi;\n\npublic:\n\n\tbinomial_coefficients(){\n\t}\n\t\n\tbinomial_coefficients(long long num){\n\t\tinit(num);\n\t}\n\t\n\t~binomial_coefficients(){\n\t\t\n\t}\n\t\n\tvoid init(long long num){\n\t\tMAX_VAL = num+1; \n\t\tfac.resize(MAX_VAL);\n\t\tmmi.resize(MAX_VAL);\n\t\t\n\t\tfactorial_mod();\n\t\tmodular_multiplicatibe_inverse();\n\t}\n\t\n\tvoid factorial_mod(){\n\t\t fac[0] = 1;\n\t\tfor(long long i = 1; i < MAX_VAL; fac[i] %= MOD, i++)\n\t\t\tfac[i] = fac[i - 1] * (i % MOD);\n\t}\n\t\n\tlong long power(long long x, long long n){\n\t\tlong long ans = 1;\n\t\tfor(;n;n >>= 1, x *= x, ans %= MOD, x %= MOD)\n\t\t\tif(n&1)ans*=x;\n\t\treturn ans % MOD;\n\t}\n\t\n\tvoid exgcd(long long a, long long b, long long &x, long long &y){\n\t\tif(b == 0){\n\t\t\tx = 1;\n\t\t\ty = 0;\n\t\t\treturn ;\n\t\t}\n\t\texgcd(b, a % b, y, x);\n\t\ty -= a / b * x;\n\t}\n\t\n\tvoid modular_multiplicatibe_inverse(){\n\t\tlong long x, y;  \n\t\texgcd(fac[MAX_VAL - 1], MOD, x, y);\n\t\tmmi[MAX_VAL-1] = (x % MOD + MOD) % MOD;\n\t\t// mmi[MAX_VAL-1] = power(fac[MAX_VAL-1], MOD-2);\n\t\tfor(long long i = MAX_VAL - 2; i >= 0; mmi[i]%=MOD, i--)\n\t\t\tmmi[i] = mmi[i + 1] * ((i + 1) % MOD);\n\t}\n\t\n\tlong long combination(long long n, long long r){\n\t\treturn r < 0 ? 0 :n < r ? 0 :fac[n] * (mmi[r] * mmi[n-r] % MOD) % MOD;\n\t}\n};\n\n\nint main(){\n\t\n\tlong long n, k;\n\tlong long ans = 0;\n\tbinomial_coefficients bc;\n\tvector<vector<long long>> dp;\n\t\n\tcin>>n>>k;\n\t\n\tbc.init(n+k);\n\tdp.resize(k+1, vector<long long>(n+2));\n\t\n\t\n\tdp[0][0] = 1;\n\t\n\tfor(int i = 1; i <= k; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\tif(j >= i) dp[i][j] += dp[i][j-i];\n\t\t\tdp[i][j] %= MOD;\n\t\t}\n\t}\n\t\n\tif(n >= k)ans = dp[k][n-k];\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Approach: count the number of size-k partitions of the integer n\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int N, K;\n  cin >> N >> K;\n  vector<vector<int>> P(2, vector<int>(N + 1));\n  P[0][0] = 1;\n  for (int k = 1; k <= K; ++k) {\n    for (int i = 0; i <= N; ++i) {\n      if (i < k)\n        P[k % 2][i] = 0;\n      else\n        P[k % 2][i] = (P[!(k % 2)][i - 1] + P[k % 2][i - k]) % 1000000007;\n    }\n  }\n  cout << P[K % 2][N] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define NUM 1001\n\nll N,K;\nll dp[NUM][NUM];\n\nll recursive(ll num_ball,ll num_box){\n\n\tif(dp[num_ball][num_box] != -1)return dp[num_ball][num_box];\n\n\tif(num_ball == 0 || num_box == 1)return 1;\n\n\tll ret = 0;\n\n\tfor(ll next_box = 1; next_box <= num_box; next_box++){\n\t\tif(next_box > num_ball)break;\n\t\tret += recursive(num_ball-next_box,next_box);\n\t\tret %= MOD;\n\t}\n\n\treturn dp[num_ball][num_box] = ret;\n}\n\nint main(){\n\n\tscanf(\"%lld %lld\",&N,&K);\n\n\tif(N < K){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tN -= K;\n\n\tfor(ll i = 0; i <= N; i++){\n\t\tfor(ll p = 0; p <= K; p++){\n\t\t\tdp[i][p] = -1;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(N,K));\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nlong long int DP[1100][1100] = {};\n\nint main(){\n\t\n\tlong long int n, k;\n\tcin >> n >> k;\n\t\n\tif(n < k){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tn -= k;\n\t\n\tDP[0][0] = 1;\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 1; j <= k; j++){\n\t\t\tDP[i][j] = DP[i][j - 1];\n\t\t\tif(i >= j){\n\t\t\t\tDP[i][j] += DP[i - j][j];\n\t\t\t}\n\t\t\tDP[i][j] %= MOD;\n\t\t}\n\t}\n\t\n\tcout << DP[n][k] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define PRINT(x)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl;\n#define PRINTA(a,first,last)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#a<<\"[\"<<(first)<<\", \"<<(last)<<\")\"<<endl;\\\n    for (int _i=(first);_i<(last);++_i){cout<<#a<<\"[\"<<_i<<\"] = \"<<(a)[_i]<<endl;}\n#define PRINTP(p)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#p<<\" = (\"<<(p.first)<<\", \"<<(p.second)<<\")\"<<endl;\n#define PRINTI(a,i)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#a<<\"[\"<<#i<<\"] = \"<<#a<<\"[\"<<(i)<<\"] = \"<<(a)[i]<<endl;\n#else\n#define PRINT(x)\n#define PRINTA(a,first,last)\n#define PRINTP(p)\n#define PRINTI(a,i)\n#endif\n\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);--i)\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define MOD 1000000007\n\nusing namespace std;\n\nusing ull = unsigned long long;\n\ntemplate <class T, T M>\nclass modulo {\npublic:\n    T data;\n\n    modulo(T data = 0) : data(data % M) {\n    }\n\n    modulo operator+(const modulo &x) const {\n        return modulo(data + x.data);\n    }\n\n    modulo operator-(const modulo &x) const {\n        return modulo(data + (M - x.data));\n    }\n\n    modulo operator*(const modulo &x) const {\n        return modulo(data * x.data);\n    }\n\n    modulo operator/(const modulo &x) const {\n        return modulo(data * x.inv().data);\n    }\n\n    modulo operator+=(const modulo &x) {\n        return data = (data + x.data) % M;\n    }\n\n    modulo operator-=(const modulo &x) {\n        return data = (data + (M - x.data)) % M;\n    }\n\n    modulo operator*=(const modulo &x) {\n        return data = (data * x.data) % M;\n    }\n\n    modulo operator/=(const modulo &x) {\n        return data = (data * x.inv().data) % M;\n    }\n\n    modulo inv() const {\n        return _pow(M - 2);\n    }\n\n    template <class Integer>\n    modulo operator^(Integer n) const {\n        if (n >= 0) {\n            return _pow(n);\n        } else {\n            return _pow(M - 1 - (-n) % (M - 1));\n        }\n    }\n\n    friend std::ostream& operator<<(std::ostream &os, const modulo &x) {\n        os << x.data;\n        return os;\n    }\n\nprivate:\n    template <class NonNegativeInteger>\n    modulo _pow(NonNegativeInteger n) const {\n        modulo result(1);\n        modulo x(*this);\n        while (n) {\n            if (n & 1) {\n                result *= x;\n            }\n            x *= x;\n            n >>= 1;\n        }\n        return result;\n    }\n};\n\ntemplate <class T, T M>\nstruct combinatorics {\n\n    using Mod = modulo<T, M>;\n\n    T N;\n    std::vector<Mod> factorial;\n    std::vector<Mod> inv_factorial;\n\n    combinatorics(T N) : N(N), factorial(N + 1), inv_factorial(N + 1) {\n        factorial[0] = 1;\n        for (T i = 1; i <= N; ++i) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n        inv_factorial[N] = factorial[N].inv();\n        for (T i = N; i >= 1; --i) {\n            inv_factorial[i - 1] = inv_factorial[i] * i;\n        }\n    }\n\n    Mod P(T n, T k) {\n        if (0 <= k && k <= n) {\n            return factorial[n] * inv_factorial[k];\n        } else {\n            return 0;\n        }\n    }\n\n    Mod C(T n, T k) {\n        if (0 <= k && k <= n) {\n            return factorial[n] * inv_factorial[k] * inv_factorial[n - k];\n        } else if (n == -1 && k == 0) { // conventinal\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    Mod H(T n, T k) {\n        if (n == 0 && k == 0) {\n            return 1;\n        } else {\n            return C(n + k - 1, k);\n        }\n    }\n};\n\nenum map_condition {\n    NONE,\n    INJECTIVE,\n    SURJECTIVE,\n};\n\nusing Mod = modulo<ull, MOD>;\n\nMod twelvefold(ull n, ull m, map_condition condition, bool up_to_permutation_of_n, bool up_to_permutation_of_m) {\n    if (!up_to_permutation_of_n && !up_to_permutation_of_m) {\n        if (condition == NONE) {\n            // O(log(n))\n            return Mod(m) ^ n;\n        } else if (condition == INJECTIVE) {\n            // pre O(m)\n            // O(1)\n            combinatorics<ull, MOD> c(m);\n            return c.P(m, m - n);\n        } else if (condition == SURJECTIVE) {\n        }\n    } else if (up_to_permutation_of_n && !up_to_permutation_of_m) {\n        if (condition == NONE) {\n            // pre O(n + m)\n            // O(1)\n            // Note that if n == 0 and m == 0 then C(-1, 0) == 1.\n            combinatorics<ull, MOD> c(n + m - 1);\n            return c.C(n + m - 1, n); // H(m, n)\n        } else if (condition == INJECTIVE) {\n            // pre O(m)\n            // O(1)\n            combinatorics<ull, MOD> c(m);\n            return c.C(m, n);\n        } else if (condition == SURJECTIVE) {\n            // pre O(n)\n            // O(1)\n            // Note that if n == 0 and m == 0 then C(-1, 0) == 1.\n            combinatorics<ull, MOD> c(n - 1);\n            return c.C(n - 1, n - m);\n        }\n    } else if (!up_to_permutation_of_n && up_to_permutation_of_m) {\n        if (condition == NONE) {\n\n        } else if (condition == INJECTIVE) {\n            return n <= m;\n        } else if (condition == SURJECTIVE) {\n        }\n    } else if (up_to_permutation_of_n && up_to_permutation_of_m) {\n        if (condition == NONE) {\n            // pre O(n * min(n, m))\n            // O(1)\n            vector<vector<Mod>> p(n + 1);\n            p[0] = {1};\n            for (ull i = 1; i <= n; ++i) {\n                p[i].resize(i + 1);\n                for (ull j = 1; j <= min(i, m); ++j) {\n                    p[i][j] = p[i - j][min(j, i - j)] + p[i][j - 1];\n                }\n            }\n            return p[n][min(m, n)];\n        } else if (condition == INJECTIVE) {\n            return n <= m;\n        } else if (condition == SURJECTIVE) {\n            if (n >= m) {\n                return twelvefold(n - m, m, NONE, true, true);\n            } else {\n                return 0;\n            }\n        }\n    }\n    assert(0);\n}\n\nint main() {\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ull n, m;\n    cin >> n >> m;\n    cout << twelvefold(n, m, SURJECTIVE, true, true) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconstexpr int64 P = 1000000007;\n\n// Verified: ABC133E, ABC132D, ABC130E\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {}\n  FiniteField() : x(0) {}\n  int64 Value() { return x; }\n  inline FiniteField operator+(FiniteField o) {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nvector<FiniteField> MakeFactorialTable(int n) {\n  vector<FiniteField> values(n + 1);\n  values[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    values[i] = values[i - 1] * i;\n  }\n  return values;\n}\n\nvector<vector<FiniteField>> MakePartitionNumberTable(int n, int k) {\n  vector<vector<FiniteField>> table(n + 1, vector<FiniteField>(k + 1));\n  for (int i = 0; i <= n; i++) {\n    table[i][1] = 1;\n    for (int j = 2; j <= k; j++) {\n      table[i][j] = table[i][j - 1];\n      if (i - j >= 0) table[i][j] += table[i - j][j];\n    }\n  }\n  return table;\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, k;\n  cin >> n >> k;\n\n  if (n < k) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  auto p_table = MakePartitionNumberTable(n - k, k);\n  cout << p_table[n - k][k].Value() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntemplate <typename NumType, int LIMIT = 2000010>\nstruct Combination {\n    vector<NumType> fact_, finv_;\n\n    Combination() : fact_(LIMIT+1), finv_(LIMIT+1) {\n        fact_[0] = finv_[LIMIT] = NumType(1);\n        for(int i=1; i<=LIMIT; i++) {\n            fact_[i] = fact_[i-1] * NumType(i);\n        }\n        \n        finv_[LIMIT] /= fact_[LIMIT];\n        for(int i=LIMIT-1; i>=0; i--) {\n            finv_[i] = finv_[i+1] * NumType(i+1);\n        }\n    }\n\n    inline NumType fact(int k) const { return fact_[k]; }\n    inline NumType finv(int k) const { return finv_[k]; }\n    NumType P(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r];\n    }\n    NumType C(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r] * finv_[r];\n    }\n    // 重複組み合わせ\n    NumType H(int n, int r) const {\n        if(n < 0 or r < 0) return NumType(0);\n        return r == 0 ? NumType(0) : C(n + r - 1, r);\n    }\n    // ベル数 (区別できる n 個のボールを区別できない k 個以下の箱に分割)\n    // B(n, n) := n 個のボールを任意個のグループに分割する場合の数\n    NumType B(int n, int k) const {\n        if(n == 0) return NumType(1);\n        k = min(n, k);\n        NumType ret(0);\n        vector<NumType> pref(k + 1); pref[0] = NumType(1);\n        for(int i=1; i<=k; i++) {\n            if(i & 1) pref[i] = pref[i-1] - finv_[i];\n            else pref[i] = pref[i-1] + finv_[i];\n        }\n        for(int i=1; i<=k; i++) {\n            // 累乗が必要なので適宜書き換える？\n            // ModInt 使うならこれでいい\n            ret += NumType(i).pow(n) * finv_[i] * pref[k-i];\n        }\n        return ret;\n    }\n    // スターリング数 (区別できる n 個のボールを区別できない k 個の箱に分割)\n    NumType S(int n, int k) const {\n        if(n < k) return NumType(0);\n        NumType ans(0);\n        for(int i=0; i<=k; i++) {\n            NumType val = C(k, i) * NumType(i).pow(n);\n            if((k - i) % 2) ans -= val;\n            else ans += val;\n        }\n        return ans * finv_[k];\n    }\n};\n\n// P(n, k) := n の k 分割 (k 個の 0 以上の整数の和)\ntemplate <typename NumType, int LIMIT = 3010>\nstruct Partition {\n    vector< vector<NumType> > dp;\n    Partition() : dp(LIMIT, vector<NumType>(LIMIT)) {\n        for(int k=0; k<LIMIT; k++) dp[0][k] = NumType(1);\n        for(int i=1; i<LIMIT; i++) {\n            for(int j=1; j<LIMIT; j++) {\n                dp[i][j] += dp[i][j-1];\n                if(i-j >= 0) dp[i][j] += dp[i-j][j];\n            }\n        }\n    }\n    inline NumType get(int n, int k) {\n        if(n < 0 or k < 0) return NumType(0);\n        return dp[n][k];\n    }\n};\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v() {\n        if(a >= mod) v = a % mod;\n        else if(a < 0) v = mod - (-a % mod);\n        else v = a;\n    }\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    operator int() const { return int(v); }\n    operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod> a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\nusing mint = ModInt<1000000007>;\n\nvoid DPL_5_A() {\n    int N, K; cin >> N >> K;\n    mint ans(K);\n    cout << ans.pow(N) << endl;\n}\n\nvoid DPL_5_B() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.P(K, N) << endl;\n}\n\nvoid DPL_5_C() {\n    int N, K; cin >> N >> K;\n\n    Combination<mint> comb;\n    mint ans = comb.S(N, K) * comb.fact(K);\n    cout << ans << endl;\n}\n\nvoid DPL_5_D() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.H(K, N) << endl;\n}\n\nvoid DPL_5_E() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.C(K, N) << endl;\n}\n\nvoid DPL_5_F() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.C(N-1, K-1) << endl;\n}\n\nvoid DPL_5_G() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.B(N, K) << endl;\n}\n\nvoid DPL_5_I() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.S(N, K) << endl;\n}\n\nvoid DPL_5_J() {\n    int N, K; cin >> N >> K;\n    Partition<mint> part;\n    cout << part.get(N, K) << endl;\n}\n\nvoid DPL_5_L() {\n    int N, K; cin >> N >> K;\n    Partition<mint> part;\n    cout << part.get(N-K, K) << endl;\n}\n\nint main() {\n    // DPL_5_A();\n    // DPL_5_B();\n    // DPL_5_C();\n    // DPL_5_D();\n    // DPL_5_E();\n    // DPL_5_F();\n    // DPL_5_G();\n    // DPL_5_I();\n    // DPL_5_J();\n    DPL_5_L();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\nconstexpr i64 MOD = 1e9 + 7;\n\ni64 partition_count(int n, int m, i64 mod) {\n    if (n < 0) return 0;\n    // divide n (undistinguished) items into m (undistinguished) groups, groups can have 0 items\n    vvi dp(m + 1, vi(n + 1));\n    dp[0][0] = 1;\n    for (int i = 1; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - i]) % mod;\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[m][n];\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    cout << partition_count(n - k, k, MOD) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define lint long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e,v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\nconst int MAXN = 1010;\nconst int MAXK = 1010;\nlong long P[MAXN][MAXK];\n\n// 分割数 (n: 玉の数, k: 箱の数)\n// 前処理時間 O(nk)\n// クエリ時間 O(1)\nvoid calcPartition(int n, int k) {\n    P[0][0] = 1;\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 1; j <= k; ++j) {\n            P[i][j] = P[i][j - 1];\n            if (i - j >= 0)\n                P[i][j] = (P[i][j] + P[i - j][j]) % MOD;\n        }\n    }\n}\n\nvoid _main() {\n    int n, k;\n    cin >> n >> k;\n    if (n - k < 0) {\n        cout << 0 << endl;\n        return;\n    }\n    calcPartition(n, k);\n    cout << P[n - k][k] << endl;\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    }\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100001,INF=1<<30;\n\nll rui(ll a,ll b){\n    if(b==1) return a%mod;\n    else if(b==0) return 1;\n    else if(b%2==0) return (rui(a,b/2)*rui(a,b/2))%mod;\n    else return (rui(a,b-1)*a)%mod;\n}\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n\n    int N,K;cin>>N>>K;\n    make();\n    ll dp[N+1][K+1];\n    for(int i=0;i<N+1;i++){\n        for(int j=0;j<K+1;j++){\n            dp[i][j]=0;\n        }\n    }\n    for(int j=0;j<K+1;j++){\n        dp[0][j]=1;\n    }\n    \n    dp[1][1]=1;\n    for(int i=1;i<=N;i++){\n        for(int j=1;j<=K;j++){\n            if(i==1&&j==1) continue;\n            if(i-j<0) dp[i][j]=dp[i][j-1];\n            else dp[i][j]=(dp[i][j-1]+dp[i-j][j])%mod;\n        }\n    }\n    if(N<K) cout<<0<<endl;\n    else cout<<dp[N-K][K]<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n\n    mint &operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n\n    mint &operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n};\n\nstruct combination {\n    vector<mint> fact, ifact;\n\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n\n    mint nPk(int n, int k) {\n        if (n < k) return 0;\n        if (n < 0 || k < 0) return 0;\n        return fact[n] * ifact[n - k];\n    }\n\n} combination(10000);\n\n\nmint bell_number(int n, int k) {\n    vector<mint> seg_right(k + 1);\n    seg_right[0] = 1;\n    for (int i = 1; i <= k; i++) {\n        mint sign = i % 2 == 0 ? 1 : -1;\n        seg_right[i] = sign * combination.ifact[i];\n    }\n\n    for (int i = 1; i < k; i++) {\n        seg_right[i] = seg_right[i] + seg_right[i - 1];\n    }\n\n    mint ans = 0;\n    for (int i = 0; i <= k; i++) {\n        mint bunshi = mint(i).pow(n);\n        mint bunbo = combination.ifact[i];\n        mint in_segma = seg_right[k - i];\n\n        mint now = bunshi * bunbo * in_segma;\n        ans += now;\n    }\n    return ans;\n}\n\nstruct PartitionFunction {\n    vector<vector<mint>> dp;\n\n    PartitionFunction(int n, int k) : dp(k + 1, vector<mint>(n + 1)) {\n        dp[0][0] = 1;\n        for (int i = 1; i <= k; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i <= j) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - i];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n    }\n\n\n};\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    if (n < k) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    PartitionFunction pf(n, k);\n\n    cout << pf.dp[k][n - k].x << endl;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MOD 1000000007;\n#define MAX_N 1010\n#define MAX_K 1010\n\n/*\n    Ball and Boxes 12\n*/\n\nll p[MAX_N][MAX_K];\n\nint main() {\n    ll n, k;\n    cin >> n >> k;\n\n    srep(i,0,n+1){\n        srep(j,1,k+1){\n            if(i <= 1 || j == 1){\n                p[i][j] = 1;\n            }else if(i < j){\n                p[i][j] = p[i][j-1];\n            }else{\n                p[i][j] = p[i][j-1] + p[i-j][j];\n            }\n            p[i][j] %= MOD;\n        }\n    }\n\n    if(n < k){\n        cout << '0' << endl;\n        return 0;\n    }\n\n    cout << p[n-k][k] << endl;\n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// a quote from http://www.igaris.com/math/c.pdf\n\n#define MOD (1000000000+7)\n\nlong long C[1001][1001];\n\nlong long power( long long x, int n )\n{\n\tif( n == 0 ) {\n\t\treturn 1;\n\t}\n\tif( n % 2 ) {\n\t\treturn x * power( x, n - 1 ) % MOD;\n\t}\n\telse {\n\t\treturn power( x * x % MOD, n / 2 );\n\t}\n}\n\nlong long ifac( long long x )\n{\n\tlong long f = 1;\n\twhile( x > 1 ) {\n\t\tf *= power( x, MOD - 2 );\n\t\tf %= MOD;\n\t\tx--;\n\t}\n\treturn f;\n}\n\nlong long part_num( long long n, int k )\n{\n\tif( n == 1 || k == 1) {\n\t\treturn 1;\n\t}\n\tif( n < 0 || k < 1 ) {\n\t\treturn 0;\n\t}\n\tif( C[n][k] ) {\n\t\treturn C[n][k];\n\t}\n\tlong long res = ( part_num( n - k, k ) + part_num( n, k - 1 ) ) % MOD;\n\tC[n][k] = res;\n\treturn res;\n}\n\nint main()\n{\n\tint n, k;\n\tcin >> n >> k;\n\n/*\n\t// Pascal's triangle for combination\n\tC[0][0] = 1;\n\tfor( int i = 1; i < 1001; i++ ) {\n\t\tfor( int j = 0; j <= i; j++ ) {\n\t\t\tif( j == 0 || j == i ) {\n\t\t\t\tC[i][j] = C[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tC[i][j] = ( C[i - 1][j - 1] + C[i - 1][j] ) % MOD;\n\t\t\t}\n\t\t}\n\t}\n*/\n\n\tlong long ans = 0;\n\tif( n >= k ) {\n\t\tans = part_num( n - k, k );\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nconst ll MOD = 1000000007LL;\n\n// 分割数は、写像12相のうち以下に相当する\n//  ・玉の区別をしない\n//  ・箱の区別をしない\n//  ・箱に入る玉の数に制限はない\n// cf: http://drken1215.hatenablog.com/entry/2018/01/16/222843\n\n// 定義\n//  P(n,k): 区別のないn個の玉を、区別のないk個の箱に、中身が0個以上になるように分ける方法\n//  Q(n,k): 区別のないn個の玉を、区別のないk個の箱に、中身が1個以上になるように分ける方法\n\n// PとQの関係\n//  Q(n,k) = P(n-k,k)\n\n// Pの初期化\n//  P(0,?) = P(?,1) = 1\n\n// Pの漸化式\n//  P(n,k) = P(n,k-1) + P(n-k,k)  if n >= k > 1\n//  P(n,k) = P(n,n)               if n < m\n\n// Qの初期化\n//  Q(?,1) = Q(?,?) = 1\n\n// Qの漸化式\n//  Q(n,k) = Q(n-1,k-1) + Q(n-k,k)  if n >= k >= 2\n\n\nclass PartitionNumber {\n    vector <vector<ll>> P, Q;\n\n    void initP(int N) {\n        for (int k = 0; k <= N; k++) P[0][k] = P[k][1] = 1;\n        for (int n = 1; n <= N; n++) {\n            for (int k = 2; k <= n; k++) P[n][k] = (P[n][k - 1] + P[n - k][k]) % MOD;\n            for (int k = n + 1; k <= N; k++) P[n][k] = P[n][n];\n        }\n    }\n\n    void initQ(int N) {\n        for (int n = 0; n <= N; n++) Q[n][1] = Q[n][n] = 1;\n        for (int n = 2; n <= N; n++) {\n            for (int k = 2; k <= n; k++) Q[n][k] = (Q[n - 1][k - 1] + Q[n - k][k]) % MOD;\n        }\n    }\n\npublic:\n    PartitionNumber(int N) {\n        P.assign(N+1, vector<ll>(N + 1, 0));\n        Q.assign(N+1, vector<ll>(N + 1, 0));\n        initP(N);\n        initQ(N);\n    }\n\n    ll p(int n, int k) { return P[n][k]; }\n\n    ll q(int n, int k) { return Q[n][k]; }\n};\n\n\n// verified\n//   https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_J\nvoid AOJ_DPL_5_J() {\n    int n, k;\n    cin >> n >> k;\n    PartitionNumber pn(1000);\n    cout << pn.p(n, k) << \"\\n\";\n}\n\n\n// verified\n//   https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_L\nvoid AOJ_DPL_5_L() {\n    int n, k;\n    cin >> n >> k;\n    PartitionNumber pn(1000);\n    cout << pn.q(n, k) << \"\\n\";\n}\n\n\n// verified\n//   https://yukicoder.me/problems/no/269\nvoid yuki269() {\n    int N, S, K;\n    cin >> N >> S >> K;\n    S -= K * N * (N - 1) / 2;\n    if (S < 0) cout << 0 << '\\n';\n    else {\n        PartitionNumber pn(S);\n        cout << pn.p(S, N) << \"\\n\";\n    }\n}\n\nint main() {\n    // AOJ_DPL_5_J();\n    AOJ_DPL_5_L();\n    //yuki269();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X)\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto x:v)cerr<<x<<' ';cerr<<endl;\n#define INF 1000000007\n#define LINF 1000000000000000007\n#define EPS 1e-9\ntypedef long long ll;\n\nlong long DPTwelvefoldWay12[1010][1010];\nlong long TwelvefoldWay12(long long n,long long k,long long MOD){\n  if(n < k)return 0;\n  n -= k;\n  DPTwelvefoldWay12[0][0] = 1;\n  for(long long i = 0;i < n+1;i++){\n    for(long long j = 1;j < k+1;j++){\n      DPTwelvefoldWay12[i][j] = DPTwelvefoldWay12[i][j-1];\n      if(i >= j){\n        DPTwelvefoldWay12[i][j] += DPTwelvefoldWay12[i-j][j];\n        DPTwelvefoldWay12[i][j] %= MOD;\n      }\n    }\n  }\n  return DPTwelvefoldWay12[n][k];\n}\n\nsigned main(){\n  ll n,k;\n  cin >> n >> k;\n  cout << TwelvefoldWay12(n,k,INF) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b){ if(a<b){ a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b){ if(a>b){ a=b; return 1; } return 0; }\n\nconst int mod=1e9+7;\n\nsigned main()\n{   \n    int N,K; cin>>N>>K;\n\n    if(N<K) cout<<0<<endl;\n    else{\n        N=N-K;\n        vector<vector<int> > P(N+1,vector<int>(K+1));\n        for(int j=0;j<=K;j++) P[0][j]=1;\n        \n        for(int i=1;i<=N;i++){\n            for(int j=1;j<=K;j++){\n                if(i-j>=0){\n                    P[i][j]=(P[i][j-1]+P[i-j][j])%mod;\n                }else{\n                    P[i][j]=P[i][j-1];\n                }\n            }\n        }\n        cout<<P[N][K]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nconst ll mo = 1000000007;\nauto modmul = [](auto... modx) {\n  ll res = 1;\n  for (auto modx_ : {modx...})\n  {\n    res *= modx_;\n    res %= mo;\n    res += mo;\n    res %= mo;\n  }\n  return res;\n};\nll mypow(ll a, ll b)\n{\n  ll res = 1;\n  a %= mo;\n  while (b)\n  {\n    if (b & 1)\n      res = res * a % mo;\n    a = a * a % mo;\n    b >>= 1;\n  }\n  return res;\n}\nconst ll MAX = 510000;\nconst ll MOD = 1000000007;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\nlong long COM(ll n, ll k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nvector<ll> factorial(ll n)\n{\n  vector<ll> fac;\n  fac.push_back(1);\n  for (ll i = 1; i < n + 10; i++)\n  {\n    fac.push_back((fac[i - 1] * i) % mo);\n  }\n  return fac;\n}\nint main()\n{\nll n , k ;\ncin >> n >> k ;\nauto mod = [](ll modx) {modx%=mo;modx+=mo;modx%=mo;return modx; };\nCOMinit();\nvector<ll> fac = factorial(100000);\n\nll s=0;\nrep(i,k+1)s=mod(s+mypow(-1,k-i)*COM(k,i)*mypow(i,n));\n\nvector<ll> b={1};\nrep(i,k)b.push_back(mod(b.back()+(i%2?1:-1)*mypow(fac[i+1],mo-2)));\nll bb=0;\nrep(i,k+1)bb=mod(bb+modmul(mypow(i,n),mypow(fac[i],mo-2),b[k-i]));\n\nvector<vector<ll>> p(5000, vector<ll>(5000,0) );\nrep(i,5000)p[i][1]=1;\nrep(i,5000)rep(j,4998)p[i][j+2]=mod(p[i][j+1]+(i-j-2>=0?p[i-j-2][j+2]:0));\n/* \nhttps://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5\nボール      箱\t      入れ方に制限なし 箱の中身は1つ以下 箱の中身は1つ以上\n区別できる   区別できる  1            2             3\n区別できない  区別できる  4            5             6\n区別できる   区別できない 7            8             9\n区別できない  区別できない 10          11            12\n*/\n//1\n//cout << mypow(k,n) << endl;\n//2\n//cout << (COM(k,n)*fac[n])%mo << endl;\n//3\n//cout << t << endl;\n//4\n//cout << COM(n+k-1,n) << endl;\n//5\n//cout << COM(k,n) << endl;\n//6\n//cout << COM(n-1,k-1) << endl;\n//7\n//cout << bb << endl;\n//8,11\n//cout << (n>k?0:1) << endl;\n//9 漸化式でもできる\n//cout << mod(s*mypow(fac[k],mo-2)) << endl;\n//10\n//cout << p[n][k] << endl;\n//12\ncout << (n-k<0?0:p[n-k][k]) << endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#if __has_include(<boost/multiprecision/cpp_int.hpp>)\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n\tusing namespace boost::multiprecision;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::reverse_iterator first, const typename std::vector<T>::reverse_iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::const_iterator first, const typename std::vector<T>::const_iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::const_reverse_iterator first, const typename std::vector<T>::const_reverse_iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\t\t\n\t\tdbool(const dbool&) = default;\n\t\tdbool(dbool&&) = default;\n\t\tdbool& operator=(const dbool&) = default;\n\t\tdbool& operator=(dbool&&) = default;\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\\\\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::deque<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE([[maybe_unused]] int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception(); }\n\tvoid catch_SIGSEGV([[maybe_unused]] int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\ninline constexpr ll extgcd(ll a, ll b, ll &x, ll &y){ ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\ninline constexpr ll invmod(ll a, ll m = MOD){ ll x = 0, y = 0; extgcd(a, m, x, y); return (x + m) % m; }\nclass Modint{\npublic:\n\tll _num;\n\tconstexpr Modint() : _num() { _num = 0; }\n\tconstexpr Modint(ll x) : _num() { _num = x % MOD; if(_num < 0) _num += MOD; }\n\tinline constexpr Modint operator= (int x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (ll x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\t//inline constexpr Modint operator= (Modint x){ _num = x._num; return *this; }\n\tinline constexpr Modint operator+ (int x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (ll x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (Modint x){ ll a = _num + x._num; if(a >= MOD) a -= MOD; return Modint{a}; }\n\tinline constexpr Modint operator+=(int x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(ll x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(Modint x){ _num += x._num; if(_num >= MOD) _num -= MOD; return *this; }\n\tinline constexpr Modint operator++(){ _num++; if(_num == MOD) _num = 0; return *this; }\n\tinline constexpr Modint operator- (int x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (ll x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (Modint x){ ll a = _num - x._num; if(a < 0) a += MOD; return Modint{a}; }\n\tinline constexpr Modint operator-=(int x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(ll x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(Modint x){ _num -= x._num; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator--(){ _num--; if(_num == -1) _num = MOD - 1; return *this; }\n\tinline constexpr Modint operator* (int x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (ll x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (Modint x){ return Modint{_num * x._num % MOD}; }\n\tinline constexpr Modint operator*=(int x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(ll x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(Modint x){ _num *= x._num; _num %= MOD; return *this; }\n\tinline constexpr Modint operator/ (int x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (ll x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (Modint x){ return Modint{_num * invmod(x._num, MOD) % MOD}; }\n\tinline constexpr Modint operator/=(int x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(ll x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(Modint x){ _num *= invmod(x._num, MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint pow(ll n){ ll i = 1, x = n>=0 ? n : -n; Modint ans = 1, cnt = n>=0 ? *this : Modint(1) / *this; while(i <= x){ if(x & i){ ans *= cnt; x ^= i; } cnt *= cnt; i *= 2; } return ans; }\n\tinline constexpr operator ll() const { return _num; }\n};\ninline std::istream& operator>>(std::istream &s, Modint &x){ ll t; s>>t; x=t; return s; }\nvector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(size_t a){\n\tif(fac.size() >= a) return;\n\tif(a < fac.size() * 2) a = fac.size() * 2;\n\tif(a >= MOD) a = MOD;\n\twhile(fac.size() < a) fac.push_back(fac.back() * ll(fac.size()));\n\tinv.resize(fac.size());\n\tinv.back() = Modint(1) / fac.back();\n\tfor(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint factorial(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint nPk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); for(ll i=n;i>(n-k);i--)val*=i; return val; }\ninline Modint nCk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); k=min(k,n-k); for(ll i=n;i>(n-k);i--)val*=i; for(ll i=k;i>1;i--)val/=i; return val; };\ninline Modint nPk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nPk_loop(n, k); reserve(n + 1); return fac[n] * inv[n - k]; }\ninline Modint nCk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nCk_loop(n, k); reserve(n + 1); return fac[n] * inv[k] * inv[n - k]; }\ninline Modint nHk(ll n, ll k){ return nCk(n + k - 1, k); } //n種類のものから重複を許してk個選ぶ=玉k個と仕切りn-1個\n\n/*\nnCk：n!が間に合わないくらい巨大でkが小さいとき、素直に計算すると間に合う のは1e7以上に組み込んであります\n\tauto f = [](ll n, ll k){\n\t\tif(n<k)return Modint(0);\n\t\tModint val(1);\n\t\tk=min(k,n-k);\n\t\tfor(ll i=n;i>(n-k);i--)val*=i;\n\t\tfor(ll i=k;i>1;i--)val/=i;\n\t\treturn val;\n\t};\n*/\n\n////\n\n// 分割数\ntemplate<class T>\nstruct Partition {\n\tll MAX;\n\tvector< vector<T> > P;\n\tconstexpr Partition(ll size) noexcept : MAX(size+1), P(MAX, vector<T>(MAX, 0)) {\n\t\tfor (ll k = 0; k < MAX; ++k) P[0][k] = 1;\n\t\tfor (ll n = 1; n < MAX; ++n) {\n\t\t\tfor (ll k = 1; k < MAX; ++k) {\n\t\t\t\tP[n][k] = P[n][k-1] + (n-k >= 0 ? P[n-k][k] : T(0));\n\t\t\t}\n\t\t}\n\t}\n\tconstexpr T get(ll n, ll k) {\n\t\tif (n < 0 || k < 0) return 0;\n\t\treturn P[n][k];\n\t}\n};\n\nModint ball1box1(ll N,ll K){\n\treturn Modint(K).pow(N);\n}\nModint ball1box1injection(ll N,ll K){\n\treturn nPk(K,N);\n}\nModint ball1box1surjection(ll N,ll K){\n\tModint ans=0;\n\tfor(ll i=0; i<=K; i++){\n\t\tModint t=nCk(K,i)*Modint(i).pow(N);\n\t\tif((K-i)%2==0)ans+=t;\n\t\telse ans-=t;\n\t}\n\treturn ans;\n}\nModint ball0box1(ll N,ll K){\n\treturn nCk(N+K-1,N);\n}\nModint ball0box1injection(ll N,ll K){\n\treturn nCk(K,N);\n}\nModint ball0box1surjection(ll N,ll K){\n\treturn nCk(N-1,K-1);\n}\nModint ball1box0(ll N,ll K){\n\tvector<Modint> v(K+1);\n\tv[0]=1;\n\tfor(ll i=1;i<=K;i++){\n\t\tModint t=Modint(1)/factorial(i);\n\t\tif(i%2==0)v[i]=v[i-1]+t;\n\t\telse v[i]=v[i-1]-t;\n\t}\n\tModint ans=0;\n\tfor(ll i=0;i<=K;i++){\n\t\tans+=Modint(i).pow(N)/factorial(i)*v[K-i];\n\t}\n\treturn ans;\n}\nModint ball1box0injection(ll N,ll K){\n\treturn N<=K ? 1 : 0;\n}\nModint ball1box0surjection(ll N,ll K){\n\treturn ball1box1surjection(N,K)/factorial(K);\n}\n\nModint ball0box0(ll N,ll K){\n\tPartition<Modint> pt(max(N,K));\n\treturn pt.get(N,K);\n}\nModint ball0box0injection(ll N,ll K){\n\treturn N<=K ? 1 : 0;\n}\nModint ball0box0surjection(ll N,ll K){\n\tPartition<Modint> pt(max(N,K));\n\treturn pt.get(N-K,K);\n}\n\n/*-----8<-----library-----8<-----*/\n \nvoid solve() {\n\t//N個のボール K個の箱\n\tll N,K;\n\tcin>>N>>K;\n\tModint ans;\n\t//ボール区別あり 箱区別あり 制限なし\n\t//ans=ball1box1(N,K);\n\t//ボール区別あり 箱区別あり 箱の中身は1つ以下\n\t//ans=ball1box1injection(N,K);\n\t//ボール区別あり 箱区別あり 箱の中身は1つ以上\n\t//ans=ball1box1surjection(N,K);\n\n\t//ボール区別なし 箱区別あり 制限なし\n\t//ans=ball0box1(N,K);\n\t//ボール区別なし 箱区別あり 箱の中身は1つ以下\n\t//ans=ball0box1injection(N,K);\n\t//ボール区別なし 箱区別あり 箱の中身は1つ以上\n\t//ans=ball0box1surjection(N,K);\n\n\n\t//ボール区別あり 箱区別なし 制限なし\n\t//ans=ball1box0(N,K);\n\t//ボール区別あり 箱区別なし 箱の中身は1つ以下\n\t//ans=ball1box0injection(N,K);\n\t//ボール区別あり 箱区別なし 箱の中身は1つ以上\n\t//ans=ball1box0surjection(N,K);\n\n\t//ボール区別なし 箱区別なし 制限なし\n\t//ans=ball0box0(N,K);\n\t//ボール区別なし 箱区別なし 箱の中身は1つ以下\n\t//ans=ball0box0injection(N,K);\n\t//ボール区別なし 箱区別なし 箱の中身は1つ以上\n\tans=ball0box0surjection(N,K);\n\n\tp(ans);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/finder.jsp?course=DPL\n//https://qiita.com/drken/items/f2ea4b58b0d21621bd51\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked _fflush_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c != '0'; }\ninline void InputF(string& v) {\n\tv.clear(); char c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v) {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\ninline string GetLine() {\n\tstring v; char c; for (InputF(c); c != '\\n' && c != '\\0'; c = gc())v += c; return v;\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>() {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>() {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](pair<int, int> n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define INT input(int)\n#define LL input(ll)\n#define STR input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(ll, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(ll v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) { p(v ? B.t : B.f); }\n\tvoid p(char v) { putchar_unlocked(v); }\n\tvoid p(const char* v) { fwrite_unlocked(v, 1, strlen(v), stdout); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(ld v) { printf(\"%.20Lf\", v); }\n\ttemplate<class T> void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); p(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)p(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)p(D.l); p(v[i]); } }\npublic:\n\tOutput& operator()() { p(D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) { p(h); p(D.l); return *this; }\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) { operator()(forward<T>(t)...); std::exit(EXIT_SUCCESS); }\n\tOutput& flush() { fflush_unlocked(stdout); return *this; }\n\tOutput& set(const BoolStr& b) { B = b; return *this; }\n\tOutput& set(const DivStr& d) { D = d; return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\tvector<T> as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto map(const F& f)const {\n\t\tvector<U> res; res.reserve(count()); each([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const { int res = 0; each([&](T i) {if (f(i))++res; }); return res; }\n\ttemplate<class F>T find_if(const F& f)const { for (T i : *this)if (f(i))return i; return 0; }\n\ttemplate<class F>auto max_by(const F& f)const { auto v = map(f); return *max_element(v.begin(), v.end()); }\n\ttemplate<class F>auto min_by(const F& f)const { auto v = map(f); return *min_element(v.begin(), v.end()); }\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline void Rotate(T& a, int left) { rotate(a.begin(), a.begin() + left, a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline T Rotated(T a, int left) { Rotate(a, left); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\tinline int pop_count(int n) { return bitset<32>(n).count(); }\n\tinline int pop_count(ll n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T(1) << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\ntemplate<int MOD>struct modint {\n\tusing T = long long;\n\tT n;\n\tconstexpr modint(const T x = 0) :n(x% MOD) { if (n < 0)n += MOD; }\n\tconstexpr int get_mod()const { return MOD; }\n\tconstexpr modint operator+()const { return *this; }\n\tconstexpr modint operator-()const { return n ? MOD - n : 0; }\n\tconstexpr modint& operator++() { if (MOD <= ++n)n = 0; return *this; }\n\tconstexpr modint& operator--() { if (n <= 0)n = MOD; n--; return *this; }\n\tconstexpr modint operator++(int) { modint t = *this; ++* this; return t; }\n\tconstexpr modint operator--(int) { modint t = *this; --* this; return t; }\n\tconstexpr modint next()const { return ++modint(*this); }\n\tconstexpr modint pred()const { return --modint(*this); }\n\tconstexpr modint operator+(const modint& m)const { return modint(*this) += m; }\n\tconstexpr modint operator-(const modint& m)const { return modint(*this) -= m; }\n\tconstexpr modint operator*(const modint& m)const { return modint(*this) *= m; }\n\tconstexpr modint operator/(const modint& m)const { return modint(*this) /= m; }\n\tconstexpr modint& operator+=(const modint& m) { n += m.n; if (n >= MOD)n -= MOD; return *this; }\n\tconstexpr modint& operator-=(const modint& m) { n -= m.n; if (n < 0)n += MOD; return *this; }\n\tconstexpr modint& operator*=(const modint& m) { n = n * m.n % MOD; return *this; }\n\tconstexpr modint& operator/=(const modint& m) {\n\t\tT a = m.n, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tT t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tn = n * u % MOD;\n\t\tif (n < 0)n += MOD;\n\t\treturn *this;\n\t}\n\tconstexpr bool operator==(const modint& m)const { return n == m.n; }\n\tconstexpr bool operator!=(const modint& m)const { return n != m.n; }\n\tconstexpr modint pow(modint m)const {\n\t\tmodint t = n, res = 1; while (m.n > 0) { if (m.n & 1)res *= t; t *= t; m.n >>= 1; } return res;\n\t}\n\tconstexpr modint operator^(modint m)const { return pow(m); }\n};\nusing mint = modint<1000000007>;\nusing VM = vector<mint>;\ntemplate<int MOD>inline ostream& operator<<(ostream& os, const modint<MOD>& m) { return os << m.n; }\ntemplate<int MOD>inline istream& operator>>(istream& is, modint<MOD>& m) { return is >> m.n; }\ninline mint operator\"\"_m(unsigned long long n) { return n; }\n\ntemplate<class T>vector<vector<T>> Partition(int n, int m) {\n\tvector<vector<T>> dp(m + 1, vector<T>(n + 1));\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tif (j - i >= 0) {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - i];\n\t\t\t} else {\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn dp;\n}\n\nint main() {\n\tini(n, k);\n\tif (n < k) {\n\t\tout(0);\n\t} else {\n\t\tout(Partition<mint>(n, k)[k][n - k]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vii vector<int>\n#define vll vector<ll>\n#define lb lower_bound\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n// #define int ll\nusing namespace std;\nconst int INF (1 << 30);\nconst ll LLINF (1LL << 55LL);\nconst int MOD = 1000000007;\nconst int MAX = 510000;\nconst double pi=3.14159265358979;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    ll n,k,dp[1010][1010];\n    cin>>n>>k;\n    if(n<k){\n        cout<<0<<endl;\n        return 0;\n    }\n    n-=k;\n    dp[0][0]=1;\n    rep2(i,1,k+1){\n        rep(j,n+1){\n            if(j-i>=0){\n                dp[i][j]=(dp[i-1][j]+dp[i][j-i])%MOD;\n            }\n            else{\n                dp[i][j]=dp[i-1][j]%MOD;\n            }\n        }\n    }\n    cout<<dp[k][n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\n#ifdef __SIZEOF_INT128__\nusing i128 = __int128;\nusing u128 = unsigned __int128;\n#endif\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\ntemplate<typename T> constexpr T PROCON_INF();\ntemplate<> constexpr i64 PROCON_INF<i64>() { return 1'010'000'000'000'000'000LL; }\ntemplate<> constexpr f64 PROCON_INF<f64>() { return 1e100; }\n\nconstexpr i64 INF  = PROCON_INF<i64>();\nconstexpr f64 FINF = PROCON_INF<f64>();\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? std::begin(cccc)+llll : std::end(cccc);\\\n    auto jjjj = llll <= rrrr ? std::begin(cccc)+rrrr : std::end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    const F f_;\n};\n\ntemplate<typename F>\ndecltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\ni64 ipow(i64 x, i64 e) {\n    assert(e >= 0);\n    i64 res = 1;\n    REP(_, e) {\n        res *= x;\n    }\n    return res;\n}\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename ForwardIt, typename T, typename Comp=less<>>\nForwardIt bsearch_find(ForwardIt first, ForwardIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == last || comp(x,*it)) return last;\n    return it;\n}\n\n// x 未満の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_lt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x 以下の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_le(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = upper_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x より大きい最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_gt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return upper_bound(first, last, x, comp);\n}\n\n// x 以上の最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_ge(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return lower_bound(first, last, x, comp);\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\nchar digit_chr(i64 n) {\n    return static_cast<char>('0' + n);\n}\n\ni64 digit_ord(char c) {\n    return c - '0';\n}\n\nchar lower_chr(i64 n) {\n    return static_cast<char>('a' + n);\n}\n\ni64 lower_ord(char c) {\n    return c - 'a';\n}\n\nchar upper_chr(i64 n) {\n    return static_cast<char>('A' + n);\n}\n\ni64 upper_ord(char c) {\n    return c - 'A';\n}\n\n// 出力は operator<< を直接使わず、このテンプレート経由で行う\n// 提出用出力とデバッグ用出力を分けるため\ntemplate<typename T>\nstruct Formatter {\n    static ostream& write_str(ostream& out, const T& x)  { return out << x; }\n    static ostream& write_repr(ostream& out, const T& x) { return out << x; }\n};\n\ntemplate<typename T>\nostream& WRITE_STR(ostream& out, const T& x) {\n    return Formatter<T>::write_str(out, x);\n}\n\ntemplate<typename T>\nostream& WRITE_REPR(ostream& out, const T& x) {\n    return Formatter<T>::write_repr(out, x);\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_STR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_STR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_REPR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_REPR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_STR(ostream& out, InputIt first, InputIt last) {\n    return WRITE_JOIN_STR(out, first, last, \" \");\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_REPR(ostream& out, InputIt first, InputIt last) {\n    out << \"[\";\n    WRITE_JOIN_REPR(out, first, last, \", \");\n    out << \"]\";\n    return out;\n}\n\ntemplate<typename T>\nvoid FROM_STR(const string& s, T& x) {\n    istringstream in(s);\n    in >> x;\n}\n\ntemplate<typename T>\nstring TO_STR(const T& x) {\n    ostringstream out;\n    WRITE_STR(out, x);\n    return out.str();\n}\n\ntemplate<typename T>\nstring TO_REPR(const T& x) {\n    ostringstream out;\n    WRITE_REPR(out, x);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_STR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_STR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_REPR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_REPR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    WRITE_JOIN_STR(out, first, last, sep);\n    return out.str();\n}\n\ntemplate<>\nstruct Formatter<i64> {\n    static ostream& write_str(ostream& out, i64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, i64 x) {\n        if(x == INF) return out << \"INF\";\n        if(x == -INF) return out << \"-INF\";\n        return out << x;\n    }\n};\n\ntemplate<>\nstruct Formatter<f64> {\n    static ostream& write_str(ostream& out, f64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF) return out << \"FINF\";\n        if(x == -FINF) return out << \"-FINF\";\n#pragma GCC diagnostic pop\n        return out << x;\n    }\n};\n\ntemplate<typename T>\nstruct Formatter<vector<T>> {\n    static ostream& write_str(ostream& out, const vector<T>& v) {\n        return WRITE_RANGE_STR(out, begin(v), end(v));\n    }\n    static ostream& write_repr(ostream& out, const vector<T>& v) {\n        out << \"vector\";\n        return WRITE_RANGE_REPR(out, begin(v), end(v));\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Formatter<pair<T1,T2>> {\n    static ostream& write_str(ostream& out, const pair<T1,T2>& p) {\n        WRITE_STR(out, p.first);\n        out << ' ';\n        WRITE_STR(out, p.second);\n        return out;\n    }\n    static ostream& write_repr(ostream& out, const pair<T1,T2>& p) {\n        out << \"(\";\n        WRITE_REPR(out, p.first);\n        out << \",\";\n        WRITE_REPR(out, p.second);\n        out << \")\";\n        return out;\n    }\n};\n\ntemplate<typename... TS>\nstruct Formatter<tuple<TS...>> {\n    template<size_t I=0, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>&) {\n        return out;\n    }\n    template<size_t I=0, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>& t) {\n        if(I != 0) out << ' ';\n        WRITE_STR(out, get<I>(t));\n        return write_str_impl<I+1>(out, t);\n    }\n\n    template<size_t I=0, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>&) {\n        if(sizeof...(TS) == 0) out << \"(\";\n        return out << \")\";\n    }\n    template<size_t I=0, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>& t) {\n        if(I == 0)\n            out << \"(\";\n        else\n            out << \",\";\n        WRITE_REPR(out, get<I>(t));\n        return write_repr_impl<I+1>(out, t);\n    }\n\n    static ostream& write_str(ostream& out, const tuple<TS...>& t) {\n        return write_str_impl(out, t);\n    }\n    static ostream& write_repr(ostream& out, const tuple<TS...>& t) {\n        return write_repr_impl(out, t);\n    }\n};\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    WRITE_STR(cout, x);\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\n[[noreturn]] void EXIT() {\n#ifdef PROCON_LOCAL\n    cerr.flush();\n#endif\n    cout.flush();\n    _Exit(0);\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_REPR(cerr, value);\n    cerr << \"\\n\";\n#endif\n}\n\ntemplate<typename T, size_t N>\nvoid DBG_ARRAY_IMPL(i64 line, const char* expr, const T (&ary)[N]) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_RANGE_REPR(cerr, begin(ary), end(ary));\n    cerr << \"\\n\";\n#endif\n}\n\ntemplate<typename InputIt>\nvoid DBG_RANGE_IMPL(i64 line, const char* expr1, const char* expr2, InputIt first, InputIt last) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr1 << \",\" << expr2 << \" = \";\n    WRITE_RANGE_REPR(cerr, first, last);\n    cerr << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n#define DBG_ARRAY(expr) DBG_ARRAY_IMPL(__LINE__, #expr, (expr))\n#define DBG_RANGE(first,last) DBG_RANGE_IMPL(__LINE__, #first, #last, (first), (last))\n\n#define PAIR  make_pair\n#define TUPLE make_tuple\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n// num {{{\n\n// 事前条件: a >= 0, b >= 0\ni64 gcd_impl(i64 a, i64 b) {\n    if(b == 0) return a;\n    return gcd_impl(b, a%b);\n}\n\n// gcd(0,0) = 0\ni64 gcd(i64 a, i64 b) {\n    return gcd_impl(abs(a), abs(b));\n}\n\n// lcm(0,x) は未定義\ni64 lcm(i64 a, i64 b) {\n    assert(a != 0 && b != 0);\n    a = abs(a);\n    b = abs(b);\n    return a / gcd_impl(a,b) * b;\n}\n\n// 事前条件: a >= 0, b >= 0\ni64 extgcd_impl(i64 a, i64 b, i64& x, i64& y) {\n    if(b == 0) {\n        x = 1; y = 0;\n        return a;\n    }\n    i64 g = extgcd_impl(b, a%b, y, x);\n    y -= a/b * x;\n    return g;\n}\n\n// g=gcd(a,b), および ax+by=g の整数解 (x0,y0) を求める\n// (g,x0,y0) を返す\n// g!=0 のとき、一般解は (x,y) = (x0+m*b/g, y0-m*a/g) で与えられる(mは整数)\ntuple<i64,i64,i64> extgcd(i64 a, i64 b) {\n    i64 x, y;\n    i64 g = extgcd_impl(abs(a), abs(b), x, y);\n    x *= sgn(a);\n    y *= sgn(b);\n    return make_tuple(g, x, y);\n}\n\n// 素因数分解\n// (素因数,指数) のリストを返す\n// n >= 1 でなければならない\n// n == 1 の場合、空リストを返す\nvector<pair<i64,i64>> factorize(i64 n) {\n    assert(n >= 1);\n\n    vector<pair<i64,i64>> res;\n\n    i64 m = n;\n    for(i64 i = 2; i*i <= n; ++i) {\n        if(m == 1) break;\n        i64 e = 0;\n        while(m % i == 0) {\n            ++e;\n            m /= i;\n        }\n        if(e) res.emplace_back(i, e);\n    }\n    if(m > 1) res.emplace_back(m, 1);\n\n    return res;\n}\n\n// 二分累乗\ntemplate<typename Monoid>\nMonoid pow_binary(Monoid x, i64 e) {\n    assert(e >= 0);\n\n    Monoid res(1);  // 行列などの場合はここを適当に変える\n    Monoid cur = x;\n    while(e > 0) {\n        if(e & 1)\n            res *= cur;\n        cur *= cur;\n        e >>= 1;\n    }\n    return res;\n}\n\n// mod m での a の逆元\n// a ⊥ m でなければならない\ni64 inv_mod(i64 a, i64 m) {\n    i64 g,x0; tie(g,x0,ignore) = extgcd(a, m);\n    assert(g == 1);\n    return modulo(x0, m);\n}\n\ntemplate<i64 P>\nstruct ModPT {\n    static_assert(P >= 2, \"P must be a prime\");\n    i64 v_;  // [0,P)\n\n    ModPT() : v_(0) {}\n    ModPT(i64 v) : v_(modulo(v,P)) {}\n\n    ModPT operator-() const {\n        return ModPT(-v_);\n    }\n    ModPT& operator+=(ModPT rhs) {\n        v_ += rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator-=(ModPT rhs) {\n        v_ += P;\n        v_ -= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator*=(ModPT rhs) {\n        v_ *= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n\n    ModPT inv() const {\n        return ModPT(inv_mod(v_,P));\n    }\n};\n\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) += lhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) -= lhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) *= lhs; }\n\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, ModPT<P> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, i64 rhs) { return lhs == ModPT<P>(rhs); }\ntemplate<i64 P>\nbool operator==(i64 lhs, ModPT<P> rhs) { return ModPT<P>(lhs) == rhs; }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, ModPT<P> rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(i64 lhs, ModPT<P> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 P>\nistream& operator>>(istream& in, ModPT<P>& x) {\n    return in >> x.v_;\n}\n\ntemplate<i64 P>\nstruct Formatter<ModPT<P>> {\n    static ostream& write_str(ostream& out, ModPT<P> x) {\n        return WRITE_STR(out, x.v_);\n    }\n    static ostream& write_repr(ostream& out, ModPT<P> x) {\n        return WRITE_REPR(out, x.v_);\n    }\n};\n\nusing ModP = ModPT<MOD>;\n\n// F(0) = 0\n// F(1) = 1\n// F(n) = F(n-1) + F(n-2)\n//\n// // decltype(auto) で受けると SIZE() が使える (auto だとポインタになってしまう)\n// decltype(auto) fib = fibonacci<1000>();\ntemplate<size_t N>\nModP (&fibonacci())[N] {\n    static_assert(N >= 2, \"\");\n    static ModP fib[N] {};\n\n    if(fib[1] != 1) {\n        fib[0] = 0;\n        fib[1] = 1;\n        FOR(i, 2, N) {\n            fib[i] = fib[i-1] + fib[i-2];\n        }\n    }\n    return fib;\n}\n\ntemplate<size_t N>\nModP (&factorial())[N] {\n    static_assert(N >= 1, \"\");\n    static ModP fac[N] {};\n\n    if(fac[0] != 1) {\n        fac[0] = 1;\n        FOR(i, 1, N) {\n            fac[i] = i * fac[i-1];\n        }\n    }\n    return fac;\n}\n\ntemplate<size_t N>\nModP (&ifactorial())[N] {\n    static_assert(N >= 1, \"\");\n    static ModP ifac[N] {};\n\n    if(ifac[0] != 1) {\n        decltype(auto) fac = factorial<N>();\n        ifac[N-1] = fac[N-1].inv();\n        for(i64 i = N-2; i >= 0; --i) {\n            ifac[i] = (i+1) * ifac[i+1];\n        }\n    }\n    return ifac;\n}\n\nModP permutation_count(i64 n, i64 r, const ModP* fac, const ModP* ifac) {\n    if(n < r) return 0;\n    return fac[n] * ifac[n-r];\n}\n\nModP combination_count(i64 n, i64 r, const ModP* fac, const ModP* ifac) {\n    if(n < r) return 0;\n    return fac[n] * ifac[r] * ifac[n-r];\n}\n\n// }}}\n\n//--------------------------------------------------------------------\n\nModP f(i64 n, i64 k) {\n    static bool done[1001][1001] {};\n    static ModP memo[1001][1001] {};\n\n    if(k == 1) return 1;\n    if(n <  k) return 0;\n    if(n == k) return 1;\n\n    if(!done[n][k]) {\n        ModP res = f(n-1,k-1) + f(n-k,k);\n\n        memo[n][k] = res;\n        done[n][k] = true;\n    }\n    return memo[n][k];\n}\n\nvoid solve() {\n    i64 N,K; RD(N); RD(K);\n\n    ModP ans = f(N, K);\n\n    // * MOD はとった?\n    // * 入出力の 0-based/1-based 確認した?\n    // * 時間/メモリ制限は確認した?\n    // * 違うやつ提出してない?\n    // * 違うやつテストしてない?\n    PRINTLN(ans);\n}\n\nsigned main() {\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nconst ULL M = 1000000007;\n\nULL powm(ULL a, ULL i) {\n    if (!i) return 1;\n    if (i & 1) return powm(a * a % M, i >> 1) * a % M;\n    return powm(a * a % M, i >> 1);\n}\n\nULL F[10001], I[10001], iF[10001];\n\nULL C(ULL n, ULL r) { return F[n] * iF[r] % M * iF[n - r] % M; }\nULL P(ULL n, ULL r) { return F[n] * iF[n - r] % M; }\nULL H(ULL n, ULL r) { return C(r + n - 1, n - 1); }\n\nstruct Problem {\n\n    void Solve() {\n        F[0] = 1; for (UL i = 1; i <= 10000; i++) F[i] = F[i - 1] * i % M;\n        I[1] = 1; for (UL i = 2; i <= 10000; i++) I[i] = M - M / i * I[M % i] % M;\n        iF[0] = 1; for (UL i = 1; i <= 10000; i++) iF[i] = iF[i - 1] * I[i] % M;\n        ULL N, K; cin >> N >> K;\n        if (N < K) { cout << 0 << endl; return; }\n        N -= K;\n        ULL dp[1001] = {};\n        dp[N] = 1;\n        rep(i, K) {\n            for (UL j = N; j >= K - i; j--) {\n                dp[j - K + i] += dp[j];\n                dp[j - K + i] %= M;\n            }\n        }\n        cout << dp[0] << endl;\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    p->Solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\") //コンパイラ最適化用\n\n#define _GLIBCXX_DEBUG //配列に[]でアクセス時のエラー表示\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n// forループ関係\n#define REP(i, n) for (ll i = 0; i < ll(n); i++)\n#define REPD(i, n) for (ll i = n - 1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = a; i < ll(b); i++)\n#define FORD(i, a, b) for (ll i = a; i > ll(b); i--)\n// xにはvectorなどのコンテナ\n#define ALL(x) x.begin(), x.end() // sortなどの引数を省略したい\n#define SIZE(x) ll(x.size())      // sizeをsize_tからllに直しておく\n//定数\n#define INF 1000000000000 // 10^12:極めて大きい値,∞\nconst int MOD = 1000000007;\n#define MAXR 100000 // 10^5:配列の最大のrange(素数列挙などで使用)\n//略記\n#define Umap unordered_map\n#define Uset unordered_set\nconst unsigned int BIT_FLAG_0 = (1 << 0); // 0000 0000 0000 0001\nconst unsigned int BIT_FLAG_1 = (1 << 1); // 0000 0000 0000 0010\nconst unsigned int BIT_FLAG_2 = (1 << 2); // 0000 0000 0000 0100\nconst unsigned int BIT_FLAG_3 = (1 << 3); // 0000 0000 0000 1000\nconst unsigned int BIT_FLAG_4 = (1 << 4); // 0000 0000 0001 0000\nconst unsigned int BIT_FLAG_5 = (1 << 5); // 0000 0000 0010 0000\nconst unsigned int BIT_FLAG_6 = (1 << 6); // 0000 0000 0100 0000\nconst unsigned int BIT_FLAG_7 = (1 << 7); // 0000 0000 1000 0000\nvoid add(long long &a, long long b) {\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n// modint: mod 計算を int を扱うように扱える構造体\n// https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod.cpp\n// https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a\n\ntemplate <int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0)\n            val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator-() const noexcept { return val ? MOD - val : 0; }\n    constexpr Fp operator+(const Fp &r) const noexcept {\n        return Fp(*this) += r;\n    }\n    constexpr Fp operator-(const Fp &r) const noexcept {\n        return Fp(*this) -= r;\n    }\n    constexpr Fp operator*(const Fp &r) const noexcept {\n        return Fp(*this) *= r;\n    }\n    constexpr Fp operator/(const Fp &r) const noexcept {\n        return Fp(*this) /= r;\n    }\n    constexpr Fp &operator+=(const Fp &r) noexcept {\n        val += r.val;\n        if (val >= MOD)\n            val -= MOD;\n        return *this;\n    }\n    constexpr Fp &operator-=(const Fp &r) noexcept {\n        val -= r.val;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr Fp &operator*=(const Fp &r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp &operator/=(const Fp &r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const Fp &r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const Fp &r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream &operator<<(ostream &os,\n                                         const Fp<MOD> &x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0)\n            return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1)\n            t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate <class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for (int i = 2; i < n; i++) {\n            fact_[i] = fact_[i - 1] * i;\n            inv_[i] = -inv_[MOD % i] * (MOD / i);\n            finv_[i] = finv_[i - 1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0)\n            return 0;\n        return fact_[n] * finv_[k] * finv_[n - k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0)\n            return 0;\n        return fact_[n];\n    }\n    // 追加\n    constexpr T perm(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0)\n            return 0;\n        return fact_[n] * finv_[k] * finv_[n - k] * fact_[k];\n    }\n\n    constexpr T inv(int n) const noexcept {\n        if (n < 0)\n            return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0)\n            return 0;\n        return finv_[n];\n    }\n};\n\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n/*\nint main() {\n    long long N, M, K; cin >> N >> M >> K;\n    bc.init(510000); // 忘れない！\n    mint sum = 0;\n    for (int i = 0; i <= N-1; ++i) {\n        for (int j = 0; j <= M-1; ++j) {\n            mint tmp = mint(N - i) * mint(M - j) * mint(i + j);\n            modpow(mint(i),N); // 引数はllあるいはmintにして渡す\n            if (i != 0 && j != 0) tmp *= 2;\n            sum += tmp;\n        }\n    }\n    cout << sum * bc.com(N*M-2, K-2) << endl;\n}\n*/\nint partition(int n, int k) {\n    if (n < 0)\n        return 0;\n    vector<vector<int>> P(n + 5, vector<int>(k + 5, 0));\n    REP(i, k + 1) { P[0][i] = 1; }\n    FOR(ni, 1, n + 1) {\n        FOR(ki, 1, k + 1) {\n            if (ni - ki >= 0) {\n                P[ni][ki] = P[ni][ki - 1] + P[ni - ki][ki];\n            } else {\n                P[ni][ki] = P[ni][ki - 1];\n            }\n            P[ni][ki] %= MOD;\n        }\n    }\n    return P[n][k] % MOD;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    cout << partition(n - k, k) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nvector<vector<ll>> PartitionNumber(ll n,ll k){\n\tvector<vector<ll>> dp(n+1,vector<ll>(k+1));\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= n; i++) {\n\t\tfor(int j = 1; j <= k; j++) {\n\t\t\tif(i - j >= 0) dp[i][j] = dp[i][j - 1] + dp[i - j][j];\n\t\t\telse dp[i][j] = dp[i][j - 1];\n\t\t\tdp[i][j] %= atcoder_mod;\n\t\t}\n\t}\n\treturn dp;\n}\nll BallBoxCombination12(ll n,ll k){\n\tif(n-k<0) return 0;\n\tauto T = PartitionNumber(n-k,k);\n\treturn T[n-k][k];\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tll N=in<ll>(),K=in<ll>();\n\t\n\tll ans = BallBoxCombination12(N,K);\n\tout(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MOD = 1e9+7;\nll dp[1010][1010];\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  if(n<k){\n\tcout<<0<<endl;\n\treturn 0;\n  }\n  dp[0][0]=1;\n  for(int i=1;i<=n;i++){\n\tfor(int j=1;j<=k;j++){            \n\t  dp[i][j]+=dp[i-1][j-1];\n\t  if(i>=j)dp[i][j]+=dp[i-j][j];       \n\t  dp[i][j]%=MOD; \n\t}\n  }\n  cout<<dp[n][k]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * aoj/dpl_5_j/main.cpp\n */\n\n// C++ 14\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring> // memset\n#include <cassert>\nusing namespace std;\n#define ll long long\n#define loop(__x, __start, __end) for(int __x = __start; __x < __end; __x++)\ntemplate <class T> ostream & operator << (ostream & out, vector<T> const & v) {\n  for (auto &&a: v) out << a << \" \"; out << endl; return out;\n}\ntemplate <class T> void dump(T &a) { cout << a << endl; }\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false; }\n/* Mod */\n#define MOD 1000000007\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%MOD+MOD)%MOD){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%MOD+MOD)%MOD; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=MOD) x-=MOD; return *this;}\n  mint& operator-=(const mint& a){ if((x+=MOD-a.x)>=MOD) x-=MOD; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=MOD; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nostream & operator << (ostream & out, mint const & v) {\n  out << v.x;\n  return out;\n}\n\n// P(n, k) = P(n-k, k) + P(n, k-1) (n, k>=0)\n// P(0, k) = 1\nint N, K;\nmint P[1010][1010];\nvoid solve() {\n  cin >> N >> K;\n  if (N<K) {\n      cout << 0 << endl;\n      return;\n  }\n  loop(k,0,K+1) P[0][k] = 1;\n  for (int n=1; n<=N; n++) {\n    for (int k=1; k<=K; k++) {\n      P[n][k] = (n-k>=0 ? P[n-k][k] : 0) + P[n][k-1];\n    }\n  }\n  cout << P[N-K][K] << endl;\n}\nint main() {\n  // cout.precision(15); cout << fixed;\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"DPL_5_L.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_L\"\n#line 1 \"/Users/knaga/programming/procon_library/macro/macros.hpp\"\n\n\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0;i<int(N);++i)\n#define rep1(i,N) for(int i=1;i<int(N);++i)\n#define all(a) (a).begin(),(a).end()\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n#define printpair(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<\"{\"<<_.first<<\",\"<<_.second<<\"}\"<<\", \"; cerr<<\"]\"<<endl; }\n#define dump(x) cerr<<#x<<\": \"<<x<<endl;\n#define bit(k) (1LL<<(k))\n#define Yes \"Yes\"\n#define No \"No\"\n#define YES \"YES\"\n#define NO \"NO\"\ntypedef long long ll;\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n  os << \"{\" <<p.first << \", \" << p.second << \"}\";\n  return os;\n}\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int INF = (ll)1e9;\nconst ll INFLL = (ll)1e18+1;\nconst ll MOD = (ll)1e9+7;\n\nconst double PI = acos(-1.0);\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst string dir = \"DRUL\";\n\n\n#line 1 \"/Users/knaga/programming/procon_library/math/mint.hpp\"\n\n\n\n#line 5 \"/Users/knaga/programming/procon_library/math/mint.hpp\"\n\nstruct mint {\n    long long x;\n    mint(long long _x=0):x((_x%MOD+MOD)%MOD){}\n    mint operator-() const { return mint(-x);}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += MOD-a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint modpow(long long t) const {\n        if (!t) return 1;\n        mint a = modpow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime MOD\n    mint inv() const {\n        return modpow(MOD-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const mint& a){\n        os << a.x;\n        return os;\n    }\n};\n\n#line 1 \"/Users/knaga/programming/procon_library/math/partition-number.cpp\"\n\n\n#line 5 \"/Users/knaga/programming/procon_library/math/partition-number.cpp\"\n\n/*\n@title 分割数($0(NK))\n@docs ../docs/math/partition-number.md\n*/\n\ntemplate<typename T = mint>\nstruct Partition{\n    int N,K;\n    vector<vector<mint>> Par;\n    Partition(int _N, int _K):N(_N),K(_K),Par(N+1, vector<mint>(K+1, 0)){\n        build();\n    }\n    void build(){\n        for(int k = 0; k <= K;k++)Par[0][k] = 1;\n        for(int n = 1; n <= N; n++){\n            for(int k = 1; k <= K; k++){\n                if(k-1 >= 0)Par[n][k] += Par[n][k-1];\n                if(n-k >= 0)Par[n][k] += Par[n-k][k];\n            }\n        }\n    }\n    mint get(int n, int k){\n        if(n < 0 || k < 0)return 0;\n        return Par[n][k];\n    }\n};\n\n\n#line 5 \"DPL_5_L.test.cpp\"\n/*\n@title 玉区別しない、箱区別しない、1個以上(分割数$P(n-k,k)$)\n@category 写像12相\n*/\nint main(){\n    int n, k;\n    cin >> n >> k;\n    Partition<mint> Par(n, k);\n    cout << Par.get(n-k, k) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nstruct Combination {\n  int mod;\n  vector<int> fact;\n  vector<int> invf;\n  vector<vector<int> > part;  \n\n  /*\n    constructor : O(sz+log(mod))    \n  */\n  Combination(int sz, int mod) : fact(sz+1), invf(sz+1), mod(mod) {\n    fact[0] = 1;\n    for ( int i = 1; i < (int)fact.size(); i++ ) {\n      fact[i] = fact[i-1]*i % mod;\n    }\n    invf[sz] = inv(fact[sz]);\n    for ( int i = sz-1; i >= 0; i-- ) {\n      invf[i] = invf[i+1]*(i+1) % mod;\n    }\n  }\n\n  int pow(int x, int n) const {\n    int ret = 1;\n    while ( n > 0 ) {\n      if ( n & 1 ) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int inv(int x) const {\n    return (pow(x, mod - 2));\n  }\n\n  /*\n    permutation\n  */\n  int P(int n, int r) const {\n    if ( r < 0 || n < r ) return (0);\n    return (fact[n]*invf[n-r] % mod);    \n  }\n\n  /*\n    combination\n  */\n  int C(int n, int r) const {\n    if ( r < 0 || n < r ) return (0);    \n    return (fact[n]*invf[r]%mod * invf[n-r] % mod);    \n  }  \n\n  /*\n    combination with repetition\n  */\n  int H(int n, int r) const {\n    if ( n < 0 || r < 0 ) return 0;\n    if ( n == 0 && r == 0 ) return 1;\n    return C(n+r-1, n);    \n  }\n\n  /*\n    stirling number\n  */\n  int S(int n, int r) const {\n    int ret = 0;\n    for ( int i = 1; i <= r; i++ ) {\n      int add = C(r, i)*pow(i, n)%mod;      \n      if ( (r-i)&1 ) ret += mod-add;\n      else ret += add;\n      ret %= mod;      \n    }\n    (ret *= invf[r]) %= mod;\n    return ret;\n  }\n\n  /*\n    bell number\n  */\n  int B(int n, int r) const {\n    int ret = 0;\n    for ( int i = 1; i <= r; i++ ) {\n      (ret += S(n, i)) %= mod;      \n    }\n    return ret;\n  }\n\n  /*\n    calc partition number\n    return partition number table\n  */\n  vector<vector<int> > built_part(int n, int r) {\n    part = vector<vector<int> >(n+1, vector<int>(r+1, 0));\n    part[0][0] = 1;\n    for ( int i = 0; i <= n; i++ ) {\n      for ( int j = 1; j <= r; j++ ) {\n\tif ( i-j >= 0 ) {\n\t  (part[i][j] = part[i][j-1]+part[i-j][j]) %= mod;\t  \n\t} else {\n\t  part[i][j] = part[i][j-1];\n\t}\n      }\n    }\n    return part;    \n  }  \n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, k;\n  cin >> n >> k;\n\n  if ( n < k ) {\n    cout << 0 << endl;\n    return 0;    \n  }\n\n  Combination c(n-k, 1e9+7);  \n  c.built_part(n-k, k);\n  cout << c.part[n-k][k] << endl;  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\ntypedef long long ll;\nusing namespace std;\n\nll dp[1001][1001];\n\nll solve(ll n, ll k, ll m) {\n  dp[0][0] = 1;\n  for(int i=0;i<=n;++i) {\n    for(int j=1;j<=k;++j) {\n      if (i<j) {\n        dp[i][j] = dp[i][j-1];\n      }\n      else {\n        dp[i][j] = (dp[i][j-1] + dp[i-j][j]) % m;\n      }\n    }\n  }\n  return dp[n][k];\n}\n\nint main() {\n  ll n,k,mod=1e9+7;\n  cin>>n>>k;\n  cout<<((n<k)?0:solve(n-k,k,mod))<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long a[1005][1005], n, k;\nconst long long mod = 1e9 + 7;\n\nlong long partit(long long nn, long long kk) {\n    for (int i = 1; i <= nn; i++) a[i][0] = 0;\n    for (int i = 0; i <= kk; i++) a[0][i] = 1;\n    for (int i = 1; i <= nn; i++) {\n        for (int j = 1; j <= kk; j++) {\n            if (j <= i) a[i][j] = (a[i][j - 1] + a[i - j][j]) % mod;\n            else a[i][j] = a[i][j - 1];\n        }\n    }\n    return a[nn][kk];\n}\n\nint main() {\n    cin >> n >> k;\n    if (n < k) cout << 0 << endl;\n    else cout << partit(n - k, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\nclass ModInt {\n    using ll = long long;\n\npublic:\n    int value;\n    static int MOD;\n\n    ModInt(ll value = 0) {\n        this->value = (-MOD < value && value < MOD ? value : value % MOD);\n        if (this->value < 0) this->value += MOD;\n    }\n\n    operator int() const noexcept { return this->value; }\n    operator ll() const noexcept { return this->value; }\n\n    ModInt& operator=(const ModInt& x) {\n        if (this != &x) { this->value = x.value; }\n        return *this;\n    }\n\n    bool operator==(const ModInt& x) const { return this->value == x.value; }\n    bool operator!=(const ModInt& x) const { return !(*this == x); }\n\n    ModInt operator+() const { return value; }\n    ModInt operator-() const { return MOD - value; }\n    ModInt operator~() const { return (*this) ^ ModInt(MOD - 2); }\n\n    ModInt operator++() { return *this += 1; }\n    ModInt operator--() { return *this -= 1; }\n\n    ModInt operator++(int) {\n        ModInt before = *this;\n        ++(*this);\n        return before;\n    }\n    ModInt operator--(int) {\n        ModInt before = *this;\n        --(*this);\n        return before;\n    }\n\n    ModInt& operator+=(const ModInt& x) {\n        int sum = this->value + x.value;\n        return *this = (sum < MOD ? sum : sum - MOD);\n    }\n    ModInt& operator-=(const ModInt& x) {\n        int diff = this->value - x.value;\n        return *this = (diff >= 0 ? diff : diff + MOD);\n    }\n    ModInt& operator+=(int x) { return *this += ModInt(x); }\n    ModInt& operator-=(int x) { return *this -= ModInt(x); }\n\n    template <class T>\n    ModInt& operator*=(const T& x) { return *this = ll(this->value) * ll(x) % MOD; }\n    template <class T>\n    ModInt& operator/=(const T& x) { return *this = (this->value % int(x) == 0 ? ModInt(this->value / int(x)) : *this * ~ModInt(x)); }\n    template <class T>\n    ModInt& operator^=(const T& x) {\n        int n = int(x);\n        ModInt b = *this;\n        *this = 1;\n        while (n > 0) {\n            if (n & 1) *this *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return *this;\n    }\n\n    template <class T>\n    ModInt operator+(const T& b) const { return ModInt(*this) += b; }\n    template <class T>\n    ModInt operator-(const T& b) const { return ModInt(*this) -= b; }\n    template <class T>\n    ModInt operator*(const T& b) const { return ModInt(*this) *= b; }\n    template <class T>\n    ModInt operator/(const T& b) const { return ModInt(*this) /= b; }\n    template <class T>\n    ModInt operator^(const T& b) const { return ModInt(*this) ^= b; }\n};\n\nstd::ostream& operator<<(std::ostream& os, const ModInt& x) { return os << x.value; }\nstd::istream& operator>>(std::istream& is, ModInt& x) { return is >> x.value; }\n\nint ModInt::MOD = 1000000007;\n\n// ボールN個、箱K個\nModInt rec(int N, int K) {\n    if (N < 0 || K < 0) return 0;\n    if (K == 0) return N == 0;\n\n    static auto dp = Vec<ModInt>(1001, 1001, ModInt(0));\n    if (dp[N][K] != ModInt(0)) return dp[N][K];\n\n    // 箱に1つずつ入れる\n    dp[N][K] += rec(N - K, K);\n    // 箱を1つ減らす\n    dp[N][K] += rec(N, K - 1);\n    return dp[N][K];\n}\n\nint main() {\n    int N, K;\n    std::cin >> N >> K;\n    std::cout << rec(N - K, K) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\n\ntemplate <class T> inline T chmax(T &a, const T b) {return a = (a < b) ? b : a;}\ntemplate <class T> inline T chmin(T &a, const T b) {return a = (a > b) ? b : a;}\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr int inf = 1e9;\nconstexpr long long INF = 1e18;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\n// dp[i][j] := 数 j を i 分割する総数\nvector<vector<ll>> dp(1010, vector<ll>(1010, 0));\nvoid part_init(){\n    dp[0][0] = 1;\n    for(int i=1; i<=1005; i++){\n        for(int j=0; j<=1005; j++){\n            if(0 <= j - i){\n                (dp[i][j] = dp[i-1][j] + dp[i][j-i]) %= MOD;\n            }\n            else{\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k; cin>>n>>k;\n    n -= k;\n\n    if(n < 0){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    part_init();\n\n    cout << dp[k][n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \nll m=1e9+7;\nll dp[1002][1002];\n\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  dp[0][0]=1;\n  n-=k;\n  for(int i=0;i<=n;i++)\n    for(int j=0;j<=k;j++){\n      if(j)dp[i][j]+=dp[i][j-1];\n      if((i||j)&&i-j>=0)dp[i][j]+=dp[i-j][j];\n      dp[i][j]%=m;\n    }\n  if(n<0)cout<<0<<endl;\n  else cout<<dp[n][k]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nll dp[1001][1001];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  INT(n); INT(k);\n  if(n < k){\n    cout << 0 << endl;\n    return 0;\n  }\n  dp[0][0] = 1;\n  for(int i = 0; i < k; i++){\n    for(int j = 0; j <= n - k; j++){\n      if(j-i-1>=0)dp[i+1][j] = (dp[i][j] + dp[i+1][j-i-1]) % mod;\n      else dp[i+1][j] = dp[i][j];\n    }\n  }\n  cout << dp[k][n-k] << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "bool debug=false;\n#include <stdio.h>\nconst int N=1e3+10;\nconst int MOD=1e9+7;\nint k;\nlong long int f[N][N];\nint min(int a,int b){return a>b?b:a;}\nlong long int dp(int n,int top){\n\tif(debug)printf(\"dp(%d,%d)\\n\",n,top);\n\tif(n==0||n==top)return 1;\n\tif(n<top)return 0;\n\tif(f[n][top]>-1)return f[n][top];\n\tf[n][top]=MOD;\n\tint lim=min(n,k);\n\tfor(int i=top;i<=lim;i++)f[n][top]+=dp(n-i,i);\n\tif(debug)printf(\"f[%d][%d]=%d\\n\",n,top,f[n][top]);\n\treturn f[n][top]%=MOD;\n}\nint main(){\n\tint n;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=k;j++)f[i][j]=-1;\n\tprintf(\"%lld\\n\",dp(n-k,1));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define VSORT(v) sort(v.begin(), v.end())\n#define VRSORT(v) sort(v.rbegin(), v.rend())\n#define ll long long\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<int, P> PP;\ntypedef pair<ll, LP> LPP;\n//typedef vector<unsigned int>vec;\n//typedef vector<ll>vec;\n//typedef vector<vec> mat;\ntypedef vector<vector<int>> Graph;\n\n//const int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n//const int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int INF = 1000000000;\nconst ll LINF = 1000000000000000000;//1e18\nconst ll  MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-10;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\ntemplate<class T> struct Partition {\n    vector<vector<T> > P;\n    constexpr Partition(int MAX) noexcept : P(MAX, vector<T>(MAX, 0)) {\n        for (int k = 0; k < MAX; ++k) P[0][k] = 1;\n        for (int n = 1; n < MAX; ++n) {\n            for (int k = 1; k < MAX; ++k) {\n                P[n][k] = P[n][k-1] + (n-k >= 0 ? P[n-k][k] : 0);\n            }\n        }\n    }\n    constexpr T get(int n, int k) {\n        if (n < 0 || k < 0) return 0;\n        return P[n][k];\n    }\n};\n\nusing mint = Fp<MOD>;\nPartition<mint> pt(5050);\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    cout << pt.get(n-k, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reprrev(i,a,b) for(int i=b-1;i>=a;i--) // [a, b)\n#define reprev(i,n) reprrev(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst ll mod = 1e9+7;\n\n\nvoid chmod(ll &M){\n    if(M >= mod) M %= mod;\n    else if(M < 0){\n        M += (abs(M)/mod + 1)*mod;\n        M %= mod;\n    }\n}\n\nll modpow(ll x, ll n){\n    if(n==0) return 1;\n    ll res=modpow(x, n/2);\n\n    if(n%2==0) return res*res%mod;\n    else return res*res%mod*x%mod;\n}\n\nint getl(int i, int N) { return i==0? N-1:i-1; };\nint getr(int i, int N) { return i==N-1? 0:i+1; };\n\n// 線分 ab の偏角 返り値は[-π, π]\ntemplate<typename T>\nT argument(const pair<T, T> &a, const pair<T, T> &b){\n    double ax=a.first, ay=a.second, bx=b.first, by=b.second;\n    return atan2(by-ay, bx-ax);\n}\n\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n\n/* 注意 \n\n    1LL<<60 * N とかのオーバーフローに気を付けろ\n    制約がヒントになる、ちゃんと全ての制約を見ろ\n\n*/\n\nint const MAX = 2000000;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAX; i++){\n        fac[i] = fac[i-1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n        finv[i] = finv[i-1] * inv[i] % mod;\n    }\n}\nlong long COM(int n, int k){\n    if(n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nint main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    COMinit();\n    int n, k; std::cin >> n >> k;\n    if (n<k) { std::cout << 0 << std::endl; return 0; }\n    std::vector<std::vector<ll>> p(1010, std::vector<ll>(1010, 0));\n    rep(j, 1010) p[0][j] = 1;\n    repr(i, 1, 1010) repr(j, 1, 1010) {\n        p[i][j] = p[i][j-1];\n        if (i-j>=0) p[i][j] += p[i-j][j];\n        chmod(p[i][j]);\n    }\n    std::cout << p[n-k][k] << std::endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\n\n// 分割数テーブル\n// NをK個の非負整数の和で表す通り数 O(NK)\nstruct PartitionNumber {\n    vector<vector<ll>> P;\n    PartitionNumber (ll N) : P(N + 1, vector<ll>(N + 1)){\n        for (ll k = 0; k <= N; k++) P[0][k] = 1;\n        for (ll n = 1; n <= N; n++) {\n            for (ll k = 1; k <= N; k++) {\n                P[n][k] = P[n][k - 1] + (n - k >= 0 ? P[n - k][k] : 0);\n                if (P[n][k] >= MOD) P[n][k] -= MOD;\n            }\n        }\n    }\n\n    ll get(ll n, ll k){\n        return P[n][k];\n    }\n};\n\nint main() {\n    init();\n    ll N, K;\n    cin >> N >> K;\n    if(N<K){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    PartitionNumber P(max(N-K, K));\n\n    cout << P.get(N-K, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint dp[1010][1010];\nsigned main() {\n    int N, K; cin >> N >> K;\n    dp[0][0] = 1;\n    for(int i=1; i<=N; i++) {\n        for(int j=0; j<=K; j++) {\n            if(j >= i) (dp[i][j] += dp[i][j-i]) %= MOD;\n            (dp[i][j] += dp[i-1][j]) %= MOD;\n        }\n    }\n    cout << dp[N][K] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<climits>\n#include<bitset>\n#include<stack>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef tuple<ll, ll, ll> lltpl;\n\nint dy8[8] = { 2,2,-2,-2,1,1,-1,-1 };\nint dx8[8] = { 1,-1,1,-1,2,-2,2,-2 };\nint dx4[4] = { 1,0,0,-1 };\nint dy4[4] = { 0,1,-1,0 };\n\n\n/******************************************************************************************/\n\n\nconst int IINF = 1e9 + 7;\nconst ll LINF = LLONG_MAX;\nconstexpr ll MOD = 1e9 + 7;\n\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type\nfill_v(T& t, const V& v) { t = v; }\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type\nfill_v(T& t, const V& v) {\n\tfor (auto& e : t) fill_v(e, v);\n}\n\n// vector\ntemplate <typename T>\nistream& operator>>(istream & is, vector<T> & vec) { for (T& x : vec) is >> x; return is; }\n// pair\ntemplate <typename T, typename U>ostream& operator<<(ostream & os, pair<T, U> & pair_var) { os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\"; return os; }\n// vector\ntemplate <typename T>ostream& operator<<(ostream & os, const vector<T> & vec) { os << \"{\";\tfor (int i = 0; i < vec.size(); i++) { os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); }os << \"}\"; return os; }\n// map\ntemplate <typename T, typename U>ostream& operator<<(ostream & os, map<T, U> & map_var) { os << \"{\";\trepi(itr, map_var) { os << *itr; itr++; if (itr != map_var.end()) os << \", \"; itr--; }os << \"}\"; return os; }\n// set\ntemplate <typename T>ostream& operator<<(ostream & os, set<T> & set_var) { os << \"{\"; repi(itr, set_var) { os << *itr; itr++; if (itr != set_var.end()) os << \", \"; itr--; }os << \"}\"; return os; }\n\n\nstruct Combination {\n\n\tvector<ll> fact, rfact;\n\n\tCombination(ll sz) : fact(sz + 1), rfact(sz + 1) {\n\n\t\tfact[0] = 1;\n\t\tfor (ll i = 1; i < fact.size(); i++) {\n\t\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\t}\n\t\t//逆元\n\t\trfact[sz] = inv(fact[sz]);\n\t\tfor (ll i = sz - 1; i >= 0; i--) {\n\t\t\trfact[i] = rfact[i + 1] * (i + 1) % MOD;\n\t\t}\n\t}\n\n\tll inv(ll x) {\n\t\treturn pow(x, MOD - 2);\n\t}\n\tll pow(ll x, ll n) {\n\t\tll ret = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) (ret *= x) %= MOD;\n\t\t\t(x *= x) %= MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn (ret);\n\t}\n\tll P(ll n, ll r) {\n\t\tif (r < 0 || n < r) return (0);\n\t\treturn (fact[n] * rfact[n - r] % MOD);\n\t}\n\n\tll C(ll p, ll q) {\n\t\tif (q < 0 || p < q) return (0);\n\t\treturn (fact[p] * rfact[q] % MOD * rfact[p - q] % MOD);\n\t}\n\n\tll H(ll n, ll r) {\n\t\tif (n < 0 || r < 0) return (0);\n\t\treturn (r == 0 ? 1 : C(n + r - 1, r));\n\t}\n};\n\n\nll dp[1005][1005];\n\nint main() {\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, k;\n\tcin >> n >> k;\n\tfor (int i = 0; i < 1005; i++)\n\t{\n\t\tdp[0][i] = 1;\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= k; j++)\n\t\t{\n\t\t\tif (i >= j) {\n\t\t\t\tdp[i][j] += dp[i][j - 1] + dp[i - j][j];\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] += dp[i][j - 1];\n\t\t\t}\n\t\t\tdp[i][j] %= MOD;\n\t\t}\n\t}\n\n\tif (n >= k) {\n\t\tcout << dp[n - k][k] << endl;\n\t}\n\telse\n\t{\n\t\tcout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_L\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long MOD = 1e9 + 7;\n\nlong long f[1010][1010];\n\nint main() {\n    long long n;//ボール\n    long long k;//箱\n    cin >> n >> k;\n\n    if (n < k) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    f[0][0] = 1;\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 1; j <= k; ++j) {\n            f[i][j] = f[i][j - 1];\n            if (i >= j) {\n                f[i][j] = (f[i][j] + f[i - j][j] + MOD) % MOD;\n            }\n        }\n    }\n\n    cout << f[n - k][k] << endl;\n    return 0;\n}\n\n/*\n * DPL_5_Jで定義したf[n][k]がほぼそのまま使える。\n * まずすべての箱に1個ずつボールを入れ，\n * 次に残ったn-k個のボールをk個以下の箱\n * （空箱あり）に入れる。\n * f[n-k][k]\n * ただし，n<kのときは0通り。\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector <T> &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector <T> &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector <T> make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt &operator^=(int64_t n) {\n    int y = x;\n    x = 1;\n    while(n > 0) {\n      if(n & 1) x = 1LL * x * y % mod;\n      y = 1LL * y * y % mod;\n      n >>= 1;\n    }\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  ModInt operator^(const int64_t n) const { return ModInt(*this) ^= n; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt< mod > &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\ntemplate< typename T >\nstruct Combination {\n  vector <T> _fact, _rfact;\n\n  Combination(int sz) : _fact(sz + 1), _rfact(sz + 1) {\n    _fact[0] = _rfact[sz] = 1;\n    for(int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n  }\n\n  inline T fact(int k) const { return _fact[k]; }\n\n  inline T rfact(int k) const { return _rfact[k]; }\n\n  T P(int n, int r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(int p, int q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(int n, int r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n\ntemplate< typename T >\nvector <vector< T >> get_partition(int n, int k) {\n  vector <vector< T >> dp(n + 1, vector< T >(k + 1));\n  dp[0][0] = 1;\n  for(int i = 0; i <= n; i++) {\n    for(int j = 1; j <= k; j++) {\n      if(i - j >= 0) dp[i][j] = dp[i][j - 1] + dp[i - j][j];\n      else dp[i][j] = dp[i][j - 1];\n    }\n  }\n  return dp;\n}\n\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n  cout << (N >= K ? get_partition< modint >(N - K, K)[N - K][K] : 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\tlong long res = ( part_num( n - k, k ) + part_num( n, k - 1 ) ) % MOD;\n\tC[n][k] = res;\n\treturn res;\n}\n\nint main()\n{\n\tint n, k;\n\tcin >> n >> k;\n\n/*\n\t// Pascal's triangle for combination\n\tC[0][0] = 1;\n\tfor( int i = 1; i < 1001; i++ ) {\n\t\tfor( int j = 0; j <= i; j++ ) {\n\t\t\tif( j == 0 || j == i ) {\n\t\t\t\tC[i][j] = C[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tC[i][j] = ( C[i - 1][j - 1] + C[i - 1][j] ) % MOD;\n\t\t\t}\n\t\t}\n\t}\n*/\n\n\tlong long ans = 0;\n\tif( n >= k ) {\n\t\tans = part_num( n - k, k );\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll dp[1001][1001];\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  n-=k;\n  \n  for(int i=0;i<=k;i++){\n    dp[i][0]=1;\n    for(int j=1;j<=n;j++){\n      if(j-i>=0)\n        dp[i][j]+=dp[i][j-i];\n\n      if(i-1>=0)\n        dp[i][j]+=dp[i-1][j];\n      \n      dp[i][j]%=mod;\n    }\n  }\n  if(n>=0)cout<<dp[k][n]<<endl;\n  else cout<<0<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define NUM 1001\n\nll N,K;\nll dp[NUM][NUM];\n\nll recursive(ll num_ball,ll num_box){\n\n\tif(dp[num_ball][num_box] != -1)return dp[num_ball][num_box];\n\n\tif(num_ball == 0 || num_box == 1)return 1;\n\n\tll ret = 0;\n\n\tfor(ll next_box = 1; next_box <= num_box; next_box++){\n\t\tif(next_box > num_ball)break;\n\t\tret += recursive(num_ball-next_box,next_box);\n\t\tret %= MOD;\n\t}\n\n\treturn dp[num_ball][num_box] = ret;\n}\n\nint main(){\n\n\tscanf(\"%lld %lld\",&N,&K);\n\n\tif(N < K){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tN -= K;\n\n\tfor(ll i = 0; i <= N; i++){\n\t\tfor(ll p = 0; p <= K; p++){\n\t\t\tdp[i][p] = -1;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(N,K));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n\nconstexpr intmax_t mod = 1e9+7;\n\nnamespace detail {\ntemplate <typename Tp, size_t N>\nstd::vector<Tp> make_vector(\n    std::vector<size_t>& sizes,\n    typename std::enable_if<(N == 1), Tp const&>::type x\n) {\n  return std::vector<Tp>(sizes[0], x);\n}\ntemplate <typename Tp, size_t N>\nauto make_vector(\n    std::vector<size_t>& sizes,\n    typename std::enable_if<(N > 1), Tp const&>::type x\n) {\n  size_t size = sizes[N-1];\n  sizes.pop_back();\n  return std::vector<decltype(make_vector<Tp, N-1>(sizes, x))>(\n      size, make_vector<Tp, N-1>(sizes, x)\n  );\n}\n}  // detail::\n\ntemplate <typename Tp, size_t N>\nauto make_vector(size_t const(&sizes)[N], Tp const& x) {\n  std::vector<size_t> s(N);\n  for (size_t i = 0; i < N; ++i) s[i] = sizes[N-i-1];\n  return detail::make_vector<Tp, N>(s, x);\n}\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\n// constexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\nint main() {\n  size_t n, k;\n  scanf(\"%zu %zu\", &n, &k);\n\n  if (n < k) return puts(\"0\"), 0;\n\n  auto dp = make_vector<intmax_t>({k+1, n+1}, 0_jd);\n  dp[0][0] = 1;\n  for (size_t i = 1; i <= k; ++i) {\n    for (size_t j = 0; j <= n; ++j) {\n      dp[i][j] = dp[i-1][j];\n      if (j >= i)\n        (dp[i][j] += dp[i][j-i]) %= mod;\n    }\n  }\n\n  printf(\"%jd\\n\", dp[k][n-k]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include    <bits/stdc++.h>\nusing   namespace   std;\ntypedef long long ll;\n\nconst int MOD = 1000000007;\n\nll  F(const ll &n, const ll &k, const vector<vector<ll>> &DP) {\n    // F(n, k)=F(n-k, k)+F(n, k-1)\n    // case 1\n        // use full k boxes\n        // -> k balls to fill all k boxes and rest: n-k for k boxes\n    // case 2\n        // not all boxes\n        // -> n balls for k-1 boxes\n    ll S=0;\n    if (n>=k)\n        S=DP.at(n-k).at(k);\n    if (0<k)\n        S +=DP.at(n).at(k-1);\n    S %=MOD;\n    return S;\n}\n\nint main() {\n    ll n, k;\n    cin >>n >>k;\n    // DP for n balls for equall or less than k boxes\n    vector<vector<ll>> DP(n+1, vector<ll> (k+1, 0));\n    for (ll i=0; i<=k; i++)\n        DP.at(0).at(i)=1;\n    for (ll i=1; i<=n; i++)\n        for (ll j=1; j<=k; j++)\n            DP.at(i).at(j) = F(i, j, DP);\n    // exact k boxes -> difference between k and k-1\n    cout <<(DP.at(n).at(k)-DP.at(n).at(k-1)+MOD)%MOD <<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1e9+7;\ntypedef vector<ll> Vec;\ntypedef vector<Vec> Mat;\n\nint main()\n{\n    int n,k;\n    while(cin>>n>>k)\n    {\n        if(n<k)\n        {\n            cout<<0<<endl;\n            continue;\n        }\n        Mat dp(n+1,Vec(k+1));\n        for(int i=0;i<=k;i++)\n        {\n            dp[0][i]=1;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=k;j++)\n            {\n                if(i>=j) dp[i][j]+=dp[i-j][j];\n                dp[i][j]+=dp[i][j-1];\n                dp[i][j]%=M;\n            }\n        }\n        cout<<dp[n-k][k]<<endl;\n    }\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong dp[1111][1111],mod=1e9+7;\nmain()\n{\n\tint n,k;cin>>n>>k;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=!i;j<=k;j++)\n\t\t{\n\t\t\tdp[i][j]=((j?dp[i][j-1]:0)+(i<j?0:dp[i-j][j]))%mod;\n\t\t}\n\t}\n\tcout<<(n<k?0:dp[n-k][k])<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define FORR(I,A,B) for(ll I = (B-1); I >= (A); --I)\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\n\nll dp[1001][1001];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll n,k;\n\tcin >> n >> k;\n\n\tn-=k;\n\tFOR(i,0,k+1){\n\t\tdp[i][0]=1;\n\t\tFOR(j,1,n+1){\n\t\t\tif((j-i)>=0)\n\t\t\t\tdp[i][j]+=dp[i][j-i];\n\t\t\tif(i>=1)\n\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\tdp[i][j] %= MOD;\n\t\t}\n\t}\n\tif(n>=0)cout << dp[k][n] << endl;\n\telse cout << 0 << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define rep(i,a,b) for(int i=a;i<(b);++i)\ntemplate<class T> inline bool chmin(T &a, T b){ if(a > b) { a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b) { a = b; return true;} return false;}\nusing ll = long long;\nconstexpr long long INF = 1LL << 62;\nconstexpr int MOD = 1e9 + 7;\nconstexpr double EPS = 1e-10;\n\nll dp[1010][1010];\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int N, K; cin >> N >> K;\n\n    dp[0][0] = 1;\n    for(int i=1; i <= K; ++i) {\n        for(int j = 0; j <= N; ++j) {\n            if(j - i >= 0) {\n                dp[i][j] = (dp[i-1][j] + dp[i][j-i]) % MOD;\n            } else {\n                dp[i][j] = dp[i-1][j] % MOD;\n            }\n        }\n    }\n\n    cout << (N >= K ? dp[K][N-K] : 0) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\nconst ll mod = 1e9+7;\n\nint main(){\n  ll n, k;\n  cin >> n >> k;\n  vector<vector<ll>> dp(n+1,vector<ll>(k+1));\n  rep(i,k+1) dp[0][i] = 1;\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= k; j++) {\n      if(i >= j) (dp[i][j] += dp[i-j][j]) %= mod;\n      (dp[i][j] += dp[i][j-1]) %= mod;\n    }\n  }\n  ll ans = (dp[n][k] - dp[n][k-1]) % mod;\n  if(ans < 0) ans += mod;\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nconst double eps = 1e-8;\nconst int MOD = 1000000007;\n// int main() {\n//     cin.tie(0);\n//     ios::sync_with_stdio(false);\n//     cout << fixed << setprecision(10);\n//\n// }\nll powm(ll a, ll n, ll m) {\n    ll ret = 1;\n    while (n > 0) {\n        if (n & 1) (ret *= a) %= m;\n        (a *= a) %= m;\n        n >>= 1;\n    }\n    return ret;\n}\nll invm(ll a, ll m) {\n    return powm(a, m-2, m);\n}\nvector<ll> fact;\nvoid init_fact(int n, ll m) {\n    fact.assign(n+1, 1);\n    for (int i = 2; i <= n; ++i) {\n        (fact[i] = fact[i-1] * i) %= m;\n    }\n}\n// require init_fact(GREATER THAN OR EQUAL TO n, m)\nll C(ll n, ll r, ll m) {\n    return (fact[n] * invm((fact[r] * fact[n-r]) % m, m)) % m;\n}\n// Stirling number\n// Stirling(n, k) := the number of cases\n//            to split n balls(distinguished)\n//            into k boxes(not distinguished)\n//            s.t. each box contains at least one ball.\n//\n// require init_fact(GREATER THAN OR EQUAL TO k, m)\nll Stirling(ll n, ll k, ll m) {\n    ll ret = 0;\n    for (ll l = 0; l <= k; ++l) {\n        ll tmp = (C(k, l, m) * powm((k-l) % m, n, m)) % m;\n        if (l & 1) tmp = (-tmp + m) % m;\n        (ret += tmp) %= m;\n    }\n    return (ret *= invm(fact[k], m)) %= m;\n}\n// Bell number\n// Bell(n, k) := the number of cases\n//            to split n balls(distinguished)\n//            into k boxes(not distinguished)\n//\n// require init_fact(GREATER THAN OR EQUAL TO k, m)\nll Bell(ll n, ll k, ll m) {\n    ll ret = 0;\n    for (ll l = 0; l <= k; ++l) {\n        (ret += Stirling(n, l, m)) %= m;\n    }\n    return ret;\n}\n// Partition function\n// Partition[k][n] := the number of cases\n//            to split n balls(not distinguished)\n//            into k boxes(not distinguished)\nvector<vector<ll>> Part;\nvoid init_partition(ll k, ll n, ll m) {\n    Part.assign(k+1, vector<ll>(n+1, 0));\n    Part[0][0] = 1;\n    for (int i = 1; i <= k; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            if (j-i >= 0) {\n                Part[i][j] = (Part[i-1][j] + Part[i][j-i]) % m;\n            } else {\n                Part[i][j] = Part[i-1][j];\n            }\n        }\n    }\n}\nint main() {\n    ll n, k; cin >> n >> k;\n    const ll mod = 1e9+7;\n    init_partition(k, n, mod);\n    cout << (Part[k][n] - Part[k-1][n] + mod) % mod << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint dp[1010][1010];\nsigned main() {\n    int N, K; cin >> N >> K;\n    N -= K;\n    dp[0][0] = 1;\n    for(int i=1; i<=K; i++) {\n        for(int j=0; j<=N; j++) {\n            if(j >= i) (dp[i][j] += dp[i][j-i]) %= MOD;\n            (dp[i][j] += dp[i-1][j]) %= MOD;\n        }\n    }\n    if(N < 0) cout << 0 << endl;\n    else cout << dp[K][N] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<Int MOD = 1000000007>\nstruct Mod{\n  Int prev=0;\n  vector<Int> fact,inv,finv;\n  Mod(){}\n  Mod(Int n){init(n);}\n  \n  Int pow(Int x,Int n){\n    Int res=1;\n    while(n){\n      if(n&1) (res*=x)%=MOD;\n      (x*=x)%=MOD;\n      n>>=1;\n    }\n    return res;\n  }\n  \n  Int inverse(Int a){\n    return pow(a,MOD-2);\n  }\n  \n  void init(Int n){\n    if(prev>=n) return;\n    prev=n;\n    fact=inv=finv=vector<Int>(n);\n    \n    fact[0]=1;\n    for(Int i=1;i<n;i++)\n      fact[i]=(fact[i-1]*i)%MOD;\n    \n    inv[1]=1;\n    for(Int i=2;i<n;i++)\n      inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    \n    finv[0]=1;\n    for(Int i=1;i<n;i++)\n      finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n  \n  Int comb(Int n,Int k){\n    Int res=1;\n    for(Int i=0;i<k;i++){\n      res*=(n-i)%MOD;\n      res%=MOD;\n      res*=inverse(i+1);\n      res%=MOD;\n    }\n    return res;\n  }\n  \n  //only for prime MOD\n  Int C(Int n,Int k){\n    if(k<0||k>n) return 0;\n    return fact[n]*finv[k]%MOD*finv[n-k]%MOD;\n  }\n\n  Int H(Int n,Int k){\n    return C(n+k-1,n);\n  }\n\n  Int S(Int n,Int k){\n    Int res=0;\n    for(Int i=1;i<=k;i++){\n      Int tmp=C(k,i)*pow(i,n)%MOD;\n      if((k-i)&1) res+=MOD-tmp;\n      else res+=tmp;\n      res%=MOD;\n    }\n    res=res*finv[k]%MOD;\n    return res;\n  }\n  \n  Int B(Int n,Int k){\n    Int res=0;\n    for(Int j=1;j<=k;j++){\n      res+=S(n,j);\n      res%=MOD;\n    }\n    return res;\n  }\n\n  \n  vector<vector<Int> > D(Int n,Int m){\n    vector<vector<Int> > dp(n+1,vector<Int>(m+1,0));\n    dp[0][0]=1;\n    for(Int i=0;i<=n;i++){\n      for(Int j=1;j<=m;j++){\n\tif(i-j>=0) dp[i][j]=(dp[i][j-1]+dp[i-j][j])%MOD;\n\telse dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n  \n  Int montmort(Int n){\n    Int res=0,rinv=1;\n    for(Int k=2;k<=n;k++){\n      rinv=rinv*inverse(k)%MOD;\n      if(k%2) res+MOD-rinv;\n      else res+=rinv;\n      res%=MOD;\n    }\n    for(Int i=1;i<=n;i++) res=res*i%MOD;\n    return res;\n  }\n  \n  // calculate P(t) from given points in [0,N]\n  Int LagrangePolynomial(vector<Int> &y,Int t){\n    Int n=y.size()-1;\n    init(n+1);\n    Int num=1;\n    for(Int i=0;i<=n;i++)\n      num=num*((t-i)%MOD)%MOD;\n    Int res=0;\n    for(Int i=0;i<=n;i++){\n      Int tmp=(y[i]*num%MOD)*inverse((t-i)%MOD)%MOD;\n      tmp=tmp*finv[i]%MOD;\n      tmp=tmp*finv[n-i]%MOD;\n      if((n-i)&1) tmp=MOD-tmp;\n      res=(res+tmp)%MOD;\n    }\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  const Int MOD = 1e9+7;\n  Mod<MOD> mod(2e5);\n  Int n,k;\n  cin>>n>>k;\n  cout<<(n<=k?mod.D(n,k)[n-k][k]:0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>  \nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000000000000000000000001\n#define LONG_INF 10000000000000000\n#define GOLD 1.61803398874989484820458\n#define MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\nlong long power(long long a,long long now) {\n\tlong long ans = 1;\n\twhile (now != 0) {\n\t\tif (now % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MOD;\n\t\t}\n\t\tnow /= 2;\n\t\ta *= a;\n\t\ta %= MOD;\n\t}\n\treturn ans;\n}\nlong long inv(long long a) {\n\treturn power(a, MOD - 2);\n}\nlong long permutation(long long a, long long b) {\n\tlong long ans = 1;\n\tfor (long long i = 0; i < b; ++i) {\n\t\tans *= (a - i);\n\t\tans %= MOD;\n\t}\n\treturn ans;\n}\nlong long combination(long long a, long long b) {\n\tlong long ans = 1;\n\tfor (long long i = 0; i < b; ++i) {\n\t\tans *= (a - i);\n\t\tans %= MOD;\n\t\tans *= inv(i + 1);\n\t\tans %= MOD;\n\t}\n\treturn ans;\n}\nlong long dp[1001][1001];\nlong long solve(long long a, long long b) {\n\tif (b == 1) return 1;\n\tif (a < 0) return 0;\n\tif (a == 0) return 1;\n\tif (dp[a][b]) return dp[a][b];\n\treturn dp[a][b] = (solve(a,b-1) + solve(a-b,b)) % MOD;\n}\nint main() {\n\tlong long n, k;\n\tcin >> n >> k;\n\tcout << solve(n-k, k) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nclass Mint{\n    public:\n    int v;\n    const long long MOD = 1000000007;\n    Mint():v(0){}\n    Mint(signed v):v(v){}\n    Mint(long long t){v=t%MOD; if(v<0)v+=MOD;}\n\n    Mint pow(long long k){\n        Mint res(1), tmp(v);\n        while(k){\n            if(k&1)res*=tmp;\n            tmp*=tmp;\n            k>>=1;\n        }\n        return res;\n    }\n    Mint inv(){return pow(MOD-2);}\n\n    Mint& operator+=(Mint a){v+=a.v; if(v>=MOD)v-=MOD; return *this;}\n    Mint& operator-=(Mint a){v+=MOD-a.v; if(v>=MOD)v-=MOD; return *this;}\n    Mint& operator*=(Mint a){v=1LL*v*a.v%MOD; return *this;}\n    Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n    Mint operator+(Mint a) const{return Mint(v)+=a;};\n    Mint operator-(Mint a) const{return Mint(v)-=a;};\n    Mint operator*(Mint a) const{return Mint(v)*=a;};\n    Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n    Mint operator-(){return v ? MOD-v : v;}\n    bool operator==(Mint a)const{return v==a.v;}\n    bool operator!=(Mint a)const{return v!=a.v;}\n\n    Mint operator=(Mint a) {v=a.v;return a;}\n\n    friend ostream& operator<<(ostream& os, const Mint& mint){\n        os << mint.v;\n        return os;\n    }\n};\n\nclass cmbs{\n    public:\n    vector<Mint> fact, finv, inv;\n    cmbs(){\n        fact.clear(); finv.clear(); inv.clear();\n    }\n    void init(int n){\n        if(n+1 <= (signed)fact.size())return;\n        fact.assign(n+1,1);\n        finv.assign(n+1,1);\n        inv.assign(n+1,1);\n\n        for(int i=1; i<=n; i++) fact[i] = fact[i-1]*Mint(i);\n        finv[n] = Mint(1)/fact[n];\n        for(int i=n; i>=1;i--) finv[i-1] = finv[i]*Mint(i);\n        for(int i=1; i<=n; i++) inv[i] = finv[i]*fact[i-1];\n    }\n    Mint comb(long long n, int k){\n        if(n<k||k<0)return Mint(0);\n        Mint res(1);\n        for(int i=0; i<k; i++){\n            res *= Mint(n-i);\n            res /= Mint(i+1);\n        }\n        return res;\n    }\n    Mint C(int n,int k){\n        if(n<k||k<0)return Mint(0);\n        init(n);\n        return fact[n]*finv[n-k]*finv[k];\n    }\n    Mint P(int n, int k){\n        if(n<k || k<0)return Mint(0);\n        init(n);\n        return fact[n]*finv[n-k];\n    }\n    Mint H(int n, int k){\n        if(n<0||k<0)return Mint(0);\n        if(!n&&!k)return Mint(1);\n        init(n+k-1);\n        return C(n+k-1,k);\n    }\n    Mint S(int n, int k){\n        Mint res;\n        init(k);\n        for(int i=0; i<=k; i++){\n            Mint v = (C(k,i) * Mint(k-i).pow(n));\n            if(i%2==0) res+=v;\n            else res-=v;\n        }\n        return res;\n    }\n    Mint bell_number(int n, int k){ // 区別できるn個のボールを区別できないk個以下の箱に分割する方法の数\n        if(n==0)return Mint(1);\n        k = std::min(k,n);\n        init(n);\n        Mint ret;\n        std::vector<Mint> pref(k+1);\n        pref[0] = Mint(1);\n        for(int i=1; i<=k; i++){\n            if(i&1) pref[i] = pref[i-1] - finv[i];\n            else pref[i] = pref[i-1] + finv[i];\n        }\n        for(int i=1; i<=k; i++){\n            ret += Mint(i).pow(n) * finv[i] * pref[k-i];\n        }\n        return ret;\n    }\n    std::vector<std::vector<Mint>> D(int n, int m){ // 区別できないn個のボールを区別できないk個以下の箱に分割する方法の数\n        if(n<0 || m<0){\n            std::vector<std::vector<Mint>> dp(1, std::vector<Mint>(1, Mint(0)));\n            return dp;\n        }\n        std::vector<std::vector<Mint>> dp(n+1, std::vector<Mint>(m+1, Mint(0)));\n        dp[0][0] = Mint(1);\n        for(int i=0; i<=n; i++){\n            for(int j=1; j<=m; j++){\n                if(i>=j)dp[i][j] = dp[i][j-1] + dp[i-j][j];\n                else dp[i][j] = dp[i][j-1];\n            }\n        }\n        return dp;\n    }\n};\n\nint main(){\n    int n,k;\n    cin>>n>>k;\n    cmbs cmb;\n    if(n-k<0)cout<<\"0\"<<endl;\n    else cout<<cmb.D(n-k,k)[n-k][k]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nconstexpr lint mod = 1e9 + 7;\ninline lint emod(lint a, lint p = mod) { return (a % p + p) % p; }\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  lint n, k; cin >> n >> k;\n  if (n < k) return cout << 0 << '\\n', 0;\n  VV<> mem; assign(mem, n + 1, k + 1, -1);\n  fill(begin(mem[0]), end(mem[0]), 1);\n  for (int i = 1; i < n + 1; ++i) mem[i][0] = 0;\n  auto rec = [&](auto rec, lint n, lint k) -> lint {\n    if (n < 0 or k < 0) return 0;\n    if (mem[n][k] != -1) return mem[n][k];\n    return mem[n][k] = (rec(rec, n, k - 1) + rec(rec, n - k, k)) % mod;\n  };\n  cout << emod(rec(rec, n - k, k)) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\nconst int maxn=(int)1e6+5;\ntypedef long long ll;\nconst ll MOD=(ll)1e9+7;\n//等价于n拆分成小于等于k个正整数的方案数\nll dp[1005][1005];//dp[i][j] j拆成i个非负数\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n,k;cin>>n>>k;\n    n-=k;\n    for(int i=0;i<=k;i++){\n        dp[i][0]=1;\n        for(int j=1;j<=n;j++){\n            if(j-i>=0)\n            dp[i][j]+=dp[i][j-i];//每个数加1？\n\n            if(i-1>=0)\n            dp[i][j]+=dp[i-1][j];//拆出个0\n            \n            dp[i][j]%=MOD;\n        }\n    }\n    if(n>=0)cout<<dp[k][n]<<endl;\n    else cout<<0<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007, INF=mod*mod*3LL;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint operator-() const { return mint(-x);}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n    mint operator+(const mint a) const { return mint(*this) += a;}\n    mint operator-(const mint a) const { return mint(*this) -= a;}\n    mint operator*(const mint a) const { return mint(*this) *= a;}\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const { return pow(mod-2);}\n    mint& operator/=(const mint a) { return *this *= a.inv();}\n    mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\n\n\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, k;\n    cin >> n >> k;\n    vector<vector<mint> > dp(n+1, vector<mint> (k+1, 0));\n    for(int i=0;i<=k;i++)dp[0][i] = 1;\n    for(ll i=1;i<=n;i++){\n    \tfor(ll j=1;j<=k;j++){\n    \t\tdp[i][j] = dp[i][j-1] + ((i>=j)?dp[i-j][j]:0LL);\n    \t}\n    }\n    cout << ((n>=k)?dp[n - k][k]: 0LL) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007LL;\n//constexpr long long MOD = 998244353LL;\ntemplate<class T, class U> inline bool chmax(T &a, U b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T, class U> inline bool chmin(T &a, U b) { if (a > b) { a = b; return true;} return false; }\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\ntemplate <std::uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = std::uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt rhs = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n\n    bool operator==(const ModInt &p) const {return a == p.a;}\n    bool operator!=(const ModInt &p) const {return a != p.a;}\n\n};\n\nusing mint = ModInt<MOD>;\n\nstruct ModCombination {\n    vector<mint> Fac;\n    vector<mint> Facinv;\n\n    ModCombination(int x) {\n        Fac.resize(x+1);\n        Facinv.resize(x+1);\n        Fac[0] = 1;\n        for (int i = 0; i < x; ++i) Fac[i+1] = Fac[i]*(i+1);\n        Facinv[x] = Fac[0]/Fac[x];\n        for (int i = x; i > 0; --i) Facinv[i-1] = Facinv[i]*i;\n    }\n\n    mint get(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return Fac[n]*Facinv[k]*Facinv[n-k];\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,K; cin >> N >> K;\n    if (N < K) {\n        cout << 0 << ln;\n        return 0;\n    }\n    N -= K;\n    vector<vector<mint>> dp(N+1, vector<mint>(K+1));\n    rep(i,K+1) dp[0][i] = 1;\n    rep(i,N) {\n        for (int j = 1; j <= K; j++) {\n            dp[i+1][j] += dp[i+1][j-1];\n            if (i+1 >= j) dp[i+1][j] += dp[i+1-j][j];\n        }\n    }\n    cout << dp[N][K].a << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {0,1,0,-1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nvector<ll> fac(MAX), finv(MAX), inv(MAX);\n\nvoid comInit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(ll i=2; i<MAX; i++){\n        fac[i] = fac[i-1]*i % mod;\n        inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n        finv[i] = finv[i-1] * inv[i] % mod;\n    }\n}\n\n\nll com(ll n, ll k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nll modpow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nll split(ll n, ll k){\n    vector<vector<ll>> p(n+1,vector<ll>(k+1,0));\n    for(int j=0; j<=k; j++) p[0][j] = 1;\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=k; j++){\n            p[i][j] = p[i][j-1];\n            if(i>=j) p[i][j] += p[i-j][j];\n            p[i][j] %= mod;\n        }\n    }\n    return p[n][k];\n}\n\nint main(){\n    ll n,k; cin >> n >> k;\n    comInit();\n    if(n<k) cout << 0 << endl;\n    else cout << split(n-k,k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ボール: 区別なし, 箱：区別なし, 入れ方: 1 個以上\n// 分割数\n// P(n, k) = P(n, k - 1) + P(n - k, k)\n#include <iostream>\nusing namespace std;\nconst int MOD = 1000000007;\nconst long long MAXN = 1010;\nlong long P[MAXN][MAXN] = {};\n\nvoid pertition_init() {\n  for(int k = 0; k < MAXN; k++) P[0][k] = 1;\n  for(int n = 1; n < MAXN; n++) {\n    for(int k = 1; k < MAXN; k++) {\n      P[n][k] += P[n][k - 1] + (n - k >= 0 ? P[n - k][k] : 0);\n      P[n][k] %= MOD;\n    }\n  }\n}\n\nint main() {\n  \n  pertition_init();\n  int n, k; cin >> n >> k;\n  if(n - k < 0) cout << 0 << endl;\n  else cout << P[n - k][k] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n                                            #include<iostream>\n                                            #include<cstdio>\n                                            #include<vector>\n                                            #include<queue>\n                                            #include<map>\n                                            #include<cstring>\n                                            #include<string>\n                                            #include <math.h>\n                                            #include<algorithm>\n                                        //    #include <boost/multiprecision/cpp_int.hpp>\n                                            #include<functional>\n                                   #define int long long\n                                            #define inf  1000000007\n                                            #define pa pair<int,int>\n                                            #define ll long long\n                                            #define pal pair<double,double>\n                                            #define ppap pair<pa,int>\n                                    //  #define PI 3.14159265358979323846\n                                            #define paa pair<int,char>\n                                            #define  mp make_pair\n                                            #define  pb push_back\n                                            #define EPS (1e-10)\n                                            #define equals(a,b) (fabs((a)-(b))<EPS)\n    int dx[8]={0,-1,0,1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n                                                   #define ppa pair<int,pas>\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                 \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                \tint zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\n\nint dp[1010][1010]={0};\n\n    signed main(){\n     \n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n,k;\n    \tcin>>n>>k;\n    \t\n    \tmod=inf;\n    \tgya(10000);\n   \n    \tfor(int i=0;i<=1000;i++)dp[0][i]=1;\n    \tfor(int i=1;i<=1000;i++){\n    \t\tdp[i][1]=1;\n    \t\tfor(int j=2;j<=1000;j++){\n    \t\t\tif(j<=i)dp[i][j]=(dp[i][j-1]+dp[i-j][j])%inf;\n    \t\t\telse dp[i][j]=dp[i][j-1];\n    \t\t}\n    \t}\n    \tcout<<(dp[n][k]-dp[n][k-1]+inf)%inf<<endl;\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_L\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n//END CUT HERE\n#ifndef call_from_test\n\n//INSERT ABOVE HERE\nsigned ABC127_E(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int h,w,k;\n  cin>>h>>w>>k;\n  using M = Mint<int>;\n\n  M ans{0};\n  for(int d=1;d<h;d++)\n    ans+=M(d)*M(h-d)*M(w)*M(w);\n\n  for(int d=1;d<w;d++)\n    ans+=M(d)*M(w-d)*M(h)*M(h);\n\n  ans*=M::comb(h*w-2,k-2);\n  cout<<ans<<endl;\n  return 0;\n}\n/*\n  verified on 2019/06/12\n  https://atcoder.jp/contests/abc127/tasks/abc127_e\n*/\n\nsigned main(){\n  //ABC127_E();\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n\n#endif\n//BEGIN CUT HERE\n// put n identical balls into k identical boxes\ntemplate<typename M>\nstruct Partition{\n  vector< vector<M> > dp;\n  Partition(int h,int w):dp(h+1,vector<M>(w+1,0)){\n    dp[0][0]=M(1);\n    for(int i=0;i<=h;i++){\n      for(int j=1;j<=w;j++){\n        dp[i][j]=dp[i][j-1];\n        if(i-j>=0) dp[i][j]+=dp[i-j][j];\n      }\n    }\n  }\n  M operator()(int n,int k){\n    return dp[n][k];\n  }\n};\n//END CUT HERE\n\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#undef call_from_test\n\nsigned main(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  Partition<Mint<int>> P(n,k);\n  printf(\"%d\\n\",k<=n?P(n-k,k).v:0);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nusing P = pair<ll, ll>;\ntypedef vector<int> vi;\nconst int MOD = (int)1e9 + 7;\nconst ll INF = 1LL << 60;\nconst int inf = 1<<30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        if (i!=N-1) os << \" \";\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, pair<T,T> const&P){\n    os << P.first;\n    os << \" \";\n    os << P.second;\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> &S){\n    auto it=S.begin();\n    while(it!=S.end()){\n        os << *it;\n        os << \" \";\n        it++;\n    }\n    os << \"\\n\";\n    return os;\n}\nll pow(int a,int b,int mod){\n    vector<bool> bit;\n    for(b=b;b>0;b>>=1){\n        bit.push_back(b&1);\n    }\n    vector<ll> fac(bit.size()); fac[0] = a;\n    ll res = 1;\n    for(int i=1;i<bit.size();i++){\n        fac[i] = (fac[i-1] * fac[i-1])%mod;\n    }\n    for(int i=0;i<bit.size();i++){\n        if(bit[i]) res*=fac[i];\n        res%=mod;\n    }\n    return res;\n}\n\n\n//mint\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x+2*MOD)%MOD){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += MOD-a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n\n    // for prime MOD\n    mint inv() const {\n        return pow(MOD-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\nostream& operator<<(ostream& os, mint a){\n    os << a.x;\n    return os;\n}\n\nclass BigCombination{\nprivate:\n    const int MAX = 510'000;\npublic:\n    mint fac[510000], inv[510000];\n    BigCombination(){\n        fac[0] = fac[1] = 1;\n        for(int i=2; i<MAX; i++){\n            fac[i] = fac[i-1] * i;\n        }\n        inv[MAX-1] = fac[MAX-1].inv();\n        for(int i=MAX-1;i>0;i--){\n            inv[i-1] = inv[i] * i;\n        }\n    }\n\n    mint combination(int n,int r){\n        if(n<r) return 0;\n        if(n==r) return 1;\n        return fac[n] * inv[r] * inv[n-r];\n    }\n    mint permutation(int n,int r){\n        if (n < r) return 0;\n        return fac[n] * inv[n-r];\n    }\n};\n\n\n//写像12相\n//区別できるボール/区別できる箱/制限なし r^n\nmint ball_1(int n,int r){\n    return pow(n,r,MOD);\n}\n//区別できるボール/区別できる箱/1個以下 rPn \nmint ball_2(int n,int r){\n    BigCombination B;\n    mint res = B.permutation(r,n);\n    return res;\n}\n//区別できるボール/区別できる箱/1個以上 包除原理\nmint ball_3(int n,int r){\n    BigCombination B;\n    mint res = 0;\n    for(int i=0;i<r;i++){\n        mint x = B.combination(r,i) * pow((r-i), n, MOD);\n        if (i&1) x *= -1;\n        res += x;\n    }\n    return res;\n}\n//区別できないボール/区別できる箱/制限なし 仕切りをどこに入れるか選ぶ (n+r-1)C(n)\nmint ball_4(int n,int r){\n    BigCombination B;\n    return B.combination(n+r-1,n);\n}\n//区別できないボール/区別できる箱/1個以下 rCn\nmint ball_5(int n,int r){\n    BigCombination B;\n    return B.combination(r,n);\n}\n//区別できないボール/区別できる箱/1個以上 n-1Cr-1(しきりを玉の間に)\nmint ball_6(int n,int r){\n    BigCombination B;\n    return B.combination(n-1,r-1);\n}\n//区別できるボール/区別できない箱/制限なし ベル数 = S(N,i)の和(0<=i<=r)\nmint ball_7(int n,int r){\n    vector<vector<mint>> S(n+1,vector<mint>(r+1,0)); //S[i][j]:=i人を区別されないj個のグループに分ける場合の数\n    for(int i=0;i<=min(n,r);i++) S[i][i]=1;\n    for(int i=0;i<=n;i++) S[i][1]=1;\n    for(int i=2;i<=n;i++){\n        for(int j=2;j<=r;j++){\n            S[i][j] = S[i-1][j-1] + S[i-1][j] * j;\n        }\n    }\n    mint res = 0;\n    for(int j=0;j<=r;j++) res+=S[n][j];\n    return res;\n}\n//区別できるボール/区別できない箱/1個以下\nmint ball_8(int n,int r){\n    return n<=r;\n}\n//区別できるボール/区別できない箱/1個以上 スターリング数 \nmint ball_9(int n,int r){\n    BigCombination B;\n    mint res = 0;\n    for(int i=0;i<r;i++){\n        mint x = B.combination(r,i) * pow((r-i), n, MOD);\n        if (i&1) x *= -1;\n        res += x;\n    }\n    return res * B.inv[r]; //ball_3の 1/r!倍\n}\n//区別できないボール/区別できない箱/制限なし 分割数\nmint ball_10(int n,int r){\n    vector<vector<mint>> P(n+1,vector<mint>(r+1,0));\n    REP(j,r+1) P[0][j]=1;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=r;j++){\n            P[i][j] = P[i][j-1]; //0を含む\n            if (i-j>=0) P[i][j] += P[i-j][j]; //0を含まない\n        }\n    }\n    return P[n][r];\n}\n//区別できないボール/区別できない箱/1個以下\nmint ball_11(int n,int r){\n    return n<=r;\n}\n//区別できないボール/区別できない箱/1個以上 分割数\nmint ball_12(int n,int r){\n    if (n-r<0) return 0;\n    return ball_10(n-r,r);\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,r;\n    cin >> n >> r;\n\n    mint ans=ball_12(n,r);\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\n/* constant */\nconst int INF = 1 << 30;\nconst int NIL = -1;\nconst int MAX = 10000;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\nstruct mint {\n    ll x;\n    mint(ll x = 0):x((x % mod + mod) % mod) {}\n    mint operator-() const { return mint(-x); }\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nstruct Partition {\n    vector<vector<mint> > P;\n    Partition(int m) : P(m + 1, vector<mint>(m + 1, 0)) {\n        for (int k = 0; k <= m; ++k) P[0][k] = 1;\n        for (int n = 1; n <= m; ++n) {\n            for (int k = 1; k <= m; ++k) {\n                P[n][k] = P[n][k-1] + (n-k >= 0 ? P[n-k][k] : 0);\n            }\n        }\n    }\n    mint operator()(int n, int k) {\n        if (n < 0 || k < 0) return 0;\n        return P[n][k];\n    }\n};\n/* global variables */\n/* function */\n/* main */\nint main() {\n    int n, k;\n    cin >> n >> k;\n    if (n < k) { cout << 0 << '\\n'; return 0; }\n    Partition p = Partition(max(n, k));\n    cout << p(n - k, k) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\n\n\n//---------------------------------------------------------------\ntemplate<int MOD> struct ModInt { int x;\n    explicit operator bool() const { return !!x; }\n    ModInt(int v = 0) : x(v % MOD) { if (x < 0) x += MOD; }\n    ModInt(long long v) : x(v % MOD) { if (x < 0) x += MOD; }\n    ModInt &operator+=(const ModInt &r) { if ((x += r.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt &r) { if ((x += MOD - r.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(const ModInt &r) { x = 1LL * x * r.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt &r) { return *this *= r.inv(); }\n    ModInt operator-() const { return x ? ModInt(MOD - x) : ModInt(x); }\n    ModInt operator+(const ModInt &r) const { return ModInt(*this) += r; }\n    ModInt operator-(const ModInt &r) const { return ModInt(*this) -= r; }\n    ModInt operator*(const ModInt &r) const { return ModInt(*this) *= r; }\n    ModInt operator/(const ModInt &r) const { return ModInt(*this) /= r; }\n    ModInt inv() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }\n        return ModInt(u); } // x.pow(MOD-2)\n    ModInt pow(long long k) const { ModInt r(1), a(x);\n        while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\n    bool operator==(const ModInt r) const { return x == r.x; }\n    bool operator!=(const ModInt r) const { return x != r.x; }\n    bool operator< (const ModInt r) const { return x <  r.x; }\n    friend ostream& operator<<(ostream &os, const ModInt<MOD>& a) { return os << a.x; }\n    friend istream& operator>>(istream &is, ModInt<MOD>& a) { return is >> a.x; }\n};\ntemplate<typename T, int SZ> struct Comb { vector<T> _fac, _ifac, _inv;\n    Comb() : _fac(SZ + 1), _ifac(SZ + 1), _inv(SZ + 1) {\n        _fac[0] = _ifac[SZ] = _inv[0] = 1;\n        for (int i = 1; i <= SZ; i++) _fac[i] = _fac[i - 1] * i;\n        _ifac[SZ] /= _fac[SZ];\n        for (int i = SZ - 1; i >= 0; i--) _ifac[i] = _ifac[i + 1] * (i + 1);\n        for (int i = 1; i <= SZ; i++) _inv[i] = _ifac[i] * _fac[i - 1]; }\n    T inv(int n) { return n < 0 ? T(0) : _inv[n]; }\n    T fac(int n) { return n < 0 ? T(0) : _fac[n]; }\n    T ifac(int n) { return n < 0 ? T(0) : _ifac[n]; }\n    T P(int a, int b) { return (b < 0 || a < b) ? T(0) : _fac[a] * _ifac[a - b]; }\n    T C(int a, int b) { return b < 0 ? T(0) : P(a, b) * _ifac[b]; }\n    T H(int n, int k) { if (n < 0 || k < 0) return T(0);\n        return k == 0 ? T(0) : C(n + k - 1, k); }\n    T S(int n, int k) { T r = 0;\n        for (int i = 0; i <= k; i++) {\n            T t = C(k, i) * T(i).pow(n); r += ((k - i) & 1 ? -t : t);\n        }\n        return r * _ifac[k];\n    }\n};\ntypedef ModInt<MOD> mint;\n//---------------------------------------------------------------\n\ntemplate<typename T>\nvector<vector<T>> partition_table(int n, int k) {\n    vector<vector<T>> dp(n + 1, vector<T>(k + 1));\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; i++) for (int j = 1; j <= k; j++) {\n        if (i - j >= 0) dp[i][j] = dp[i][j - 1] + dp[i - j][j];\n        else dp[i][j] = dp[i][j - 1];\n    }\n    return dp;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    cout << (n >= k ? partition_table<mint>(n - k, k)[n - k][k] : 0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MOD 1000000007\n\nint dp[1010][1010];\n//dp[n][k]=nをk個以下の整数の和で表す場合の数\n//        =nをk以下の整数の和で表す場合の数\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int j=0;j<=m;j++)dp[0][j]=1;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=m;j++)dp[i][j]=(dp[i][j-1]+(i-j>=0?dp[i-j][j]:0))%MOD;\n\tprintf(\"%d\\n\",(dp[n][m]-dp[n][m-1]+MOD)%MOD);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\n\nvoid run (void) {\n  i32 n, k;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &k);\n  if (n < k) {\n    puts(\"0\");\n    return;\n  }\n  n -= k;\n  const i32 mod = 1000000007;\n  i32 *dp = (i32 *) calloc (n + 1, sizeof (i32));\n  dp[0] = 1;\n  for (i32 i = 1; i <= k; ++i) {\n    for (i32 j = i; j <= n; ++j) {\n      dp[j] += dp[j - i];\n      dp[j] %= mod;\n    }\n  }\n  printf (\"%\" PRIi32 \"\\n\", dp[n]);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_5_L Balls and Boxes 12\n// n 個の区別できないボールを k 個の区別できない箱に入れる\n// とき、可能な入れ方の総数を求めてください。\n// ただし、\n//    どのボールも、必ずいずれかの箱に入れる。\n//    どの箱にも、1つ以上のボールを入れる。\n// 答えは制限付き分割数 divnum(n-k, k)\n// 2019.3.11 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\nint tbl[1001][1001];\n\nint divnum(int n, int k)\n{\n\tint ans;\n\n\tif (tbl[n][k]) return tbl[n][k];\n\tif (n < 0) return 0;\n\tif (n == 0 || n == 1 || k == 1) return 1;\n\telse {\n\t\tans = divnum(n, k - 1);\n\t\tif (n >= k) ans += divnum(n - k, k);\n\t}\n\treturn tbl[n][k] = ans % MOD;\n}\n\nint main()\n{\n\tint n, k;\n\n\tscanf(\"%d%d\", &n, &k);\n\tif (n < k) puts(\"0\");\n\telse printf(\"%d\\n\", divnum(n-k, k));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//Twelvefold way[syazou 12-sou]\n#include<stdio.h>\n#define mod 1000000007\n#define faclim 1048576\n#define partition_nlim 1024\n#define partition_klim 1024\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long factorial[faclim];\nlong long invfact[faclim];\nlong long bce[faclim];\n\nvoid cfact(){\n  long long i;\n  factorial[0]=1;\n  factorial[1]=1;\n  for(i=2;i<faclim;i++){\n    factorial[i]=factorial[i-1]*i;\n    factorial[i]%=mod;\n  }\n  invfact[faclim-1]=modular_inverse(factorial[faclim-1]);\n  for(i=faclim-2;i>=0;i--){\n    invfact[i]=invfact[i+1]*(i+1);\n    invfact[i]%=mod;\n  }\n  for(i=0;i<faclim;i++){\n    if(i%2==1){bce[i]=mod-1;}\n    else{bce[i]=1;}\n    bce[i]*=invfact[i];\n    bce[i]%=mod;\n    if(i!=0){\n      bce[i]+=bce[i-1];\n      if(bce[i]>=mod){bce[i]-=mod;}\n    }\n  }\n}\n\nlong long calcnCr(long long n,long long k){\n  if(k<0 || n<k){return 0;}\n  return (factorial[n]*((invfact[k]*invfact[n-k])%mod))%mod;\n}\n\nlong long partition[partition_nlim][partition_klim];\nlong long partition_isinit=0;\n\nvoid partition_init(){\n  if(partition_isinit==1){return;}\n  partition_isinit=1;\n  long long i,j;\n  for(i=0;i<partition_nlim;i++){\n    for(j=0;j<partition_klim;j++){\n      partition[i][j]=-1;\n    }\n  }\n}\n\nlong long partition_rep(long long n,long long k){\n  if(n<0 || k<0){return 0;}\n  if(n==0){return 1;}\n  if(k==0){\n    if(n==0){return 1;}\n    else{return 0;}\n  }\n  if(partition[n][k]!=-1){return partition[n][k];}\n  partition[n][k]=(partition_rep(n,k-1)+partition_rep(n-k,k))%mod;\n  return partition[n][k];\n}\n\n// packing n balls using k boxes\n// |  distinguish  |  each boxes contains the balls limited  |\n// | balls | boxes |  no limits  |  at most 1  | at least 1  |\n// |  can  |  can  |      1      |      2      |      3      |\n// | can't |  can  |      4      |      5      |      6      |\n// |  can  | can't |      7      |      8      |      9      |\n// | can't | can't |     10      |     11      |     12      |\n\nlong long twelvefold_way(long long n,long long k,long long type){\n  long long i,r=0,dt;\n  switch(type){\n    case 1:\n      return power(k,n);\n      break;\n    case 2:\n      if(k<n){return 0;}\n      return (factorial[k]*invfact[k-n])%mod;\n      break;\n    case 3:\n      if(n<k){return 0;}\n      for(i=0;i<=k;i++){\n        dt=(calcnCr(k,i)*power(i,n))%mod;\n        if((k-i)%2==1){r+=(mod-dt);}\n        else{r+=dt;}\n        if(r>=mod){r-=mod;}\n      }\n      return r;\n      break;\n    case 4:\n      return calcnCr(n+k-1,n);\n      break;\n    case 5:\n      if(k<n){return 0;}\n      return calcnCr(k,n);\n      break;\n    case 6:\n      if(n<k){return 0;}\n      return calcnCr(n-1,k-1);\n      break;\n    case 7:\n      for(i=0;i<=k;i++){\n        dt=(power(i,n)*invfact[i])%mod;\n        r+=dt*bce[k-i];\n        r%=mod;\n      }\n      return r;\n    case 8:\n      if(k<n){return 0;}\n      return 1;\n      break;\n    case 9:\n      if(n<k){return 0;}\n      for(i=0;i<=k;i++){\n        dt=(calcnCr(k,i)*power(i,n))%mod;\n        if((k-i)%2==1){r+=(mod-dt);}\n        else{r+=dt;}\n        if(r>=mod){r-=mod;}\n      }\n      r*=invfact[k];r%=mod;\n      return r;\n      break;\n    case 10:\n      partition_init();\n      return partition_rep(n,k);\n      break;\n    case 11:\n      if(k<n){return 0;}\n      return 1;\n      break;\n    case 12:\n      if(n<k){return 0;}\n      partition_init();\n      return partition_rep(n-k,k);\n      break;\n  }\n}\n\nint main(){\n  cfact();\n  long long n,k;\n  scanf(\"%lld%lld\",&n,&k);\n  printf(\"%lld\\n\",twelvefold_way(n,k,12));\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h> // uint64_t\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\n#define BUF_SIZE 20\n#define DIVISOR 1000000007\n\nint get_int2(int *a1, int *a2) {\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return -1;\n  sscanf(line, \"%d %d\", a1, a2);\n#else\n#error\n#endif\n  return 0;\n}\n\n#define NUM_MAX 1000\n#define K_MAX 1000\n\n// pdp[# of partitions][# of balls]\nstatic uint64_t pdp[K_MAX+1][NUM_MAX+1];\nvoid init() {\n    pdp[0][0] = 1;\n    int i, j;\n    for(i = 1; i <= K_MAX; i++) {\n        for(j = 0; j <= NUM_MAX; j++) {\n            pdp[i][j] = pdp[i-1][j];\n            if(j>=i) pdp[i][j] = (pdp[i][j] + pdp[i][j-i])%DIVISOR;\n        }\n    }\n    return;\n}\n\nint main(void) {\n    int n, k;\n    get_int2(&n, &k);\n    init();\n    uint64_t ans = (n-k>=0) ? (int)pdp[k][n-k] : 0;\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n \npublic class Main implements Runnable {\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        FastScanner sc = new FastScanner();\n        \n        int n = sc.nextInt();\n        int k = sc.nextInt();\n\n    \tSystem.out.println(partition(n-k,k));\n\n    }\n    \n\t//分割数をdpで求める\n\t//nをk個の非負整数の和で表す（⇔k個以下の自然数の和で表す）場合の数\n\tstatic int partition(int n, int k){\n\t\tif(n<0){return 0;} //こうしておくことで、partition(n-k,k)でnを丁度k個の自然数で表す組合せの数を計算できる\n\t\tif(n==0){return 1;}\n\t\tint mod = 1000000007;\n\t\tif(k>n){k=n;} //無駄な計算を省ける。テーブルごと使う場合は注意。\n\t\tint[][] dp = new int[n+1][k+1];\n\t\tdp[0][0] = 1;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tdp[i][1] = 1; \n\t\t}\n\t\tfor(int i=2;i<=k;i++){\n\t\t\tdp[0][i] = 1;\n\t\t\tdp[1][i] = 1; \n\t\t}\n\t\t\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=2;j<=k;j++){\n\t\t\t\tif(i-j>=0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + dp[i-j][j]; //0を最低1つ含む + 丁度k個の自然数の和\n\t\t\t\t\tdp[i][j] %= mod;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dp[n][k];\n\t}\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextIntArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int K = cin.nextint;\n        var ncr = new BinomialCoefficient(N + K);\n\n        N -= K;\n        if (N < 0)\n        {\n            WriteLine(0);\n            return;\n        }\n        var dp = new ModInt[N + 1][];\n        for (int i = 0; i < dp.Length; i++)\n        {\n            dp[i] = new ModInt[K + 1];\n        }\n        dp[0][0] = 1;\n        for (int i = 0; i <= N; i++)\n        {\n            for (int j = 0; j <= K; j++)\n            {              \n                if(j + 1 <= K) dp[i][j + 1] += dp[i][j];\n                if (i + j <= N) dp[i + j][j] += dp[i][j];\n            }\n            //dp[i].join();\n        }\n        WriteLine(dp[N][K]);\n    }\n\n}\n\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\n/// <OriginalAuthor>camypaper</OriginalAuthor>\nstruct ModInt\n{\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k)\n    {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n\nclass BinomialCoefficient\n{\n    public ModInt[] fact, ifact;\n    public BinomialCoefficient(int n)\n    {\n        fact = new ModInt[n + 1];\n        ifact = new ModInt[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = ModInt.Inverse(fact[n]);\n        for (int i = n - 1; i >= 0; i--)\n            ifact[i] = ifact[i + 1] * (i + 1);\n        ifact[0] = ifact[1];\n    }\n    public ModInt this[int n, int r]\n    {\n        get\n        {\n            if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n            return fact[n] * ifact[n - r] * ifact[r];\n        }\n    }\n    public ModInt RepeatedCombination(int n, int k)\n    {\n        if (k == 0) return 1;\n        return this[n + k - 1, k];\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\n\tstatic void Main()\n\t{\n    string[] input = Console.ReadLine().Split(' ');\n    long n = long.Parse(input[0]);\n    long k = long.Parse(input[1]);\n    long p = 1000000007;\n\n    if(n-k < 0) Console.WriteLine(0);\n    else Console.WriteLine(SplitNumber(n-k,k,p));\n\t}\n\n  static long SplitNumber(long n, long k, long mod)\n  {//区別しないn個の玉を区別しないk個の箱に分ける方法の個数(mod)をO(nk)で返す。\n  //数え方は、dp[n,k]は、0個の箱を含む時+dp[n,k-1]、含まない時+dp[n-k,k]とする。\n    long[,] dp = new long[n+1,k+1];\n    \n    for(int i = 0; i <= k; i++)\n    {\n      dp[0,i] = 1;\n      for(int j = 1; j <= n; j++)\n      {\n        if(j-i >= 0) dp[j,i] += dp[j-i,i];\n        if(i-1 >= 0) dp[j,i] += dp[j,i-1];\n     \n        dp[j,i] %= mod;\n      }\n    }\n\n    return dp[n,k];\n  }\n  \n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace CsharpSpiral {\n    partial class Program {\n        static void Main(string[] args) {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            new Program().Solve(new ConsoleInput(Console.In, ' '));\n            Console.Out.Flush();\n        }\n        public void Solve(ConsoleInput cin) {\n            var n = cin.ReadInt;\n            var k = cin.ReadInt;\n            n -= k;\n            if(n < 0) { Console.WriteLine(0); return; }\n            const int modulo = 1000000007;\n            var F = new ResidueField(modulo);\n            var P = new long[n+1, k+1];\n            for(int i = 0; i <= n; i++) {\n                P[i, 0] = 0;\n                if(k >= 1) P[i, 1] = 1;\n            }\n            for(int j = 0; j <= k; j++) {\n                P[0, j] = 1;\n                if(n >= 1) P[1, j] = 1;\n            }\n            for(int i = 2; i <= n; i++) {\n                for(int j = 2; j <= k && i - j >= 0; j++) {\n                    P[i, j] = F.Add(P[i, j - 1], P[i - j, j]);\n                }\n                for(int j = i + 1; j <= k; j++) {\n                    P[i, j] = P[i, j - 1];\n                }\n            }\n            Console.WriteLine(P[n,k]);\n        }\n        class ResidueField {\n            public readonly long modulo;\n            public ResidueField(int mModulo) {\n                modulo = mModulo;\n            }\n            private long[] factorialTable = { 1 };\n            private int factorialTableLastIndex { get { return factorialTable.Length - 1; } }\n            public long mod(long x) => x < 0 ? x % modulo + modulo : x % modulo;\n            public long Add(long a, long b) => mod(a + b);\n            public long Sub(long a, long b) => mod(a - b);\n            public long Mul(long a, long b) => mod(a * b);\n            public long Pow(long a, long n) {\n                if(n == 0) return 1;\n                var R = 1L;\n                n = n < 0 ? n % (modulo - 1) + (modulo - 1) : n % (modulo - 1);\n                for(; n > 0; a = Mul(a, a), n >>= 1) {\n                    if((n & 1) != 0) R = Mul(R, a);\n                }\n                return R;\n            }\n            private static long extgcd(long a, long b, ref long x, ref long y) {\n                if(b == 0) {\n                    x = 1; y = 0; return a;\n                }\n                var q = a / b;\n                var g = extgcd(b, a - q * b, ref x, ref y);\n                var z = x - q * y;\n                x = y; y = z;\n                return g;\n            }\n            public long Inv(long a) {\n                if(a == 0) throw new DivideByZeroException();\n                long x = 0, y = 0;\n                extgcd(a, modulo, ref x, ref y);\n                return mod(x);\n            }\n            public long Div(long a, long b) => Mul(a, Inv(b));\n            public void ExpandFactorialTable(int N) {\n                var k = factorialTableLastIndex;\n                Array.Resize(ref factorialTable, N + 1);\n                for(int i = k + 1; i <= N; i++) {\n                    if(i == 0) { factorialTable[i] = 1; continue; }\n                    factorialTable[i] = Mul(factorialTable[i - 1], i);\n                }\n            }\n            public long Factorial(int n) {\n                if(n > factorialTableLastIndex)\n                    ExpandFactorialTable(n);\n                return factorialTable[n];\n            }\n            public long Permutation(int n, int k) {\n                if(k < 0 || k > n) return 0;\n                return Div(Factorial(n), Factorial(n - k));\n            }\n            public long Combination(int n, int k) {\n                if(k < 0 || k > n) return 0;\n                return Div(Factorial(n), Mul(Factorial(k), Factorial(n - k)));\n            }\n            \n        }\n    }\n\n    static class ExtendClass {\n        public static string Join<T>(this IEnumerable<T> X, string separator = \" \") => string.Join(separator, X);\n    }\n\n    class ConsoleInput {\n        private readonly TextReader _stream;\n        private readonly char _separator = ' ';\n        private readonly Queue<string> inputStream;\n        public ConsoleInput(TextReader stream, char separator = ' ') {\n            this._separator = separator;\n            this._stream = stream;\n            inputStream = new Queue<string>();\n        }\n        public string Read {\n            get {\n                if(inputStream.Count != 0) return inputStream.Dequeue();\n                string[] tmp = _stream.ReadLine().Split(_separator);\n                for(int i = 0; i < tmp.Length; ++i)\n                    inputStream.Enqueue(tmp[i]);\n                return inputStream.Dequeue();\n            }\n        }\n        public string ReadLine { get { return _stream.ReadLine(); } }\n        public int ReadInt { get { return int.Parse(Read); } }\n        public long ReadLong { get { return long.Parse(Read); } }\n        public double ReadDouble { get { return double.Parse(Read); } }\n        public string[] ReadStrArray(long N) {\n            var ret = new string[N];\n            for(long i = 0; i < N; ++i)\n                ret[i] = Read;\n            return ret;\n        }\n        public int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i < N; ++i) ret[i] = ReadInt; return ret; }\n        public long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i < N; ++i) ret[i] = ReadLong; return ret; }\n        public double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i < N; ++i) ret[i] = ReadDouble; return ret; }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int K = cin.nextint;\n        var ncr = new BinomialCoefficient(N + K);\n\n        N -= K;\n        var dp = new ModInt[N + 1][];\n        for (int i = 0; i < dp.Length; i++)\n        {\n            dp[i] = new ModInt[K + 1];\n        }\n        dp[0][0] = 1;\n        for (int i = 0; i <= N; i++)\n        {\n            for (int j = 0; j <= K; j++)\n            {              \n                if(j + 1 <= K) dp[i][j + 1] += dp[i][j];\n                if (i + j <= N) dp[i + j][j] += dp[i][j];\n            }\n            //dp[i].join();\n        }\n        WriteLine(dp[N][K]);\n    }\n\n}\n\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\n/// <OriginalAuthor>camypaper</OriginalAuthor>\nstruct ModInt\n{\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k)\n    {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n\nclass BinomialCoefficient\n{\n    public ModInt[] fact, ifact;\n    public BinomialCoefficient(int n)\n    {\n        fact = new ModInt[n + 1];\n        ifact = new ModInt[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = ModInt.Inverse(fact[n]);\n        for (int i = n - 1; i >= 0; i--)\n            ifact[i] = ifact[i + 1] * (i + 1);\n        ifact[0] = ifact[1];\n    }\n    public ModInt this[int n, int r]\n    {\n        get\n        {\n            if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n            return fact[n] * ifact[n - r] * ifact[r];\n        }\n    }\n    public ModInt RepeatedCombination(int n, int k)\n    {\n        if (k == 0) return 1;\n        return this[n + k - 1, k];\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "MOD = 1_000_000_007\n\ndef memoize(name)\n  original = \"__original_#{name}__\"\n  self.class.class_eval {\n    alias_method(original, name)\n    private(original)\n    cache = {}\n    define_method(name){|*args|\n      cache[args] ||= send(original, *args)\n    }\n  }\nend \n\ndef f(n, k)\n  return 1 if n == 0\n  return 0 if n < 0\n  return 0 if k == 0\n  (f(n, k-1) + f(n-k, k)) % MOD\nend\n\nmemoize :f\n\nn, k = gets.split.map(&:to_i)\np f(n - k, k)\n"
  },
  {
    "language": "Ruby",
    "code": "s,n=gets.split.map &:to_i;s-=n;p s<0?0:(b=[1]+[0]*s;1.upto(n){|i|i.upto(s){|j|b[j]=(b[j-i]+b[j])%(10**9+7)}};b[s])\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc configure(scanner *bufio.Scanner) {\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanned := scanner.Scan()\n\tif !scanned {\n\t\tpanic(\"scan failed\")\n\t}\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\textra := 0\n\tif os.Getenv(\"I\") == \"IronMan\" {\n\t\tfp, _ = os.Open(os.Getenv(\"END_GAME\"))\n\t\textra = 100\n\t}\n\tscanner := bufio.NewScanner(fp)\n\tconfigure(scanner)\n\twriter := bufio.NewWriter(wfp)\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tfmt.Fprintln(writer, r)\n\t\t}\n\t\twriter.Flush()\n\t}()\n\tsolve(scanner, writer)\n\tfor i := 0; i < extra; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tn := getNextInt(scanner)\n\tk := getNextInt(scanner)\n\tdp := makeGrid(n+1, k+1)\n\tdp[0][0] = 1\n\tfor i := 1; i < n+1; i++ {\n\t\tfor j := 1; j < k+1; j++ {\n\t\t\tdp[i][j].addAs(dp[i-1][j-1])\n\t\t\tif i-j >= 0 {\n\t\t\t\tdp[i][j].addAs(dp[i-j][j])\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Fprintln(writer, dp[n][k])\n}\n\nfunc makeGrid(h, w int) [][]mint {\n\tindex := make([][]mint, h, h)\n\tdata := make([]mint, h*w, h*w)\n\tfor i := 0; i < h; i++ {\n\t\tindex[i] = data[i*w : (i+1)*w]\n\t}\n\treturn index\n}\n\ntype mint int64\n\nfunc (mt mint) mod() mint {\n\tm := mint(1e9 + 7)\n\tmt %= m\n\tif mt < 0 {\n\t\treturn mt + m\n\t}\n\treturn mt\n}\nfunc (mt mint) inv() mint {\n\treturn mt.pow(mint(0).sub(2))\n}\nfunc (mt mint) pow(n mint) mint {\n\tp := mint(1)\n\tfor n > 0 {\n\t\tif n%2 == 1 {\n\t\t\tp.mulAs(mt)\n\t\t}\n\t\tmt.mulAs(mt)\n\t\tn >>= 1\n\t}\n\treturn p\n}\nfunc (mt mint) add(x mint) mint {\n\treturn (mt + x).mod()\n}\nfunc (mt mint) sub(x mint) mint {\n\treturn (mt - x).mod()\n}\nfunc (mt mint) mul(x mint) mint {\n\treturn (mt * x).mod()\n}\nfunc (mt mint) div(x mint) mint {\n\treturn mt.mul(x.inv())\n}\nfunc (mt *mint) addAs(x mint) *mint {\n\t*mt = mt.add(x)\n\treturn mt\n}\nfunc (mt *mint) subAs(x mint) *mint {\n\t*mt = mt.sub(x)\n\treturn mt\n}\nfunc (mt *mint) mulAs(x mint) *mint {\n\t*mt = mt.mul(x)\n\treturn mt\n}\nfunc (mt *mint) divAs(x mint) *mint {\n\t*mt = mt.div(x)\n\treturn mt\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nN, K = map(int, input().split())\nMOD = 10**9 + 7\n\ndef partition_num(n, k, mod):\n    partition = {i: defaultdict(int) for i in range(n + 1)}\n    for j in range(1, k+1):\n        partition[0][j] = 1\n    for i in range(1, n+1):\n        partition[i][1] = 1\n        for j in range(2, k+1):\n            if i - j >= 0:\n                partition[i][j] = (partition[i][j - 1] + partition[i - j][j]) % mod\n            else:\n                partition[i][j] = partition[i][j - 1] % mod\n    return partition\nif N-K >= 0:\n    p = partition_num(N-K, K, MOD)\n    ans = p[N-K][K]\nelse:\n    ans = 0\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nmod = 10 ** 9 + 7\nP = [[0] * (K + 1) for i in range(N + 1)]\nfor i in range(1, N + 1):\n\tP[i][1] = 1\nfor i in range(1, min(N, K) + 1):\n\tP[i][i] = 1\nfor n in range(1, N + 1):\n\tfor k in range(2, min(n - 1, K) + 1):\n\t\tP[n][k] = (P[n - k][k] + P[n - 1][k - 1]) % mod\nprint(P[N][K])\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom functools import lru_cache\nsys.setrecursionlimit(500000)\nmod = 10**9+7\n@lru_cache(maxsize=None)\ndef partition(n, k):  # 自然数 n を k 個の自然数の和で表す場合の数\n    if n < 0 or n < k:\n        return 0\n    elif k == 1 or n == k:\n        return 1\n    else:\n        return (partition(n-k, k) + partition(n-1, k-1)) % mod  # 1 を使わない場合と使う場合の和\nn, k = map(int, input().split())\nprint(partition(n, k))\n\n"
  },
  {
    "language": "Python",
    "code": "n, k = map(int, input().split())\nMOD = pow(10,9)+7\nif n < k:print(0)\nelse:\n    n = n-k\n    dp = [[0]*(n+1) for _ in range(k+1)]\n    dp[0][0] = 1\n    for i in range(1,k+1):\n        for j in range(n+1):\n            if j-i >= 0:\n                dp[i][j] = (dp[i-1][j] + dp[i][j-i]) % MOD\n            else:\n                dp[i][j] = dp[i-1][j]\n    print(dp[k][n])\n"
  },
  {
    "language": "Python",
    "code": "#!python3\n\niim = lambda: map(int, input().rstrip().split())\nfrom itertools import chain, repeat\n\ndef resolve():\n    N, K = iim()\n\n    if N < K:\n        print(0)\n        return\n    if N == 1 or K == 1:\n        print(1)\n        return\n\n    mod = 10**9 + 7\n\n    dp = [[0]*(K+1) for i in range(N+1)]\n    dp[0][0] = 1\n\n    for i, kx, i0 in zip( range(1, N+1), chain(range(1, K), repeat(K)), chain(repeat(1, N+1-K), range(2, K+1))):\n        #print(i, kx, i0)\n        for k in range(i0, kx + 1):\n            dp[i][k] = dp[i-1][k-1] + dp[i-k][k]\n\n    #for row in  dp:\n    #    print(row)\n\n    print(dp[N][K] % mod)\n\nif __name__ == \"__main__\":\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\nMOD = 10**9 + 7\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    n, k = LI()\n\n    if n - k >= 0:\n        dp = [[0] * (k + 1) for _ in range(n - k + 1)]\n        for i in range(k + 1):\n            dp[0][i] = 1\n\n        for i in range(n - k):\n            for j in range(k):\n                if i - j >= 0:\n                    dp[i+1][j+1] = dp[i+1][j] + dp[i-j][j+1]\n                else:\n                    dp[i+1][j+1] = dp[i+1][j]\n                dp[i+1][j+1] %= MOD\n\n        print(dp[-1][-1])\n    else:\n        print(0)\n\nif __name__ == '__main__':\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "def way12(ball, box):\n    \"\"\"ball: False / box: False / constraints: 1 or more\n    ans = P(ball - box, box)  Pは分割数 / 計算量 O(ball * box)\n    \"\"\"\n    if ball < box: \n        return 0\n \n    # P[i][j] := 整数iを順序を区別せずに「j以下の自然数」の和に分ける場合の数\n    diff = ball - box\n    P = [[0] * (diff + 1) for _ in range(diff + 1)]\n    for j in range(diff + 1):\n        P[0][j] = 1\n    for i in range(diff):\n        for j in range(diff):\n            if i - j >= 0:\n                P[i + 1][j + 1] = (P[i + 1][j] + P[i - j][j + 1]) % MOD\n            else:\n                P[i + 1][j + 1] = P[i + 1][j]\n\n    return P[diff][min(diff, box)]\n\n\nn, k = map(int, input().split())\nMOD = 10 ** 9 + 7\n\nprint(way12(n, k))\n"
  },
  {
    "language": "Python",
    "code": "class Twelvefold(): #n <= 1000程度\n    def __init__(self, n, mod, build=True):\n        self.mod = mod\n        self.fct = [0 for _ in range(n + 1)]\n        self.inv = [0 for _ in range(n + 1)]\n        self.fct[0] = 1\n        self.inv[0] = 1\n        for i in range(n):\n            self.fct[i + 1] = self.fct[i] * (i + 1) % mod\n        self.inv[n] = pow(self.fct[n], mod - 2, mod)\n        for i in range(n)[::-1]:\n            self.inv[i] = self.inv[i + 1] * (i + 1) % mod\n        if build: self.build(n)\n\n    def build(self, n):\n        self.stl = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        self.bel = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        self.prt = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        self.stl[0][0] = 1\n        self.bel[0][0] = 1\n        for i in range(n):\n            for j in range(n):\n                self.stl[i + 1][j + 1] = self.stl[i][j] + (j + 1) * self.stl[i][j + 1]\n                self.stl[i + 1][j + 1] %= self.mod\n        for i in range(n):\n            for j in range(n):\n                self.bel[i + 1][j + 1] = self.bel[i + 1][j] + self.stl[i + 1][j + 1] % self.mod\n                self.bel[i + 1][j + 1] %= self.mod\n        for j in range(n + 1):\n            self.prt[0][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if i - j >= 0:\n                    self.prt[i + 1][j + 1] = self.prt[i + 1][j] + self.prt[i - j][j + 1]\n                else:\n                    self.prt[i + 1][j + 1] = self.prt[i + 1][j]\n                self.prt[i + 1][j + 1] %= self.mod\n\n    def solve(self, element, subset, equate_element=False, equate_subset=False, less_than_1=False, more_than_1=False):\n        assert not less_than_1 or not more_than_1\n        n = element\n        k = subset\n        a = equate_element\n        b = equate_subset\n        c = less_than_1\n        d = more_than_1\n        id = a * 3 + b * 6 + c + d * 2\n        tw = [self.tw1, self.tw2, self.tw3, self.tw4, self.tw5, self.tw6, self.tw7, self.tw8, self.tw9, self.tw10, self.tw11, self.tw12]\n        return tw[id](n, k)\n\n    def tw1(self, n, k):\n        return pow(k, n, self.mod)\n\n    def tw2(self, n, k):\n        if k - n < 0: return 0\n        return self.fct[k] * self.inv[k - n] % self.mod\n\n    def tw3(self, n, k):\n        return self.stl[n][k] * self.fct[k] % self.mod\n\n    def tw4(self, n, k):\n        if k == 0: return 0\n        return self.fct[n + k - 1] * self.inv[n] * self.inv[k - 1] % self.mod\n\n    def tw5(self, n, k):\n        if k - n < 0: return 0\n        return self.fct[k] * self.inv[n] * self.inv[k - n] % self.mod\n\n    def tw6(self, n, k):\n        if n - k < 0 or k == 0: return 0\n        return self.fct[n - 1] * self.inv[k - 1] * self.inv[n - k] % self.mod\n\n    def tw7(self, n, k):\n        return self.bel[n][k]\n\n    def tw8(self, n, k):\n        if k - n < 0: return 0\n        return 1\n\n    def tw9(self, n, k):\n        return self.stl[n][k]\n\n    def tw10(self, n, k):\n        return self.prt[n][k]\n\n    def tw11(self, n, k):\n        if k - n < 0: return 0\n        return 1\n\n    def tw12(self, n, k):\n        if n - k < 0: return 0\n        return self.prt[n - k][k]\n\nn, k = map(int, input().split())\nt = Twelvefold(1000, 10**9 + 7, 1)\nprint(t.solve(n, k, 1, 1, 0, 1))\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef comb(n, k):\n    if n < 0 or k < 0 or n < k: return 0\n    return math.factorial(n) // math.factorial(n-k) // math.factorial(k)\n\n\n\nn,k = map(int, input().split())\nMOD = 10 ** 9 + 7\n\ndp = [[0] * (n+1)] * (k+1)\n\ndp[0][0] = 1\nfor i in range(1, k+1):\n    for j in range(n+1):\n        if j >= i: dp[i][j] = (dp[i-1][j] + dp[i][j-i])%MOD\n        else: dp[i][j] = dp[i-1][j]\n\nif n >= k: print(dp[k][n-k])\nelse: print(0)\n"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nMOD = 10**9 + 7\n\nD = [[0]*(K+1) for i in range(N+1)]\nfor i in range(1, N+1):\n    D[i][1] = 1\nfor i in range(1, min(N, K)+1):\n    D[i][i] = 1\nfor n in range(1, N+1):\n    for k in range(2, min(n-1, K)+1):\n        D[n][k] = (D[n-k][k] + D[n-1][k-1]) % MOD\nprint(D[N][K] % MOD)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: map(int, sys.stdin.readline().split())\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\ndef prepare(n, MOD):\n    # 1! - n! の計算\n    f = 1\n    factorials = [1]  # 0!の分\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 の計算\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 の計算\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef main():\n    n, m = ns()\n\n    if n < m:\n        print(0)\n        exit()\n    else:\n        n -= m\n    # 分割数：N個の数をK個に分ける方法\n    # 分けたものは区別できないので、3を[1,2],[2,1]のように分けるのは合わせて1カウント\n    # dp[i][j] = dp[i][j-i] + dp[i-1][j] jをi個に分割する数\n    # 蟻本P66\n\n    dp = [[0 for _ in range(n + 1)] for __ in range(m + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(n + 1):\n            if j - i >= 0:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - i]\n            else:\n                dp[i][j] = dp[i - 1][j]\n            dp[i][j] %= MOD\n    print(dp[m][n])\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# (n - k, k) version of DPL_5_J.\nif __name__ == \"__main__\":\n    n, k = map(lambda x: int(x), input().split())\n    if n < k:\n        print(0)\n        exit(0)\n    modulo = 10 ** 9 + 7\n    dp = [[0] * (n + 1 - k)] * (k + 1)\n    dp[0][0] = 1\n    for i in range(1, k + 1):\n        for j in range(n + 1 - k):\n            if i <= j:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - i]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    ans = dp[k][n - k] % modulo\n\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nMOD = 10**9 + 7\n \nD = [[0]*(K+1) for i in range(N+1)]\nfor i in range(1, N+1):\n    D[i][1] = 1\nfor i in range(1, min(N, K)+1):\n    D[i][i] = 1\nfor n in range(1, N+1):\n    for k in range(2, min(n-1, K)+1):\n        D[n][k] = (D[n-k][k] + D[n-1][k-1]) % MOD\nprint(D[N][K] % MOD)\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn partition_number(n: usize, k: usize) -> usize {\n    let p = 1_000_000_007;\n    let mut dp = vec![vec![0; k+1]; n+1];\n    for i in 1..n+1 {\n        dp[i][1] = 1;\n    }\n    for j in 1..k+1 {\n        dp[1][j] = 1;\n    }\n    // P(n,k) = P(n,k-1) + P(n-k,k)\n    for i in 2..n+1 {\n        for j in 2..k+1 {\n            let ex = if i == j {\n                1\n            } else if i > j {\n                dp[i-j][j]\n            } else {\n                0\n            };\n            dp[i][j] = (dp[i][j-1] + ex) % p;\n        }\n    }\n    dp[n][k]\n}\nfn solve() {\n    input! { n: usize, k: usize }\n    let res = if n < k {\n        0\n    } else if n == k {\n        1\n    } else if n - k == 1 {\n        1\n    } else {\n        partition_number(n-k, k)\n    };\n    println!(\"{}\", res);\n}\n"
  }
]