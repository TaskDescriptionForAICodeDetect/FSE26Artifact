[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=3e5+5;\nchar buf[1<<12],*p1=buf,*p2=buf,nc;int ny;\ninline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n,a[MAXN],tot[2],Sum[MAXN];\ninline bool chk(int mid){\n\tint k=0;\n\tfor(int i=2;i<=n;i+=2)if(Sum[i-1]-Sum[k]>=mid)\n\t\tk=min(k,Sum[i]);\n\treturn Sum[n]-k>=mid;\n}\nint main(){\n\tn=read();Rep(i,1,n)tot[i&1]+=a[i]=read();\n\tif(!(n&1))cout<<max(tot[0],tot[1])<<' '<<min(tot[0],tot[1])<<\"\\n\";\n\telse{\n\t\tRep(i,1,n)Sum[i]=Sum[i-1]+(i&1?a[i]:-a[i]);\n\t\tint l=0,r=tot[0]+tot[1],ans=0;\n\t\tfor(int mid;l<=r;)mid=l+r>>1,chk(mid)?l=mid+1,ans=mid:r=mid-1;\n\t\tcout<<tot[0]+ans<<\" \"<<tot[1]-ans<<'\\n';\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std; \nconst int Max_N(300050);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nint N, A[Max_N], white, black, Pre[Max_N];\n\nbool check(int mid)\n{\n\tint nowmin(0);\n\tfor (int i = 1;i <= N;i += 2)\n\t{\n\t\tif (Pre[i] - nowmin >= mid)\n\t\t\tnowmin = min(nowmin, Pre[i + 1]);\n\t}\n\treturn Pre[N] - nowmin >= mid;\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tgi(A[i]);\n\t\tif (i & 1)\n\t\t\tblack += A[i], Pre[i] = Pre[i - 1] + A[i];\n\t\telse\n\t\t\twhite += A[i], Pre[i] = Pre[i - 1] - A[i];\n\t}\n\tif ((N & 1) == 0)\n\t\tprint(max(black, white)), putc(' '), print(min(black, white));\n\telse\n\t{\n\t\tint l = 0, r = black + 1, mid;\n\t\twhile (l < r)\n\t\t{\n\t\t\tmid = l + ((r - l) >> 1);\n\t\t\tif (check(mid))\n\t\t\t\tl = mid + 1;\n\t\t\telse\n\t\t\t\tr = mid;\n\t\t}\n\t\tprint(white + (l - 1)), putc(' '), print(black - (l - 1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn=300111;\nint n;\nint a[maxn];\nll pre[maxn];\nint dp0[maxn],dp1[maxn];\nint cost(int i,int j)\n{\n\treturn pre[j]-pre[i-1];\n}\nvoid out(int x)\n{\n\tint sum=0;\n\tfor(int i=1;i<=n;i++)sum+=a[i];\n//\tcerr<<\"sum=\"<<sum<<endl;\n\tassert((sum+x)%2==0);\n\tcout<<(sum+x)/2<<\" \"<<(sum-x)/2<<endl;\n}\nvoid calcdp(int dp[])\n{\n\tfor(int i=1;i<=n;i+=2)\n\t{\n\t\tdp[i]=cost(1,i);\n\t\tfor(int j=2;j<i;j+=2)\n\t\t{\n\t\t\tdp[i]=max(dp[i],min(dp[j-1]-cost(j,i),cost(j+1,i)-cost(1,j)));\n\t\t}\n\t}\n}\nint main()\n{\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)geti(a[i]);\n\tfor(int i=1;i<=n;i++)pre[i]=pre[i-1]+(i&1?a[i]:-a[i]);\n\tif(n%2==0)\n\t{\n\t\tout(max(pre[n],-pre[n]));\n\t\treturn 0;\n\t}\n\tint ans=pre[n];\n\tint sum=cost(1,n);\n\tcalcdp(dp0);\n\treverse(a+1,a+n+1);\n\tcalcdp(dp1);\n\treverse(a+1,a+n+1);\n\treverse(dp1+1,dp1+n+1);\n//\tfor(int i=1;i<=n;i+=2)cerr<<dp0[i]<<\" \";cerr<<endl;\n//\tfor(int i=1;i<=n;i+=2)cerr<<dp1[i]<<\" \";cerr<<endl;\n\t\n\tfor(int i=2;i<=n;i+=2)\n\t{\n\t\tans=max(ans,min(dp0[i-1]-cost(i,n),dp1[i+1]-cost(1,i)));\n\t}\n\tout(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300005;\nint n, a[N], s[N][2];\nbool f[N];\n\nbool check(int mid) {\n\tf[0] = true;\n\tint mx = 0;\n\tfor (int i = 2; i < n; i += 2) {\n\t\tif (mx >= mid - s[i][1] + s[i - 1][0]) {\n\t\t\tf[i] = true;\n\t\t\tmx = max(mx, s[i][0] - s[i][1]);\n\t\t\tif (s[n][1] - s[i][1] >= mid)\n\t\t\t\treturn true;\n\t\t} else\n\t\t\tf[i] = false;\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\ts[i][i - 1 & 1] = s[i - 1][i - 1 & 1];\n\t\ts[i][i & 1] = s[i - 1][i & 1] + a[i];\n\t}\n\tif (n % 2 == 0) {\n\t\tif (s[n][0] < s[n][1])\n\t\t\tswap(s[n][0], s[n][1]);\n\t\tprintf(\"%d %d\\n\", s[n][0], s[n][1]);\n\t\treturn 0;\n\t}\n\tint l = 0, r = s[n][1];\n\twhile (l < r) {\n\t\tint mid = l + r + 1 >> 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tif (s[n][0] + l > s[n][1])\n\t\tprintf(\"%d %d\\n\", s[n][0] + l, s[n][1] - l);\n\telse\n\t\tprintf(\"%d %d\\n\", s[n][1], s[n][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=3e5+5;\nint n,a[N],foo,bar;\nbool check(int mid){\n\tint mn=0;\n\tfor(int i=2;i<n;i+=2)\n\t\tif(a[i-1]-mn>=mid)\n\t\t\tmn=min(mn,a[i]);\n\treturn a[n]-mn>=mid;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i&1)foo+=a[i];\n\t\telse bar+=a[i],a[i]=-a[i];\n\t\ta[i]+=a[i-1];\n\t}\n\tif(~n&1)return printf(\"%d %d\\n\",max(foo,bar),min(foo,bar)),0;\n\tint l=0,r=3e8,res;\n\twhile(l<=r){\n\t\tint mid=l+r>>1;\n\t\tif(check(mid))res=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tprintf(\"%d %d\\n\",bar+res,foo-res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\nint main(){\n\tstatic int N;\n\tstatic int a[300010];\n\tscanf(\"%d\",&N);\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t\n\tstatic int sumA[300010],sumB[300010];\n\tsumA[0] = 0;\n\tsumB[0] = 0;\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tsumA[i] = sumA[i-1];\n\t\tsumB[i] = sumB[i-1];\n\t\tif(i%2 == 1)sumA[i] += a[i];\n\t\telse sumB[i] += a[i];\n\t}\n\t\n\tint ret = max(sumA[N],sumB[N]);\n\tif(N%2 == 1){\n\t\tint l = 0, r = 1000000000;\n\t\twhile(l<r){\n\t\t\tint m = (l+r+1)/2;\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 1 ; i <= N ; i ++){\n\t\t\t\tif(i%2 == 1)sum += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(sum < a[i] && sum >= m)sum = 0;\n\t\t\t\t\telse sum -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum <= m)l = m;\n\t\t\telse r = m-1;\n\t\t}\n\t\tret = max( ret , sumB[N]+l );\n\t}\n\t\n\tcout << ret << \" \" << sumA[N]+sumB[N]-ret << endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n 　　　　　／＞　 フ\n 　　　　　| 　_　 _|\n 　 　　　／`ミ _x 彡\n 　　 　 /　　　 　 |\n 　　　 /　  ヽ　　 ?\n 　／￣|　　 |　|　|\n 　| (￣ヽ＿_ヽ_)_)\n 　＼二つ\n  */\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n    static short st[30];short tp=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++tp]=x%10,x/=10; while(x);\n    while(tp) putchar('0'|st[tp--]);\n    putchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int N = 300500;\nint sum[N], a[N], res, t, n;\nbool check(int mid) {\n    int k = 0;\n    for (int i = 2;i <= n; i += 2) \n        if (sum[i-1] - k >= mid) Mn(k, sum[i]);\n    return sum[n] - k >= mid;\n}\n\nint main() {\n    read(n);\n    for (int i = 1;i <= n; i++) {\n        read(a[i]), sum[i] = i & 1 ? sum[i-1] + a[i] : sum[i-1] - a[i];\n        res += a[i];\n    }\n    if (~n & 1) {\n        t = max(sum[n], -sum[n]);\n        write((res + t) / 2, ' '), write((res - t) / 2);\n        return 0;\n    }\n    int l = 0, r = 1e9;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (check(mid)) l = mid + 1;\n        else r = mid - 1;\n    }\n    t  = -sum[n] + 2 * r;\n    write((res + t) / 2, ' '), write((res - t) / 2, ' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF int(1e9)\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=300005;\nint n,tot,sum;\nint a[maxn];\n\nbool check(int x){\n\tint cur=a[1];\n\tfor(int i=2;i<=n;i+=2){\n\t\tif(cur>=x)cur=max(cur+a[i+1]-a[i],a[i+1]);\n\t\telse cur+=a[i+1]-a[i];\n\t}\n\treturn cur>=x;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tREP(i,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\ttot+=a[i];\n\t\tsum+=(i&1)?a[i]:-a[i];\n\t}\n\tif(!(n&1)){\n\t\tint sum1=(tot+sum)/2,sum2=(tot-sum)/2;\n\t\tprintf(\"%d %d\\n\",max(sum1,sum2),min(sum1,sum2));\n\t\treturn 0;\n\t}\n\tint l=0,r=tot+1;\n\twhile(r-l>1){\n\t\tint mid=l+r>>1;\n\t\tif(check(mid))l=mid;\n\t\telse r=mid;\n\t}\n\tint sum1=max((tot+sum)/2,(tot-sum+2*l)/2),sum2=tot-sum1;\n\tprintf(\"%d %d\\n\",sum1,sum2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nll f[300001];\n\nvoid init() {\n\tf[1] = 1;\n\tll ma = 0;\n\tfor (int i = 3; i <= 300000; i += 2) {\n\t\tint d = i / 2;\n\t\tif (d % 2 == 0) {\n\t\t\tf[i] = 2 * (f[d - 1] + f[d + 1]);\n\t\t}\n\t\telse {\n\t\t\tf[i] = f[d] + f[d];\n\t\t}\n\t\tma = max(ma, f[i]);\n\t}\n\tcout << ma << \"\\n\";\n}\n\nvoid solve() {\n\n\n\n\tint n; cin >> n;\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tint sum = 0;\n\trep(i, n)sum += a[i];\n\n\tif (n % 2 == 0) {\n\t\tint s1 = 0, s2 = 0;\n\t\tfor (int i = 0; i < n; i += 2)s1 += a[i];\n\t\tfor (int i = 1; i < n; i += 2)s2 += a[i];\n\t\tint ans1 = max(s1, s2);\n\t\tint ans2 = sum - ans1;\n\t\tcout << ans1 << \" \" << ans2 << \"\\n\";\n\t}\n\telse {\n\t\tvector<vector<int>> ra(n + 1,vector<int>(2));\n\t\trep(i, n) {\n\t\t\tra[i + 1] = ra[i];\n\t\t\tra[i + 1][i%2] += a[i];\n\t\t}\n\t\tmap<P, bool> used;\n\t\tmap<P, int> memo;\n\t\tfunction<int(int, int)> dfs = [&](int l, int r)->int{\n\t\t\tif (used[{l, r}])return memo[{l, r}];\n\t\t\tused[{l, r}] = true;\n\t\t\tint res = ra[r + 1][l%2] - ra[l][l%2];\n\t\t\tif (l == r) {\n\t\t\t\tres = a[l];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint res1 = mod, res2 = mod;\n\t\t\t\tint len = (r - l + 1);\n\t\t\t\tif (len % 4 == 3) {\n\t\t\t\t\tint d = len / 2;\n\t\t\t\t\tint m = l + d;\n\t\t\t\t\tres1 = min(res1, dfs(l, m - 1) + ra[r + 1][m%2] - ra[m][m%2]);\n\t\t\t\t\tres1 = min(res1, dfs(m + 1, r) + ra[m + 1][m%2] - ra[l][m%2]);\n\t\t\t\t\tres = max(res, res1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int ex = -1; ex <= 1; ex += 2) {\n\t\t\t\t\t\tint d = len / 2 + ex;\n\t\t\t\t\t\tint m = l + d;\n\t\t\t\t\t\tres1 = mod;\n\t\t\t\t\t\tres1 = min(res1, dfs(l, m - 1) + ra[r + 1][m%2] - ra[m][m%2]);\n\t\t\t\t\t\tres1 = min(res1, dfs(m + 1, r) + ra[m + 1][m%2] - ra[l][m%2]);\n\t\t\t\t\t\tres = max(res, res1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << l << \" \" << r << \" \" << res << \"\\n\";\n\t\t\treturn memo[{l, r}] = res;\n\t\t};\n\t\tint ans = dfs(0, n - 1);\n\t\tcout << ans << \" \"<<sum-ans<<\"\\n\";\n\t}\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    if (n % 2 == 0) {\n        int s1 = 0;\n        int s2 = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                s1 += a[i];\n            } else {\n                s2 += a[i];\n            }\n        }\n        cout << std::max(s1, s2) << \" \" << std::min(s1, s2) << \"\\n\";\n        return 0;\n    }\n\n    int l = 0;\n    int r = 1000000000;\n    while (r > l + 1) {\n        int m = (l + r) / 2;\n        int bp = 0;\n        int s = 0;\n        bool ok = false;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                s += a[i];\n                if (s - bp >= m) {\n                    if (i == n - 1) {\n                        ok = true;\n                    } else {\n                        if (s - a[i + 1] < bp) {\n                            bp = s - a[i + 1];\n                        }\n                    }\n                }\n            } else {\n                s -= a[i];\n            }\n        }\n        if (ok) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n\n    int s = l;\n    int s2 = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 1) s += a[i];\n        s2 += a[i];\n    }\n    cout << s << \" \" << s2 - s << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[303030];\nll B[303030];\nll S[2];\nint ok(ll v) {\n\tint i;\n\tFOR(i,N) B[i]=A[i];\n\tfor(int cur=N-1;cur>0;cur-=2) if(B[cur]<v || B[cur-1]<B[cur]) B[cur-2]+=B[cur]-B[cur-1];\n\treturn B[0]>=v;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i];\n\t\tS[i%2]+=A[i];\n\t}\n\tif(N%2==0) {\n\t\tcout<<max(S[0],S[1])<<\" \"<<min(S[0],S[1])<<endl;\n\t\treturn;\n\t}\n\t\n\tll Z=-1LL<<40;\n\tfor(i=40;i>=0;i--) if(ok(Z+(1LL<<i))) Z+=1LL<<i;\n\t\n\tcout<<(S[1]+Z)<<\" \"<<(S[0]-Z)<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 300020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nint n,a[maxn],sumw,sumb;\n\ninline bool check(int mid){\n\tint mx = 0;\n\trep(i,1,n){\n\t\tif ( i & 1 ){\n\t\t\tmx += a[i];\n\t\t\tif ( mx >= mid && i + 1 <= n ) mx = max(mx,a[i + 1]);\n\t\t}\n\t\telse mx -= a[i];\n\t}\n\treturn mx >= mid;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%d\",&a[i]) , ((i & 1) ? sumb : sumw) += a[i];\n\tif ( !(n & 1) ){\n\t\tcout<<max(sumw,sumb)<<\" \"<<min(sumw,sumb)<<endl;\n\t\treturn 0;\n\t}\n\tint l = 0 , r = inf , x = 0;\n\twhile ( l <= r ){\n\t\tint mid = (l + r) >> 1;\n\t\tif ( check(mid) ) l = mid + 1 , x = mid;\n\t\telse r = mid - 1;\n\t}\n\tcout<<sumw + x<<\" \"<<sumb - x<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 3e5 + 7;\nint n, a[N], B, W;\n\ninline bool pd(int X) {\n\tint t = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (i & 1) t += a[i];\n\t\telse if (t >= X) t = max(t - a[i], 0);\n\t\telse t -= a[i];\n\treturn t >= X;\n}\n\nint main() {\n\trd(n), rda(a, n);\n\tfor (int i = 1; i <= n; i++)\n\t\tif (i & 1) B += a[i];\n\t\telse W += a[i];\n\tif (!(n & 1)) return print(max(B, W), min(B, W)), 0;\n\tint l = 0, r = B;\n\twhile (l < r) {\n\t\tint mid = (l + r + 1) >> 1;\n\t\tif (pd(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tprint(W + l, B - l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300005;\nint n, a[N], s[N][2];\nbool f[N];\n\nbool check(int mid) {\n\tf[0] = true;\n\tint mx = 0;\n\tfor (int i = 2; i < n; i += 2) {\n\t\tif (mx >= mid - s[i][1] + s[i - 1][0]) {\n\t\t\tf[i] = true;\n\t\t\tmx = max(mx, s[i][0] - s[i][1]);\n\t\t\tif (s[n][1] - s[i][1] >= mid)\n\t\t\t\treturn true;\n\t\t} else\n\t\t\tf[i] = false;\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\ts[i][i - 1 & 1] = s[i - 1][i - 1 & 1];\n\t\ts[i][i & 1] = s[i - 1][i & 1] + a[i];\n\t}\n\tif (n % 2 == 0) {\n\t\tif (s[n][0] < s[n][1])\n\t\t\tswap(s[n][0], s[n][1]);\n\t\tprintf(\"%d %d\\n\", s[n][0], s[n][1]);\n\t\treturn 0;\n\t}\n\tint l = 0, r = s[n][1];\n\twhile (l < r) {\n\t\tint mid = l + r + 1 >> 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tif (s[n][0] + l > s[n][1])\n\t\tprintf(\"%d %d\\n\", s[n][0] + l, s[n][1] - l);\n\telse\n\t\tprintf(\"%d %d\\n\", s[n][1], s[n][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint a[524288];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint s=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\ts+=a[i];\n\t}\n\tif(!(n&1))\n\t{\n\t\tint ans1=0,ans2=0;\n\t\tfor(int i=1;i<=n;i+=2)\n\t\t{\n\t\t\tans1+=a[i];\n\t\t}\n\t\tfor(int i=2;i<=n;i+=2)\n\t\t{\n\t\t\tans2+=a[i];\n\t\t}\n\t\tif(ans1<ans2)\n\t\t{\n\t\t\tint t=ans1;\n\t\t\tans1=ans2;\n\t\t\tans2=t;\n\t\t}\n\t\tprintf(\"%d %d\\n\",ans1,ans2);\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=n;i+=2)\n\t{\n\t\tans+=a[i];\n\t\ta[i]=-a[i];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]+=a[i-1];\n\t}\n\tint l=0,r=1000000000;\n\twhile(l<r)\n\t{\n\t\tint mid=(l+r+1)>>1;\n\t\tint mn=0;\n\t\tfor(int i=2;i<=n;i+=2)\n\t\t{\n\t\t\tif(a[i-1]-mn>=mid&&a[i]<mn)\n\t\t\t{\n\t\t\t\tmn=a[i];\n\t\t\t}\n\t\t}\n\t\tif(a[n]-mn>=mid)\n\t\t{\n\t\t\tl=mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr=mid-1;\n\t\t}\n\t}\n\tans+=l;\n\tprintf(\"%d %d\\n\",ans,s-ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300010\nusing namespace std;\nint n,a[N],s[N];\nbool check(int x){\n\tint no=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (i%2==1)no-=a[i];\n\t\telse if (no<x&&no+a[i]>0)no=0;else no+=a[i];\n\t}\n\tif (no<x) return 0;\n\treturn 1;\n}\nint ch(int x){x++;if (x<0&&x%2)x-=2;return x/2;}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){cin>>a[i];s[i]=a[i];if (i>2)s[i]+=s[i-2];}\n\tif (n%2==0)cout<<max(s[n],s[n-1])<<' '<<min(s[n],s[n-1])<<endl;\n\telse{\n\t\tint l=-n*1000,r=n*1000,mid;\n\t\twhile (l<r){\n\t\t\tmid=ch(l+r);\n\t\t\tif (check(mid))l=mid;else r=mid-1;\n\t\t}\n\t\tcout<<s[n-1]-l<<' '<<s[n]+l<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 300005\nint read() {\n    int s=0,w=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n\t{\n\t    if(ch=='-') w=-1;\n\t    ch=getchar();\n\t}\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();\n    return s*w;\n}\nint n;\nint a[M],tol[M],s1[M],s2[M];\nint ans1,ans2;\nvoid work(int *a,int n) {\n    int sum1=0,sum2=0;\n    if(n&1) sum1=a[n],n--;\n    for(int i=1;i<=n;i+=2) s1[(i+1)/2]=s1[(i+1)/2-1]+a[i];\n    for(int i=2;i<=n;i+=2) s2[(i+1)/2]=s2[(i+1)/2-1]+a[i];\n    for(int i=2,tp=0;i<=n;i+=2)\n\t{\n\t    int p=i/2;\n\t    if(!tp&&s1[n/2]-s1[p-1]>s2[n/2]-s2[p-1]) tp=1;\n\t    if(!tp) sum1+=a[i],sum2+=a[i-1];\n\t    else sum1+=a[i-1],sum2+=a[i];\n\t}\n    if(sum1>ans1) ans1=sum1,ans2=sum2;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++) a[i]=read();\n    work(a,n);\n    for(int i=1;i<=n;i++) tol[i]=a[n-i+1];\n    for(int i=1;i<=n;i++) a[i]=tol[i];\n    work(a,n);\n    cout<<ans1<<' '<<ans2<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n\tint n;\n\tcin >> n;\n\tint a[n];\n        int goukei = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t}\n       for(int i=0;i<n;i++)\n             goukei += a.at(i)\n\tint guukinosa = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(i % 2){\n\t\t\tguukinosa -= a[i];\n\t\t} else {\n\t\t\tguukinosa += a[i];\n\t\t}\n\t}\n\tif(n % 2 == 0){\n\t\tcout << (goukei + max(guukinosa, -guukinosa)) / 2 << \" \" << (goukei - max(guukinosa, -guukinosa)) / 2;\n\t\treturn 0;\n\t}\n\telse if(guukinosa >= 100){\n\t\tcout << (goukei + guukinosa) / 2 << \" \" << (goukei - guukinosa) / 2;\n\t\treturn 0;\n\t}\n        else{\n\tint b = 0;\n\tint c = 100;\n\twhile(b + 1 < c){\n\t\tint d = (b + c) / 2;\n\t\tvector<int> e;\n\t\te.push_back(a[0]);\n\t\tfor(int i = 1; i < n; i += 2){\n\t\t\tif(e[e.size() - 1] < d || a[i] < e[e.size() - 1]){\n\t\t\t\te[e.size() - 1] += a[i+1] - a[i];\n\t\t\t} else {\n\t\t\t\te.push_back(a[i]);\n\t\t\t\te.push_back(a[i+1]);\n\t\t\t}\n\t\t}\n\t\tif(e[e.size() - 1] >= d){\n\t\t\tb = d;\n\t\t} else {\n\t\t\tc = d;\n\t\t}\n\t}\n\tcout << (goukei + max(guukinosa, (-guukinosa + 2 * b))) / 2 << \" \" << (goukei - max(guukinosa, (-guukinosa + 2 * b))) / 2;\n\treturn 0;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 300000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,a[MN+5],tot[2],ans,s[MN+5],L[MN+5],R[MN+5];\nbool Solve(int lim)\n{\n    int mn=1e9;\n    for(int j=1;j<=n;j+=2)\n    {\n        if(tot[0]+s[j]-mn>=lim) L[j-1]=true; else L[j-1]=false;\n        if(tot[0]+s[j]>=lim) mn=min(mn,s[j+1]);\n    }\n    mn=-1e9;\n    for(int j=n;j>=1;j-=2)\n    {\n        if(tot[0]+mn-s[j-1]>=lim&&L[j-1]) return true;\n        if(tot[0]+s[n]-s[j-1]>=lim) mn=max(mn,s[j-2]);\n    }\n    return false;\n}\nint main()\n{   \n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read(),tot[i&1]+=a[i];\n    if(~n&1) return 0*printf(\"%d %d\\n\",max(tot[0],tot[1]),min(tot[1],tot[0]));\n    ans=max(tot[0],tot[1]);\n    int l=ans+1,r=tot[0]+tot[1],mid;\n    for(int i=1;i<=n;++i) s[i]=s[i-1]+((i&1)?1:-1)*a[i];\n    while(l<=r)\n    {\n        mid=l+r>>1;\n        if(Solve(mid)) ans=mid,l=mid+1;\n        else r=mid-1;\n    }\n    printf(\"%d %d\\n\",ans,tot[0]+tot[1]-ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e6 + 1000;\nint n,a[N],sum[N],s[2];\nint check(int x)\n{\n\tint k = 0;\n\tfor(int i = 2;i <= n;i += 2)\n\t\tif(sum[i - 1] - k >= x) k = min(sum[i],k); \n\treturn sum[n] - k >= x;\n}\nint main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++) s[i & 1] += a[i] = read();\n\tif(n & 1 == 0) {cout << max(s[0],s[1]) << \" \" << min(s[0],s[1]); return 0;}\n\telse\n\t{\n\t\tfor(int i = 1;i <= n;i ++) sum[i] = sum[i - 1] + (i & 1 ? a[i] : -a[i]);\n\t\tint l = 0,r = s[0] + s[1],mid,ans;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(check(mid)) {ans = mid; l = mid + 1;}\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tcout << s[0] + ans << \" \" << s[1] - ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define maxn 1005\nint f[maxn][maxn],s[maxn],sodd[maxn],seven[maxn],n;bool vis[maxn][maxn];\nint calcl(int r,int l){\n\tif (r&1)return /*cerr<<\"calc:\"<<l<<\" \"<<r<<\" \"<<sodd[r]-sodd[l-1]<<endl,*/sodd[r]-sodd[l-1];else return seven[r]-seven[l-1];\n}\nint calcr(int l,int r){\n\tif (l&1)return /*cerr<<\"calc:\"<<l<<\" \"<<r<<\" \"<<sodd[r]-sodd[l-1]<<endl,*/sodd[r]-sodd[l-1];else return seven[r]-seven[l-1];\n}\nint dfs(int l,int r){\n\tif (l>r)return 0;if (vis[l][r])return f[l][r];vis[l][r]=true;\n\trep(i,l,r){\n\t\tint ind=i;\n\t\tint resl=0,resr=0;\n\t\tresl=calcl(ind,l)+(((ind-l+1)&1)?(s[r]-s[ind]-dfs(ind+1,r)):dfs(ind+1,r));\n\t\tresr=calcr(ind,r)+(((r-ind+1)&1)?(s[ind-1]-s[l-1]-dfs(l,ind-1)):dfs(l,ind-1));\n\t\t// cerr<<l<<\" \"<<r<<\" \"<<ind<<\" \"<<resl<<\" \"<<resr<<endl;\n\t\tint res=0;if (l==ind)res=resr;else if (ind==r)res=resl;else res=min(resl,resr);\n\t\tf[l][r]=max(f[l][r],res);\n\t\t\n\t}\n\t// cerr<<l<<\" \"<<r<<\" \"<<f[l][r]<<endl;\n\treturn f[l][r];\n}\nint main(){\n\tscanf(\"%d\",&n);if (n>1000)printf(\"%d %d\\n\",0,0);rep(i,1,n)scanf(\"%d\",&s[i]);\n\tfor (int i=1;i<=n;i+=2)sodd[i]=s[i];\n\tfor (int i=2;i<=n;i+=2)seven[i]=s[i];\n\trep(i,1,n)s[i]+=s[i-1],sodd[i]+=sodd[i-1],seven[i]+=seven[i-1];\n\tprintf(\"%d %d\\n\",dfs(1,n),s[n]-dfs(1,n));return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define per(i,a,b) for (int i=a;i>=b;i--)\nvoid read(int&x){\n\tx=0;char c=getchar();\n\twhile (!isdigit(c))c=getchar();\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n}\n#define maxn 300005\n\n\n\nint n,a[maxn];\nvoid solve_even(){\n\tint odd=0,even=0;\n\trep(i,1,n)if (i&1)odd+=a[i];else even+=a[i];\n\tprintf(\"%d %d\\n\",max(odd,even),min(odd,even));\n}\nbool check(int mid){\n\tint s=0;\n\tfor (int i=1;i<=n;i+=2){\n\t\ts+=a[i];bool flag=false;if (s>=mid)flag=true;\n\t\ts-=a[i+1];if (flag&&s<0)s=0;\n\t}\n\treturn s>=mid;\n}\nvoid solve_odd(){\n\tint s=0;rep(i,1,n)s+=a[i];\n\tint l=-s,r=s;\n\twhile (l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif (check(mid))l=mid+1;else r=mid-1;\n\t}\n\trep(i,1,n)if (~i&1)r+=a[i];\n\tprintf(\"%d %d\\n\",r,s-r);\n}\nint main(){\n\tread(n);rep(i,1,n)read(a[i]);\n\tif (~n&1)solve_even();else solve_odd();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint s[MAXN],a[MAXN],n;\nbool check(int x)\n{\n\tint ans=0;\n\tfor (int i=1;i<n;i+=2)\n\t\tif (s[i]-ans>=x) upmin(ans,s[i+1]);\n\treturn s[n]-ans>=x;\n}\nint main()\n{\n\tn=read();\n\tint sum=0;\n\tfor (int i=1;i<=n;i++) a[i]=read(),sum+=a[i];\n\tif (!(n&1))\n\t{\n\t\tint s=0;\n\t\tfor (int i=1;i<=n;i++) s+=(i&1)*a[i];\n\t\tprintf(\"%d %d\\n\",max(s,sum-s),min(s,sum-s));\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++) s[i]=s[i-1]+a[i]*((i&1)?1:-1);\n\tint l=0,r=n*1000;\n\twhile (l<r)\n\t{\n\t\tint mid=(l+r+1)>>1;\n\t\tif (check(mid)) l=mid;\n\t\telse r=mid-1;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!(i&1)) l+=a[i];\n\tprintf(\"%d %d\\n\",l,sum-l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=300005;\nint n,sum,a[N],ar[N];\nbool check(int x){\n\tint dq=0;\n\tfor(int i=2;i<=n;i+=2){\n\t\tif(ar[i-1]>=dq+x)dq=min(ar[i],dq);\n\t}\n\treturn ar[n]>=dq+x;\n}\nint solve(){\n\tint l=0,r=2e8;\n\twhile(l<r){\n\t\tint mid=(l+r)>>1; mid++;\n\t\tif(check(mid))l=mid; else r=mid-1;\n\t}\n\treturn l;\n}\nint main(){\n\tn=read();\n\tFor(i,1,n)sum+=(a[i]=read());\n\tFor(i,1,n){ar[i]=ar[i-1]; if(i&1)ar[i]+=a[i]; else ar[i]-=a[i];}\n\tif(n%2==0){\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i+=2)ans+=a[i];\n\t\tcout<<max(ans,sum-ans)<<\" \"<<min(ans,sum-ans)<<endl;\n\t}else{\n\t\tint s=0;\n\t\tfor(int i=2;i<=n;i+=2)s+=a[i];\n\t\tint ans=s+solve();\n\t\tcout<<ans<<\" \"<<sum-ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<int> a(n);\n        int esum = 0, osum = 0;\n        for (int i = 0; i < n; i ++) {\n                scanf(\"%d\", &a[i]);\n                if (i & 1) {\n                        osum += a[i];\n                } else {\n                        esum += a[i];\n                }\n        }\n        if (n & 1) {\n                int lb = 0, ub = 100000000;\n                while (ub - lb > 1) {\n                        int mid = (lb + ub) / 2;\n                        vector<int> b = a;\n                        for (int i = 0; i < n - 1; i += 2) {\n                                if (b[i] >= mid && b[i + 1] >= b[i]) {\n                                        continue;\n                                } else {\n                                        b[i + 2] += b[i] - b[i + 1];\n                                }\n                        }\n                        if (b[n - 1] >= mid) {\n                                lb = mid;\n                        } else {\n                                ub = mid;\n                        }\n                }\n                printf(\"%d %d\\n\", lb + osum, esum - lb);\n        } else {\n                printf(\"%d %d\\n\", max(esum, osum), min(esum, osum));\n        }\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint a[333333];\nint S[333333];\nint sum;\n\nvoid out(int diff)\n{\n\tcout<<(sum+diff)/2<<' '<<(sum-diff)/2<<'\\n'; exit(0);\n}\n\nint getS(int l, int r)\n{\n\tif(l==0) return S[r];\n\telse return S[r]-S[l-1];\n}\n\nint dp[333333];\n\nint cost(int i, int j)\n{\n\treturn max((j>=2?dp[j-2]:-int(1e9)), getS(j, i));\n}\n\nset<ii> SS; \n\nvoid add(ii x)\n{\n\tauto it = SS.lower_bound(x);\n\tif(it!=SS.begin())\n\t{\n\t\tit--; \n\t\tif(it->se<=x.se) return ;\n\t\tit++;\n\t}\n\twhile(it!=SS.end()&&it->se>=x.se) \n\t{\n\t\tit=SS.erase(it);\n\t}\n\tSS.insert(x);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i]; sum+=a[i];\n\t\tif(i%2==0) a[i]*=-1;\n\t\tS[i]=a[i]+(i>0?S[i-1]:0);\n\t}\n\tif(n%2==0) out(abs(S[n-1]));\n\tdp[0] = min(0, getS(0,0));\n\tint shift = a[0]; add(mp(-int(1e9), 0));\n\tfor(int i=2;i<n;i+=2)\n\t{\n\t\tshift+=a[i-1]+a[i];\n\t\tadd(mp(dp[i-2], a[i]-shift));\n\t\tint lo = -int(1e9); int hi = int(1e9);\n\t\twhile(lo<=hi)\n\t\t{\n\t\t\tint mid=(lo+hi)>>1;\n\t\t\t//is mid reachable\n\t\t\t//check the largest pair with (<= mid, ?)\n\t\t\t//cerr<<\"LO HI : \"<<lo<<' '<<hi<<'\\n';\n\t\t\tauto it = SS.upper_bound(mp(mid+1,-int(1e9)));\n\t\t\t//cerr<<\"LARGE : \"<<it->fi<<' '<<it->se<<'\\n';\n\t\t\tbool pos=1;\n\t\t\tif(it==SS.begin()) pos=0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tit--;\n\t\t\t\t//cerr<<\"IT \"<<it->fi<<' '<<it->se<<'\\n';\n\t\t\t\tif(it->se+shift>mid) pos=0;\n\t\t\t}\n\t\t\tif(pos)\n\t\t\t{\n\t\t\t\tdp[i]=mid; hi=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\n\t\t//cerr<<i<<' '<<dp[i]<<'\\n';\n\t}\n\tout(S[n-1]-2*dp[n-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\ntypedef long long LL;\n\nint read() {\n  int ans = 0, c, f = 1;\n  while (!isdigit(c = getchar()))\n    if (c == '-') f *= -1;\n  do ans = ans * 10 + c - '0';\n  while (isdigit(c = getchar()));\n  return ans * f;\n}\n\nconst int N = 300050;\n\nint n, a[N], B, W;\n\nbool check(int X) {\n  int t = 0;\n  for (int i = 1; i <= n; ++i)\n    if (i & 1) { // Black\n      t += a[i];\n    } else { // White\n      if (t >= X) t = std::max(t - a[i], 0);\n      else t -= a[i];\n    }\n  return t >= X;\n}\n\nint main() {\n  n = read();\n  B = W = 0;\n  for (int i = 1; i <= n; ++i)\n    (i & 1 ? B : W) += a[i] = read();\n  if (~n & 1) {\n    if (B < W) std::swap(B, W);\n    printf(\"%d %d\\n\", B, W);\n    return 0;\n  }\n  int l = 0, r = B;\n  while (l < r) {\n    int mid = (l + r + 1) / 2;\n    if (check(mid)) l = mid;\n    else r = mid - 1;\n  }\n  printf(\"%d %d\\n\", W + l, B - l);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#ifdef MAROON_LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\" SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nvoid Even(int n,vi a){\n\tint ans[2]{};\n\tREP(i,n)\n\t\tans[i%2]+=a[i];\n\tif(ans[0]<ans[1])swap(ans[0],ans[1]);\n\tcout<<ans[0]<<\" \"<<ans[1]<<endl;\n}\n\nvoid Odd(int n,vi a){\n\tint ans[2]{};\n\tREP(i,n)\n\t\tans[i%2]+=a[i];\n\tint l=0,r=n*1001;\n\twhile(r-l>1){\n\t\tconst int mid=(l+r)/2;\n\t\tint x=0,cur=0;\n\t\tbool ok=false;\n\t\tREP(i,n){\n\t\t\tif(i%2==0)\n\t\t\t\tcur+=a[i];\n\t\t\telse\n\t\t\t\tcur-=a[i];\n\t\t\tif(i%2==0){\n\t\t\t\tif(cur-x>=mid){\n\t\t\t\t\tif(i==n-1)\n\t\t\t\t\t\tok=true;\n\t\t\t\t\telse\n\t\t\t\t\t\tchmin(x,cur-a[i+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok)l=mid;\n\t\telse r=mid;\n\t}\n\tcout<<ans[1]+l<<\" \"<<ans[0]-l<<endl;\n}\n\nsigned main(){\n\tint n=read();\n\tvi a(n);REP(i,n)a[i]=read();\n\tif(n%2==0)Even(n,a);\n\telse Odd(n,a);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\nint sum = 0;\nint main(){\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tint diff = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(i % 2){\n\t\t\tdiff -= a[i];\n\t\t} else {\n\t\t\tdiff += a[i];\n\t\t}\n\t}\n\tif(n % 2 == 0){\n\t\tcout << (sum + max(diff, -diff)) / 2 << \" \" << (sum - max(diff, -diff)) / 2 << '\\n';\n\t\treturn 0;\n\t}\n\tif(diff >= 1000){\n\t\tcout << (sum + diff) / 2 << \" \" << (sum - diff) / 2 << '\\n';\n\t\treturn 0;\n\t}\n\tint s = 0; // yes\n\tint e = 1000; // no\n\twhile(s + 1 < e){\n\t\tint d = (s + e) / 2;\n\t\tvector<int> r;\n\t\tr.push_back(a[0]);\n\t\tfor(int i = 1; i < n; i += 2){\n\t\t\tif(r[r.size() - 1] < d || a[i] <= r[r.size() - 1]){\n\t\t\t\tr[r.size() - 1] += a[i+1] - a[i];\n\t\t\t} else {\n\t\t\t\tr.push_back(a[i]);\n\t\t\t\tr.push_back(a[i+1]);\n\t\t\t}\n\t\t}\n\t\tif(r[r.size() - 1] >= d){\n\t\t\ts = d;\n\t\t} else {\n\t\t\te = d;\n\t\t}\n\t}\n\tcout << (sum + max(diff, (-diff + 2 * s))) / 2 << \" \" << (sum - max(diff, (-diff + 2 * s))) / 2 << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nstruct fin {\n\tvector<int> T;\n\tfin() = default;\n\tfin(int N) : T(N+10, OVER9000) {}\n\n\tint lastone(int x) {return x&(x^(x-1));}\n\n\tvoid put(int pos, int val) {\n\t\tfor(int i = pos+1; i < (int)T.size(); i += lastone(i))\n\t\t\tT[i] = min(T[i], val);\n\t}\n\n\tint get(int pos) {\n\t\tint ret = OVER9000;\n\t\tfor(int i = pos+1; i > 0; i -= lastone(i)) ret = min(ret, T[i]);\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, MX = 1000;\n\tcin >> N;\n\tvector<int> A(N);\n\tvector<int> sum[2] = {vector<int>(N+1, 0), vector<int>(N+1, 0)};\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t\tsum[1-i%2][i+1] = sum[1-i%2][i];\n\t\tsum[i%2][i+1] = sum[i%2][i] + A[i];\n\t}\n\tif(N%2 == 0) {\n\t\tcout << max(sum[0][N], sum[1][N]) << \" \" << min(sum[0][N], sum[1][N]) << \"\\n\";\n\t\treturn 0;\n\t}\n\tA.push_back(0);\n\tint ans_l = abs(sum[0][N]-sum[1][N]), ans_r = abs(sum[0][N]-sum[1][N])+2*MX;\n\tmap<int, int> X;\n\tX[sum[1][N]-sum[0][N]] = 0;\n\tfor(int i = 2; i < N; i += 2) X[sum[1][i+1]-sum[0][i]] = 0;\n\tint x_mx = 0;\n\tALL_THE(X, it) it->ss = x_mx++;\n\tvector<int> X_id(N), X_val(x_mx+1, OVER9000);\n\tALL_THE(X, it) X_val[it->ss] = it->ff;\n\tfor(int i = 2; i < N; i += 2) X_id[i] = X[sum[1][i+1]-sum[0][i]];\n\twhile(ans_r-ans_l > 1) {\n\t\tint ans_m = (ans_l + ans_r) / 2;\n\t\tvector<int> valid(N+2, 0);\n\t\tvalid[0] = 1;\n\t\tfin F(x_mx);\n\t\tfor(int i = 2; i <= N+1; i += 2) {\n\t\t\tint d = sum[0][i-1]-sum[1][i-2]+sum[1][1];\n\t\t\tif(sum[1][N]-sum[0][N]+2*d >= ans_m && valid[0] && d < A[i-1]) valid[i] = 1;\n\t\t\tauto it = X.lower_bound((ans_m+sum[0][N]-sum[1][N]+1)/2+sum[1][i-2]-sum[0][i-1]);\n\t\t\tint id = x_mx;\n\t\t\tif(it != X.end()) id = it->ss;\n\t\t\tif(X_val[id] < A[i-1]+sum[1][i-2]-sum[0][i-1]) valid[i] = 1;\n\t\t\telse if(F.get(x_mx-id) < sum[1][i-2]-sum[0][i-1]) valid[i] = 1;\n\t\t\tif(i < N && valid[i]) F.put(x_mx-X_id[i], sum[1][i+1]-sum[0][i]-A[i-1]);\n\t\t}\n\t\tif(valid[N+1]) ans_l = ans_m;\n\t\telse ans_r = ans_m;\n\t}\n\tcout << (ans_l+sum[0][N]+sum[1][N])/2 << \" \" << (-ans_l+sum[0][N]+sum[1][N])/2 << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, w[301010], S[301000];\nint sum = 0;\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tsum += w[i];\n\t}\n\tint ss = 0;\n\tS[1] = w[1];\n\tfor (i = 2; i <= n; i++)S[i] = S[i - 2] + w[i];\n\tss = max(S[n], sum - S[n]);\n\tif (n % 2 == 0) {\n\t\tprintf(\"%d %d\\n\", ss, sum - ss);\n\t\treturn 0;\n\t}\n\twhile (1) {}\n\tfor (i = 2; i < n; i += 2) {\n\t\tint r1 = S[n - 1] - S[i];\n\t\tint r2 = S[n] - S[i - 1];\n\t\tint l1 = S[i - 2];\n\t\tint l2 = S[i - 1];\n\t\tss = max(ss, min(l1 + r2, r1 + l2) + w[i]);\n\t}\n\tprintf(\"%d %d\\n\", ss, sum - ss);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint dat[303030];\nbool isok(int med, int num)\n{\n\tint mini = 0, now = 0;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tif (i % 2 == 0)now += dat[i];\n\t\telse now -= dat[i];\n\t\tif (i % 2 == 0 && mini + med <= now)\n\t\t{\n\t\t\tif (i == num - 1)return true;\n\t\t\telse mini = min(mini, now - dat[i + 1]);\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tint s0 = 0, s1 = 0;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tscanf(\"%d\", &dat[i]);\n\t\tif (i % 2 == 0)s0 += dat[i];\n\t\telse s1 += dat[i];\n\t}\n\tif (num % 2 == 0)\n\t{\n\t\tprintf(\"%d %d\\n\", max(s0, s1), min(s0, s1));\n\t\treturn 0;\n\t}\n\tint beg = 0, end = 1000000000;\n\tfor (;;)\n\t{\n\t\tif (beg == end)break;\n\t\tint med = (beg + end + 1) / 2;\n\t\tif (isok(med, num))beg = med;\n\t\telse end = med - 1;\n\t}\n\tprintf(\"%d %d\\n\", s1 + beg, s0 - beg);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\n\nint N;\nV<int> a;\nV<int> s;\n\nint main(){\n\tcin>>N;\n\ta.resize(N);\n\trep(i,N) cin>>a[i];\n\tif(N%2 == 0){\n\t\tint x[2] = {};\n\t\trep(i,N) x[i%2] += a[i];\n\t\tif(x[0]<x[1]) swap(x[0],x[1]);\n\t\tcout<<x[0]<<\" \"<<x[1]<<endl;\n\t\treturn 0;\n\t}\n\n\ts.resize(N+1);\n\trep(i,N) s[i+1] += s[i] + (i%2==0 ? a[i] : -a[i]);\n\n\tauto can = [&](int X){\t//>=X: ok\n\t\tint N = ::N/2+1;\n\t\tint mn = 0;\n\t\trep1(r,N){\n\t\t\tif(s[r*2-1]-mn >= X){\n\t\t\t\tchmin(mn,s[r*2]);\n\t\t\t\tif(r == N) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tint ub = 1e9, lb = -1e9;\n\twhile(ub-lb>1){\n\t\tint m = (ub+lb)/2;\n\t\tif(can(m)) lb = m;\n\t\telse ub = m;\n\t}\n\tint sm = 0;\n\trep(i,N) sm += a[i];\n\tint sm1 = 0;\n\trep(i,N) if(i%2==1) sm1 += a[i];\n\tint A = sm1 + lb;\n\tint B = sm - A;\n\tcout<<A<<\" \"<<B<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<19;\nint sm[2],a[Q],b[Q];\nint n;\nint ch(int lim)\n{\n\tint op=0;\n\tfor(int i=1;i<=n;i+=2)\n\t\tif(b[i]-op>=lim)op=min(op,b[i+1]);\n\treturn b[n]-op>=lim;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]),b[i]=b[i-1]+(i&1?1:-1)*a[i],sm[i&1]+=a[i];\n\tif(n&1){\n\t\tint l=0,r=sm[0]+sm[1];\n\t\twhile(l<=r){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(ch(mid))l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\treturn printf(\"%d %d\",sm[0]+r,sm[1]-r)&0;\n\t}\n\tif(sm[0]<sm[1])swap(sm[0],sm[1]);\n\tprintf(\"%d %d\",sm[0],sm[1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=300005;\nint n;\nint a[N],s[N];\nbool check(int x){\n    int v=0;\n    for (int i=1;i<n;i+=2)\n        if (s[i]-v>=x)\n            v=min(v,s[i+1]);\n    return s[n]-v>=x;\n}\nint main(){\n    n=read();\n    For(i,1,n)\n        a[i]=read();\n    if (n%2==0){\n        int s0=0,s1=0;\n        For(i,1,n)\n            if (i&1)\n                s0+=a[i];\n            else\n                s1+=a[i];\n        cout<<max(s0,s1)<<\" \"<<min(s0,s1)<<endl;\n        return 0;\n    }\n    For(i,1,n)\n        if (i&1)\n            s[i]=s[i-1]+a[i];\n        else\n            s[i]=s[i-1]-a[i];\n    int L=1,R=n*1000,mid,ans=L;\n    while (L<=R){\n        mid=(L+R)>>1;\n        if (check(mid))\n            L=mid+1,ans=mid;\n        else\n            R=mid-1;\n    }\n    For(i,1,n)\n        if (i%2==0)\n            ans+=a[i];\n    int s=0;\n    For(i,1,n)\n        s+=a[i];\n    cout<<ans<<\" \"<<s-ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n\nconst int maxn = 3e5 + 10;\ntypedef long long LL;\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x * 10) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nint n, a[maxn];\nLL s[maxn];\n\nint ck(LL x)\n{\n\tint now = 0;\n\tif(s[n] - s[now] >= x) return 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif((i & 1) == 0 && s[i - 1] - s[now] >= x)\n\t\t{\n\t\t\tif(s[i] < s[now]) now = i;\n\t\t\tif(s[n] - s[i] >= x) return 1;\n\t\t}\n\treturn 0;\n}\n\nint main()\n{\n\n\tn = read();\n\tLL sumb = 0, sumw = 0;\n\tfor(int i = 1; i <= n; ++i) a[i] = read(), sumb += (i & 1 ? a[i] : 0), sumw += (i & 1 ? 0 : a[i]);\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\ts[i] += (i & 1 ? a[i] : 0);\n\t\ts[i] += (i & 1 ? 0 : -a[i]);\n\t\ts[i] += s[i - 1];\n\t}\n\n\tLL l = -sumw, r = sumb, ans = -LLONG_MAX;\n\twhile(l <= r)\n\t{\n\t\tint mid = (l + r) >> 1;\n\t\tif(ck(mid)) l = mid + 1, ans = mid;\n\t\telse r = mid - 1;\n\t}\n\n\tcout << sumw + ans << ' ' << sumb - ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing i64 = long long;\n\nconst int N = 300000 + 7;\n\nint n;\ni64 a[N], b[N], s[2];\ni64 l, r, m, p;\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", a + i),\n\t\tb[i] = b[i - 1] + (i & 1 ? 1 : -1) * a[i],\n\t\ts[i & 1] += a[i];\n\tif (n % 2 == 0) return printf(\"%lld %lld\", std::max(s[0], s[1]), std::min(s[0], s[1])), 0;\n\n\tr = s[0] + s[1];\n\twhile (l < r) {\n\t\tm = l + r + 1 >> 1, p = 0;\n\t\tfor (int i = 1; i < n; i += 2)\n\t\t\tif (b[i] + p >= m) p = std::max(p, a[i + 1] - b[i]);\n\t\tb[n] + p >= m ? (l = m) : (r = m - 1);\n\t}\n\tm = std::max(s[0] + l, s[1]);\n\treturn printf(\"%lld %lld\", m, s[0] + s[1] - m);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=300005;\nint n,B,W,a[N],S[N];\nbool check(int v){\n\tint mn=0;\n\tfor (int i=2;i<n;i+=2)\n\t\tif (mn+v<=S[i-1]) mn=min(mn,S[i]);\n\treturn mn+v<=S[n];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\tS[i]=S[i-1];\n\t\tif (i&1) B+=a[i],S[i]+=a[i];\n\t\telse W+=a[i],S[i]-=a[i];\n\t}\n\tif (!(n&1)){\n\t\tif (W>B) swap(W,B);\n\t\tprintf(\"%d %d\\n\",B,W);\n\t}\n\telse{\n\t\tint l=-1e9,r=1e9,ans;\n\t\twhile (l<=r){\n\t\t\tint mid=(l+r+1)/2;\n\t\t\tif (check(mid))\n\t\t\t\tans=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tans=max(B,W+ans);\n\t\tprintf(\"%d %d\\n\",ans,B+W-ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.11.2019 17:41:21       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> s(2);\n  for (int i = 0; i < n; i++) {\n    s[i % 2] += a[i];\n  }\n  if (n % 2 == 0) {\n    cout << max(s[0], s[1]) << \" \" << min(s[0], s[1]) << '\\n';\n    return 0;\n  }\n  int low = s[0], high = s[0] + s[1];\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    vector<bool> dp(n + 2, false);\n    dp[0] = true;\n    int take = s[1];\n    for (int j = 0; j < n; j++) {\n      if (dp[j]) {\n        take = max(take, s[1]);\n      }\n      if (j % 2 == 0) take += a[j];\n      else take -= a[j];\n      if (j % 2 == 0 && take >= mid) {\n        dp[j + 2] = true;\n      }\n    }\n    if (dp[n + 1]) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  cout << low << \" \" << s[0] + s[1] - low << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 300010;\n\nint n;\nint a[MAX_N];\nint dp[MAX_N];\nint sum[2][MAX_N];\nint s[2];\n\nint quadratic_dp ()\n{\n\tdp[0] = (1 << 30);\n\tfor (int i = 1; i * 2 <= (n + 1); i ++)\n\t{\n\t\tdp[i] = -(1 << 30); /// infinty\n\t\tfor (int j = 0; j < i; j ++)\n        \tdp[i] = max (dp[i], min (dp[j], sum[1][i * 2 - 1] - sum[1][j * 2] - (sum[0][i * 2 - 1] - sum[0][j * 2])));\n\t}\n\n\treturn dp[(n + 1) / 2];\n}\n\nbool check (int x)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; i += 2)\n    {\n        if (sum >= x)\n            sum = max (sum - a[i - 1] + a[i], a[i]);\n        else\n            sum = sum - a[i - 1] + a[i];\n    }\n    return sum >= x;\n}\n\nint nlogn ()\n{\n    int l, r, mid;\n\n    l = -1;\n    r = s[1] + 1;\n    while (r - l > 1)\n    {\n        mid = (l + r) >> 1;\n\n        if (check (mid))\n            l = mid;\n        else\n            r = mid;\n    }\n\n    return l;\n}\n\nint main ()\n{\n\tscanf (\"%d\", &n);\n\tfor (int i = 1; i <= n; i ++)\n\t\tscanf (\"%d\", &a[i]);\n\n\tfor (int i = 1; i <= n; i ++)\n\t\ts[i & 1] += a[i];\n\n\tif (!(n & 1))\n\t{\n\t\tprintf (\"%d %d\\n\", max (s[0], s[1]), min (s[0], s[1]));\n\t\treturn 0;\n\t}\n\n\tsum[0][0] = sum[1][0] = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tsum[0][i] = sum[0][i - 1];\n\t\tsum[1][i] = sum[1][i - 1];\n\t\tsum[i & 1][i] += a[i];\n\t}\n\n\tint ans;\n\n\t///ans = quadratic ();\n\tans = nlogn ();\n\n\tprintf (\"%d %d\\n\", s[0] + ans, s[1] - ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef KOMAKI_LOCAL\n#define NDEBUG\n#endif\n\n#include <bits/stdc++.h>\n#include <sys/time.h>\n#include <unistd.h>\nusing namespace std;\n#define i64         int64_t\n#define rep(i, n)   for(i64 i = 0; i < ((i64)(n)); ++i)\n#define sz(v)       ((i64)((v).size()))\n#define bit(n)      (((i64)1)<<((i64)(n)))\n#define all(v)      (v).begin(), (v).end()\n\nstd::string dbgDelim(int &i){ return (i++ == 0 ? \"\" : \", \"); }\n#define dbgEmbrace(exp) { int i = 0; os << \"{\"; { exp; } os << \"}\"; return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp);\ntemplate <int INDEX, class TUPLE> void dbgDeploy(std::ostream &os, TUPLE tuple){}\ntemplate <int INDEX, class TUPLE, class H, class ...Ts> void dbgDeploy(std::ostream &os, TUPLE t)\n{ os << (INDEX == 0 ? \"\" : \", \") << get<INDEX>(t); dbgDeploy<INDEX + 1, TUPLE, Ts...>(os, t); }\ntemplate <class T, class K> void dbgDeploy(std::ostream &os, std::pair<T, K> p, std::string delim)\n{ os << \"(\" << p.first << delim << p.second << \")\"; }\ntemplate <class ...Ts> std::ostream& operator<<(std::ostream &os, std::tuple<Ts...> t)\n{ os << \"(\"; dbgDeploy<0, std::tuple<Ts...>, Ts...>(os, t); os << \")\"; return os; }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p)\n{ dbgDeploy(os, p, \", \"); return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v)\n{ dbgEmbrace( for(T t: v){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> s)\n{ dbgEmbrace( for(T t: s){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q)\n{ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.front(); }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q)\n{ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.top();   }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp)\n{ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp)\n{ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\n#define DBG_OUT std::cerr\n#define DBG_OVERLOAD(_1, _2, _3, _4, _5, _6, macro_name, ...) macro_name\n#define DBG_LINE() { char s[99]; sprintf(s, \"line:%3d | \", __LINE__); DBG_OUT << s; }\n#define DBG_OUTPUT(v) { DBG_OUT << (#v) << \"=\" << (v); }\n#define DBG1(v, ...) { DBG_OUTPUT(v); }\n#define DBG2(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG1(__VA_ARGS__); }\n#define DBG3(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG2(__VA_ARGS__); }\n#define DBG4(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG3(__VA_ARGS__); }\n#define DBG5(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG4(__VA_ARGS__); }\n#define DBG6(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG5(__VA_ARGS__); }\n\n#define DEBUG0() { DBG_LINE(); DBG_OUT << std::endl; }\n#define DEBUG(...)                                                      \\\n  {                                                                     \\\n    DBG_LINE();                                                         \\\n    DBG_OVERLOAD(__VA_ARGS__, DBG6, DBG5, DBG4, DBG3, DBG2, DBG1)(__VA_ARGS__); \\\n    DBG_OUT << std::endl;                                               \\\n  }\n\n\nint main()\n{\n  i64 n;\n  cin >> n;\n  vector<i64> v(n);\n  rep(i, n) cin >> v[i];\n  if(sz(v) % 2 == 0){\n    i64 t[] = {0, 0};\n    rep(i, sz(v)) t[i % 2] += v[i];\n    cout << max(t[0], t[1]) << \" \" << min(t[0], t[1]) << endl;\n    return 0;\n  }\n  exit(1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    int b = 0, w = 0;\n    for (int i = 0; i < n; ++i)\n        (i % 2 == 0 ? b : w) += a[i];\n    int ans1, ans2;\n    if (n % 2 == 0) {\n        ans1 = max(b, w);\n    } else {\n        ans1 = b;\n        vector<int> sum(n + 1);\n        for (int i = 0; i < n; ++i)\n            sum[i + 1] = sum[i] + (i % 2 == 0 ? a[i] : -a[i]);\n        int l = 0, r = b;\n        while (l < r) {\n            int x = (l + r + 1) / 2;\n            int mn = 0;\n            for (int i = 1; i < n; i += 2)\n                if (sum[i] - mn >= x)\n                    mn = min(mn, sum[i + 1]);\n            if (sum[n] - mn >= x)\n                l = x;\n            else\n                r = x - 1;\n        }\n        ans1 = max(ans1, w + l);\n    }\n    ans2 = b + w - ans1;\n    cout << ans1 << \" \"<< ans2 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, a[303030], b[303030], S;\n\nstruct Segtree{\n    long long N, M;\n    long long mnm[1048576], mxm[1048576];\n    void init(){\n        for(int i = 0; i < M; ++i)mnm[i + N] = mxm[i + N] = b[i];\n        for(int i = N - 1; i; --i){\n            mnm[i] = min(mnm[2 * i], mnm[2 * i + 1]);\n            mxm[i] = max(mxm[2 * i], mxm[2 * i + 1]);\n        }\n    }\n    Segtree(long long _N) : mnm(), mxm(){\n        N = 1;\n        M = _N;\n        while(N < _N)N *= 2;\n    }\n    long long mnn(long long L, long long R){\n        L += N;\n        R += N;\n        long long ret = 189501249917890;\n        while(L < R){\n            if(L & 1){\n                ret = min(ret, mnm[L]);\n                ++L;\n            }\n            if(R & 1){\n                ret = min(ret, mnm[R - 1]);\n            }\n            L /= 2;\n            R /= 2;\n        }\n        return ret;\n    }\n    long long mxx(long long L, long long R){\n        L += N;\n        R += N;\n        long long ret = -189501249917890;\n        while(L < R){\n            if(L & 1){\n                ret = max(ret, mxm[L]);\n                ++L;\n            }\n            if(R & 1){\n                ret = max(ret, mxm[R - 1]);\n            }\n            L /= 2;\n            R /= 2;\n        }\n        return ret;\n    }\n};\n\nSegtree sgt(524288);\n\nint main(){\n    scanf(\"%lld\", &N);\n    if(N & 1){\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + i);\n            S += a[i];\n            a[i] *= (i & 1) ? -1 : 1;\n        }\n        partial_sum(a, a + N, b + 1);\n        long long ans = b[N];\n        sgt.init();\n        for(int i = 1; i < N; i += 2){\n            ans = max(ans, -b[N] + 2 * min(sgt.mxx(i + 1, N + 1) - b[i + 1], b[i] - sgt.mnn(0, i + 1)));\n        }\n        cout << (S + ans) / 2 << \" \" << (S - ans) / 2 << endl;\n    }else{\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + 4);\n            a[i & 1] += a[4];\n        }\n        if(a[0] < a[1])swap(a[0], a[1]);\n        cout << a[0] << \" \" << a[1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[300005];\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t}\n\telse{\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tif(c-b >= 1005){\n\t\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t\t\treturn 0;\n\t\t}\n\t\tint lb = 0,ub = 1007;\n\t\twhile(ub-lb>1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tif(c >= b+mid){\n\t\t\t\tlb = mid; continue;\n\t\t\t}\n\t\t\tpriority_queue<P1>que;\n\t\t\tpriority_queue<P,vector<P>,greater<P> >que2;\n\t\t\tint zan = c-b;\n\t\t\tint lazy = 0;\n\t\t\tint cur = 0;\n\t\t\trepn(i,n){\n\t\t\t\tif(i%2 == 1) cur += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(cur>=mid){\n\t\t\t\t\t\tque2.push(mp(cur-a[i],i));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tque.push(mp(cur,mp(cur-a[i],i)));\n\t\t\t\t\t}\n\t\t\t\t\tcur -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint pre = -1;\n\t\t\twhile(1){\n\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t}\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP1 p = que.top();\n\t\t\t\t\tif(p.sc.sc<=pre){\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy >= mid){\n\t\t\t\t\t\tque2.push(p.sc);\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbool ok = 0;\n\t\t\t\twhile(!que2.empty()){\n\t\t\t\t\tP p = que2.top();\n\t\t\t\t\tif(p.sc<=pre){\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi>=0){\n\t\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlazy += p.fi;\n\t\t\t\t\t\tpre = p.sc;\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(0);\n\t\t\tfail:;\n\t\t}\n\t\tassert(lb+b>=c);\n\t\tprintf(\"%lld %lld\\n\",lb+b,c-lb);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n#include <bitset>\n#include <assert.h>\n#include <complex.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long Int;\ntypedef unsigned long long UInt;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double Pi = acos(-1.0);\nconst int INF = 1000000000;\nconst Int INF2 = Int(INF) * 5000;\nconst Int INF3 = Int(INF) * INF;\nconst int MAX = 300007;\nconst int MAXE = 2007000;\nconst int MAXV = 5000;\nconst int BASE = 1000000000;\nconst int ST = 1000000007;\n\nconst int MOD = 1000000007;\n\nint a[MAX];\n\nint s[2][MAX];\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\" , \"w\", stdout);\n\n\n    int n;\n    cin >> n;\n\n    FOR(i,0,n)\n    {\n        scanf(\"%d\" , &a[i]);\n\n        s[0][i + 1] += s[0][i];\n        s[1][i + 1] += s[1][i];\n\n        s[i % 2][i + 1] += a[i];\n    }\n\n    if (n % 2 == 0)\n    {\n        cout << max(s[0][n] , s[1][n]) << ' ' << min(s[0][n] , s[1][n]) << endl;\n        return 0;\n    }\n\n    int res = s[0][n];\n\n    for(int i = 1; i < n; i += 2)\n    {\n        int r1 = s[1][i + 1] + s[0][n] - s[0][i + 1];\n        int r2 = s[0][i] + s[1][n] - s[1][i];\n        res = max(res , min(r1 ,r2));\n    }\n\n    cout << res << ' ' << s[0][n] + s[1][n] - res << endl;\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\nint sum = 0;\nint main(){\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tint diff = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(i % 2){\n\t\t\tdiff -= a[i];\n\t\t} else {\n\t\t\tdiff += a[i];\n\t\t}\n\t}\n\tif(n % 2 == 0){\n\t\tcout << (sum + max(diff, -diff)) / 2 << \" \" << (sum - max(diff, -diff)) / 2 << '\\n';\n\t\treturn 0;\n\t}\n\tif(diff >= 1000){\n\t\tcout << (sum + diff) / 2 << \" \" << (sum - diff) / 2 << '\\n';\n\t\treturn 0;\n\t}\n\tint s = 0; // yes\n\tint e = 1000; // no\n\twhile(s + 1 < e){\n\t\tint d = (s + e) / 2;\n\t\tvector<int> r;\n\t\tr.push_back(a[0]);\n\t\tfor(int i = 1; i < n; i += 2){\n\t\t\tif(r[r.size() - 1] < d || a[i] <= r[r.size() - 1]){\n\t\t\t\tr[r.size() - 1] += a[i+1] - a[i];\n\t\t\t} else {\n\t\t\t\tr.push_back(a[i]);\n\t\t\t\tr.push_back(a[i+1]);\n\t\t\t}\n\t\t}\n\t\tif(r[r.size() - 1] >= d){\n\t\t\ts = d;\n\t\t} else {\n\t\t\te = d;\n\t\t}\n\t}\n\tcout << (sum + max(diff, (-diff + 2 * s))) / 2 << \" \" << (sum - max(diff, (-diff + 2 * s))) / 2 << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, w[301010], S[301000];\nint sum = 0;\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tsum += w[i];\n\t}\n\tint ss = 0;\n\tS[1] = w[1];\n\tfor (i = 2; i <= n; i++)S[i] = S[i - 2] + w[i];\n\tss = max(S[n], sum - S[n]);\n\tif (n % 2 == 0) {\n\t\tprintf(\"%d %d\\n\", ss, sum - ss);\n\t\treturn 0;\n\t}\n\tfor (i = 2; i < n; i += 2) {\n\t\tint r1 = S[n - 1] - S[i];\n\t\tint r2 = S[n] - S[i - 1];\n\t\tint l1 = S[i - 2];\n\t\tint l2 = S[i - 1];\n\t\tss = max(ss, min(l1 + r2, r1 + l2) + w[i]);\n\t}\n\tprintf(\"%d %d\\n\", ss, sum - ss);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, a[300233], W = 0, B = 0;\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    (i & 1 ? B : W) += a[i];\n  }\n  if (!(n & 1)) {\n    printf(\"%d %d\\n\", max(B, W), min(B, W));\n    return 0;\n  }\n  int l = 0, r = 300000001;\n  while (l < r) {\n    int mid = (l + r + 1) >> 1, sum = a[1];\n    for (int i = 2; i <= n; i += 2) {\n      if (sum >= mid) {\n        sum = max(sum - a[i] + a[i + 1], a[i + 1]);\n      } else {\n        sum = sum - a[i] + a[i + 1];\n      }\n    }\n    if (sum >= mid) {\n      l = mid;\n    } else {\n      r = mid - 1;\n    }\n  }\n  printf(\"%d %d\\n\", W + l, B - l);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N;\nvi A;\nll sum = 0, W, B, res;\n\nvoid solve0() { res = max(W,B); }\n\nbool test(int mid) {\n    int csum = A[0];\n    for (int i = 1; i < sz(A); i += 2) {\n        if (csum < mid) csum += A[i+1]-A[i];\n        else csum = A[i+1]+max(0,csum-A[i]);\n    }\n    return csum >= mid;\n}\n\nvoid solve1() {\n    int lo = 0, hi = 1e9;\n    while (lo < hi) {\n        int mid = (lo+hi+1)/2;\n        if (test(mid)) lo = mid;\n        else hi = mid-1;\n    }\n    res = W+lo;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N; A.resize(N); F0R(i,N) cin >> A[i];\n    F0R(i,N) {\n        if (i&1) W += A[i];\n        else B += A[i];\n    }\n    sum = W+B;\n    if (N % 2 == 0) solve0();\n    else solve1();\n    cout << res << \" \" << sum-res;\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int N = 3e5 + 5;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, a[N], s[N];\nvoid solve1() {\n\tint s0 = 1, s1 = 0;\n\tfor(int i = 1; i <= n; ++ i) if(i & 1) s0 += a[i]; else s1 += a[i];\n\tprintf(\"%d %d\\n\", max(s0, s1), min(s0, s1));\n}\nbool check(int mid) {\n\tint v = 0;\n\tfor(int i = 1; i < n; i += 2) if(s[i] - v >= mid) v = min(v, s[i + 1]);\n\treturn s[n] - v >= mid;\n}\nvoid solve2() {\n\tfor(int i = 1; i <= n; ++ i) if(i & 1) s[i] += a[i]; else s[i] -= a[i];\n\tint l = 1, r = n * 1000, mid;\n\twhile(l < r) {\n\t\tmid = (l + r) >> 1;\n\t\tif(check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tfor(int i = 2; i <= n; i += 2) l += a[i];\n\tint sum = 0;\n\tfor(int i = 1; i <= n; ++ i) sum += a[i];\n\tprintf(\"%d %d\\n\", l, sum - l); \n}\nint main() {\n\tn = read();\n\tfor(int i = 1; i <= n; ++ i) a[i] = read();\n\tif(n % 2 == 0) return solve1(), 0;\n\telse return solve2(), 0;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\ntypedef long long ll;\ntypedef double dd;\n#define For(i,j,k) for (int i=(int)j;i<=(int)k;++i)\n#define Forr(i,j,k) for (int i=(int)j;i>=(int)k;--i)\n#define Set(a,p) memset(a,p,sizeof(a))\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b) { return a<b?a=b,1:0; }\ntemplate<typename T>bool chkmin(T &a,T b) { return a>b?a=b,1:0; }\n\nconst int maxn=3e5+1e2;\nint n;\nint B,W;\nint sum[maxn];\n\ninline void file() {\n\tfreopen(\"AGC026F.in\",\"r\",stdin);\n\tfreopen(\"AGC026F.out\",\"w\",stdout);\n}\n\ninline int read() {\n\tint x=0,p=1;\n\tchar c=getchar();\n\twhile (!isdigit(c)) { if (c=='-') p=-1; c=getchar();}\n\twhile (isdigit(c)) { x=(x<<1)+(x<<3)+(c-'0'); c=getchar();}\n\treturn x*p;\n}\n\ninline bool check(int p) {\n\tint lst=0;\n\tfor (int i=2;i<=n-1;i+=2)\n\t\tif (sum[i-1]-lst>=p) chkmin(lst,sum[i]);\n\treturn sum[n]-lst>=p;\n}\n\ninline int calc() {\n\tint l=-2e9,r=2e9,ans=0;\n\twhile (l+1<r) {\n\t\tint mid=(l+r)/2;\n\t\tif (check(mid)) chkmax(ans,mid),l=mid;\n\t\telse r=mid;\n\t}\n\treturn ans;\n}\n\nint main() {\n//\tfile();\n\tn=read();\n\tFor (i,1,n) {\n\t\tint x=read();\n\t\tif (i&1) sum[i]=sum[i-1]+x,B+=x;\n\t\telse sum[i]=sum[i-1]-x,W+=x;\n\t}\n\tif (n%2==0) {\n\t\tprintf(\"%d %d\",max(B,W),min(B,W)); return 0;\n\t}\n\tint Ans=calc();\n\tprintf(\"%d %d\",W+Ans,B-Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0 , f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 3e5 + 5;\nint n;\nint W , B;\nint a[N] , sum[N];\ninline bool check(int mid)\n{\n\tint minn = 0;\n\tfor(int i = 2;i < n;i += 2) if(sum[i - 1] - minn >= mid) minn = min(minn,sum[i]);\n\treturn sum[n] - minn >= mid;\n}\nint main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\ta[i] = read(); sum[i] = sum[i - 1];\n\t\tif(i & 1) B += a[i] , sum[i] += a[i];\n\t\telse W += a[i] , sum[i] -= a[i];\n\t}\n\tif(!(n & 1)) printf(\"%d %d\\n\",max(B,W),min(B,W));\n\telse\n\t{\n\t\tint l = -3e8 , r = 3e8 , ans = 0;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif(check(mid)) ans = mid , l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tint res = max(W + ans,B);\n\t\tprintf(\"%d %d\\n\",res,W + B - res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300005;\n\nint n;\nint a[N];\nlong long sum[2][N];\nmap< pair<int, int>, long long> mp;\n\nlong long cal(int l, int r) {\n\tif (mp.count({l, r})) return mp[{l, r}];\n\tlong long &ret = mp[{l, r}];\n\tret = max(sum[0][r] - sum[0][l - 1], sum[1][r] - sum[1][l - 1]);\n\tif ((r - l + 1) % 2 == 0) return ret;\n\tfor (int i = l + 1; i < r; i += 2) {\n\t\tret = max(ret, min(cal(l, i - 1), cal(i + 1, r)) + a[i]);\n\t}\n\treturn ret;\n}\n\nint main() {\n\t// srand(time(0));\n\tios::sync_with_stdio(false);\n\t// n = 300000;\n\t// for (int i = 1; i <= n; ++i) a[i] = rand() % n + 1;\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\tlong long all = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tall += a[i];\n\t\tsum[0][i] = sum[0][i - 1] + (i % 2 == 0) * a[i];\n\t\tsum[1][i] = sum[1][i - 1] + (i % 2 == 1) * a[i]; \n\t}\n\tlong long res = cal(1, n);\n\tcout << res << ' ' << all - res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define N 100010\nusing namespace std;\nint num[N],sum[N];\nint n;\nbool check(int x)\n{\n\tint ans=0;\n\tfor(int i=1;i<=n;i+=2)\n\tif(ans+x<=sum[i]) ans=min(ans,sum[i+1]);\n\treturn x+ans<=sum[n];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint a[2]={0,0};\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&num[i]),a[i&1]+=num[i];\n\tif(n&1)\n\t{\n\t\tfor(int i=1;i<=n;i++) sum[i]=sum[i-1]+(i&1?1:-1)*num[i];\n\t\tint l=0,r=a[0]+a[1],ans=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(check(mid)) l=mid+1,ans=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",a[0]+ans,a[1]-ans);\n\t}\n\telse printf(\"%d %d\\n\",max(a[0],a[1]),min(a[0],a[1]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 200200;\nconst int mod = 998244353;\ntypedef long long ll;\ninline ll pow(ll a,int b,ll ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1) ans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\ninline void reduce(int & x){ x += x >> 31 & mod; }\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nint sum;\nint n, a[maxn];\nint a0[maxn], a1[maxn];\nint s0[maxn];\ninline void output(int x) { std::cout << x << ' ' << sum - x << '\\n', exit(0); }\ninline bool ok(int x) {\n\tint k = 0;\n\tfor(int i = 2;i <= n;i += 2) if(s0[i - 1] - k >= x) k = std::min(k, s0[i]);\n\treturn s0[n] - k >= x;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor(int i = 1;i <= n;++i){\n\t\tstd::cin >> a[i], sum += a[i];\n\t\ta0[i] = a0[i - 1];\n\t\ta1[i] = a1[i - 1];\n\t\ti[i & 1 ? a0 : a1] += a[i];\n\t}\n\tif(n % 2 == 0) output(std::max(a0[n], a1[n]));\n\tfor(int i = 1;i <= n;++i) s0[i] = s0[i - 1] + (i & 1 ? a[i] : -a[i]);\n\tint l = 0,r = 1e9;\n\tfor(;l + 1 != r;) {\n\t\tint mid = l + r >> 1;\n\t\t(ok(mid) ? l : r) = mid;\n\t}\n\tstd::cout << a1[n] + l << ' ' << a0[n] - l << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\n#define int long long\nconst int N=3e5+5;\n\nint n;\nint a[N];\nint ans,sum;\n\nbool check(int x){\n    //printf(\"check(%lld)\\n\",x);\n    int pos=0;//a[0]=0\n    for(int i=2;i<=n+1;i+=2){\n        if(a[i-1]-a[pos]<=x)pos=i;\n    }\n    //printf(\"pos=%lld\\n\",pos);\n    return pos>=n;\n}\nsigned main(){\n    scanf(\"%lld\",&n);\n    FOR(i,1,n)scanf(\"%lld\",&a[i]),sum+=a[i];\n    int c[2]={0,0};\n    FOR(i,1,n)c[i&1]+=a[i];\n    if(c[0]<c[1])swap(c[0],c[1]);\n    if(n%2==0){\n        printf(\"%lld %lld\\n\",c[0],c[1]);\n        return 0;\n    }\n    for(int i=1;i<=n;i+=2)a[i]=-a[i];\n    //FOR(i,1,n)printf(\"%lld%c\",a[i],\" \\n\"[i==n]);\n    for(int i=2;i<=n;i+=2)ans+=a[i];\n    FOR(i,2,n+1)a[i]+=a[i-1];\n    int l=-1e9,r=1e9,mid;\n    while(l<r)mid=floor((l+r+0.0)/2),check(mid)?r=mid:l=mid+1;\n    //printf(\"ans=%lld\\n\",ans);\n    ans-=l;\n    if(ans>c[0])printf(\"%lld %lld\\n\",ans,sum-ans);\n    else printf(\"%lld %lld\\n\",c[0],c[1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[301010], S[301000], P[301000], SS[301000];\nint L[301000], R[301000];\nint sum = 0;\nint Get(int b, int e) {\n\tint i, sum = 0;\n\tfor (i = b; i <= e; i++) {\n\t\tP[i - b + 1] = w[i];\n\t\tsum += w[i];\n\t}\n\tint n = e - b + 1;\n\tSS[1] = P[1];\n\tfor (i = 2; i <= n; i++)SS[i] = SS[i - 2] + P[i];\n\tint ss = max(SS[n], sum - SS[n]);\n\tif (n % 2 == 0)return ss;\n\tfor (i = 2; i < n; i += 2) {\n\t\tint r1 = SS[n - 1] - SS[i];\n\t\tint r2 = SS[n] - SS[i - 1];\n\t\tint l1 = SS[i - 2];\n\t\tint l2 = SS[i - 1];\n\t\tss = max(ss, min(l1 + r2, r1 + l2) + P[i]);\n\t}\n\treturn ss;\n}\nint main() {\n\tint i, n;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tsum += w[i];\n\t}\n\tint ss = 0;\n\tS[1] = w[1];\n\tfor (i = 2; i <= n; i++)S[i] = S[i - 2] + w[i];\n\tfor (i = 1; i <= n; i++) {\n\t\tL[i] = Get(1, i);\n\t\tR[i] = Get(i, n);\n\t}\n\tss = max(S[n], sum - S[n]);\n\tif (n % 2 == 0) {\n\t\tprintf(\"%d %d\\n\", ss, sum - ss);\n\t\treturn 0;\n\t}\n\tfor (i = 2; i < n; i += 2) {\n\t\tint r1 = S[n - 1] - S[i];\n\t\tint l1 = S[i - 2];\n\t\tss = max(ss, min(l1 + R[i+1], r1 + L[i-1]) + w[i]);\n\t}\n\tprintf(\"%d %d\\n\", ss, sum - ss);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N + 4);\n\tfor (int i = 2; i <= N + 1; i++) {\n\t\tcin >> v[i];\n\t}\n\tvector<int>oddl(N + 4);\n\tvector<int>evenl(N + 4);\n\tfor (int i = 2; i <= N + 3; i++) {\n\t\toddl[i] = oddl[i - 1];\n\t\tif (i % 2)oddl[i] += v[i];\n\t}\n\tfor (int i = 2; i <= N + 3; i++) {\n\t\tevenl[i] = evenl[i - 1];\n\t\tif (i % 2 == 0) evenl[i] += v[i];\n\t}\n\tvector<int>oddr(N + 4);\n\tvector<int>evenr(N + 4);\n\tfor (int i = N + 1; i >= 0; i--) {\n\t\toddr[i] = oddr[i + 1];\n\t\tif (i % 2)oddr[i] += v[i];\n\t}\n\tfor (int i = N + 1; i >= 0; i--) {\n\t\tevenr[i] = evenr[i + 1];\n\t\tif (i % 2 == 0) evenr[i] += v[i];\n\t}\n\tint evenmin = 100000;\n\tfor (int i = 2; i <= N + 1; i++) {\n\t\tif (i % 2 == 0)\t\tevenmin = min(evenmin, v[i]);\n\t}\n\tint ans = max(evenl[N + 1], oddl[N + 1]);\n\tif (N % 2)ans = max(ans, oddl[N + 1] + evenmin);\n\tfor (int i = 2; i <= N + 1; i++) {\n\t\tif (i % 2) {\n\t\t\tif (N % 2) {\n\t\t\t\tans = max(ans, min(oddl[i] + max(evenr[i + 1], oddr[i + 1]), oddr[i] + max(evenl[i - 1], oddl[i - 1])));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = max(ans, min(oddl[i] + max(evenr[i + 1], oddr[i + 1]), oddr[i] + min(evenl[i - 1], oddl[i - 1])));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (N % 2) {\n\t\t\t\tans = max(ans, min(evenl[i] + min(oddr[i + 1], evenr[i + 1]), evenr[i] + min(oddl[i - 1], evenl[i - 1])));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = max(ans, min(evenl[i] + min(oddr[i + 1], evenr[i + 1]), evenr[i] + max(oddl[i - 1], evenl[i - 1])));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \" \" << accumulate(v.begin(), v.end(), 0) - ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n    static short st[30];short tp=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++tp]=x%10,x/=10; while(x);\n    while(tp) putchar('0'|st[tp--]);\n    putchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int N = 300500;\nint sum[N], a[N], res, t, n;\nbool check(int mid) {\n    int k = 0;\n    for (int i = 2;i <= n; i += 2) \n        if (sum[i-1] - k >= mid) Mn(k, sum[i]);\n    return sum[n] - k >= mid;\n}\n\nint main() {\n    read(n);\n    for (int i = 1;i <= n; i++) {\n        read(a[i]), sum[i] = i & 1 ? sum[i-1] + a[i] : sum[i-1] - a[i];\n        res += a[i];\n    }\n    if (~n & 1) {\n        t = max(sum[n], -sum[n]);\n        write((res + t) / 2, ' '), write((res - t) / 2);\n        return 0;\n    }\n    int l = 0, r = 1e9;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (check(mid)) l = mid + 1;\n        else r = mid - 1;\n    }\n    t  = -sum[n] + 2 * r;\n    write((res + t) / 2, ' '), write((res - t) / 2, ' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 310000;\n\nint n;\nll a[MAXN];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\tif (n % 2 == 0) {\n\t\tll x = 0;\n\t\tll y = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (i % 2 == 0)\n\t\t\t\tx += a[i];\n\t\t\telse\n\t\t\t\ty += a[i];\n\t\tcout << max(x, y) << \" \" << min(x, y) << \"\\n\";\n\t\treturn 0;\n\t}\n\tll base = 0;\n\tll sum = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tsum += a[i];\n\t\tif (i % 2 == 0)\n\t\t\tbase -= a[i];\n\t\telse\n\t\t\tbase += a[i];\n\t}\n\tll l = max(0ll, -base * 2);\n\tll r = 1e9;\n\twhile (r - l > 1) {\n\t\tll mid = (l + r) >> 1;\n\t\tset<ll> ss;\n\t\tss.insert(0);\n\t\tll cur = 2 * a[0];\n\t\tint fl = 0;\n\t\tfor (int i = 0; i < n; i += 2) {\n\t\t\tif (i > 0)\n\t\t\t\tcur -= a[i - 1] * 2, cur += 2 * a[i];\n\t\t\tif (cur - *ss.begin() >= mid) {\n\t\t\t\tif (i == n - 1)\n\t\t\t\t\tfl = 1;\n\t\t\t\telse {\n\t\t\t\t\tss.insert(cur - 2 * a[i + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fl)\n\t\t\tl = mid;\n\t\telse\n\t\t\tr = mid;\n\t}\n\tll diff = base + l;\n\tcout << (sum + diff) / 2 << \" \" << (sum - diff) / 2 << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\nusing namespace std;\n\nbool canMake(vector<int> &v, int x) {\n    int n = v.size();\n    int sum = v[0], best = 0;\n    \n    for(int i = 1; i < n + 2; i += 2) {\n        if(sum - best >= x) {\n            if(i == n)\n                return true;\n            if(i < n) {\n                best = min(best, sum - v[i]);\n            }\n        }\n\n        if(i < n) {\n            sum -= v[i];\n        }\n\n        if(i + 1 < n) {\n            sum += v[i + 1];\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<int> v(n, 0);\n    vector<int> p(2, 0);\n\n    for(int i = 0; i < n; i += 1) {\n        cin >> v[i];\n        p[i % 2] += v[i];\n    }\n\n    if(n % 2 == 0) {\n        cout << max(p[0], p[1]) << \" \" << min(p[0], p[1]) << \"\\n\";\n        return 0;\n    }  \n\n    int ans = p[0];\n    int best = 0;\n\n    for(int lf = 0, rt = 1e8; lf <= rt;) {\n        int mid = (lf + rt) / 2;\n        if(canMake(v, mid)) {\n            best = mid;\n            lf = mid + 1;\n        } else {\n            rt = mid - 1;\n        }\n    }\n    \n    ans = max(ans, p[1] + best);\n    cout << ans << \" \" << p[0] + p[1] - ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint sm;\nint solve(){\n\tint N;\n\tcin>>N;\n\tvector<int> a(N);\n\trep(i,N) cin>>a[i];\n\trep(i,N) sm += a[i];\n\tvector<int> sum(N+1);\n\tvector<int> le(N+1),ri(N+1);\n\trep(i,N){\n\t\tsum[i+1] = sum[i] + a[i];\n\t}\n\trep(i,N){\n\t\tle[i+1] = a[i] - le[i];\n\t}\n\trep(i,N){\n\t\tri[i+1] = a[N-1-i] - ri[i];\n\t}\n\tif(N%2==0){\n\t\treturn max(le[N],ri[N]);\n\t}\n\tint mx = 0;\n\trep(i,N){\n\t\tif(i%2==0){\n\t\t\tint x = le[i+1] + min(ri[N-1-i],-ri[N-1-i]);\n\t\t\tint y = ri[N-i] + min(le[i],-le[i]);\n\t\t\tchmax(mx,min(x,y));\n\t\t}else{\n\t\t\tint x = le[i+1] + ri[N-i-1];\n\t\t\tint y = ri[N-i] + le[i];\n\t\t\tchmax(mx,min(x,y));\n\t\t}\n\t}\n\treturn mx;\n}\nint main(){\n\tint dif = solve();\n\tint a = (sm+dif)/2;\n\tint b = sm - a;\n\tcout<<a<<\" \"<<b<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define R(i,n) for(int i = 0; i < (n); i++)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, set<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\n\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.FI << \",\" << P.SE << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 300001;\nint t[MAX],sum = 0;\nint n;\nvoid pri(int dif){\n  cout << (sum + dif) / 2 << \" \" << (sum - dif) / 2 << \"\\n\";\n  exit(0);\n}\nbool spr(int x){\n  int naj = 0;\n  R(i,n){\n    if(i % 2 == 0){\n      naj += t[i];\n    }else{\n      int pom = naj - t[i];\n      if(naj >= x){\n        naj = max(pom,0ll);\n      }else{\n        naj = pom;\n      }\n    }\n  }\n  return naj >= x;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  R(i,n){\n    cin >> t[i];\n    sum += t[i];\n  }\n  int res = 0;\n  R(i,n){\n    res += (i % 2 ? 1 : -1) * t[i];\n  }\n  if(n % 2 == 0){\n    pri(abs(res));\n  }\n  int po = 0, ko = 1e9;\n  while(po + 1 != ko){\n    int m = (po + ko) / 2;\n    if(spr(m)){\n      po = m;\n    }else{\n      ko = m;\n    }\n  }\n  pri(res + 2 * po);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\ntypedef unsigned int u32;\nconst int N=3e5+5;\nint n,a[N],s[N][2];\ntemplate<class T>T abs(T x){return x<0?-x:x;}\ntemplate<class T>bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>T min(T a,T b){return a<b?a:b;}\nint solve(int l,int r){\n\tif(l==r)return a[l];\n\tint res=abs((s[r][0]-s[l-1][0])-(s[r][1]-s[l-1][1])),c,x;\n\tif((l^r^1)&1){\n\t\tc=!(l&1);\n\t\tfor(x=l+1;x<=r;x+=2){\n\t\t\tif(s[x-1][c]-s[l-1][c]>=s[x-1][c^1]-s[l-1][c^1]&&s[r][c]-s[x][c]>=s[r][c^1]-s[x][c^1])continue;\n\t\t\tchkmax(res,min(solve(l,x-1)+(s[r][c]-s[x-1][c])-(s[r][c^1]-s[x-1][c^1]),solve(x+1,r)+(s[x][c]-s[l-1][c])-(s[x][c^1]-s[l-1][c^1])));\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)s[i][0]=s[i-1][0],s[i][1]=s[i-1][1],scanf(\"%d\",a+i),s[i][i&1]+=a[i];\n\tu32 dif=solve(1,n);\n\tu32 sum=(u32)s[n][0]+s[n][1];\n\tu32 sigma=(sum-dif)>>1,sugim=sigma+dif;\n\tprintf(\"%u %u\\n\",sugim,sigma);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 200200;\nconst int mod = 998244353;\ntypedef long long ll;\ninline ll pow(ll a,int b,ll ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1) ans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\ninline void reduce(int & x){ x += x >> 31 & mod; }\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nint sum;\nint n, a[maxn];\nint a0[maxn], a1[maxn];\nint s0[maxn];\ninline void output(int x) { std::cout << x << ' ' << sum - x << '\\n', exit(0); }\ninline bool ok(int x) {\n\tint k = 0;\n\tfor(int i = 2;i <= n;i += 2) if(s0[i - 1] - k >= x) k = std::min(k, s0[i]);\n\treturn s0[n] - k >= x;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor(int i = 1;i <= n;++i){\n\t\tstd::cin >> a[i], sum += a[i];\n\t\ta0[i] = a0[i - 1];\n\t\ta1[i] = a1[i - 1];\n\t\ti[i & 1 ? a0 : a1] += a[i];\n\t}\n\tif(n % 2 == 0) output(std::max(a0[n], a1[n]));\n\tfor(int i = 1;i <= n;++i) s0[i] = s0[i - 1] + (i & 1 ? a[i] : -a[i]);\n\tint l = 0,r = 1e9;\n\tfor(;l + 1 != r;) {\n\t\tint mid = l + r >> 1;\n\t\t(ok(mid) ? l : r) = mid;\n\t}\n\tstd::cout << ok(41) << '\\n';\n\tstd::cout << a1[n] + l << ' ' << a0[n] - l << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e5+20;\n\nint n,a[maxn],sum;\n\ninline void init()\n{\n\tn=read();\n\tREP(i,1,n)a[i]=read(),sum+=a[i];\n}\n\nint x[maxn],y[maxn];\n\ninline bool check(int ck)\n{\n\tint mx=0;\n\tREP(i,1,n>>1)\n\t{\n\t\tif(x[i]+mx>=ck)chkmax(mx,-y[i]);\n\t}\n\tif(x[n+1>>1]+mx>=ck)return 1;\n\telse return 0;\n}\n\ninline void doing()\n{\n\tif(~n&1)\n\t{\n\t\tint B=0,W=0;\n\t\tREP(i,1,n)if(i&1)B+=a[i];else W+=a[i];\n\t\tif(B<W)swap(B,W);\n\t\tprintf(\"%d %d\\n\",B,W);\n\t}else\n\t{\n\t\tint W=0;\n\t\tREP(i,1,n)if(~i&1)W+=a[i];\n\t\tREP(i,1,n+1>>1)x[i]=x[i-1]+a[i*2-1]-a[i*2-2],y[i]=y[i-1]+a[i*2-1]-a[i*2];\n\t\tint l=0,r=sum;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=l+r+1>>1;\n\t\t\tif(check(mid))l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",W+l,sum-W-l);\n\t}\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll> \n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1<<30)\n#define int long long\nusing namespace std;\nconst int N=300005;\nint n,a[N],B,W,s[N];\nbool ok(int t){\n\tint mn=0;\n\tfor (int i=2;i<=n-1;i+=2)\n\t\tif (s[i-1]-mn>=t) mn=min(mn,s[i]);\n\treturn s[n]-mn>=t;\n}\nint calc(){\n\tint l=0,r=B,ans;\n\twhile (l<=r){\n\t\tint mid=((ll)l+r)/2;\n\t\tif (ok(mid)) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn ans;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tif (i%2==0) W+=a[i],s[i]=s[i-1]-a[i];\n\t\telse B+=a[i],s[i]=s[i-1]+a[i]; \n\t}\n\tif ((!n&1))\n\t\treturn printf(\"%lld %lld\\n\",max(W,B),min(W,B)),0;\n\tll ans=W+calc();\n\tprintf(\"%lld %lld\\n\",ans,(ll)B+W-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <map>\n#include <set>\n#define ri register int\n#define pi acos(-1.0)\n\nusing namespace std;\n\ninline char gch()\n{\n    static char buf[100010], *h = buf, *t = buf;\n    return h == t && (t = (h = buf) + fread(buf, 1, 100000, stdin), h == t) ? EOF : *h ++;\n}\n\ntypedef long long lo;\n\ntypedef unsigned int uint;\n\ntemplate<typename inp_typ>\n\ninline void re(inp_typ &x)\n{\n    x = 0;\n    char a; bool b = 0;\n    while(!isdigit(a = getchar()))\n        b = a == '-';\n    while(isdigit(a))\n        x = x * 10 + a - '0', a = getchar();\n    if(b == 1)\n        x = - x;\n}\n\nint n, bla, whi, a[300030];\n\ninline bool check(int v)\n{\n    int su = 0;\n    for(ri i = 1; i <= n; i += 2)\n        if(su >= v)\n            su = max(su + a[i] - a[i - 1], a[i]);\n        else\n            su += a[i] - a[i - 1];\n    return su >= v;\n}\n\nint main()\n{\n    re(n);\n    for(ri i = 1; i <= n; re(a[i]), bla += (i & 1) ? a[i] : 0, whi += (!(i & 1)) ? a[i] : 0, i ++);\n    if(!(n & 1))\n        printf(\"%d %d\", max(bla, whi), min(bla, whi));\n    else\n    {\n        int l = 0, r = bla, ans = 0;\n        while(l <= r)\n        {\n            int mid = (l + r) >> 1;\n            if(check(mid))\n                ans = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        }\n        printf(\"%d %d\", max(bla, whi + ans), min(whi, bla - ans));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 3e5, inf = 3e8;\nint n, a[maxn + 3], b[maxn + 3], w[maxn + 3], s[maxn + 3];\nbool dp[maxn + 3];\n\nbool check(int x) {\n\tint mn = 0;\n\tfor (int i = 1; i <= n; i += 2) {\n\t\tif (s[i] - mn >= x) {\n\t\t\tdp[i] = true;\n\t\t\tmn = min(mn, s[i + 1]);\n\t\t} else {\n\t\t\tdp[i] = false;\n\t\t}\n\t}\n\treturn dp[n];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = b[i - 1], w[i] = w[i - 1];\n\t\ti & 1 ? b[i] += a[i] : w[i] += a[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\ts[i] = b[i] - w[i];\n\t}\n\tif (~n & 1) {\n\t\tprintf(\"%d %d\\n\", max(b[n], w[n]), min(b[n], w[n]));\n\t} else {\n\t\tint l = -inf, r = inf, mid;\n\t\twhile (l < r) {\n\t\t\tmid = ((l + r + inf * 2 + 1) >> 1) - inf;\n\t\t\tif (check(mid)) {\n\t\t\t\tl = mid;\n\t\t\t} else {\n\t\t\t\tr = mid - 1;\n\t\t\t}\n\t\t}\n\t\tint x = max(w[n] + l, b[n]);\n\t\tprintf(\"%d %d\\n\", x, b[n] + w[n] - x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, a[303030], b[303030], S;\n\nstruct Segtree{\n    long long N, M;\n    long long mnm[1048576], mxm[1048576];\n    void init(){\n        for(int i = 0; i < M; ++i)mnm[i + N] = mxm[i + N] = b[i];\n        for(int i = N - 1; i; --i){\n            mnm[i] = min(mnm[2 * i], mnm[2 * i + 1]);\n            mxm[i] = max(mxm[2 * i], mxm[2 * i + 1]);\n        }\n    }\n    Segtree(long long _N) : mnm(), mxm(){\n        N = 1;\n        M = _N;\n        while(N < _N)N *= 2;\n    }\n    long long mnn(long long L, long long R){\n        L += N;\n        R += N;\n        long long ret = 189501249917890;\n        while(L < R){\n            if(L & 1){\n                ret = min(ret, mnm[L]);\n                ++L;\n            }\n            if(R & 1){\n                ret = min(ret, mnm[R - 1]);\n            }\n            L /= 2;\n            R /= 2;\n        }\n        return ret;\n    }\n    long long mxx(long long L, long long R){\n        L += N;\n        R += N;\n        long long ret = -189501249917890;\n        while(L < R){\n            if(L & 1){\n                ret = max(ret, mxm[L]);\n                ++L;\n            }\n            if(R & 1){\n                ret = max(ret, mxm[R - 1]);\n            }\n            L /= 2;\n            R /= 2;\n        }\n        return ret;\n    }\n};\n\nSegtree sgt(524288);\n\nint main(){\n    scanf(\"%lld\", &N);\n    if(N & 1){\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + i);\n            S += a[i];\n            a[i] *= (i & 1) ? -1 : 1;\n        }\n        partial_sum(a, a + N, b + 1);\n        long long ans = b[N];\n        sgt.init();\n        for(int i = 1; i < N; i += 2){\n            ans = max(ans, -b[N] + 2 * min(sgt.mxx(i + 1, N + 1) - b[i + 1], b[i] - sgt.mnn(0, i)));\n        }\n        cout << (S + ans) / 2 << \" \" << (S - ans) / 2 << endl;\n    }else{\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + 4);\n            a[i & 1] += a[4];\n        }\n        if(a[0] < a[1])swap(a[0], a[1]);\n        cout << a[0] << \" \" << a[1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint n;\nint B,W;\nint a[300050];\nbool judge(int x)\n{\n\tint now=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(i&1)\n\t\t{\n\t\t\tnow+=a[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(now>=a[i]) now-=a[i];\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(now<x) return 0;\n\t\t\t\tnow=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn now>=x;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i&1) B+=a[i];\n\t\telse W+=a[i];\n\t}\n\tif(~n&1)\n\t{\n\t\tprintf(\"%d %d\\n\",max(B,W),min(B,W));\n\t\treturn 0;\n\t}\n\tint l=0,r=B,re=-1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(judge(mid)) l=mid+1,re=mid;\n\t\telse r=mid-1;\n\t}\n\tint an=max(B,W+re);\n\tprintf(\"%d %d\\n\",an,B+W-an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F(i, a, b) for (int i = a; i <= b; i ++)\n#define G(i, a, b) for (int i = a; i >= b; i --)\n#define out4(x, y, z, w) { if (debug) printf(#x\" = \"),W(x),printf(\" \"#y\" = \"),W(y),printf(\" \"#z\" = \"),W(z),printf(\" \"#w\" = \"),W(w),putc('\\n'); }\n#define out3(x, y, z) { if (debug) printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), printf(\" \"#z\" = \"), W(z), putc('\\n'); }\n#define out2(x, y) { if (debug) printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), putc('\\n'); }\n#define out1(x) { if (debug) printf(#x\" = \"), W(x), putc('\\n'); }\n#define outline(x) { if (debug) puts(\"-------------------------------------------\"#x\"----------------------------------------\"); }\n#define outarr(a, L, R) { if (debug) { printf(#a\"[%d..%d] = \", L, R); F(i, L, R) W(a[i]), putc(' '); putc('\\n'); } }\n#define Assert(x) { if ((debug) && (!(x))) { puts(\"Wrong Answer\"); exit(0); } }\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define mem(a, b) memset(a, b, sizeof a)\n#define mec(a, b) memcpy(a, b, sizeof a)\n#define mx(a, b) ((a) = max(a, b))\n#define mn(a, b) ((a) = min(a, b))\n#define lowbit(x) ((x) & (-(x)))\n#define abs(x) ((max(x, - (x))))\n#define get getchar()\n#define pb push_back\n#define putc putchar\n\ntemplate <typename Int>\nvoid R(Int &x) {\n\tchar c = get; x = 0; Int t = 1;\n\tfor (; !isdigit(c); c = get) t = (c == '-' ? - 1 : t);\n\tfor (; isdigit(c); x = (x << 3) + (x << 1) + c - '0', c = get); x *= t;\n}\ntemplate <typename Int>\nvoid W(Int x) {\n\tif (x < 0) { putc('-'); x = - x ; }\n\tif (x > 9) W(x / 10); putc(x % 10 + '0');\n}\n\n#define debug (0)\n\nusing namespace std;\n\nconst int N = 3e5 + 10;\nint n, a[N], f[N], S[N];\nint A, B, Ans;\n\nbool ok(int md) {\n\tf[0] = 1;\n\tF(i, 1, n + 1) {\n\t\tf[i] = 0;\n\t\tif (i % 2 == 0)\n\t\t\tF(j, 0, i - 1)\n\t\t\t\tif (f[j] && j % 2 == 0 && S[i - 1] - S[j] >= md)\n\t\t\t\t\tf[i] = 1;\n\t}\n\tout1(md);\n\toutarr(f, 1, n);\n\treturn f[n + 1];\n}\n\nint main() {\n//\tfreopen(\"data.in\",\"r\",stdin);\n\n\tR(n);\n\tF(i, 1, n) R(a[i]), A += a[i] * (i & 1), B += a[i], S[i] = a[i] * (i & 1 ? 1 : (-1));\n\tF(i, 1, n) S[i] += S[i - 1];\n\tB -= A;\n\tif (n & 1) {\n\t\tAns = A;\n\t\tout2(A, B);\n\t\tint l = 0, r = B + A;\n\t\twhile (l <= r) {\n\t\t\tint md = (l + r >> 1);\n\t\t\tif (ok(md))\n\t\t\t\tmx(Ans, B + md), l = md + 1;\n\t\t\telse\n\t\t\t\tr = md - 1;\n\t\t}\n\t}\n\telse\n\t\tAns = max(A, B);\n\tW(Ans), putc(' '), W(A + B - Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 300005;\n\nint n, A[N], S[N];\n\ninline int read() {\n\tint x = 0, f = 0, ch = getchar();\n\twhile (!isdigit(ch))\n\t\tf |= (ch == '-'), ch = getchar();\n\twhile (isdigit(ch))\n\t\tx = x * 10 + ch - '0', ch = getchar();\n\treturn f ? -x : x;\n}\n\ninline bool check(const int mid) {\n\tint v = 0;\n\tfor (int i = 1; i < n; i += 2)\n\t\tif (S[i] - v >= mid)\n\t\t\tv = min(v, S[i + 1]);\n\treturn S[n] - v >= mid;\n}\n\nint main() {\n\tn = read();\n\tint B = 0, W = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tA[i] = read();\n\t\tif (i & 1)\n\t\t\tB += A[i], S[i] = S[i - 1] + A[i];\n\t\telse\n\t\t\tW += A[i], S[i] = S[i - 1] - A[i];\n\t}\n\tif (n & 1)\n\t{\n\t\tint l = -N * 1000, r = N * 1000, mid, ans = 0;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif (check(mid))\n\t\t\t\tans = mid + W, l = mid + 1;\n\t\t\telse\n\t\t\t\tr = mid - 1;\n\t\t}\n\t\tans = max(ans, B);\n\t\tprintf(\"%d %d\\n\", ans, B + W - ans);\n\t}\n\telse\n\t\tprintf(\"%d %d\\n\", max(B, W), min(B, W));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nint sum = 0;\nint main(){\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tint diff = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(i % 2){\n\t\t\tdiff -= a[i];\n\t\t} else {\n\t\t\tdiff += a[i];\n\t\t}\n\t}\n\tif(n % 2 == 0){\n\t\tcout << (sum + max(diff, -diff)) / 2 << \" \" << (sum - max(diff, -diff)) / 2 << '\\n';\n\t\treturn 0;\n\t}\n\tif(diff >= 1000){\n\t\tcout << (sum + diff) / 2 << \" \" << (sum - diff) / 2 << '\\n';\n\t\treturn 0;\n\t}\n\tint s = 0;\n\tint e = 1000;\n\twhile(s + 1 < e){\n\t\tint d = (s + e) / 2;\n\t\tvector<int> r;\n\t\tr.push_back(a[0]);\n\t\tfor(int i = 1; i < n; i += 2){\n\t\t\tif(r[r.size() - 1] < d || a[i] <= r[r.size() - 1]){\n\t\t\t\tr[r.size() - 1] += a[i+1] - a[i];\n\t\t\t} else {\n\t\t\t\tr.push_back(a[i]);\n\t\t\t\tr.push_back(a[i+1]);\n\t\t\t}\n\t\t}\n\t\tif(r[r.size() - 1] >= d){\n\t\t\ts = d;\n\t\t} else {\n\t\t\te = d;\n\t\t}\n\t}\n\tcout << (sum + max(diff, (-diff + 2 * s))) / 2 << \" \" << (sum - max(diff, (-diff + 2 * s))) / 2 << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n; ll a[SZ],B,W,qz[SZ];\nbool ok(ll t)\n{\n\tll mo=0;\n\tfor(int i=2;i<=n-1;i+=2)\n\t\tif(qz[i-1]-mo>=t) mo=min(mo,qz[i]);\n\treturn qz[n]-mo>=t;\n}\nll calc()\n{\n\tll l=-1e18,r=1e18;\n\twhile(l<r)\n\t{\n\t\tll g=l+((r-l+1)>>1);\n\t\tif(ok(g)) l=g; else r=g-1;\n\t}\n\treturn l;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",a+i);\n\t\tif(i%2==0) W+=a[i],qz[i]=qz[i-1]-a[i];\n\t\telse B+=a[i],qz[i]=qz[i-1]+a[i];\n\t}\n\tif(n%2==0)\n\t{\n\t\tprintf(\"%lld %lld\\n\",max(W,B),min(W,B));\n\t\treturn 0;\n\t}\n\tll ans=W+calc();\n\tprintf(\"%lld %lld\\n\",ans,B+W-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstdlib>\n#include <utility>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstring>\n\nusing namespace std;\n\n#define ll long long\n\n#ifndef ONLINE_JUDGE\n#define debug(format, ...) fprintf(stderr, \\\n    \"%s:%d: \" format \"\\n\", __func__, __LINE__,##__VA_ARGS__)\n#else\n#define debug(format, ...)\n#define NDEBUG\n#endif\n\nint n;\nint a[300050];\nbool good[300050];\nint psum[300050];\n\nbool check(int amt)\n{\n    for (int i = 0; i <= n + 1; i++) good[i] = false;\n    int cur_min = 2000000000;\n    for (int i = 0; i <= n + 1; i += 2) {\n        if (i == 0 || psum[i-1] - psum[i-2] >= cur_min) {\n            good[i] = true;\n            cur_min = min(cur_min, amt - psum[n-1] - psum[i] + (i < 1 ? 0 : psum[i-1]));\n        }\n    }\n    return good[n + 1];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    int total = 0;\n    for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n    for (int i = 1; i <= n; i++) {\n        total += a[i];\n        psum[i] = a[i] + (i < 2 ? 0 : psum[i-2]);\n    }\n    if (n % 2 == 0) {\n        int odd = 0, even = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i % 2) odd += a[i];\n            else even += a[i];\n        }\n        printf(\"%d %d\", max(odd, even), min(odd, even));\n        return 0;\n    }\n    int l = 0;\n    int r = 300000000;\n    while (l < r) {\n        int mid = (l + r) / 2 + 1;\n        if (check(mid)) {\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    printf(\"%d %d\", l, total - l);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn=300111;\nstruct data\n{\n\tset<pair<int,int> >st;\n\tvoid add(int x,int y)//add (x,y)\n\t{\n\t\tst.insert(MP(x,y));\n\t\twhile(true)\n\t\t{\n\t\t\tset<pair<int,int> >::iterator it=st.lower_bound(MP(x,y+1));\n\t\t\tif(it!=st.end()&&it->SS<=y)st.erase(it);else break;\n\t\t}\n\t}\n\tint query(int l)//query max(y) when x<=l\n\t{\n\t\tset<pair<int,int> >::iterator it=st.lower_bound(MP(l+1,-2e9));\n\t\tif(it==st.begin())return -1e9;\n\t\telse\n\t\t{\n\t\t\tit--;\n\t\t\treturn it->SS;\n\t\t}\n\t}\n\tvoid init()\n\t{\n\t\tst.clear();\n\t}\n}yxg1,yxg2;\nint n;\nint a[maxn],pre[maxn];\nint dp0[maxn],dp1[maxn];\nint cost(int i,int j)\n{\n\treturn pre[j]-pre[i-1];\n}\nvoid out(int x)\n{\n\tint sum=0;\n\tfor(int i=1;i<=n;i++)sum+=a[i];\n//\tcerr<<\"sum=\"<<sum<<endl;\n\tassert((sum+x)%2==0);\n\tcout<<(sum+x)/2<<\" \"<<(sum-x)/2<<endl;\n}\nvoid calcdp(int dp[])\n{\n\tstatic int A[maxn],B[maxn];\n\tfor(int i=1;i<=n;i++)pre[i]=pre[i-1]+(i&1?a[i]:-a[i]);\n\tyxg1.init();\n\tyxg2.init();\n\tfor(int i=1;i<=n;i+=2)\n\t{\n\t\tdp[i]=cost(1,i);\n\t\tint X=pre[i];\n//\t\tdp[i]=max(dp[i],min(dp[j-1]-cost(j,i),cost(j+1,i)-cost(1,j)));\n//\t\tdp[i]=max(dp[i],min(dp[j]-pre[i]+pre[j],pre[i]-2*pre[j+1]));\n//\t\tdp[i]=max(dp[i],min(dp[j]-X+pre[j],X-2*pre[j+1]));\n//\t\tdp[i]=max(dp[i],-X+min(dp[j]+pre[j],2*X-2*pre[j+1]));\n//\t\tfor(int j=1;j<i;j+=2)dp[i]=max(dp[i],-X+min(A[j],2*X+B[j]));\n\t\tdp[i]=max(dp[i],-X+max(yxg1.query(2*X),2*X+yxg2.query(-2*X-1)));\n\t\tA[i]=dp[i]+pre[i];\n\t\tB[i]=-2*pre[i+1];\n\t\tyxg1.add(A[i]-B[i],A[i]);\n\t\tyxg2.add(B[i]-A[i],B[i]);\n\t}\n}\nint main()\n{\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)geti(a[i]);\n\tfor(int i=1;i<=n;i++)pre[i]=pre[i-1]+(i&1?a[i]:-a[i]);\n\tif(n%2==0)\n\t{\n\t\tout(max(pre[n],-pre[n]));\n\t\treturn 0;\n\t}\n\tint ans=pre[n];\n\tint sum=cost(1,n);\n\tcalcdp(dp0);\n\treverse(a+1,a+n+1);\n\tcalcdp(dp1);\n\treverse(a+1,a+n+1);\n\treverse(dp1+1,dp1+n+1);\n\tfor(int i=1;i<=n;i++)pre[i]=pre[i-1]+(i&1?a[i]:-a[i]);\n//\tfor(int i=1;i<=n;i+=2)cerr<<dp0[i]<<\" \";cerr<<endl;\n//\tfor(int i=1;i<=n;i+=2)cerr<<dp1[i]<<\" \";cerr<<endl;\n\t\n\tfor(int i=2;i<=n;i+=2)\n\t{\n\t\tans=max(ans,min(dp0[i-1]-cost(i,n),dp1[i+1]-cost(1,i)));\n\t}\n\tout(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing i64 = long long;\n\nconst int N = 300000 + 7;\n\nint n;\ni64 a[N], b[N], s[2];\ni64 l, r, m, p;\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", a + i),\n\t\tb[i] = b[i - 1] + (i & 1 ? 1 : -1) * a[i],\n\t\ts[i & 1] += a[i];\n\tif (n % 2 == 0) return printf(\"%lld %lld\", std::max(s[0], s[1]), std::min(s[0], s[1])), 0;\n\n\tr = s[0] + s[1];\n\twhile (l < r) {\n\t\tm = l + r + 1 >> 1, p = 0;\n\t\tfor (int i = 1; i < n; i += 2)\n\t\t\tif (b[i] + p >= m) p = std::max(p, a[i + 1] - b[i]);\n\t\tb[n] + p >= m ? (l = m) : (r = m - 1);\n\t}\n\tm = std::max(s[0] + l, s[1]);\n\treturn printf(\"%lld %lld\", m, s[0] + s[1] - m), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 300005\n#define inf 0x3f3f3f3f\nvoid Read(int &p)\n{\n\tp = 0;\n\tchar c = getchar();\n\tfor (; c < '0' || c > '9'; c = getchar());\n\tfor (; c >= '0' && c <= '9'; c = getchar())p = p * 10 + c - '0';\n}\nint n, A[N], S[N], s1, s2;\nint main()\n{\n\tRead(n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tRead(A[i]);\n\t\tif (i & 1)\n\t\t\ts1 += A[i], S[i] = S[i - 1] + A[i];\n\t\telse\n\t\t\ts2 += A[i], S[i] = S[i - 1] - A[i];\n\t}\n\tif (n & 1)\n\t{\n\t\tint l = 1, r = inf;\n\t\twhile (l < r)\n\t\t{\n\t\t\tint mid = (l + r + 1) >> 1;\n\t\t\tint now = 0;\n\t\t\tfor (int i = 1; i < n; i += 2)\n\t\t\t\tif (S[i] - now >= mid)\n\t\t\t\t\tnow = min(now, S[i + 1]);\n\t\t\tif (S[n] - now >= mid)\n\t\t\t\tl = mid;\n\t\t\telse\n\t\t\t\tr = mid - 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", s2 + l, s1 - l);\n\t}\n\telse\n\t{\n\t\tprintf(\"%d %d\\n\", max(s1, s2), min(s1, s2));\n\t\treturn 0;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nconst int nax=1000*1007;\n\nint n;\nll tab[nax];\n\nll s;\n\nll pre[nax];\nll suf[nax];\n\nll dp[nax];\n\nvoid wypisz(ll v)\n{\n\tdebug() << imie(v);\n\tprintf(\"%lld %lld\\n\", (s+v)/2, (s-v)/2);\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%lld\", &tab[i]);\n\t\ts+=tab[i];\n\t}\n\tll x=0;\n\tfor (int i=2; i<=n; i+=2)\n\t\tx+=tab[i];\n\tif (!(n&1))\n\t\twypisz(max(x, s-x)-min(x, s-x));\n\t//~ ll wyn=max(x, s-x)-min(x, s-x);\n\tfor (int i=1; i<=n; i++)\n\t\tpre[i]=tab[i]-pre[i-1];\n\t//~ for (int i=n; i; i--)\n\t\t//~ suf[i]=tab[i]-suf[i+1];\n\t//~ for (int i=2; i<=n; i+=2)\n\t\t//~ wyn=max(wyn, min(pre[i]+abs(suf[i+1]), abs(pre[i-1])+suf[i]));\n\t//~ wypisz(wyn);\n\tll wyn=x-(s-x);\n\t\n\tll bsa=-1e9;\n\tll bsb=1e9;\n\tll bss;\n\twhile(bsa<bsb)\n\t{\n\t\tbss=(bsa+bsb+2)>>1;\n\t\t\n\t\tll naj=0;\n\t\tfor (int i=1; i<=n; i+=2)\n\t\t{\n\t\t\tif (pre[i]-bss>=naj)\n\t\t\t{\n\t\t\t\tdp[i]=1;\n\t\t\t\tnaj=min(naj, -pre[i+1]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i]=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif (dp[n])\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tdebug() << imie(bsa);\n\t\n\twyn+=2*bsa;\n\t\n\twypisz(wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 3e5 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 1e9 + 7 ;\nconst double eps = 1e-7 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n;\n\nll a[maxn], sum[2], ans;\n\nbool check(ll lim)\n{\n\tll sum = 0, pre = 0, val;\n\trep(i, 1, n)\n\t{\n\t\tpre += val = a[i] * ((i & 1) ? -1 : 1);\n\t\tif(pre - val - sum <= lim) sum = max(sum, pre);\n\t}\n\tif(pre - sum <= lim) return 1;\n\treturn 0;\n}\n\nsigned main()\n{\n\tscanf(\"%lld\", &n);\n\trep(i, 1, n) scanf(\"%lld\", &a[i]), sum[i & 1] += a[i];\n\tif(!(n & 1))\n\t{\n\t\tprintf(\"%lld %lld\\n\", max(sum[0], sum[1]), min(sum[0], sum[1]));\n\t\treturn 0;\n\t}\n\tll l = -1e9, r = 1e9;\n\twhile(l <= r)\n\t{\n\t\tll mid = (l + r) >> 1;\n\t\tif(check(mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tans = sum[0] - ans;\n\tprintf(\"%lld %lld\\n\", ans, sum[0] + sum[1] - ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\n\nint n,a[N],B,W,sum[N];\n\n//inline bool check(int mid)\n//{\n//\tfor(int i=2;i<n;i+=2) if(sum[i-1]>=mid&&sum[n]-sum[i]>=mid) return 1;\n//\treturn 0;\n//}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i&1) B+=a[i];\n\t\telse W+=a[i];\n\t}\n\t\n//\tfor(int i=2;i<n;i+=2) printf(\"%d \",min(sum[i-1],sum[n]-sum[i]));puts(\"\");\n\tif(n&1)\n\t{\n\t\tint l=0;\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tif(i&1) sum[i]=sum[i-1]+a[i];\n\t\t\telse sum[i]=sum[i-1]-a[i];\n\t\t}\n\t\tfor(int i=2;i<n;i+=2) l=max(l,min(sum[i-1],sum[n]-sum[i]));\n//\t\tint l=0,r=B+W;\n//\t\twhile(l<r)\n//\t\t{\n//\t\t\tint mid=l+r>>1;\n//\t\t\tif(check(mid)) l=mid+1;\n//\t\t\telse r=mid;\n//\t\t}\n\t\tif(B>=W+l) printf(\"%d %d\",B,W);\n\t\telse printf(\"%d %d\",W+l,B-l);\n\t}\n\telse printf(\"%d %d\",max(W,B),min(W,B));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cassert>\n#include<cmath>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<vector>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\n#define REP(i,x,y) for(int i=x;i<=y;i++)\n#define rep(i,n) REP(i,1,n)\n#define rep0(i,n) REP(i,0,n-1)\n#define repG(i,x) for(int i=pos[x];~i;i=e[i].next)\n#define ll long long\n#define db double\nconst int N=3e5+7;\nconst int INF=1e9+7;\nint n;\nint a[N],s[N];\nbool check(int x){\n\tint mn=0;\n\tfor(int i=2;i<n;i+=2){\n\t\tif(s[i-1]-mn>=x)mn=min(mn,s[i]);\n\t}\n\treturn s[n]-mn>=x;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tint s1=0,s2=0;\n\t\trep(i,n)if(i&1)s1+=a[i];else s2+=a[i];\n\t\tprintf(\"%d %d\\n\",max(s1,s2),min(s1,s2));\n\t}\n\telse{\n\t\tint l=0,r=0,ans,s1=0,s2=0;\n\t\trep(i,n)r+=a[i];\n\t\trep(i,n)if(i&1)s1+=a[i];else s2+=a[i];\n\t\trep(i,n)s[i]=s[i-1]+((i&1)?a[i]:-a[i]);\n\t\twhile(l<r-1){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(check(mid))l=mid;\n\t\t\telse r=mid;\n\t\t}\n\t\tif(check(r))ans=r;\n\t\telse ans=l;\n\t\tprintf(\"%d %d\\n\",s2+ans,s1-ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5+5;\nint n,a[N],s[N];\n\ninline bool check(int x){\n\tint v=0;\n\tfor(int i=1;i<n;i+=2){\n\t\tif(s[i]-v>=x){\n\t\t\tv=min(v,s[i+1]);\n\t\t}\n\t}\n\treturn s[n]-v>=x;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tif(!n%2){\n\t\tint s0=0,s1=0;\n\t\tfor(int i=1;i<=n;i++)if(i&1)s0+=a[i];else s[1]+=a[i];\n\t\tcout << max(s0,s1) << \" \" << min(s0,s1) << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(i&1)s[i]=s[i-1]+a[i];\n\t\telse s[i]=s[i-1]-a[i];\n\t}\n\tint l=1, r=n*1000, ans=l;\n\twhile(l<=r){\n\t\tint mid = (l+r)>>1;\n\t\tif(check(mid))l=mid+1,ans=mid;\n\t\telse r=mid-1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(i%2==0)\n\t\t\tans+=a[i];\n\t}\n\tint s=0;\n\tfor(int i=1;i<=n;i++)s+=a[i];\n\tcout << ans << \" \" << s - ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 300003\nint a[N],i,l,m,n,r,s,x;\ninline void solve(){for(s=0,i=2;i<n;i+=2)if(m<=a[i-1]-s)s=s<a[i]?s:a[i];}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)scanf(\"%d\",a+i);\n    for(i=2;i<=n;i+=2)x+=a[i],a[i]=-a[i];\n    for(i=1;i<=n;i++)a[i]+=a[i-1];\n    if(~n&1)return 0*printf(\"%d %d\\n\",a[n]>0?x+a[n]:x,a[n]>0?x:x+a[n]);\n    for(l=0,r=x+a[n]+x;l<r;)m=l+r+2>>1,solve(),m<=a[n]-s?l=m:r=m-1;\n    return 0*printf(\"%d %d\\n\",x+l,x+a[n]-l);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+7;\nint n,w[N],f[N],q[N];\ninline int read(){\n    int num=0; char g=getchar(); while(g<48||57<g) g=getchar();\n    while(47<g&&g<58) num=(num<<1)+(num<<3)+g-48,g=getchar(); return num;\n}\ninline bool check(int u){\n\tint sx=0;\n\tfor(int i=2;i<=n+1;i+=2){\n\t\tif(sx+f[i]-q[i-1]>=u){\n\t\t\tsx=max(sx,q[i+1]-f[i]);\n\t\t\tif(i==n+1) return true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;i++) w[i]=read();\n\tif(n%2==0){\n\t\tint a=0,b=0;\n\t\tfor(int i=1;i<=n;i++) if(i&1) a+=w[i]; else b+=w[i];\n\t\tcout<<max(a,b)<<' '<<min(a,b)<<endl;\n\t}\n\telse{\n\t\tint sum=0;\n\t\tfor(int i=1;i<=n+1;i++){\n\t\t\tsum+=w[i]; f[i]+=f[i-1],q[i]+=q[i-1];\n\t\t\tif(i&1) f[i]+=w[i]; else q[i]+=w[i];\n\t\t}\n\t\tint l=0,r=sum,c=0;\n\t\twhile(l<=r){\n\t\t\tint d=(l+r)>>1; if(check(d)) c=d,l=d+1; else r=d-1;\n\t\t}\n\t\tcout<<c+q[n+1]<<' '<<sum-c-q[n+1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline LL read(){\n\tLL x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst LL MAXN = 500010;\nconst LL INF = 2147483600;\n\nLL N; LL a[MAXN+1];\nLL s[2];\n\ninline bool check(LL T){\n\tLL mxp=0; bool fg=0;\n\tfor(LL i=1;i<=N;i++){\n\t\tif((i&1)&&fg) mxp=max(mxp,0LL),fg=0;\n\t\tmxp+=((i&1)?1:-1)*a[i];\n\t\tif((i&1)&&mxp>=T) fg=1;\n\t} return fg;\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tfor(LL i=1;i<=N;i++) a[i]=read(),s[i&1]+=a[i];\n\tif(!(N&1)){ printf(\"%lld %lld\\n\",max(s[0],s[1]),min(s[0],s[1])); return 0; }\n\tLL ad=0,l=1,r=s[0]+s[1];\n\twhile(l<=r){\n\t\tLL mid=(l+r)>>1LL;\n\t\tif(check(mid)) ad=mid,l=mid+1;\n\t\telse r=mid-1;\n\t} printf(\"%lld %lld\\n\",ad+s[0],s[1]-ad);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 100010\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint a[N],b[N],n;\ninline int check(int k)\n{\tmemcpy(b,a,sizeof(a));\n\tfor(rint i=1;i<=n;i+=2)\n\tif(i==n) return (b[i]>=k);\n\telse if(!(b[i]>=k&&b[i+1]>=b[i])) b[i+2]+=b[i]-b[i+1];\n}\nint main()\n{\tint s0=0,s1=0; cin>>n;\n\tfor(rint i=1;i<=n;i++) scanf(\"%d\",&a[i]),(i&1)?s0+=a[i]:s1+=a[i];\n\tif(n%2==0){cout<<max(s0,s1)<<\" \"<<min(s0,s1)<<endl;return 0;}\n\tint l=0,r=3e8,ans=-1;\n\twhile(l<=r)\n\t{\tint mid=(l+r)>>1;\n\t\tif(check(mid)) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tcout<<ans+s1<<\" \"<<s0-ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int N=3e5+10;\nint a[N],n,ans,ans2;\nbool check(int lim){\n\tint now=0;\n\tfor (int i=2;i<=n;i+=2){\n\t\tnow+=a[i-1]-a[i-2];\n\t\tif (now>=lim)now=max(now,a[i]);\n\t}\n\treturn now+a[n]-a[n-1]>=lim;\n}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]),ans2+=a[i];\n\tif (~n&1){\n\t\tint sum1=0,sum2=0;\n\t\tfor (int i=1;i<=n;i++)sum1+=a[i]*(i&1),sum2+=a[i]*(~i&1);\n\t\tcout<<max(sum1,sum2)<<' '<<min(sum1,sum2)<<endl;\n\t\treturn 0;\n\t}\n\tfor (int u=1<<30;u;u>>=1)\n\t\tif (check(ans+u))ans+=u;\n\tfor (int i=2;i<=n;i+=2)ans+=a[i];\n\tcout<<ans<<' '<<ans2-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nint n,a[301000],S1,S2;\nbool check(int lim){\n\tint now=0,lst=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i&1){\n\t\t\tif(now>=lim&&now+lst+a[i]<=0) now=lst=0;\n\t\t\tnow+=lst+a[i];\n\t\t}\n\t\telse lst=-a[i];\n\t}\n\treturn now>=lim;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++){\n\t\tread(a[i]);\n\t\tif(i&1) S1+=a[i];\n\t\telse S2+=a[i];\n\t}\n\tif(~n&1){cout<<max(S1,S2)<<' '<<min(S1,S2)<<'\\n';return 0;}\n\tint l=0,r=S1+1;\n\twhile(l+1<r){\n\t\tint mid=l+r>>1;\n\t\tif(check(mid)) l=mid;\n\t\telse r=mid;\n\t}\n\tcout<<S2+l<<' '<<S1-l<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc()) \n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 300010;\nint n, a[N], sum[2], ans, cur[2];\nint main() {\n  read(n);\n  rep (i, 1, n) read(a[i]);\n  rep (i, 1, n) sum[i&1] += a[i];\n  if (n % 2 == 0) {\n    printf(\"%d %d\\n\", max(sum[0], sum[1]), min(sum[0], sum[1]));\n    return 0;\n  } else {\n    ans = sum[1];\n    rep (i, 1, n) {\n      if (i % 2 == 0)\n\tans = max(ans, min(cur[0] + a[i] + sum[1] - cur[1], sum[0] - cur[0] + cur[1]));\n      cur[i&1] += a[i];\n    }\n    printf(\"%d %d\\n\", ans, sum[0] + sum[1] - ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long LL;\nconst int N = 3e5+10;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n;\nint a[N] , s[N];\n\ninline bool check(int mid)\n{\n\tint k = 0;\n\tfor(int i = 1 ; i < n ; i += 2) if(s[i] - k >= mid) k = min(k , s[i+1]);\n\treturn s[n] - k >= mid;\n}\n\nint main()\n{\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++i) a[i] = read();\n\tif(n % 2 == 0)\n\t{\n\t\tint sum1 = 0 , sum2 = 0;\n\t\tfor(int i = 1 ; i <= n ; ++i) if(i & 1) sum1 += a[i]; else sum2 += a[i];\n\t\tcout << max(sum1 , sum2) << ' ' << min(sum1 , sum2) << '\\n';\n\t\treturn 0;\n\t} \n\tfor(int i = 1 ; i <= n ; ++i) s[i] = s[i-1] + ((i&1) ? 1 : -1) * a[i];\n\tint l = 0 , r = n * 1000 , mid , ans;\n\twhile(l <= r)\n\t{\n\t\tmid = (l + r) >> 1;\n\t\tif(check(mid)) l = mid + 1 , ans = mid; else r = mid - 1;\n\t}\n\tint sum = 0;\n\tfor(int i = 1 ; i <= n ; ++i) sum += a[i];\n\tfor(int i = 1 ; i <= n ; ++i) if(i % 2 == 0) ans += a[i];\n\tcout << ans << ' ' << sum - ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int maxn=(3e5)+10;\nint n,d[maxn],s[maxn],S;\nbool solve(int mid) {\n\tint mn=0;\n\tfor (int i=1;i<=n;i+=2) {\n\t\tif (mn<=s[i]-mid) {\n\t\t\tif (i==n) return 1;\n\t\t\tmn=min(mn,s[i+1]);\n\t\t}\n\t}\n\treturn 0;\n}\nvoid solve1() {\n\tint a=0;\n\tfor (int i=1;i<=n;i++) {\n\t\ts[i]=s[i-1];\n\t\tif (i&1) s[i]+=d[i];\n\t\telse s[i]-=d[i],a+=d[i];\n\t\tS+=d[i];\n\t\t//printf(\"%d \",s[i]);\n\t}\n//\tprintf(\"\\n\");\n\tint l=0,r=S,res,mid;\n\twhile (l<=r) {\n\t\tmid=(l+r)/2;\n\t\tif (solve(mid)) res=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tres+=a;\n\tprintf(\"%d %d\\n\",res,S-res);\n}\nvoid solve2() {\n\tint a=0,b=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (i&1) a+=d[i];\n\t\telse b+=d[i];\n\tprintf(\"%d %d\\n\",max(a,b),min(a,b));\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n);\n\tfor (int i=1;i<=n;i++) read(d[i]);\n\tif (n&1) solve1();\n\telse solve2();\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\n\n#define M 1000005\nint n;\nint a[M];\n\ninline bool check(int x) {\n\tint sum=0;\n\tfor(int i=1;i<=n;i+=2) {\n\t\tif(sum>=x) sum=max(sum+a[i]-a[i-1],a[i]);\n\t\telse sum+=a[i]-a[i-1];\n\t}\n\treturn sum>=x;\n}\n\nint main () {\n\t//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) scanf(\"%d\",a+i);\n\tint sum[2]={0};\n\tfor1(1,n,i) sum[i&1]+=a[i];\n\tif(!(n&1)) printf(\"%d %d\\n\",max(sum[0],sum[1]),min(sum[0],sum[1]));\n\telse {\n\t\tint l=0,r=sum[1],mid,ans;\n\t\twhile (l<=r) {\n\t\t\tmid=l+r>>1;\n\t\t\tif(check(mid)) ans=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",sum[0]+ans,sum[1]-ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x <<\": \" << (x) << endl\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#ifdef LOCAL\n#define see(x) cout  << #x << \": \" << (x) << endl\n#endif\n#ifndef LOCAL\n#define see(x)\n#endif\n\n\n#define rep(n) for(int _ = 0; _ != (n); ++_)\n//#define rep(i, a, b) for(int i = (a); i <= (b); ++i)\n#define Rng(i, n) for(int i = 0; i != (n); ++i)\n#define rng(i, a, b) for(int i = (a); i < (b); ++i)\n#define rno(i, b) for(int i = 0; i<(b); ++i)\n#define rnc(i, a, b) for(int i = (a); i<=(b); ++i)\n#define RNG(i, a) for(auto &i: (a))\n#define dwn(i, r, l) for(int i = (r); i>=(l); i--)\n\nnamespace std {\n    template<class T>\n    T begin(std::pair<T, T> p)\n    {\n        return p.first;\n    }\n    template<class T>\n    T end(std::pair<T, T> p)\n    {\n        return p.second;\n    }\n}\n\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate<class Range>\nstd::pair<std::reverse_iterator<decltype(begin(std::declval<Range>()))>, std::reverse_iterator<decltype(begin(std::declval<Range>()))>> make_reverse_range(Range &&r)\n{\n    return std::make_pair(make_reverse_iterator(::begin(r)), make_reverse_iterator(::end(r)));\n}\n\n#define RRNG(x, cont) for (auto &x: make_reverse_range(cont))\n\n\n\ntemplate<class T> int sign(const T &a) { return a == 0 ? 0 : a > 0 ? 1 : -1; }\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> void Min(T &a, const T &b){ a = min(a, b); }\ntemplate<class T> void Max(T &a, const T &b){ a = max(a, b); }\n\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\nusing pii = pair<int, int>;\nusing pdd = pair<double, double>;\nusing pip = pair<int, pii>;\nusing szt = size_t;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing pli = pair<ll,int>;\nusing wg = vector<vpii>; //weighted graph\n\nint cas;\nconst double pi = acos(-1);\nll mod = 1e9 + 7;\n\ntemplate<class T>\ninline void add_mod(T &a, const T &b) {\n    a += b;\n    if (a >= mod) a -= mod;\n}\ntemplate<class T>\nvoid sub_mod(T &a, const T &b){\n    a -= b;\n    if (a < 0) a += mod;\n}\nauto bo=[](int x){\n    bitset<5> a(x);\n    cout << a << endl;\n};\n\n//返回值：a中比k小的元素有多少个？\ntemplate<class V, class Cont>\nint get_rank(const V &k, const Cont &a){\n    return std::lower_bound(all(a), k) - a.begin();\n}\n\nmat operator*(const mat &a, const mat &b) {\n    mat c(a.size(), vec(b[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            if (a[i][j]) { // optimization for sparse matrix\n                for (int k = 0; k < b[0].size(); k++) {\n                    add_mod(c[i][k], a[i][j] * b[j][k] % mod);\n                }\n            }\n        }\n    }\n    return c;\n}\n\nvec operator*(const mat &a, const vec &b) {\n    vec c(a.size());\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            add_mod(c[i], a[i][j] * b[j] % mod);\n        }\n    }\n    return c;\n}\n\nmat pow(mat a, ull n) {\n    mat res(a.size(), vec(a[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        res[i][i] = 1;\n    }\n    while (n) {\n        if (n & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\n// Codeforces does not support __int128\n//std::ostream& operator<<(std::ostream& os, __int128 T) {\n//    if (T<0) os<<\"-\";\n//    if (T>=10 ) os<<T/10;\n//    if (T<=-10) os<<(-(T/10));\n//    return os<<( (int) (T%10) >0 ? (int) (T%10) : -(int) (T%10) ) ;\n//}\n//\n//__int128 LPOW(__int128 x, ll n) {\n//    __int128 res = 1;\n//    for (; n; n /= 2, x *= x, x %= mod) {\n//        if (n & 1) {\n//            res *= x;\n//            res %= mod;\n//        }\n//    }\n//    return res;\n//}\n\nll POW(ll x, ll n){\n    ll res = 1;\n    for (; n; n /= 2, x *= x, x %= mod) {\n        if (n & 1) {\n            res *= x;\n            res %= mod;\n        }\n    }\n    return res;\n}\n\n\nll INV(ll x) {\n    return POW(x, mod - 2);\n}\n\nll inv(ll x){\n//    see(x);\n    return x == 1? 1: (mod - mod/x * inv(mod%x) % mod);\n}\n\n\n\n// 2D rotation\nvoid rotate(double &x, double &y, double theta) {\n    double tx = cos(theta) * x - sin(theta) * y;\n    double ty = sin(theta) * x + cos(theta) * y;\n    x = tx, y = ty;\n}\nstruct bit {\n    static const int BIT_N = 1e5 + 5;\n    ll bit[BIT_N];\n    void init(int n){\n        rng(i, 1, n+1) bit[i] = 0;\n    }\n\n    ll sum(int x) {\n        ll res = 0;\n        while (x) {\n            res += bit[x];\n            x -= x & -x;\n        }\n        return res;\n    }\n\n    ll sum(int l, int r) {\n        if (l > r) return 0;\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int x, ll v, int n) {\n        while (x <= n) {\n            bit[x] += v;\n            x += x & -x;\n        }\n    }\n};\n\n\nnamespace util{\n    int len(ll x){return snprintf(nullptr, 0, \"%lld\", x);}\n    vi get_d(ll x){\n        vi res;\n        while(x) {\n            res.pb(x%10);\n            x /= 10;\n        }\n        reverse(all(res));\n        return res;\n    }\n    template <class T> T parity(const T &a){\n        return a & 1;\n    }\n    template <class T>\n    void out (const vector<T> &a){\n        std::copy(a.begin(), a.end(), std::ostream_iterator<T>(std::cout, \", \"));\n        cout << endl;\n    };\n}\n\nusing namespace util;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n\nusing order_statistic_tree = __gnu_pbds::tree<\n        int,\n        __gnu_pbds::null_type,\n        greater<int>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n\n\nconst ll LINF = LLONG_MAX/10;\nconst int INF = INT_MAX/10;\nconst int M = 5005;\n\n\nll dp[M];\n\nint c[M], f[M];\n\nint nn[M], v[M], p[M];\n\nint main() {\n    // Single Cut of Failure taught me\n    cout << std::fixed;\n    cout << setprecision(10);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n\n#ifdef LOCAL\n    freopen(\"main.in\", \"r\", stdin);\n//    freopen(\"main.out\", \"w\", stdout);\n#endif\n\n    int n; scan(n);\n    vi a(n);\n    RNG(x, a) scan(x);\n    int sb = 0;\n    for(int i = 0; i<n; i+=2)\n        sb += a[i];\n    int sw = 0;\n    for(int i=1; i<n; i+=2)\n        sw += a[i];\n    if(n % 2 == 0){\n        println(max(sb, sw), min(sb, sw));\n        return 0;\n    }\n\n\n    auto check = [n, sb, sw, &a](int x) {\n        int mi = 0;\n        int sum = 0;\n        rng(i, 0, n) {\n            if (i & 1) {\n                if (sum - mi >= x) {\n                    if (sb - sw - (sum - a[i]) >= x)\n                        return true;\n                    sum -= a[i];\n                    Min(mi, sum);\n                }\n                else sum -= a[i];\n            }\n            else sum += a[i];\n        }\n        return false;\n    };\n\n    int l = sb - sw + 1, r = sb;\n    while(l<=r){\n        int mid = l + (r-l)/2;\n        if(check(mid)){\n            l = mid + 1;\n        }\n        else r = mid - 1;\n    }\n\n    assert(sw + r >= sb);\n    println(sw + r, sb - r);\n\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nstruct Node {\n\tNode *lch, *rch;\n\tint l, r;\n\tP cl, cr;\n\tNode(int l, int r) :l(l), r(r), cl({l,mod }),lch(NULL),rch(NULL) {};\n};\n\nvoid add(Node* nd, int x,int y) {\n\tint l = nd->l,  r = nd->r;\n\tif (r - l == 1) {\n\t\tif (nd->cl.second == mod) {\n\t\t\tnd->cl = { x,y };\n\t\t\tnd->cr = { x,y };\n\t\t}\n\t\telse {\n\t\t\tif (nd->cl.second < y) {\n\t\t\t\tnd->cl = { x,y };\n\t\t\t\tnd->cr = { x,y };\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tif (x < m) {\n\t\tif (nd->lch == NULL) {\n\t\t\tnd->lch = new Node(l, m);\n\t\t}\n\t\tadd(nd->lch, x, y);\n\t}\n\telse {\n\t\tif (nd->rch == NULL) {\n\t\t\tnd->rch = new Node(m, r);\n\t\t}\n\t\tadd(nd->rch, x, y);\n\t}\n\tif (nd->lch == NULL) {\n\t\tnd->cl = nd->rch->cl;\n\t\tnd->cr = nd->rch->cr;\n\t}\n\telse if (nd->rch == NULL) {\n\t\tnd->cl = nd->lch->cl;\n\t\tnd->cr = nd->lch->cr;\n\t}\n\telse {\n\t\tvector<P> vs;\n\t\tvector<P> v = { nd->lch->cl,nd->lch->cr,nd->rch->cl,nd->rch->cr };\n\t\trep(i, 4) {\n\t\t\twhile (vs.size() && vs.back().second <= v[i].second)vs.pop_back();\n\t\t\tvs.push_back(v[i]);\n\t\t}\n\t\tnd->cl = vs[0];\n\t\tnd->cr = vs.back();\n\t}\n}\nint query(Node *nd,int ad) {\n\tif (nd->r - nd->l == 1) {\n\t\treturn min(nd->l, nd->cl.second + ad);\n\t}\n\n\tif (nd->lch == NULL)return query(nd->rch, ad);\n\telse if (nd->rch == NULL)return query(nd->lch, ad);\n\telse {\n\t\tif (nd->lch->cr.first <= nd->lch->cr.second + ad) {\n\t\t\treturn max(nd->lch->cr.first, query(nd->rch, ad));\n\t\t}\n\t\telse {\n\t\t\treturn query(nd->lch, ad);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> a(n);\n\tint sum = 0;\n\trep(i, n) {\n\t\tcin >> a[i]; sum += a[i];\n\t}\n\tif (n % 2 == 0) {\n\t\tint s1 = 0, s2 = 0;\n\t\tfor (int i = 0; i < n; i += 2) {\n\t\t\ts1 += a[i];\n\t\t}\n\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\ts2 += a[i];\n\t\t}\n\t\tint ans1 = max(s1, s2);\n\t\tcout << ans1 << \" \" << sum - ans1 << \"\\n\";\n\t\treturn;\n\t}\n\n\tint ad = 0;\n\tNode *nd = new Node(0, mod + 1);\n\tadd(nd, mod, 0);\n\n\tvector<int> memo(n + 2);\n\tmemo[0] = mod;\n\n\tint ex = 0;\n\tfor (int i = 1; i < n; i += 2)ex += a[i];\n\n\tfor (int i = 2; i <= n + 1; i += 2) {\n\t\tif (i >= 4) {\n\t\t\tad += a[i - 2]-a[i-3];\n\t\t}\n\t\tmemo[i] = min(memo[i - 2], ex + a[i-2]);\n\t\tmemo[i] = max(memo[i], query(nd, ad));\n\t\tadd(nd, memo[i - 2], ex + a[i - 2] - ad);\n\t}\n\n\tint ans = memo[n + 1];\n\tcout << ans << \" \"<<sum-ans<<\"\\n\";\n\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <string>\n#include <cmath>\n#define SIZE 300005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll A[SIZE];\nll left[SIZE],right[SIZE];\nint n;\n\nbool check(ll X)\n{\n\tright[n]=0;\n\tfor(int i=0;i<n;i+=2) right[n]+=A[i];\n\tfor(int i=n-2;i>=1;i-=2)\n\t{\n\t\tright[i]=right[i+2];\n\t\tright[i]-=A[i+1];\n\t\tright[i]+=A[i];\n\t}\n\tleft[1]=A[0]-A[1];\n\tfor(int i=3;i<n;i+=2)\n\t{\n\t\tleft[i]=left[i-2];\n\t\tleft[i]+=A[i-1];\n\t\tleft[i]-=A[i];\n\t}\n\tll mn=0;\n\tfor(int i=1;i<n;i+=2)\n\t{\n\t\tif(mn+X<=right[i])\n\t\t{\n\t\t\tmn=min(mn,left[i]);\n\t\t}\n\t}\n\treturn mn+X<=right[n];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%lld\",&A[i]);\n\tll all=0;\n\tfor(int i=0;i<n;i++) all+=A[i];\n\tif(n%2==0)\n\t{\n\t\tll s1=0,s2=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i%2==0) s1+=A[i];\n\t\t\telse s2+=A[i];\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",max(s1,s2),all-max(s1,s2));\n\t}\n\telse\n\t{\n\t\tll low=0,up=all+1;\n\t\twhile(up-low>1)\n\t\t{\n\t\t\tll d=(low+up)/2;\n\t\t\tif(check(d)) low=d;\n\t\t\telse up=d;\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",low,all-low);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint maxx(vector<int> a, int flag[], int idx){\n\tint n = a.size();\n\tint maxm=-1;\n\tfor(int i = idx+1; i<n; i++){\n\t\tif(! flag[i]){\n\t\t\tif(maxm == -1){ maxm = i; continue;}\n\t\t\tif(a[maxm] < a[i]) maxm = i;\n\t\t}\n\t}\n\t\n\tfor(int i = idx-1; i>=0; i--){\n\t\tif(! flag[i]){\n\t\t\tif(maxm == -1){ maxm = i; continue;}\n\t\t\tif(a[maxm] < a[i]) maxm = i;\n\t\t}\n\t}\t\n\t\n\tflag[maxm]=1;\n\treturn maxm;\n\t\n}\nint main(void){\n\t\n\tint n; cin>>n; \n\tvector<int> a(n);\n\tfor(int i=0; i<n; i++) cin>>a[i]; //5 20 100 10 1 10\n\t\n\tint p[2] = {0,0};\n\tint flag[n]; for(int i=0; i<n; i++)flag[i]=0;\n\t\n\tint maxm = maxx(a, flag, 0);\n\tp[0] += a[maxm];\n\t\t\n\tint i=1;\n\twhile(i < n){\n\t\tint t = i%2;\n//\tcout<<\"aaaaaaaaa---\"<<flag[1]<<\" \"<<flag[3]<<endl;\n\t\tif(maxm == 0 && !flag[maxm+1]){ flag[maxm+1]=1; p[t]+=a[maxm+1]; maxm++;}\n\t\telse if(maxm==n-1 && !flag[maxm-1]){flag[maxm-1]=1;p[t]+=a[maxm-1];maxm--;}\n\t\t\n\t\telse if(maxm-1 >=0 && maxm+1 < n && (!flag[maxm-1] || !flag[maxm+1])){\n\t\t\t\t\t\t\n\t\t\t\n\t\t\tif(flag[maxm-1]){ p[t] += a[maxm+1]; flag[maxm+1]++; maxm++; }\n\t\t\telse if(flag[maxm+1]){ p[t] += a[maxm-1]; flag[maxm-1]++; maxm--;}\n\t\t\telse {\n\t\t\t\tif(a[maxm-1] > a[maxm+1]){p[t] += a[maxm-1];flag[maxm-1]++;maxm--;}\n\t\t\t\telse {p[t] += a[maxm+1]; flag[maxm+1]++; maxm++;}\n\t\t\t}\n\t\t}\n\t\telse if( ((maxm == 0 && flag[1]) || (maxm==n-1 && flag[n-2])) || \\\n\t\t\t((maxm != 0 && flag[maxm-1]) && (maxm != n-2 && flag[maxm+1])) ){\n\t\t\tmaxm = maxx(a, flag, maxm);\n\t\t\tp[t] += a[maxm];\n\t\t}\n\t\t\n\t//cout<<p[0]<<\"\\t\\t\"<<p[1]<<\"--\"<<maxm<<endl ; fflush(stdout);\n\t\ti++;\n\t}\n\t\n\tcout<<p[0]<<\" \"<<p[1]; \n\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[300005],s[300005];\nbool check(int x){\n\tint Mn=0;\n\tfor(int i=1;i<=n;i++)if(!(i&1))\n\t\tif(2*(s[i-1]-s[Mn])>=x&&s[i]<s[Mn])Mn=i;\n\treturn 2*(s[n]-s[Mn])>=x;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint S=0;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),S+=a[i];\n\tfor(int i=1;i<=n;i++)s[i]=s[i-1]+(i&1?a[i]:-a[i]);\n\tif(!(n&1)){\n\t\tprintf(\"%d %d\\n\",(S+abs(s[n]))/2,(S-abs(s[n]))/2);\n\t\treturn 0;\n\t}\n\tint l=1,r=2e9;\n\tint d=-s[n];\n\twhile(l<r){\n\t\tint mid=r-((r-l)>>1);\n\t\tif(check(mid))l=mid;\n\t\telse r=mid-1;\n\t}\n\tprintf(\"%d %d\\n\",(S+(d+l))/2,(S-(d+l))/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int MAX_N = 3e5 + 5;\n\ntypedef long long ll;\n\nint arr [MAX_N];\nll altpref [MAX_N];\n\nbool can (ll K, int n) {\n  ll req = K;\n  for (int i = 1; i <= n; i += 2) {\n    if (altpref[i] >= req) {\n      if (i == n) return true;\n      req = min(req, altpref[i + 1] + K);\n    }\n  }\n  return false;\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> arr[i];\n    sum += arr[i];\n  }\n\n  if (n % 2 == 0) {\n    // easy case\n    int anse = 0, anso = 0;\n    for (int i = 1; i <= n; i++) {\n      if (i % 2 == 0) {\n        anse += arr[i];\n      } else {\n        anso += arr[i];\n      }\n    }\n\n    int ans = max(anse, anso);\n    cout << ans << \" \" << sum - ans << '\\n';\n  } else {\n    // hard case\n    int def = 0;\n    for (int i = 2; i <= n; i += 2) {\n      def += arr[i];\n    }\n\n    for (int i = 1; i <= n; i++) {\n      if (i % 2 == 1) {\n        altpref[i] = altpref[i - 1] + arr[i];\n      } else {\n        altpref[i] = altpref[i - 1] - arr[i];\n      }\n    }\n\n    int ans = 0;\n    for (int i = 1 << 29; i != 0; i /= 2) {\n      if (can(ans + i, n)) {\n        ans += i;\n      }\n    }\n\n    ans += def;\n    cout << ans << \" \" << sum - ans << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N + 4);\n\tfor (int i = 2; i <= N + 1; i++) {\n\t\tcin >> v[i];\n\t}\n\tvector<int>oddl(N + 4);\n\tvector<int>evenl(N + 4);\n\tfor (int i = 2; i <= N + 3; i++) {\n\t\toddl[i] = oddl[i - 1];\n\t\tif (i % 2)oddl[i] += v[i];\n\t}\n\tfor (int i = 2; i <= N + 3; i++) {\n\t\tevenl[i] = evenl[i - 1];\n\t\tif (i % 2 == 0) evenl[i] += v[i];\n\t}\n\tvector<int>oddr(N + 4);\n\tvector<int>evenr(N + 4);\n\tfor (int i = N + 1; i >= 0; i--) {\n\t\toddr[i] = oddr[i + 1];\n\t\tif (i % 2)oddr[i] += v[i];\n\t}\n\tfor (int i = N + 1; i >= 0; i--) {\n\t\tevenr[i] = evenr[i + 1];\n\t\tif (i % 2 == 0) evenr[i] += v[i];\n\t}\n\tint evenmin = 100000;\n\tfor (int i = 2; i <= N + 1; i++) {\n\t\tif (i % 2 == 0)\t\tevenmin = min(evenmin, v[i]);\n\t}\n\tint ans = max(evenl[N + 1], oddl[N + 1]);\n\tif (N % 2)ans = max(ans, oddl[N + 1] + evenmin);\n\tfor (int i = 2; i <= N + 1; i++) {\n\t\tif (i % 2) {\n\t\t\tif (N % 2) {\n\t\t\t\tans = max(ans, min(oddl[i] + max(evenr[i + 1], oddr[i + 1]), oddr[i] + max(evenl[i - 1], oddl[i - 1])));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = max(ans, min(oddl[i] + max(evenr[i + 1], oddr[i + 1]), oddr[i] + min(evenl[i + 1], oddl[i + 1])));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (N % 2) {\n\t\t\t\tans = max(ans, min(evenl[i] + min(oddr[i + 1], evenr[i + 1]), evenr[i] + min(oddl[i - 1], evenl[i - 1])));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = max(ans, min(evenl[i] + min(oddr[i + 1], evenr[i + 1]), evenr[i] + max(oddl[i + 1], evenl[i + 1])));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \" \" << accumulate(v.begin(), v.end(), 0) - ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define maxn 1005\nint f[maxn][maxn],s[maxn],sodd[maxn],seven[maxn],n;bool vis[maxn][maxn];\nint calcl(int r,int l){\n\tif (r&1)return /*cerr<<\"calc:\"<<l<<\" \"<<r<<\" \"<<sodd[r]-sodd[l-1]<<endl,*/sodd[r]-sodd[l-1];else return seven[r]-seven[l-1];\n}\nint calcr(int l,int r){\n\tif (l&1)return /*cerr<<\"calc:\"<<l<<\" \"<<r<<\" \"<<sodd[r]-sodd[l-1]<<endl,*/sodd[r]-sodd[l-1];else return seven[r]-seven[l-1];\n}\nint dfs(int l,int r){\n\tif (l>r)return 0;if (vis[l][r])return f[l][r];vis[l][r]=true;\n\trep(i,l,r){\n\t\tint ind=i;\n\t\tint resl=0,resr=0;\n\t\tresl=calcl(ind,l)+(((ind-l+1)&1)?(s[r]-s[ind]-dfs(ind+1,r)):dfs(ind+1,r));\n\t\tresr=calcr(ind,r)+(((r-ind+1)&1)?(s[ind-1]-s[l-1]-dfs(l,ind-1)):dfs(l,ind-1));\n\t\t// cerr<<l<<\" \"<<r<<\" \"<<ind<<\" \"<<resl<<\" \"<<resr<<endl;\n\t\tint res=0;if (l==ind)res=resr;else if (ind==r)res=resl;else res=min(resl,resr);\n\t\tf[l][r]=max(f[l][r],res);\n\t\t\n\t}\n\t// cerr<<l<<\" \"<<r<<\" \"<<f[l][r]<<endl;\n\treturn f[l][r];\n}\nint main(){\n\tscanf(\"%d\",&n);if (n>1000)return printf(\"%d %d\\n\",0,0),0;rep(i,1,n)scanf(\"%d\",&s[i]);\n\tfor (int i=1;i<=n;i+=2)sodd[i]=s[i];\n\tfor (int i=2;i<=n;i+=2)seven[i]=s[i];\n\trep(i,1,n)s[i]+=s[i-1],sodd[i]+=sodd[i-1],seven[i]+=seven[i-1];\n\tprintf(\"%d %d\\n\",dfs(1,n),s[n]-dfs(1,n));return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3e5 + 10;\n\nint a[N], n, sum[2];\n\nbool check(int x) {\n  int sum = 0;\n  for(int i = 1; i <= n; i += 2) {\n    if(sum >= x) { \n      sum = max(sum + a[i] - a[i - 1], a[i]);\n    } else {\n      sum += a[i] - a[i - 1];\n    }\n  }\n  return sum >= x;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    sum[i & 1] += a[i];\n  }\n  if(~n & 1) {\n    cout << max(sum[0], sum[1]) << \" \" << min(sum[0], sum[1]) << endl;\n  } else {\n    int ans = 0, l = 0, r = sum[1];\n    while(l <= r) {\n      int mid = l + r >> 1;\n      if(check(mid)) {\n\tans = mid;\n\tl = mid + 1;\n      } else {\n\tr = mid - 1;\n      }\n    }\n    cout << sum[0] + ans << \" \" << sum[1] - ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint a[333333];\nint S[333333];\nint sum;\n\nvoid out(int diff)\n{\n\tcout<<(sum+diff)/2<<' '<<(sum-diff)/2<<'\\n'; exit(0);\n}\n\nint getS(int l, int r)\n{\n\tif(l==0) return S[r];\n\telse return S[r]-S[l-1];\n}\n\nint dp[333333];\nset<ii> SS; \n\nvoid add(ii x)\n{\n\tauto it = SS.lower_bound(x);\n\tif(it!=SS.begin())\n\t{\n\t\tit--; \n\t\tif(it->se<=x.se) return ;\n\t\tit++;\n\t}\n\twhile(it!=SS.end()&&it->se>=x.se) \n\t{\n\t\tit=SS.erase(it);\n\t}\n\tSS.insert(x);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i]; sum+=a[i];\n\t\tif(i%2==0) a[i]*=-1;\n\t\tS[i]=a[i]+(i>0?S[i-1]:0);\n\t}\n\tif(n%2==0) out(abs(S[n-1]));\n\tdp[0] = min(0, a[0]);\n\tint shift = a[0]; add(mp(-int(1e9), 0));\n\tfor(int i=2;i<n;i+=2)\n\t{\n\t\tshift+=a[i-1]+a[i];\n\t\tadd(mp(dp[i-2], a[i]-shift));\n\t\tint lo = -int(1e9); int hi = int(1e9);\n\t\twhile(lo<=hi)\n\t\t{\n\t\t\tint mid=(lo+hi)>>1;\n\t\t\tauto it = SS.upper_bound(mp(mid+1,-int(1e9)));\n\t\t\tbool pos=1;\n\t\t\tif(it==SS.begin()) pos=0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tit--;\n\t\t\t\tif(it->se+shift>mid) pos=0;\n\t\t\t}\n\t\t\tif(pos)\n\t\t\t{\n\t\t\t\tdp[i]=mid; hi=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\n\t}\n\tout(S[n-1]-2*dp[n-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nstruct Node {\n\tNode *lch, *rch;\n\tint l, r;\n\tP cl, cr;\n\tNode(int l, int r) :l(l), r(r), cl({l,mod }),lch(NULL),rch(NULL) {};\n};\n\nvoid add(Node* nd, int x,int y) {\n\tint l = nd->l,  r = nd->r;\n\tif (r - l == 1) {\n\t\tif (nd->cl.second == mod) {\n\t\t\tnd->cl = { x,y };\n\t\t\tnd->cr = { x,y };\n\t\t}\n\t\telse {\n\t\t\tif (nd->cl.second < y) {\n\t\t\t\tnd->cl = { x,y };\n\t\t\t\tnd->cr = { x,y };\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tif (x < m) {\n\t\tif (nd->lch == NULL) {\n\t\t\tnd->lch = new Node(l, m);\n\t\t}\n\t\tadd(nd->lch, x, y);\n\t}\n\telse {\n\t\tif (nd->rch == NULL) {\n\t\t\tnd->rch = new Node(m, r);\n\t\t}\n\t\tadd(nd->rch, x, y);\n\t}\n\tif (nd->lch == NULL) {\n\t\tnd->cl = nd->rch->cl;\n\t\tnd->cr = nd->rch->cr;\n\t}\n\telse if (nd->rch == NULL) {\n\t\tnd->cl = nd->lch->cl;\n\t\tnd->cr = nd->lch->cr;\n\t}\n\telse {\n\t\tvector<P> vs;\n\t\tvector<P> v = { nd->lch->cl,nd->lch->cr,nd->rch->cl,nd->rch->cr };\n\t\trep(i, 4) {\n\t\t\twhile (vs.size() && vs.back().second <= v[i].second)vs.pop_back();\n\t\t\tvs.push_back(v[i]);\n\t\t}\n\t\tnd->cl = vs[0];\n\t\tnd->cr = vs.back();\n\t}\n}\nint query(Node *nd,int ad) {\n\tif (nd->r - nd->l == 1) {\n\t\treturn min(nd->l, nd->cl.second + ad);\n\t}\n\n\tif (nd->lch == NULL)return query(nd->rch, ad);\n\telse if (nd->rch == NULL)return query(nd->lch, ad);\n\telse {\n\t\treturn max(query(nd->lch, ad), query(nd->rch, ad));\n\t\t\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> a(n);\n\tint sum = 0;\n\trep(i, n) {\n\t\tcin >> a[i]; sum += a[i];\n\t}\n\tif (n % 2 == 0) {\n\t\tint s1 = 0, s2 = 0;\n\t\tfor (int i = 0; i < n; i += 2) {\n\t\t\ts1 += a[i];\n\t\t}\n\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\ts2 += a[i];\n\t\t}\n\t\tint ans1 = max(s1, s2);\n\t\tcout << ans1 << \" \" << sum - ans1 << \"\\n\";\n\t\treturn;\n\t}\n\n\tint ad = 0;\n\tNode *nd = new Node(0, mod + 1);\n\tadd(nd, mod, 0);\n\n\tvector<int> memo(n + 2);\n\tmemo[0] = mod;\n\n\tint ex = 0;\n\tfor (int i = 1; i < n; i += 2)ex += a[i];\n\n\tfor (int i = 2; i <= n + 1; i += 2) {\n\t\tif (i >= 4) {\n\t\t\tad += a[i - 2]-a[i-3];\n\t\t}\n\t\tmemo[i] = min(memo[i - 2], ex + a[i-2]);\n\t\tmemo[i] = max(memo[i], query(nd, ad));\n\t\tadd(nd, memo[i - 2], ex + a[i - 2] - ad);\n\t}\n\n\tint ans = memo[n + 1];\n\tcout << ans << \" \"<<sum-ans<<\"\\n\";\n\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, a[303030], b[303030], S;\n\nstruct Segtree{\n    long long N, M;\n    long long mnm[1048576], mxm[1048576];\n    void init(){\n        for(int i = 0; i < M; ++i)mnm[i + N] = mxm[i + N] = b[i];\n        for(int i = N - 1; i; --i){\n            mnm[i] = min(mnm[2 * i], mnm[2 * i + 1]);\n            mxm[i] = max(mxm[2 * i], mxm[2 * i + 1]);\n        }\n    }\n    Segtree(long long _N) : mnm(), mxm(){\n        N = 1;\n        M = _N;\n        while(N < _N)N *= 2;\n    }\n    long long mnn(long long L, long long R){\n        L += N;\n        R += N;\n        long long ret = 189501249917890;\n        while(L < R){\n            if(L & 1){\n                ret = min(ret, mnm[L]);\n                ++L;\n            }\n            if(R & 1){\n                ret = min(ret, mnm[R - 1]);\n            }\n            L /= 2;\n            R /= 2;\n        }\n        return ret;\n    }\n    long long mxx(long long L, long long R){\n        L += N;\n        R += N;\n        long long ret = -189501249917890;\n        while(L < R){\n            if(L & 1){\n                ret = max(ret, mxm[L]);\n                ++L;\n            }\n            if(R & 1){\n                ret = max(ret, mxm[R - 1]);\n            }\n            L /= 2;\n            R /= 2;\n        }\n        return ret;\n    }\n};\n\nSegtree sgt(524288);\n\nint main(){\n    scanf(\"%lld\", &N);\n    assert(N & 1);\n    if(N & 1){\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + i);\n            S += a[i];\n            a[i] *= (i & 1) ? -1 : 1;\n        }\n        partial_sum(a, a + N, b + 1);\n        long long ans = b[N];\n        sgt.init();\n        for(int i = 1; i < N; i += 2){\n            ans = max(ans, -b[N] + 2 * min(sgt.mxx(i + 1, N + 1) - b[i + 1], b[i] - sgt.mnn(0, i + 1)));\n        }\n        cout << (S + ans) / 2 << \" \" << (S - ans) / 2 << endl;\n    }else{\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + 4);\n            a[i & 1] += a[4];\n        }\n        if(a[0] < a[1])swap(a[0], a[1]);\n        cout << a[0] << \" \" << a[1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') { if (ch == '-') bo = -1; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9') { res = (res << 1) + (res << 3) + ch - '0'; ch = getchar(); }\n\treturn bo * res;\n}\n\ntemplate<typename T> void read(T &x) { x = read(); }\ntemplate<typename T, typename ...Argv> void read(T &a, Argv &...argv) { read(a); read(argv...); }\n\nconst int N = 3e5 + 100;\nint a[N], sum[N], n, s[2];\n\nbool check(int mid) { // 删掉几个偶数点，使得剩下极长连续子序列的收益 >= mid\n\tint Min = 0;\n\tfor (int i = 2; i <= n; ++ i) {\n\t\tif (sum[i - 1] - Min >= mid) { // i - 1 为右端点 Min 所对应的点位 l - 1;\n\t\t\tMin = std::min(Min, sum[i]); // 由于是验证可行性所以保留前缀和最小的点即可\n\t\t}\n\t}\n\treturn sum[n] - Min >= mid;\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++ i) s[i & 1] += (a[i] = read()), sum[i] = sum[i - 1] + (i & 1 ? a[i] : -a[i]); \n\tif (!(n & 1)) {\n\t\tstd::cout << std::max(s[0], s[1]) << ' ' << std::min(s[0], s[1]) << std::endl;\n\t\treturn 0;\n\t}\n\tint l = 0, r = s[0] + s[1], ans = 0;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (check(mid)) l = mid + 1, ans = mid;\n\t\telse r = mid - 1;\n\t}\n\tans += s[0];\n\tstd::cout << ans << ' ' << s[0] + s[1] - ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = (int) 3e5;\n\nint n;\nint ans[2], a[N + 5];\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(n);\n    for(int i = 1; i <= n; ++i) {\n        read(a[i]), ans[i & 1] += a[i];\n    }\n\n    if(n & 1) {\n        int l = 0, r = ans[0];\n\n        while(l < r) {\n            int mid = (l + r + 1) >> 1, cur = 0, lst = 0;\n            for(int i = 1; i <= n; ++i) {\n                if(!(i & 1)) {\n                    if(ans[0] + cur - lst >= ans[1] + mid) {  \n                        chkmin(lst, cur - a[i]);\n                    }\n                }\n                cur += (i & 1) ? a[i] : -a[i];\n            }\n\n            if(ans[0] + cur - lst >= ans[1] + mid) {\n                l = mid;\n            } else {\n                r = mid - 1;\n            }\n        }\n        printf(\"%d %d\\n\", ans[1] + l, ans[0] - l);\n    } else {\n        if(ans[0] < ans[1])\n            std::swap(ans[0], ans[1]);\n        printf(\"%d %d\\n\", ans[0], ans[1]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[300005],w,b,n;\nbool chk(int x){\n\tint s=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(i&1)s+=a[i];\n\t\telse {\n\t\t\tif(s>=x){s=max(s-a[i],0LL);}\n\t\t\telse s-=a[i];\n\t\t}\n\t}\n\treturn s>=x;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tread(n);\n\tfor(int i=1;i<=n;++i){\n\t\tread(a[i]);\n\t\t(i&1?b:w)+=a[i];\n\t}\n\tif(!(n&1))return write(max(w,b),' ',min(w,b),'\\n');\n\tint l=b-w,r=b,mid;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tif(chk(mid))l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tchk(l-1);\n\twrite(w+max(l-1,b-w),' ',b-max(l-1,b-w),'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n#define mp make_pair\n\nconst int MAXN = 300000;\nconst int INF = (1 << 30);\n\nstruct segment_tree{\n\t#define lch (x << 1)\n\t#define rch (x << 1 | 1)\n\tstruct node{\n\t\tint le, ri; pii mn;\n\t}t[4*MAXN + 5];\n\tvoid pushup(int x) {t[x].mn = min(t[lch].mn, t[rch].mn);}\n\tvoid build(int x, int l, int r) {\n\t\tt[x].le = l, t[x].ri = r;\n\t\tif( l == r ) {\n\t\t\tt[x].mn.fi = 0, t[x].mn.se = l;\n\t\t\treturn ;\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tbuild(lch, l, m), build(rch, m + 1, r);\n\t\tpushup(x);\n\t}\n\tvoid modify(int x, int p, int k) {\n\t\tif( t[x].le == t[x].ri ) {\n\t\t\tt[x].mn.fi = k;\n\t\t\treturn ;\n\t\t}\n\t\tint m = (t[x].le + t[x].ri) >> 1;\n\t\tif( p <= m ) modify(lch, p, k);\n\t\telse modify(rch, p, k);\n\t\tpushup(x);\n\t}\n\tpii query(int x, int l, int r) {\n\t\tif( t[x].ri < l || t[x].le > r )\n\t\t\treturn mp(INF, INF);\n\t\telse if( l <= t[x].le && t[x].ri <= r )\n\t\t\treturn t[x].mn;\n\t\treturn min(query(lch, l, r), query(rch, l, r));\n\t}\n}T1, T2;\n\nbool vis[2][MAXN + 5], tg[MAXN + 5]; int sum[MAXN + 5];\n\nint s[2], a[MAXN + 5], N;\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d\", &a[i]), s[i & 1] += a[i];\n\tif( N % 2 == 0 )\n\t\tprintf(\"%d %d\\n\", max(s[0], s[1]), min(s[0], s[1]));\n\telse {\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tsum[i] = sum[i-1] + (i & 1 ? a[i] : -a[i]);\n\t\tT1.build(1, 1, N>>1), T2.build(1, 1, N>>1);\n\t\tfor(int i=2;i<=N;i+=2) T1.modify(1, i>>1, sum[i-1] - a[i]);\n\t\tfor(int i=2;i<=N;i+=2) T2.modify(1, i>>1, -(sum[i] + a[i]));\n\t\tqueue<pii>que; que.push(mp(0, 0)), que.push(mp(1, N + 1));\n\t\ttg[N + 1] = tg[0] = true;\n\t\twhile( !que.empty() ) {\n\t\t\tpii x = que.front(); que.pop();\n\t\t\tif( x.fi == 0 ) {\n\t\t\t\tint l = (x.se + 2) >> 1, r = (N >> 1);\n\t\t\t\tpii p = T1.query(1, l, r);\n\t\t\t\twhile( sum[x.se] >= p.fi ) {\n\t\t\t\t\tvis[0][p.se] = true;\n\t\t\t\t\tT1.modify(1, p.se, INF);\n\t\t\t\t\tif( vis[1][p.se] ) {\n\t\t\t\t\t\tque.push(mp(0, p.se));\n\t\t\t\t\t\tque.push(mp(1, p.se));\n\t\t\t\t\t\ttg[p.se<<1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tp = T1.query(1, l, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint l = 1, r = (x.se - 2) >> 1;\n\t\t\t\tpii p = T2.query(1, l, r);\n\t\t\t\twhile( -sum[x.se-1] >= p.fi ) {\n\t\t\t\t\tvis[1][p.se] = true;\n\t\t\t\t\tT2.modify(1, p.se, INF);\n\t\t\t\t\tif( vis[0][p.se] ) {\n\t\t\t\t\t\tque.push(mp(0, p.se));\n\t\t\t\t\t\tque.push(mp(1, p.se));\n\t\t\t\t\t\ttg[p.se<<1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tp = T2.query(1, l, r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF, lst = 0;\n\t\tfor(int i=2;i<=N+1;i+=2) {\n\t\t\tif( tg[i] ) {\n\t\t\t\tans = min(ans, sum[i-1] - sum[lst]);\n\t\t\t\tlst = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", s[0] + ans, s[1] - ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[300005];\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t}\n\telse{\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tif(c-b >= 1005){\n\t\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t\t\treturn 0;\n\t\t}\n\t\tint lb = 0,ub = 1007;\n\t\twhile(ub-lb>1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tint dif = c-b;\n\t\t\tif(dif >= mid){\n\t\t\t\tlb = mid; continue;\n\t\t\t}\n\t\t\tint cur = 0;\n\t\t\trepn(i,n){\n\t\t\t\tif(i%2 == 1) cur += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(cur>=mid && cur-a[i]<=0){\n\t\t\t\t\t\tdif -= (cur-a[i]);\n\t\t\t\t\t\tcur = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tcur -= a[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dif >= mid){\n\t\t\t\t\tlb = mid; goto nxt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tub = mid; nxt:;\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",lb+b,c-lb);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 344444;\nint n,a[N];\nbool ck(int mid){\n\tint now=0;\n\trep(i,1,n)\n\t\tif(i&1)now+=a[i];\n\t\telse{\n\t\t\tif(now>=mid)now=max(now-a[i],0);else now-=a[i];\n\t\t}\n\treturn now>=mid;\n}\nint main() {\n\tread(n);rep(i,1,n)read(a[i]);\n\tif(n%2==0){\n\t\tint x=0,y=0;\n\t\trep(i,1,n)if(i&1)x+=a[i];else y+=a[i];\n\t\tprintf(\"%d %d\\n\",max(x,y),min(x,y));return 0;\n\t}\n\tint res=0,l=0,r=0;rep(i,1,n)r+=a[i];\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(ck(mid))res=mid,l=mid+1;else r=mid-1;\n\t}\n\trep(i,1,n)if(i%2==0)res+=a[i];int qaq=-res;rep(i,1,n)qaq+=a[i];\n\tprintf(\"%d %d\\n\",res,qaq);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 300000;\nconst int INF = (1 << 30);\n\nint s[2], sum[MAXN + 5], a[MAXN + 5], N;\nbool check(int x) {\n\tint k = 0;\n\tfor(int i=2;i<=N;i+=2) {\n\t\tif( sum[i-1] - k >= x )\n\t\t\tk = min(k, sum[i]);\n\t}\n\treturn sum[N] - k >= x;\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d\", &a[i]), s[i & 1] += a[i];\n\tif( N % 2 == 0 )\n\t\tprintf(\"%d %d\\n\", max(s[0], s[1]), min(s[0], s[1]));\n\telse {\n\t\tfor(int i=1;i<=N;i++) sum[i] = sum[i-1] + (i & 1 ? a[i] : -a[i]);\n\t\tint le = 0, ri = s[0] + s[1];\n\t\twhile( le < ri ) {\n\t\t\tint mid = (le + ri + 1) >> 1;\n\t\t\tif( check(mid) ) le = mid;\n\t\t\telse ri = mid - 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", s[0] + le, s[1] - le);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint s[MAXN],a[MAXN],n;\nbool check(int x)\n{\n\tint ans=0;\n\tfor (int i=1;i<n;i+=2)\n\t\tif (s[i]-ans>=x) upmin(ans,s[i+1]);\n\treturn s[n]-ans>=x;\n}\nint main()\n{\n\tn=read();\n\tint sum=0;\n\tfor (int i=1;i<=n;i++) a[i]=read(),sum+=a[i];\n\tif (!n)\n\t{\n\t\tint s=0;\n\t\tfor (int i=1;i<=n;i++) s+=(i&1)*a[i];\n\t\tprintf(\"%d %d\\n\",max(s,sum-s),min(s,sum-s));\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++) s[i]=s[i-1]+a[i]*((i&1)?1:-1);\n\tint l=0,r=n*1000;\n\twhile (l<r)\n\t{\n\t\tint mid=(l+r+1)>>1;\n\t\tif (check(mid)) l=mid;\n\t\telse r=mid-1;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!(i&1)) l+=a[i];\n\tprintf(\"%d %d\\n\",l,sum-l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\nconst char lf = '\\n';\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 300007;\n\nint n;\nlint val[_],ps[_]={0},sval[2]={0};\n\ninline int able(lint x)\n{\n\tlint las=0;\n\tfor(int i=2;i<n && ps[n]-las<x;i+=2)if(ps[i-1]-las>=x)las=min(las,ps[i]);\n\treturn ps[n]-las>=x;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\t\n\tn=ty();\n\tfor(int i=1;i<=n;i++)val[i]=ty(),sval[i&1]+=val[i];\n\tif(!(n&1)){cout<<max(sval[0],sval[1])<<\" \"<<min(sval[0],sval[1])<<lf;return 0;}\n\n\tfor(int i=1;i<=n;i++)ps[i]=ps[i-1]+val[i]*(i&1?1:-1);\n\tlint l=-2e9,r=2e9;\n\twhile(r>l)\n\t{\n\t\tlint mid=(l+r+1)>>1;\n\t\tif(able(mid))l=mid;\n\t\telse r=mid-1;\n\t}\n\tcout<<sval[0]+l<<\" \"<<sval[1]-l<<lf;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n\tint n;\n\tcin >> n;\n\tint a[n];\n        int goukei = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\tgoukei += a[i];\n\t}\n\tint guukinosa = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(i % 2){\n\t\t\tguukinosa -= a[i];\n\t\t} else {\n\t\t\tguukinosa += a[i];\n\t\t}\n\t}\n\tif(n % 2 == 0){\n\t\tcout << (goukei + max(guukinosa, -guukinosa)) / 2 << \" \" << (goukei - max(guukinosa, -guukinosa)) / 2;\n\t\treturn 0;\n\t}\n\telse if(guukinosa >= 100){\n\t\tcout << (goukei + guukinosa) / 2 << \" \" << (goukei - guukinosa) / 2;\n\t\treturn 0;\n\t}\n        else{\n\tint b = 0;\n\tint c = 100;\n\twhile(b + 1 < c){\n\t\tint d = (b + c) / 2;\n\t\tvector<int> e;\n\t\te.push_back(a[0]);\n\t\tfor(int i = 1; i < n; i += 2){\n\t\t\tif(e[e.size() - 1] < d || a[i] < e[e.size() - 1]){\n\t\t\t\te[e.size() - 1] += a[i+1] - a[i];\n\t\t\t} else {\n\t\t\t\te.push_back(a[i]);\n\t\t\t\te.push_back(a[i+1]);\n\t\t\t}\n\t\t}\n\t\tif(e[e.size() - 1] >= d){\n\t\t\tb = d;\n\t\t} else {\n\t\t\tc = d;\n\t\t}\n\t}\n\tcout << (goukei + max(guukinosa, (-guukinosa + 2 * b))) / 2 << \" \" << (goukei - max(guukinosa, (-guukinosa + 2 * b))) / 2;\n\treturn 0;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=300005;\nint n,a[N],su[N],i,s1,s2,l,r,m,mx;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)scanf(\"%d\",a+i),su[i]=su[i-1]+(i&1?a[i]:-a[i]);\n\tfor(i=1;i<=n;i+=2)s1+=a[i];for(i=2;i<=n;i+=2)s2+=a[i];\n\tif(!(n&1)){printf(\"%d %d\\n\",max(s1,s2),min(s1,s2));return 0;}\n\tr=s1;\n\tfor(;l<r;){\n\t\tm=l+r+1>>1;mx=0;\n\t\tfor(i=2;i<=n;i+=2)if(su[i-1]+mx>=m)mx=max(mx,-su[i]);\n\t\tif(mx+su[n]>=m)l=m;else r=m-1;\n\t}\n\tprintf(\"%d %d\\n\",l+s2,s1-l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 300010\n\nusing namespace std;\n\nint n, a[N], qz[N][2], ans, zh;\n\nint main(){\n//\tfreopen(\"funny.in\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tqz[i][0]=qz[i-1][0];\n\t\tqz[i][1]=qz[i-1][1];\n\t\tif (i%2) qz[i][1]+=a[i];\n\t\telse qz[i][0]+=a[i];\n\t\tzh+=a[i];\n\t}\n\tif (n%2==0) ans=max(qz[n][1], qz[n][0]);\n\telse{\n\t\tans=qz[n][1];\n\t\tfor (int i=1; i<=n/2; i++){\n\t\t\tans=max(ans, min(qz[i*2][0]+qz[n][1]-qz[i*2][1], qz[n][0]-qz[i*2-1][0]+qz[i*2-1][1]));\n\t\t}\n\t}\n\tprintf(\"%d %d\", ans, zh-ans);\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nint A[300011];\n\nbool ok(LL mid) {\n    LL pre = A[0];\n    for (int i=1; i<N; i+=2) {\n\tif (pre >= mid && A[i] >= pre) {\n\t    pre = A[i+1];\n\t} else {\n\t    pre = pre - A[i] + A[i+1];\n\t}\n    }\n    return pre >= mid;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", A+i);\n\n    LL ansA = 0, ansB = 0;\n    if (N % 2 == 0) {\n\tREP (i, N) {\n\t    if (i&1) ansB += A[i];\n\t    else ansA += A[i];\n\t}\n\tif (ansA < ansB) swap(ansA, ansB);\n    } else {\n\tLL lo = 0, hi = 1LL<<40;\n\twhile (hi - lo > 1) {\n\t    LL mid = (lo + hi) / 2;\n\t    (ok(mid)? lo: hi) = mid;\n\t}\n\n\tLL sum = 0, alt = 0;\n\tREP (i, N) {\n\t    sum += A[i];\n\t    if (i&1) alt -= A[i];\n\t    else alt += A[i];\n\t}\n\tansA = (lo*2-alt+sum)/2;\n\tansB = sum - ansA;\n    }\n    printf(\"%lld %lld\\n\", ansA, ansB);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nstruct fin {\n\tvector<int> T;\n\tfin() = default;\n\tfin(int N) : T(N+10, OVER9000) {}\n\n\tint lastone(int x) {return x&(x^(x-1));}\n\n\tvoid put(int pos, int val) {\n\t\tfor(int i = pos+1; i < (int)T.size(); i += lastone(i))\n\t\t\tT[i] = min(T[i], val);\n\t}\n\n\tint get(int pos) {\n\t\tint ret = OVER9000;\n\t\tfor(int i = pos+1; i > 0; i -= lastone(i)) ret = min(ret, T[i]);\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, MX = 1000;\n\tcin >> N;\n\tvector<int> A(N);\n\tvector<int> sum[2] = {vector<int>(N+1, 0), vector<int>(N+1, 0)};\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t\tsum[1-i%2][i+1] = sum[1-i%2][i];\n\t\tsum[i%2][i+1] = sum[i%2][i] + A[i];\n\t}\n\tif(N%2 == 0) {\n\t\tcout << max(sum[0][N], sum[1][N]) << \" \" << min(sum[0][N], sum[1][N]) << \"\\n\";\n\t\treturn 0;\n\t}\n\tA.push_back(0);\n\tint ans_l = abs(sum[0][N]-sum[1][N]), ans_r = abs(sum[0][N]-sum[1][N])+2*MX;\n\tmap<int, int> X;\n\tX[sum[1][N]-sum[0][N]] = 0;\n\tfor(int i = 2; i < N; i += 2) X[sum[1][i+1]-sum[0][i]] = 0;\n\tint x_mx = 0;\n\tALL_THE(X, it) it->ss = x_mx++;\n\tvector<int> X_id(N), X_val(x_mx+1, OVER9000);\n\tALL_THE(X, it) X_val[it->ss] = it->ff;\n\tfor(int i = 2; i < N; i += 2) X_id[i] = X[sum[1][i+1]-sum[0][i]];\n\twhile(ans_r-ans_l > 1) {\n\t\tint ans_m = (ans_l + ans_r) / 2;\n\t\tvector<int> valid(N+2, 0);\n\t\tvalid[0] = 1;\n\t\tfin Fl(x_mx), Fr(x_mx);\n\t\tfor(int i = 2; i <= N+1; i += 2) {\n\t\t\tint d = sum[0][i-1]-sum[1][i-2]+sum[1][1];\n\t\t\tif(sum[1][N]-sum[0][N]+2*d >= ans_m && valid[0] && d < A[i-1]) valid[i] = 1;\n\t\t\tauto it = X.lower_bound((ans_m+sum[0][N]-sum[1][N]+1)/2+sum[1][i-2]-sum[0][i-1]);\n\t\t\tint id = x_mx;\n\t\t\tif(it != X.end()) id = it->ss;\n\t\t\tif(Fr.get(x_mx-id) < A[i-1]+sum[1][i-2]-sum[0][i-1]) valid[i] = 1;\n\t\t\telse if(Fl.get(x_mx-id) < sum[1][i-2]-sum[0][i-1]) valid[i] = 1;\n\t\t\tif(i < N && valid[i]) {\n\t\t\t\tFl.put(x_mx-X_id[i], sum[1][i+1]-sum[0][i]-A[i-1]);\n\t\t\t\tFr.put(x_mx-X_id[i], sum[1][i+1]-sum[0][i]);\n\t\t\t}\n\t\t}\n\t\tif(valid[N+1]) ans_l = ans_m;\n\t\telse ans_r = ans_m;\n\t}\n\tcout << (ans_l+sum[0][N]+sum[1][N])/2 << \" \" << (-ans_l+sum[0][N]+sum[1][N])/2 << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define N 100012\nint n,co[2],a[N],s[N],ans=0;\ninline bool can(int mid){int i,v=0;for(i=2;i<=n;i+=2)if(s[i-1]>=(mid+v))v=min(v,s[i]);return (s[n]>=(mid+v));}\nint main(){\n\tscanf(\"%d\",&n);int i,l,r,mid;for(i=1;i<=n;i++){scanf(\"%d\",&a[i]);co[i&1]+=a[i];}\n\tif(!(n&1)){printf(\"%d %d\",max(co[0],co[1]),min(co[0],co[1]));return 0;}\n\tfor(i=1;i<=n;i++)s[i]=s[i-1]+(i&1)?a[i]:(-a[i]);l=1;r=1e9;\n\twhile(l<=r){mid=(l+r)>>1;if(can(mid)){ans=mid;l=mid+1;}else r=mid-1;}printf(\"%d %d\",co[0]+ans,co[1]-ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nint n,a[300005],s[300005],s0,s1;\n\nbool Check(int x)\n{\n    int v=0;\n    for(int i=1;i<n;i+=2)\n        if(s[i]-v>=x)\n            v=std::min(v,s[i+1]);\n    return s[n]-v>=x;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n    if(!(n&1))\n    {\n        for(int i=1;i<=n;++i)(i&1?s0:s1)+=a[i];\n        printf(\"%d %d\\n\",std::max(s0,s1),std::min(s0,s1));\n        return 0;\n    }\n    for(int i=1;i<=n;++i)s[i]=s[i-1]+(i&1?a[i]:-a[i]);\n    int l=1,r=1000*n,Mid;\n    while(l<r)\n        if(Check(Mid=(l+r)>>1))l=Mid+1;\n        else r=Mid;\n    int Ans=l-1,Sum=0;\n    for(int i=2;i<=n;i+=2)Ans+=a[i];\n    for(int i=1;i<=n;++i)Sum+=a[i];\n    printf(\"%d %d\\n\",Ans,Sum-Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn=300111;\nstruct data\n{\n\tset<pair<int,int> >st;\n\tvoid add(int x,int y)//add (x,y)\n\t{\n\t\tst.insert(MP(x,y));\n\t\twhile(true)\n\t\t{\n\t\t\tset<pair<int,int> >::iterator it=st.lower_bound(MP(x,y+1));\n\t\t\tif(it!=st.end()&&it->SS<=y)st.erase(it);else break;\n\t\t}\n\t}\n\tint query(int l)//query max(y) when x<=l\n\t{\n\t\tset<pair<int,int> >::iterator it=st.lower_bound(MP(l+1,-2e9));\n\t\tif(it==st.begin())return -1e9;\n\t\telse\n\t\t{\n\t\t\tit--;\n\t\t\treturn it->SS;\n\t\t}\n\t}\n\tvoid init()\n\t{\n\t\tst.clear();\n\t}\n}yxg1,yxg2;\nint n;\nint a[maxn],pre[maxn];\nint dp0[maxn],dp1[maxn];\nint cost(int i,int j)\n{\n\treturn pre[j]-pre[i-1];\n}\nvoid out(int x)\n{\n\tint sum=0;\n\tfor(int i=1;i<=n;i++)sum+=a[i];\n//\tcerr<<\"sum=\"<<sum<<endl;\n\tassert((sum+x)%2==0);\n\tcout<<(sum+x)/2<<\" \"<<(sum-x)/2<<endl;\n}\nvoid calcdp(int dp[])\n{\n\tstatic int A[maxn],B[maxn];\n\tfor(int i=1;i<=n;i++)pre[i]=pre[i-1]+(i&1?a[i]:-a[i]);\n\tyxg1.init();\n\tyxg2.init();\n\tfor(int i=1;i<=n;i+=2)\n\t{\n\t\tdp[i]=cost(1,i);\n\t\tint X=pre[i];\n\t\tdp[i]=max(dp[i],-X+min(yxg1.query(2*X),2*X+yxg2.query(-2*X-1)));\n\t\tA[i+1]=dp[i]+pre[i];\n\t\tB[i+1]=-2*pre[i+1];\n\t\tyxg1.add(A[i+1]-B[i+1],A[i+1]);\n\t\tyxg2.add(B[i+1]-A[i+1],B[i+1]);\n\t}\n}\nint main()\n{\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)geti(a[i]);\n\tfor(int i=1;i<=n;i++)pre[i]=pre[i-1]+(i&1?a[i]:-a[i]);\n\tif(n%2==0)\n\t{\n\t\tout(max(pre[n],-pre[n]));\n\t\treturn 0;\n\t}\n\tint ans=pre[n];\n\tint sum=cost(1,n);\n\tcalcdp(dp0);\n\treverse(a+1,a+n+1);\n\tcalcdp(dp1);\n\treverse(a+1,a+n+1);\n\treverse(dp1+1,dp1+n+1);\n\tfor(int i=1;i<=n;i++)pre[i]=pre[i-1]+(i&1?a[i]:-a[i]);\n//\tfor(int i=1;i<=n;i+=2)cerr<<dp0[i]<<\" \";cerr<<endl;\n//\tfor(int i=1;i<=n;i+=2)cerr<<dp1[i]<<\" \";cerr<<endl;\n\t\n\tfor(int i=2;i<=n;i+=2)\n\t{\n\t\tans=max(ans,min(dp0[i-1]-cost(i,n),dp1[i+1]-cost(1,i)));\n\t}\n\tout(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,a[300030],sumb,sumw;\nbool check(int w)\n{\n\tint mi=0,sum=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(i&1)sum+=a[i];\n\t\telse\n\t\t{\n\t\t\tif(sum-mi>=w)mi=min(mi,sum-a[i]);\n\t\t\tsum-=a[i];\n\t\t}\n\t}\n\treturn sum-mi>=w;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i+=2)sumb+=a[i];\n\tfor(int i=2;i<=n;i+=2)sumw+=a[i];\t\n\tif(n%2==0)\n\t{\n\t\tif(sumb>sumw)printf(\"%d %d\\n\",sumb,sumw);\n\t\telse printf(\"%d %d\\n\",sumw,sumb);\n\t\treturn 0;\n\t}\n\tint l=0,r=sumb,mid;\n\twhile(l<r)\n\t{\n\t\tmid=l+r+1>>1;\n\t\tif(check(mid))l=mid;\n\t\telse r=mid-1;\n\t}\n\tprintf(\"%d %d\\n\",sumw+l,sumb-l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n#define mp make_pair\n\nconst int MAXN = 300000;\nconst int INF = (1 << 30);\n\nstruct segment_tree{\n\t#define lch (x << 1)\n\t#define rch (x << 1 | 1)\n\tstruct node{\n\t\tint le, ri; pii mn;\n\t}t[4*MAXN + 5];\n\tvoid pushup(int x) {t[x].mn = min(t[lch].mn, t[rch].mn);}\n\tvoid build(int x, int l, int r) {\n\t\tt[x].le = l, t[x].ri = r;\n\t\tif( l == r ) {\n\t\t\tt[x].mn.fi = 0, t[x].mn.se = l;\n\t\t\treturn ;\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tbuild(lch, l, m), build(rch, m + 1, r);\n\t\tpushup(x);\n\t}\n\tvoid modify(int x, int p, int k) {\n\t\tif( t[x].le == t[x].ri ) {\n\t\t\tt[x].mn.fi = k;\n\t\t\treturn ;\n\t\t}\n\t\tint m = (t[x].le + t[x].ri) >> 1;\n\t\tif( p <= m ) modify(lch, p, k);\n\t\telse modify(rch, p, k);\n\t\tpushup(x);\n\t}\n\tpii query(int x, int l, int r) {\n\t\tif( t[x].ri < l || t[x].le > r )\n\t\t\treturn mp(INF, INF);\n\t\telse if( l <= t[x].le && t[x].ri <= r )\n\t\t\treturn t[x].mn;\n\t\treturn min(query(lch, l, r), query(rch, l, r));\n\t}\n}T1, T2;\n\nbool vis[2][MAXN + 5], tg[MAXN + 5]; int sum[MAXN + 5];\n\nint s[2], a[MAXN + 5], N;\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d\", &a[i]), s[i & 1] += a[i];\n\tif( N % 2 == 0 )\n\t\tprintf(\"%d %d\\n\", max(s[0], s[1]), min(s[0], s[1]));\n\telse {\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tsum[i] = sum[i-1] + (i & 1 ? a[i] : -a[i]);\n\t\tT1.build(1, 1, N>>1), T2.build(1, 1, N>>1);\n\t\tfor(int i=2;i<=N;i+=2) T1.modify(1, i>>1, sum[i-1] - a[i]);\n\t\tfor(int i=2;i<=N;i+=2) T2.modify(1, i>>1, -(sum[i] + a[i]));\n\t\tqueue<pii>que; que.push(mp(0, 0)), que.push(mp(1, N + 1));\n\t\ttg[N + 1] = tg[0] = true;\n\t\twhile( !que.empty() ) {\n\t\t\tpii x = que.front(); que.pop();\n\t\t\tif( x.fi == 0 ) {\n\t\t\t\tint l = (x.se + 2) >> 1, r = (N >> 1);\n\t\t\t\tpii p = T1.query(1, l, r);\n\t\t\t\twhile( sum[x.se] >= p.fi ) {\n\t\t\t\t\tvis[0][p.se<<1] = true;\n\t\t\t\t\tT1.modify(1, p.se, INF);\n\t\t\t\t\tif( vis[1][p.se<<1] ) {\n\t\t\t\t\t\tque.push(mp(0, p.se << 1));\n\t\t\t\t\t\tque.push(mp(1, p.se << 1));\n\t\t\t\t\t\ttg[p.se<<1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tp = T1.query(1, l, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint l = 1, r = (x.se - 2) >> 1;\n\t\t\t\tpii p = T2.query(1, l, r);\n\t\t\t\twhile( -sum[x.se-1] >= p.fi ) {\n\t\t\t\t\tvis[1][p.se<<1] = true;\n\t\t\t\t\tT2.modify(1, p.se, INF);\n\t\t\t\t\tif( vis[0][p.se<<1] ) {\n\t\t\t\t\t\tque.push(mp(0, p.se<<1));\n\t\t\t\t\t\tque.push(mp(1, p.se<<1));\n\t\t\t\t\t\ttg[p.se<<1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tp = T2.query(1, l, r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF, lst = 0;\n\t\tfor(int i=2;i<=N+1;i+=2) {\n\t\t\tif( tg[i] ) {\n\t\t\t\tans = min(ans, sum[i-1] - sum[lst]);\n\t\t\t\tlst = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", s[0] + ans, s[1] - ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long int N;\n\n\nint checkif(long long int arr[],long long int N,int num){\nfor(int i=0;i<N;i++){\n    if(arr[i]==num){\n        return 1;\n    }\n}\nreturn 0;\n}\n\nint find_adjacent(long long int i,long long int flag[]){\nif(i-1>=0  && flag[i-1]==0){\n    if(flag[i-1]==0){return 1;}\n    else return 0;\n}\n\nelse return 0;\n}\n\nint find_adjacent2(long long int i,long long int flag[]){\nif(i+1<=N && flag[i+1]==0){\n    if(flag[i+1]==0){return 1;}\n    else return 0;\n}\nelse return 0;\n}\n\nlong long int check_for_adjacent(long long int mini_ind_sugim,long long int arr[],long long int flag[]){\nlong long int mini2=0,temp_mini2_ind;\nif(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==1){\nif(arr[mini_ind_sugim-1]>arr[mini_ind_sugim+1]){\n     //   sigma=sigma+arr[mini_ind_sugim-1];\n       // printf(\"%lld\\n\",sigma);\n      //max_ind_sigma=mini_ind_sugim-1;\n//flag[mini_ind_sugim-1]=1;}\nreturn mini_ind_sugim-1;\n}\nelse{\n\n   // sigma=sigma+arr[mini_ind_sugim+1];\n   // printf(\"%lld\\n\",sigma);\n  //  max_ind_sigma=mini_ind_sugim+1;\n  //  flag[mini_ind_sugim+1]=1;\n  return mini_ind_sugim+1;\n}\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==0){\n   // sigma=sigma+arr[mini_ind_sugim-1];\n    //max_ind_sigma=mini_ind_sugim-1;\n    //flag[mini_ind_sugim-1]=1;\n    return mini_ind_sugim-1;\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==0 && find_adjacent2(mini_ind_sugim,flag)==1){\n    //sigma=sigma+arr[mini_ind_sugim+1];\n   // max_ind_sigma=mini_ind_sugim+1;\n    //flag[mini_ind_sugim+1]=1;\n    return mini_ind_sugim+1;\n}\nelse{\n       for(long long int i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                temp_mini2_ind=i;\n            }\n        }\n    }\n    return temp_mini2_ind;\n   // sigma=sigma+mini2;\n   // printf(\"%lld\\n\",sigma);\n    //flag[max_ind_sigma]=1;\n}\n}\n\n\nint main(){\n\nscanf(\"%lld\",&N);\nlong long int arr[N],i,maxs=2000,mini=0,mini_ind_sugim,max_ind_sigma,flag[N],arr2[N],sigma=0,sugim=0,mini2=0,mini2_ind;\nmemset(flag,0,sizeof(flag));\n\nfor(i=0;i<N;i++){\n    scanf(\"%lld\",&arr[i]);\n    arr2[i]=arr[i];\n    if(arr[i]>mini){\n        mini=arr[i];\n        mini_ind_sugim=i;\n    }\n}\n\nsugim=sugim+mini;\nflag[mini_ind_sugim]=1;\n//printf(\"%lld\\n\",sugim);\n\nif(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==1){\nif(arr[mini_ind_sugim-1]>arr[mini_ind_sugim+1]){\n        sigma=sigma+arr[mini_ind_sugim-1];\n    //    printf(\"%lld\\n\",sigma);\nmax_ind_sigma=mini_ind_sugim-1;\nflag[mini_ind_sugim-1]=1;}\nelse{\n\n    sigma=sigma+arr[mini_ind_sugim+1];\n  //  printf(\"%lld\\n\",sigma);\n    max_ind_sigma=mini_ind_sugim+1;\n    flag[mini_ind_sugim+1]=1;\n}\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==0){\n    sigma=sigma+arr[mini_ind_sugim-1];\n    max_ind_sigma=mini_ind_sugim-1;\n    flag[mini_ind_sugim-1]=1;\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==0 && find_adjacent2(mini_ind_sugim,flag)==1){\n    sigma=sigma+arr[mini_ind_sugim+1];\n    max_ind_sigma=mini_ind_sugim+1;\n    flag[mini_ind_sugim+1]=1;\n}\nelse{\n       for(i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                max_ind_sigma=i;\n            }\n        }\n    }\n    sigma=sigma+mini2;\n//    printf(\"%lld\\n\",sigma);\n    flag[max_ind_sigma]=1;\n}\n\n\n\n\nint turn=0;\nwhile(checkif(flag,N,0)==1){\n      // printf(\"yessss\\n\");\n       if(turn==0){\n          //  cout<<max_ind_sigma<<endl;\n       mini_ind_sugim=check_for_adjacent(max_ind_sigma,arr,flag);\n       //cout<<mini_ind_sugim<<endl;\n       sugim=sugim+arr[mini_ind_sugim];\n       flag[mini_ind_sugim]=1;\n       turn=1;\n       }\n       else{\n            //cout<<mini_ind_sugim<<endl;\n            max_ind_sigma=check_for_adjacent(mini_ind_sugim,arr,flag);\n\n            sigma=sigma+arr[max_ind_sigma];\n            flag[max_ind_sigma]=1;\n            turn=0;\n       }\n}\n\ncout<<endl;\n\nprintf(\"%lld %lld\",sugim,sigma);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 3e5 + 20 , inf = 1e9 + 20 ;\nint n , a[N] , b , w ;\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] ;\n\t\t(i & 1 ? w : b) += a[i] ;\n\t}\n\n\tif (!(n & 1))\n\t\treturn cout << max(b , w) << ' ' << min(b , w) << '\\n' , 0 ;\n\n\tint low = 0 , high = inf ;\n\n\twhile (high - low > 1) {\n\t\tint mid = (low + high) >> 1 ;\n\n\t\tint mx = 0 ;\n\n\t\tfor (int i = 0 ; i < n ; i ++) {\n\t\t\tif (i & 1) mx -= a[i] ;\n\t\t\telse {\n\t\t\t\tmx += a[i] ;\n\t\t\t\tif (mx >= mid && i + 1 < n) mx = max(mx , a[i + 1]) ;\n\t\t\t}\n\t\t}\n\n\t\t(mx >= mid ? low : high) = mid ;\n\t}\n\n\tcout << w + low << ' ' << b - low << '\\n' ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#define lowbit(x) ((x)&-(x))\ntypedef long long ll;\nconst int N=3e5+5,M=3e6+5;\nconst ll inf=1ll<<40;\nll a[N],s[N],f[N],g[N],b[N];int n,m,rk[N];\ntemplate<class T>T abs(T x){return x<0?-x:x;}\ntemplate<class T>bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>T min(T a,T b){return a<b?a:b;}\ntemplate<class T>T div2(T x){return (x-(x&1))/2;}\ninline void init(){\n\tstd::reverse(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)s[i]=s[i-1]+((i&1)?-a[i]:a[i]);\n}\nstruct node{\n\tnode*c[2];\n\tint size;\n\tll v1,v2,key,x1,x2;\n\tnode();\n\tvoid pushup();\n}Tnull,*null=&Tnull,pl[M],*rt[N];int pp;\nnode::node(){\n\tc[0]=c[1]=null;\n\tv1=v2=x1=x2=key=size=0;\n}\nvoid node::pushup(){\n\tsize=c[0]->size+c[1]->size+1;\n\tx1=v1,x2=v2;\n\tif(c[0]!=null)chkmax(x1,c[0]->x1),chkmax(x2,c[0]->x2); \n\tif(c[1]!=null)chkmax(x1,c[1]->x1),chkmax(x2,c[1]->x2);\n}\nvoid rot(node*&x,bool f){\n\tnode*y=x->c[f];\n\tx->c[f]=y->c[f^1],y->c[f]=x;\n\tx->pushup(),x=y,x->pushup(); \n}\nvoid insert(node*&x,node*y){\n\tif(x==null){\n\t\tx=y,x->c[0]=x->c[1]=null,x->pushup();\n\t\treturn;\n\t}\n\tbool f=x->key<y->key;\n\tinsert(x->c[f],y);\n\tif(x->c[f]->size>(x->size+1)*0.75)rot(x,f);else x->pushup();\n}\nll ask(node*x,ll cut){\n\tif(x==null)return -inf;\n\tll res=-inf;\n\tif(x->key<=cut){\n\t\tchkmax(res,x->v1-cut);\n\t\tif(x->c[0]!=null)chkmax(res,x->c[0]->x1-cut);\n\t\tchkmax(res,ask(x->c[1],cut));\n\t}else{\n\t\tchkmax(res,x->v2+cut);\n\t\tif(x->c[1]!=null)chkmax(res,x->c[1]->x2+cut);\n\t\tchkmax(res,ask(x->c[0],cut));\n\t}\n\treturn res;\n}\ninline void calc(ll*f){\n\tint i,x;\n\tfor(m=0,i=1;i<=n;i++)b[++m]=s[i];\n\tstd::sort(b+1,b+m+1),m=std::unique(b+1,b+m+1)-b-1;\n\tfor(i=1;i<=n;i++)rk[i]=m-(std::lower_bound(b+1,b+m+1,s[i])-b)+1;\n\tpp=0;\n\tfor(i=1;i<=m;i++)rt[i]=null;\n\tfor(i=1;i<=n;i+=2){\n\t\tf[i]=abs(s[i]);\n\t\tfor(x=rk[i]-1;x;x-=lowbit(x))chkmax(f[i],ask(rt[x],s[i]));\n\t\tif(i<n){\n\t\t\tfor(x=rk[i+1];x<=m;x+=lowbit(x)){\n\t\t\t\tnode*z=pl+(pp++);\n\t\t\t\tz->key=div2(2*s[i+1]+s[i]-f[i]);\n\t\t\t\tz->v1=2*s[i+1],z->v2=f[i]-s[i];\n\t\t\t\tinsert(rt[x],z);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tll dif=0,sum=0;\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",a+i),dif+=(i&1)?a[i]:-a[i],sum+=a[i];\n\tdif=abs(dif);\n\tif(n&1){\n\t\tstd::reverse(a+1,a+n+1);\n\t\tinit(),calc(f),init(),calc(g),init();\n\t\tstd::reverse(g+1,g+n+1);\n\t\tfor(i=2;i<n;i+=2)chkmax(dif,a[i]+min(s[i-1]+g[i+1],f[i-1]+s[n]-s[i]));\n\t}\n\tll sigma=(sum-dif)>>1,sugim=sigma+dif;\n\tprintf(\"%lld %lld\\n\",sugim,sigma);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 300000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,a[MN+5],tot[2],ans,s[MN+5],L[MN+5],R[MN+5];\nbool Solve(int lim)\n{\n    int mn=1e9;memset(L,0,sizeof(L));\n    for(int j=2;j<=n;j+=2)\n    {\n        if(tot[0]+s[j-1]>=lim) mn=min(mn,s[j]),L[j]=true;\n        if(tot[0]+s[j-1]-mn>=lim) L[j]=true;\n    }\n    mn=-1e9;\n    for(int j=n-1;j;j-=2)\n    {\n        int fg=0;\n        if(tot[0]+s[n]-s[j]>=lim) fg=1,mn=max(mn,s[j-1]);\n        if(tot[0]+mn-s[j-1]>=lim) fg=1;\n        if(fg&&L[j]) return true;\n    }\n    return false;\n}\nint main()\n{   \n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read(),tot[i&1]+=a[i];\n    if(~n&1) return 0*printf(\"%d %d\\n\",max(tot[0],tot[1]),min(tot[1],tot[0]));\n    ans=max(tot[0],tot[1]);\n    int l=ans+1,r=tot[0]+tot[1],mid;\n    for(int i=1;i<=n;++i) s[i]=s[i-1]+((i&1)?1:-1)*a[i];\n    while(l<=r)\n    {\n        mid=l+r>>1;\n        if(Solve(mid)) ans=mid,l=mid+1;\n        else r=mid-1;\n    }\n    printf(\"%d %d\\n\",ans,tot[0]+tot[1]-ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nint R(int l,int r)\n{\n\treturn (rand()<<15|rand())%(r-l+1)+l;\n}\nint a[333333];\nint s[333333];\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<=n;++i)a[i]=io::F();\n\tif(n&1)\n\t{\n\t\tint c[2]={0};\n\t\tfor(register int i=1;i<=n;++i)c[i&1]+=a[i];\n\t\tint ans=c[1];\n\t\tfor(register int i=1;i<=n;++i)\n\t\t\ts[i]=s[i-1]+(i&1?a[i]:-a[i]);\n\t\tfor(int l=dmax(0,c[1]-c[0]),r=c[1]+c[0],mid=l+r>>1;l<=r;mid=l+r>>1)\n\t\t{\n\t\t\tint a=0;\n\t\t\tfor(int i=1;i<n;i+=2)\n\t\t\t\t if(s[i]-a>=mid)cmin(a,s[i+1]);\n\t\t\tif(s[n]-a>=mid)cmax(ans,c[0]+mid),l=mid+1;\n\t\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",ans,c[0]+c[1]-ans);\n\t}\n\telse\n\t{\n\t\tint c[2]={0};\n\t\tfor(register int i=1;i<=n;++i)c[i&1]+=a[i];\n\t\tprintf(\"%d %d\\n\",dmax(c[0],c[1]),dmin(c[0],c[1]));\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') { if (ch == '-') bo = -1; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9') { res = (res << 1) + (res << 3) + ch - '0'; ch = getchar(); }\n\treturn bo * res;\n}\n\ntemplate<typename T> void read(T &x) { x = read(); }\ntemplate<typename T, typename ...Argv> void read(T &a, Argv &...argv) { read(a); read(argv...); }\n\nconst int N = 3e5 + 10;\n\nint sum[N], a[N], n, s[2];\n\nbool check(int mid) {\n\tint res = 0;\n\tfor (int i = 2; i <= n; ++ i) {\n\t\tif (sum[i - 1] - res >= mid) res = std::min(sum[i], res);\n\t}\n\treturn sum[n] - res >= mid;\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tread(a[i]); sum[i] = sum[i - 1] + (i & 1 ? a[i] : -a[i]);\n\t\ts[i & 1] += a[i];\n\t}\n\tif (!(n & 1)) { printf(\"%d %d\\n\", std::max(s[0], s[1]), std::min(s[0], s[1])); return 0; }\n\tint l = 0, r = s[0] + s[1];\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (check(mid)) l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\tint ans = std::max(s[0] + l - 1, s[1]);\n\tprintf(\"%d %d\\n\", ans, s[0] + s[1] - ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\ntypedef unsigned int u32;\nconst int N=3e5+5;\nint n,a[N],s[N],f[N],g[N];\ntemplate<class T>T abs(T x){return x<0?-x:x;}\ntemplate<class T>bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>T min(T a,T b){return a<b?a:b;}\ninline void init(){\n\tstd::reverse(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)s[i]=s[i-1]+((i&1)?-a[i]:a[i]);\n}\ninline void calc(int*f){\n\tint i,j;\n\tfor(i=1;i<=n;i+=2){\n\t\tf[i]=abs(s[i]);\n\t\tfor(j=2;j<i;j+=2){\n\t\t\tif(s[i]>=s[j]){\n\t\t\t\tchkmax(f[i],min(a[j]+f[j-1]+s[i]-s[j],s[i]));\n\t\t\t}else{\n\t\t\t\tchkmax(f[i],min(a[j]+f[j-1]+s[i]-s[j],s[j]+s[j]-s[i]));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tif(n>10000)exit(0);\n\tint dif=0;\n\tu32 sum=0;\n\tfor(i=1;i<=n;i++)scanf(\"%d\",a+i),dif+=(i&1)?a[i]:-a[i],sum+=a[i];\n\tdif=abs(dif);\n\tif(n&1){\n\t\tstd::reverse(a+1,a+n+1);\n\t\tinit(),calc(f),init(),calc(g),init();\n\t\tstd::reverse(g+1,g+n+1);\n\t\tfor(i=2;i<n;i+=2)chkmax(dif,a[i]+min(s[i-1]+g[i+1],f[i-1]+s[n]-s[i]));\n\t}\n\tu32 sigma=(sum-dif)>>1,sugim=sigma+dif;\n\tprintf(\"%u %u\\n\",sugim,sigma);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[300010], sum[300010], n;\ninline int check(int x) {\n    int _min = 0;\n    for (int i = 1; i <= n; i += 2) {\n        if (sum[i] - _min >= x) {\n            _min = min(_min, sum[i + 1]);\n            if (i == n) return 1;\n        }\n    }\n    return 0;\n}\nint main() {\n    scanf(\"%d\", &n);\n    int sum1 = 0, sum2 = 0;\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", a + i);\n        if (i % 2 == 0) a[i] = -a[i], sum1 -= a[i];\n        else sum2 += a[i];\n        sum[i] = sum[i - 1] + a[i];\n    }\n    if (n % 2 == 0) return printf(\"%d %d\\n\", max(sum1, sum2), min(sum1, sum2));\n    int ans, l = -1.5e9, r = 1.5e9;\n    while (l <= r) {\n        int mid = l + r >> 1;\n        if (check(mid)) l = mid + 1, ans = mid;\n        else r = mid - 1;\n    }\n    return printf(\"%d %d\\n\", sum1 + ans, sum2 - ans), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 3e5+5;\n\nint a[MAXN], n, s, ans, dp[MAXN];\n\nbool chk(int x) {\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int i = 0; i < n; i += 2) {\n\t\tif (i == 0) {\n\t\t\tdp[0] = a[0];\n\t\t\tcontinue;\n\t\t}\n\t\tif (dp[i-2] < x) {\n\t\t\tdp[i] = dp[i-2] - a[i-1] + a[i];\n\t\t} else {\n\t\t\tdp[i] = max(dp[i-2] - a[i-1] + a[i], a[i]);\n\t\t}\n\t}\n\treturn (dp[n-1] >= x);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\ts += a[i];\n\t}\n\tif (n%2 == 0) {\n\t\tint x = 0;\n\t\tfor (int i = 0; i < n; i += 2)\n\t\t\tx += a[i];\n\t\tcout << max(x, s-x) << ' ' << min(x, s-x) << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i += 2)\n\t\tans += a[i];\n\tint lo = 0, hi = s;\n\twhile (lo != hi) {\n\t\tint mid = (lo+hi+1)/2;\n\t\tif (chk(mid))\n\t\t\tlo = mid;\n\t\telse\n\t\t\thi = mid-1;\n\t}\n\tcout << s-ans+lo << ' ' << ans-lo << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\ntypedef long long ll;\nconst int N=3e5+5;\nll a[N],s[N],f[N],g[N];int n;\ntemplate<class T>T abs(T x){return x<0?-x:x;}\ntemplate<class T>bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>T min(T a,T b){return a<b?a:b;}\ninline void init(){\n\tstd::reverse(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)s[i]=s[i-1]+((i&1)?-a[i]:a[i]);\n}\ninline void calc(ll*f){\n\tint i,j;\n\tfor(i=1;i<=n;i+=2){\n\t\tf[i]=abs(s[i]);\n\t\tfor(j=2;j<i;j+=2){\n\t\t\tif(s[i]>=s[j]){\n\t\t\t\tchkmax(f[i],min(a[j]+f[j-1]-s[j],0ll)+s[i]);\n\t\t\t}else if(2*s[i]>=3*s[j]-a[j]-f[j-1]){\n\t\t\t\tchkmax(f[i],2*s[j]-s[i]);\n\t\t\t}else{\n\t\t\t\tchkmax(f[i],a[j]+f[j-1]+s[i]-s[j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tif(n>10000)exit(0);\n\tll dif=0,sum=0;\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",a+i),dif+=(i&1)?a[i]:-a[i],sum+=a[i];\n\tdif=abs(dif);\n\tif(n&1){\n\t\tstd::reverse(a+1,a+n+1);\n\t\tinit(),calc(f),init(),calc(g),init();\n\t\tstd::reverse(g+1,g+n+1);\n\t\tfor(i=2;i<n;i+=2)chkmax(dif,a[i]+min(s[i-1]+g[i+1],f[i-1]+s[n]-s[i]));\n\t}\n\tll sigma=(sum-dif)>>1,sugim=sigma+dif;\n\tprintf(\"%lld %lld\\n\",sugim,sigma);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint a[300001],s[2],sum[300001];\nint n,l,r,mid;\nbool pd(int x)\n{\n\tint k=0;\n\tfor (int i=2;i<=n;i+=2)\n\t{\n\t\tif (sum[i-1]-k>=x)k=min(k,sum[i]);\n\t}\n\treturn sum[n]-k>=x;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]),s[i&1]+=a[i];\n\tif (n%2==0)\n\t{\n\t\tprintf(\"%d %d\\n\",max(s[0],s[1]),min(s[0],s[1]));\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)sum[i]=sum[i-1]+a[i]*(i&1?1:-1);\n\tl=0,r=s[0]+s[1];\n\twhile (r>l)\n\t{\n\t\tmid=(l+r+1)>>1;\n\t\tif (pd(mid))l=mid;else r=mid-1;\n\t}\n\tprintf(\"%d %d\\n\",s[0]+l,s[1]-l);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=301010;\nint a[N],s[N],n,ss;\n/*int solve(int l,int r) {\n\tif (vis[l][r]) return dp[l][r];\n\telse {\n\t\tvis[l][r]=1;\n\t\tint ans=2*(s[r*2-1]-s[2*l]);\n\t\tfor (int i=l+1;i<r;i++) {\n\t\t\tans=max(ans,min(solve(i,r),solve(l,i)));\n\t\t}\n\t\tprintf(\"%d %d %d\\n\",l,r,ans);\n\t\treturn dp[l][r]=ans;\n\t}\n}\n*/\nint vis[N];\nbool check(int md) {\n\tvis[0]=1;\n\tint z=0;\n\trep(i,1,n/2+2) {\n\t\tvis[i]=0;\n//\t\trep(j,0,i) if (vis[j]&&2*s[i*2-1]-2*s[2*j]>=md)\n//\t\t\tvis[i]=1;\n//\t\tprintf(\"%d %d %d\\n\",md,i,vis[i]);\n\t\tif (2*s[i*2-1]-z>=md) vis[i]=1; else vis[i]=0;\n\t\tif (vis[i]) z=min(z,2*s[2*i]);\n\t}\n\treturn vis[n/2+1];\n}\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",a+i),ss+=a[i];\n\tif (n%2==0) {\n\t\tint s1=0,s2=0;\n\t\trep(i,1,n+1) if (i%2==0) s1+=a[i]; else s2+=a[i];\n\t\tprintf(\"%d %d\\n\",max(s1,s2),min(s1,s2));\n\t\treturn 0;\n\t}\n\trep(i,1,n+1) {\n\t\tif (i%2==1) s[i]=s[i-1]+a[i]; else s[i]=s[i-1]-a[i];\n\t}\n\n//\tmemset(vis,0,sizeof(vis));\n//\tprintf(\"%d\\n\",solve(0,n/2+1)-s[n]);\n\n\tint l=-1e9,r=1e9;\n\twhile (l+1<r) {\n\t\tint md=l+(r-l)/2;\n\t\tif (check(md)) l=md; else r=md;\n\t}\n\tl-=s[n];\n\tprintf(\"%d %d\\n\",(ss+l)/2,(ss-l)/2);\n//\tprintf(\"%d\\n\",l-s[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define fr first\n\n#define sc second\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nconst int Mod = 1e9 + 7;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 2e18 + 100;\n\nconst double eps = 1e-9;\n\nconst int maxn = 3e5 + 100, maxw = 1e6 + 100, inf = 1e9 + 100, sq = 300, mod = 1e9 + 7, LG = 17;\n\nint n;\n\nint a[maxn];\n\nint Sum;\n\nint oddv;\n\nbool check(int W){\n    int now = 0;\n    int can = 1;\n    for (int i = 0; i < n; i += 2){\n        if (can)\n            setmax(now, 0);\n        now += a[i];\n        can = 0;\n        if (oddv + now >= W)\n            can = 1;\n        if (i == n - 1)\n            return can;\n        now -= a[i + 1];\n    }\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"sort.in\", \"r\", stdin);\n    //freopen(\"sort.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++){\n        cin >> a[i];\n        Sum += a[i];\n        if (i & 1)\n            oddv += a[i];\n    }\n    int big = 3e8 + 1;\n    #ifdef ONPC\n        big = 130;\n    #endif // ONPC\n    int l = max(oddv, Sum - oddv), r = (n % 2 == 0 ? l : big);\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (check(m))\n            l = m;\n        else\n            r = m;\n    }\n    cout << l << ' ' << Sum - l;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0 , f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 3e5 + 5;\nint n;\nint W , B;\nint a[N] , sum[N];\ninline bool check(int mid)\n{\n\tint minn = 0;\n\tfor(int i = 2;i < n;i += 2) if(sum[i - 1] - minn >= mid) minn = min(minn,sum[i]);\n\treturn sum[n] - minn >= mid;\n}\nint main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\ta[i] = read(); sum[i] = sum[i - 1];\n\t\tif(i & 1) B += a[i] , sum[i] += a[i];\n\t\telse W += a[i] , sum[i] -= a[i];\n\t}\n\tif(!(n & 1)) printf(\"%d %d\\n\",max(B,W),min(B,W));\n\telse\n\t{\n\t\tint l = -3e8 , r = 3e8 , ans = 0;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif(check(mid)) ans = mid , l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tint res = max(W + ans,B);\n\t\tprintf(\"%d %d\\n\",res,W + B - res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 300005\nint read() {\n    int s=0,w=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n\t{\n\t    if(ch=='-') w=-1;\n\t    ch=getchar();\n\t}\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();\n    return s*w;\n}\nint n,a[M],sum;\nint s[M],a1,a2;\nbool check(int lim) {\n    int p=0;\n    for(int i=1;i<=n+1;i++)\n\t{\n\t    if(i&1) continue ;\n\t    if(s[i-1]-s[p]>=lim)\n\t\t{\n\t\t    if(i==n+1) return 1;\n\t\t    if(s[i]<s[p]) p=i;\n\t\t}\n\t}\n    return 0;\n}\nvoid work() {\n    for(int i=1;i<=n;i++) s[i]=s[i-1]+(i&1?a[i]:-a[i]);\n    for(int i=2;i<=n;i+=2) a1+=a[i];\n    int l=-sum,r=sum,mid,ans;\n    do{\n\tmid=(l+r)>>1;\n\tif(check(mid)) ans=mid,l=mid+1;\n\telse r=mid-1;\n    }while(l<=r);\n    a1+=ans,a2=sum-a1;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++) {a[i]=read();sum+=a[i];}\n    if(!(n&1))\n\t{\n\t    int x=0;\n\t    for(int i=1;i<=n;i+=2) x+=a[i];\n\t    if(x>a1) a1=x,a2=sum-x;\n\t    x=0;\n\t    for(int i=n;i>=1;i-=2) x+=a[i];\n\t    if(x>a1) a1=x,a2=sum-x;\n\t}\n    else work();\n    cout<<a1<<' '<<a2<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, MX = 1000;\n\tcin >> N;\n\tvector<int> A(N);\n\tvector<int> sum[2] = {vector<int>(N+1, 0), vector<int>(N+1, 0)};\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t\tsum[1-i%2][i+1] = sum[1-i%2][i];\n\t\tsum[i%2][i+1] = sum[i%2][i] + A[i];\n\t}\n\tif(N%2 == 0) {\n\t\tcout << max(sum[0][N], sum[1][N]) << \" \" << min(sum[0][N], sum[1][N]) << \"\\n\";\n\t\treturn 0;\n\t}\n\tint ans_l = abs(sum[0][N]-sum[1][N]), ans_r = abs(sum[0][N]-sum[1][N])+2*MX;\n\twhile(ans_r-ans_l > 1) {\n\t\tint ans_m = (ans_l + ans_r) / 2;\n\t\tvector<int> valid(N+2, 0);\n\t\tvalid[0] = 1;\n\t\tA.push_back(0);\n\t\tset< pair<int, int> > X;\n\t\tfor(int i = 2; i <= N+1; i += 2) {\n\t\t\tint d = sum[0][i-1]-sum[1][i-2]+sum[1][1];\n\t\t\tif(sum[1][N]-sum[0][N]+2*d >= ans_m && valid[0] && d < A[i-1]) valid[i] = 1;\n\t\t\tauto it = X.lower_bound({(ans_m+sum[0][N]-sum[1][N]+1)/2+sum[1][i-2]-sum[0][i-1], -1});\n\t\t\tif(it != X.end()) {\n\t\t\t\tif(it->ff < A[i-1]+sum[1][i-2]-sum[0][i-1]) valid[i] = 1;\n\t\t\t\telse while(it != X.end()) {\n\t\t\t\t\tif(it->ff-MX >= sum[1][i-2]-sum[0][i-1]) break;\n\t\t\t\t\tif(it->ff-A[it->ss-1] < sum[1][i-2]-sum[0][i-1]) {\n\t\t\t\t\t\tvalid[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(valid[i]) X.insert({sum[1][i+1]-sum[0][i], i});\n\t\t}\n\t\tif(valid[N+1]) ans_l = ans_m;\n\t\telse ans_r = ans_m;\n\t}\n\tcout << (ans_l+sum[0][N]+sum[1][N])/2 << \" \" << (-ans_l+sum[0][N]+sum[1][N])/2 << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[300010];\nint f[300010];\nint n;\nbool check(int mid)\n{\n\tint mn=0;\n\tbool flag=true;\n\tfor(int i=2;i<=n+1;i+=2)\n\t{\n\t\tflag=(f[i-1]-mn>=mid);\n\t\tif(flag)\n\t\t\tmn=min(mn,f[i]);\n\t}\n\treturn flag;\n}\nint main()\n{\n\tint W=0,B=0;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tf[i]=f[i-1];\n\t\tif(i&1){\n\t\t\tB+=a[i];\n\t\t\tf[i]+=a[i];\n\t\t}\n\t\telse{\n\t\t\tW+=a[i];\n\t\t\tf[i]-=a[i];\n\t\t}\n\t}\n\tif(n%2==0){\n\t\tprintf(\"%d %d\\n\",max(W,B),min(W,B));\n\t\treturn 0;\n\t}\n\tint l=0,r=1e9;\n\twhile(l+1<r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))l=mid;\n\t\telse r=mid;\n\t}\n\tint res=max(B,W+l);\n\tprintf(\"%d %d\\n\",res,W+B-res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=300000;\n\nint n;\nint a[MAXN];\n\nint sumodd,sumevn;\n\nbool can(int want) {\n\tif(want<sumodd) return true;\n\tint need=want-sumodd;\n\tint cur=0;\n\tfor(int i=0;i<n;i+=2) {\n\t\tif(i>0) { if(cur>=need&&cur-a[i-1]<0) cur=0; else cur-=a[i-1]; }\n\t\tcur+=a[i];\n\t}\n\treturn cur>=need;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n); REP(i,n) scanf(\"%d\",&a[i]);\n\n\tsumodd=0,sumevn=0; REP(i,n) if(i%2==0) sumevn+=a[i]; else sumodd+=a[i];\n\tif(n%2==0) {\n\t\tprintf(\"%d %d\\n\",max(sumodd,sumevn),min(sumodd,sumevn));\n\t} else {\n\t\tint l=max(sumodd,sumevn),h=sumodd+sumevn+1;\n\t\twhile(l+1<h) {\n\t\t\tint m=l+(h-l)/2;\n\t\t\tif(can(m)) l=m; else h=m;\n\t\t}\n\t\tprintf(\"%d %d\\n\",l,sumodd+sumevn-l);\n\t}\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MX = 300005;\n\nusing namespace std;\n\nint a[MX];\n\nint main()\n{\n\tint n, odd = 0, evn = 0;\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tif(i&1) odd += a[i];\n\t\telse evn += a[i];\n\t}\n\tif(n & 1)\n\t{\n\t\tint l = 1, r = 300000000, mid, ans;\n\t\tauto check = [=](int need)\n\t\t{\n\t\t\tint sum = a[1];\n\t\t\tfor(int i=2; i<=n; i+=2)\n\t\t\t{\n\t\t\t\tif(sum >= need) sum = max(sum+a[i+1]-a[i], a[i+1]);\n\t\t\t\telse sum += a[i+1]-a[i];\n\t\t\t}\n\t\t\treturn sum >= need;\n\t\t};\n\t\twhile(l < r)\n\t\t{\n\t\t\tmid = (l+r+1) / 2;\n\t\t\tif(check(mid)) l = ans = mid;\n\t\t\telse r = ans = mid-1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", evn+ans, odd-ans);\n\t}\n\telse printf(\"%d %d\\n\", max(odd, evn), min(odd, evn));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rua system(\"pause\")\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}\n\twhile (isdigit(c)) {x = x * 10 + c - '0', c = getchar();}\n\treturn x * f;\n}\n\nconst int MAXN = 3e5 + 10;\nint n, a[MAXN];\nll s1[MAXN], s2[MAXN], dp[MAXN];\n\ninline bool check(ll x)\n{\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tll now = s1[i] - s2[i];\n\t\t\n\t\tif (i & 1)\n\t\t{\n\t\t\tif (i != n)\n\t\t\t{\n\t\t\t\tdp[i] = dp[i - 1];\n\t\t\t\tif (now - dp[i - 1] >= x)\n\t\t\t\t\tdp[i] = min(dp[i], s1[i + 1] - s2[i + 1]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (now - dp[i - 1] >= x) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse dp[i] = dp[i - 1];\n\t}\n\tassert(0);\n\treturn 0;\n}\n\nint main()\n{\n\tn = read();\n\tfor (int i = 1; i <= n; i ++) a[i] = read();\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\ts1[i] = s1[i - 1];\n\t\ts2[i] = s2[i - 1];\n\t\tif (i & 1) s1[i] += a[i];\n\t\telse s2[i] += a[i];\n\t}\n\t\n\tif (!(n & 1))\n\t{\n\t\tprintf(\"%lld %lld\\n\", max(s1[n], s2[n]), min(s1[n], s2[n]));\n\t\treturn 0;\n\t}\n\t\n\tll ans = s2[n], L = 0, R = s1[n] + s2[n], res = 0;\n\twhile (L <= R)\n\t{\n\t\tll MID = (L + R) >> 1;\n\t\tif (check(MID)) L = MID + 1, res = MID;\n\t\telse R = MID - 1;\n\t}\n\tprintf(\"%lld %lld\\n\", ans + res, s1[n] + s2[n] - ans - res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\nint main(){\n\tstatic int N;\n\tstatic int a[300010];\n\tscanf(\"%d\",&N);\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t\n\tstatic int sumA[300010],sumB[300010];\n\tsumA[0] = 0;\n\tsumB[0] = 0;\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tsumA[i] = sumA[i-1];\n\t\tsumB[i] = sumB[i-1];\n\t\tif(i%2 == 1)sumA[i] += a[i];\n\t\telse sumB[i] += a[i];\n\t}\n\t\n\tint ret = max(sumA[N],sumB[N]);\n\tif(N%2 == 1){\n\t\tint l = 0, r = 1000000000;\n\t\twhile(l<r){\n\t\t\tint m = (l+r+1)/2;\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 1 ; i <= N ; i ++){\n\t\t\t\tif(i%2 == 1)sum += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(sum < a[i] && sum >= m)sum = 0;\n\t\t\t\t\telse sum -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum >= m)l = m;\n\t\t\telse r = m-1;\n\t\t}\n\t\tret = max( ret , sumB[N]+l );\n\t}\n\t\n\tcout << ret << \" \" << sumA[N]+sumB[N]-ret << endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nstruct Node {\n\tNode* lch, * rch;\n\tint l, r;\n\tP cl, cr;\n\tNode(int l, int r) :l(l), r(r), cl({ l,mod }), lch(NULL), rch(NULL) {};\n};\n\nvoid add(Node* nd, int x, int y) {\n\tint l = nd->l, r = nd->r;\n\tif (r - l == 1) {\n\t\tif (nd->cl.second == mod) {\n\t\t\tnd->cl = { x,y };\n\t\t\tnd->cr = { x,y };\n\t\t}\n\t\telse {\n\t\t\tif (nd->cl.second < y) {\n\t\t\t\tnd->cl = { x,y };\n\t\t\t\tnd->cr = { x,y };\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tif (x < m) {\n\t\tif (nd->lch == NULL) {\n\t\t\tnd->lch = new Node(l, m);\n\t\t}\n\t\tadd(nd->lch, x, y);\n\t}\n\telse {\n\t\tif (nd->rch == NULL) {\n\t\t\tnd->rch = new Node(m, r);\n\t\t}\n\t\tadd(nd->rch, x, y);\n\t}\n\tif (nd->lch == NULL) {\n\t\tnd->cl = nd->rch->cl;\n\t\tnd->cr = nd->rch->cr;\n\t}\n\telse if (nd->rch == NULL) {\n\t\tnd->cl = nd->lch->cl;\n\t\tnd->cr = nd->lch->cr;\n\t}\n\telse {\n\t\tvector<P> vs;\n\t\tvector<P> v = { nd->lch->cl,nd->lch->cr,nd->rch->cl,nd->rch->cr };\n\t\trep(i, 4) {\n\t\t\twhile (vs.size() && vs.back().second <= v[i].second)vs.pop_back();\n\t\t\tvs.push_back(v[i]);\n\t\t}\n\t\tnd->cl = vs[0];\n\t\tnd->cr = vs.back();\n\t}\n}\nint query(Node* nd, int ad) {\n\tif (nd->cr.first <= nd->cr.second + ad) {\n\t\treturn nd->cr.first;\n\t}\n\tif (nd->cl.first >= nd->cl.second + ad) {\n\t\treturn nd->cl.second + ad;\n\t}\n\tif (nd->r - nd->l == 1) {\n\t\treturn min(nd->l, nd->cl.second + ad);\n\t}\n\n\tif (nd->lch == NULL)return query(nd->rch, ad);\n\telse if (nd->rch == NULL)return query(nd->lch, ad);\n\telse {\n\t\treturn max(query(nd->lch, ad), query(nd->rch, ad));\n\t}\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> a(n);\n\tint sum = 0;\n\trep(i, n) {\n\t\tcin >> a[i]; sum += a[i];\n\t}\n\tif (n % 2 == 0) {\n\t\tint s1 = 0, s2 = 0;\n\t\tfor (int i = 0; i < n; i += 2) {\n\t\t\ts1 += a[i];\n\t\t}\n\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\ts2 += a[i];\n\t\t}\n\t\tint ans1 = max(s1, s2);\n\t\tcout << ans1 << \" \" << sum - ans1 << \"\\n\";\n\t\treturn;\n\t}\n\n\tint ad = 0;\n\tNode* nd = new Node(0, mod + 1);\n\tadd(nd, mod, 0);\n\n\tvector<int> memo(n + 2);\n\tmemo[0] = mod;\n\n\tint ex = 0;\n\tfor (int i = 1; i < n; i += 2)ex += a[i];\n\n\tfor (int i = 2; i <= n + 1; i += 2) {\n\t\tif (i >= 4) {\n\t\t\tad += a[i - 2] - a[i - 3];\n\t\t}\n\t\tmemo[i] = min(memo[i - 2], ex + a[i - 2]);\n\t\tmemo[i] = max(memo[i], query(nd, ad));\n\t\tadd(nd, memo[i - 2], ex + a[i - 2] - ad);\n\t}\n\n\tint ans = memo[n + 1];\n\tcout << ans << \" \" << sum - ans << \"\\n\";\n\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 300010\n\nusing namespace std;\n\nint n, a[N], qz[N][2], ans, zh;\n\nint dg(int l, int r){\n\tif ((r-l+1)%2==0) return max(qz[r][0]-qz[l-1][0], qz[r][1]-qz[l-1][1]);\n\tint ans=qz[r][1]; \n\tfor (int i=1; i<=n; i++)\n\t\tif (i%2==0) ans=max(ans, min(qz[i][0]+qz[r][1]-qz[i][1], qz[r][0]-qz[i-1][0]+qz[i-1][1]));\n\treturn ans;\n}\n\nint main(){\n//\tfreopen(\"funny.in\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tqz[i][0]=qz[i-1][0];\n\t\tqz[i][1]=qz[i-1][1];\n\t\tif (i%2) qz[i][1]+=a[i];\n\t\telse qz[i][0]+=a[i];\n\t\tzh+=a[i];\n\t}\n\tans=dg(1, n);\n\tprintf(\"%d %d\", ans, zh-ans);\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool check(vector<int> &a, int mid) {\n  int value = a[0];\n  for (int i = 2; i < a.size(); i += 2) {\n    if (value >= mid) {\n      value = max(value + a[i] - a[i - 1], a[i]);\n    } else {\n      value += a[i] - a[i - 1];\n    }\n  }\n  return value >= mid;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> a(n);\n  int sum = 0, black = 0, white = 0;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n    sum += a[i];\n    if (i & 1) {\n      white += a[i];\n    } else {\n      black += a[i];\n    }\n  }\n  if (!(n & 1)) {\n    printf(\"%d %d\\n\", max(black, white), min(black, white));\n  } else {\n    int l = 0, r = black, result = 0;\n    while (l <= r) {\n      int mid = l + r >> 1;\n      if (check(a, mid)) {\n        result = mid;\n        l = mid + 1;\n      } else {\n        r = mid - 1;\n      }\n    }\n    printf(\"%d %d\\n\", white + result, black - result);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[300010], sum[300010], n;\ninline int check(int x) {\n    int _min = 0;\n    for (int i = 1; i <= n; i += 2) {\n        if (sum[i] - _min >= x) {\n            _min = min(_min, sum[i + 1]);\n            if (i == n) return 1;\n        }\n    }\n    return 0;\n}\nint main() {\n    scanf(\"%d\", &n);\n    int sum1 = 0, sum2 = 0;\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", a + i);\n        if (i % 2 == 0) a[i] = -a[i], sum1 -= a[i];\n        else sum2 += a[i];\n        sum[i] = sum[i - 1] + a[i];\n    }\n    if (n % 2 == 0) return printf(\"%d %d\\n\", max(sum1, sum2), min(sum1, sum2)), 0;\n    int ans, l = -1.5e9, r = 1.5e9;\n    while (l <= r) {\n        int mid = l + r >> 1;\n        if (check(mid)) l = mid + 1, ans = mid;\n        else r = mid - 1;\n    }\n    return printf(\"%d %d\\n\", sum1 + ans, sum2 - ans), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize (\"O3\")\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\nenable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return {i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (c it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(x...) \" [\" #x \": \" << (x) << \"] \"\n\nusing ld = long double;\nusing ll = long long;\n\nconstexpr int mod = 1000 * 1000 * 1000 + 7;\nconstexpr int odw2 = (mod + 1) / 2;\n\nvoid OdejmijOd(int& a, int b) { a -= b; if (a < 0) a += mod; }\nint Odejmij(int a, int b) { OdejmijOd(a, b); return a; }\nvoid DodajDo(int& a, int b) { a += b; if (a >= mod) a -= mod; }\nint Dodaj(int a, int b) { DodajDo(a, b); return a; }\nint Mnoz(int a, int b) { return (ll) a * b % mod; }\nvoid MnozDo(int& a, int b) { a = Mnoz(a, b); }\nint Pot(int a, int b) { int res = 1; while (b) { if (b % 2 == 1) MnozDo(res, a); a = Mnoz(a, a); b /= 2; } return res; }\nint Odw(int a) { return Pot(a, mod - 2); }\nvoid PodzielDo(int& a, int b) { MnozDo(a, Odw(b)); }\nint Podziel(int a, int b) { return Mnoz(a, Odw(b)); }\nint Moduluj(ll x) { x %= mod; if (x < 0) x += mod; return x; }\n\ntemplate <typename T> T Maxi(T& a, T b) { return a = max(a, b); }\ntemplate <typename T> T Mini(T& a, T b) { return a = min(a, b); }\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> A(n);\n  for (int& x : A) cin >> x;\n  int sum[2] = {0, 0};\n  for (int i = 0; i < n; i++) {\n    sum[i % 2] += A[i];\n  }\n  if (n % 2 == 0) {\n    cout << max(sum[0], sum[1]) << \" \" << min(sum[0], sum[1]) << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (i % 2 == 1) A[i] *= -1;\n    if (i > 0) A[i] += A[i - 1];\n  }\n  auto Ok = [n, &A](int x) -> bool {\n    int najm = 0;\n    for (int i = 1; i < n; i += 2) {\n      if (najm <= A[i - 1] - x) {\n        Mini(najm, A[i]);\n      }\n    }\n    return najm <= A[n - 1] - x;\n  };\n  int a = 0, b = n * 1005;\n  while (a < b) {\n    const int c = (a + b + 1) / 2;\n    if (Ok(c)) {\n      a = c;\n    } else {\n      b = c - 1;\n    }\n  }\n  cout << (sum[1] + a) << \" \" << (sum[0] - a) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e6 + 1000;\nint n,a[N],sum[N],s[2];\nint check(int x)\n{\n\tint k = 0;\n\tfor(int i = 2;i <= n;i += 2)\n\t\tif(sum[i - 1] - k >= x) k = min(sum[i],k); \n\treturn sum[n] - k >= x;\n}\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++) s[i & 1] += a[i] = read();\n\tif(n & 1 == 0) {cout << max(s[0],s[1]) << \" \" << min(s[0],s[1]); return 0;}\n\telse\n\t{\n\t\tfor(int i = 1;i <= n;i ++) sum[i] = sum[i - 1] + (i & 1 ? a[i] : -a[i]);\n\t\tint l = 0,r = s[0] + s[1],mid,ans;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(check(mid)) {ans = mid; l = mid + 1;}\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tcout << s[0] + ans << \" \" << s[1] - ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=300005;\nint a[Maxn],sum[Maxn][2];\nint main(){\n    int n;scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&a[i]);\n        memcpy(sum[i],sum[i-1],sizeof(sum[i]));\n        sum[i][i&1]+=a[i];\n    }\n    if(n%2==0){\n        cout<<max(sum[n][0],sum[n][1])<<\" \"<<min(sum[n][0],sum[n][1])<<\"\\n\";\n        return 0;\n    }\n    int l=-3e8,r=3e8;\n    while(l<=r){\n        int mid=(l+r)/2,p=0;\n        for(int i=2;i<=n;i+=2)\n            if(mid+p<=sum[i-1][1]-sum[i-2][0])\n                p=min(p,sum[i-1][1]-sum[i][0]);\n        if(mid+p<=sum[n][1]-sum[n][0])l=mid+1;\n        else r=mid-1;\n    }\n    cout<<r+sum[n][0]<<\" \"<<sum[n][1]-r<<\"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 3e5 + 10;\n\nint N, A[MAX_N];\n\nbool check(int x) {\n    int min_s = 0, s = 0;\n    for (int i = 1; i < N; i += 2) {\n        s += A[i];\n        bool succ = s >= min_s + x;\n        s -= A[i + 1];\n        if (succ) min_s = min(min_s, s);\n    }\n    s += A[N];\n    return s >= min_s + x;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    int sum = 0;\n    for (int i = 1; i <= N; i++) scanf(\"%d\", &A[i]), sum += A[i];\n    int ans = 0;\n    if (N % 2 == 0) {\n        for (int i = 1; i <= N; i += 2) ans += A[i];\n        if (ans < sum - ans) ans = sum - ans;\n    } else {\n        for (int i = 1; i <= N; i += 2) ans += A[i];\n        int base = 0;\n        for (int i = 2; i <= N; i += 2) base += A[i];\n        int l = 0, r = sum;\n        while (l != r) {\n            int m = (l + r) / 2;\n            if (check(m + 1)) l = m + 1;\n            else r = m;\n        }\n        ans = max(ans, base + l);\n    }\n    printf(\"%d %d\\n\", ans, sum - ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//第8回シンデレラガール総選挙は是非本田未央ちゃんに投票をお願いします！\n//ファンのことも他のアイドルの子たちのことも本当に大事にしてて、今まで周りに色んなものを与えてくれました。\n//今度は私たちが未央ちゃんにお返しをする番です。みんなでガラスの靴を履かせてあげましょう！\n// #本田未央を一番星に #本田未央を令和のシンデレラガールに #第8回シンデレラガール総選挙\n#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nlint a[364364],b[364364];\nint n;\nbool cal(lint mi){\n\tlint ret=0;\n\trep(i,n) b[i]=a[i];\n\tfor(int i=0;i<n-1;i+=2){\n\t\tif(mi>b[i] || b[i]>b[i+1]) b[i+2]+=b[i]-b[i+1];\n\t}\n\treturn b[n-1]>=mi;\n}\nint main()\n{\n\tcin>>n;rep(i,n) cin>>a[i];\n\tlint s=0,s2=0;\n\trep(i,n){\n\t\tif(i%2==0) s+=a[i];else s2+=a[i];\n\t}\n\tif(n%2==0){\n\t\tcout<<max(s,s2)<<' '<<min(s,s2)<<endl;return 0;\n\t}\n\tlint lo=-123456789012345678LL,hi=123456789012345678LL;\n\twhile(hi>lo){\n\t\tlint mi=(hi+lo+1)/2;\n\t\t//cout<<lo<<' '<<hi<<' '<<mi<<endl;\n\t\tif(cal(mi)) lo=mi;else hi=mi-1;\n\t}\n\tcout<<max(s,s2+lo)<<' '<<s+s2-max(s,s2+lo)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define fo(i,l,r,x) for(int i=(l);i<=(r);i+=x)\nusing namespace std;\nconst int N=3e5+10,inf=1e9;\nint n,a[N],s1,s2,f[N];\nbool check(int x){\n    int mn=0;\n    fo(i,1,n,2) (f[i]-mn>=x)?mn=min(f[i+1],mn):0;\n    return mn==-inf;\n}\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n) scanf(\"%d\",a+i),i&1?s1+=a[i]:s2+=a[i];\n    if(!(n&1)){if(s1<s2) swap(s1,s2);printf(\"%d %d\\n\",s1,s2);return 0;}\n    rep(i,1,n) f[i]=i&1?f[i-1]+a[i]:f[i-1]-a[i];f[n+1]=-1e9;\n    int l=-inf,r=inf,t=-inf;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)) l=mid+1,t=mid;\n        else r=mid-1;\n    }\n    int x=s2+t,y=s1+s2-x;\n    printf(\"%d %d\\n\",x,y);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=3e5+10,inf=0x3f3f3f3f;\nint n,sumw,sumb,a[maxn];\ninline bool check(int x){\n\tint sum=a[1];\n\tfor(int i=3;i<=n;i+=2)\n\t\tif(sum>=x) sum=max(sum+a[i]-a[i-1],a[i]);\n\t\telse sum+=a[i]-a[i-1];\n\treturn sum>=x;\n}\nint main(){\n\tn=read();\n\tREP(i,1,n) a[i]=read();\n\tREP(i,1,n)\n\t\tif(i&1) sumb+=a[i];\n\t\telse sumw+=a[i];\n\tint ans;\n\tif(n%2==0) ans=max(sumw,sumb);\n\telse{\n\t\tint L=0,R=sumb;\n\t\twhile(L<=R){\n\t\t\tint Mid=(L+R)>>1;\n\t\t\tif(check(Mid)) L=Mid+1;\n\t\t\telse R=Mid-1;\n\t\t}\n\t\tans=max(sumw+L-1,sumb);\n\t}\n\tprintf(\"%d %d\\n\",ans,sumw+sumb-ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 300010;\n\nint num[N], sum[N], n;\n\nint main() {\n    scanf(\"%d\", &n); int A = 0, B = 0;\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &num[i]), sum[i] = sum[i - 1];\n        if (i & 1) sum[i] += num[i], A += num[i];\n        else sum[i] -= num[i], B += num[i];\n    }\n    if (n % 2 == 0) {\n        printf(\"%d %d\\n\", max(A, B), min(A, B));\n        return 0;\n    }\n    auto check = [&](int mid) -> bool {\n        int mn = 0; static int dp[N];\n        for (int i = 1; i <= n; i += 2) \n            if (sum[i] - mn >= mid) {\n                mn = min(mn, sum[i + 1]), dp[i] = 1;\n            } else dp[i] = 0;\n        return dp[n];\n    };\n    int l = 1, r = A + B, mid, res = B;\n    while (l <= r) {\n        if (check(mid = (l + r) >> 1)) res = B + mid, l = mid + 1;\n        else r = mid - 1;\n    }\n    printf(\"%d %d\\n\", res, A + B - res);\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define fo(x,a,b) for(int x=(a),e_=(b);x<=e_;x++)\n#define Max(a,b) ((a)>(b)?(a):(b))\n\nconst int N=300005;\nint f[N],a[N],n,B,W,ans;\nbool pd[N];\n\nvoid In(int& a){\n\ta=0;char c=getchar();for(;c<48||c>57;c=getchar());\n\tfor(;c>47&&c<58;c=getchar()) a=(a<<1)+(a<<3)+c-48;\n}\nbool ck(int mid){\n\tint tr=0;\n\tfor(int i=2; i<=n+1; i+=2) {\n\t\tif(f[i-1]-f[tr] >= mid) {\n\t\t\tif(f[i]<f[tr]) tr=i;\n\t\t\tif(i==n+1) return true;\n\t\t} \n\t}return false;\n}\nint main(){\n\tIn(n);\n\tfo(i,1,n) {\n\t\tIn(a[i]);\n\t\tf[i]=f[i-1];\n\t\tif(i&1) B+=a[i], f[i]+=a[i]; else W+=a[i], f[i]-=a[i];\n\t}f[n+1]=f[n];\n\tans=Max(B,W);\n\tif(n%2==0) {printf(\"%d %d\",ans,B+W-ans);return 0;}\n\n\tint l=ans-W+1,r=B+W,mid,k=0;\n\twhile(l<=r) {\n\t\tmid=(l+r)>>1;\n//\t\tprintf(\"mid:%d\\n\",mid);\n\t\tif(ck(mid)) l=mid+1, k=mid; else r=mid-1;\n\t}\n\tans=Max(ans,W+k);\n\tprintf(\"%d %d\",ans,B+W-ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long int N;\n\n\nint checkif(long long int arr[],long long int N,int num){\nfor(int i=0;i<N;i++){\n    if(arr[i]==num){\n        return 1;\n    }\n}\nreturn 0;\n}\n\nint find_adjacent(long long int i,long long int flag[]){\nif(i-1>=0  && flag[i-1]==0){\n    if(flag[i-1]==0){return 1;}\n    else return 0;\n}\n\nelse return 0;\n}\n\nint find_adjacent2(long long int i,long long int flag[]){\nif(i+1<=N && flag[i+1]==0){\n    if(flag[i+1]==0){return 1;}\n    else return 0;\n}\nelse return 0;\n}\n\nlong long int check_for_adjacent(long long int mini_ind_sugim,long long int arr[],long long int flag[]){\nlong long int mini2=0,temp_mini2_ind;\nif(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==1){\nif(arr[mini_ind_sugim-1]>arr[mini_ind_sugim+1]){\n     //   sigma=sigma+arr[mini_ind_sugim-1];\n       // printf(\"%lld\\n\",sigma);\n      //max_ind_sigma=mini_ind_sugim-1;\n//flag[mini_ind_sugim-1]=1;}\nreturn mini_ind_sugim-1;\n}\nelse{\n\n   // sigma=sigma+arr[mini_ind_sugim+1];\n   // printf(\"%lld\\n\",sigma);\n  //  max_ind_sigma=mini_ind_sugim+1;\n  //  flag[mini_ind_sugim+1]=1;\n  return mini_ind_sugim+1;\n}\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==0){\n   // sigma=sigma+arr[mini_ind_sugim-1];\n    //max_ind_sigma=mini_ind_sugim-1;\n    //flag[mini_ind_sugim-1]=1;\n    return mini_ind_sugim-1;\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==0 && find_adjacent2(mini_ind_sugim,flag)==1){\n    //sigma=sigma+arr[mini_ind_sugim+1];\n   // max_ind_sigma=mini_ind_sugim+1;\n    //flag[mini_ind_sugim+1]=1;\n    return mini_ind_sugim+1;\n}\nelse{\n       for(long long int i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                temp_mini2_ind=i;\n            }\n        }\n    }\n    return temp_mini2_ind;\n   // sigma=sigma+mini2;\n   // printf(\"%lld\\n\",sigma);\n    //flag[max_ind_sigma]=1;\n}\n}\n\n\nint main(){\n\nscanf(\"%lld\",&N);\nlong long int arr[N],i,maxs=2000,mini=0,mini_ind_sugim,max_ind_sigma,flag[N],arr2[N],sigma=0,sugim=0,mini2=0,mini2_ind;\nmemset(flag,0,sizeof(flag));\n\nfor(i=0;i<N;i++){\n    scanf(\"%lld\",&arr[i]);\n    arr2[i]=arr[i];\n    if(arr[i]>mini){\n        mini=arr[i];\n        mini_ind_sugim=i;\n    }\n}\n\nsugim=sugim+mini;\nflag[mini_ind_sugim]=1;\n//printf(\"%lld\\n\",sugim);\n\nif(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==1){\nif(arr[mini_ind_sugim-1]>arr[mini_ind_sugim+1]){\n        sigma=sigma+arr[mini_ind_sugim-1];\n    //    printf(\"%lld\\n\",sigma);\nmax_ind_sigma=mini_ind_sugim-1;\nflag[mini_ind_sugim-1]=1;}\nelse{\n\n    sigma=sigma+arr[mini_ind_sugim+1];\n  //  printf(\"%lld\\n\",sigma);\n    max_ind_sigma=mini_ind_sugim+1;\n    flag[mini_ind_sugim+1]=1;\n}\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==0){\n    sigma=sigma+arr[mini_ind_sugim-1];\n    max_ind_sigma=mini_ind_sugim-1;\n    flag[mini_ind_sugim-1]=1;\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==0 && find_adjacent2(mini_ind_sugim,flag)==1){\n    sigma=sigma+arr[mini_ind_sugim+1];\n    max_ind_sigma=mini_ind_sugim+1;\n    flag[mini_ind_sugim+1]=1;\n}\nelse{\n       for(i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                max_ind_sigma=i;\n            }\n        }\n    }\n    sigma=sigma+mini2;\n//    printf(\"%lld\\n\",sigma);\n    flag[max_ind_sigma]=1;\n}\n\n\n\n\nint turn=0;\nwhile(checkif(flag,N,0)==1){\n      // printf(\"yessss\\n\");\n       if(turn==0){\n          //  cout<<max_ind_sigma<<endl;\n       mini_ind_sugim=check_for_adjacent(max_ind_sigma,arr,flag);\n       //cout<<mini_ind_sugim<<endl;\n       sugim=sugim+arr[mini_ind_sugim];\n       flag[mini_ind_sugim]=1;\n       turn=1;\n       }\n       else{\n            //cout<<mini_ind_sugim<<endl;\n            max_ind_sigma=check_for_adjacent(mini_ind_sugim,arr,flag);\n\n            sigma=sigma+arr[max_ind_sigma];\n            flag[max_ind_sigma]=1;\n            turn=0;\n       }\n}\n\n\n\nprintf(\"%lld %lld\\n\",sugim,sigma);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x <<\": \" << (x) << endl\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#ifdef LOCAL\n#define see(x) cout  << #x << \": \" << (x) << endl\n#endif\n#ifndef LOCAL\n#define see(x)\n#endif\n\n\n#define rep(n) for(int _ = 0; _ != (n); ++_)\n//#define rep(i, a, b) for(int i = (a); i <= (b); ++i)\n#define Rng(i, n) for(int i = 0; i != (n); ++i)\n#define rng(i, a, b) for(int i = (a); i < (b); ++i)\n#define rno(i, b) for(int i = 0; i<(b); ++i)\n#define rnc(i, a, b) for(int i = (a); i<=(b); ++i)\n#define RNG(i, a) for(auto &i: (a))\n#define dwn(i, r, l) for(int i = (r); i>=(l); i--)\n\nnamespace std {\n    template<class T>\n    T begin(std::pair<T, T> p)\n    {\n        return p.first;\n    }\n    template<class T>\n    T end(std::pair<T, T> p)\n    {\n        return p.second;\n    }\n}\n\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate<class Range>\nstd::pair<std::reverse_iterator<decltype(begin(std::declval<Range>()))>, std::reverse_iterator<decltype(begin(std::declval<Range>()))>> make_reverse_range(Range &&r)\n{\n    return std::make_pair(make_reverse_iterator(::begin(r)), make_reverse_iterator(::end(r)));\n}\n\n#define RRNG(x, cont) for (auto &x: make_reverse_range(cont))\n\n\n\ntemplate<class T> int sign(const T &a) { return a == 0 ? 0 : a > 0 ? 1 : -1; }\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> void Min(T &a, const T &b){ a = min(a, b); }\ntemplate<class T> void Max(T &a, const T &b){ a = max(a, b); }\n\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\nusing pii = pair<int, int>;\nusing pdd = pair<double, double>;\nusing pip = pair<int, pii>;\nusing szt = size_t;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing pli = pair<ll,int>;\nusing wg = vector<vpii>; //weighted graph\n\nint cas;\nconst double pi = acos(-1);\nll mod = 1e9 + 7;\n\ntemplate<class T>\ninline void add_mod(T &a, const T &b) {\n    a += b;\n    if (a >= mod) a -= mod;\n}\ntemplate<class T>\nvoid sub_mod(T &a, const T &b){\n    a -= b;\n    if (a < 0) a += mod;\n}\nauto bo=[](int x){\n    bitset<5> a(x);\n    cout << a << endl;\n};\n\n//返回值：a中比k小的元素有多少个？\ntemplate<class V, class Cont>\nint get_rank(const V &k, const Cont &a){\n    return std::lower_bound(all(a), k) - a.begin();\n}\n\nmat operator*(const mat &a, const mat &b) {\n    mat c(a.size(), vec(b[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            if (a[i][j]) { // optimization for sparse matrix\n                for (int k = 0; k < b[0].size(); k++) {\n                    add_mod(c[i][k], a[i][j] * b[j][k] % mod);\n                }\n            }\n        }\n    }\n    return c;\n}\n\nvec operator*(const mat &a, const vec &b) {\n    vec c(a.size());\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            add_mod(c[i], a[i][j] * b[j] % mod);\n        }\n    }\n    return c;\n}\n\nmat pow(mat a, ull n) {\n    mat res(a.size(), vec(a[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        res[i][i] = 1;\n    }\n    while (n) {\n        if (n & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\n// Codeforces does not support __int128\n//std::ostream& operator<<(std::ostream& os, __int128 T) {\n//    if (T<0) os<<\"-\";\n//    if (T>=10 ) os<<T/10;\n//    if (T<=-10) os<<(-(T/10));\n//    return os<<( (int) (T%10) >0 ? (int) (T%10) : -(int) (T%10) ) ;\n//}\n//\n//__int128 LPOW(__int128 x, ll n) {\n//    __int128 res = 1;\n//    for (; n; n /= 2, x *= x, x %= mod) {\n//        if (n & 1) {\n//            res *= x;\n//            res %= mod;\n//        }\n//    }\n//    return res;\n//}\n\nll POW(ll x, ll n){\n    ll res = 1;\n    for (; n; n /= 2, x *= x, x %= mod) {\n        if (n & 1) {\n            res *= x;\n            res %= mod;\n        }\n    }\n    return res;\n}\n\n\nll INV(ll x) {\n    return POW(x, mod - 2);\n}\n\nll inv(ll x){\n//    see(x);\n    return x == 1? 1: (mod - mod/x * inv(mod%x) % mod);\n}\n\n\n\n// 2D rotation\nvoid rotate(double &x, double &y, double theta) {\n    double tx = cos(theta) * x - sin(theta) * y;\n    double ty = sin(theta) * x + cos(theta) * y;\n    x = tx, y = ty;\n}\nstruct bit {\n    static const int BIT_N = 1e5 + 5;\n    ll bit[BIT_N];\n    void init(int n){\n        rng(i, 1, n+1) bit[i] = 0;\n    }\n\n    ll sum(int x) {\n        ll res = 0;\n        while (x) {\n            res += bit[x];\n            x -= x & -x;\n        }\n        return res;\n    }\n\n    ll sum(int l, int r) {\n        if (l > r) return 0;\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int x, ll v, int n) {\n        while (x <= n) {\n            bit[x] += v;\n            x += x & -x;\n        }\n    }\n};\n\n\nnamespace util{\n    int len(ll x){return snprintf(nullptr, 0, \"%lld\", x);}\n    vi get_d(ll x){\n        vi res;\n        while(x) {\n            res.pb(x%10);\n            x /= 10;\n        }\n        reverse(all(res));\n        return res;\n    }\n    template <class T> T parity(const T &a){\n        return a & 1;\n    }\n    template <class T>\n    void out (const vector<T> &a){\n        std::copy(a.begin(), a.end(), std::ostream_iterator<T>(std::cout, \", \"));\n        cout << endl;\n    };\n}\n\nusing namespace util;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n\nusing order_statistic_tree = __gnu_pbds::tree<\n        int,\n        __gnu_pbds::null_type,\n        greater<int>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n\n\nconst ll LINF = LLONG_MAX/10;\nconst int INF = INT_MAX/10;\nconst int M = 5005;\n\n\nll dp[M];\n\nint c[M], f[M];\n\nint nn[M], v[M], p[M];\n\nint main() {\n    // Single Cut of Failure taught me\n    cout << std::fixed;\n    cout << setprecision(10);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n\n#ifdef LOCAL\n    freopen(\"main.in\", \"r\", stdin);\n//    freopen(\"main.out\", \"w\", stdout);\n#endif\n\n    int n; scan(n);\n    vi a(n);\n    RNG(x, a) scan(x);\n    int sb = 0;\n    for(int i = 0; i<n; i+=2)\n        sb += a[i];\n    int sw = 0;\n    for(int i=1; i<n; i+=2)\n        sw += a[i];\n\n\n    auto check = [n, sb, sw, &a](int x) {\n        int mi = 0;\n        int sum = 0;\n        rng(i, 0, n) {\n            if (i & 1) {\n                if (sum - mi >= x) {\n                    if (sb - sw - (sum - a[i]) >= x)\n                        return true;\n                    sum -= a[i];\n                    Min(mi, sum);\n                }\n                else sum -= a[i];\n            }\n            else sum += a[i];\n        }\n        return false;\n    };\n\n    int l = sb - sw + 1, r = sb;\n    while(l<=r){\n        int mid = l + (r-l)/2;\n        if(check(mid)){\n            l = mid + 1;\n        }\n        else r = mid - 1;\n    }\n\n    assert(sw + r >= sb);\n    println(sw + r, sb - r);\n\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[300005];\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t}\n\telse{\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tif(c-b >= 1000){\n\t\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t\t\treturn 0;\n\t\t}\n\t\tint lb = 0,ub = 1000;\n\t\twhile(ub-lb>1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tif(c >= b+mid){\n\t\t\t\tlb = mid; continue;\n\t\t\t}\n\t\t\tpriority_queue<P1>que;\n\t\t\tpriority_queue<P,vector<P>,greater<P> >que2;\n\t\t\tint zan = c-b;\n\t\t\tint lazy = 0;\n\t\t\tint cur = 0;\n\t\t\trepn(i,n){\n\t\t\t\tif(i%2 == 1) cur += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(cur>=mid){\n\t\t\t\t\t\tque2.push(mp(cur-a[i],i));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tque.push(mp(cur,mp(cur-a[i],i)));\n\t\t\t\t\t}\n\t\t\t\t\tcur -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint pre = -1;\n\t\t\twhile(1){\n\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t}\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP1 p = que.top();\n\t\t\t\t\tif(p.sc.sc<=pre){\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy >= mid){\n\t\t\t\t\t\tque2.push(p.sc);\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbool ok = 0;\n\t\t\t\twhile(!que2.empty()){\n\t\t\t\t\tP p = que2.top();\n\t\t\t\t\tif(p.sc<=pre){\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi>=0){\n\t\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlazy += p.fi;\n\t\t\t\t\t\tpre = p.sc;\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t\tok = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tub = mid;\n\t\t\tfail:;\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",lb+b,c-lb);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n\nusing namespace std;\n\nint n, a[N], qz[N][2], ans, zh;\n\nint dg(int l, int r){\n\tif ((r-l+1)%2==0) return max(qz[r][0]-qz[l-1][0], qz[r][1]-qz[l-1][1]);\n\tint ans=qz[r][1]; \n\tfor (int i=1; i<=n; i++)\n\t\tif (i%2==0) ans=max(ans, min(qz[i][0]+qz[r][1]-qz[i][1], qz[r][0]-qz[i-1][0]+qz[i-1][1]));\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tqz[i][0]=qz[i-1][0];\n\t\tqz[i][1]=qz[i-1][1];\n\t\tif (i%2) qz[i][1]+=a[i];\n\t\telse qz[i][0]+=a[i];\n\t\tzh+=a[i];\n\t}\n\tans=dg(1, n);\n\tprintf(\"%d %d\", ans, zh-ans);\n} "
  },
  {
    "language": "C++",
    "code": "#ifndef KOMAKI_LOCAL\n#define NDEBUG\n#endif\n\n#include <bits/stdc++.h>\n#include <sys/time.h>\n#include <unistd.h>\nusing namespace std;\n#define i64         int64_t\n#define rep(i, n)   for(i64 i = 0; i < ((i64)(n)); ++i)\n#define sz(v)       ((i64)((v).size()))\n#define bit(n)      (((i64)1)<<((i64)(n)))\n#define all(v)      (v).begin(), (v).end()\n\nstd::string dbgDelim(int &i){ return (i++ == 0 ? \"\" : \", \"); }\n#define dbgEmbrace(exp) { int i = 0; os << \"{\"; { exp; } os << \"}\"; return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp);\ntemplate <int INDEX, class TUPLE> void dbgDeploy(std::ostream &os, TUPLE tuple){}\ntemplate <int INDEX, class TUPLE, class H, class ...Ts> void dbgDeploy(std::ostream &os, TUPLE t)\n{ os << (INDEX == 0 ? \"\" : \", \") << get<INDEX>(t); dbgDeploy<INDEX + 1, TUPLE, Ts...>(os, t); }\ntemplate <class T, class K> void dbgDeploy(std::ostream &os, std::pair<T, K> p, std::string delim)\n{ os << \"(\" << p.first << delim << p.second << \")\"; }\ntemplate <class ...Ts> std::ostream& operator<<(std::ostream &os, std::tuple<Ts...> t)\n{ os << \"(\"; dbgDeploy<0, std::tuple<Ts...>, Ts...>(os, t); os << \")\"; return os; }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p)\n{ dbgDeploy(os, p, \", \"); return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v)\n{ dbgEmbrace( for(T t: v){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> s)\n{ dbgEmbrace( for(T t: s){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q)\n{ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.front(); }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q)\n{ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.top();   }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp)\n{ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp)\n{ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\n#define DBG_OUT std::cerr\n#define DBG_OVERLOAD(_1, _2, _3, _4, _5, _6, macro_name, ...) macro_name\n#define DBG_LINE() { char s[99]; sprintf(s, \"line:%3d | \", __LINE__); DBG_OUT << s; }\n#define DBG_OUTPUT(v) { DBG_OUT << (#v) << \"=\" << (v); }\n#define DBG1(v, ...) { DBG_OUTPUT(v); }\n#define DBG2(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG1(__VA_ARGS__); }\n#define DBG3(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG2(__VA_ARGS__); }\n#define DBG4(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG3(__VA_ARGS__); }\n#define DBG5(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG4(__VA_ARGS__); }\n#define DBG6(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG5(__VA_ARGS__); }\n\n#define DEBUG0() { DBG_LINE(); DBG_OUT << std::endl; }\n#define DEBUG(...)                                                      \\\n  {                                                                     \\\n    DBG_LINE();                                                         \\\n    DBG_OVERLOAD(__VA_ARGS__, DBG6, DBG5, DBG4, DBG3, DBG2, DBG1)(__VA_ARGS__); \\\n    DBG_OUT << std::endl;                                               \\\n  }\n\n\nint main()\n{\n  i64 n;\n  cin >> n;\n  vector<i64> v(n);\n  rep(i, n) cin >> v[i];\n  if(sz(v) % 2 == 0){\n    i64 t[] = {0, 0};\n    rep(i, sz(v)) t[i % 2] += v[i];\n    cout << max(t[0], t[1]) << \" \" << min(t[0], t[1]) << endl;\n    return 0;\n  }\n\n  vector<i64> odd_left(n);\n  vector<i64> odd_right(n);\n  vector<i64> even_left(n);\n  vector<i64> even_right(n);\n  rep(i, n){\n    odd_left[i] = (0 < i ? odd_left[i - 1]: 0) + (i % 2 == 0 ? v[i] : 0);\n    even_left[i] = (0 < i ? even_left[i - 1]: 0) + (i % 2 == 1 ? v[i] : 0);\n  }\n  reverse(all(v));\n  rep(i, n){\n    odd_right[i] = (0 < i ? odd_right[i - 1]: 0) + (i % 2 == 0 ? v[i] : 0);\n    even_right[i] = (0 < i ? even_right[i - 1]: 0) + (i % 2 == 1 ? v[i] : 0);\n  }\n  reverse(all(odd_right));\n  reverse(all(even_right));\n\n  i64 best = odd_left[sz(v) - 1];\n\n  rep(i, n){\n    if(i % 2 == 0) continue;\n    i64 total_0 = even_left[i] + odd_right[i + 1];\n    i64 total_1 = even_right[i] + odd_left[i - 1];\n    best = max(best, min(total_0, total_1));\n  }\n  \n  i64 total = 0;\n  rep(i, n) total += v[i];\n  cout << best << \" \" << total - best << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 300060\nint n,v[N];\nlong long su[N],su1,su2;\nbool check(long long l)\n{\n\tlong long mn=0;\n\tfor(int i=1;i<=n;i+=2)\n\tif(su[i]-mn>=l)\n\t{\n\t\tif(mn>su[i+1])mn=su[i+1];\n\t\tif(i==n)return 1;\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]);\n\tif(~n&1)\n\t{\n\t\tlong long s1=0,s2=0;\n\t\tfor(int i=1;i<=n;i+=2)s1+=v[i],s2+=v[i+1];\n\t\tprintf(\"%lld %lld\\n\",max(s1,s2),min(s1,s2));\n\t}\n\telse\n\t{\n\t\tfor(int i=1;i<=n;i++)su1+=v[i]*(i&1),su[i]=su[i-1]+v[i]*(i&1?1:-1),su2+=v[i]*(~i&1);\n\t\tlong long lb=0,rb=2e10,as=0;\n\t\twhile(lb<=rb)\n\t\t{\n\t\t\tlong long mid=(lb+rb)>>1;\n\t\t\tif(check(mid))as=mid,lb=mid+1;\n\t\t\telse rb=mid-1;\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",su2+as,su1-as);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long int N;\n\n\nint checkif(long long int arr[],long long int N,int num){\nfor(int i=0;i<N;i++){\n    if(arr[i]==num){\n        return 1;\n    }\n}\nreturn 0;\n}\n\nint find_adjacent(int i,long long int flag[]){\nif(i-1>=0  && flag[i-1]==0){\n    if(flag[i-1]==0){return 1;}\n    else return 0;\n}\n\nelse return 0;\n}\n\nint find_adjacent2(int i,long long int flag[]){\nif(i+1<=N && flag[i+1]==0){\n    if(flag[i+1]==0){return 1;}\n    else return 0;\n}\nelse return 0;\n}\n\nlong long int check_for_adjacent(long long int mini_ind_sugim,long long int arr[],long long int flag[]){\nlong long int mini2=0,temp_mini2_ind;\nif(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==1){\nif(arr[mini_ind_sugim-1]>arr[mini_ind_sugim+1]){\n     //   sigma=sigma+arr[mini_ind_sugim-1];\n       // printf(\"%lld\\n\",sigma);\n      //max_ind_sigma=mini_ind_sugim-1;\n//flag[mini_ind_sugim-1]=1;}\nreturn mini_ind_sugim-1;\n}\nelse{\n\n   // sigma=sigma+arr[mini_ind_sugim+1];\n   // printf(\"%lld\\n\",sigma);\n  //  max_ind_sigma=mini_ind_sugim+1;\n  //  flag[mini_ind_sugim+1]=1;\n  return mini_ind_sugim+1;\n}\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==0){\n   // sigma=sigma+arr[mini_ind_sugim-1];\n    //max_ind_sigma=mini_ind_sugim-1;\n    //flag[mini_ind_sugim-1]=1;\n    return mini_ind_sugim-1;\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==0 && find_adjacent2(mini_ind_sugim,flag)==1){\n    //sigma=sigma+arr[mini_ind_sugim+1];\n   // max_ind_sigma=mini_ind_sugim+1;\n    //flag[mini_ind_sugim+1]=1;\n    return mini_ind_sugim+1;\n}\nelse{\n       for(long long int i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                temp_mini2_ind=i;\n            }\n        }\n    }\n    return temp_mini2_ind;\n   // sigma=sigma+mini2;\n   // printf(\"%lld\\n\",sigma);\n    //flag[max_ind_sigma]=1;\n}\n}\n\n\nint main(){\n\nscanf(\"%lld\",&N);\nlong long int arr[N],i,maxs=2000,mini=0,mini_ind_sugim,max_ind_sigma,flag[N],arr2[N],sigma=0,sugim=0,mini2=0,mini2_ind;\nmemset(flag,0,sizeof(flag));\n\nfor(i=0;i<N;i++){\n    scanf(\"%lld\",&arr[i]);\n    arr2[i]=arr[i];\n    if(arr[i]>mini){\n        mini=arr[i];\n        mini_ind_sugim=i;\n    }\n}\n\nsugim=sugim+mini;\nflag[mini_ind_sugim]=1;\n//printf(\"%lld\\n\",sugim);\n\nif(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==1){\nif(arr[mini_ind_sugim-1]>arr[mini_ind_sugim+1]){\n        sigma=sigma+arr[mini_ind_sugim-1];\n    //    printf(\"%lld\\n\",sigma);\nmax_ind_sigma=mini_ind_sugim-1;\nflag[mini_ind_sugim-1]=1;}\nelse{\n\n    sigma=sigma+arr[mini_ind_sugim+1];\n  //  printf(\"%lld\\n\",sigma);\n    max_ind_sigma=mini_ind_sugim+1;\n    flag[mini_ind_sugim+1]=1;\n}\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==0){\n    sigma=sigma+arr[mini_ind_sugim-1];\n    max_ind_sigma=mini_ind_sugim-1;\n    flag[mini_ind_sugim-1]=1;\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==0 && find_adjacent2(mini_ind_sugim,flag)==1){\n    sigma=sigma+arr[mini_ind_sugim+1];\n    max_ind_sigma=mini_ind_sugim+1;\n    flag[mini_ind_sugim+1]=1;\n}\nelse{\n       for(i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                max_ind_sigma=i;\n            }\n        }\n    }\n    sigma=sigma+mini2;\n//    printf(\"%lld\\n\",sigma);\n    flag[max_ind_sigma]=1;\n}\n\n\n\n\nint turn=0;\nwhile(checkif(flag,N,0)==1){\n      // printf(\"yessss\\n\");\n       if(turn==0){\n          //  cout<<max_ind_sigma<<endl;\n       mini_ind_sugim=check_for_adjacent(max_ind_sigma,arr,flag);\n       //cout<<mini_ind_sugim<<endl;\n       sugim=sugim+arr[mini_ind_sugim];\n       flag[mini_ind_sugim]=1;\n       turn=1;\n       }\n       else{\n            //cout<<mini_ind_sugim<<endl;\n            max_ind_sigma=check_for_adjacent(mini_ind_sugim,arr,flag);\n\n            sigma=sigma+arr[max_ind_sigma];\n            flag[max_ind_sigma]=1;\n            turn=0;\n       }\n}\n\n\n\nprintf(\"%lld %lld\\n\",sugim,sigma);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nint n,a[301000],S1,S2;\nbool check(int lim){\n\tint now=0,lst=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i&1){\n\t\t\tif(now>=lim&&now+lst<=0) now=lst=0;\n\t\t\tnow+=lst+a[i];\n\t\t}\n\t\telse lst=-a[i];\n\t}\n\treturn now>=lim;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++){\n\t\tread(a[i]);\n\t\tif(i&1) S1+=a[i];\n\t\telse S2+=a[i];\n\t}\n\tif(~n&1){cout<<max(S1,S2)<<' '<<min(S1,S2)<<'\\n';return 0;}\n\tint l=0,r=S1+1;\n\twhile(l+1<r){\n\t\tint mid=l+r>>1;\n\t\tif(check(mid)) l=mid;\n\t\telse r=mid;\n\t}\n\tcout<<S2+l<<' '<<S1-l<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n\nusing namespace std;\n\nint n, a[N], qz[N][2], ans, zh;\n\nint dg(int l, int r){\n\tif ((r-l+1)%2==0) return max(qz[r][0]-qz[l-1][0], qz[r][1]-qz[l-1][1]);\n\tint ans=qz[r][1]; \n\tfor (int i=1; i<=n; i++)\n\t\tif (i%2==0) ans=max(ans, min(qz[i][0]+qz[r][1]-qz[i][1], qz[r][0]-qz[i-1][0]+qz[i-1][1]));\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tqz[i][0]=qz[i-1][0];\n\t\tqz[i][1]=qz[i-1][1];\n\t\tif (i%2) qz[i][1]+=a[i];\n\t\telse qz[i][0]+=a[i];\n\t\tzh+=a[i];\n\t}\n\tans=dg(1, n);\n\tprintf(\"%d %d\", ans, zh-ans);\n  \n  \treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#define lowbit(x) ((x)&-(x))\nusing std::vector;\ntypedef long long ll;\nconst int N=3e5+5,M=3e6+5;\nconst ll inf=1ll<<40;\nll a[N],s[N],f[N],g[N],b[N];int n,m,rk[N];\ntemplate<class T>T abs(T x){return x<0?-x:x;}\ntemplate<class T>bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>T min(T a,T b){return a<b?a:b;}\ntemplate<class T>T div2(T x){return (x-(x&1))/2;}\ninline void init(){\n\tstd::reverse(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)s[i]=s[i-1]+((i&1)?-a[i]:a[i]);\n}\nstruct node{\n\tnode*c[2];\n\tint size;\n\tll v1,v2,key,x1,x2;\n\tnode();\n\tvoid pushup();\n}Tnull,*null=&Tnull,pl[M],*rt[N];int pp;\nnode::node(){\n\tc[0]=c[1]=null;\n\tv1=v2=x1=x2=key=size=0;\n}\nvoid node::pushup(){\n\tsize=c[0]->size+c[1]->size+1;\n\tx1=v1,x2=v2;\n\tif(c[0]!=null)chkmax(x1,c[0]->x1),chkmax(x2,c[0]->x2); \n\tif(c[1]!=null)chkmax(x1,c[1]->x1),chkmax(x2,c[1]->x2);\n}\nvoid rot(node*&x,bool f){\n\tnode*y=x->c[f];\n\tx->c[f]=y->c[f^1],y->c[f]=x;\n\tx->pushup(),x=y,x->pushup(); \n}\nvoid insert(node*&x,node*y){\n\tif(x==null){\n\t\tx=y,x->c[0]=x->c[1]=null,x->pushup();\n\t\treturn;\n\t}\n\tbool f=x->key<y->key;\n\tinsert(x->c[f],y);\n\tif(x->c[f]->size>(x->size+1)*0.75)rot(x,f);else x->pushup();\n}\nll ask(node*x,ll cut){\n\t//for <=cut, v1-cut\n\t//for >cut, v2+cut\n\tif(x==null)return -inf;\n\tll res=-inf;\n\tif(x->key<=cut){\n\t\tchkmax(res,x->v1-cut);\n\t\tif(x->c[0]!=null)chkmax(res,x->c[0]->x1-cut);\n\t\tchkmax(res,ask(x->c[1],cut));\n\t}else{\n\t\tchkmax(res,x->v2+cut);\n\t\tif(x->c[1]!=null)chkmax(res,x->c[1]->x2+cut);\n\t\tchkmax(res,ask(x->c[0],cut));\n\t}\n\treturn res;\n}\ninline void calc(ll*f){\n\tint i,x;\n\tfor(m=0,i=1;i<=n;i++)b[++m]=s[i];\n\tstd::sort(b+1,b+m+1),m=std::unique(b+1,b+m+1)-b-1;\n\tfor(i=1;i<=n;i++)rk[i]=m-(std::lower_bound(b+1,b+m+1,s[i])-b)+1;\n\tpp=0;\n\tfor(i=1;i<=m;i++)rt[i]=null;\n\tfor(i=1;i<=n;i+=2){\n\t\tf[i]=abs(s[i]);\n\t\tfor(x=rk[i]-1;x;x-=lowbit(x))chkmax(f[i],ask(rt[x],s[i]));\n\t\tif(i<n){\n\t\t\tfor(x=rk[i+1];x<=m;x+=lowbit(x)){\n\t\t\t\tnode*z=pl+(pp++);\n\t\t\t\tz->key=div2(2*s[i+1]+s[i]-f[i]);\n\t\t\t\tz->v1=2*s[i+1],z->v2=f[i]-s[i];\n\t\t\t\tinsert(rt[x],z);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tll dif=0,sum=0;\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",a+i),dif+=(i&1)?a[i]:-a[i],sum+=a[i];\n\tdif=abs(dif);\n\tif(n&1){\n\t\tstd::reverse(a+1,a+n+1);\n\t\tinit(),calc(f),init(),calc(g),init();\n\t\tstd::reverse(g+1,g+n+1);\n\t\tfor(i=2;i<n;i+=2)chkmax(dif,a[i]+min(s[i-1]+g[i+1],f[i-1]+s[n]-s[i]));\n\t}\n\tll sigma=(sum-dif)>>1,sugim=sigma+dif;\n\tprintf(\"%lld %lld\\n\",sugim,sigma);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  cin >> a;\n  if (~n & 1) {\n    int s0 = 0, s1 = 0;\n    for (int i = 0; i < n; i += 2) {\n      s0 += a[i];\n      s1 += a[i + 1];\n    }\n    cout << max(s0, s1) << ' ' << min(s0, s1);\n  } else {\n    int s0 = a[0], s1 = 0;\n    for (int i = 1; i < n; i += 2) {\n      s1 += a[i];\n      s0 += a[i + 1];\n    }\n    function<bool(int)> pred = [&](int x) {\n      x -= s1;\n      vector<int> pre(n);\n      pre[0] = a[0];\n      for (int i = 1; i < n; ++i) {\n        if (i & 1)\n          pre[i] = pre[i - 1] - a[i];\n        else\n          pre[i] = pre[i - 1] + a[i];\n      }\n      int minimal = 0;\n      for (int i = 1; i < n; i += 2)\n        if (pre[i - 1] - minimal >= x)\n          minimal = min(minimal, pre[i]);\n      return pre[n - 1] - minimal >= x;\n    };\n    int l = s0, r = s0 + s1;\n    while (l < r) {\n      int mid = (l + r + 1) >> 1;\n      if (pred(mid))\n        l = mid;\n      else\n        r = mid - 1;\n    }\n    cout << l << ' ' << s0 + s1 - l;\n  }\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\nint N;\nint A[333333];\n\nint S[333333],dp[333333];\n\nbool check(int x){\n    S[1]=A[0];\n    for(int i=1;i<N/2+1;i++){\n        S[i+1]=S[i]+A[i*2]-A[i*2-1];\n    }\n\n    //S[i+1]-S[j+1]+A[j*2+1]>=x\n\n    memset(dp,0,sizeof(dp));\n\n    dp[0]=1;\n    int uku=0;\n    rep(i,N/2+1){\n        if(S[i+1]>=x+uku){\n            dp[i+1]=1;\n            chmin(uku,S[i+1]-A[i*2+1]);\n        }\n    }\n    return dp[N/2+1];\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>A[i];\n\n    int sum[2]={};\n    rep(i,N)sum[i&1]+=A[i];\n\n\n    if(N%2==0){\n        cout<<*max_element(sum,sum+2)<<\" \"<<*min_element(sum,sum+2)<<endl;\n    }\n    else{\n        int lb=0,ub=1001001001;\n        while(ub-lb>1){\n            int mid=(ub+lb)/2;\n            if(check(mid-sum[1]))lb=mid;\n            else ub=mid;\n        }\n        cout<<lb<<\" \"<<sum[0]+sum[1]-lb<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=3e5+5;\n\nint n,a[N],p[N];\n\nbool check(int x) {\n\tint tmp=0;\n\tfor(int i=2;i<n;i+=2) if (p[i-1]-tmp>=x) tmp=min(tmp,p[i]);\n\treturn p[n]-tmp>=x;\n}\n\nint main() {\n\tn=read();\n\tfo(i,1,n) a[i]=read();\n\tif (!(n&1)) {\n\t\tstatic int c[2];\n\t\tfo(i,1,n) c[i&1]+=a[i];\n\t\tprintf(\"%d %d\\n\",max(c[0],c[1]),min(c[0],c[1]));\n\t\treturn 0;\n\t}\n\tint b=0,s=0;\n\tfo(i,1,n) {\n\t\tif (!(i&1)) b+=a[i];\n\t\ts+=a[i];\n\t}\n\tfo(i,1,n) p[i]=((i&1)?1:-1)*a[i]+p[i-1];\n\tint l=b,r=s,p=b;\n\twhile (l<=r) {\n\t\tint mid=l+r>>1;\n\t\tif (check(mid-b)) p=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tprintf(\"%d %d\\n\",p,s-p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x <<\": \" << (x) << endl\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#ifdef LOCAL\n#define see(x) cout  << #x << \": \" << (x) << endl\n#endif\n#ifndef LOCAL\n#define see(x)\n#endif\n\n\n#define rep(n) for(int _ = 0; _ != (n); ++_)\n//#define rep(i, a, b) for(int i = (a); i <= (b); ++i)\n#define Rng(i, n) for(int i = 0; i != (n); ++i)\n#define rng(i, a, b) for(int i = (a); i < (b); ++i)\n#define rno(i, b) for(int i = 0; i<(b); ++i)\n#define rnc(i, a, b) for(int i = (a); i<=(b); ++i)\n#define RNG(i, a) for(auto &i: (a))\n#define dwn(i, r, l) for(int i = (r); i>=(l); i--)\n\nnamespace std {\n    template<class T>\n    T begin(std::pair<T, T> p)\n    {\n        return p.first;\n    }\n    template<class T>\n    T end(std::pair<T, T> p)\n    {\n        return p.second;\n    }\n}\n\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate<class Range>\nstd::pair<std::reverse_iterator<decltype(begin(std::declval<Range>()))>, std::reverse_iterator<decltype(begin(std::declval<Range>()))>> make_reverse_range(Range &&r)\n{\n    return std::make_pair(make_reverse_iterator(::begin(r)), make_reverse_iterator(::end(r)));\n}\n\n#define RRNG(x, cont) for (auto &x: make_reverse_range(cont))\n\n\n\ntemplate<class T> int sign(const T &a) { return a == 0 ? 0 : a > 0 ? 1 : -1; }\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> void Min(T &a, const T &b){ a = min(a, b); }\ntemplate<class T> void Max(T &a, const T &b){ a = max(a, b); }\n\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\nusing pii = pair<int, int>;\nusing pdd = pair<double, double>;\nusing pip = pair<int, pii>;\nusing szt = size_t;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing pli = pair<ll,int>;\nusing wg = vector<vpii>; //weighted graph\n\nint cas;\nconst double pi = acos(-1);\nll mod = 1e9 + 7;\n\ntemplate<class T>\ninline void add_mod(T &a, const T &b) {\n    a += b;\n    if (a >= mod) a -= mod;\n}\ntemplate<class T>\nvoid sub_mod(T &a, const T &b){\n    a -= b;\n    if (a < 0) a += mod;\n}\nauto bo=[](int x){\n    bitset<5> a(x);\n    cout << a << endl;\n};\n\n//返回值：a中比k小的元素有多少个？\ntemplate<class V, class Cont>\nint get_rank(const V &k, const Cont &a){\n    return std::lower_bound(all(a), k) - a.begin();\n}\n\nmat operator*(const mat &a, const mat &b) {\n    mat c(a.size(), vec(b[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            if (a[i][j]) { // optimization for sparse matrix\n                for (int k = 0; k < b[0].size(); k++) {\n                    add_mod(c[i][k], a[i][j] * b[j][k] % mod);\n                }\n            }\n        }\n    }\n    return c;\n}\n\nvec operator*(const mat &a, const vec &b) {\n    vec c(a.size());\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            add_mod(c[i], a[i][j] * b[j] % mod);\n        }\n    }\n    return c;\n}\n\nmat pow(mat a, ull n) {\n    mat res(a.size(), vec(a[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        res[i][i] = 1;\n    }\n    while (n) {\n        if (n & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\n// Codeforces does not support __int128\n//std::ostream& operator<<(std::ostream& os, __int128 T) {\n//    if (T<0) os<<\"-\";\n//    if (T>=10 ) os<<T/10;\n//    if (T<=-10) os<<(-(T/10));\n//    return os<<( (int) (T%10) >0 ? (int) (T%10) : -(int) (T%10) ) ;\n//}\n//\n//__int128 LPOW(__int128 x, ll n) {\n//    __int128 res = 1;\n//    for (; n; n /= 2, x *= x, x %= mod) {\n//        if (n & 1) {\n//            res *= x;\n//            res %= mod;\n//        }\n//    }\n//    return res;\n//}\n\nll POW(ll x, ll n){\n    ll res = 1;\n    for (; n; n /= 2, x *= x, x %= mod) {\n        if (n & 1) {\n            res *= x;\n            res %= mod;\n        }\n    }\n    return res;\n}\n\n\nll INV(ll x) {\n    return POW(x, mod - 2);\n}\n\nll inv(ll x){\n//    see(x);\n    return x == 1? 1: (mod - mod/x * inv(mod%x) % mod);\n}\n\n\n\n// 2D rotation\nvoid rotate(double &x, double &y, double theta) {\n    double tx = cos(theta) * x - sin(theta) * y;\n    double ty = sin(theta) * x + cos(theta) * y;\n    x = tx, y = ty;\n}\nstruct bit {\n    static const int BIT_N = 1e5 + 5;\n    ll bit[BIT_N];\n    void init(int n){\n        rng(i, 1, n+1) bit[i] = 0;\n    }\n\n    ll sum(int x) {\n        ll res = 0;\n        while (x) {\n            res += bit[x];\n            x -= x & -x;\n        }\n        return res;\n    }\n\n    ll sum(int l, int r) {\n        if (l > r) return 0;\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int x, ll v, int n) {\n        while (x <= n) {\n            bit[x] += v;\n            x += x & -x;\n        }\n    }\n};\n\n\nnamespace util{\n    int len(ll x){return snprintf(nullptr, 0, \"%lld\", x);}\n    vi get_d(ll x){\n        vi res;\n        while(x) {\n            res.pb(x%10);\n            x /= 10;\n        }\n        reverse(all(res));\n        return res;\n    }\n    template <class T> T parity(const T &a){\n        return a & 1;\n    }\n    template <class T>\n    void out (const vector<T> &a){\n        std::copy(a.begin(), a.end(), std::ostream_iterator<T>(std::cout, \", \"));\n        cout << endl;\n    };\n}\n\nusing namespace util;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n\nusing order_statistic_tree = __gnu_pbds::tree<\n        int,\n        __gnu_pbds::null_type,\n        greater<int>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n\n\nconst ll LINF = LLONG_MAX/10;\nconst int INF = INT_MAX/10;\nconst int M = 5005;\n\n\nll dp[M];\n\nint c[M], f[M];\n\nint nn[M], v[M], p[M];\n\nint main() {\n    // Single Cut of Failure taught me\n    cout << std::fixed;\n    cout << setprecision(10);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n\n#ifdef LOCAL\n    freopen(\"main.in\", \"r\", stdin);\n//    freopen(\"main.out\", \"w\", stdout);\n#endif\n\n    int n; scan(n);\n    vi a(n);\n    RNG(x, a) scan(x);\n    int sb = 0;\n    for(int i = 0; i<n; i+=2)\n        sb += a[i];\n    int sw = 0;\n    for(int i=1; i<n; i+=2)\n        sw += a[i];\n\n\n    auto check = [n, sb, sw, &a](int x) {\n        int mi = INT_MAX;\n        int sum = 0;\n        rng(i, 0, n) {\n            if (i & 1) {\n                if (sum >= x || sum - x  >= mi) {\n                    if (sb - sw - (sum - a[i]) >= x)\n                        return true;\n                    sum -= a[i];\n                    Min(mi, sum);\n                }\n                else sum -= a[i];\n            }\n            else sum += a[i];\n        }\n        return false;\n    };\n\n    int l = sb - sw + 1, r = sb;\n    while(l<=r){\n        int mid = l + (r-l)/2;\n        if(check(mid)){\n            l = mid + 1;\n        }\n        else r = mid - 1;\n    }\n\n    assert(sw + r >= sb);\n    println(sw + r, sb - r);\n\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[300005];\nint n;\nbool b[300005];\nint ans[2];\nint findmax(){\n\tint maxn=-0x3f3f3f3f;\n\tint k;\n\tfor(int i=1;i<=n;i++){\n\t\tif(b[i])\n\t\t\tcontinue;\n\t\tif(maxn<a[i]){\n\t\t\tmaxn=a[i];\n\t\t\tk=i;\n\t\t}\n\t}\n\treturn k;\n}\nint main(){\n\tcin>>n;\n\tb[0]=b[n+1]=true;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\tint last=0;\n\tint x=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(last){\n\t\t\tif(b[last-1]&&b[last+1]){\n\t\t\t\tlast=findmax();\n\t\t\t\tans[x]+=a[last];\n\t\t\t\tb[last]=true;\n\t\t\t\tx=(x+1)%2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(b[last-1]){\n\t\t\t\t\tlast++;\n\t\t\t\t\tans[x]+=a[last];\n\t\t\t\t\tb[last]=true;\n\t\t\t\t\tx=(x+1)%2;\n\t\t\t\t}\n\t\t\t\telse if(b[last+1]){\n\t\t\t\t\tlast--;\n\t\t\t\t\tans[x]+=a[last];\n\t\t\t\t\tb[last]=true;\n\t\t\t\t\tx=(x+1)%2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(a[last-1]>a[last+1]){\n\t\t\t\t\t\tlast--;\n\t\t\t\t\t\tans[x]+=a[last];\n\t\t\t\t\t\tb[last]=true;\n\t\t\t\t\t\tx=(x+1)%2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlast++;\n\t\t\t\t\t\tans[x]+=a[last];\n\t\t\t\t\t\tb[last]=true;\n\t\t\t\t\t\tx=(x+1)%2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlast=findmax();\n\t\t\tans[x]+=a[last];\n\t\t\tb[last]=true;\n\t\t\tx=(x+1)%2;\n\t\t}\n\t}\n\tcout<<ans[0]<<\" \"<<ans[1]<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nint p[310000];\nint q[310000];\nint A,B;\n\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);\n\tfor(int i=0;i<a;i++){\n\t\tif(i%2==0)A+=p[i];\n\t\telse B+=p[i];\n\t}\n\tif(a%2==0){\n\t\tprintf(\"%d %d\\n\",max(A,B),min(A,B));\n\t\treturn 0;\n\t}\n\tint left=0;\n\tint right=310000000;\n\twhile(left+1<right){\n\t\tint M=(left+right)/2;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tq[i]=p[i];\n\t\t\tif(i%2)q[i]=-q[i];\n\t\t}\n\t\tfor(int i=1;i<a;i+=2){\n\t\t\tif(q[i]+q[i-1]<0&&q[i-1]>=M){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tq[i+1]+=q[i]+q[i-1];\n\t\t\t}\n\t\t}\n\t\tif(q[a-1]>=M){\n\t\t\tleft=M;\n\t\t}else right=M;\n\t}\n\tprintf(\"%d %d\\n\",left+B,A-left);\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-01-27 15:38:58\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\nconst int N=300010;\nint n,a[N],s[N],ans,Ans;\nint check(int p)\n{\n\tint lst=0;\n\tfr(i,1,n-1) if((i&1)&&s[i+1]>lst&&s[n]-2*(s[i]-lst)>=p) lst=s[i+1];\n//\tprintf(\"%d %d\\n\",p,s[n]-2*(s[n]-lst)>=p);\n\treturn s[n]-2*(s[n]-lst)>=p;\n}\nint main()\n{\n\tn=read();\n\tfr(i,1,n)\n\t{\n\t\ta[i]=read();\n\t\tif(i&1) s[i]=s[i-1]-a[i];\n\t\telse s[i]=s[i-1]+a[i];\n\t\tAns+=a[i];\n//\t\tprintf(\"%d%c\",s[i],i==n?'\\n':' ');\n\t}\n\tans=abs(s[n]);\n\tif(n&1)\n\t{\n\t\tint l=-1000000000,r=1000000000;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(check(mid)){ l=mid+1; ans=std::max(ans,mid); }\n\t\t\telse r=mid;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",(Ans+ans)/2,(Ans-ans)/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline LL read(){\n\tLL x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst LL MAXN = 100010;\nconst LL INF = 2147483600;\n\nLL N; LL a[MAXN+1];\nLL s[2];\n\ninline bool check(LL T){\n\tLL mxp=0; bool fg=0;\n\tfor(LL i=1;i<=N;i++){\n\t\tif((i&1)&&fg) mxp=max(mxp,0LL),fg=0;\n\t\tmxp+=((i&1)?1:-1)*a[i];\n\t\tif((i&1)&&mxp>=T) fg=1;\n\t} return fg;\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tfor(LL i=1;i<=N;i++) a[i]=read(),s[i&1]+=a[i];\n\tif(!(N&1)){ printf(\"%lld %lld\\n\",max(s[0],s[1]),min(s[0],s[1])); return 0; }\n\tLL ad=0,l=1,r=s[0]+s[1];\n\twhile(l<=r){\n\t\tLL mid=(l+r)>>1;\n\t\tif(check(mid)) ad=mid,l=mid+1;\n\t\telse r=mid-1;\n\t} printf(\"%lld %lld\\n\",ad+s[0],s[1]-ad);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e6 + 1000;\nint a[N],sum[N],s[2];\nint check(int x)\n{\n\tint k = 0;\n\tfor(int i = 2;i <= n;i += 2)\n\t\tif(sum[i - 1] - k >= x) k = min(sum[i],k); \n\treturn sum[n] - k >= x;\n}\nint main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++) s[i & 1] += a[i] = read();\n\tif(n & 1 == 0) {cout << max(s[0],s[1]) << \" \" << min(s[0],s[1]); return 0;}\n\telse\n\t{\n\t\tfor(int i = 1;i <= n;i ++) sum[i] = sum[i - 1] + (i & 1 ? a[i] : -a[i]);\n\t\tint l = 0,r = s[0] + s[1],mid,ans;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(check(mid)) {ans = mid; l = mid + 1;}\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tcout << s[0] + ans << \" \" << s[1] - ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst int N = 3e5 + 5;\nint n, a[N], s[N];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nint check(int mid)\n{\n\tint res = 0;\n\tfor(int i = 1; i <= n; i ++) if(s[i] - res >= mid) res = min(res, s[i + 1]);\n\treturn s[n] - res >= mid;\n}\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read();\n\tfor(int i = 1; i <= n; i ++) a[i] = read();\n\tif(n % 2 == 0)\n\t{\n\t\tint sum1 = 0, sum2 = 0;\n\t\tfor(int i = 1; i <= n; i ++) if(i & 1) sum1 += a[i]; else sum2 += a[i];\n\t\tprintf(\"%d %d\\n\", max(sum1, sum2), min(sum1, sum2));\n\t}\n\telse\n\t{\n\t\tint sum = 0;\n\t\tfor(int i = 1; i <= n; i ++)\n\t\t{\n\t\t\tif(i & 1) s[i] = s[i - 1] + a[i];\n\t\t\telse s[i] = s[i - 1] - a[i];\n\t\t\tsum += a[i];\n\t\t}\n\t\tint l = 0, r = n * 1000, ans = 0;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif(check(mid)) ans = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tfor(int i = 1; i <= n; i ++) if(i % 2 == 0) ans += a[i];//\n\t\tprintf(\"%d %d\\n\", ans, sum - ans);\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=3e5+20;\n\nint n,a[maxn],sum;\n\ninline void init()\n{\n\tn=read();\n\tREP(i,1,n)a[i]=read(),sum+=a[i];\n}\n\nint x[maxn],y[maxn];\n\ninline bool check(int ck)\n{\n\tint mx=0;\n\tREP(i,1,n>>1)\n\t{\n\t\tif(x[i]+mx>=ck)chkmax(mx,-y[i]);\n\t}\n\tif(x[n+1>>1]+mx>=ck)return 1;\n\telse return 0;\n}\n\ninline void doing()\n{\n\tif(~n&1)\n\t{\n\t\tint B=0,W=0;\n\t\tREP(i,1,n)if(i&1)B+=a[i];else W+=a[i];\n\t\tif(B<W)swap(B,W);\n\t\tprintf(\"%d %d\\n\",B,W);\n\t}else\n\t{\n\t\tint W=0;\n\t\tREP(i,1,n)if(~i&1)W+=a[i];\n\t\tREP(i,1,n+1>>1)x[i]=x[i-1]+a[i*2-1]-a[i*2-2],y[i]=y[i-1]+a[i*2-1]-a[i*2];\n\t\tint l=0,r=sum;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=l+r+1>>1;\n\t\t\tif(check(mid))l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",W+l,sum-W-l);\n\t}\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long int N;\n\n\nint checkif(long long int arr[],long long int N,int num){\nfor(int i=0;i<N;i++){\n    if(arr[i]==num){\n        return 1;\n    }\n}\nreturn 0;\n}\n\nint find_adjacent(long long int i,long long int flag[]){\nif(i-1>=0  && flag[i-1]==0){\n    if(flag[i-1]==0){return 1;}\n    else return 0;\n}\n\nelse return 0;\n}\n\nint find_adjacent2(long long int i,long long int flag[]){\nif(i+1<=N && flag[i+1]==0){\n    if(flag[i+1]==0){return 1;}\n    else return 0;\n}\nelse return 0;\n}\n\nlong long int check_for_adjacent(long long int mini_ind_sugim,long long int arr[],long long int flag[]){\nlong long int mini2=0,temp_mini2_ind;\nif(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==1){\nif(arr[mini_ind_sugim-1]>arr[mini_ind_sugim+1]){\n     //   sigma=sigma+arr[mini_ind_sugim-1];\n       // printf(\"%lld\\n\",sigma);\n      //max_ind_sigma=mini_ind_sugim-1;\n//flag[mini_ind_sugim-1]=1;}\nreturn mini_ind_sugim-1;\n}\nelse{\n\n   // sigma=sigma+arr[mini_ind_sugim+1];\n   // printf(\"%lld\\n\",sigma);\n  //  max_ind_sigma=mini_ind_sugim+1;\n  //  flag[mini_ind_sugim+1]=1;\n  return mini_ind_sugim+1;\n}\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==0){\n   // sigma=sigma+arr[mini_ind_sugim-1];\n    //max_ind_sigma=mini_ind_sugim-1;\n    //flag[mini_ind_sugim-1]=1;\n    return mini_ind_sugim-1;\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==0 && find_adjacent2(mini_ind_sugim,flag)==1){\n    //sigma=sigma+arr[mini_ind_sugim+1];\n   // max_ind_sigma=mini_ind_sugim+1;\n    //flag[mini_ind_sugim+1]=1;\n    return mini_ind_sugim+1;\n}\nelse{\n       for(long long int i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                temp_mini2_ind=i;\n            }\n        }\n    }\n    return temp_mini2_ind;\n   // sigma=sigma+mini2;\n   // printf(\"%lld\\n\",sigma);\n    //flag[max_ind_sigma]=1;\n}\n}\n\n\nint main(){\n\nscanf(\"%lld\",&N);\nlong long int arr[N],i,maxs=2000,mini=0,mini_ind_sugim,max_ind_sigma,flag[N],arr2[N],sigma=0,sugim=0,mini2=0,mini2_ind;\nmemset(flag,0,sizeof(flag));\n\nfor(i=0;i<N;i++){\n    scanf(\"%lld\",&arr[i]);\n    arr2[i]=arr[i];\n    if(arr[i]>mini){\n        mini=arr[i];\n        mini_ind_sugim=i;\n    }\n}\n\nsugim=sugim+mini;\nflag[mini_ind_sugim]=1;\n//printf(\"%lld\\n\",sugim);\n\nif(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==1){\nif(arr[mini_ind_sugim-1]>arr[mini_ind_sugim+1]){\n        sigma=sigma+arr[mini_ind_sugim-1];\n    //    printf(\"%lld\\n\",sigma);\nmax_ind_sigma=mini_ind_sugim-1;\nflag[mini_ind_sugim-1]=1;}\nelse{\n\n    sigma=sigma+arr[mini_ind_sugim+1];\n  //  printf(\"%lld\\n\",sigma);\n    max_ind_sigma=mini_ind_sugim+1;\n    flag[mini_ind_sugim+1]=1;\n}\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==0){\n    sigma=sigma+arr[mini_ind_sugim-1];\n    max_ind_sigma=mini_ind_sugim-1;\n    flag[mini_ind_sugim-1]=1;\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==0 && find_adjacent2(mini_ind_sugim,flag)==1){\n    sigma=sigma+arr[mini_ind_sugim+1];\n    max_ind_sigma=mini_ind_sugim+1;\n    flag[mini_ind_sugim+1]=1;\n}\nelse{\n       for(i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                max_ind_sigma=i;\n            }\n        }\n    }\n    sigma=sigma+mini2;\n//    printf(\"%lld\\n\",sigma);\n    flag[max_ind_sigma]=1;\n}\n\n\n\n\nint turn=0;\nwhile(checkif(flag,N,0)==1){\n      // printf(\"yessss\\n\");\n       if(turn==0){\n          //  cout<<max_ind_sigma<<endl;\n       mini_ind_sugim=check_for_adjacent(max_ind_sigma,arr,flag);\n       //cout<<mini_ind_sugim<<endl;\n       sugim=sugim+arr[mini_ind_sugim];\n       flag[mini_ind_sugim]=1;\n       turn=1;\n       }\n       else{\n            //cout<<mini_ind_sugim<<endl;\n            max_ind_sigma=check_for_adjacent(mini_ind_sugim,arr,flag);\n\n            sigma=sigma+arr[max_ind_sigma];\n            flag[max_ind_sigma]=1;\n            turn=0;\n       }\n}\n\ncout<<endl;\n\nprintf(\"%lld %lld\",sugim,sigma);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300005;\n\nint n;\nint a[N];\nlong long sum[2][N];\n\nlong long cal(int l, int r) {\n\tlong long ret = max(sum[0][r] - sum[0][l - 1], sum[1][r] - sum[1][l - 1]);\n\tif ((r - l + 1) % 2 == 0) return ret;\n\tfor (int i = l + 1; i < r; i += 2) {\n\t\tret = max(ret, min(cal(l, i - 1), cal(i + 1, r)) + a[i]);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tlong long all = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i], all += a[i];\n\t\tsum[0][i] = sum[0][i - 1] + (i % 2 == 0) * a[i];\n\t\tsum[1][i] = sum[1][i - 1] + (i % 2 == 1) * a[i]; \n\t}\n\tlong long res = cal(1, n);\n\tcout << res << ' ' << all - res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N;\nvector<long long> a;\n\nint main() {\n    cin >> N;\n    long long black = 0, white = 0;\n    a.resize(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> a[i];\n        if (i % 2 == 0) black += a[i];\n        else white += a[i];\n    }\n    if (N % 2 == 0) cout << max(black, white) << \" \" << min(black, white) << endl;\n    else {\n        long long low = 0, high = 1<<30;\n        while (high - low > 1) {\n            long long mid = (low + high) / 2;\n\t\t\tvector<long long> dp; dp.assign(N + 1, -(1LL << 60));\n\t\t\tdp[1] = a[0];\n\t\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\t\t// 直前をカットする場合\n\t\t\t\tif (dp[i - 2] >= mid) dp[i] = max(dp[i], a[i - 1]);\n\t\t\t\t\n\t\t\t\t// 直前をカットしない場合\n\t\t\t\tdp[i] = max(dp[i], dp[i - 2] - a[i - 2] + a[i - 1]);\n\t\t\t}\n\n\t\t\t//cout << \"----------------\" << endl << \"mid = \" << mid << endl;\n\t\t\t//for (int i = 1; i <= N; ++i) cout << i << \": \" << dp[i] << endl;\n\n\t\t\tif (dp[N] >= mid) low = mid;\n\t\t\telse high = mid;\n        }\n        cout << white + low << \" \" << black - low << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n\nconst int maxn = 3e5 + 10;\ntypedef long long LL;\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x * 10) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nint n, a[maxn];\nLL s[maxn];\n\nint ck(LL x)\n{\n\tint now = 0;\n\tif(s[n] - s[now] >= x) return 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif((i & 1) == 0 && s[i - 1] - s[now] >= x)\n\t\t{\n\t\t\tif(s[i] < s[now]) now = i;\n\t\t\tif(s[n] - s[i] >= x) return 1;\n\t\t}\n\treturn 0;\n}\n\nint main()\n{\n\n\tn = read();\n\tLL sumb = 0, sumw = 0;\n\tfor(int i = 1; i <= n; ++i) a[i] = read(), sumb += (i & 1 ? a[i] : 0), sumw += (i & 1 ? 0 : a[i]);\n\n\tif(!(n & 1)) return cout << max(sumb, sumw) << ' ' << min(sumb, sumw) << endl, 0;\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\ts[i] += (i & 1 ? a[i] : 0);\n\t\ts[i] += (i & 1 ? 0 : -a[i]);\n\t\ts[i] += s[i - 1];\n\t}\n\n\tLL l = 0, r = sumb, ans = -LLONG_MAX;\n\twhile(l <= r)\n\t{\n\t\tint mid = (l + r) >> 1;\n\t\tif(ck(mid)) l = mid + 1, ans = mid;\n\t\telse r = mid - 1;\n\t}\n\n\tcout << sumw + ans << ' ' << sumb - ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nconst int nax=1000*1007;\n\nint n;\nll tab[nax];\n\nll s;\n\nll pre[nax];\nll suf[nax];\n\nll dp[nax];\n\nvoid wypisz(ll v)\n{\n\tdebug() << imie(v);\n\tprintf(\"%lld %lld\\n\", (s+v)/2, (s-v)/2);\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%lld\", &tab[i]);\n\t\ts+=tab[i];\n\t}\n\tll x=0;\n\tfor (int i=2; i<=n; i+=2)\n\t\tx+=tab[i];\n\tif (!(n&1))\n\t\twypisz(max(x, s-x)-min(x, s-x));\n\t//~ ll wyn=max(x, s-x)-min(x, s-x);\n\tfor (int i=1; i<=n; i++)\n\t\tpre[i]=tab[i]-pre[i-1];\n\t//~ for (int i=n; i; i--)\n\t\t//~ suf[i]=tab[i]-suf[i+1];\n\t//~ for (int i=2; i<=n; i+=2)\n\t\t//~ wyn=max(wyn, min(pre[i]+abs(suf[i+1]), abs(pre[i-1])+suf[i]));\n\t//~ wypisz(wyn);\n\tll wyn=x-(s-x);\n\t\n\tll bsa=-1e9;\n\tll bsb=1e9;\n\tll bss;\n\twhile(bsa<bsb)\n\t{\n\t\tbss=(bsa+bsb+2)>>1;\n\t\t\n\t\tll naj=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tdp[i]=0;\n\t\tdp[0]=1;\n\t\tfor (int i=1; i<=n; i+=2)\n\t\t{\n\t\t\tif (pre[i]-bss>=naj)\n\t\t\t{\n\t\t\t\tdp[i]=1;\n\t\t\t\tnaj=min(naj, -pre[i+1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif (dp[n])\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tdebug() << imie(bsa);\n\t\n\twyn+=2*bsa;\n\t\n\twypisz(wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[300005];\nint n;\nbool b[300005];\nint ans[2];\nint findmax(){\n\tint maxn=-0x3f3f3f3f;\n\tint k;\n\tfor(int i=1;i<=n;i++){\n\t\tif(b[i])\n\t\t\tcontinue;\n\t\tif(maxn<a[i]){\n\t\t\tmaxn=a[i];\n\t\t\tk=i;\n\t\t}\n\t}\n\treturn k;\n}\nint main(){\n\tcin>>n;\n\tb[0]=b[n+1]=true;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\tint last=0;\n\tint x=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(last){\n\t\t\tif(b[last-1]&&b[last+1]){\n\t\t\t\tlast=findmax();\n\t\t\t\tans[x]+=a[last];\n\t\t\t\tb[last]=true;\n\t\t\t\tx=(x+1)%2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(b[last-1]){\n\t\t\t\t\tlast++;\n\t\t\t\t\tans[x]+=a[last];\n\t\t\t\t\tb[last]=true;\n\t\t\t\t\tx=(x+1)%2;\n\t\t\t\t}\n\t\t\t\telse if(b[last+1]){\n\t\t\t\t\tlast--;\n\t\t\t\t\tans[x]+=a[last];\n\t\t\t\t\tb[last]=true;\n\t\t\t\t\tx=(x+1)%2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(a[last-1]>a[last+1]){\n\t\t\t\t\t\tlast--;\n\t\t\t\t\t\tans[x]+=a[last];\n\t\t\t\t\t\tb[last]=true;\n\t\t\t\t\t\tx=(x+1)%2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlast++;\n\t\t\t\t\t\tans[x]+=a[last];\n\t\t\t\t\t\tb[last]=true;\n\t\t\t\t\t\tx=(x+1)%2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlast=findmax();\n\t\t\tans[x]+=a[last];\n\t\t\tb[last]=true;\n\t\t\tx=(x+1)%2;\n\t\t}\n\t}\n\tif(ans[0]<ans[1])\n\t\tswap(ans[0],ans[1]);\n\tcout<<ans[0]<<\" \"<<ans[1]<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int N = 3e5 + 5;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, a[N], s[N];\nvoid solve1() {\n\tint s0 = 0, s1 = 0;\n\tfor(int i = 1; i <= n; ++ i) if(i & 1) s0 += a[i]; else s1 += a[i];\n\tprintf(\"%d %d\\n\", max(s0, s1), min(s0, s1));\n}\nbool check(int mid) {\n\tint v = 0;\n\tfor(int i = 1; i < n; i += 2) if(s[i] - v >= mid) v = min(v, s[i + 1]);\n\treturn s[n] - v >= mid;\n}\nvoid solve2() {\n\tfor(int i = 1; i <= n; ++ i) if(i & 1) s[i] = s[i - 1] + a[i]; else s[i] = s[i - 1] - a[i];\n\tint l = 1, r = n * 1000, mid, ans = l;\n\twhile(l <= r) {\n\t\tmid = (l + r) >> 1;\n\t\tif(check(mid)) l = mid + 1, ans = mid;\n\t\telse r = mid - 1;\n\t}\n\tfor(int i = 2; i <= n; i += 2) ans += a[i];\n\tint sum = 0;\n\tfor(int i = 1; i <= n; ++ i) sum += a[i];\n\tprintf(\"%d %d\\n\", ans, sum - ans); \n}\nint main() {\n\tn = read();\n\tfor(int i = 1; i <= n; ++ i) a[i] = read();\n\tif(n % 2 == 0) return solve1(), 0;\n\telse return solve2(), 0;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=3e5+5;\nchar buf[1<<12],*p1=buf,*p2=buf,nc;int ny;\ninline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n,a[MAXN],tot[2],Sum[MAXN];\ninline bool chk(int mid){\n\tint k=0;\n\tfor(int i=2;i<=n;i+=2)if(Sum[i-1]-k>=mid)\n\t\tk=min(k,Sum[i]);\n\treturn Sum[n]-k>=mid;\n}\nint main(){\n\tn=read();Rep(i,1,n)tot[i&1]+=a[i]=read();\n\tif(!(n&1))cout<<max(tot[0],tot[1])<<' '<<min(tot[0],tot[1])<<\"\\n\";\n\telse{\n\t\tRep(i,1,n)Sum[i]=Sum[i-1]+(i&1?a[i]:-a[i]);\n\t\tint l=0,r=tot[0]+tot[1],ans=0;\n\t\tfor(int mid;l<=r;)mid=l+r>>1,chk(mid)?l=mid+1,ans=mid:r=mid-1;\n\t\tcout<<tot[0]+ans<<\" \"<<tot[1]-ans<<'\\n';\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n; ll a[SZ],B,W,b[SZ];\nbool ok(ll t)\n{\n\tfor(int i=1;i<=n;++i) b[i]=a[i];\n\tfor(int i=n;i>1;i-=2)\n\t\tif(b[i]<t||b[i-1]<b[i]) b[i-2]+=b[i]-b[i-1];\n\treturn b[1]>=t;\n}\nll calc()\n{\n\tll l=-1e18,r=1e18;\n\twhile(l<r)\n\t{\n\t\tll g=l+((r-l+1)>>1);\n\t\tif(ok(g)) l=g; else r=g-1;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",a+i);\n\t\tif(i%2==0) W+=a[i]; else B+=a[i];\n\t}\n\tif(n%2==0)\n\t{\n\t\tprintf(\"%lld %lld\\n\",max(W,B),min(W,B));\n\t\treturn 0;\n\t}\n\tll ans=W+calc();\n\tprintf(\"%lld %lld\\n\",ans,B+W-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\nusing namespace std;\n\ntypedef long long li;\ntypedef unsigned long long lu;\nconst li infl = ~0LLU >> 2;\n\ntemplate <class T>\ninline void Min(T &x, T y) {\n  if (y < x) x = y;\n}\ntemplate <class T>\ninline void Max(T &x, T y) {\n  if (y > x) x = y;\n}\n\nconst int mod = 1e9 + 7;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\nint Inv(int x) {\n  return Pow(x, mod - 2);\n}\n\n// ----------------------------------------\n\nconst int maxn = 3e5;\nconst int inf = 1e9;\n\nint n, a[maxn], sum_a;\nint sumd[maxn];\nbool dp[maxn];\n\nvoid Exit(int ans) {\n  printf(\"%d %d\\n\", ans, sum_a - ans);\n  exit(0);\n}\n\nbool Check(int lim) {\n  FILL(dp, n, 0);\n  int min_yes = 0;\n\n  for (int i = 1; i < n; i += 2) {\n    dp[i] = (sumd[i - 1] - min_yes >= lim);\n    if (dp[i]) {\n      Min(min_yes, sumd[i]);\n    }\n  }\n\n  return sumd[n - 1] - min_yes >= lim;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  sum_a = 0;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n    sum_a += a[i];\n  }\n  int sum1 = 0;\n  for (int i = 0; i < n; i += 2) {\n    sum1 += a[i];\n  }\n  int ans = max(sum1, sum_a - sum1);\n  if (~n & 1) {\n    Exit(ans);\n  }\n\n  sumd[0] = a[0];\n  for (int i = 1; i < n; ++i) {\n    sumd[i] = sumd[i - 1] + a[i] * (i & 1 ? -1 : 1);\n  }\n\n  int low = 0, high = 2 * sum_a + 1;\n  while (high - low > 1) {\n    int mid = low + high >> 1;\n    if (Check(mid)) {\n      low = mid;\n    } else {\n      high = mid;\n    }\n  }\n  Max(ans, sum_a - sum1 + low);\n  Exit(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nint n, sum, buff, a[100005];\nint main() {\n\tcin >> n;\n\tfor(int i = 0; i < n; i ++) {\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tfor(int i = 0; i < n; i ++) {\n\t\tif(i % 2)\n\t\t\tbuff -= a[i];\n\t\telse\n\t\t\tbuff += a[i];\n\t}\n\tif(n % 2 == 0) {\n\t\tcout << (sum + max(buff, -buff)) / 2 << \" \" << (sum - max(buff, -buff)) / 2 << '\\n';\n\t\treturn 0;\n\t}\n\tif(buff >= 1000) {\n\t\tcout << (sum + buff) / 2 << \" \" << (sum - buff) / 2 << '\\n';\n\t\treturn 0;\n\t}\n\tint s = 0;\n\tint e = 1000; \n\twhile(s + 1 < e) {\n\t\tint d = (s + e) / 2;\n\t\tvector <int> r;\n\t\tr.push_back(a[0]);\n\t\tfor(int i = 1; i < n; i += 2) {\n\t\t\tif(r[r.size() - 1] < d || a[i] <= r[r.size() - 1]) {\n\t\t\t\tr[r.size() - 1] += a[i+1] - a[i];\n\t\t\t} else {\n\t\t\t\tr.push_back(a[i]);\n\t\t\t\tr.push_back(a[i + 1]);\n\t\t\t}\n\t\t}\n\t\tif(r[r.size() - 1] >= d)\n\t\t\ts = d;\n\t\telse\n\t\t\te = d;\n\t}\n\tcout << (sum + max(buff, (-buff + 2 * s))) / 2 << \" \";\n\tcout << (sum - max(buff, (-buff + 2 * s))) / 2 << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[300005];\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t}\n\telse{\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tint lb = 0,ub = 1000000007;\n\t\twhile(ub-lb>1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tif(c >= b+mid){\n\t\t\t\tlb = mid; continue;\n\t\t\t}\n\t\t\tpriority_queue<P1>que;\n\t\t\tpriority_queue<P,vector<P>,greater<P> >que2;\n\t\t\tint zan = c-b;\n\t\t\tint lazy = 0;\n\t\t\tint cur = 0;\n\t\t\trepn(i,n){\n\t\t\t\tif(i%2 == 1) cur += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(cur>=mid){\n\t\t\t\t\t\tque2.push(mp(cur-a[i],i));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tque.push(mp(cur,mp(cur-a[i],i)));\n\t\t\t\t\t}\n\t\t\t\t\tcur -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint pre = -1;\n\t\t\twhile(1){\n\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t}\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP1 p = que.top();\n\t\t\t\t\tif(p.sc.sc<=pre){\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy >= mid){\n\t\t\t\t\t\tque2.push(p.sc);\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbool ok = 0;\n\t\t\t\twhile(!que2.empty()){\n\t\t\t\t\tP p = que2.top();\n\t\t\t\t\tif(p.sc<=pre){\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi>=0){\n\t\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlazy += p.fi;\n\t\t\t\t\t\tpre = p.sc;\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(0);\n\t\t\tfail:;\n\t\t}\n\t\tassert(lb+b>c);\n\t\tprintf(\"%lld %lld\\n\",lb+b,c-lb);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int N=3e5+2;\nconst int inf=1e9+7;\nint ar[N],sum[N][2];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,min1=0,lef=-inf,rig=inf,mid;\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>ar[i];\n\t\tsum[i][1]=sum[i-1][1];\n\t\tsum[i][0]=sum[i-1][0];\n\t\tif(i&1){\n\t\t\tsum[i][1]+=ar[i];\n\t\t}\n\t\telse{\n\t\t\tsum[i][0]+=ar[i];\n\t\t}\n\t}\n\tif(!(n&1)){\n\t\tcout<<max(sum[n][0],sum[n][1])<<' '<<min(sum[n][0],sum[n][1]);\n\t}\n\telse{\n\t\twhile(lef<rig){\n\t\t\tmid=(lef+rig+1)/2;\n\t\t\tbool cac=false;\n\t\t\tfor(i=2;i<=n;i+=2){\n\t\t\t\tif(sum[i-1][1]-sum[i-1][0]>=mid+min1){\n\t\t\t\t\tif(sum[n][1]-sum[n][0]-(sum[i][1]-sum[i][0])>=mid){\n\t\t\t\t\t\tcac=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmin1=min(min1,sum[i][1]-sum[i][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cac){\n\t\t\t\tlef=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\trig=mid-1;\n\t\t\t}\n\t\t}\n\t\t//cout<<lef<<endl;\n\t\tcout<<max(sum[n][1],sum[n][0]+lef)<<' '<<sum[n][0]+sum[n][1]-max(sum[n][1],sum[n][0]+lef);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, a[303030], b[303030], S;\n\nstruct Segtree{\n    long long N, M;\n    long long mnm[1048576], mxm[1048576];\n    void init(){\n        fill(mnm, mnm + 1048576, 189501249917890);\n        fill(mxm, mxm + 1048576, -189501249917890);\n        for(int i = 0; i < M; ++i)mnm[i + N] = mxm[i + N] = b[i];\n        for(int i = N - 1; i; --i){\n            mnm[i] = min(mnm[2 * i], mnm[2 * i + 1]);\n            mxm[i] = max(mxm[2 * i], mxm[2 * i + 1]);\n        }\n    }\n    Segtree(long long _N) : mnm(), mxm(){\n        N = 1;\n        M = _N;\n        while(N < _N)N *= 2;\n    }\n    long long mnn(long long L, long long R){\n        L += N;\n        R += N;\n        long long ret = 189501249917890;\n        while(L < R){\n            if(L & 1){\n                ret = min(ret, mnm[L]);\n                ++L;\n            }\n            if(R & 1){\n                ret = min(ret, mnm[R - 1]);\n            }\n            L /= 2;\n            R /= 2;\n        }\n        return ret;\n    }\n    long long mxx(long long L, long long R){\n        L += N;\n        R += N;\n        long long ret = -189501249917890;\n        while(L < R){\n            if(L & 1){\n                ret = max(ret, mxm[L]);\n                ++L;\n            }\n            if(R & 1){\n                ret = max(ret, mxm[R - 1]);\n            }\n            L /= 2;\n            R /= 2;\n        }\n        return ret;\n    }\n};\n\nSegtree sgt(524288);\n\nint main(){\n    scanf(\"%lld\", &N);\n    if(N & 1){\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + i);\n            S += a[i];\n            a[i] *= (i & 1) ? -1 : 1;\n        }\n        partial_sum(a, a + N, b + 1);\n        long long ans = b[N];\n        sgt.init();\n        for(int i = 1; i < N; i += 2){\n            ans = max(ans, -b[N] + 2 * min(sgt.mxx(i + 1, N + 1) - b[i + 1], b[i] - sgt.mnn(0, i + 1)));\n        }\n        cout << (S + ans) / 2 << \" \" << (S - ans) / 2 << endl;\n    }else{\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + 4);\n            a[i & 1] += a[4];\n        }\n        if(a[0] < a[1])swap(a[0], a[1]);\n        cout << a[0] << \" \" << a[1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5+5;\nint n,a[N],s[N];\n\ninline bool check(int x){\n\tint v=0;\n\tfor(int i=1;i<n;i+=2){\n\t\tif(s[i]-v>=x){\n\t\t\tv=min(v,s[i+1]);\n\t\t}\n\t}\n\treturn s[n]-v>=x;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tif(!(n%2)){\n\t\tint s0=0,s1=0;\n\t\tfor(int i=1;i<=n;i++)if(i&1)s0+=a[i];else s1+=a[i];\n\t\tcout << max(s0,s1) << \" \" << min(s0,s1) << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(i&1)s[i]=s[i-1]+a[i];\n\t\telse s[i]=s[i-1]-a[i];\n\t}\n\tint l=1, r=n*1000, ans=l;\n\twhile(l<=r){\n\t\tint mid = (l+r)>>1;\n\t\tif(check(mid))l=mid+1,ans=mid;\n\t\telse r=mid-1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(i%2==0)\n\t\t\tans+=a[i];\n\t}\n\tint s=0;\n\tfor(int i=1;i<=n;i++)s+=a[i];\n\tcout << ans << \" \" << s - ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[300005];\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t}\n\telse{\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tif(c-b >= 1000){\n\t\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t\t\treturn 0;\n\t\t}\n\t\tint lb = 0,ub = 1000;\n\t\twhile(ub-lb>1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tif(c >= b+mid){\n\t\t\t\tlb = mid; continue;\n\t\t\t}\n\t\t\tpriority_queue<P1>que;\n\t\t\tpriority_queue<P,vector<P>,greater<P> >que2;\n\t\t\tint zan = c-b;\n\t\t\tint lazy = 0;\n\t\t\tint cur = 0;\n\t\t\trepn(i,n){\n\t\t\t\tif(i%2 == 1) cur += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(cur>=mid){\n\t\t\t\t\t\tque2.push(mp(cur-a[i],i));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tque.push(mp(cur,mp(cur-a[i],i)));\n\t\t\t\t\t}\n\t\t\t\t\tcur -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint pre = -1;\n\t\t\twhile(1){\n\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t}\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP1 p = que.top();\n\t\t\t\t\tif(p.sc.sc<=pre){\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy >= mid){\n\t\t\t\t\t\tque2.push(p.sc);\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbool ok = 0;\n\t\t\t\twhile(!que2.empty()){\n\t\t\t\t\tP p = que2.top();\n\t\t\t\t\tif(p.sc<=pre){\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy>=0){\n\t\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlazy = p.fi;\n\t\t\t\t\t\tpre = p.sc;\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t\tok = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tub = mid;\n\t\t\tfail:;\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",lb+b,c-lb);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint a[300010], n, sum = 0, A = 0, B = 0;\n\nbool check(int x) {\n    int mx = a[1];\n    for(int i = 3; i <= n; i += 2) {\n        if(mx >= x) mx += a[i] - a[i - 1], mx = max(mx, a[i]);\n        else mx += a[i] - a[i - 1];\n    }\n    return mx >= x;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), sum += a[i], A += (i % 2) * a[i];\n    B = sum - A;\n    if(n % 2 == 0) printf(\"%d %d\\n\", max(A, B), min(A, B)); else {\n        int ans = 0;\n        for(int L = 0, R = sum; L <= R; ) {\n            int md = (L + R) / 2;\n            if(check(md)) ans = md, L = md + 1; else R = md - 1;\n        }\n        printf(\"%d %d\\n\", B + ans, sum - B - ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=300005;\nint n,a[N],s[N];\nint check(int x){\n\tint v=0;\n\tfor (int i=1;i<=n;i+=2)\n\t\tif (s[i]-v>=x)v=min(v,s[i+1]);\n\treturn s[n]-v>=x;\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tif (i&1)s[i]=s[i-1]+a[i];\n\t\telse s[i]=s[i-1]-a[i];\n\tif (n%2==0){\n\t\tint s1=0,s2=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i&1)s1+=a[i];\n\t\t\telse s2+=a[i];\n\t\tprintf(\"%d %d\\n\",max(s1,s2),min(s1,s2));\n\t\treturn 0;\n\t}\n\tint l=0,r=1000*n;\n\twhile (l<r){\n\t\tint mid=(l+r+1)/2;\n\t\tif (check(mid))l=mid;\n\t\telse r=mid-1;\n\t}\n\tint s1=l,s2=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (i%2==0)s1+=a[i];\n\tfor (int i=1;i<=n;i++)s2+=a[i];\n\tprintf(\"%d %d\\n\",s1,s2-s1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint n,a[N],s[N];\nint check(int x){\n\tint v=0;\n\tfor (int i=1;i<=n;i+=2)\n\t\tif (s[i]-v>=x)v=min(v,s[i+1]);\n\treturn s[n]-v>=x;\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tif (i&1)s[i]=s[i-1]+a[i];\n\t\telse s[i]=s[i-1]-a[i];\n\tif (n%2==0){\n\t\tint s1=0,s2=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i&1)s1+=a[i];\n\t\t\telse s2+=a[i];\n\t\tprintf(\"%d %d\\n\",max(s1,s2),min(s1,s2));\n\t\treturn 0;\n\t}\n\tint l=0,r=1000*n;\n\twhile (l<r){\n\t\tint mid=(l+r+1)/2;\n\t\tif (check(mid))l=mid;\n\t\telse r=mid-1;\n\t}\n\tint s1=l,s2=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (i%2==0)s1+=a[i];\n\tfor (int i=1;i<=n;i++)s2+=a[i];\n\tprintf(\"%d %d\\n\",s1,s2-s1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll> \n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1<<30)\n#define int long long\nusing namespace std;\nconst int N=300005;\nint n,a[N],B,W,s[N];\nbool ok(int t){\n\tint mn=0;\n\tfor (int i=2;i<=n-1;i+=2)\n\t\tif (s[i-1]-mn>=t) mn=min(mn,s[i]);\n\treturn s[n]-mn>=t;\n}\nint calc(){\n\tint l=0,r=B,ans;\n\twhile (l<=r){\n\t\tint mid=((ll)l+r)/2;\n\t\tif (ok(mid)) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn ans;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tif (i%2==0) W+=a[i],s[i]=s[i-1]-a[i];\n\t\telse B+=a[i],s[i]=s[i-1]+a[i]; \n\t}\n\tif (!(n&1))\n\t\treturn printf(\"%lld %lld\\n\",max(W,B),min(W,B)),0;\n\tll ans=W+calc();\n\tprintf(\"%lld %lld\\n\",ans,(ll)B+W-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tios::sync_with_stdio(0);\n  \tint n, x = 0, y = 0;\n  \tcin >> n;\n  \tfor (int i = 0; i < n; i++){\n    \tint w;\n      \tcin >> w;\n      \ty += w;\n      \tif (i & 1)\n\t\t\tx += w;\n    }\n  \tcout << max(x, y - x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint n,a[N],s[N];\nint check(int x){\n\tint v=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (s[i]-v>=x)v=min(v,s[i+1]);\n\treturn s[n]-v>=x;\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tif (i&1)s[i]=s[i-1]+a[i];\n\t\telse s[i]=s[i-1]-a[i];\n\tif (n%2==0){\n\t\tint s1=0,s2=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i&1)s1+=a[i];\n\t\t\telse s2+=a[i];\n\t\tprintf(\"%d %d\\n\",max(s1,s2),min(s1,s2));\n\t\treturn 0;\n\t}\n\tint l=0,r=1000*n;\n\twhile (l<r){\n\t\tint mid=(l+r+1)/2;\n\t\tif (check(mid))l=mid;\n\t\telse r=mid-1;\n\t}\n\tint s1=l,s2=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (i%2==0)s1+=a[i];\n\tfor (int i=1;i<=n;i++)s2+=a[i];\n\tprintf(\"%d %d\\n\",s1,s2-s1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[300005];\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t}\n\telse{\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tif(c-b >= 1005){\n\t\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t\t\treturn 0;\n\t\t}\n\t\tint lb = 0,ub = 1005;\n\t\twhile(ub-lb>1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tif(c >= b+mid){\n\t\t\t\tlb = mid; continue;\n\t\t\t}\n\t\t\tpriority_queue<P1>que;\n\t\t\tpriority_queue<P,vector<P>,greater<P> >que2;\n\t\t\tint zan = c-b;\n\t\t\tint lazy = 0;\n\t\t\tint cur = 0;\n\t\t\trepn(i,n){\n\t\t\t\tif(i%2 == 1) cur += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(cur>=mid){\n\t\t\t\t\t\tque2.push(mp(cur-a[i],i));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tque.push(mp(cur,mp(cur-a[i],i)));\n\t\t\t\t\t}\n\t\t\t\t\tcur -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint pre = -1;\n\t\t\twhile(1){\n\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t}\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP1 p = que.top();\n\t\t\t\t\tif(p.sc.sc<=pre){\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy >= mid){\n\t\t\t\t\t\tque2.push(p.sc);\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbool ok = 0;\n\t\t\t\twhile(!que2.empty()){\n\t\t\t\t\tP p = que2.top();\n\t\t\t\t\tif(p.sc<=pre){\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi>=0){\n\t\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlazy += p.fi;\n\t\t\t\t\t\tpre = p.sc;\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t\tok = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tub = mid;\n\t\t\tfail:;\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",lb+b,c-lb);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\ntemplate <class T> T abs(T x){ return x < 0 ? -x : x; }\ntemplate <class T> bool chkmax(T &x, T y){ return x < y ? x = y, true : false; }\ntemplate <class T> T min(T a, T b){ return a < b ? a : b; }\ntypedef unsigned int u32;\nconst int N = 3e5 + 5;\nint n, a[N], b[N][2];\nu32 sum, dif, hi, lo;\nint main(){\n\tint i, a0, a1, b0, b1;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i ++) {\n\t\tscanf(\"%d\", a + i), b[i][i & 1] += a[i], sum += a[i];\n\t\tb[i][0] += b[i - 1][0], b[i][1] += b[i - 1][1];\n\t}\n\tdif = abs(b[n][0] - b[n][1]);\n\tif (n & 1) {\n\t\tfor (i = 2; i <= n; i += 2) {\n\t\t\ta0 = b[i - 1][0], a1 = b[i - 1][1];\n\t\t\tb0 = b[n][0] - b[i][0], b1 = b[n][1] - b[i][1];\n\t\t\tchkmax(dif, a[i] + min(b1 - b0 + abs(a1 - a0), a1 - a0 + abs(b1 - b0)));\n\t\t}\n\t}\n\tlo = (sum - dif) >> 1, hi = lo + dif;\n\tprintf(\"%u %u\\n\", hi, lo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long int N;\n\nint checkif(long long int arr[],long long int N,int num){\nfor(int i=0;i<N;i++){\n    if(arr[i]==num){\n        return 1;\n    }\n}\n}\n\nint find_adjacent(int i,long long int flag[]){\nif(i-1>=0  && flag[i-1]==0){\n    if(flag[i-1]==0){return 1;}\n    else return 0;\n}\n\nelse return 0;\n}\n\nint find_adjacent2(int i,long long int flag[]){\nif(i+1<=N && flag[i+1]==0){\n    if(flag[i+1]==0){return 1;}\n    else return 0;\n}\nelse return 0;\n}\n\nint main(){\n\nscanf(\"%lld\",&N);\nlong long int arr[N],i,maxs=2000,mini=0,mini_ind,max_ind,flag[N],arr2[N],sigma=0,sugim=0,mini2=0,mini2_ind;\nmemset(flag,0,sizeof(flag));\n\nfor(i=0;i<N;i++){\n    scanf(\"%lld\",&arr[i]);\n    arr2[i]=arr[i];\n    if(arr[i]>mini){\n        mini=arr[i];\n        mini_ind=i;\n    }\n}\n\nsugim=sugim+mini;\nflag[mini_ind]=1;\nprintf(\"%lld\\n\",sugim);\n\nif(find_adjacent(mini_ind,flag)==1 && find_adjacent2(mini_ind,flag)==1){\nif(arr[mini_ind-1]>arr[mini_ind+1]){\n        sigma=sigma+arr[mini_ind-1];\n        printf(\"%lld\\n\",sigma);\nmax_ind=mini_ind-1;\nflag[mini_ind-1]=1;}\nelse{\n    sigma=sigma+arr[mini_ind+1];\n    printf(\"%lld\\n\",sigma);\n    max_ind=mini_ind+1;\n    flag[mini_ind+1]=1;\n}\n}\nelse{\n       for(i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                max_ind=i;\n            }\n        }\n    }\n    sigma=sigma+mini2;\n    printf(\"%lld\\n\",sigma);\n    flag[max_ind]=1;\n}\n\nfor(i=0;i<N;i++){\n    printf(\"%lld\",flag[i]);\n}\nprintf(\"\\n\");\n\n\nint turn=0;\nwhile(checkif(flag,N,0)==1){\n       printf(\"yessss\\n\");\n\n\n        if(turn==0){\n\nif(find_adjacent(max_ind,flag)==1 &&  find_adjacent2(max_ind,flag)==1){\nif(arr[max_ind-1]>arr[max_ind+1]){sugim=sugim+arr[max_ind-1];flag[max_ind-1]=1;mini_ind=max_ind-1;printf(\"%lld\\n\",sugim);}\nelse{\n    sugim=sugim+arr[max_ind+1];\n    mini_ind=max_ind-1;\n    flag[mini_ind]=1;\n    printf(\"%lld\\n\",sugim);\n}\n}\nelse{\n    for(i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                mini_ind=i;\n\n            }\n        }\n    }\n    sugim=sugim+mini2;\n    printf(\"%lld\\n\",sugim);\n    flag[mini_ind]=1;\n\n}\nturn=1;\n        }\n        else{\n            if(find_adjacent(mini_ind,flag)==1 && find_adjacent2(mini_ind,flag)==1){\nif(arr[mini_ind-1]>arr[mini_ind+1]){sigma=sigma+arr[mini_ind-1];max_ind=mini_ind-1;flag[mini_ind-1]=1;printf(\"%lld\\n\",sigma);}\nelse{\n    sigma=sigma+arr[mini_ind+1];\n    printf(\"%lld\\n\",sigma);\n    max_ind=mini_ind+1;\n    flag[mini_ind+1]=1;\n}\n}\nelse{\n for(i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                mini_ind=i;\n            }\n        }\n    }\n    sigma=sigma+mini2;\n    printf(\"%lld\\n\",sigma);\n    flag[mini_ind]=1;\n\n}\nturn=0;\n        }\n\n}\nprintf(\"%lld %lld\\n\",sugim,sigma);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint s[MAXN],a[MAXN],n;\nbool check(int x)\n{\n\tint ans=0;\n\tfor (int i=1;i<n;i++)\n\t\tif (s[i]-ans>=x) upmin(ans,s[i+1]);\n\treturn s[n]-ans>=x;\n}\nint main()\n{\n\tn=read();\n\tint sum=0;\n\tfor (int i=1;i<=n;i++) a[i]=read(),sum+=a[i];\n\tif (!n)\n\t{\n\t\tint s=0;\n\t\tfor (int i=1;i<=n;i++) s+=(i&1)*a[i];\n\t\tprintf(\"%d %d\\n\",max(s,sum-s),min(s,sum-s));\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++) s[i]=s[i-1]+a[i]*((i&1)?1:-1);\n\tint l=0,r=n*1000;\n\twhile (l<r)\n\t{\n\t\tint mid=(l+r+1)>>1;\n\t\tif (check(mid)) l=mid;\n\t\telse r=mid-1;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!(i&1)) l+=a[i];\n\tprintf(\"%d %d\\n\",l,sum-l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 300010;\nint A[MAXN], pre[MAXN], n;\nbool solve(int x) {\n\tint pmin = 0;\n\tfor (int i = 2; i <= n; i += 2)\n\t\tif (pre[i - 1] - pmin >= x)\n\t\t\tpmin = std::min(pmin, pre[i]); \n\treturn pre[n] - pmin >= x;\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tint sa = 0, sb = 0, sum = 0l;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::cin >> A[i]; sum += A[i];\n\t\ti & 1 ? sa += A[i] : sb += A[i];\n\t\tpre[i] = pre[i - 1] + (i & 1 ? 1 : -1) * A[i];\n\t}\n\tint Ans = std::max(sa, sb);\n\tif (n & 1) {\n\t\tint l = -sum, r = sum, ans = 0;\n\t\twhile (l <= r) {\n\t\t\tint mid = l + r >> 1;\n\t\t\tif (solve(mid)) ans = mid, l = mid + 1; else r = mid - 1;\n\t\t}\n\t\tAns = std::max(Ans, sb + ans);\n\t}\n\tstd::cout << Ans << ' ' << sum - Ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<unordered_map>\ntypedef unsigned int u32;\nconst int N=3e5+5;\nint n,a[N],s[N][2],f[N],g[N];\ntemplate<class T>T abs(T x){return x<0?-x:x;}\ntemplate<class T>bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>T min(T a,T b){return a<b?a:b;}\ninline int fin(int l,int r){return (s[r][0]-s[l-1][0])-(s[r][1]-s[l-1][1]);}\ninline int calc(int l,int r){return abs(fin(l,r));}\nint main(){\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tif(n>10000)exit(0);\n\tfor(i=1;i<=n;i++)s[i][0]=s[i-1][0],s[i][1]=s[i-1][1],scanf(\"%d\",a+i),s[i][i&1]+=a[i];\n\tint dif=abs(s[n][0]-s[n][1]);\n\tif(n&1){\n\t\tfor(i=1;i<=n;i+=2){\n\t\t\tf[i]=calc(1,i); \n\t\t\tfor(j=2;j<=i;j+=2)chkmax(f[i],a[j]+min(calc(1,j-1)+fin(j+1,i),fin(1,j-1)+calc(j+1,i)));\n\t\t}\n\t\tfor(i=n;i>=1;i-=2){\n\t\t\tg[i]=calc(i,n);\n\t\t\tfor(j=i+1;j<=n;j+=2)chkmax(g[i],a[j]+min(calc(i,j-1)+fin(j+1,n),fin(i,j-1)+calc(j+1,n)));\n\t\t}\n\t\tfor(i=2;i<=n;i+=2){\n\t\t\tchkmax(dif,a[i]+min(fin(1,i-1)+g[i+1],f[i-1]+fin(i+1,n)));\n\t\t}\n\t}\n\tu32 sum=(u32)s[n][0]+s[n][1];\n\tu32 sigma=(sum-dif)>>1,sugim=sigma+dif;\n\tprintf(\"%u %u\\n\",sugim,sigma);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 300010;\n\nint n, a[maxn], sum[maxn];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tif (n & 1) {\n\t\tint L = -1e9, R = 1e9, ans = 0, s = 0;\n\t\tfor (int i = 1; i <= n; i++) if (i & 1) sum[i] = sum[i-1] + a[i]; else sum[i] = sum[i-1] - a[i];\n\t\twhile (L <= R) {\n\t\t\tint mid = (L + R) >> 1;\n\t\t\tint mns = 0;\n\t\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\t\tif (sum[i] - mns >= mid) {\n\t\t\t\t\tmns = min(mns, sum[i+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum[n] - mns >= mid) {\n\t\t\t\tL = mid + 1;\n\t\t\t\tans = mid;\n\t\t\t} else R = mid-1;\n\t\t}\n\t\tfor (int i = 2; i <= n; i += 2) ans += a[i];\n\t\tfor (int i = 1; i <= n; i++) s += a[i];\n\t\tprintf(\"%d %d\\n\", ans, s - ans);\n\t} else {\n\t\tint s0 = 0, s1 = 0;\n\t\tfor (int i = 1; i <= n; i++) if (i & 1) s1 += a[i]; else s0 += a[i];\n\t\tif (s0 < s1) swap(s0, s1);\n\t\tprintf(\"%d %d\\n\", s0, s1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Written By NewbieChd\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\nconst int BUF = 1000000;\nchar buf[BUF], *p1, *p2;\ninline char getChar() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUF, stdin), p1 == p2) ? EOF : *p1++; }\ninline int read() {\n    int f = 0;\n    char c;\n    while (!isdigit(c = getChar())) {}\n    do\n        f = f * 10 + (c ^ 48);\n    while (isdigit(c = getChar()));\n    return f;\n}\n\nconst int maxN = 300007;\nint a[maxN], dp[maxN];\n\nint main() {\n    int n = read(), i, s[2] = {0, 0};\n    \n    for (i = 1; i <= n; ++i)\n        a[i] = read(), s[i & 1] += a[i];\n    \n    if (n & 1) {\n        int l = 0, r = s[0] + s[1], mid;\n        dp[0] = a[1];\n        while (l < r) {\n            mid = (l + r + 1) >> 1;\n            for (i = 2; i < n; i += 2) {\n                dp[i] = dp[i - 2] - a[i];\n                if (dp[i - 2] >= mid)\n                    dp[i] = max(dp[i], 0);\n                dp[i] += a[i + 1];\n            }\n            dp[n - 1] >= mid ? l = mid : r = mid - 1;\n        }\n        l += s[0];\n        if (l > s[1])\n            printf(\"%d %d\\n\", l, s[0] + s[1] - l);\n        else\n            printf(\"%d %d\\n\", s[1], s[0]);\n    }\n    else\n        printf(\"%d %d\\n\", max(s[0], s[1]), min(s[0], s[1]));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 3e5 + 10;\n\nint a[N],n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline bool check(int val) {\n\tint sum = 0;\n\tfor(int i = 1;i <= n;i += 2) {\n\t\tif(sum >= val) sum = max(sum + a[i] - a[i - 1],a[i]);\n\t\telse sum += a[i] - a[i - 1];\n\t}\n\treturn sum >= val;\n}\n\nint main() {\n\n\tn = read(); int black = 0,white = 0;\n\tFor(i,1,n) {\n\t\ta[i] = read();\n\t\tif(i & 1) black += a[i];\n\t\telse white += a[i];\n\t}\n\tif(!(n & 1)) {\n\t\tprintf(\"%d %d\\n\",max(black,white),min(black,white));\n\t} else {\n\t\tint l = 0,r = black;\n\t\twhile(l < r) {\n\t\t\tint mid = (l + r + 1) >> 1;\n\t\t\tif(check(mid)) l = mid;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",max(black,white + l),min(white,black - l));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x <<\": \" << (x) << endl\n//Ã�Â¥Ã¯Â¿Â½Ã�Â¨Ã�Â¦Ã�Â¯Ã¯Â¿Â½Ã�Â¤Ã�Â¸Ã�ÂªÃ�Â¥Ã¯Â¿Â½Ã�Â½Ã�Â¦Ã¯Â¿Â½Ã�Â°Ã�Â§Ã¯Â¿Â½Ã¯Â¿Â½Ã�Â¥Ã¯Â¿Â½Ã�Â¥Ã�Â¥Ã¯Â¿Â½Ã�Â£Ã�Â¥Ã�Â¤Ã¯Â¿Â½Ã�Â¦Ã¯Â¿Â½Ã�Â§Ã�Â¨Ã�Â¡Ã¯Â¿Â½Ã�Â¤Ã�Â¸Ã¯Â¿Â½Ã�Â¦Ã�Â¬Ã�Â¡Ã�Â¯Ã�Â¼Ã¯Â¿Â½Ã�Â¥Ã¯Â¿Â½Ã�ÂºÃ�Â¥Ã¯Â¿Â½Ã�Â£Ã�Â¥Ã�Â¤Ã¯Â¿Â½Ã�Â¦Ã¯Â¿Â½Ã�Â§Ã�Â¨Ã�Â¡Ã¯Â¿Â½Ã�Â¤Ã�Â¸Ã¯Â¿Â½Ã�Â¦Ã�Â¬Ã�Â¡Ã�Â£Ã¯Â¿Â½Ã¯Â¿Â½Ã�Â§Ã¯Â¿Â½Ã�Â¶Ã�Â¥Ã¯Â¿Â½Ã¯Â¿Â½Ã�Â¥Ã�Â°Ã�Â±Ã�Â¥Ã¯Â¿Â½Ã�Â¯Ã�Â¤Ã�Â»Ã�Â¥Ã�Â¥Ã�Â¿Ã�Â«Ã�Â©Ã¯Â¿Â½Ã¯Â¿Â½Ã�Â¥Ã�Â¾Ã¯Â¿Â½Ã�Â§Ã¯Â¿Â½Ã�Â¥Ã�Â¦Ã¯Â¿Â½Ã�Â¯Ã�Â¥Ã¯Â¿Â½Ã�ÂªÃ�Â¤Ã�Â¸Ã�ÂªÃ�Â¥Ã¯Â¿Â½Ã�Â°Ã�Â¦Ã¯Â¿Â½Ã�Â¹Ã�Â¦Ã�Â®Ã�ÂµÃ�Â©Ã¯Â¿Â½Ã¯Â¿Â½Ã�Â¨Ã�Â¯Ã�Â¯Ã�Â¤Ã�ÂºÃ¯Â¿Â½\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#ifdef LOCAL\n#define see(x) cout  << #x << \": \" << (x) << endl\n#endif\n#ifndef LOCAL\n#define see(x)\n#endif\n\n\n#define rep(n) for(int _ = 0; _ != (n); ++_)\n//#define rep(i, a, b) for(int i = (a); i <= (b); ++i)\n#define Rng(i, n) for(int i = 0; i != (n); ++i)\n#define rng(i, a, b) for(int i = (a); i < (b); ++i)\n#define rno(i, b) for(int i = 0; i<(b); ++i)\n#define rnc(i, a, b) for(int i = (a); i<=(b); ++i)\n#define RNG(i, a) for(auto &i: (a))\n#define dwn(i, r, l) for(int i = (r); i>=(l); i--)\n\nnamespace std {\n    template<class T>\n    T begin(std::pair<T, T> p)\n    {\n        return p.first;\n    }\n    template<class T>\n    T end(std::pair<T, T> p)\n    {\n        return p.second;\n    }\n}\n\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate<class Range>\nstd::pair<std::reverse_iterator<decltype(begin(std::declval<Range>()))>, std::reverse_iterator<decltype(begin(std::declval<Range>()))>> make_reverse_range(Range &&r)\n{\n    return std::make_pair(make_reverse_iterator(::begin(r)), make_reverse_iterator(::end(r)));\n}\n\n#define RRNG(x, cont) for (auto &x: make_reverse_range(cont))\n\n\n\ntemplate<class T> int sign(const T &a) { return a == 0 ? 0 : a > 0 ? 1 : -1; }\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> void Min(T &a, const T &b){ a = min(a, b); }\ntemplate<class T> void Max(T &a, const T &b){ a = max(a, b); }\n\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\nusing pii = pair<int, int>;\nusing pdd = pair<double, double>;\nusing pip = pair<int, pii>;\nusing szt = size_t;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing pli = pair<ll,int>;\nusing wg = vector<vpii>; //weighted graph\n\nint cas;\nconst double pi = acos(-1);\nll mod = 1e9 + 7;\n\ntemplate<class T>\ninline void add_mod(T &a, const T &b) {\n    a += b;\n    if (a >= mod) a -= mod;\n}\ntemplate<class T>\nvoid sub_mod(T &a, const T &b){\n    a -= b;\n    if (a < 0) a += mod;\n}\nauto bo=[](int x){\n    bitset<5> a(x);\n    cout << a << endl;\n};\n\n//返回值：a中比k小的元素有多少个？\ntemplate<class V, class Cont>\nint get_rank(const V &k, const Cont &a){\n    return std::lower_bound(all(a), k) - a.begin();\n}\n\nmat operator*(const mat &a, const mat &b) {\n    mat c(a.size(), vec(b[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            if (a[i][j]) { // optimization for sparse matrix\n                for (int k = 0; k < b[0].size(); k++) {\n                    add_mod(c[i][k], a[i][j] * b[j][k] % mod);\n                }\n            }\n        }\n    }\n    return c;\n}\n\nvec operator*(const mat &a, const vec &b) {\n    vec c(a.size());\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            add_mod(c[i], a[i][j] * b[j] % mod);\n        }\n    }\n    return c;\n}\n\nmat pow(mat a, ull n) {\n    mat res(a.size(), vec(a[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        res[i][i] = 1;\n    }\n    while (n) {\n        if (n & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\n// Codeforces does not support __int128\n//std::ostream& operator<<(std::ostream& os, __int128 T) {\n//    if (T<0) os<<\"-\";\n//    if (T>=10 ) os<<T/10;\n//    if (T<=-10) os<<(-(T/10));\n//    return os<<( (int) (T%10) >0 ? (int) (T%10) : -(int) (T%10) ) ;\n//}\n//\n//__int128 LPOW(__int128 x, ll n) {\n//    __int128 res = 1;\n//    for (; n; n /= 2, x *= x, x %= mod) {\n//        if (n & 1) {\n//            res *= x;\n//            res %= mod;\n//        }\n//    }\n//    return res;\n//}\n\nll POW(ll x, ll n){\n    ll res = 1;\n    for (; n; n /= 2, x *= x, x %= mod) {\n        if (n & 1) {\n            res *= x;\n            res %= mod;\n        }\n    }\n    return res;\n}\n\n\nll INV(ll x) {\n    return POW(x, mod - 2);\n}\n\nll inv(ll x){\n//    see(x);\n    return x == 1? 1: (mod - mod/x * inv(mod%x) % mod);\n}\n\n\n\n// 2D rotation\nvoid rotate(double &x, double &y, double theta) {\n    double tx = cos(theta) * x - sin(theta) * y;\n    double ty = sin(theta) * x + cos(theta) * y;\n    x = tx, y = ty;\n}\nstruct bit {\n    static const int BIT_N = 1e5 + 5;\n    ll bit[BIT_N];\n    void init(int n){\n        rng(i, 1, n+1) bit[i] = 0;\n    }\n\n    ll sum(int x) {\n        ll res = 0;\n        while (x) {\n            res += bit[x];\n            x -= x & -x;\n        }\n        return res;\n    }\n\n    ll sum(int l, int r) {\n        if (l > r) return 0;\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int x, ll v, int n) {\n        while (x <= n) {\n            bit[x] += v;\n            x += x & -x;\n        }\n    }\n};\n\n\nnamespace util{\n    int len(ll x){return snprintf(nullptr, 0, \"%lld\", x);}\n    vi get_d(ll x){\n        vi res;\n        while(x) {\n            res.pb(x%10);\n            x /= 10;\n        }\n        reverse(all(res));\n        return res;\n    }\n    template <class T> T parity(const T &a){\n        return a & 1;\n    }\n    template <class T>\n    void out (const vector<T> &a){\n        std::copy(a.begin(), a.end(), std::ostream_iterator<T>(std::cout, \", \"));\n        cout << endl;\n    };\n}\n\nusing namespace util;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n\nusing order_statistic_tree = __gnu_pbds::tree<\n        int,\n        __gnu_pbds::null_type,\n        greater<int>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n\n\nconst ll LINF = LLONG_MAX/2;\nconst int INF = INT_MAX/2;\nconst int M = 5005;\n\n\nll dp[M];\n\nint c[M], f[M];\n\nint nn[M], v[M], p[M];\n\nint main() {\n    // Single Cut of Failure taught me\n    cout << std::fixed;\n    cout << setprecision(10);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n\n#ifdef LOCAL\n    freopen(\"main.in\", \"r\", stdin);\n//    freopen(\"main.out\", \"w\", stdout);\n#endif\n\n    int n; scan(n);\n    vi a(n);\n    RNG(x, a) scan(x);\n    int sb = 0;\n    for(int i = 0; i<n; i+=2)\n        sb += a[i];\n    int sw = 0;\n    for(int i=1; i<n; i+=2)\n        sw += a[i];\n\n\n    auto check = [n, sb, sw, &a](int x) {\n        int mi = INF;\n        int sum = 0;\n        rng(i, 0, n) {\n            if (i & 1) {\n                if (sum >= x || sum - mi >= x) {\n                    if (sb - sw - (sum - a[i]) >= x)\n                        return true;\n                    sum -= a[i];\n                    Min(mi, sum);\n                }\n                else sum -= a[i];\n            }\n            else sum += a[i];\n        }\n        return false;\n    };\n\n    int l = sb - sw + 1, r = sb;\n    while(l<=r){\n        int mid = l + (r-l)/2;\n        if(check(mid)){\n            l = mid + 1;\n        }\n        else r = mid - 1;\n    }\n\n    println(sw + r, sb - r);\n\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[300005];\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t}\n\telse{return 0;\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tif(c-b >= 1000){\n\t\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t\t\treturn 0;\n\t\t}\n\t\tint lb = 0,ub = 1000;\n\t\twhile(ub-lb>1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tif(c >= b+mid){\n\t\t\t\tlb = mid; continue;\n\t\t\t}\n\t\t\tpriority_queue<P1>que;\n\t\t\tpriority_queue<P,vector<P>,greater<P> >que2;\n\t\t\tint zan = c-b;\n\t\t\tint lazy = 0;\n\t\t\tint cur = 0;\n\t\t\trepn(i,n){\n\t\t\t\tif(i%2 == 1) cur += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(cur>=mid){\n\t\t\t\t\t\tque2.push(mp(cur-a[i],i));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tque.push(mp(cur,mp(cur-a[i],i)));\n\t\t\t\t\t}\n\t\t\t\t\tcur -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint pre = -1;\n\t\t\twhile(1){\n\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t}\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP1 p = que.top();\n\t\t\t\t\tif(p.sc.sc<=pre){\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy >= mid){\n\t\t\t\t\t\tque2.push(p.sc);\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbool ok = 0;\n\t\t\t\twhile(!que2.empty()){\n\t\t\t\t\tP p = que2.top();\n\t\t\t\t\tif(p.sc<=pre){\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy>=0){\n\t\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlazy = p.fi;\n\t\t\t\t\t\tpre = p.sc;\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t\tok = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tub = mid;\n\t\t\tfail:;\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",lb+b,c-lb);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 300060\nint n,v[N];\nlong long su[N],su1,su2;\nbool check(long long l)\n{\n\tlong long mn=0;\n\tfor(int i=1;i<=n;i+=2)\n\tif(su[i]-mn>=l)\n\t{\n\t\tif(mn>su[i+1])mn=su[i+1];\n\t\tif(i==n)return 1;\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]);\n\tif(~n&1)\n\t{\n\t\tlong long s1=0,s2=0;\n\t\tfor(int i=1;i<=n;i+=2)s1+=v[i],s2+=v[i+1];\n\t\tprintf(\"%lld %lld\\n\",max(s1,s2),min(s1,s2));\n\t}\n\telse\n\t{\n\t\tfor(int i=1;i<=n;i++)su1+=v[i]*(i&1),su[i]=su[i-1]+v[i]*(i&1?1:-1),su2+=v[i]*(~i&1);\n\t\tlong long lb=0,rb=2e10,as=0;\n\t\twhile(lb<=rb)\n\t\t{\n\t\t\tlong long mid=(lb+rb)>>1;\n\t\t\tif(check(mid))as=mid,lb=mid+1;\n\t\t\telse rb=mid-1;\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",su2+as,su1-as);\n\t}\n}//orzwkr"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define maxn 1005\nint f[maxn][maxn],s[maxn],sodd[maxn],seven[maxn],n;bool vis[maxn][maxn];\nint calcl(int r,int l){\n\tif (r&1)return /*cerr<<\"calc:\"<<l<<\" \"<<r<<\" \"<<sodd[r]-sodd[l-1]<<endl,*/sodd[r]-sodd[l-1];else return seven[r]-seven[l-1];\n}\nint calcr(int l,int r){\n\tif (l&1)return /*cerr<<\"calc:\"<<l<<\" \"<<r<<\" \"<<sodd[r]-sodd[l-1]<<endl,*/sodd[r]-sodd[l-1];else return seven[r]-seven[l-1];\n}\nint dfs(int l,int r){\n\tif (l>r)return 0;if (vis[l][r])return f[l][r];vis[l][r]=true;\n\trep(i,l,r){\n\t\tint ind=i;\n\t\tint resl=0,resr=0;\n\t\tresl=calcl(ind,l)+(((ind-l+1)&1)?(s[r]-s[ind]-dfs(ind+1,r)):dfs(ind+1,r));\n\t\tresr=calcr(ind,r)+(((r-ind+1)&1)?(s[ind-1]-s[l-1]-dfs(l,ind-1)):dfs(l,ind-1));\n\t\t// cerr<<l<<\" \"<<r<<\" \"<<ind<<\" \"<<resl<<\" \"<<resr<<endl;\n\t\tint res=0;if (l==ind)res=resr;else if (ind==r)res=resl;else res=min(resl,resr);\n\t\tf[l][r]=max(f[l][r],res);\n\t\t\n\t}\n\t// cerr<<l<<\" \"<<r<<\" \"<<f[l][r]<<endl;\n\treturn f[l][r];\n}\nint main(){\n\tscanf(\"%d\",&n);rep(i,1,n)scanf(\"%d\",&s[i]);\n\tfor (int i=1;i<=n;i+=2)sodd[i]=s[i];\n\tfor (int i=2;i<=n;i+=2)seven[i]=s[i];\n\trep(i,1,n)s[i]+=s[i-1],sodd[i]+=sodd[i-1],seven[i]+=seven[i-1];\n\tprintf(\"%d %d\\n\",dfs(1,n),s[n]-dfs(1,n));return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[300005];\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t}\n\telse{\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tif(c-b >= 1005){\n\t\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t\t\treturn 0;\n\t\t}\n\t\tint lb = 0,ub = 1007;\n\t\twhile(ub-lb>1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tif(c >= b+mid){\n\t\t\t\tlb = mid; continue;\n\t\t\t}\n\t\t\tpriority_queue<P1>que;\n\t\t\tpriority_queue<P,vector<P>,greater<P> >que2;\n\t\t\twhile(!que.empty()) que.pop();\n\t\t\twhile(!que2.empty()) que2.pop();\n\t\t\tint zan = c-b;\n\t\t\tint lazy = 0;\n\t\t\tint cur = 0;\n\t\t\trepn(i,n){\n\t\t\t\tif(i%2 == 1) cur += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(cur>=mid){\n\t\t\t\t\t\tque2.push(mp(cur-a[i],i));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tque.push(mp(cur,mp(cur-a[i],i)));\n\t\t\t\t\t}\n\t\t\t\t\tcur -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint pre = -1;\n\t\t\twhile(1){\n\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t}\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP1 p = que.top();\n\t\t\t\t\tif(p.sc.sc<=pre){\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy >= mid){\n\t\t\t\t\t\tque2.push(p.sc);\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbool ok = 0;\n\t\t\t\twhile(!que2.empty()){\n\t\t\t\t\tP p = que2.top();\n\t\t\t\t\tif(p.sc<=pre){\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy>=0){\n\t\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlazy = p.fi;\n\t\t\t\t\t\tpre = p.sc;\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t\tok = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tub = mid;\n\t\t\tfail:;\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",lb+b,c-lb);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MAXN = 3000;\nint a[MAXN + 5], sum[2][MAXN + 5];\nint dp[MAXN + 5][MAXN + 5][2];\n//先手-0，后手-1 \nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum[i&1][i] = sum[i&1][i-1] + a[i];\n\t\tsum[i&1^1][i] = sum[i&1^1][i-1];\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tdp[i][i][0] = a[i];\n\tfor(int l=2;l<=N;l++) {\n\t\tfor(int i=1;i+l-1<=N;i++) {\n\t\t\tint j = i+l-1;\n\t\t\tif( sum[i&1][j] - sum[i&1][i-1] > sum[j&1][j] - sum[j&1][i-1] ) {\n\t\t\t\tdp[i][j][0] = sum[i&1][j] - sum[i&1][i-1];\n\t\t\t\tdp[i][j][1] = sum[i&1^1][j] - sum[i&1^1][i-1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j][0] = sum[j&1][j] - sum[j&1][i-1];\n\t\t\t\tdp[i][j][1] = sum[j&1^1][j] - sum[j&1^1][i-1];\n\t\t\t}\n\t\t\tfor(int k=i+1;k<=j-1;k++) {\n\t\t\t\tint p = dp[i][k-1][(j-k)&1] + sum[(k+1)&1][j] - sum[(k+1)&1][k];\n\t\t\t\tint q = dp[k+1][j][(k-i)&1] + sum[(k+1)&1][k-1] - sum[(k+1)&1][i-1];\n\t\t\t\tif( p > q ) {\n\t\t\t\t\tint r = dp[i][k-1][(j-k)&1^1] + sum[(k+1)&1^1][j] - sum[(k+1)&1^1][k] + a[k];\n\t\t\t\t\tif( r > dp[i][j][0] ) {\n\t\t\t\t\t\tdp[i][j][0] = r;\n\t\t\t\t\t\tdp[i][j][1] = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint r = dp[k+1][j][(k-i)&1^1] + sum[(k+1)&1^1][k-1] - sum[(k+1)&1^1][i-1] + a[k];\n\t\t\t\t\tif( r > dp[i][j][0] ) {\n\t\t\t\t\t\tdp[i][j][0] = r;\n\t\t\t\t\t\tdp[i][j][1] = q;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", dp[1][N][0], dp[1][N][1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\nusing namespace std;\n#define re register\n#define cmax(a,b) ((a)>(b)?(a):(b))\nint a[300100],c[300100],n;\nbool check(re int x)\n{\n\tint x1=0;\n\tfor(re int i=2;i<=n;i+=2)\n\t{\n\t\tx1+=a[i-1];\n\t\tif(x1>=x&&x1<a[i])x1=0;\n\t\telse x1-=a[i];\n\t}x1+=a[n];\n\treturn (x1>=x);\n}\nint main()\n{\n\tre int w=0;\n\tscanf(\"%d\",&n);\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);w+=a[i];c[i]=a[i];\n\t\tif(i>2)c[i]+=c[i-2];\n\t}if(n&1)\n\t{\n\t\tre int l=0,r=w;\n\t\tfor(re int mid=(l+r+1)>>1;l<r;mid=(l+r+1)>>1)\n\t\t{\n\t\t\tif(check(mid))l=mid;else r=mid-1;\n\t\t}printf(\"%d %d\\n\",l+c[n-1],w-l-c[n-1]);\n\t}\n\telse \n\t{\n\t\tif(c[n-1]>c[n])printf(\"%d %d\",c[n-1],c[n]);\n\t\telse printf(\"%d %d\",c[n],c[n-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define maxn 1005\nint f[maxn][maxn],s[maxn],sodd[maxn],seven[maxn],n;bool vis[maxn][maxn];\nint calcl(int r,int l){\n\tif (r&1)return sodd[r]-sodd[l-1];else return seven[r]-seven[l-1];\n}\nint calcr(int l,int r){\n\tif (l&1)return sodd[r]-sodd[l-1];else return seven[r]-seven[l-1];\n}\nint dfs(int l,int r){\n\tif (l>r)return 0;if (vis[l][r])return f[l][r];vis[l][r]=true;\n\trep(i,l,r){\n\t\tint ind=i;\n\t\tint resl=0,resr=0;\n\t\tresl=calcl(ind,l)+(((ind-l+1)&1)?(s[r]-s[ind]-dfs(ind+1,r)):dfs(ind+1,r));\n\t\tresr=calcr(ind,r)+(((r-ind+1)&1)?(s[ind-1]-s[l-1]-dfs(l,ind-1)):dfs(l,ind-1));\n\t\t// cerr<<l<<\" \"<<r<<\" \"<<ind<<\" \"<<resl<<\" \"<<resr<<endl;\n\t\tint res=0;if (l==ind)res=resr;else if (ind==r)res=resl;else res=min(resl,resr);\n\t\tf[l][r]=max(f[l][r],res);\n\t\t\n\t}\n\t// cerr<<l<<\" \"<<r<<\" \"<<f[l][r]<<endl;\n\treturn f[l][r];\n}\nint main(){\n\tscanf(\"%d\",&n);if (n>1000)return printf(\"%d %d\\n\",0,0),0;rep(i,1,n)scanf(\"%d\",&s[i]);\n\tfor (int i=1;i<=n;i+=2)sodd[i]=s[i];\n\tfor (int i=2;i<=n;i+=2)seven[i]=s[i];\n\trep(i,1,n)s[i]+=s[i-1],sodd[i]+=sodd[i-1],seven[i]+=seven[i-1];\n\tprintf(\"%d %d\\n\",dfs(1,n),s[n]-dfs(1,n));return 0;\n}*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define per(i,a,b) for (int i=b;i>=b;i--)\n\n#define maxn 300005\nconst int inf=(int)1e9;\nint s[maxn],sodd[maxn],seven[maxn],n;\nint calc(int l,int r){\n\tif (l>r)return inf;else return (sodd[r]-sodd[l-1])-(seven[r]-seven[l-1]);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t\tscanf(\"%d\",&s[i]);\n\t\tif (i&1)sodd[i]=s[i];else seven[i]=s[i];\n\t}\n\trep(i,1,n){\n\t\ts[i]+=s[i-1];\n\t\tsodd[i]+=sodd[i-1];\n\t\tseven[i]+=seven[i-1];\n\t}\n\tint res=0;\n\tif (~n&1)res=max(sodd[n],seven[n]);\n\telse{\n\t\t// res=sodd[n];\n\t\tfor (int i=0;i<=n;i+=2){\n\t\t\tif (calc(i+1,n)<=calc(1,i-1))res=max(res,sodd[n]-sodd[i]+seven[i]);\n\t\t\tint l=0,r=(n-i-3)/2;//i+1,n-2\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=(l+r)>>1;int m=i+1+2*mid;\n\t\t\t\tif (calc(i+1,m)<=min(calc(1,i-1),calc(m+2,n)))l=mid+1;else r=mid-1;\n\t\t\t}\n\t\t\tif (r>=0)res=max(res,seven[i]+seven[n]-seven[i+1+2*r]+sodd[i+1+2*r]-sodd[i-1]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",res,s[n]-res);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint a[300005];\nint jival,ouval;\n\nbool isok(int mid) {\n\tint vv = a[1];\n\tfor(int i=3;i<=n;i+=2) {\n\t\tif(vv>=mid) {\n\t\t\tvv = max(vv+a[i]-a[i-1],a[i]);\n\t\t} else vv = vv + a[i] - a[i-1];\n\t}\n\treturn vv>=mid;\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i&1) jival += a[i];\n\t\telse ouval += a[i];\n\t}\n\tif(!(n&1)) {\n\t\tprintf(\"%d %d\",max(jival,ouval),min(jival,ouval));\n\t\treturn 0;\n\t}\n\tint l = 0; int r = jival , mid , ans = 0;\n\twhile(l<=r) {\n\t\tmid = (l+r)>>1;\n\t\tif(isok(mid)) {\n\t\t\tans = mid , l = mid + 1;\n\t\t} else r = mid - 1;\n\t}\n\tprintf(\"%d %d\",ouval+ans,jival-ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, a[303030], b[303030], S;\n\nstruct Segtree{\n    long long N, M;\n    long long mnm[1048576], mxm[1048576];\n    void init(){\n        for(int i = 0; i < M; ++i)mnm[i + N] = mxm[i + N] = b[i];\n        for(int i = N - 1; i; --i){\n            mnm[i] = min(mnm[2 * i], mnm[2 * i + 1]);\n            mxm[i] = max(mxm[2 * i], mxm[2 * i + 1]);\n        }\n    }\n    Segtree(long long _N) : mnm(), mxm(){\n        N = 1;\n        M = _N;\n        while(N < _N)N *= 2;\n    }\n    long long mnn(long long L, long long R){\n        L += N;\n        R += N;\n        long long ret = 189501249917890;\n        while(L < R){\n            if(L & 1){\n                ret = min(ret, mnm[L]);\n                ++L;\n            }\n            if(R & 1){\n                ret = min(ret, mnm[R - 1]);\n            }\n            L /= 2;\n            R /= 2;\n        }\n        return ret;\n    }\n    long long mxx(long long L, long long R){\n        L += N;\n        R += N;\n        long long ret = -189501249917890;\n        while(L < R){\n            if(L & 1){\n                ret = max(ret, mxm[L]);\n                ++L;\n            }\n            if(R & 1){\n                ret = max(ret, mxm[R - 1]);\n            }\n            L /= 2;\n            R /= 2;\n        }\n        return ret;\n    }\n};\n\nSegtree sgt(524288);\n\nint main(){\n    scanf(\"%lld\", &N);\n    assert(N & 1);\n    if(N & 1){\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + i);\n            S += a[i];\n            a[i] *= (i & 1) ? -1 : 1;\n        }\n        partial_sum(a, a + N, b + 1);\n        long long ans = b[N];\n        for(int i = 0; i < N; ++i)cout << a[i] << \" \";\n        cout << endl;\n        for(int i = 0; i <= N; ++i)cout << b[i] << \" \";\n        cout << endl;\n        sgt.init();\n        for(int i = 1; i < N; i += 2){\n            ans = max(ans, -b[N] + 2 * min(sgt.mxx(i + 1, N + 1) - b[i + 1], b[i] - sgt.mnn(0, i)));\n        }\n        cout << (S + ans) / 2 << \" \" << (S - ans) / 2 << endl;\n    }else{\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + 4);\n            a[i & 1] += a[4];\n        }\n        if(a[0] < a[1])swap(a[0], a[1]);\n        cout << a[0] << \" \" << a[1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nint n,m,i,j,a[300005];\nlong long s[300005],s0,s1,l,r,mid,ans;\nbool check(long long x){\n\tlong long mi=0;\n\tint i;\n\tfor(i=2;i<=n;i+=2){\n\t\tif(s[i-1]-mi>=x){\n\t\t\tmi=min(mi,s[i]);\n\t\t}\n\t}\n\treturn s[n]-mi>=x;\n}\nint main(){\n\tcin>>n;\n\trep(i,n){\n\t\tcin>>a[i];\n\t\ts[i]=s[i-1];\n\t\tif(i&1) s[i]+=a[i]; else s[i]-=a[i];\n\t\tif(i&1) s1+=a[i]; else s0+=a[i];\n\t}\n\tif(n%2==0){\n\t\tcout<<max(s0,s1)<<' '<<min(s0,s1)<<endl;\n\t\treturn 0;\n\t}\n\tl=-(s0+s1);r=s0+s1;\n\twhile(l<r){\n\t\tmid=((l+r)>>1);\n\t\tif(check(mid)){\n\t\t\tl=mid+1;\n\t\t\tans=mid;\n\t\t}\n\t\telse r=mid;\n\t}\n\tcout<<s0+ans<<' '<<s1-ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint n;\nint seq[300050];\n\nbool chk(int mid)\n{\n\tint val = seq[1];\n\tfor(int i = 2;i <= n; i += 2)\n\t{\n\t\tif(val >= mid) val = max(val + seq[i + 1] - seq[i],seq[i + 1]);\n\t\telse val += seq[i + 1] - seq[i];\n\t}\n\treturn val >= mid;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint ji = 0,ou = 0;\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tscanf(\"%d\",&seq[i]);\n\t\tif(i % 2) ji += seq[i];\n\t\telse ou += seq[i];\n\t}\n\tif(n % 2 == 0)\n\t{\n\t\tprintf(\"%d %d\\n\",max(ji,ou),min(ji,ou));\n\t}\n\telse\n\t{\n\t\tint l = 0,r = 300000000,ans;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif(chk(mid)) ans = mid,l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",ou + ans,ji - ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#define lowbit(x) ((x)&-(x))\ntypedef long long ll;\nconst int N=3e5+5,M=3e6+5;\nconst ll inf=1ll<<40;\nll a[N],s[N],f[N],g[N],b[N];int n,m,rk[N];\ntemplate<class T>T abs(T x){return x<0?-x:x;}\ntemplate<class T>bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>T min(T a,T b){return a<b?a:b;}\ntemplate<class T>T div2(T x){return (x-(x&1))/2;}\ninline void init(){\n\tstd::reverse(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)s[i]=s[i-1]+((i&1)?-a[i]:a[i]);\n}\nstruct node{\n\tnode*c[2];\n\tint size;\n\tll v1,v2,key,x1,x2;\n\tnode();\n\tvoid pushup();\n}Tnull,*null=&Tnull,pl[M],*rt[N];int pp;\nnode::node(){\n\tc[0]=c[1]=null;\n\tv1=v2=x1=x2=key=size=0;\n}\nvoid node::pushup(){\n\tsize=c[0]->size+c[1]->size+1;\n\tx1=v1,x2=v2;\n\tif(c[0]!=null)chkmax(x1,c[0]->x1),chkmax(x2,c[0]->x2); \n\tif(c[1]!=null)chkmax(x1,c[1]->x1),chkmax(x2,c[1]->x2);\n}\nvoid rot(node*&x,bool f){\n\tnode*y=x->c[f];\n\tx->c[f]=y->c[f^1],y->c[f^1]=x;\n\tx->pushup(),x=y,x->pushup(); \n}\nvoid insert(node*&x,node*y){\n\tif(x==null){\n\t\tx=y,x->c[0]=x->c[1]=null,x->pushup();\n\t\treturn;\n\t}\n\tbool f=x->key<y->key;\n\tinsert(x->c[f],y);\n\tif(x->c[f]->size>(x->size+1)*0.75)rot(x,f);else x->pushup();\n}\nll ask(node*x,ll cut){\n\tif(x==null)return -inf;\n\tll res=-inf;\n\tif(x->key<=cut){\n\t\tchkmax(res,x->v1-cut);\n\t\tif(x->c[0]!=null)chkmax(res,x->c[0]->x1-cut);\n\t\tchkmax(res,ask(x->c[1],cut));\n\t}else{\n\t\tchkmax(res,x->v2+cut);\n\t\tif(x->c[1]!=null)chkmax(res,x->c[1]->x2+cut);\n\t\tchkmax(res,ask(x->c[0],cut));\n\t}\n\treturn res;\n}\ninline void calc(ll*f){\n\tint i,x;\n\tfor(m=0,i=1;i<=n;i++)b[++m]=s[i];\n\tstd::sort(b+1,b+m+1),m=std::unique(b+1,b+m+1)-b-1;\n\tfor(i=1;i<=n;i++)rk[i]=m-(std::lower_bound(b+1,b+m+1,s[i])-b)+1;\n\tpp=0;\n\tfor(i=1;i<=m;i++)rt[i]=null;\n\tfor(i=1;i<=n;i+=2){\n\t\tf[i]=abs(s[i]);\n\t\tfor(x=rk[i]-1;x;x-=lowbit(x))chkmax(f[i],ask(rt[x],s[i]));\n\t\tif(i<n){\n\t\t\tfor(x=rk[i+1];x<=m;x+=lowbit(x)){\n\t\t\t\tnode*z=pl+(pp++);\n\t\t\t\tz->key=div2(2*s[i+1]+s[i]-f[i]);\n\t\t\t\tz->v1=2*s[i+1],z->v2=f[i]-s[i];\n\t\t\t\tinsert(rt[x],z);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tll dif=0,sum=0;\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",a+i),dif+=(i&1)?a[i]:-a[i],sum+=a[i];\n\tdif=abs(dif);\n\tif(n&1){\n\t\tstd::reverse(a+1,a+n+1);\n\t\tinit(),calc(f),init(),calc(g),init();\n\t\tstd::reverse(g+1,g+n+1);\n\t\tfor(i=2;i<n;i+=2)chkmax(dif,a[i]+min(s[i-1]+g[i+1],f[i-1]+s[n]-s[i]));\n\t}\n\tll sigma=(sum-dif)>>1,sugim=sigma+dif;\n\tprintf(\"%lld %lld\\n\",sugim,sigma);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 300010\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint sum[N];\ninline int check(int dat,int n) {\n    int Min=0;\n    for (int i=2;i<=n;i+=2) \n        if (dat<=sum[i-1]-Min) Min=min(Min,sum[i]);\n    return dat<=sum[n]-Min;\n}\nint main() {\n    int n=read(),A=0,B=0;\n    for (int i=1;i<=n;i++) {\n        int dat=read(); sum[i]=sum[i-1];\n        if (i&1) A+=dat,sum[i]+=dat; else B+=dat,sum[i]-=dat;\n    }\n    if (!(n&1)) return printf(\"%d %d\",max(A,B),min(A,B)),0;\n    int l=-1e8,r=1e8,ans=0;\n    while (l<=r) {\n        int mid=(l+r)>>1;\n        if (check(mid,n)) ans=mid,l=mid+1; else r=mid-1;\n    }\n    printf(\"%d %d\",max(A,B+ans),A+B-max(A,B+ans));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, x, n) for (int i = int(x); i <= int(n); ++i)\n#define for1(i, n, x) for (int i = int(n); i >= int(x); --i)\n#define x first\n#define y second\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef long double ld;\ntypedef vector <ll> vi;\n\nconst int N = 2e6 + 1;\nconst int K = 2e3 + 1;\nconst int INF = 1e9 + 9;\nconst int B = 1e9 + 7;\n\nint n, a[N];\nint s[N];\nint d[K][K];\n\nint main() {\n    #ifdef black\n    freopen(\"in\", \"r\", stdin);\n    #endif // black\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n;\n    forn(i, 1, n) {\n        cin >> a[i];\n        s[i] = s[i - 1] + a[i] * (i % 2 ? -1 : 1);\n    }\n    ll sum = 0;\n    forn(i, 1, n) sum += a[i];\n\n    forn(len, 1, n) {\n        forn(l, 1, n - len + 1) {\n            int r = l + len - 1;\n            d[l][r] = -sum;\n            forn(k, l, r) {\n                int prx = (s[k] - s[l - 1]) * (k % 2 ? -1 : 1) + d[k + 1][r] * ((k - l) % 2 ? 1 : -1);\n                int sux = (s[r] - s[k - 1]) * (k % 2 ? -1 : 1) + d[l][k - 1] * ((r - k) % 2 ? 1 : -1);\n\n                if (k == l) d[l][r] = max(d[l][r], sux);\n                else\n                if (k == r) d[l][r] = max(d[l][r], prx);\n                else\n                d[l][r] = max(d[l][r], min(prx, sux));\n            }\n        }\n    }\n\n    assert((sum - d[1][n]) % 2 == 0);\n    cout << (sum - d[1][n]) / 2 + d[1][n] << \" \" << (sum - d[1][n]) / 2 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\nusing namespace std;\n#define re register\n#define cmax(a,b) ((a)>(b)?(a):(b))\nint a[300100],c[300100],n;\nbool check(re int x)\n{\n\tint x1=0;\n\tfor(re int i=2;i<=n;i+=2)\n\t{\n\t\tx1+=a[i-1];\n\t\tif(x1>=x&&x1<a[i])x1=0;\n\t\telse x1-=a[i];\n\t}x1+=a[n];\n\treturn (x1>=x);\n}\nint main()\n{\n\tre int w=0;\n\tscanf(\"%d\",&n);\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);w+=a[i];c[i]=a[i];\n\t\tif(i>1)c[i]+=c[i-2];\n\t}if(n&1)\n\t{\n\t\tre int l=0,r=w;\n\t\tfor(re int mid=(l+r+1)>>1;l<r;mid=(l+r+1)>>1)\n\t\t{\n\t\t\tif(check(mid))l=mid;else r=mid-1;\n\t\t}printf(\"%d %d\\n\",l+c[n-1],w-l-c[n-1]);\n\t}\n\telse \n\t{\n\t\tif(a[n-1]>a[n])printf(\"%d %d\",c[n-1],c[n]);\n\t\telse printf(\"%d %d\",c[n],c[n-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nconst int nax=1000*1007;\n\nint n;\nll tab[nax];\n\nll s;\n\nll pre[nax];\nll suf[nax];\n\nvoid wypisz(ll v)\n{\n\tdebug() << imie(v);\n\tprintf(\"%lld %lld\\n\", (s+v)/2, (s-v)/2);\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%lld\", &tab[i]);\n\t\ts+=tab[i];\n\t}\n\tll x=0;\n\tfor (int i=1; i<=n; i+=2)\n\t\tx+=tab[i];\n\tif (!(n&1))\n\t\twypisz(max(x, s-x)-min(x, s-x));\n\tll wyn=max(x, s-x)-min(x, s-x);\n\tfor (int i=1; i<=n; i++)\n\t\tpre[i]=tab[i]-pre[i-1];\n\tfor (int i=n; i; i--)\n\t\tsuf[i]=tab[i]-suf[i+1];\n\tfor (int i=2; i<=n; i+=2)\n\t\twyn=max(wyn, min(pre[i]+abs(suf[i+1]), abs(pre[i-1])+suf[i]));\n\twypisz(wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint n,a[300005],b[300005],w[300005],f[300005],x;\nbool check(int v)\n{\n\tmemset(f,0,sizeof(f));\n\tf[0]=1;\n\tx=0;\n\tfor(int i=1;i<=n;i+=2)\n\t{\n\t\tif(w[i]-b[i]-x<=v)\n\t\t{\n\t\t\tf[i]=1;\n\t\t\tx=max(x,w[i+1]-b[i+1]);\n\t\t}\n\t}\n\treturn f[n];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tb[i]=b[i-1],w[i]=w[i-1];\n\t\tif(i&1)b[i]+=a[i];\n\t\telse w[i]+=a[i];\n\t}\n\tif(n%2==0)return printf(\"%d %d\\n\",max(b[n],w[n]),min(b[n],w[n])),0;\n\tint l=-w[n]-b[n],r=w[n]+b[n];\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",w[n]-l,b[n]+l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=300005;\nint a[MAXN],n;\nLL pres[MAXN];\nbool check(LL S)\n{\n\tint P=0;\n\tfor(int i=1;i<=n;i+=2)if(pres[i]-pres[P]>=S&&pres[P]>=pres[i+1])\n\t\tP=i+1;\n\treturn pres[n]-pres[P]>=S;\n}\nint main()\n{\n\tn=read();for(int i=1;i<=n;i++)a[i]=read();\n\tif(!(n&1))\n\t{\n\t\tint s1=0,s2=0;\n\t\tfor(int i=1;i<=n;i++)(i&1)?(s1+=a[i]):(s2+=a[i]);\n\t\tpr1(max(s1,s2));pr2(min(s1,s2));\n\t}\n\telse\n\t{\n\t\tfor(int i=1;i<=n;i++)pres[i]=pres[i-1]+((i&1)?a[i]:-a[i]);\n\t\tLL l=1,r=1LL*n*1000,ans=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(check(mid))ans=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tLL s1=0,s2=0;\n\t\tfor(int i=1;i<=n;i++)if(!(i&1))s1+=a[i];\n\t\tfor(int i=1;i<=n;i++)s2+=a[i];\n\t\tpr1(ans+s1);pr2(s2-(ans+s1));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<int> a(n);\n        int e = 0, o = 0;\n        for (int i = 0; i < n; i ++) {\n                scanf(\"%d\", &a[i]);\n                (i & 1 ? o : e) += a[i];\n        }\n        if (n & 1) {\n                int lb = 0, ub = 100000000;\n                while (ub - lb > 1) {\n                        int mid = (lb + ub) / 2;\n                        vector<int> b = a;\n                        for (int i = 0; i < n - 1; i += 2) {\n                                if (b[i] < mid || b[i + 1] < b[i]) {\n                                        b[i + 2] += b[i] - b[i + 1];\n                                }\n                        }\n                        (b[n - 1] >= mid ? lb : ub) = mid;\n                }\n                printf(\"%d %d\\n\", lb + o, e - lb);\n        } else {\n                printf(\"%d %d\\n\", max(e, o), min(e, o));\n        }\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n; ll a[SZ],B,W;\nll qz[SZ];\nbool ok(ll t)\n{\n\tll mo=0;\n\tfor(int i=2;i<=n-1;i+=2)\n\t\tif(qz[i-1]-mo>=t) mo=min(mo,qz[i]);\n\treturn qz[n]-mo>=t;\n}\nll calc()\n{\n\tll l=-1e18,r=1e18;\n\twhile(l<r)\n\t{\n\t\tll g=l+((r-l+1)>>1);\n\t\tif(ok(g)) l=g; else r=g-1;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",a+i);\n\t\tif(i%2==0) W+=a[i],qz[i]=qz[i-1]-a[i];\n\t\telse B+=a[i],qz[i]=qz[i-1]+a[i];\n\t}\n\tif(n%2==0)\n\t{\n\t\tprintf(\"%lld %lld\\n\",max(W,B),min(W,B));\n\t\treturn 0;\n\t}\n\tll ans=max(B,W+calc());\n\tprintf(\"%lld %lld\\n\",ans,B+W-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\nusing namespace std;\n#define N 300010\nll a[N],n;\nbool solve(ll x){\n  vector<ll> v;\n  for(int i=0;i<n;i++)v.push_back(a[i]);\n  while(v.size()>1){\n    ll w=v[v.size()-1];\n    ll b=v[v.size()-2];\n    if(b<w||w<x)v[v.size()-3]+=w-b;\n    v.pop_back();v.pop_back();\n  }\n  return x<=v[0];\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++)cin>>a[i];\n    ll l=0,r=1e15,m;\n    while(l<r-1){\n      m=(l+r)/2;\n      if(solve(m))l=m;\n      else r=m;\n    }\n    ll vl=0,vr=0;\n    for(int i=0;i<n;i++){\n      if(i&1)vl+=a[i];\n      else vr+=a[i];\n    }\n    if(n&1)cout<<vl+l<<\" \"<<vr-l<<endl;\n    else cout<<max(vl,vr)<<\" \"<<min(vl,vr)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=300000 +117;\nconst int MM=300000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nint a[NN]={};\nint pre[NN]={};\nbool chk(int x){\n\tint mii=0;\n\tfor(int i=2;i<=n;i+=2){\n\t\tif(pre[i-1]-mii>=x){\n\t\t\tmii=min(mii,pre[i]);\n\t\t}\n\t}\n\treturn pre[n]-mii>=x;\n}\nint main(){\n\t//open();\n\tn=read();\n\tint s=0;\n\tint s1=0;\n\tint s2=0;\n\tfor(int i=1;i<=n;++i){\n\t\ta[i]=read();\n\t\ts+=a[i];\n\t\tpre[i]=a[i];\n\t\tif(i&1){\n\t\t\ts1+=a[i];\n\t\t}\n\t\telse{\n\t\t\ts2+=a[i];\n\t\t\tpre[i]=-pre[i];\n\t\t}\n\t\tpre[i]+=pre[i-1];\n\t}\n\tint ans=max(s1,s2);\n\tif(n&1){\n\t\tint l=0,r=s;\n\t\twhile(l!=r){\n\t\t\tint mid=(l+r+1)>>1;\n\t\t\tif(chk(mid)){\n\t\t\t\tl=mid;\n\t\t\t}\n\t\t\telse r=mid-1;\n\t\t}\n\t\tans=max(ans,s2+l);\n\t}\n\tprintf(\"%d %d\\n\",ans,s-ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\nint tot;\nvoid out(int ans) {\n  int a = (tot+ans)/2;\n  int b = tot-a;\n  cout<<a<<\" \"<<b<<endl;\n}\n\nbool f(vi& s, vi& t, int x) {\n  int n = sz(s);\n  int l = s[0];\n  rep(i,n) {\n    if (t[i] >= l+x) {\n      if (i == n-1) return true;\n      // mins(l,s[i]);\n      mins(l,s[i+1]);\n    }\n  }\n  return false;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n);\n  cin>>a;\n  tot = suma(a);\n  a.insert(a.begin(),0);\n  rep(i,n) if (i&1) a[i+1] *= -1;\n  rep(i,n) a[i+1] += a[i];\n  if (n%2 == 0) {\n    int ans = abs(a.back());\n    out(ans);\n    return 0;\n  }\n  vi s, t;\n  rep(i,n+1) {\n    if (i&1) {\n      t.pb(a[i]);\n    } else {\n      s.pb(a[i]);\n    }\n  }\n  int l = -INF, r = INF;\n  while (l+1<r) {\n    int c = (l+r)>>1;\n    if (f(s,t,c)) l = c; else r = c;\n  }\n  // cerr<<l<<endl;\n  int ans = -a.back() + l*2;\n  out(ans);\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0 , f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 3e5 + 5;\nint n;\nint W , B;\nint a[N] , sum[N];\ninline bool check(int mid)\n{\n\tint minn = 0;\n\tfor(int i = 2;i < n;i += 2) if(sum[i - 1] - minn >= mid) minn = min(minn,sum[i]);\n\treturn sum[n] - minn >= mid;\n}\nint main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\ta[i] = read();\n\t\tif(i & 1) B += a[i] , sum[i] += a[i];\n\t\telse W += a[i] , sum[i] -= a[i];\n\t}\n\tif(!(n & 1)) printf(\"%d %d\\n\",max(B,W),min(B,W));\n\telse\n\t{\n\t\tint l = -3e8 , r = 3e8 , ans = 0;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif(check(mid)) ans = mid , l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tint res = max(W + ans,B);\n\t\tprintf(\"%d %d\\n\",res,W + B - res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for (int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 3e5 + 10;\n\nint n;\nint A[N], sumw[N], sumb[N];\n\nbool check(int x) {\n\tint cur = A[1];\n\tFor(i, 1, n - 1) if (i % 2 == 0) {\n\t\tif (cur >= x) cur = max(cur - A[i], 0);\n\t\telse cur -= A[i];\n\t\tcur += A[i + 1];\n\t}\n\treturn cur >= x;\n}\n\nint main() {\n\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tsumb[i] = sumb[i - 1] + (i & 1 ? A[i] : 0);\n\t\tsumw[i] = sumw[i - 1] + (!(i & 1) ? A[i] : 0);\n\t}\n\n\tif (n % 2 == 0) {\n\t\tprintf(\"%d %d\\n\", max(sumb[n], sumw[n]), min(sumb[n], sumw[n]));\n\t\treturn 0;\n\t}\n\n\tint L = 0, R = sumb[n];\n\twhile (L < R) {\n\t\tint mid = (L + R + 1) >> 1;\n\t\tif (check(mid)) L = mid;\n\t\telse R = mid - 1;\n\t}\n\tprintf(\"%d %d\\n\", sumw[n] + L, sumb[n] - L);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nll f[300001];\n\nvoid init() {\n\tf[1] = 1;\n\tll ma = 0;\n\tfor (int i = 3; i <= 300000; i += 2) {\n\t\tint d = i / 2;\n\t\tif (d % 2 == 0) {\n\t\t\tf[i] = 2 * (f[d - 1] + f[d + 1]);\n\t\t}\n\t\telse {\n\t\t\tf[i] = f[d] + f[d];\n\t\t}\n\t\tma = max(ma, f[i]);\n\t}\n\tcout << ma << \"\\n\";\n}\n\nvoid solve() {\n\n\n\n\tint n; cin >> n;\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tint sum = 0;\n\trep(i, n)sum += a[i];\n\n\tif (n % 2 == 0) {\n\t\tint s1 = 0, s2 = 0;\n\t\tfor (int i = 0; i < n; i += 2)s1 += a[i];\n\t\tfor (int i = 1; i < n; i += 2)s2 += a[i];\n\t\tint ans1 = max(s1, s2);\n\t\tint ans2 = sum - ans1;\n\t\tcout << ans1 << \" \" << ans2 << \"\\n\";\n\t}\n\telse {\n\t\tvector<vector<int>> ra(n + 1,vector<int>(2));\n\t\trep(i, n) {\n\t\t\tra[i + 1] = ra[i];\n\t\t\tra[i + 1][i%2] += a[i];\n\t\t}\n\t\tmap<P, bool> used;\n\t\tmap<P, int> memo;\n\t\tfunction<int(int, int)> dfs = [&](int l, int r)->int{\n\t\t\tif (used[{l, r}])return memo[{l, r}];\n\t\t\tused[{l, r}] = true;\n\t\t\tint res = ra[r + 1][l%2] - ra[l][l%2];\n\t\t\tif (l == r) {\n\t\t\t\tres = a[l];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint res1 = mod, res2 = mod;\n\t\t\t\tint len = (r - l + 1);\n\t\t\t\tif (len % 4 == 3) {\n\t\t\t\t\tint d = len / 2;\n\t\t\t\t\tint m = l + d;\n\t\t\t\t\tres1 = min(res1, dfs(l, m - 1) + ra[r + 1][m%2] - ra[m][m%2]);\n\t\t\t\t\tres1 = min(res1, dfs(m + 1, r) + ra[m + 1][m%2] - ra[l][m%2]);\n\t\t\t\t\tres = max(res, res1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int ex = -(len/2-1); ex <= len/2-1; ex += 2) {\n\t\t\t\t\t\tint d = len / 2 + ex;\n\t\t\t\t\t\tint m = l + d;\n\t\t\t\t\t\tres1 = mod;\n\t\t\t\t\t\tres1 = min(res1, dfs(l, m - 1) + ra[r + 1][m%2] - ra[m][m%2]);\n\t\t\t\t\t\tres1 = min(res1, dfs(m + 1, r) + ra[m + 1][m%2] - ra[l][m%2]);\n\t\t\t\t\t\tres = max(res, res1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << l << \" \" << r << \" \" << res << \"\\n\";\n\t\t\treturn memo[{l, r}] = res;\n\t\t};\n\t\tint ans = dfs(0, n - 1);\n\t\tcout << ans << \" \"<<sum-ans<<\"\\n\";\n\t}\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n; ll a[SZ],B,W;\nll qz[SZ];\nbool ok(ll t)\n{\n\tll mo=0;\n\tfor(int i=2;i<=n-1;i+=2)\n\t\tif(qz[i-1]-mo>=t) mo=min(mo,qz[i]);\n\treturn qz[n]-mo>=t;\n}\nll calc()\n{\n\tll l=0,r=1e18;\n\twhile(l<r)\n\t{\n\t\tll g=(l+r+1)>>1;\n\t\tif(ok(g)) l=g; else r=g-1;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",a+i);\n\t\tif(i%2==0) W+=a[i],qz[i]=qz[i-1]-a[i];\n\t\telse B+=a[i],qz[i]=qz[i-1]+a[i];\n\t}\n\tif(n%2==0)\n\t{\n\t\tprintf(\"%lld %lld\\n\",max(W,B),min(W,B));\n\t\treturn 0;\n\t}\n\tll ans=max(B,W+calc());\n\tprintf(\"%lld %lld\\n\",ans,B+W-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=300005;\nint n;\nint a[N],s[N];\nbool check(int x){\n    int v=0;\n    for (int i=1;i<n;i+=2)\n        if (s[i]-v>=x)\n            v=min(v,s[i+1]);\n    return s[n]-v>=x;\n}\nint main(){\n    n=read();\n    For(i,1,n)\n        a[i]=read();\n    if (n%2==0){\n        int s0=0,s1=0;\n        For(i,1,n)\n            if (i&1)\n                s0+=a[i];\n            else\n                s1+=a[i];\n        cout<<max(s0,s1)<<\" \"<<min(s0,s1)<<endl;\n        return 0;\n    }\n    For(i,1,n)\n        if (i&1)\n            s[i]=s[i-1]+a[i];\n        else\n            s[i]=s[i-1]-a[i];\n    int L=1,R=n*1000,mid,ans=L;\n    while (L<=R){\n        mid=(L+R)>>1;\n        if (check(mid))\n            L=mid+1,ans=mid;\n        else\n            R=mid-1;\n    }\n    For(i,1,n)\n        if (i%2==0)\n            ans+=a[i];\n    int s=0;\n    For(i,1,n)\n        s+=a[i];\n    cout<<ans<<\" \"<<s-ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long int N;\n\n\nint checkif(long long int arr[],long long int N,int num){\nfor(long long int i=0;i<N;i++){\n    if(arr[i]==num){\n        return 1;\n    }\n}\nreturn 0;\n}\n\nint find_adjacent(long long int i,long long int flag[]){\nif(i-1>=0  && flag[i-1]==0){\n    if(flag[i-1]==0){return 1;}\n    else return 0;\n}\n\nelse return 0;\n}\n\nint find_adjacent2(long long int i,long long int flag[]){\nif(i+1<=N && flag[i+1]==0){\n    if(flag[i+1]==0){return 1;}\n    else return 0;\n}\nelse return 0;\n}\n\nlong long int check_for_adjacent(long long int mini_ind_sugim,long long int arr[],long long int flag[]){\nlong long int mini2=0,temp_mini2_ind;\nif(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==1){\nif(arr[mini_ind_sugim-1]>arr[mini_ind_sugim+1]){\n     //   sigma=sigma+arr[mini_ind_sugim-1];\n       // printf(\"%lld\\n\",sigma);\n      //max_ind_sigma=mini_ind_sugim-1;\n//flag[mini_ind_sugim-1]=1;}\nreturn mini_ind_sugim-1;\n}\nelse{\n\n   // sigma=sigma+arr[mini_ind_sugim+1];\n   // printf(\"%lld\\n\",sigma);\n  //  max_ind_sigma=mini_ind_sugim+1;\n  //  flag[mini_ind_sugim+1]=1;\n  return mini_ind_sugim+1;\n}\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==0){\n   // sigma=sigma+arr[mini_ind_sugim-1];\n    //max_ind_sigma=mini_ind_sugim-1;\n    //flag[mini_ind_sugim-1]=1;\n    return mini_ind_sugim-1;\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==0 && find_adjacent2(mini_ind_sugim,flag)==1){\n    //sigma=sigma+arr[mini_ind_sugim+1];\n   // max_ind_sigma=mini_ind_sugim+1;\n    //flag[mini_ind_sugim+1]=1;\n    return mini_ind_sugim+1;\n}\nelse{\n       for(long long int i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                temp_mini2_ind=i;\n            }\n        }\n    }\n    return temp_mini2_ind;\n   // sigma=sigma+mini2;\n   // printf(\"%lld\\n\",sigma);\n    //flag[max_ind_sigma]=1;\n}\n}\n\n\nint main(){\n\nscanf(\"%lld\",&N);\nlong long int arr[N],i,maxs=2000,mini=0,mini_ind_sugim,max_ind_sigma,flag[N],arr2[N],sigma=0,sugim=0,mini2=0,mini2_ind;\nmemset(flag,0,sizeof(flag));\n\nfor(i=0;i<N;i++){\n    scanf(\"%lld\",&arr[i]);\n    arr2[i]=arr[i];\n    if(arr[i]>mini){\n        mini=arr[i];\n        mini_ind_sugim=i;\n    }\n}\n\nsugim=sugim+mini;\nflag[mini_ind_sugim]=1;\n//printf(\"%lld\\n\",sugim);\n\nif(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==1){\nif(arr[mini_ind_sugim-1]>arr[mini_ind_sugim+1]){\n        sigma=sigma+arr[mini_ind_sugim-1];\n    //    printf(\"%lld\\n\",sigma);\nmax_ind_sigma=mini_ind_sugim-1;\nflag[mini_ind_sugim-1]=1;}\nelse{\n\n    sigma=sigma+arr[mini_ind_sugim+1];\n  //  printf(\"%lld\\n\",sigma);\n    max_ind_sigma=mini_ind_sugim+1;\n    flag[mini_ind_sugim+1]=1;\n}\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==1 && find_adjacent2(mini_ind_sugim,flag)==0){\n    sigma=sigma+arr[mini_ind_sugim-1];\n    max_ind_sigma=mini_ind_sugim-1;\n    flag[mini_ind_sugim-1]=1;\n}\nelse if(find_adjacent(mini_ind_sugim,flag)==0 && find_adjacent2(mini_ind_sugim,flag)==1){\n    sigma=sigma+arr[mini_ind_sugim+1];\n    max_ind_sigma=mini_ind_sugim+1;\n    flag[mini_ind_sugim+1]=1;\n}\nelse{\n       for(i=0;i<N;i++){\n        if(flag[i]==0){\n            if(arr[i]>mini2){\n                mini2=arr[i];\n                max_ind_sigma=i;\n            }\n        }\n    }\n    sigma=sigma+mini2;\n//    printf(\"%lld\\n\",sigma);\n    flag[max_ind_sigma]=1;\n}\n\n\n\n\nint turn=0;\nwhile(checkif(flag,N,0)==1){\n      // printf(\"yessss\\n\");\n       if(turn==0){\n          //  cout<<max_ind_sigma<<endl;\n       mini_ind_sugim=check_for_adjacent(max_ind_sigma,arr,flag);\n       //cout<<mini_ind_sugim<<endl;\n       sugim=sugim+arr[mini_ind_sugim];\n       flag[mini_ind_sugim]=1;\n       turn=1;\n       }\n       else{\n            //cout<<mini_ind_sugim<<endl;\n            max_ind_sigma=check_for_adjacent(mini_ind_sugim,arr,flag);\n\n            sigma=sigma+arr[max_ind_sigma];\n            flag[max_ind_sigma]=1;\n            turn=0;\n       }\n}\n\ncout<<endl;\n\nprintf(\"%lld %lld\",sugim,sigma);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\nusing namespace std;\n#define re register\n#define cmax(a,b) ((a)>(b)?(a):(b))\nint a[300100],c[300100],n;\nbool check(re int x)\n{\n\tint x1=0;\n\tfor(re int i=2;i<=n;i+=2)\n\t{\n\t\tx1+=a[i-1];\n\t\tif(x1>=x&&x1<a[i])x1=0;\n\t\telse x1-=a[i];\n\t}x1+=a[n];\n\treturn (x1>=x);\n}\nint main()\n{\n\tre int w=0;\n\tscanf(\"%d\",&n);\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);w+=a[i];c[i]=a[i];\n\t\tif(i>1)c[i]+=a[i-2];\n\t}if(n&1)\n\t{\n\t\tre int l=0,r=w;\n\t\tfor(re int mid=(l+r+1)>>1;l<r;mid=(l+r+1)>>1)\n\t\t{\n\t\t\tif(check(mid))l=mid;else r=mid-1;\n\t\t}printf(\"%d %d\\n\",l+c[n-1],w-l-c[n-1]);\n\t}\n\telse \n\t{\n\t\tif(a[n-1]>a[n])printf(\"%d %d\",c[n-1],c[n]);\n\t\telse printf(\"%d %d\",c[n],c[n-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll> \n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1<<30)\n#define int long long\nusing namespace std;\nconst int N=300005;\nint n,a[N],B,W,s[N];\nbool ok(int t){\n\tint mn=0;\n\tfor (int i=2;i<=n-1;i+=2)\n\t\tif (s[i-1]-mn>=t) mn=min(mn,s[i]);\n\treturn s[n]-mn>=t;\n}\nint calc(){\n\tint l=-B,r=B,ans;\n\twhile (l<=r){\n\t\tint mid=((ll)l+r)/2;\n\t\tif (ok(mid)) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn ans;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tif (i%2==0) W+=a[i],s[i]=s[i-1]-a[i];\n\t\telse B+=a[i],s[i]=s[i-1]+a[i]; \n\t}\n\tif ((!n&1))\n\t\treturn printf(\"%lld %lld\\n\",max(W,B),min(W,B)),0;\n\tll ans=W+calc();\n\tprintf(\"%lld %lld\\n\",ans,(ll)B+W-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, a[300005];\nLL psum[300005];\n\nLL cmin;\nbool dp[300005];\n\nbool check(LL x)\n{\n\tcmin = 0;\n\trep1(i, n) if(i & 1) {\n\t\tdp[i] = psum[i] - x >= cmin;\n\t\tif(dp[i]) cmin = min(cmin, psum[i + 1]);\n\t}\n\treturn dp[n];\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) scanf(\"%d\", &a[i]);\n\tif(n % 2 == 0) {\n\t\tint ans0 = 0, ans1 = 0;\n\t\trep(i, n) if(i & 1) ans1 += a[i];\n\t\telse ans0 += a[i];\n\t\tprintf(\"%d %d\\n\", max(ans0, ans1), min(ans0, ans1));\n\t\treturn 0;\n\t}\n\t\n\tpsum[0] = 0;\n\trep(i, n) psum[i + 1] = psum[i] + (i & 1 ? -a[i] : a[i]);\n\tLL ans0 = 0, ans1 = 0;\n\trep(i, n) if(i & 1) ans0 += a[i];\n\telse ans1 += a[i];\n\t\n\tLL cl = 0, cr = 3e9;\n\twhile(cl < cr) {\n\t\tLL mid = cl + cr + 1 >> 1;\n\t\tif(check(mid)) cl = mid;\n\t\telse cr = mid - 1;\n\t}\n\tans0 += cr;\n\tans1 -= cr;\n\tprintf(\"%lld %lld\\n\", ans0, ans1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std; \nconst int Max_N(300050);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nint N, A[Max_N], white, black;\n\nbool check(int mid)\n{\n\tint nowmin(0);\n\tfor (int i = 1, Sum = 0;i <= N;++i)\n\t{\n\t\tif (i & 1)\n\t\t\tSum += A[i];\n\t\telse\n\t\t\tSum -= A[i];\n\t\tif (i == N)\n\t\t\treturn Sum - nowmin >= mid;\n\t\tif (Sum - nowmin >= mid)\n\t\t\tnowmin = min(nowmin, Sum); \n\t}\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tgi(A[i]);\n\t\tif (i & 1)\n\t\t\tblack += A[i];\n\t\telse\n\t\t\twhite += A[i];\n\t}\n\tif ((N & 1) == 0)\n\t\tprintf(\"%d %d\\n\", max(white, black), min(white, black));\n\telse\n\t{\n\t\tint l = 0, r = black + 1, mid;\n\t\twhile (l < r)\n\t\t{\n\t\t\tmid = l + ((r - l) >> 1);\n\t\t\tif (check(mid))\n\t\t\t\tl = mid + 1;\n\t\t\telse\n\t\t\t\tr = mid;\n\t\t}\n\t\tprintf(\"%d %d\\n\", white + (l - 1), black - (l - 1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 3e5 + 10;\n\nint n;\nint a[MAXN], sum[MAXN];\n\ninline bool check(int QAQ) {\n\tint min = 0;\n\tfor (int i = 1; i < n; i += 2) sum[i] - min >= QAQ && (min = std::min(min, sum[i + 1]));\n\treturn sum[n] - min >= QAQ; \n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tif (n % 2 == 0) {\n\t\tint A = 0, B = 0;\n\t\tfor (int i = 1; i <= n >> 1; ++i) A += a[i * 2 - 1], B += a[i * 2];\n\t\treturn printf(\"%d %d\\n\", std::max(A, B), std::min(A, B)), 0;\n\t}\n\tint A = 0, B = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i & 1) A += a[i], sum[i] = sum[i - 1] + a[i];\n\t\telse B += a[i], sum[i] = sum[i - 1] - a[i];\n\t}\n\tint ans = 0;\n\tfor (int L = 0, R = n * 1000, mid = (L + R) >> 1; L <= R; mid = (L + R) >> 1) check(mid) ? L = (ans = mid) + 1 : R = mid - 1;\n\tans = std::max(A, ans + B);\n\tprintf(\"%d %d\\n\", ans, A + B - ans);\n\treturn 0;\n}\n// A: odd, B: even"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn=300111;\nstruct data\n{\n\tset<pair<ll,ll> >st;\n\tll query(ll l)//query max(y) when x<=l\n\t{\n\t\tset<pair<ll,ll> >::iterator it=st.lower_bound(MP(l+1,-2e18));\n\t\tif(it==st.begin())return -2e18;\n\t\telse\n\t\t{\n\t\t\tit--;\n\t\t\treturn it->SS;\n\t\t}\n\t}\n\tvoid add(ll x,ll y)//add (x,y)\n\t{\n\t\tif(query(x)>=y)return;\n\t\tst.insert(MP(x,y));\n\t\twhile(true)\n\t\t{\n\t\t\tset<pair<ll,ll> >::iterator it=st.lower_bound(MP(x,y+1));\n\t\t\tif(it!=st.end()&&it->SS<=y)st.erase(it);else break;\n\t\t}\n\t}\n\tvoid init()\n\t{\n\t\tst.clear();\n\t}\n}yxg1,yxg2;\nint n;\nint a[maxn],pre[maxn];\nint dp0[maxn],dp1[maxn];\nint cost(int i,int j)\n{\n\treturn pre[j]-pre[i-1];\n}\nvoid out(int x)\n{\n\tint sum=0;\n\tfor(int i=1;i<=n;i++)sum+=a[i];\n//\tcerr<<\"sum=\"<<sum<<endl;\n\tassert((sum+x)%2==0);\n\tcout<<(sum+x)/2<<\" \"<<(sum-x)/2<<endl;\n}\nvoid calcdp(int dp[])\n{\n\tstatic int A[maxn],B[maxn];\n\tfor(int i=1;i<=n;i++)pre[i]=pre[i-1]+(i&1?a[i]:-a[i]);\n\tyxg1.init();\n\tyxg2.init();\n\tfor(int i=1;i<=n;i+=2)\n\t{\n\t\tdp[i]=cost(1,i);\n\t\tint X=pre[i];\n//\t\tdp[i]=max(dp[i],min(dp[j-1]-cost(j,i),cost(j+1,i)-cost(1,j)));\n//\t\tdp[i]=max(dp[i],min(dp[j]-pre[i]+pre[j],pre[i]-2*pre[j+1]));\n//\t\tdp[i]=max(dp[i],min(dp[j]-X+pre[j],X-2*pre[j+1]));\n//\t\tdp[i]=max(dp[i],-X+min(dp[j]+pre[j],2*X-2*pre[j+1]));\n//\t\tfor(int j=1;j<i;j+=2)dp[i]=max(dp[i],-X+min(A[j],2*X+B[j]));\n\t\tdp[i]=max(dp[i],int(-X+max(yxg1.query(2*X),2*X+yxg2.query(-2*X-1))));\n\t\tA[i]=dp[i]+pre[i];\n\t\tB[i]=-2*pre[i+1];\n\t\tyxg1.add(A[i]-B[i],A[i]);\n\t\tyxg2.add(B[i]-A[i],B[i]);\n\t}\n\t\n}\nint main()\n{\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)geti(a[i]);\n\tfor(int i=1;i<=n;i++)pre[i]=pre[i-1]+(i&1?a[i]:-a[i]);\n\tif(n%2==0)\n\t{\n\t\tout(max(pre[n],-pre[n]));\n\t\treturn 0;\n\t}\n\tint ans=pre[n];\n\tint sum=cost(1,n);\n\tcalcdp(dp0);\n\treverse(a+1,a+n+1);\n\tcalcdp(dp1);\n\treverse(a+1,a+n+1);\n\treverse(dp1+1,dp1+n+1);\n\tfor(int i=1;i<=n;i++)pre[i]=pre[i-1]+(i&1?a[i]:-a[i]);\n//\tfor(int i=1;i<=n;i+=2)cerr<<dp0[i]<<\" \";cerr<<endl;\n//\tfor(int i=1;i<=n;i+=2)cerr<<dp1[i]<<\" \";cerr<<endl;\n\t\n\tfor(int i=2;i<=n;i+=2)\n\t{\n\t\tans=max(ans,min(dp0[i-1]-cost(i,n),dp1[i+1]-cost(1,i)));\n\t}\n\tout(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc()) \n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 300010, INF = 300000000;\nint n, a[N], sum[2], b[N], dp[N];\nbool check(int x) {\n  rep (i, 1, n)\n    if (i&1) b[i] = a[i];\n    else b[i] = -a[i];\n  rep (i, 2, n) b[i] += b[i-1];\n  memset(dp, 0, sizeof dp);\n  dp[0] = 1;\n  int cur = 0;\n  rep (i, 1, n) if (i % 2 == 1) {\n    if (b[i] - cur >= x) {\n      dp[i+1] = 1;\n      cur = min(cur, b[i+1]);\n    }\n  }\n  if (dp[n+1] == 1) return true;\n  else return false;\n}\nint main() {\n  read(n);\n  rep (i, 1, n) read(a[i]);\n  rep (i, 1, n) sum[i&1] += a[i];\n  if (n % 2 == 0) {\n    printf(\"%d %d\\n\", max(sum[0], sum[1]), min(sum[0], sum[1]));\n    return 0;\n  } else {\n    int ans = sum[1];\n    int l = -INF, r = INF, res = INF;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if (check(mid)) l = mid + 1, res = mid;\n      else r = mid - 1;\n    }\n    ans = max(ans, res + sum[0]);\n    printf(\"%d %d\\n\", ans, sum[1] + sum[0] - ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nconst int N=3e5+1;\nint n, a[N], s[N];\nint main() {\n\tint sum[2]={};\n\tassert(scanf(\"%d\", &n)==1);\n\tfor(int i=1; i<=n; ++i) {\n\t\tassert(scanf(\"%d\", a+i)==1);\n\t\tsum[i%2]+=a[i];\n\t\ts[i]=s[i-1]+(i%2==1?a[i]:-a[i]);\n\t}\n\tif(n%2==0) {\n\t\tstd::sort(sum, sum+2);\n\t\tprintf(\"%d %d\\n\", sum[1], sum[0]);\n\t\treturn 0;\n\t}\n\tint l=0, r=sum[1];\n\twhile(l<r) {\n\t\tint x=(l+r+1)/2, min=0;\n\t\tfor(int i=2; i<n; i+=2) if(s[i-1]-min>=x&&s[i]<min) min=s[i];\n\t\tif(s[n]-min>=x) l=x; else r=x-1;\n\t}\n\tprintf(\"%d %d\\n\", sum[0]+l, sum[1]-l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n     \ntypedef long long Long;\n\nconst int N = 3e5 + 233;\nint n, a[N];\nLong sum[N], f[N];\n\nint main(void) {\n  ios::sync_with_stdio(0);\n  cin >> n;\n  rep (i, n) {\n    cin >> a[i];\n    sum[i] = sum[i - 1] + a[i];\n    f[i] = f[i - 1] + (i & 1 ? 1 : -1) * a[i];\n  }\n  if (n % 2 == 0) {\n    Long B = 0, W = 0;\n    rep (i, n) i & 1 ? B += a[i] : W += a[i];\n    cout << max(W, B) << \" \" << min(W, B) << \"\\n\";\n  } else {\n    auto check = [] (Long mid) {\n\t\t   Long pre = 0;\n\t\t   for (int i = 2; i <= n; i += 2) {\n\t\t     if (f[i - 1] - pre >= mid)\n\t\t       pre = min(pre, f[i]);\n\t\t   }\n\t\t   return f[n] - pre >= mid;\n\t\t };\n    Long l = -1e18, r = 1e18;\n    while (l < r) {\n      Long mid = l + (r - l + 1) / 2;\n      if (check(mid)) l = mid;\n      else r = mid - 1;\n    }\n    Long B = 0, W = 0;\n    rep (i, n) i & 1 ? B += a[i] : W += a[i];\n    cout << max(B, W + l) << \" \" << sum[n] - max(B, W + l) << \"\\n\";    \n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=3e5+10;\nint a[N],n,B,W;\nint sum[N];\nbool check(int x) {\n\tint mi=0;\n\tfor(int i=2;i<n;i+=2)\n\t\tif(mi+x<=sum[i-1]) mi=min(mi,sum[i]);\n\treturn mi+x<=sum[n];\n}\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(a[i]),sum[i]=sum[i-1];\n\t\tif(i&1) B+=a[i],sum[i]+=a[i];\n\t\telse W+=a[i],sum[i]-=a[i];\n\t}\n\tif(!(n&1)) {\n\t\tprintf(\"%d %d\",max(B,W),min(B,W));\n\t\treturn 0;\n\t}\n\tint lb=-3e8,rb=3e8;\n\twhile(lb<rb) {\n\t\tint mid=lb+rb+1>>1;\n\t\tif(check(mid)) lb=mid;\n\t\telse rb=mid-1;\n\t}\n\tint ans=max(W+lb,B);\n\tprintf(\"%d %d\",ans,W+B-ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long LL;\nconst int N = 3e5+10;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n;\nint a[N] , s[N];\n\ninline bool check(int mid)\n{\n\tint k = 0;\n\tfor(int i = 1 ; i < n ; i += 2) if(s[i] - k >= mid) k = min(k , s[i+1]);\n\treturn s[n] - k >= mid;\n}\n\nint main()\n{\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++i) a[i] = read();\n\tfor(int i = 1 ; i <= n ; ++i) s[i] = s[i-1] + ((i&1) ? 1 : -1) * a[i];\n\tint l = 0 , r = n * 1000 , mid , ans;\n\twhile(l <= r)\n\t{\n\t\tmid = (l + r) >> 1;\n\t\tif(check(mid)) l = mid + 1 , ans = mid; else r = mid - 1;\n\t}\n\tint sum = 0;\n\tfor(int i = 1 ; i <= n ; ++i) sum += a[i];\n\tfor(int i = 1 ; i <= n ; ++i) if(i % 2 == 0) ans += a[i];\n\tcout << ans << ' ' << sum - ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll> \n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1ll<<40)\n#define int long long\nusing namespace std;\nconst int N=300005;\nint n,a[N],B,W,s[N];\nbool ok(int t){\n\tint mn=0;\n\tfor (int i=2;i<=n-1;i+=2)\n\t\tif (s[i-1]-mn>=t) mn=min(mn,s[i]);\n\treturn s[n]-mn>=t;\n}\nint calc(){\n\tint l=-INF,r=INF,ans;\n\twhile (l<=r){\n\t\tint mid=((ll)l+r)/2;\n\t\tif (ok(mid)) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn ans;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tif (i%2==0) W+=a[i],s[i]=s[i-1]-a[i];\n\t\telse B+=a[i],s[i]=s[i-1]+a[i]; \n\t}\n\tif ((!n&1))\n\t\treturn printf(\"%lld %lld\\n\",max(W,B),min(W,B)),0;\n\tll ans=W+calc();\n\tprintf(\"%lld %lld\\n\",ans,(ll)B+W-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\n#define int long long\nconst int N=3e5+5;\n\nint n;\nint a[N];\nint ans,sum;\n\nbool check(int x){\n    //printf(\"check(%lld)\\n\",x);\n    int pos=0;//a[0]=0\n    for(int i=2;i<=n+1;i+=2){\n        if(a[i-1]-a[pos]<=x)if(a[i]>a[pos])pos=i;//BUG#1:没判大小关系\n    }\n    //printf(\"pos=%lld\\n\",pos);\n    return a[n]-a[pos]<=x;\n}\nsigned main(){\n    scanf(\"%lld\",&n);\n    FOR(i,1,n)scanf(\"%lld\",&a[i]),sum+=a[i];\n    int c[2]={0,0};\n    FOR(i,1,n)c[i&1]+=a[i];\n    if(c[0]<c[1])swap(c[0],c[1]);\n    if(n%2==0){\n        printf(\"%lld %lld\\n\",c[0],c[1]);\n        return 0;\n    }\n    for(int i=1;i<=n;i+=2)a[i]=-a[i];\n    //FOR(i,1,n)printf(\"%lld%c\",a[i],\" \\n\"[i==n]);\n    for(int i=2;i<=n;i+=2)ans+=a[i];\n    FOR(i,2,n+1)a[i]+=a[i-1];\n    int l=-1e9,r=1e9,mid;\n    while(l<r)mid=floor((l+r+0.0)/2),check(mid)?r=mid:l=mid+1;\n    //printf(\"ans=%lld\\n\",ans);\n    ans-=l;\n    if(ans>c[0])printf(\"%lld %lld\\n\",ans,sum-ans);\n    else printf(\"%lld %lld\\n\",c[0],c[1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n;\nll a[300001];\nll dpl[300001],dpr[300001];\nvoid funny(ll* dp){\n\tll sumr=0;\n\tll suml=a[1];\n\tfor(int i=2; i<=n ;i+=2) sumr+=a[i];\n\tdp[2]=suml+sumr;\n\tfor(int i=4; i<=n ;i+=2){\n\t\tsumr=sumr-a[i-2];\n\t\tsuml=suml+a[i-1];\n\t\tdp[i]=max(dp[i-2],suml+sumr);\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tll tot=0;\n\tfor(int i=1; i<=n ;i++){\n\t\tcin >> a[i];tot+=a[i];\n\t}\n\tif(n%2==0){\n\t\tll s1=0,s2=0;\n\t\tfor(int i=1; i<=n ;i++)\n\t\t\tif(i&1) s1+=a[i];\n\t\t\telse s2+=a[i];\n\t\tcout << max(s1,s2) << ' ' << min(s1,s2) << '\\n';\n\t\treturn 0;\n\t}\n\tfunny(dpr);\n\treverse(a+1,a+n+1);\n\tfunny(dpl);\n\treverse(dpl+1,dpl+n+1);\n\tll ans=0;\n\tfor(int i=2; i<=n ;i+=2){\n\t\tans=max(ans,min(dpl[i],dpr[i]));\n\t}\n\tll ez=0;\n\tfor(int i=1; i<=n ;i+=2) ez+=a[i];\n\tans=max(ans,ez);\n\tcout << ans << ' '<< tot-ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define pii pair<int,int>\n#define mp make_pair\nusing namespace std;\n\nint n,a[N],B,W,tot,fa[N],sum[N];\npii q[N];\nbool f[N];\n\ninline bool check(int x)\n{\n\tint minn=1e9;\n\tfor(int i=2;i<=n;i+=2)\n\t{\n\t\tif(sum[i-1]>=x) f[i]=1;\n\t\telse if(sum[i-1]-x>=minn) f[i]=1;\n\t\telse f[i]=0;\n\t\tif(f[i]) minn=min(minn,sum[i]);\n\t}\n\treturn f[n];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i&1) B+=a[i],sum[i]=sum[i-1]+a[i];\n\t\telse W+=a[i],sum[i]=sum[i-1]-a[i];\n\t}\n\tif(n&1)\n\t{\n\t\tn++;sum[n]=sum[n-1];\n\t\tsort(q+1,q+1+tot);\n\t\tint l=0,r=B+W;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=l+r>>1;\n\t\t\tif(check(mid)) l=mid+1;\n\t\t\telse r=mid;\n\t\t}\n\t\tprintf(\"%d %d\",W+l-1,B-l+1);\n\t}\n\telse printf(\"%d %d\",max(W,B),min(W,B));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 300010;\n\nint n;\nint a[MAX_N];\nint dp[MAX_N];\nint sum[2][MAX_N];\n\nvoid quadratic_dp ()\n{\n\n\tdp[0] = -(1 << 30);\n\tfor (int i = 1; i * 2 <= (n + 1); i ++)\n\t{\n\t\tdp[i] = (1 << 30); /// infinty\n\t\tfor (int j = 0; j < i; j ++)\n        {\n            ///printf (\"%d %d - %d\\n\", j * 2, dp[j], sum[0][i * 2 - 1] - sum[0][j * 2] - (sum[1][i * 2 - 1] - sum[1][j * 2]));\n\t\t\tdp[i] = min (dp[i], max (dp[j], sum[0][i * 2 - 1] - sum[0][j * 2] - (sum[1][i * 2 - 1] - sum[1][j * 2])));\n        }\n\t\t///printf (\"%d %d\\n\", i, dp[i]);\n\t}\n}\n\nint main ()\n{\n\tscanf (\"%d\", &n);\n\tfor (int i = 1; i <= n; i ++)\n\t\tscanf (\"%d\", &a[i]);\n\n\tint s[2] = {0, 0};\n\n\tfor (int i = 1; i <= n; i ++)\n\t\ts[i & 1] += a[i];\n\n\tif (!(n & 1))\n\t{\n\t\tprintf (\"%d %d\\n\", max (s[0], s[1]), min (s[0], s[1]));\n\t\treturn 0;\n\t}\n\n\tsum[0][0] = sum[1][0] = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tsum[0][i] = sum[0][i - 1];\n\t\tsum[1][i] = sum[1][i - 1];\n\t\tsum[i & 1][i] += a[i];\n\t}\n\n\tquadratic_dp ();\n\n\t///nlogn_dp ();\n\n\tprintf (\"%d %d\\n\", (s[0] - dp[(n / 2) + 1]), (s[1] + dp[(n / 2) + 1]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\n\nconst int maxn=300111;\nint n,a[maxn];\n\nbool check(int sum)\n{\n\tint mn=0,pre=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i%2==0&&pre-mn>=sum)mn=min(mn,pre-a[i]);\n\t\tif(i%2)pre+=a[i];\n\t\telse pre-=a[i];\n\t}\n\tif(pre-mn>=sum)return true;\n\telse return false;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\t\n\tint s1=0,s2=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i%2)s1+=a[i];\n\t\telse s2+=a[i];\n\t}\n\tif(n%2==0)\n\t{\n\t\tif(s1<s2)swap(s1,s2);\n\t\tprintf(\"%d %d\\n\",s1,s2);\n\t\treturn 0;\n\t}\n\t\n\tint lb=0,rb=1e9,mid;\n\twhile(lb<rb-1)\n\t{\n\t\tmid=(lb+rb)>>1;\n\t\tif(check(mid))lb=mid;\n\t\telse rb=mid;\n\t}\n\tprintf(\"%d %d\\n\",s2+lb,s1-lb);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, a[303000], s[303000];\n\nbool chk(int aim){\n    int mn=0;\n    for (int i=1;i<n;i+=2)\n        if (s[i]-mn>=aim)\n            mn=min(mn,s[i+1]);\n    return s[n]-mn>=aim;\n}\n\nvoid fuck1(){\n    for (int i=1;i<=n;++i)\n        s[i]=s[i-1] + (i&1? a[i]: -a[i]);\n    int l=0, r=3e8, ans=0;\n    for (;l<=r;){\n        int mid=l+r>>1;\n        if (chk(mid)) l=mid+1, ans=mid;\n        else r=mid-1;\n    }\n    int sum=0;\n    for (int i=1;i<=n;++i){\n        sum+=a[i];\n        if (~i&1) ans+=a[i]; \n    }\n    cout<<ans<<' '<<sum-ans<<endl;\n}\n\nvoid fuck0(){\n    int s[2]={0,0};\n    for (int i=1;i<=n;++i) s[i%2]+=a[i];\n    cout<<max(s[0],s[1])<<' '<<min(s[0],s[1])<<endl;\n}\n\nint main(){\n    cin>>n;\n    for (int i=1;i<=n;++i) cin>>a[i];\n    if (n&1) fuck1();\n    else fuck0();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[303030];\nll B[303030];\nll S[2];\nint ok(ll v) {\n\tint i;\n\tFOR(i,N) B[i]=A[i];\n\tfor(cur=N-1;cur>0;cur-=2) if(B[cur]<v || B[cur-1]<B[cur]) B[cur-2]+=B[cur]-B[cur-1];\n\treturn B[0]>=v;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i];\n\t\tS[i%2]+=A[i];\n\t}\n\tif(N%2==0) {\n\t\tcout<<max(S[0],S[1])<<\" \"<<min(S[0],S[1])<<endl;\n\t\treturn;\n\t}\n\t\n\tll Z=-1LL<<40;\n\tfor(i=40;i>=0;i--) if(ok(Z+(1LL<<i))) Z+=1LL<<i;\n\t\n\tcout<<(S[1]+Z)<<\" \"<<(S[0]-Z)<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) int(a.size())\n#define clr(a) memset(a,0,sizeof(a))\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=3e5+10;\nconst int mod=0;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nint n,a[N],sb=0,sw=0;\nint check(int mid) {\n    int val=a[1];\n    for(int i=3;i<=n;i+=2) {\n        if(val>=mid) val=max(val+a[i]-a[i-1],a[i]);\n        else val+=a[i]-a[i-1];\n    }\n    return val>=mid;\n}\nint main() {\n    n=gi();\n    for(int i=1;i<=n;i++) a[i]=gi(),(i&1)?sb+=a[i]:sw+=a[i];\n    if(!(n&1)) return printf(\"%d %d\\n\",max(sb,sw),min(sb,sw)),0;\n    int l=0,r=sb,ret=0;\n    while(l<=r) {\n        int mid=(l+r)>>1;\n        if(check(mid)) ret=mid,l=mid+1;\n        else r=mid-1;\n    }\n    printf(\"%d %d\\n\",sw+ret,sb-ret);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N;\nvector<long long> a;\n\nint main() {\n    cin >> N;\n    long long black = 0, white = 0;\n    a.resize(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> a[i];\n        if (i % 2 == 0) black += a[i];\n        else white += a[i];\n    }\n    if (N % 2 == 0) cout << max(black, white) << \" \" << min(black, white) << endl;\n    else {\n        long long low = 0, high = 1<<30;\n        while (high - low > 1) {\n            long long mid = (low + high) / 2;\n\t\t\tvector<long long> dp; dp.assign(N + 1, -(1LL << 60));\n\t\t\tdp[1] = a[0];\n\t\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\t\t// 直前をカットする場合\n\t\t\t\tif (dp[i - 2] >= mid) dp[i] = max(dp[i], a[i - 1]);\n\t\t\t\t\n\t\t\t\t// 直前をカットしない場合\n\t\t\t\tdp[i] = max(dp[i], dp[i - 2] - a[i - 2] + a[i - 1]);\n\t\t\t}\n\t\t\tif (dp[N] >= mid) low = mid;\n\t\t\telse high = mid;\n        }\n        cout << white + low << \" \" << black - low << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<unordered_map>\ntypedef unsigned int u32;\nconst int N=3e5+5;\nint n,a[N],s[N][2];\ntemplate<class T>T abs(T x){return x<0?-x:x;}\ntemplate<class T>bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>T min(T a,T b){return a<b?a:b;}\nstd::unordered_map<int,int>dd[N];\nint solve(int l,int r){\n\tif(l==r)return a[l];\n\tif(dd[l].count(r))return dd[l][r];\n\tint res=abs((s[r][0]-s[l-1][0])-(s[r][1]-s[l-1][1])),c,x;\n\tif((l^r^1)&1){\n\t\tc=!(l&1);\n\t\tfor(x=l+1;x<=r;x+=2){\n\t\t\tchkmax(res,min(solve(l,x-1)+(s[r][c]-s[x-1][c])-(s[r][c^1]-s[x-1][c^1]),solve(x+1,r)+(s[x][c]-s[l-1][c])-(s[x][c^1]-s[l-1][c^1])));\n\t\t}\n\t}\n\treturn dd[l][r]=res;\n}\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)s[i][0]=s[i-1][0],s[i][1]=s[i-1][1],scanf(\"%d\",a+i),s[i][i&1]+=a[i];\n\tu32 dif=solve(1,n);\n\tu32 sum=(u32)s[n][0]+s[n][1];\n\tu32 sigma=(sum-dif)>>1,sugim=sigma+dif;\n\tprintf(\"%u %u\\n\",sugim,sigma);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nnamespace zyt\n{\n\ttemplate<typename T>\n\tinline bool read(T &x)\n\t{\n\t\tchar c;\n\t\tbool f = false;\n\t\tx = 0;\n\t\tdo\n\t\t\tc = getchar();\n\t\twhile (c != EOF && c != '-' && !isdigit(c));\n\t\tif (c == EOF)\n\t\t\treturn false;\n\t\tif (c == '-')\n\t\t\tf = true, c = getchar();\n\t\tdo\n\t\t\tx = x * 10 + c - '0', c = getchar();\n\t\twhile (isdigit(c));\n\t\tif (f)\n\t\t\tx = -x;\n\t\treturn true;\n\t}\n\ttemplate<typename T>\n\tinline void write(T x)\n\t{\n\t\tstatic char buf[20];\n\t\tchar *pos = buf;\n\t\tif (x < 0)\n\t\t\tputchar('-'), x = -x;\n\t\tdo\n\t\t\t*pos++ = x % 10 + '0';\n\t\twhile (x /= 10);\n\t\twhile (pos > buf)\n\t\t\tputchar(*--pos);\n\t}\n\tconst int N = 3e5 + 10;\n\tint arr[N], W, B, n, sum[N];\n\tbool check(const int x)\n\t{\n\t\tint mn = 0;\n\t\tfor (int i = 2; i <= n; i += 2)\n\t\t\tif (sum[i - 1] - mn >= x - W)\n\t\t\t\tmn = min(mn, sum[i]);\n\t\treturn sum[n] - mn >= x - W;\n\t}\n\tint work()\n\t{\n\t\tread(n);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tread(arr[i]), sum[i] = sum[i - 1] + arr[i] * (i & 1 ? 1 : -1);\n\t\tfor (int i = 1; i <= n; i += 2)\t\n\t\t\tB += arr[i];\n\t\tfor (int i = 2; i <= n; i += 2)\n\t\t\tW += arr[i];\n\t\tif (!(n & 1))\n\t\t\tprintf(\"%d %d\", max(B, W), min(B, W));\n\t\telse\n\t\t{\n\t\t\tint l = max(W, B + 1), r = (B + W), ans = B;\n\t\t\twhile (l <= r)\n\t\t\t{\n\t\t\t\tint mid = (l + r) >> 1;\n\t\t\t\tif (check(mid))\n\t\t\t\t\tl = mid + 1, ans = mid;\n\t\t\t\telse\n\t\t\t\t\tr = mid - 1;\n\t\t\t}\n\t\t\tprintf(\"%d %d\", ans, B + W - ans);\n\t\t}\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\treturn zyt::work();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <numeric>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int& a_i : a) {\n    cin >> a_i;\n  }\n  vector<int> p(n), s(n);\n  for (int i = 0; i < n; ++i) {\n    p[i] = a[i] + (i >= 2 ? p[i - 2] : 0);\n  }\n  for (int i = n - 1; i >= 0; --i) {\n    s[i] = a[i] + (i <= n - 3 ? s[i + 2] : 0);\n  }\n  int tot = accumulate(a.begin(), a.end(), 0);\n  int su = -1, si = -1;\n  for (int i = 0; i < n; ++i) {\n    int nsu = -1;\n    {\n      nsu = (i > 0 ? p[i - 1] : 0) + ((i & 1) ? (i + 2 < n ? s[i + 2] : 0) : (i + 1 < n ? s[i + 1] : 0));\n    }\n    {\n      int rsum = (i + 1 < n ? s[i + 1] : 0) + (((n - i) & 1) ? (i > 0 ? p[i - 1] : 0) : (i - 2 >= 0 ? p[i - 2] : 0));\n      nsu = max(nsu, rsum);\n    }\n    int nsi = tot - nsu;\n    if (nsi > si) {\n      si = nsi;\n      su = nsu;\n    }\n  }\n  assert(si != -1 && su != -1);\n  cout << si << ' ' << su << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nconst int MAX = 300000;\n\nbool check(int *a, int l, int r, int X) {\n\tif (r - l == 1) return a[l] >= X;\n\tif (a[l] < X || a[l + 1] < a[l]) {\n\t\ta[l + 2] += a[l] - a[l + 1];\n\t\treturn check(a, l + 2, r, X);\n\t}\n\treturn check(a, l + 2, r, X - a[l + 1] + a[l]);\n}\n\nint get(int *a, int l, int r, int X) {\n\tif(r - l == 1) return a[l];\n\tif (a[l] < X || a[l + 1] < a[l]) {\n\t\ta[l + 2] += a[l] - a[l + 1];\n\t\treturn a[l + 1] + get(a, l + 2, r, X);\n\t}\n\treturn a[l + 1] + get(a, l + 2, r, X - a[l + 1] + a[l]);\n}\n\nint main() {\n\tint N;\n\tstatic int a[MAX], cpy[MAX];\n\tcin >> N;\n\tfor (int i = 0;i < N;i ++) cin >> a[i];\n\t\n\tif ((N & 1) == 0) { // Nが偶数\n\t\tint sum[2] = {0, 0};\n\t\tfor (int i = 0;i < N;i ++) {\n\t\t\tsum[i & 1] += a[i];\n\t\t}\n\t\tif (sum[0] < sum[1]) cout << sum[1] << ' ' << sum[0];\n\t\telse cout << sum[0] << ' ' << sum[1];\n\t\treturn 0;\n\t} // Nが奇数\n\t\n\tint sum = 0;\n\tfor (int i = 0;i < N;i ++) sum += a[i];\n\t\n\tint ans = 0;\n\tfor (int ng = sum, mid = (sum >> 1);ng - ans > 1;mid = ans + ((ng - ans) >> 1)) {\n\t\tmemcpy(cpy, a, sizeof(int) * N);\n\t\tif (check(cpy, 0, N, mid)) ans = mid;\n\t\telse ng = mid;\n\t}\n\tans = get(a, 0, N, ans);\n\t\n\tcout << ans << ' ' << sum - ans;\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説ACなので何も無いです、解説読んでね\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3e5 + 5;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, w, b, a[MAXN], s[MAXN];\nbool check(int mid) {\n\tint Min = 0;\n\tfor (int i = 2; i <= n; i += 2)\n\t\tif (s[i - 1] - Min >= mid) chkmin(Min, s[i]);\n\treturn s[n] - Min >= mid;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(a[i]);\n\t\tif (i & 1) b += a[i], s[i] = s[i - 1] + a[i];\n\t\telse w += a[i], s[i] = s[i - 1] - a[i];\n\t}\n\tif (n % 2 == 0) {\n\t\tprintf(\"%d %d\\n\", max(w, b), min(w, b));\n\t\treturn 0;\n\t}\n\tint l = -w - b, r = w + b;\n\twhile (l < r) {\n\t\tint mid = (l + r + 2 * w + 2 * b + 1) / 2 - w - b;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tprintf(\"%d %d\\n\", w + l, b - l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x <<\": \" << (x) << endl\n//Ã�Â¥Ã¯Â¿Â½Ã�Â¨Ã�Â¦Ã�Â¯Ã¯Â¿Â½Ã�Â¤Ã�Â¸Ã�ÂªÃ�Â¥Ã¯Â¿Â½Ã�Â½Ã�Â¦Ã¯Â¿Â½Ã�Â°Ã�Â§Ã¯Â¿Â½Ã¯Â¿Â½Ã�Â¥Ã¯Â¿Â½Ã�Â¥Ã�Â¥Ã¯Â¿Â½Ã�Â£Ã�Â¥Ã�Â¤Ã¯Â¿Â½Ã�Â¦Ã¯Â¿Â½Ã�Â§Ã�Â¨Ã�Â¡Ã¯Â¿Â½Ã�Â¤Ã�Â¸Ã¯Â¿Â½Ã�Â¦Ã�Â¬Ã�Â¡Ã�Â¯Ã�Â¼Ã¯Â¿Â½Ã�Â¥Ã¯Â¿Â½Ã�ÂºÃ�Â¥Ã¯Â¿Â½Ã�Â£Ã�Â¥Ã�Â¤Ã¯Â¿Â½Ã�Â¦Ã¯Â¿Â½Ã�Â§Ã�Â¨Ã�Â¡Ã¯Â¿Â½Ã�Â¤Ã�Â¸Ã¯Â¿Â½Ã�Â¦Ã�Â¬Ã�Â¡Ã�Â£Ã¯Â¿Â½Ã¯Â¿Â½Ã�Â§Ã¯Â¿Â½Ã�Â¶Ã�Â¥Ã¯Â¿Â½Ã¯Â¿Â½Ã�Â¥Ã�Â°Ã�Â±Ã�Â¥Ã¯Â¿Â½Ã�Â¯Ã�Â¤Ã�Â»Ã�Â¥Ã�Â¥Ã�Â¿Ã�Â«Ã�Â©Ã¯Â¿Â½Ã¯Â¿Â½Ã�Â¥Ã�Â¾Ã¯Â¿Â½Ã�Â§Ã¯Â¿Â½Ã�Â¥Ã�Â¦Ã¯Â¿Â½Ã�Â¯Ã�Â¥Ã¯Â¿Â½Ã�ÂªÃ�Â¤Ã�Â¸Ã�ÂªÃ�Â¥Ã¯Â¿Â½Ã�Â°Ã�Â¦Ã¯Â¿Â½Ã�Â¹Ã�Â¦Ã�Â®Ã�ÂµÃ�Â©Ã¯Â¿Â½Ã¯Â¿Â½Ã�Â¨Ã�Â¯Ã�Â¯Ã�Â¤Ã�ÂºÃ¯Â¿Â½\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#ifdef LOCAL\n#define see(x) cout  << #x << \": \" << (x) << endl\n#endif\n#ifndef LOCAL\n#define see(x)\n#endif\n\n\n#define rep(n) for(int _ = 0; _ != (n); ++_)\n//#define rep(i, a, b) for(int i = (a); i <= (b); ++i)\n#define Rng(i, n) for(int i = 0; i != (n); ++i)\n#define rng(i, a, b) for(int i = (a); i < (b); ++i)\n#define rno(i, b) for(int i = 0; i<(b); ++i)\n#define rnc(i, a, b) for(int i = (a); i<=(b); ++i)\n#define RNG(i, a) for(auto &i: (a))\n#define dwn(i, r, l) for(int i = (r); i>=(l); i--)\n\nnamespace std {\n    template<class T>\n    T begin(std::pair<T, T> p)\n    {\n        return p.first;\n    }\n    template<class T>\n    T end(std::pair<T, T> p)\n    {\n        return p.second;\n    }\n}\n\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate<class Range>\nstd::pair<std::reverse_iterator<decltype(begin(std::declval<Range>()))>, std::reverse_iterator<decltype(begin(std::declval<Range>()))>> make_reverse_range(Range &&r)\n{\n    return std::make_pair(make_reverse_iterator(::begin(r)), make_reverse_iterator(::end(r)));\n}\n\n#define RRNG(x, cont) for (auto &x: make_reverse_range(cont))\n\n\n\ntemplate<class T> int sign(const T &a) { return a == 0 ? 0 : a > 0 ? 1 : -1; }\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> void Min(T &a, const T &b){ a = min(a, b); }\ntemplate<class T> void Max(T &a, const T &b){ a = max(a, b); }\n\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\nusing pii = pair<int, int>;\nusing pdd = pair<double, double>;\nusing pip = pair<int, pii>;\nusing szt = size_t;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing pli = pair<ll,int>;\nusing wg = vector<vpii>; //weighted graph\n\nint cas;\nconst double pi = acos(-1);\nll mod = 1e9 + 7;\n\ntemplate<class T>\ninline void add_mod(T &a, const T &b) {\n    a += b;\n    if (a >= mod) a -= mod;\n}\ntemplate<class T>\nvoid sub_mod(T &a, const T &b){\n    a -= b;\n    if (a < 0) a += mod;\n}\nauto bo=[](int x){\n    bitset<5> a(x);\n    cout << a << endl;\n};\n\n//返回值：a中比k小的元素有多少个？\ntemplate<class V, class Cont>\nint get_rank(const V &k, const Cont &a){\n    return std::lower_bound(all(a), k) - a.begin();\n}\n\nmat operator*(const mat &a, const mat &b) {\n    mat c(a.size(), vec(b[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            if (a[i][j]) { // optimization for sparse matrix\n                for (int k = 0; k < b[0].size(); k++) {\n                    add_mod(c[i][k], a[i][j] * b[j][k] % mod);\n                }\n            }\n        }\n    }\n    return c;\n}\n\nvec operator*(const mat &a, const vec &b) {\n    vec c(a.size());\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            add_mod(c[i], a[i][j] * b[j] % mod);\n        }\n    }\n    return c;\n}\n\nmat pow(mat a, ull n) {\n    mat res(a.size(), vec(a[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        res[i][i] = 1;\n    }\n    while (n) {\n        if (n & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\n// Codeforces does not support __int128\n//std::ostream& operator<<(std::ostream& os, __int128 T) {\n//    if (T<0) os<<\"-\";\n//    if (T>=10 ) os<<T/10;\n//    if (T<=-10) os<<(-(T/10));\n//    return os<<( (int) (T%10) >0 ? (int) (T%10) : -(int) (T%10) ) ;\n//}\n//\n//__int128 LPOW(__int128 x, ll n) {\n//    __int128 res = 1;\n//    for (; n; n /= 2, x *= x, x %= mod) {\n//        if (n & 1) {\n//            res *= x;\n//            res %= mod;\n//        }\n//    }\n//    return res;\n//}\n\nll POW(ll x, ll n){\n    ll res = 1;\n    for (; n; n /= 2, x *= x, x %= mod) {\n        if (n & 1) {\n            res *= x;\n            res %= mod;\n        }\n    }\n    return res;\n}\n\n\nll INV(ll x) {\n    return POW(x, mod - 2);\n}\n\nll inv(ll x){\n//    see(x);\n    return x == 1? 1: (mod - mod/x * inv(mod%x) % mod);\n}\n\n\n\n// 2D rotation\nvoid rotate(double &x, double &y, double theta) {\n    double tx = cos(theta) * x - sin(theta) * y;\n    double ty = sin(theta) * x + cos(theta) * y;\n    x = tx, y = ty;\n}\nstruct bit {\n    static const int BIT_N = 1e5 + 5;\n    ll bit[BIT_N];\n    void init(int n){\n        rng(i, 1, n+1) bit[i] = 0;\n    }\n\n    ll sum(int x) {\n        ll res = 0;\n        while (x) {\n            res += bit[x];\n            x -= x & -x;\n        }\n        return res;\n    }\n\n    ll sum(int l, int r) {\n        if (l > r) return 0;\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int x, ll v, int n) {\n        while (x <= n) {\n            bit[x] += v;\n            x += x & -x;\n        }\n    }\n};\n\n\nnamespace util{\n    int len(ll x){return snprintf(nullptr, 0, \"%lld\", x);}\n    vi get_d(ll x){\n        vi res;\n        while(x) {\n            res.pb(x%10);\n            x /= 10;\n        }\n        reverse(all(res));\n        return res;\n    }\n    template <class T> T parity(const T &a){\n        return a & 1;\n    }\n    template <class T>\n    void out (const vector<T> &a){\n        std::copy(a.begin(), a.end(), std::ostream_iterator<T>(std::cout, \", \"));\n        cout << endl;\n    };\n}\n\nusing namespace util;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n\nusing order_statistic_tree = __gnu_pbds::tree<\n        int,\n        __gnu_pbds::null_type,\n        greater<int>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n\n\nconst ll LINF = LLONG_MAX/10;\nconst int INF = INT_MAX/10;\nconst int M = 5005;\n\n\nll dp[M];\n\nint c[M], f[M];\n\nint nn[M], v[M], p[M];\n\nint main() {\n    // Single Cut of Failure taught me\n    cout << std::fixed;\n    cout << setprecision(10);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n\n#ifdef LOCAL\n    freopen(\"main.in\", \"r\", stdin);\n//    freopen(\"main.out\", \"w\", stdout);\n#endif\n\n    int n; scan(n);\n    vi a(n);\n    RNG(x, a) scan(x);\n    int sb = 0;\n    for(int i = 0; i<n; i+=2)\n        sb += a[i];\n    int sw = 0;\n    for(int i=1; i<n; i+=2)\n        sw += a[i];\n\n\n    auto check = [n, sb, sw, &a](int x) {\n        int mi = INF;\n        int sum = 0;\n        rng(i, 0, n) {\n            if (i & 1) {\n                if (sum >= x || sum - mi >= x) {\n                    if (sb - sw - (sum - a[i]) >= x)\n                        return true;\n                    sum -= a[i];\n                    Min(mi, sum);\n                }\n                else sum -= a[i];\n            }\n            else sum += a[i];\n        }\n        return false;\n    };\n\n    int l = sb - sw + 1, r = sb;\n    while(l<=r){\n        int mid = l + (r-l)/2;\n        if(check(mid)){\n            l = mid + 1;\n        }\n        else r = mid - 1;\n    }\n\n    println(sw + r, sb - r);\n\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint n;\nint B,W;\nint a[300050];\nbool judge(int x)\n{\n\tint now=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(i&1)\n\t\t{\n\t\t\tnow+=a[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(now>=a[i]) now-=a[i];\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(now<x) return 0;\n\t\t\t\tnow=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i&1) B+=a[i];\n\t\telse W+=a[i];\n\t}\n\tif(~n&1)\n\t{\n\t\tprintf(\"%d %d\\n\",max(B,W),min(B,W));\n\t\treturn 0;\n\t}\n\tint l=0,r=B,re=-1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(judge(mid)) l=mid+1,re=mid;\n\t\telse r=mid-1;\n\t}\n\tint an=max(B,W+re);\n\tprintf(\"%d %d\\n\",an,B+W-an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int MAX_N = 3e5 + 5;\n\nint arr [MAX_N];\nint altpref [MAX_N];\nint altsuff [MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    sum += arr[i];\n  }\n  \n  altpref[0] = arr[0];\n  altpref[1] = arr[1];\n  for (int i = 2; i < n; i++) {\n    altpref[i] = arr[i] + altpref[i - 2];\n  }\n\n  for (int i = n - 1; i >= 0; i--) {\n    altsuff[i] = arr[i] + altsuff[i + 2];\n  }\n\n  int ans = max(altpref[n - 1], altsuff[0]);\n  if (n % 2 == 1) {\n    for (int i = 1; i < n; i += 2) {\n      ans = max(ans, min(altpref[i - 1] + altsuff[i],\n                         altpref[i] + altsuff[i + 1]));\n    }\n  }\n  cout << ans << \" \" << sum - ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int N=3e5+2;\nconst int inf=1e9+7;\nint ar[N],sum[N][2];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,min1=0,lef=-inf,rig=inf,mid;\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>ar[i];\n\t\tsum[i][1]=sum[i-1][1];\n\t\tsum[i][0]=sum[i-1][0];\n\t\tif(i&1){\n\t\t\tsum[i][1]+=ar[i];\n\t\t}\n\t\telse{\n\t\t\tsum[i][0]+=ar[i];\n\t\t}\n\t}\n\tif(!(n&1)){\n\t\tcout<<max(sum[n][0],sum[n][1])<<' '<<min(sum[n][0],sum[n][1]);\n\t}\n\telse{\n\t\twhile(lef<rig){\n\t\t\tmin1=0;\n\t\t\tmid=(lef+rig+1)/2;\n\t\t\tbool cac=false;\n\t\t\tfor(i=2;i<=n;i+=2){\n\t\t\t\tif(sum[i-1][1]-sum[i-1][0]>=mid+min1){\n\t\t\t\t\tif(sum[n][1]-sum[n][0]-(sum[i][1]-sum[i][0])>=mid){\n\t\t\t\t\t\tcac=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmin1=min(min1,sum[i][1]-sum[i][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cac){\n\t\t\t\tlef=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\trig=mid-1;\n\t\t\t}\n\t\t}\n\t\t//cout<<lef<<endl;\n\t\tcout<<max(sum[n][1],sum[n][0]+lef)<<' '<<sum[n][0]+sum[n][1]-max(sum[n][1],sum[n][0]+lef);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=300005,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,ans,a[N],s[N][2];\nbool check(int mid){\n\tint las=0;\n\tfor (int i=2;i<=n;i+=2)\n\tif (s[i-1][1]-s[i-1][0]-las>=mid) las=min(las,s[i][1]-s[i][0]);\n\treturn (s[n][1]-s[n][0]-las>=mid);\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++){\n\t\ta[i]=read();\n\t\ts[i][0]=s[i-1][0];\n\t\ts[i][1]=s[i-1][1];\n\t\ts[i][i&1]+=a[i];\n\t}\n\tif (n&1){\n\t\tint l=0,r=s[n][0]+s[n][1],mid;\n\t\twhile (l<r){\n\t\t\tmid=(l+r+1)>>1;\n\t\t\tif (check(mid)) l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",s[n][0]+l,s[n][1]-l);\n\t}\n\telse printf(\"%d %d\\n\",max(s[n][0],s[n][1]),min(s[n][0],s[n][1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nll f[300001];\n\nvoid init() {\n\tf[1] = 1;\n\tll ma = 0;\n\tfor (int i = 3; i <= 300000; i += 2) {\n\t\tint d = i / 2;\n\t\tif (d % 2 == 0) {\n\t\t\tf[i] = 2 * (f[d - 1] + f[d + 1]);\n\t\t}\n\t\telse {\n\t\t\tf[i] = f[d] + f[d];\n\t\t}\n\t\tma = max(ma, f[i]);\n\t}\n\tcout << ma << \"\\n\";\n}\n\nvoid solve() {\n\n\n\n\tint n; cin >> n;\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tint sum = 0;\n\trep(i, n)sum += a[i];\n\n\tif (n % 2 == 0) {\n\t\tint s1 = 0, s2 = 0;\n\t\tfor (int i = 0; i < n; i += 2)s1 += a[i];\n\t\tfor (int i = 1; i < n; i += 2)s2 += a[i];\n\t\tint ans1 = max(s1, s2);\n\t\tint ans2 = sum - ans1;\n\t\tcout << ans1 << \" \" << ans2 << \"\\n\";\n\t}\n\telse {\n\t\tvector<vector<int>> ra(n + 1,vector<int>(2));\n\t\trep(i, n) {\n\t\t\tra[i + 1] = ra[i];\n\t\t\tra[i + 1][i%2] += a[i];\n\t\t}\n\t\tmap<P, bool> used;\n\t\tmap<P, int> memo;\n\t\tfunction<int(int, int)> dfs = [&](int l, int r)->int{\n\t\t\tif (l == r)return a[l];\n\t\t\tif (used[{l, r}])return memo[{l, r}];\n\t\t\tused[{l, r}] = true;\n\t\t\tint res = ra[r + 1][l%2] - ra[l][l%2];\n\t\t\tif (l == r) {\n\t\t\t\tres = a[l];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint res1 = mod, res2 = mod;\n\t\t\t\tint len = (r - l + 1);\n\t\t\t\tif (len % 4 == 3) {\n\t\t\t\t\tfor (int ex = -2; ex <= 2; ex += 2) {\n\t\t\t\t\t\tint d = len / 2 + ex;\n\t\t\t\t\t\tif (d <= 0 || d >= len)continue;\n\t\t\t\t\t\tint m = l + d;\n\t\t\t\t\t\tres1 = mod;\n\t\t\t\t\t\tres1 = min(res1, dfs(l, m - 1) + ra[r + 1][m % 2] - ra[m][m % 2]);\n\t\t\t\t\t\tres1 = min(res1, dfs(m + 1, r) + ra[m + 1][m % 2] - ra[l][m % 2]);\n\t\t\t\t\t\tres = max(res, res1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int ex = -1; ex <= 1; ex += 2) {\n\t\t\t\t\t\tint d = len / 2 + ex;\n\t\t\t\t\t\tint m = l + d;\n\t\t\t\t\t\tres1 = mod;\n\t\t\t\t\t\tres1 = min(res1, dfs(l, m - 1) + ra[r + 1][m%2] - ra[m][m%2]);\n\t\t\t\t\t\tres1 = min(res1, dfs(m + 1, r) + ra[m + 1][m%2] - ra[l][m%2]);\n\t\t\t\t\t\tres = max(res, res1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << l << \" \" << r << \" \" << res << \"\\n\";\n\t\t\treturn memo[{l, r}] = res;\n\t\t};\n\t\tint ans = dfs(0, n - 1);\n\t\tcout << ans << \" \"<<sum-ans<<\"\\n\";\n\t}\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e5+20;\n\nint n,a[maxn],sum;\n\ninline void init()\n{\n\tn=read();\n\tREP(i,1,n)a[i]=read(),sum+=a[i];\n}\n\nint x[maxn],y[maxn];\n\ninline bool check(int ck)\n{\n\tint mx=0;\n\tREP(i,1,n>>1)\n\t{\n\t\tif(x[i]+mx>=ck)chkmax(mx,-y[i]);\n\t}\n\tif(x[n+1>>1]+mx>=ck)return 1;\n\telse return 0;\n}\n\ninline void doing()\n{\n\tif(~n&1)\n\t{\n\t\tint B=0,W=0;\n\t\tREP(i,1,n)if(i&1)B+=a[i];else W+=a[i];\n\t\tif(B<W)swap(B,W);\n\t\tprintf(\"%d %d\\n\",B,W);\n\t}else\n\t{\n\t\tint W=0;\n\t\tREP(i,1,n)if(~i&1)W+=a[i];\n\t\tREP(i,1,n+1>>1)x[i]=x[i-1]+a[i*2-1]-a[i*2-2],y[i]=y[i-1]+a[i*2-1]-a[i*2];\n\t\tint l=0,r=sum;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=l+r+1>>1;\n\t\t\tif(check(mid))l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",W+l,sum-W-l);\n\t}\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n#define int long long\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[300005];\nsigned main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n) scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",max(c,b),min(c,b));\n\t}\n\telse{\n\t\tll c=0,b=0;\n\t\trepn(i,n){\n\t\t\tif(i%2==1) c+=a[i];\n\t\t\telse b+=a[i];\n\t\t}\n\t\tint lb = 0,ub = 10000000007ll;\n\t\twhile(ub-lb>1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tif(c >= b+mid){\n\t\t\t\tlb = mid; continue;\n\t\t\t}\n\t\t\tpriority_queue<P1>que;\n\t\t\tpriority_queue<P,vector<P>,greater<P> >que2;\n\t\t\tint zan = c-b;\n\t\t\tint lazy = 0;\n\t\t\tint cur = 0;\n\t\t\trepn(i,n){\n\t\t\t\tif(i%2 == 1) cur += a[i];\n\t\t\t\telse{\n\t\t\t\t\tif(cur>=mid){\n\t\t\t\t\t\tque2.push(mp(cur-a[i],i));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tque.push(mp(cur,mp(cur-a[i],i)));\n\t\t\t\t\t}\n\t\t\t\t\tcur -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint pre = -1;\n\t\t\twhile(1){\n\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t}\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP1 p = que.top();\n\t\t\t\t\tif(p.sc.sc<=pre){\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi-lazy >= mid){\n\t\t\t\t\t\tque2.push(p.sc);\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbool ok = 0;\n\t\t\t\twhile(!que2.empty()){\n\t\t\t\t\tP p = que2.top();\n\t\t\t\t\tif(p.sc<=pre){\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.fi>=0){\n\t\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlazy += p.fi;\n\t\t\t\t\t\tpre = p.sc;\n\t\t\t\t\t\tque2.pop();\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\tif(zan-lazy >= mid){\n\t\t\t\t\t\t\tlb = mid; goto fail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok){\n\t\t\t\t\tub = mid; goto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(0);\n\t\t\tfail:;\n\t\t}\n\t\tassert(lb+b>c);\n\t\tprintf(\"%lld %lld\\n\",lb+b,c-lb);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e5+7;\nint n,w[N],f[N],q[N];\ninline int read(){\n    int num=0; char g=getchar(); while(g<48||57<g) g=getchar();\n    while(47<g&&g<58) num=(num<<1)+(num<<3)+g-48,g=getchar(); return num;\n}\ninline bool check(int u){\n\tint sx=0;\n\tfor(int i=2;i<=n+1;i+=2){\n\t\tif(sx+f[i]-q[i-1]>=u){\n\t\t\tsx=max(sx,q[i+1]-f[i]);\n\t\t\tif(i==n+1) return true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;i++) w[i]=read();\n\tif(n%2==0){\n\t\tint a=0,b=0;\n\t\tfor(int i=1;i<=n;i++) if(i&1) a+=w[i]; else b+=w[i];\n\t\tcout<<max(a,b)<<' '<<min(a,b)<<endl;\n\t}\n\telse{\n\t\tint sum=0;\n\t\tfor(int i=1;i<=n+1;i++){\n\t\t\tsum+=w[i]; f[i]+=f[i-1],q[i]+=q[i-1];\n\t\t\tif(i&1) f[i]+=w[i]; else q[i]+=w[i];\n\t\t}\n\t\tint l=0,r=sum,c=0;\n\t\twhile(l<=r){\n\t\t\tint d=(l+r)>>1; if(check(d)) c=d,l=d+1; else r=d-1;\n\t\t}\n\t\tcout<<c+q[n+1]<<' '<<sum-c-q[n+1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n     \ntypedef long long Long;\n\nconst int N = 3e5 + 233;\nint n, a[N];\nLong sum[N], f[N];\n\nint main(void) {\n  ios::sync_with_stdio(0);\n  cin >> n;\n  rep (i, n) {\n    cin >> a[i];\n    sum[i] = sum[i - 1] + a[i];\n    f[i] = f[i - 1] + (i & 1 ? 1 : -1) * a[i];\n  }\n  if (n % 2 == 0) {\n    Long B = 0, W = 0;\n    rep (i, n) i & 1 ? B += a[i] : W += a[i];\n    cout << max(W, B) << \" \" << min(W, B) << \"\\n\";\n  } else {\n    auto check = [] (Long mid) {\n\t\t   Long pre = 0;\n\t\t   for (int i = 2; i <= n; i += 2) {\n\t\t     if (f[i - 1] - pre >= mid)\n\t\t       pre = min(pre, f[i]);\n\t\t   }\n\t\t   return f[n] - pre >= mid;\n\t\t };\n    Long l = -1e18, r = 1e18;\n    while (l < r) {\n      Long mid = l + (r - l + 1) / 2;\n      if (check(mid)) l = mid;\n      else r = mid - 1;\n    }\n    Long B = 0, W = 0;\n    rep (i, n) i & 1 ? B += a[i] : W += a[i];\n    cout << max(B, W + l) << \" \" << sum[n] - max(B, W + l) << \"\\n\";    \n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int N, a[303030], b[303030], S;\n\nint main(){\n    scanf(\"%lld\", &N);\n    if(N & 1){\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + i);\n            S += a[i];\n            a[i] *= (i & 1) ? -1 : 1;\n        }\n        partial_sum(a, a + N, b);\n        long long ans = b[N - 1];\n        for(int i = 1; i < N; i += 2){\n            ans = max(ans, -a[i] - max(b[N - 1] - b[i] - abs(b[i - 1]), b[i - 1] - abs(b[N - 1] - b[i])));\n        }\n        cout << (S + ans) / 2 << \" \" << (S - ans) / 2 << endl;\n    }else{\n        for(int i = 0; i < N; ++i){\n            scanf(\"%lld\", a + 4);\n            a[i & 1] += a[4];\n        }\n        if(a[0] < a[1])swap(a[0], a[1]);\n        cout << a[0] << \" \" << a[1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\nusing ll = int64_t;\nusing ld = double;\nusing ull = uint64_t;\nusing namespace std;\nusing namespace __gnu_pbds;\n\nconst int MAXN = 300228;\nll a[MAXN];\n\nll sum;\n\nvoid finish(ll delta) {\n    cout << (sum + delta) / 2 << \" \" << (sum - delta) / 2 << \"\\n\";\n    exit(0);\n}\n\nconst ll INF = (1ll << 60);\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        sum += a[i];\n    }\n\n    if (n % 2 == 0) {\n        ll s[2] = { 0, 0 };\n        for (int i = 0; i < n; ++i) {\n            s[i % 2] += a[i];\n        }\n\n        finish(abs(s[0] - s[1]));\n    } else {\n        vector<ll> v{ a, a + n };\n        for (;;) {\n            int sz = v.size();\n            \n            for (int i = 1; i < v.size(); i += 2) {\n                if (v[i] < v[i - 1]) {\n                    v[i + 1] += v[i - 1] - v[i];\n                    v.erase(v.begin() + i - 1, v.begin() + i + 1);\n                    break;\n                }\n\n                if (v[i] < v[i + 1]) {\n                    v[i - 1] += v[i + 1] - v[i];\n                    v.erase(v.begin() + i, v.begin() + i + 2);\n                    break;\n                }\n            }\n\n            if (sz == v.size()) {\n                break;\n            }\n        }\n\n        ll ans = 0;\n        ll mn = INF;\n        for (int i = 0; i < v.size(); ++i) {\n            if (i % 2) {\n                ans += v[i];\n            } else {\n                ans -= v[i];\n                mn = min(mn, v[i]);\n            }\n        }\n\n        finish(ans + 2 *  mn);\n    }\n\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    while (true) cout << \"ね\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint n;\nint B,W;\nint a[300050];\nint s[300050];\nbool judge(int x)\n{\n\tint mn=0;\n\tif(s[n]>=x) return 1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tif(s[i-1]-mn>=x)\n\t\t{\n\t\t\tif(s[n]-s[i]>=x) return 1;\n\t\t\tmn=min(mn,s[i]);\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i&1)\n\t\t{\n\t\t\tB+=a[i];\n\t\t\ts[i]=s[i-1]+a[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tW+=a[i];\n\t\t\ts[i]=s[i-1]-a[i];\n\t\t}\n\t}\n\tif(~n&1)\n\t{\n\t\tprintf(\"%d %d\\n\",max(B,W),min(B,W));\n\t\treturn 0;\n\t}\n\tint l=0,r=B,re=-1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(judge(mid)) l=mid+1,re=mid;\n\t\telse r=mid-1;\n\t}\n\tint an=max(B,W+re);\n\tprintf(\"%d %d\\n\",an,B+W-an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[300005],w,b,n;\nbool chk(int x){\n\tint s=0,las=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(i&1)s+=a[i];\n\t\telse {\n\t\t\tif(s>=las+x){chkmin(las,s-a[i]);}\n\t\t\ts-=a[i];\n\t\t}\n\t}\n\treturn s>=las+x;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tread(n);\n\tfor(int i=1;i<=n;++i){\n\t\tread(a[i]);\n\t\t(i&1?b:w)+=a[i];\n\t}\n\tif(!(n&1))return write(max(w,b),' ',min(w,b),'\\n');\n\tint l=b-w,r=b,mid;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tif(chk(mid))l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tchk(l-1);\n\twrite(w+max(l-1,b-w),' ',b-max(l-1,b-w),'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 301000\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n;\nint h[N], sum[N];\nnamespace jzp1 {\n\tinline void sol() {\n\t\tfor (int i = 1; i <= n; ++i)\tread(h[i]);\n\t\tint tmp1 = 0, tmp2 = 0;\n\t\tfor (int i = 1; i <= n; i += 2) {\n\t\t\ttmp1 += h[i], tmp2 += h[i + 1];\n\t\t}\n\t\tprintf(\"%d %d\\n\", max(tmp1, tmp2), min(tmp1, tmp2));\n\t}\n}\n\ninline bool che(int k) {\n\tint tmp = 0;\n\tfor (int i = 1; i <= n; ++i) if (i & 1) {\n\t\tif (sum[i] - tmp >= k) {\n\t\t\tMIN(tmp, sum[i + 1]);\n\t\t} else if (i == n)\treturn false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tread(n);\n\tif (n % 2 == 0) {\n\t\tjzp1::sol();\n\t\treturn 0;\n\t}\n\tint r = 0, tot = 0, totsum = 0;\n\tfor (int i= 1; i <= n; ++i) read(h[i]), r += h[i], totsum += h[i];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i & 1)\tsum[i] = sum[i - 1] + h[i];\n\t\telse\tsum[i] = sum[i - 1] - h[i], tot += h[i];\n\t}\n\tint l = -r, res = 0;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (che(mid))\tres = mid, l = mid + 1;\n\t\telse\tr = mid - 1;\n\t}\n\tprintf(\"%d %d\\n\", res + tot, totsum - (res + tot));\n\treturn 0;\n}\n\n/*\n5\n20 100 10 1 10\n//120 21\n\n6\n4 5 1 1 4 5\n//11 9\n\n5\n1 10 100 10 1\n//102 20\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nconst int MAX = 300000;\n\nbool check(int *a, int l, int r, int X) {\n\tif (r - l == 1) return a[l] >= X; // 1個しか残っていないならそれを取る\n\tif (a[l] < X || a[l + 1] < a[l]) { // a[l+1]を取らない\n\t\ta[l + 2] += a[l] - a[l + 1];\n\t\treturn check(a, l + 2, r, X);\n\t}\n\t\n\treturn check(a, l + 2, r, X); // a[l+1]を取る\n}\n\nint main() {\n\tint N;\n\tstatic int a[MAX], cpy[MAX]; // cpyはaをコピーして使う用\n\tcin >> N;\n\tfor (int i = 0;i < N;i ++) cin >> a[i];\n\t\n\tint sum[2] = {0, 0}; // sum[0]はoddSum、sum[1]はevenSum\n\tfor (int i = 0;i < N;i ++) {\n\t\tsum[i & 1] += a[i];\n\t}\n\t\n\tif ((N & 1) == 0) { // Nが偶数\n\t\tif (sum[0] < sum[1]) cout << sum[1] << ' ' << sum[0];\n\t\telse cout << sum[0] << ' ' << sum[1];\n\t\treturn 0;\n\t} // Nが奇数\n\t\n\tint ans = 0;\n\tfor (int ng = sum[0] + sum[1], mid = (ng >> 1);ng - ans > 1;mid = ans + ((ng - ans) >> 1)) { // 二分探索\n\t\tmemcpy(cpy, a, sizeof(int) * N);\n\t\tif (check(cpy, 0, N, mid)) ans = mid; // midについて、evenSumを省いた値を最大化するように探索\n\t\telse ng = mid;\n\t}\n\t\n\tcout << sum[1] + ans << ' ' << sum[0] - ans;\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説ACなので何も無いです、解説読んでね\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int N = 3e5 + 5;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, a[N], s[N];\nvoid solve1() {\n\tint s0 = 1, s1 = 0;\n\tfor(int i = 1; i <= n; ++ i) if(i & 1) s0 += a[i]; else s1 += a[i];\n\tprintf(\"%d %d\\n\", max(s0, s1), min(s0, s1));\n}\nbool check(int mid) {\n\tint v = 0;\n\tfor(int i = 1; i < n; i += 2) if(s[i] - v >= mid) v = min(v, s[i + 1]);\n\treturn s[n] - v >= mid;\n}\nvoid solve2() {\n\tfor(int i = 1; i <= n; ++ i) if(i & 1) s[i] = s[i - 1] + a[i]; else s[i] = s[i - 1] - a[i];\n\tint l = 1, r = n * 1000, mid, ans = l;\n\twhile(l <= r) {\n\t\tmid = (l + r) >> 1;\n\t\tif(check(mid)) l = mid + 1, ans = mid;\n\t\telse r = mid - 1;\n\t}\n\tfor(int i = 2; i <= n; i += 2) ans += a[i];\n\tint sum = 0;\n\tfor(int i = 1; i <= n; ++ i) sum += a[i];\n\tprintf(\"%d %d\\n\", ans, sum - ans); \n}\nint main() {\n\tn = read();\n\tfor(int i = 1; i <= n; ++ i) a[i] = read();\n\tif(n % 2 == 0) return solve1(), 0;\n\telse return solve2(), 0;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 301000\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n;\nint h[N], sum[N];\nnamespace jzp1 {\n\tinline void sol() {\n\t\tfor (int i = 1; i <= n; ++i)\tread(h[i]);\n\t\tint tmp1 = 0, tmp2 = 0;\n\t\tfor (int i = 1; i <= n; i += 2) {\n\t\t\ttmp1 += h[i], tmp2 += h[i + 1];\n\t\t}\n\t\tprintf(\"%d %d\\n\", max(tmp1, tmp2), min(tmp1, tmp2));\n\t}\n}\n\ninline bool che(int k) {\n\tint tmp = 0;\n\tfor (int i = 1; i <= n; ++i) if (i & 1) {\n\t\tif (sum[i] - tmp >= k) {\n\t\t\tMIN(tmp, sum[i + 1]);\n\t\t} else if (i == n)\treturn false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tread(n);\n\tif (n % 2 == 0) {\n\t\tjzp1::sol();\n\t\treturn 0;\n\t}\n\tint r = 0, tot = 0, totsum = 0;\n\tfor (int i= 1; i <= n; ++i) read(h[i]), r += h[i], totsum += h[i];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i & 1)\tsum[i] = sum[i - 1] + h[i];\n\t\telse\tsum[i] = sum[i - 1] - h[i], tot += h[i];\n\t}\n\tint l = -r, res = 0;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (che(mid))\tres = mid, l = mid + 1;\n\t\telse\tr = mid - 1;\n\t}\n\tprintf(\"%d %d\\n\", res + tot, totsum - (res + tot));\n\treturn 0;\n}\n\n/*\n5\n20 100 10 1 10\n//120 21\n\n6\n4 5 1 1 4 5\n//11 9\n\n5\n1 10 100 10 1\n//102 20\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=300300;\nint n,L,R,a[N],s[2][N];\nbool chk(int lim){\n\tint mi=0,ret=0;\n\tFOR(i,1,n)if(i&1){\n\t\tif(lim<=s[1][i]-s[0][i]-mi)\n\t\t\tmi=min(mi,s[1][i+1]-s[0][i+1]),ret=i==n;\n\t}return ret;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,1,n) scanf(\"%d\",&a[i]),s[i&1][i]=a[i];\n\tFOR(i,1,n) s[0][i]+=s[0][i-1],s[1][i]+=s[1][i-1];\n\tif(!(n&1)) return cout<<max(s[0][n],s[1][n])<<' '<<min(s[0][n],s[1][n])<<'\\n',0;\n\tL=0,R=s[1][n];\n\twhile(L<R){\n\t\tint md=(L+R+1)>>1;\n\t\tchk(md)?L=md:R=md-1;\n\t}\n\tcout<<s[0][n]+L<<' '<<s[1][n]-L<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef KOMAKI_LOCAL\n#define NDEBUG\n#endif\n\n#include <bits/stdc++.h>\n#include <sys/time.h>\n#include <unistd.h>\nusing namespace std;\n#define i64         int64_t\n#define rep(i, n)   for(i64 i = 0; i < ((i64)(n)); ++i)\n#define sz(v)       ((i64)((v).size()))\n#define bit(n)      (((i64)1)<<((i64)(n)))\n#define all(v)      (v).begin(), (v).end()\n\nstd::string dbgDelim(int &i){ return (i++ == 0 ? \"\" : \", \"); }\n#define dbgEmbrace(exp) { int i = 0; os << \"{\"; { exp; } os << \"}\"; return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp);\ntemplate <int INDEX, class TUPLE> void dbgDeploy(std::ostream &os, TUPLE tuple){}\ntemplate <int INDEX, class TUPLE, class H, class ...Ts> void dbgDeploy(std::ostream &os, TUPLE t)\n{ os << (INDEX == 0 ? \"\" : \", \") << get<INDEX>(t); dbgDeploy<INDEX + 1, TUPLE, Ts...>(os, t); }\ntemplate <class T, class K> void dbgDeploy(std::ostream &os, std::pair<T, K> p, std::string delim)\n{ os << \"(\" << p.first << delim << p.second << \")\"; }\ntemplate <class ...Ts> std::ostream& operator<<(std::ostream &os, std::tuple<Ts...> t)\n{ os << \"(\"; dbgDeploy<0, std::tuple<Ts...>, Ts...>(os, t); os << \")\"; return os; }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p)\n{ dbgDeploy(os, p, \", \"); return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v)\n{ dbgEmbrace( for(T t: v){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> s)\n{ dbgEmbrace( for(T t: s){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q)\n{ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.front(); }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q)\n{ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.top();   }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp)\n{ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp)\n{ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\n#define DBG_OUT std::cerr\n#define DBG_OVERLOAD(_1, _2, _3, _4, _5, _6, macro_name, ...) macro_name\n#define DBG_LINE() { char s[99]; sprintf(s, \"line:%3d | \", __LINE__); DBG_OUT << s; }\n#define DBG_OUTPUT(v) { DBG_OUT << (#v) << \"=\" << (v); }\n#define DBG1(v, ...) { DBG_OUTPUT(v); }\n#define DBG2(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG1(__VA_ARGS__); }\n#define DBG3(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG2(__VA_ARGS__); }\n#define DBG4(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG3(__VA_ARGS__); }\n#define DBG5(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG4(__VA_ARGS__); }\n#define DBG6(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG5(__VA_ARGS__); }\n\n#define DEBUG0() { DBG_LINE(); DBG_OUT << std::endl; }\n#define DEBUG(...)                                                      \\\n  {                                                                     \\\n    DBG_LINE();                                                         \\\n    DBG_OVERLOAD(__VA_ARGS__, DBG6, DBG5, DBG4, DBG3, DBG2, DBG1)(__VA_ARGS__); \\\n    DBG_OUT << std::endl;                                               \\\n  }\n\n\nint main()\n{\n  i64 n;\n  cin >> n;\n  vector<i64> v(n);\n  rep(i, n) cin >> v[i];\n  if(sz(v) % 2 == 0){\n    i64 t[] = {0, 0};\n    rep(i, sz(v)) t[i % 2] += v[i];\n    cout << max(t[0], t[1]) << \" \" << min(t[0], t[1]) << endl;\n    return 0;\n  }\n  \n  vector<i64> odd_left(n);\n  vector<i64> odd_right(n);\n  vector<i64> even_left(n);\n  vector<i64> even_right(n);\n  rep(i, n){\n    odd_left[i] = odd_left[i] + (i % 2 == 0 ? v[i] : 0);\n    even_left[i] = even_left[i] + (i % 2 == 1 ? v[i] : 0);\n  }\n  reverse(all(v));\n  rep(i, n){\n    odd_right[i] = odd_right[i] + (i % 2 == 0 ? v[i] : 0);\n    even_right[i] = even_right[i] + (i % 2 == 1 ? v[i] : 0);\n  }\n  reverse(all(odd_right));\n  reverse(all(even_right));\n  \n  i64 best = odd_left[sz(v) - 1];\n  \n  rep(i, n){\n    if(i % 2 == 0) continue;\n    i64 total_0 = even_left[i] + odd_right[i + 1];\n    i64 total_1 = even_right[i] + odd_left[i - 1];\n    best = max(best, min(total_0, total_1));\n  }\n  \n  i64 total = 0;\n  rep(i, n) total += v[i];\n  cout << best << \" \" << total - best << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define N 300012\nint n,co[2],a[N],s[N],ans=0;\ninline bool can(int mid){int i,v=0;for(i=2;i<=n;i+=2)if(s[i-1]>=(mid+v))v=min(v,s[i]);return (s[n]>=(mid+v));}\nint main(){\n\tscanf(\"%d\",&n);int i,l,r,mid;for(i=1;i<=n;i++){scanf(\"%d\",&a[i]);co[i&1]+=a[i];}\n\tif(!(n&1)){printf(\"%d %d\",max(co[0],co[1]),min(co[0],co[1]));return 0;}\n\tfor(i=1;i<=n;i++)s[i]=s[i-1]+((i&1)?a[i]:(-a[i]));l=1;r=1e9;\n\twhile(l<=r){mid=(l+r)>>1;if(can(mid)){ans=mid;l=mid+1;}else r=mid-1;}printf(\"%d %d\",co[0]+ans,co[1]-ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mpcy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\ntypedef vector<int> poly;\nconst int MAXN = 300005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = - 1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n, a[MAXN], sum[MAXN], B, W;\n\ninline bool check(int M) {\n\tint pre = 0;\n\tfor (int i = 2; i <= n; i += 2) {\n\t\tif (sum[i - 1] - pre >= M) {\n\t\t\tpre = min(pre, sum[i]);\n\t\t}\n\t}\n\treturn (sum[n] - pre >= M);\n}\n\nvoid init() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(a[i]);\n\t\tif (i & 1) {\n\t\t\tB += a[i];\n\t\t\tsum[i] = sum[i - 1] + a[i];\n\t\t} else {\n\t\t\tW += a[i];\n\t\t\tsum[i] = sum[i - 1] - a[i];\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tif (n % 2 == 0) {\n\t\tprintf(\"%d %d\\n\", max(B, W), min(B, W));\n\t\treturn;\n\t}\n\tint L = -3e8, R = -L, P;\n\twhile (L <= R) {\n\t\tint M = (L + R) >> 1;\n\t\tif (check(M)) {\n\t\t\tL = (P = M) + 1;\n\t\t} else {\n\t\t\tR = M - 1;\n\t\t}\n\t}\n\tint A = max(B, W + P);\n\tprintf(\"%d %d\\n\", A, B + W - A);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 3e5;\n\nint n;\n\nint a[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) a[i] = read<int>();\n}\n\ninline void solve()\n{\n\tif(n % 2 == 0)\n\t{\n\t\tint sum[2] = {0, 0};\n\t\tfor(int i = 1; i <= n; ++i) sum[i & 1] += a[i];\n\t\tprintf(\"%d %d\\n\", max(sum[0], sum[1]), min(sum[0], sum[1]));\n\t\treturn;\n\t}\n\n\tconst int INF = (int) 1e9;\n\n\tstatic int b[MAXN + 5];\n\tfor(int i = 1; i <= n; ++i) b[i] = (i & 1 ? +1 : -1) * a[i];\n\tfor(int i = 1; i <= n; ++i) b[i] += b[i - 1];\n\n\tauto check = [&] (int X)\n\t{\n\t\tstatic int f[MAXN + 5];\n\n\t\tint mn = 0;\n\t\tfor(int i = 1; i <= n; ++i) if(i % 2 == 1 && (f[i] = (b[i] - mn >= X))) chkmin(mn, b[i + 1]);\n\t\treturn f[n];\n\t};\n\n\tint l = 0, r = INF;\n\twhile(l < r)\n\t{\n\t\tint mid = (l + r + 1) / 2;\n\t\tif(check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\n\tint ans = l, sum = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tif(i % 2 == 0) ans += a[i];\n\t\tsum += a[i];\n\t}\n\tprintf(\"%d %d\\n\", ans, sum - ans);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define pii pair<int,int>\n#define mp make_pair\nusing namespace std;\n\nint n,a[N],B,W,tot,fa[N],sum[N];\npii q[N];\n\nint find(int x){return fa[x]<0?x:fa[x]=find(fa[x]);}\n\ninline void merge(int t1,int t2,int val)\n{\n\tif(fa[t1]<fa[t2]) swap(t1,t2);\n\tsum[t2]+=sum[t1]-val;\n\tfa[t2]+=fa[t1];\n\tfa[t1]=t2;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i&1) B+=a[i];\n\t\telse W+=a[i];\n\t\tfa[i]=-1;\n\t\tsum[i]=a[i];\n\t}\n\tif(n&1)\n\t{\n\t\tint l=1e9;\n\t\tfor(int i=2;i<n;i+=2)\n\t\t\tq[++tot]=mp(a[i],i);\n\t\tsort(q+1,q+1+tot);\n\t\tfor(int i=1;i<=tot;++i)\n\t\t{\n\t\t\tint t1=find(q[i].second-1),t2=find(q[i].second+1);\n\t\t\tif(sum[t1]+sum[t2]>=q[i].first) merge(t1,t2,q[i].first);\n\t\t}\n\t\tfor(int i=1;i<=n;i+=2) l=min(l,sum[find(i)]);//,printf(\"%d %d\\n\",find(i),sum[find(i)]);\n\t\tprintf(\"%d %d\",W+l,B-l);\n\t}\n\telse printf(\"%d %d\",max(W,B),min(W,B));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 300200;\nconst int mod = 998244353;\ntypedef long long ll;\ninline ll pow(ll a,int b,ll ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1) ans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\ninline void reduce(int & x){ x += x >> 31 & mod; }\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nint sum;\nint n, a[maxn];\nint a0[maxn], a1[maxn];\nint s0[maxn];\ninline void output(int x) { std::cout << x << ' ' << sum - x << '\\n', exit(0); }\ninline bool ok(int x) {\n\tint k = 0;\n\tfor(int i = 2;i <= n;i += 2) if(s0[i - 1] - k >= x) k = std::min(k, s0[i]);\n\treturn s0[n] - k >= x;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor(int i = 1;i <= n;++i){\n\t\tstd::cin >> a[i], sum += a[i];\n\t\ta0[i] = a0[i - 1];\n\t\ta1[i] = a1[i - 1];\n\t\ti[i & 1 ? a0 : a1] += a[i];\n\t}\n\tif(n % 2 == 0) output(std::max(a0[n], a1[n]));\n\tfor(int i = 1;i <= n;++i) s0[i] = s0[i - 1] + (i & 1 ? a[i] : -a[i]);\n\tint l = 0,r = 1e9;\n\tfor(;l + 1 != r;) {\n\t\tint mid = l + r >> 1;\n\t\t(ok(mid) ? l : r) = mid;\n\t}\n\toutput(a1[n] + l);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 1234568\n\nusing namespace std;\ntypedef long long ll;\nll n,ans,a[maxn],s[maxn],t[maxn],p[maxn],q[maxn],sum,res;\n\nint main(){\n    cin >> n;\n    for (int i=1;i<=n;i++) cin >> a[i];\n    for (int i=1;i<=n;i++) sum+=a[i];\n    for (int i=1;i<=n;i+=2) ans+=a[i];\n    for (int i=2;i<=n;i+=2) res+=a[i];\n    ans=max(ans,res);\n    if (n%2==0){\n        cout << ans << ' ' << sum-ans << endl;\n    }\n    else {\n        res=0; for (int i=1;i<=n;i+=2) res+=a[i],s[i]=res;\n        res=0; for (int i=2;i<=n;i+=2) res+=a[i],t[i]=res;\n        res=0; for (int i=n;i>=1;i-=2) res+=a[i],p[i]=res;\n        res=0; for (int i=n-1;i>=2;i-=2) res+=a[i],q[i]=res;\n        for (int i=2;i<n;i+=2) {\n            ans=max(ans,a[i]+min(s[i-1]+q[i+2],t[i-2]+p[i+1]));\n        }\n        cout << ans << ' ' << sum-ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<unordered_map>\ntypedef unsigned int u32;\nconst int N=3e5+5;\nint n,a[N],s[N][2],f[N],g[N];\ntemplate<class T>T abs(T x){return x<0?-x:x;}\ntemplate<class T>bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>T min(T a,T b){return a<b?a:b;}\ninline int fin(int l,int r){return (s[r][0]-s[l-1][0])-(s[r][1]-s[l-1][1]);}\ninline int calc(int l,int r){return abs(fin(l,r));}\nint main(){\n\tint i,j;\n\tscanf(\"%d\",&n);\n///\tif(n>10000)exit(0);\n\tfor(i=1;i<=n;i++)s[i][0]=s[i-1][0],s[i][1]=s[i-1][1],scanf(\"%d\",a+i),s[i][i&1]+=a[i];\n\tint dif=abs(s[n][0]-s[n][1]);\n\tif(n&1){\n\t\tfor(i=1;i<=n;i+=2){\n\t\t\tf[i]=calc(1,i); \n\t\t\tfor(j=2;j<i;j+=2)chkmax(f[i],a[j]+min(f[j-1]+fin(j+1,i),fin(1,j-1)+calc(j+1,i)));\n\t\t}\n\t\tfor(i=n;i>=1;i-=2){\n\t\t\tg[i]=calc(i,n);\n\t\t\tfor(j=i+1;j<n;j+=2)chkmax(g[i],a[j]+min(calc(i,j-1)+fin(j+1,n),fin(i,j-1)+g[j+1]));\n\t\t}\n\t\tfor(i=2;i<n;i+=2){\n\t\t\tchkmax(dif,a[i]+min(fin(1,i-1)+g[i+1],f[i-1]+fin(i+1,n)));\n\t\t}\n\t}\n\tu32 sum=(u32)s[n][0]+s[n][1];\n\tu32 sigma=(sum-dif)>>1,sugim=sigma+dif;\n\tprintf(\"%u %u\\n\",sugim,sigma);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n#define rep(i, j, k) for (int i = (j); i <= (k); i++)\n#define per(i, j, k) for (int i = (j); i >= (k); i--)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nconst int N = 3e5+3;\nint n,a[N];\nll sum[2],ans,s[N];\n\nbool chk(int x){\n    ll v=0;\n    rep(i,1,n) if(s[i]-v>=x) v=min(v,s[i+1]);\n    return s[n]-v>=x;\n}\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n) scanf(\"%d\",&a[i]);\n    rep(i,1,n) sum[i&1]+=a[i];\n    if(n%2==0){\n        printf(\"%lld %lld\\n\",max(sum[0],sum[1]),min(sum[0],sum[1]));\n        return 0;\n    }\n    rep(i,1,n) s[i]=s[i-1]+a[i]*((i&1)?1:-1);\n    ll l=1,r=n*1000,mid;\n    while(l<r){\n        mid=(1+l+r)>>1;\n        if(chk(mid)) l=mid;\n        else r=mid-1;\n    }\n    for(int i = 2; i <= n; i+=2) l+=a[i];\n    printf(\"%lld %lld\\n\",l,sum[0]+sum[1]-l);\n    return 0;\n}\n/*\n不妨设先手是 A，后手是 B。定义 i 为奇数时，ai 为\"奇数位上的数\"；i 为偶数时， ai 为\"偶数位上的数\"。定义左、右两端的数分别表示 a1 和 an。\n\n考虑第一步：\n\n首先，如果 A 取了左右某一个端点，那么他必然能取走和他取的点奇偶性相同的所有点。\n\n然后，我们考虑 A 取了一个中间点后会发生什么：如果这个点左边和右边的剩余点数都是奇数，那么无论 B 取左还是右，取完某一边之后，问题规模缩小成另一边的情况，A 一定还是先手；否则 B 就可以取剩余点数为偶数的那一边，并成为先手。\n\n考虑 n 为偶数的情况。\n\n如果 A 取了一个中间点，那么一定有一边剩余奇数个，一边剩余偶数个。那么 B 一定先操作偶数个的那一边，然后获得奇数那一边的先手权，然后取最优策略。那么 A 还不如直接取偶数那一边的端点，这样做不仅取到了前一种方案能取到的，而且让 B 在另一边没有了先手选择权，一定不劣于前一种方案。\n\n所以，当 n 为偶数时，先手能取到的最大值为 max(奇数位之和, 偶数位之和) 。\n\nn 为奇数的情况较为复杂。\n\n但是同理，A 不会去取一个位于奇数位的数，这样会导致两边剩余个数都为偶数，不如直接取两端。\n\n于是，n 为奇数时，A 只有两种策略：\n\n取端点，即拿走所有奇数位的数。\n取某一个偶数位的数。此时，如果 B 取左边，那么 A 会继续获得右边的先手权；否则 A 获得左边的先手权。这个过程可以看作问题规模的缩小。\n如果将第二种策略用二叉树的形式表示出来，那么 B 一定会选择某一个叶子，使得最终答案最小。\n\n考虑先假设所有偶数位的贡献都已被 A 收取，那么 A 在一个区间执行“取端点”操作得到的收益就是这个区间的奇数位之和减去偶数位之和（注意这里的两端点一定都是奇数）。\n\n我们要做的是找出一个叶子集合，使得对这些叶子“取端点”的收益的最小值尽量大。\n\n考虑二分答案x，之后问题转化为是否可以删除某些偶数位上的数，使得剩下的序列中任意一个极大的连续段之和(奇数位之和减偶数位之和)都不小于x。\n\n考虑暴力DP，枚举右端点，然后再暴力枚举前一个划分点。时间复杂度不可接受。\n\n由于DP信息只有“能”和“不能”，所以我们可以考虑贪心，只保留“能”的点中前缀和最小的即可。\n\n时间复杂度 O(nlog∑ai)。\n*/"
  },
  {
    "language": "C++",
    "code": "出演料1点だけください 0.1点でもいいです"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e6 + 1000;\nint n,a[N],sum[N],s[2];\nint check(int x)\n{\n\tint k = 0;\n\tfor(int i = 2;i <= n;i += 2)\n\t\tif(sum[i - 1] - k >= x) k = min(sum[i],k); \n\treturn sum[n] - k >= x;\n}\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++) s[i & 1] += (a[i] = read());\n\tif((n & 1) == 0) {cout << max(s[0],s[1]) << \" \" << min(s[0],s[1]); return 0;}\n\telse\n\t{\n\t\tfor(int i = 1;i <= n;i ++) sum[i] = sum[i - 1] + (i & 1 ? a[i] : -a[i]);\n\t\tint l = 0,r = s[0] + s[1],mid,ans = 0;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(check(mid)) {ans = mid; l = mid + 1;}\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tcout << s[0] + ans << \" \" << s[1] - ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nnamespace zyt\n{\n\ttemplate<typename T>\n\tinline bool read(T &x)\n\t{\n\t\tchar c;\n\t\tbool f = false;\n\t\tx = 0;\n\t\tdo\n\t\t\tc = getchar();\n\t\twhile (c != EOF && c != '-' && !isdigit(c));\n\t\tif (c == EOF)\n\t\t\treturn false;\n\t\tif (c == '-')\n\t\t\tf = true, c = getchar();\n\t\tdo\n\t\t\tx = x * 10 + c - '0', c = getchar();\n\t\twhile (isdigit(c));\n\t\tif (f)\n\t\t\tx = -x;\n\t\treturn true;\n\t}\n\ttemplate<typename T>\n\tinline void write(T x)\n\t{\n\t\tstatic char buf[20];\n\t\tchar *pos = buf;\n\t\tif (x < 0)\n\t\t\tputchar('-'), x = -x;\n\t\tdo\n\t\t\t*pos++ = x % 10 + '0';\n\t\twhile (x /= 10);\n\t\twhile (pos > buf)\n\t\t\tputchar(*--pos);\n\t}\n\tconst int N = 1e5 + 10;\n\tint arr[N], W, B, n;\n\tbool check(const int x)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 2; i <= n; i += 2)\n\t\t{\n\t\t\tsum += arr[i - 1];\n\t\t\tif (sum >= x - W)\n\t\t\t\tsum = 0;\n\t\t\telse\n\t\t\t\tsum -= arr[i];\n\t\t}\n\t\tsum += arr[n];\n\t\treturn sum >= x - W;\n\t}\n\tint work()\n\t{\n\t\tread(n);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tread(arr[i]);\n\t\tfor (int i = 1; i <= n; i += 2)\t\n\t\t\tB += arr[i];\n\t\tfor (int i = 2; i <= n; i += 2)\n\t\t\tW += arr[i];\n\t\tif (!(n & 1))\n\t\t\tprintf(\"%d %d\", max(B, W), min(B, W));\n\t\telse\n\t\t{\n\t\t\tint l = B + 1, r = (B + W), ans = B;\n\t\t\twhile (l <= r)\n\t\t\t{\n\t\t\t\tint mid = (l + r) >> 1;\n\t\t\t\tif (check(mid))\n\t\t\t\t\tl = mid + 1, ans = mid;\n\t\t\t\telse\n\t\t\t\t\tr = mid - 1;\n\t\t\t}\n\t\t\tprintf(\"%d %d\", ans, B + W - ans);\n\t\t}\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\treturn zyt::work();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[303030];\nll B[303030];\nint S[303030][2];\n\nint ok(ll v) {\n\tint i;\n\tFOR(i,N) B[i]=A[i];\n\t\n\tint cur=N-1;\n\t\n\twhile(cur>0) {\n\t\tif(B[cur]>=v && B[cur-1]>=B[cur]) {\n\t\t\tv -= B[cur-1]-B[cur];\n\t\t}\n\t\telse {\n\t\t\tB[cur-2]+=B[cur]-B[cur-1];\n\t\t}\n\t\tcur-=2;\n\t}\n\t\n\treturn B[0]>=v;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i];\n\t\tS[i+1][0]=S[i][0];\n\t\tS[i+1][1]=S[i][1];\n\t\tS[i+1][i%2]+=A[i];\n\t}\n\tif(N%2==0) {\n\t\tcout<<max(S[N][0],S[N][1])<<\" \"<<min(S[N][0],S[N][1])<<endl;\n\t\treturn;\n\t}\n\t\n\tll Z=-1LL<<40;\n\tfor(i=40;i>=0;i--) if(ok(Z+(1LL<<i))) Z+=1LL<<i;\n\t\n\tcout<<(S[N][1]+Z)<<\" \"<<(S[N][0]-Z)<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 300000;\nconst int INF = (1 << 30);\n\nint s[2], sum[MAXN + 5], a[MAXN + 5], N;\nbool check(int x) {\n\tint k = 0;\n\tfor(int i=2;i<=N;i+=2) {\n\t\tif( sum[i-1] - k >= x )\n\t\t\tk = min(k, sum[i]);\n\t}\n\treturn sum[N] - k >= x;\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d\", &a[i]), s[i & 1] += a[i];\n\tif( N % 2 == 0 )\n\t\tprintf(\"%d %d\\n\", max(s[0], s[1]), min(s[0], s[1]));\n\telse {\n\t\tfor(int i=1;i<=N;i++) sum[i] = sum[i-1] + (i & 1 ? a[i] : -a[i]);\n\t\tint le = 0, ri = s[0] + s[1];\n\t\twhile( le < ri ) {\n\t\t\tint mid = (le + ri + 1) >> 1;\n\t\t\tif( check(mid) ) le = mid;\n\t\t\telse ri = mid - 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\", s[0] + le, s[1] - le);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 300000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,a[MN+5],tot[2],ans,s[MN+5],L[MN+5],R[MN+5];\nbool Solve(int lim)\n{\n    int mn=1e9;memset(L,0,sizeof(L));\n    for(int j=2;j<=n;j+=2)\n    {\n        if(tot[0]+s[j-1]>=lim) mn=min(mn,s[j]),L[j]=true;\n        if(tot[0]+s[j-1]-mn>=lim) L[j]=true;\n    }\n    mn=-1e9;\n    for(int j=n-1;j;j-=2)\n    {\n        int fg=0;\n        if(tot[0]+s[n]-s[j]>=lim) fg=1,mn=max(mn,s[j-1]);\n        if(tot[0]+mn-s[j]>=lim) fg=1;\n        if(fg&&L[j]) return true;\n    }\n    return false;\n}\nint main()\n{   \n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read(),tot[i&1]+=a[i];\n    if(~n&1) return 0*printf(\"%d %d\\n\",max(tot[0],tot[1]),min(tot[1],tot[0]));\n    ans=max(tot[0],tot[1]);\n    int l=ans+1,r=tot[0]+tot[1],mid;\n    for(int i=1;i<=n;++i) s[i]=s[i-1]+((i&1)?1:-1)*a[i];\n    while(l<=r)\n    {\n        mid=l+r>>1;\n        if(Solve(mid)) ans=mid,l=mid+1;\n        else r=mid-1;\n    }\n    printf(\"%d %d\\n\",ans,tot[0]+tot[1]-ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 300010\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint sum[N];\ninline int check(int dat,int n) {\n    int Min=0;\n    for (int i=2;i<=n;i+=2) \n        if (dat<=sum[i-1]-Min) Min=min(Min,sum[i]);\n    return dat<=sum[n]-Min;\n}\nint main() {\n    int n=read(),A=0,B=0;\n    for (int i=1;i<=n;i++) {\n        int dat=read(); sum[i]=sum[i-1];\n        if (i&1) A+=dat,sum[i]+=dat; else B+=dat,sum[i]-=dat;\n    }\n    if (!(n&1)) return printf(\"%d %d\",max(A,B),min(A,B));\n    int l=-1e8,r=1e8,ans=0;\n    while (l<=r) {\n        int mid=(l+r)>>1;\n        if (check(mid,n)) ans=mid,l=mid+1; else r=mid-1;\n    }\n    printf(\"%d %d\",max(A,B+ans),A+B-max(A,B+ans));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<cstdio>\nusing namespace std;\n#define re register\n#define cmax(a,b) ((a)>(b)?(a):(b))\nint a[300100],c[300100],n;\nbool check(re int x)\n{\n\tint x1=0;\n\tfor(re int i=2;i<=n;i+=2)\n\t{\n\t\tx1+=a[i-1];\n\t\tif(x1>=x&&x1<a[i])x1=0;\n\t\telse x1-=a[i];\n\t}x1+=a[n];\n\treturn (x1>=x);\n}\nint main()\n{\n\tre int w=0;\n\tscanf(\"%d\",&n);\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);w+=a[i];c[i]=a[i];\n\t\tif(i>2)c[i]+=c[i-2];\n\t}if(n&1)\n\t{\n\t\tre int l=0,r=w;\n\t\tfor(re int mid=(l+r+1)>>1;l<r;mid=(l+r+1)>>1)\n\t\t{\n\t\t\tif(check(mid))l=mid;else r=mid-1;\n\t\t}printf(\"%d %d\\n\",l+c[n-1],w-l-c[n-1]);\n\t}\n\telse \n\t{\n\t\tif(c[n-1]>c[n])printf(\"%d %d\",c[n-1],c[n]);\n\t\telse printf(\"%d %d\",c[n],c[n-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint n,m,a[300011],l,r,sum[2],s;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)sum[i%2]=sum[i%2]+a[i];\n\tif((n%2)==1)\n\t{\n\t\tint l=1,r=2000000000;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=(l+r+1)/2;\n\t\t\ts=0;\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif((i%2)==1)s=s+a[i];\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tif((s>=mid)&&(s-a[i]<0))s=0;\n\t\t\t\t\telse s=s-a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s>=mid)l=mid;\n\t\t\telse r=mid-1; \n\t\t}\n\t\tsum[0]=sum[0]+l;\n\t\tsum[1]=sum[1]-l;\n\t}\n\tif(sum[0]>sum[1])printf(\"%d %d\\n\",sum[0],sum[1]);\n\telse printf(\"%d %d\\n\",sum[1],sum[0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define fo(x,a,b) for(int x=(a),e_=(b);x<=e_;x++)\n#define Max(a,b) ((a)>(b)?(a):(b))\n\nconst int N=300005;\nint f[N],a[N],n,B,W,ans;\nbool pd[N];\n\nvoid In(int& a){\n\ta=0;char c=getchar();for(;c<48||c>57;c=getchar());\n\tfor(;c>47&&c<58;c=getchar()) a=(a<<1)+(a<<3)+c-48;\n}\nbool ck(int mid){\n\tint tr=0;\n\tfor(int i=2; i<=n+1; i+=2) {\n\t\tif(f[i-1]-f[tr] >= mid) {\n\t\t\tif(f[i]<f[tr]) tr=i;\n\t\t\tif(i==n+1) return true;\n\t\t} \n\t}return false;\n}\nint main(){\n\tIn(n);\n\tfo(i,1,n) {\n\t\tIn(a[i]);\n\t\tf[i]=f[i-1];\n\t\tif(i&1) B+=a[i], f[i]+=a[i]; else W+=a[i], f[i]-=a[i];\n\t}f[n+1]=f[n];\n\tans=Max(B,W);\n\tif(n%2==0) {printf(\"%d %d\",ans,B+W-ans);return 0;}\n\n\tint l=ans-W+1,r=B+W,mid,k=0;\n\twhile(l<=r) {\n\t\tmid=(l+r)>>1;\n//\t\tprintf(\"mid:%d\\n\",mid);\n\t\tif(ck(mid)) l=mid+1, k=mid; else r=mid-1;\n\t}\n\tans=Max(ans,B+k);\n\tprintf(\"%d %d\",ans,B+W-ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<unordered_map>\ntypedef unsigned int u32;\nconst int N=3e5+5;\nint n,a[N],s[N][2];\ntemplate<class T>T abs(T x){return x<0?-x:x;}\ntemplate<class T>bool chkmax(T&a,T b){return a<b?a=b,true:false;}\ntemplate<class T>T min(T a,T b){return a<b?a:b;}\nstd::unordered_map<int,int>dd[N];\nint solve(int l,int r){\n\tif(l==r)return a[l];\n\tint res=abs((s[r][0]-s[l-1][0])-(s[r][1]-s[l-1][1])),c,x;\n\tif(l!=1&&r!=n)return res;\n\tif(dd[l].count(r))return dd[l][r];\n\tif((l^r^1)&1){\n\t\tc=!(l&1);\n\t\tfor(x=l+1;x<=r;x+=2){\n\t\t\tchkmax(res,min(solve(l,x-1)+(s[r][c]-s[x-1][c])-(s[r][c^1]-s[x-1][c^1]),solve(x+1,r)+(s[x][c]-s[l-1][c])-(s[x][c^1]-s[l-1][c^1])));\n\t\t}\n\t}\n\treturn dd[l][r]=res;\n}\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tif(n>10000)return 0;\n\tfor(i=1;i<=n;i++)s[i][0]=s[i-1][0],s[i][1]=s[i-1][1],scanf(\"%d\",a+i),s[i][i&1]+=a[i];\n\tu32 dif=solve(1,n);\n\tu32 sum=(u32)s[n][0]+s[n][1];\n\tu32 sigma=(sum-dif)>>1,sugim=sigma+dif;\n\tprintf(\"%u %u\\n\",sugim,sigma);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n; ll a[SZ],B,W;\nll qz[SZ];\nbool ok(ll t)\n{\n\tll mo=0;\n\tfor(int i=2;i<=n-1;i+=2)\n\t\tif(qz[i-1]-mo>=t) mo=min(mo,qz[i]);\n\treturn qz[n]-mo>=t;\n}\nll calc()\n{\n\tll l=-1e18,r=1e18;\n\twhile(l<r)\n\t{\n\t\tll g=l+((r-l+1)>>1);\n\t\tif(ok(g)) l=g; else r=g-1;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",a+i);\n\t\tif(i%2==0) W+=a[i],qz[i]=qz[i-1]-a[i];\n\t\telse B+=a[i],qz[i]=qz[i-1]+a[i];\n\t}\n\tif(n%2==0)\n\t{\n\t\tprintf(\"%lld %lld\\n\",max(W,B),min(W,B));\n\t\treturn 0;\n\t}\n\tll ans=W+calc();\n\tprintf(\"%lld %lld\\n\",ans,B+W-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int n;\n   cin >> n;\n   vector<int> a(n);\n   int evenSum = 0;\n   int oddSum = 0;\n   for (int i = 0; i < n; ++i) {\n      cin >> a[i];\n      if (i % 2) {\n         oddSum += a[i];\n      } else {\n         evenSum += a[i];\n      }\n   }\n   if (n % 2 == 0) {\n      cout << max(evenSum, oddSum) << \" \" << min(evenSum, oddSum) << \"\\n\";\n      return 0;\n   }\n   int l = 0, r = 1e9;\n   while (l < r) {\n      int md = (l + r + 1) >> 1;\n      vector<int> f(n);\n      for (int i = 0; i < n; i += 2) {\n         if (i == 0) {\n            f[i] = a[i];\n         } else if (f[i - 2] < md) {\n            f[i] = f[i - 2] - a[i - 1] + a[i];\n         } else {\n            f[i] = max(f[i - 2] - a[i - 1] + a[i], a[i]);\n         }\n      }\n      if (f[n - 1] >= md) {\n         l = md;\n      } else {\n         r = md - 1;\n      }\n   }\n   cout << oddSum + l << \" \" << evenSum - l << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 300010;\n\nint n;\nint a[MAX_N];\nint dp[MAX_N];\nint sum[2][MAX_N];\n\nvoid quadratic_dp ()\n{\n\n\tdp[0] = +(1 << 30);\n\tfor (int i = 1; i * 2 <= (n + 1); i ++)\n\t{\n\t\tdp[i] = -(1 << 30); /// infinty\n\t\tfor (int j = 0; j < i; j ++)\n        {\n            ///printf (\"%d %d - %d\\n\", j * 2, dp[j], sum[0][i * 2 - 1] - sum[0][j * 2] - (sum[1][i * 2 - 1] - sum[1][j * 2]));\n\t\t\tdp[i] = max (dp[i], min (dp[j], sum[1][i * 2 - 1] - sum[1][j * 2] - (sum[0][i * 2 - 1] - sum[0][j * 2])));\n        }\n\t\t///printf (\"%d %d\\n\", i, dp[i]);\n\t}\n}\n\n/**\nvoid nlong_dp ()\n{\n    int l, r, mid;\n\n    l =\n}\n**/\n\nint main ()\n{\n\tscanf (\"%d\", &n);\n\tfor (int i = 1; i <= n; i ++)\n\t\tscanf (\"%d\", &a[i]);\n\n\tint s[2] = {0, 0};\n\n\tfor (int i = 1; i <= n; i ++)\n\t\ts[i & 1] += a[i];\n\n\tif (!(n & 1))\n\t{\n\t\tprintf (\"%d %d\\n\", max (s[0], s[1]), min (s[0], s[1]));\n\t\treturn 0;\n\t}\n\n\tsum[0][0] = sum[1][0] = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tsum[0][i] = sum[0][i - 1];\n\t\tsum[1][i] = sum[1][i - 1];\n\t\tsum[i & 1][i] += a[i];\n\t}\n\n\tquadratic_dp ();\n\t///nlogn_dp ();\n\n\tprintf (\"%d %d\\n\", (s[0] + dp[(n / 2) + 1]), (s[1] - dp[(n / 2) + 1]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\nconst int N=3e5+5;\nint n,a[N],b[N],w[N];\n\nbool ok(int X)\n{\n\tint mx=0;\n\tfor(int i=1;i<=n;i+=2)\n\tif(b[i]-w[i]+mx>=X)\n\t{\n\t\tif(i==n)return 1;\n\t\tmx=max(mx,-b[i]+w[i+1]);\n\t}\n\treturn 0;\n}\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tcin>>n;\n\trep(i,1,n)\n\t{\n\t\tscanf(\"%d\",a+i);\n\t\tb[i]=b[i-1]+a[i]*(i%2);\n\t\tw[i]=w[i-1]+a[i]*(i%2==0);\n\t}\n\tif(n%2==0)\n\t{\n\t\tprintf(\"%d %d\\n\",max(b[n],w[n]),b[n]+w[n]-max(b[n],w[n]));\n\t\texit(0);\n\t}\n\tint l=max(0,b[n]-w[n]),r=b[n]+1;\n\twhile(l+1!=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(ok(mid))l=mid;\n\t\telse r=mid;\n\t}\n\tprintf(\"%d %d\\n\",w[n]+l,b[n]+w[n]-(w[n]+l));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MaxN = 300010;\n\nint n, a[MaxN], pe[2], sum[MaxN];\n\nbool check(int m) {\n  int t = 0;\n  for (int i = n - 1; i; i -= 2)\n    if (m + t <= sum[i])\n      t = min(t, sum[i - 1]);\n  return sum[0] - t >= m;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  int total = 0;\n  for (int i = 0; i < n; i++)\n    scanf(\"%d\", &a[i]), total += a[i];\n  for (int i = 0; i < n; i++)\n    pe[i & 1] += a[i];\n  int ans = 0;\n  if (!(n & 1)) {\n    ans = max(pe[0], pe[1]); \n  } else {\n    for (int i = n, s = 1; i--; s = -s)\n      sum[i] = sum[i + 1] + s * a[i];\n    int l = 0, r = INT_MAX >> 2;\n    while (l + 1 < r) {\n      int m = l + r >> 1;\n      check(m) ? (l = m) : (r = m);\n    }\n    ans = pe[1] + l;\n  } \n  printf(\"%d %d\\n\", ans, total - ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 300005\n#define pii pair<int,int>\n#define mp make_pair\nusing namespace std;\n\nint n,a[N],B,W,tot,fa[N],sum[N];\npii q[N];\nbool f[N];\n\ninline bool check(int x)\n{\n\tint minn=0;\n\tfor(int i=2;i<=n;i+=2)\n\t{\n\t\tif(sum[i-1]-x>=minn) f[i]=1;\n\t\telse f[i]=0;\n\t\tif(f[i]) minn=min(minn,sum[i]);\n\t}\n\treturn f[n];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i&1) B+=a[i],sum[i]=sum[i-1]+a[i];\n\t\telse W+=a[i],sum[i]=sum[i-1]-a[i];\n\t}\n\tif(n&1)\n\t{\n\t\tn++;sum[n]=sum[n-1];\n\t\tsort(q+1,q+1+tot);\n\t\tint l=0,r=B+W;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=l+r>>1;\n\t\t\tif(check(mid)) l=mid+1;\n\t\t\telse r=mid;\n\t\t}\n\t\tprintf(\"%d %d\",W+l-1,B-l+1);\n\t}\n\telse printf(\"%d %d\",max(W,B),min(W,B));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\nint main(){\n\tstatic int N;\n\tstatic int a[300010];\n\tscanf(\"%d\",&N);\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t\n\tstatic int sumA[300010],sumB[300010];\n\tsumA[0] = 0;\n\tsumB[0] = 0;\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tsumA[i] = sumA[i-1];\n\t\tsumB[i] = sumB[i-1];\n\t\tif(i%2 == 1)sumA[i] += a[i];\n\t\telse sumB[i] += a[i];\n\t}\n\t\n\tint ret = max(sumA[N],sumB[N]);\n\tif(N%2 == 1){\n\t\tfor(int i = 2 ; i <= N ; i += 2){\n\t\t\tret = max( ret , min( sumA[i-1]+sumB[N]-sumB[i-1] , sumB[i]+sumA[N]-sumA[i] ) );\n\t\t}\n\t}\n\t\n\tcout << ret << \" \" << sumA[N]+sumB[N]-ret << endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint a[333333];\nint S[333333];\nint sum;\n\nvoid out(int diff)\n{\n\tcout<<(sum+diff)/2<<' '<<(sum-diff)/2<<'\\n'; exit(0);\n}\n\nint getS(int l, int r)\n{\n\tif(l==0) return S[r];\n\telse return S[r]-S[l-1];\n}\n\nint dp[333333];\n\nint cost(int i, int j)\n{\n\treturn max((j>=2?dp[j-2]:-int(1e9)), getS(j, i));\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i]; sum+=a[i];\n\t\tif(i%2==0) a[i]*=-1;\n\t\tS[i]=a[i]+(i>0?S[i-1]:0);\n\t}\n\tif(n%2==0) out(abs(S[n-1]));\n\tdp[0] = min(0, getS(0,0));\n\tfor(int i=2;i<n;i+=2)\n\t{\n\t\tdp[i]=int(1e9);\n\t\tfor(int j=0;j<=i;j+=2) dp[i]=min(dp[i],cost(i,j));\n\t}\n\tout(S[n-1]-2*dp[n-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 300010;\n\nint N, B, W;\nint A[MN], psum[MN];\n\nbool check(int x) {\n    int mx = psum[N - 1];\n    for(int i = N - 1; i >= 0; i--) {\n        if(i % 2 && mx - psum[i] >= x) {\n            mx = max(mx, psum[i] + A[i]);\n        }\n    }\n    return mx >= x;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n        if(i % 2) W += A[i];\n        else B += A[i];\n    }\n\n    if(N % 2 == 0) {\n        printf(\"%d %d\", max(B, W), min(B, W));\n        return 0;\n    }\n\n    for(int i = 0; i < N; i++) {\n        if(i % 2) psum[i] = -A[i];\n        else psum[i] = A[i];\n        if(i) psum[i] += psum[i - 1];\n    }\n\n    int s = 0, e = 1e9, p = -1;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(check(m)) {\n            p = m;\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n    printf(\"%d %d\", W + p, B - p);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\nint main(){\n\tstatic int N;\n\tstatic int a[300010];\n\tscanf(\"%d\",&N);\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t\n\tstatic int sumA[300010],sumB[300010];\n\tsumA[0] = 0;\n\tsumB[0] = 0;\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tsumA[i] = sumA[i-1];\n\t\tsumB[i] = sumB[i-1];\n\t\tif(i%2 == 1)sumA[i] += a[i];\n\t\telse sumB[i] += a[i];\n\t}\n\t\n\tint ret = max(sumA[N],sumB[N]);\n\tif(N%2 == 1){\n\t\tret = sumA[N];\n\t\tfor(int i = 2 ; i <= N ; i += 2){\n\t\t\tret = max( ret , min( sumA[i-1]+sumB[N]-sumB[i-1] , sumB[i]+sumA[N]-sumA[i] ) );\n\t\t}\n\t}\n\t\n\tcout << ret << \" \" << sumA[N]+sumB[N]-ret << endl;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nconst int nax=1000*1007;\n\nint n;\nll tab[nax];\n\nll s;\n\nll pre[nax];\nll suf[nax];\n\nvoid wypisz(ll v)\n{\n\tdebug() << imie(v);\n\tprintf(\"%lld %lld\\n\", (s+v)/2, (s-v)/2);\n\texit(0);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%lld\", &tab[i]);\n\t\ts+=tab[i];\n\t}\n\tll x=0;\n\tfor (int i=1; i<=n; i+=2)\n\t\tx+=tab[i];\n\tif (!(n&1))\n\t\twypisz(max(x, s-x)-min(x, s-x));\n\tll wyn=max(x, s-x)-min(x, s-x);\n\tfor (int i=1; i<=n; i++)\n\t\tpre[i]=tab[i]-pre[i-1];\n\tfor (int i=n; i; i--)\n\t\tsuf[i]=tab[i]-suf[i+1];\n\tfor (int i=2; i<=n; i+=2)\n\t\twyn=max(wyn, min(pre[i]+suf[i+1], pre[i-1]+suf[i]));\n\twypisz(wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nnamespace zyt\n{\n\ttemplate<typename T>\n\tinline bool read(T &x)\n\t{\n\t\tchar c;\n\t\tbool f = false;\n\t\tx = 0;\n\t\tdo\n\t\t\tc = getchar();\n\t\twhile (c != EOF && c != '-' && !isdigit(c));\n\t\tif (c == EOF)\n\t\t\treturn false;\n\t\tif (c == '-')\n\t\t\tf = true, c = getchar();\n\t\tdo\n\t\t\tx = x * 10 + c - '0', c = getchar();\n\t\twhile (isdigit(c));\n\t\tif (f)\n\t\t\tx = -x;\n\t\treturn true;\n\t}\n\ttemplate<typename T>\n\tinline void write(T x)\n\t{\n\t\tstatic char buf[20];\n\t\tchar *pos = buf;\n\t\tif (x < 0)\n\t\t\tputchar('-'), x = -x;\n\t\tdo\n\t\t\t*pos++ = x % 10 + '0';\n\t\twhile (x /= 10);\n\t\twhile (pos > buf)\n\t\t\tputchar(*--pos);\n\t}\n\tconst int N = 3e5 + 10;\n\tint arr[N], W, B, n;\n\tbool check(const int x)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 2; i <= n; i += 2)\n\t\t{\n\t\t\tsum += arr[i - 1];\n\t\t\tif (sum >= x - W)\n\t\t\t\tsum = 0;\n\t\t\telse\n\t\t\t\tsum -= arr[i];\n\t\t}\n\t\tsum += arr[n];\n\t\treturn sum >= x - W;\n\t}\n\tint work()\n\t{\n\t\tread(n);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tread(arr[i]);\n\t\tfor (int i = 1; i <= n; i += 2)\t\n\t\t\tB += arr[i];\n\t\tfor (int i = 2; i <= n; i += 2)\n\t\t\tW += arr[i];\n\t\tif (!(n & 1))\n\t\t\tprintf(\"%d %d\", max(B, W), min(B, W));\n\t\telse\n\t\t{\n\t\t\tint l = B + 1, r = (B + W), ans = B;\n\t\t\twhile (l <= r)\n\t\t\t{\n\t\t\t\tint mid = (l + r) >> 1;\n\t\t\t\tif (check(mid))\n\t\t\t\t\tl = mid + 1, ans = mid;\n\t\t\t\telse\n\t\t\t\t\tr = mid - 1;\n\t\t\t}\n\t\t\tprintf(\"%d %d\", ans, B + W - ans);\n\t\t}\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\treturn zyt::work();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, w[301010], S[301000];\nint sum = 0;\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tsum += w[i];\n\t}\n\tint ss = 0;\n\tS[1] = w[1];\n\tfor (i = 2; i <= n; i++)S[i] = S[i - 2] + w[i];\n\tss = max(S[n], sum - S[n]);\n\tif (n % 2 == 0) {\n\t\tprintf(\"%d %d\\n\", ss, sum - ss);\n\t\treturn 0;\n\t}\n\tfor (i = 2; i < n; i += 2) {\n\t\tint r1 = S[n - 1] - S[i - 2];\n\t\tint r2 = S[n] - S[i - 1];\n\t\tint l1 = S[i - 2];\n\t\tint l2 = S[i - 1];\n\t\tss = max(ss, min(l1 + r2, r1 + l2) + w[i]);\n\t}\n\tprintf(\"%d %d\\n\", ss, sum - ss);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 3e5;\nint n;\nll sum, a[maxn + 10], a1, a2;\nll s[maxn + 10], mn;\nbool f[maxn + 10];\n\nbool chk(ll x) {\n\tf[0] = 1; mn = 0;\n\tfor (int i = 2; i <= n; i += 2) {\n\t\tif (s[i - 1] - mn >= x) {\n\t\t\tf[i] = 1; mn = min(mn, s[i]);\n\t\t} else f[i] = 0;\n\t}\n\tfor (int i = 0; i <= n; i += 2)\n\t\tif (f[i] && s[n] - s[i] >= x) return 1;\n\treturn 0;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lld\", &a[i]); sum += a[i];\n\t}\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (i & 1) a1 += a[i];\n\t\telse a2 += a[i];\n\tif (~n & 1) {\n\t\ta1 = max(a1, a2);\n\t\tprintf(\"%lld %lld\", a1, sum - a1);\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (~i & 1) a[i] = -a[i];\n\t\ts[i] = s[i - 1] + a[i];\n\t}\n\tll l = 0, r = 1e9;\n\twhile (l != r) {\n\t\tll mid = (l + r + 1) >> 1;\n\t\tif (chk(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\ta1 = max(a1, a2 + l);\n\tprintf(\"%lld %lld\", a1, sum - a1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,ans,sum,a[300010],l,r,mid,an,nw;\n\nbool check(int mid)\n{\n\tint nw=0;\n\tfor (int i=1; i<=n; i++) \n\t\tif (i&1) nw+=2*a[i]; else\n\t\t{\n\t\t\tif (nw>=mid) \n\t\t\t{\n\t\t\t\tif (nw-2*a[i]<0) nw=0;\n\t\t\t\telse nw-=2*a[i];\n\t\t\t} else nw-=2*a[i];\n\t\t}\n\treturn nw>=mid;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]),sum+=a[i];\n\tfor (int i=1; i<=n; i+=2) ans+=a[i];\n\tans=max(ans,sum-ans);\n\tif (!(n&1)) return printf(\"%d %d\\n\",ans,sum-ans),0;\n\tfor (int i=1; i<=n; i++) nw+=(a[i]*((i&1)?-1:1));\n\tl=ans-(sum-ans)+1,r=sum,ans=ans-(sum-ans);\n\twhile (l<=r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\tif (check(mid-nw)) l=mid+1,ans=mid; else r=mid-1;\n\t}\n\tprintf(\"%d %d\\n\",(sum+ans)/2,(sum-ans)/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=300005;\nint a[N],n,b,w;\n\nint chk(int owo){\n\tint val=a[1];\n\tfor(int i=3;i<=n;i+=2)\n\t\tif(val>=owo)val=max(val+a[i]-a[i-1],a[i]);\n\t\telse val+=a[i]-a[i-1];\n\treturn val>=owo;\n}\n\nint main(){\n\tread(n);\n\trep(i,1,n){\n\t\tread(a[i]);\n\t\tif(i&1)b+=a[i];\n\t\telse w+=a[i];\n\t}\n\tif(n%2==0){\n\t\tprintf(\"%d %d\\n\",max(b,w),min(b,w));\n\t\treturn 0;\n\t}\n\tint l=0,r=b,mid;\n\twhile(l<r){\n\t\tmid=(l+r+1)>>1;\n\t\tif(chk(mid))l=mid;\n\t\telse r=mid-1;\n\t}\n\tprintf(\"%d %d\\n\",w+l,b-l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 300000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,a[MN+5],tot[2],ans,s[MN+5],L[MN+5],R[MN+5];\nbool Solve(int lim)\n{\n    int mn=1e9;\n    for(int j=1;j<=n;j+=2)\n    {\n        if(tot[0]+s[j]-mn>=lim) L[j-1]=true; else L[j-1]=false;\n        if(tot[0]+s[j]>=lim) mn=min(mn,s[j+1]);\n    }\n    mn=1e9;\n    for(int j=n;j>=1;j-=2)\n    {\n        if(tot[0]+mn-s[j-1]>=lim&&L[j-1]) return true;\n        if(tot[0]+s[n]-s[j-1]>=lim) mn=max(mn,s[j-2]);\n    }\n    return false;\n}\nint main()\n{   \n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read(),tot[i&1]+=a[i];\n    if(~n&1) return 0*printf(\"%d %d\\n\",max(tot[0],tot[1]),min(tot[1],tot[0]));\n    ans=max(tot[0],tot[1]);\n    int l=ans+1,r=tot[0]+tot[1],mid;\n    for(int i=1;i<=n;++i) s[i]=s[i-1]+((i&1)?1:-1)*a[i];\n    while(l<=r)\n    {\n        mid=l+r>>1;\n        if(Solve(mid)) ans=mid,l=mid+1;\n        else r=mid-1;\n    }\n    printf(\"%d %d\\n\",ans,tot[0]+tot[1]-ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n,B,W;\nconst int N=300010;\nint a[N],sum[N];\nint check(int mid)\n{\n\tint mn=0;\n\tfor(int i=2;i<n;++i)\n\t\tif(mn<=sum[i-1]-mid)mn=min(mn,sum[i]);\n\treturn mn<=sum[n]-mid;\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);sum[i]=sum[i-1];\n\t\tif(i&1)B+=a[i],sum[i]+=a[i];\n\t\telse W+=a[i],sum[i]-=a[i];\n\t}\n\tif(!(n&1))return printf(\"%d %d\",max(B,W),min(B,W))==2333;\n\tint L=-3e8,R=3e8,pos=0,ans;\n\twhile(L<=R)\n\t{\n\t\tint mid=(L+R)/2;\n\t\tif(check(mid))pos=mid,L=mid+1;\n\t\telse R=mid-1;\n\t}\n\tans=max(W+pos,B);\n\tcout<<ans<<\" \"<<W+B-ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define fi first\n#define se second\n#define mp make_pair\n//#define ivorysi\n#define pii pair<int,int>\nusing namespace std;\ntypedef long long int64;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\n\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {putchar('-');x = -x;}\n    if(x >= 10) out(x / 10);\n    putchar('0' + x % 10);\n}\nint N;\nint64 a[300005],sum[300005][2];\nbool check(int64 mid) {\n    int64 t = 0; \n    for(int i = 2 ; i <= N ; i += 2) {\n\tif(sum[i - 1][1] - sum[i - 1][0] + t >= mid) {\n\t    t = max(sum[i][0] - sum[i][1],t);\n\t}\n    }\n    if(sum[N][1] - sum[N][0] + t >= mid) return true;\n    return false;\n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) read(a[i]);\n    int64 L = 0,R = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n\tR += a[i];L -= a[i];\n\tsum[i][0] = sum[i - 1][0];\n\tsum[i][1] = sum[i - 1][1];\n\tsum[i][i & 1] += a[i];\n    }\n    if(N % 2 == 0) {\n\tout(max(sum[N][0],sum[N][1]));space;out(min(sum[N][0],sum[N][1]));enter;\n\treturn;\n    }\n    while(L < R) {\n\tint64 mid = (L + R + 1) >> 1;\n\tif(check(mid)) L = mid;\n\telse R = mid - 1;\n    }\n    int64 a = L + sum[N][0];\n    int64 b = sum[N][0] + sum[N][1] - a;\n    out(a);space;out(b);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x <<\": \" << (x) << endl\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#ifdef LOCAL\n#define see(x) cout  << #x << \": \" << (x) << endl\n#endif\n#ifndef LOCAL\n#define see(x)\n#endif\n\n\n#define rep(n) for(int _ = 0; _ != (n); ++_)\n//#define rep(i, a, b) for(int i = (a); i <= (b); ++i)\n#define Rng(i, n) for(int i = 0; i != (n); ++i)\n#define rng(i, a, b) for(int i = (a); i < (b); ++i)\n#define rno(i, b) for(int i = 0; i<(b); ++i)\n#define rnc(i, a, b) for(int i = (a); i<=(b); ++i)\n#define RNG(i, a) for(auto &i: (a))\n#define dwn(i, r, l) for(int i = (r); i>=(l); i--)\n\nnamespace std {\n    template<class T>\n    T begin(std::pair<T, T> p)\n    {\n        return p.first;\n    }\n    template<class T>\n    T end(std::pair<T, T> p)\n    {\n        return p.second;\n    }\n}\n\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate<class Range>\nstd::pair<std::reverse_iterator<decltype(begin(std::declval<Range>()))>, std::reverse_iterator<decltype(begin(std::declval<Range>()))>> make_reverse_range(Range &&r)\n{\n    return std::make_pair(make_reverse_iterator(::begin(r)), make_reverse_iterator(::end(r)));\n}\n\n#define RRNG(x, cont) for (auto &x: make_reverse_range(cont))\n\n\n\ntemplate<class T> int sign(const T &a) { return a == 0 ? 0 : a > 0 ? 1 : -1; }\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> void Min(T &a, const T &b){ a = min(a, b); }\ntemplate<class T> void Max(T &a, const T &b){ a = max(a, b); }\n\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\nusing pii = pair<int, int>;\nusing pdd = pair<double, double>;\nusing pip = pair<int, pii>;\nusing szt = size_t;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing pli = pair<ll,int>;\nusing wg = vector<vpii>; //weighted graph\n\nint cas;\nconst double pi = acos(-1);\nll mod = 1e9 + 7;\n\ntemplate<class T>\ninline void add_mod(T &a, const T &b) {\n    a += b;\n    if (a >= mod) a -= mod;\n}\ntemplate<class T>\nvoid sub_mod(T &a, const T &b){\n    a -= b;\n    if (a < 0) a += mod;\n}\nauto bo=[](int x){\n    bitset<5> a(x);\n    cout << a << endl;\n};\n\n//返回值：a中比k小的元素有多少个？\ntemplate<class V, class Cont>\nint get_rank(const V &k, const Cont &a){\n    return std::lower_bound(all(a), k) - a.begin();\n}\n\nmat operator*(const mat &a, const mat &b) {\n    mat c(a.size(), vec(b[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            if (a[i][j]) { // optimization for sparse matrix\n                for (int k = 0; k < b[0].size(); k++) {\n                    add_mod(c[i][k], a[i][j] * b[j][k] % mod);\n                }\n            }\n        }\n    }\n    return c;\n}\n\nvec operator*(const mat &a, const vec &b) {\n    vec c(a.size());\n    for (int i = 0; i < a.size(); i++) {\n        for (int j = 0; j < a[0].size(); j++) {\n            add_mod(c[i], a[i][j] * b[j] % mod);\n        }\n    }\n    return c;\n}\n\nmat pow(mat a, ull n) {\n    mat res(a.size(), vec(a[0].size()));\n    for (int i = 0; i < a.size(); i++) {\n        res[i][i] = 1;\n    }\n    while (n) {\n        if (n & 1) {\n            res = res * a;\n        }\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\n// Codeforces does not support __int128\n//std::ostream& operator<<(std::ostream& os, __int128 T) {\n//    if (T<0) os<<\"-\";\n//    if (T>=10 ) os<<T/10;\n//    if (T<=-10) os<<(-(T/10));\n//    return os<<( (int) (T%10) >0 ? (int) (T%10) : -(int) (T%10) ) ;\n//}\n//\n//__int128 LPOW(__int128 x, ll n) {\n//    __int128 res = 1;\n//    for (; n; n /= 2, x *= x, x %= mod) {\n//        if (n & 1) {\n//            res *= x;\n//            res %= mod;\n//        }\n//    }\n//    return res;\n//}\n\nll POW(ll x, ll n){\n    ll res = 1;\n    for (; n; n /= 2, x *= x, x %= mod) {\n        if (n & 1) {\n            res *= x;\n            res %= mod;\n        }\n    }\n    return res;\n}\n\n\nll INV(ll x) {\n    return POW(x, mod - 2);\n}\n\nll inv(ll x){\n//    see(x);\n    return x == 1? 1: (mod - mod/x * inv(mod%x) % mod);\n}\n\n\n\n// 2D rotation\nvoid rotate(double &x, double &y, double theta) {\n    double tx = cos(theta) * x - sin(theta) * y;\n    double ty = sin(theta) * x + cos(theta) * y;\n    x = tx, y = ty;\n}\nstruct bit {\n    static const int BIT_N = 1e5 + 5;\n    ll bit[BIT_N];\n    void init(int n){\n        rng(i, 1, n+1) bit[i] = 0;\n    }\n\n    ll sum(int x) {\n        ll res = 0;\n        while (x) {\n            res += bit[x];\n            x -= x & -x;\n        }\n        return res;\n    }\n\n    ll sum(int l, int r) {\n        if (l > r) return 0;\n        return sum(r) - sum(l - 1);\n    }\n\n    void add(int x, ll v, int n) {\n        while (x <= n) {\n            bit[x] += v;\n            x += x & -x;\n        }\n    }\n};\n\n\nnamespace util{\n    int len(ll x){return snprintf(nullptr, 0, \"%lld\", x);}\n    vi get_d(ll x){\n        vi res;\n        while(x) {\n            res.pb(x%10);\n            x /= 10;\n        }\n        reverse(all(res));\n        return res;\n    }\n    template <class T> T parity(const T &a){\n        return a & 1;\n    }\n    template <class T>\n    void out (const vector<T> &a){\n        std::copy(a.begin(), a.end(), std::ostream_iterator<T>(std::cout, \", \"));\n        cout << endl;\n    };\n}\n\nusing namespace util;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n\nusing order_statistic_tree = __gnu_pbds::tree<\n        int,\n        __gnu_pbds::null_type,\n        greater<int>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n\n\nconst ll LINF = LLONG_MAX/10;\nconst int INF = INT_MAX/10;\nconst int M = 5005;\n\n\nll dp[M];\n\nint c[M], f[M];\n\nint nn[M], v[M], p[M];\n\nint main() {\n    // Single Cut of Failure taught me\n    cout << std::fixed;\n    cout << setprecision(10);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n\n#ifdef LOCAL\n    freopen(\"main.in\", \"r\", stdin);\n//    freopen(\"main.out\", \"w\", stdout);\n#endif\n\n    int n; scan(n);\n    vi a(n);\n    RNG(x, a) scan(x);\n    int sb = 0;\n    for(int i = 0; i<n; i+=2)\n        sb += a[i];\n    int sw = 0;\n    for(int i=1; i<n; i+=2)\n        sw += a[i];\n\n\n    auto check = [n, sb, sw, &a](int x) {\n        int mi = INT_MAX;\n        int sum = 0;\n        rng(i, 0, n) {\n            if (i & 1) {\n                if (sum >= x || sum - x  >= mi) {\n                    if (sb - sw - (sum - a[i]) >= x)\n                        return true;\n                    sum -= a[i];\n                    Min(mi, sum);\n                }\n                else sum -= a[i];\n            }\n            else sum += a[i];\n        }\n        return false;\n    };\n\n    int l = sb - sw + 1, r = sb;\n    while(l<=r){\n        int mid = l + (r-l)/2;\n        if(check(mid)){\n            l = mid + 1;\n        }\n        else r = mid - 1;\n    }\n\n    println(sw + r, sb - r);\n\n\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint n;\nint B,W;\nint a[300050];\nint s[300050];\nbool judge(int x)\n{\n\tint mn=0;\n\tif(s[n]>=x) return 1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tif(s[i-1]-mn>=x)\n\t\t{\n\t\t\tif(s[n]-s[i]>=x) return 1;\n\t\t\tmn=min(mn,s[i]);\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(i&1)\n\t\t{\n\t\t\tB+=a[i];\n\t\t\ts[i]=s[i-1]+a[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tW+=a[i];\n\t\t\ts[i]=s[i-1]-a[i];\n\t\t}\n\t}\n\tif(~n&1)\n\t{\n\t\tprintf(\"%d %d\\n\",max(B,W),min(B,W));\n\t\treturn 0;\n\t}\n\tint l=0,r=B,re=-1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(judge(mid)) l=mid+1,re=mid;\n\t\telse r=mid-1;\n\t}\n\tint an=max(B,W+re);\n\tprintf(\"%d %d\\n\",an,B+W-an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 300000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,a[MN+5],tot[2],ans,s[MN+5],L[MN+5],R[MN+5];\nbool Solve(int lim)\n{\n    int mn=1e9;memset(L,0,sizeof(L));\n    for(int j=2;j<=n;j+=2)\n    {\n        if(tot[0]+s[j-1]>=lim) L[j]=true;\n        if(tot[0]+s[j-1]-mn>=lim) L[j]=true;\n        if(L[j])  mn=min(mn,s[j]);\n    }\n    mn=-1e9;\n    for(int j=n-1;j;j-=2)\n    {\n        int fg=0;\n        if(tot[0]+s[n]-s[j]>=lim) fg=1;\n        if(tot[0]+mn-s[j]>=lim) fg=1;\n        if(fg&&L[j]) return true;\n        if(fg) mn=max(mn,s[j-1]);\n    }\n    return false;\n}\nint main()\n{   \n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read(),tot[i&1]+=a[i];\n    if(~n&1) return 0*printf(\"%d %d\\n\",max(tot[0],tot[1]),min(tot[1],tot[0]));\n    ans=max(tot[0],tot[1]);\n    int l=ans+1,r=tot[0]+tot[1],mid;\n    for(int i=1;i<=n;++i) s[i]=s[i-1]+((i&1)?1:-1)*a[i];\n    while(l<=r)\n    {\n        mid=l+r>>1;\n        if(Solve(mid)) ans=mid,l=mid+1;\n        else r=mid-1;\n    }\n    printf(\"%d %d\\n\",ans,tot[0]+tot[1]-ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 500010\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint a[N],b[N],n;\ninline int check(int k)\n{\tmemcpy(b,a,sizeof(a));\n\tfor(rint i=1;i<=n;i+=2)\n\tif(i==n) return (b[i]>=k);\n\telse if(!(b[i]>=k&&b[i+1]>=b[i])) b[i+2]+=b[i]-b[i+1];\n}\nint main()\n{\tint s0=0,s1=0; cin>>n;\n\tfor(rint i=1;i<=n;i++) scanf(\"%d\",&a[i]),(i&1)?s0+=a[i]:s1+=a[i];\n\tif(n%2==0){cout<<max(s0,s1)<<\" \"<<min(s0,s1)<<endl;return 0;}\n\tint l=0,r=3e8,ans=-1;\n\twhile(l<=r)\n\t{\tint mid=(l+r)>>1;\n\t\tif(check(mid)) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tcout<<ans+s1<<\" \"<<s0-ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=3e5+5;\n\nint n;\nint a[N];\n\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)scanf(\"%d\",&a[i]);\n    if(n%2==0){\n        int c[2]={0,0};\n        FOR(i,1,n)c[i&1]+=a[i];\n        if(c[0]<c[1])swap(c[0],c[1]);\n        printf(\"%d %d\\n\",c[0],c[1]);\n        return 0;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint N;\nint A[300005];\nint B, W;\nint Partial[300005];\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i <= N; i++)\n    {\n        cin >> A[i];\n        Partial[i] = Partial[i - 1];\n        if(i % 2 == 1)\n        {\n            B += A[i];\n            Partial[i] += A[i];\n        }\n\n        else\n        {\n            W += A[i];\n            Partial[i] -= A[i];\n        }\n    }\n\n}\nbool check(int X)\n{\n    int Min = 0, PMin = 0;\n    Partial[N + 1] = Partial[N];\n    for(int i = 2; i <= N + 1; i += 2)\n    {\n        if(Partial[i - 1] - Partial[PMin] >= X)\n        {\n            if(Min > Partial[i])\n            {\n                Min = Partial[i];\n                PMin = i;\n            }\n            if(i == N + 1)\n                return 1;\n        }\n    }\n    return 0;\n}\nint binS()\n{\n    int left = 0, right = B, sol = 0, mid;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check(mid) == 1)\n        {\n            sol = mid;\n            left = mid + 1;\n        }\n        else\n            right = mid - 1;\n    }\n    int X = max(B, W + sol);\n    return X;\n}\n\nvoid Solve()\n{\n    if(N % 2 == 0)\n    {\n        cout << max(W, B) << \" \" << min(W, B) << \"\\n\";\n        return;\n    }\n    int X = binS();\n    cout << X << \" \" << W + B - X << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nMain AC Solution\n*/\n\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nconst int MN = TEN(6);\nconst int MM = (MN - 1) / 2;\nconst ll MA = TEN(9);\n\nV<ll> input() {\n    int n;\n    assert(scanf(\"%d\", &n));\n    assert(1 <= n && n <= MN);\n    V<ll> v(n);\n    for (int i = 0; i < n; i++) assert(scanf(\"%lld\", &(v[i])));\n    return v;\n}\n\nmt19937 gen;\nvoid reseed(ll seed) {\n    gen = mt19937(seed);\n    for (int i = 0; i < 10000; i++) {\n        gen(); // skip\n    }\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    using D = uniform_int_distribution<ll>;\n    assert(l <= r);\n    return D(l, r)(gen);\n}\n\nint main() {\n    V<ll> v = input();\n    int n = int(v.size());\n\n    ll sm = 0;\n    for (auto d: v) sm += d;\n\n    if (n % 2 == 0) {\n        //odd\n        ll buf[2] = {0, 0};\n        for (int i = 0; i < n; i++) buf[i%2] += v[i];\n        if (buf[0] < buf[1]) swap(buf[0], buf[1]);\n        cout << buf[0] << \" \" << buf[1] << endl;\n        return 0;\n    }\n\n    int m = n/2;\n    V<ll> l(m), r(m);\n    l[0] = v[1] - v[0];\n    for (int i = 1; i < m; i++) l[i] = l[i-1] + v[2*i+1] - v[2*i];\n    r[m-1] = v[n-2] - v[n-1];\n    for (int i = m-2; i >= 0; i--) r[i] = r[i+1] + v[2*i+1] - v[2*i+2];\n\n    auto check = [&](ll md) {\n        ll l_off = 0;\n        for (int i = 0; i < m; i++) {\n            if (r[i] < md || l[i] + l_off < 0) continue;\n            else {\n                md -= l[i] + l_off;\n                l_off -= l[i] + l_off;\n                if (md <= 0) return true;\n            }\n        }\n        return false;\n    };\n    ll lw = 0, up = TEN(18);\n    while (up - lw > 1) {\n        ll md = (lw + up) / 2;\n        if (check(md)) {\n            lw = md;\n        } else {\n            up = md;\n        }\n    }\n    ll ans = lw;\n    for (int i = 0; i < n; i+=2) ans += v[i];\n    cout << ans << \" \" << sm - ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\nusing namespace std;\n#define N 300010\nll a[N],n;\nbool solve(ll x){\n  vector<ll> v;\n  for(int i=0;i<n;i++)v.push_back(a[i]);\n  while(v.size()>1){\n    ll w=v[v.size()-1];\n    ll b=v[v.size()-2];\n    if(b<w||w<x)v[v.size()-3]+=w-b;\n    v.pop_back();v.pop_back();\n  }\n  return x<=v[0];\n}\nint main(){\n    cin>>n;\n    ll vl=0,vr=0;\n    for(int i=0;i<n;i++){\n      cin>>a[i];\n      if(i&1)vl+=a[i];\n      else vr+=a[i];\n    }\n    if(n&1){\n      ll l=0,r=1e15,m;\n      while(l<r-1){\n\tm=(l+r)/2;\n\tif(solve(m))l=m;\n\telse r=m;\n      }\n      cout<<vl+l<<\" \"<<vr-l<<endl;\n    }\n    else cout<<max(vl,vr)<<\" \"<<min(vl,vr)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 300003\n#define LL long long\n#define mod 998244353\n\nint n,ans,tot;\nint a[N],sum[N];\n\ninline int read(){\n\tint X=0,w=0;\n\tchar ch=0;\n\twhile (ch<'0' || ch>'9')\n\t  w|=ch=='-',ch=getchar();\n\twhile (ch>='0' && ch<='9')\n\t  X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w ? -X : X;\n}\n\ninline bool check(int x){\n\tint res=0;\n\tfor (int i=1;i<n;i+=2)\n\t  if (sum[i]-res>=x) res=min(res,sum[i+1]);\n\treturn sum[n]-res>=x;\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++)\n\t  a[i]=read();\n\tif (n%2==0){\n\t\tint sum1=0,sum2=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\t  if (i%2==1) sum1+=a[i];\n\t\t    else sum2+=a[i];\n\t\tprintf(\"%d %d\\n\",max(sum1,sum2),min(sum1,sum2));\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t  \tif (!(i & 1)) ans+=a[i];\n\t\tif (i & 1) sum[i]=sum[i-1]+a[i];\n\t\t  else sum[i]=sum[i-1]-a[i];\n\t\ttot+=a[i];\n\t}\n\tint l=1,r=1000*n,res=1;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif (check(mid)){\n\t\t\tl=mid+1;\n\t\t\tres=mid;\n\t\t}\n\t\telse r=mid-1;\n\t}\n\tprintf(\"%d %d\\n\",ans+res,(tot-ans-res));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 200200;\nconst int mod = 998244353;\ntypedef long long ll;\ninline ll pow(ll a,int b,ll ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1) ans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\ninline void reduce(int & x){ x += x >> 31 & mod; }\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nint sum;\nint n, a[maxn];\nint a0[maxn], a1[maxn];\nint s0[maxn];\ninline void output(int x) { std::cout << x << ' ' << sum - x << '\\n', exit(0); }\ninline bool ok(int x) {\n\tint k = 0;\n\tfor(int i = 2;i <= n;i += 2) if(s0[i - 1] - k >= x) k = std::min(k, s0[i]);\n\treturn s0[n] - k >= x;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor(int i = 1;i <= n;++i){\n\t\tstd::cin >> a[i], sum += a[i];\n\t\ta0[i] = a0[i - 1];\n\t\ta1[i] = a1[i - 1];\n\t\ti[i & 1 ? a0 : a1] += a[i];\n\t}\n\tif(n % 2 == 0) output(std::max(a0[n], a1[n]));\n\tfor(int i = 1;i <= n;++i) s0[i] = s0[i - 1] + (i & 1 ? a[i] : -a[i]);\n\tint l = a0[n],r = 1e9;\n\tfor(;l + 1 != r;) {\n\t\tint mid = l + r >> 1;\n\t\t(ok(mid) ? l : r) = mid;\n\t}\n\toutput(l);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\ntemplate <class T> T abs(T x){ return x < 0 ? -x : x; }\ntemplate <class T> bool chkmax(T &x, T y){ return x < y ? x = y, true : false; }\ntemplate <class T> T min(T a, T b){ return a < b ? a : b; }\ntypedef unsigned int u32;\nconst int N = 3e5 + 5;\nint n, a[N], b[N][2], dif;\nu32 sum, hi, lo;\nint main(){\n\tint i, a0, a1, b0, b1;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i ++) {\n\t\tscanf(\"%d\", a + i), b[i][i & 1] += a[i], sum += a[i];\n\t\tb[i][0] += b[i - 1][0], b[i][1] += b[i - 1][1];\n\t}\n\tdif = abs(b[n][0] - b[n][1]);\n\tif (n & 1) {\n\t\tfor (i = 2; i <= n; i += 2) {\n\t\t\ta0 = b[i - 1][0], a1 = b[i - 1][1];\n\t\t\tb0 = b[n][0] - b[i][0], b1 = b[n][1] - b[i][1];\n\t\t\tchkmax(dif, a[i] + min(b0 - b1 + abs(a1 - a0), a0 - a1 + abs(b1 - b0)));\n\t\t}\n\t}\n\tlo = (sum - dif) >> 1, hi = lo + dif;\n\tprintf(\"%u %u\\n\", hi, lo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=301010;\nint a[N],s[N],n,ss;\n/*int solve(int l,int r) {\n\tif (vis[l][r]) return dp[l][r];\n\telse {\n\t\tvis[l][r]=1;\n\t\tint ans=2*(s[r*2-1]-s[2*l]);\n\t\tfor (int i=l+1;i<r;i++) {\n\t\t\tans=max(ans,min(solve(i,r),solve(l,i)));\n\t\t}\n\t\tprintf(\"%d %d %d\\n\",l,r,ans);\n\t\treturn dp[l][r]=ans;\n\t}\n}\n*/\nbool check(int md) {\n\tstatic int vis[N];\n\tvis[0]=1;\n\tint z=0;\n\trep(i,1,n/2+2) {\n\t\tvis[i]=0;\n//\t\trep(j,0,i) if (vis[j]&&2*s[i*2-1]-2*s[2*j]>=md)\n//\t\t\tvis[i]=1;\n//\t\tprintf(\"%d %d %d\\n\",md,i,vis[i]);\n\t\tif (2*s[i*2-1]-z>=md) vis[i]=1; else vis[i]=0;\n\t\tif (vis[i]) z=min(z,2*s[2*i]);\n\t}\n\treturn vis[n/2+1];\n}\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",a+i),ss+=a[i];\n\tif (n%2==0) {\n\t\tint s1=0,s2=0;\n\t\trep(i,1,n+1) if (i%2==0) s1+=a[i]; else s2+=a[i];\n\t\tprintf(\"%d %d\\n\",max(s1,s2),min(s1,s2));\n\t}\n\trep(i,1,n+1) {\n\t\tif (i%2==1) s[i]=s[i-1]+a[i]; else s[i]=s[i-1]-a[i];\n\t}\n\n//\tmemset(vis,0,sizeof(vis));\n//\tprintf(\"%d\\n\",solve(0,n/2+1)-s[n]);\n\n\tint l=-1e9,r=1e9;\n\twhile (l+1<r) {\n\t\tint md=l+(r-l)/2;\n\t\tif (check(md)) l=md; else r=md;\n\t}\n\tl-=s[n];\n\tprintf(\"%d %d\\n\",(ss+l)/2,(ss-l)/2);\n//\tprintf(\"%d\\n\",l-s[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N , arr[300003] , sum[2];\n\nint main(){\n\tios::sync_with_stdio(0); cin >> N;\n\tfor(int i = 1 ; i <= N ; ++i){cin >> arr[i]; sum[i & 1] += arr[i];}\n\tif(N & 1){\n\t\tfor(int i = 1 ; i <= N ; ++i) arr[i] = arr[i - 1] + (i & 1 ? arr[i] : -arr[i]);\n\t\tint L = -1.5e9 , R = 1.5e9;\n\t\twhile(L < R){\n\t\t\tint mid = (L + R + 1) >> 1 , pre = 0;\n\t\t\tfor(int j = 2 ; j < N && arr[N] - pre < mid ; j += 2)\n\t\t\t\tif(arr[j - 1] - pre >= mid) pre = min(pre , arr[j]);\n\t\t\tarr[N] - pre >= mid ? L = mid : R = mid - 1;\n\t\t}\n\t\tprintf(\"%d %d\\n\" , sum[0] + L , sum[1] - L);\n\t}\n\telse printf(\"%d %d\\n\" , max(sum[0] , sum[1]) , min(sum[0] , sum[1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=300005;\nint n;\nint a[N],s[N];\nbool check(int x){\n\tint v=0;\n\tfor (int i=1;i<n;i+=2)\n\t\tif (s[i]-v>=x)\n\t\t\tv=min(v,s[i+1]);\n\treturn s[n]-v>=x;\n}\nint main(){\n\tn=read();\n\tFor(i,1,n)\n\t\ta[i]=read();\n\tif (n%2==0){\n\t\tint s0=0,s1=0;\n\t\tFor(i,1,n)\n\t\t\tif (i&1)\n\t\t\t\ts0+=a[i];\n\t\t\telse\n\t\t\t\ts1+=a[i];\n\t\tcout<<max(s0,s1)<<\" \"<<min(s0,s1)<<endl;\n\t\treturn 0;\n\t}\n\tFor(i,1,n)\n\t\tif (i&1)\n\t\t\ts[i]=s[i-1]+a[i];\n\t\telse\n\t\t\ts[i]=s[i-1]-a[i];\n\tint L=1,R=n*1000,mid,ans=L;\n\twhile (L<=R){\n\t\tmid=(L+R)>>1;\n\t\tif (check(mid))\n\t\t\tL=mid+1,ans=mid;\n\t\telse\n\t\t\tR=mid-1;\n\t}\n\tFor(i,1,n)\n\t\tif (i%2==0)\n\t\t\tans+=a[i];\n\tint s=0;\n\tFor(i,1,n)\n\t\ts+=a[i];\n\tcout<<ans<<\" \"<<s-ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300005;\nint n, a[N], s[N][2];\nbool f[N];\n\nbool check(int mid) {\n\tf[0] = true;\n\tint mx = 0;\n\tfor (int i = 2; i < n; i += 2) {\n\t\tif (mx >= mid - s[i][1] + s[i - 1][0]) {\n\t\t\tf[i] = true;\n\t\t\tmx = max(mx, s[i][0] - s[i][1]);\n\t\t\tif ((s[n][1] - s[i][1]) - (s[n][0] - s[i][0]) >= mid)\n\t\t\t\treturn true;\n\t\t} else\n\t\t\tf[i] = false;\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\ts[i][i - 1 & 1] = s[i - 1][i - 1 & 1];\n\t\ts[i][i & 1] = s[i - 1][i & 1] + a[i];\n\t}\n\tif (n % 2 == 0) {\n\t\tif (s[n][0] < s[n][1])\n\t\t\tswap(s[n][0], s[n][1]);\n\t\tprintf(\"%d %d\\n\", s[n][0], s[n][1]);\n\t\treturn 0;\n\t}\n\tint l = 0, r = s[n][1];\n\twhile (l < r) {\n\t\tint mid = l + r + 1 >> 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tif (s[n][0] + l > s[n][1])\n\t\tprintf(\"%d %d\\n\", s[n][0] + l, s[n][1] - l);\n\telse\n\t\tprintf(\"%d %d\\n\", s[n][1], s[n][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=3e5+5;\n\nint n;\nint a[N];\nint ans,sum;\n\nbool check(int x){\n    //printf(\"check(%d)\\n\",x);\n    int pos=0;//a[0]=0\n    for(int i=2;i<=n+1;i+=2){\n        if(a[i-1]-a[pos]<=x)pos=i;\n    }\n    //printf(\"pos=%d\\n\",pos);\n    return pos>=n;\n}\nint main(){\n    scanf(\"%d\",&n);\n    FOR(i,1,n)scanf(\"%d\",&a[i]),sum+=a[i];\n    int c[2]={0,0};\n    FOR(i,1,n)c[i&1]+=a[i];\n    if(c[0]<c[1])swap(c[0],c[1]);\n    if(n%2==0){\n        printf(\"%d %d\\n\",c[0],c[1]);\n        return 0;\n    }\n    for(int i=1;i<=n;i+=2)a[i]=-a[i];\n    //FOR(i,1,n)printf(\"%d%c\",a[i],\" \\n\"[i==n]);\n    for(int i=2;i<=n;i+=2)ans+=a[i];\n    FOR(i,2,n+1)a[i]+=a[i-1];\n    int l=-1e9,r=1e9,mid;\n    while(l<r)mid=floor((l+r+0.0)/2),check(mid)?r=mid:l=mid+1;\n    //printf(\"ans=%d\\n\",ans);\n    ans-=l;\n    if(ans>c[0])printf(\"%d %d\\n\",ans,sum-ans);\n    else printf(\"%d %d\\n\",c[0],c[1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[303030];\nll B[303030];\nint S[303030][2];\n\nint ok(ll v) {\n\tint i;\n\tFOR(i,N) B[i]=A[i];\n\t\n\tint cur=N-1;\n\t\n\twhile(cur>0) {\n\t\tif(B[cur]>=v && B[cur-1]>=B[cur]) {\n\t\t\t//v -= B[cur-1]-B[cur];\n\t\t}\n\t\telse {\n\t\t\tB[cur-2]+=B[cur]-B[cur-1];\n\t\t}\n\t\tcur-=2;\n\t}\n\t\n\treturn B[0]>=v;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i];\n\t\tS[i+1][0]=S[i][0];\n\t\tS[i+1][1]=S[i][1];\n\t\tS[i+1][i%2]+=A[i];\n\t}\n\tif(N%2==0) {\n\t\tcout<<max(S[N][0],S[N][1])<<\" \"<<min(S[N][0],S[N][1])<<endl;\n\t\treturn;\n\t}\n\t\n\tll Z=-1LL<<40;\n\tfor(i=40;i>=0;i--) if(ok(Z+(1LL<<i))) Z+=1LL<<i;\n\t\n\tcout<<(S[N][1]+Z)<<\" \"<<(S[N][0]-Z)<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.11.2019 17:41:21       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> s(2);\n  for (int i = 0; i < n; i++) {\n    s[i % 2] += a[i];\n  }\n  if (n % 2 == 0) {\n    cout << max(s[0], s[1]) << \" \" << min(s[0], s[1]) << '\\n';\n    return 0;\n  }\n  int low = s[0], high = s[0] + s[1];\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    vector<bool> dp(n + 2, false);\n    dp[0] = true;\n    for (int i = 0; i < n; i += 2) {\n      if (dp[i]) {\n        int take = s[1];\n        for (int j = i; j < n; j++) {\n          if (j % 2 == 0) take += a[j];\n          else take -= a[j];\n          if (j % 2 == 0 && take >= mid) {\n            dp[j + 2] = true;\n          }\n        }\n      }\n    }\n    if (dp[n + 1]) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  cout << low << \" \" << s[0] + s[1] - low << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=301010;\nint a[N],s[N],n,ss;\n/*int solve(int l,int r) {\n\tif (vis[l][r]) return dp[l][r];\n\telse {\n\t\tvis[l][r]=1;\n\t\tint ans=2*(s[r*2-1]-s[2*l]);\n\t\tfor (int i=l+1;i<r;i++) {\n\t\t\tans=max(ans,min(solve(i,r),solve(l,i)));\n\t\t}\n\t\tprintf(\"%d %d %d\\n\",l,r,ans);\n\t\treturn dp[l][r]=ans;\n\t}\n}\n*/\nint vis[N];\nbool check(int md) {\n\tvis[0]=1;\n\tint z=0;\n\trep(i,1,n/2+2) {\n\t\tvis[i]=0;\n//\t\trep(j,0,i) if (vis[j]&&2*s[i*2-1]-2*s[2*j]>=md)\n//\t\t\tvis[i]=1;\n//\t\tprintf(\"%d %d %d\\n\",md,i,vis[i]);\n\t\tif (2*s[i*2-1]-z>=md) vis[i]=1; else vis[i]=0;\n\t\tif (vis[i]) z=min(z,2*s[2*i]);\n\t}\n\treturn vis[n/2+1];\n}\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",a+i),ss+=a[i];\n\tif (n%2==0) {\n\t\tint s1=0,s2=0;\n\t\trep(i,1,n+1) if (i%2==0) s1+=a[i]; else s2+=a[i];\n\t\tprintf(\"%d %d\\n\",max(s1,s2),min(s1,s2));\n\t}\n\trep(i,1,n+1) {\n\t\tif (i%2==1) s[i]=s[i-1]+a[i]; else s[i]=s[i-1]-a[i];\n\t}\n\n//\tmemset(vis,0,sizeof(vis));\n//\tprintf(\"%d\\n\",solve(0,n/2+1)-s[n]);\n\n\tint l=-1e9,r=1e9;\n\twhile (l+1<r) {\n\t\tint md=l+(r-l)/2;\n\t\tif (check(md)) l=md; else r=md;\n\t}\n\tl-=s[n];\n\tprintf(\"%d %d\\n\",(ss+l)/2,(ss-l)/2);\n//\tprintf(\"%d\\n\",l-s[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=3e5+10;\nint a[N],n,B,W;\nint sum[N];\nbool check(int x) {\n\tint mi=0;\n\tfor(int i=2;i<n;i+=2)\n\t\tif(mi+x<=sum[i-1]) mi=min(mi,sum[i]);\n\treturn mi+x<=sum[n];\n}\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(a[i]),sum[i]=sum[i-1];\n\t\tif(i&1) B+=a[i],sum[i]+=a[i];\n\t\telse W+=a[i],sum[i]-=a[i];\n\t}\n\tif(!(n&1)) {\n\t\tprintf(\"%d %d\",max(B,W),min(B,W));\n\t\treturn 0;\n\t}\n\tint lb=-3e8,rb=3e8;\n\twhile(lb<rb) {\n\t\tint mid=lb+rb+1>>1;\n\t\tif(check(mid)) lb=mid;\n\t\telse rb=mid-1;\n\t}\n\tint ans=max(W+lb,B);\n\tprintf(\"%d %d\",ans,W+B-ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=3e5+100;\nint a[N],qz[N];\nint mymax(int x,int y) {return x>y?x:y;}\nint mymin(int x,int y) {return x<y?x:y;}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tif(n%2==0){\n\t\tint sum1=0,sum2=0;\n\t\tfor(int i=1;i<=n;i+=2) sum1+=a[i];\n\t\tfor(int i=2;i<=n;i+=2) sum2+=a[i];\n\t\tprintf(\"%d %d\\n\",mymax(sum1,sum2),mymin(sum1,sum2));\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(i%2==1) qz[i]=qz[i-1]+a[i];\n\t\telse qz[i]=qz[i-1]-a[i];\n\t}\n\tint l=0,r=2e9,ans;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tint min=0;bool pd=false;\n\t\tfor(int i=1;i<=n;i+=2){\n\t\t\tif(qz[i]-min>=mid){\n\t\t\t\tif(i==n) pd=true;\n\t\t\t\tmin=mymin(min,qz[i]-a[i+1]);\n\t\t\t}\n\t\t}\n\t\tif(pd) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tint sum1=0,sum2=0;\n\tfor(int i=1;i<=n;i+=2) sum1+=a[i];\n\tfor(int i=2;i<=n;i+=2) sum2+=a[i];\n\tprintf(\"%d %d\\n\",sum2+ans,sum1-ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib> \nint n,a[300010];\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nvoid cmin(int&a,int b){b<a?a=b:1;}\nvoid cmax(int&a,int b){b>a?a=b:1;}\nint g[300010],sum[300010];\nint calc(){\n\tint s[2]={0};\n\tfor(int i=0;i<n;i++)s[i%2]+=a[i];\n\tif(n%2==0)return max(s[0],s[1]);\n\tsum[n]=0;\n\tfor(int i=n;i--;)sum[i]=sum[i+1]+(i&1?-a[i]:a[i]);\n\tint left=0,right=1<<29,mid;\n\twhile(right-left>1){\n\t\tmid=left+right>>1;\n\t\tint val=0;\n\t\tfor(int i=n-1;i;i-=2){\n\t\t\tif(sum[i]-val>=mid)cmin(val,sum[i-1]);\n\t\t}\n\t\tif(sum[0]-val>=mid)left=mid;\n\t\telse right=mid;\n\t}\n\treturn s[1]+left;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint sum=0;\n\tfor(int i=0;i<n;i++)scanf(\"%d\",a+i),sum+=a[i];\n\tint ans=calc();\n\tprintf(\"%d %d\\n\",ans,sum-ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 300005\nint read() {\n    int s=0,w=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n\t{\n\t    if(ch=='-') w=-1;\n\t    ch=getchar();\n\t}\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();\n    return s*w;\n}\nint n;\nint a[M],tol[M],s1[M],s2[M];\nint ans1,ans2;\nvoid work(int *a,int n) {\n    int sum1=0,sum2=0;\n    if(n&1) sum1=a[n],n--;\n    for(int i=1;i<=n;i+=2) s1[(i+1)/2]=s1[(i+1)/2-1]+a[i];\n    for(int i=2;i<=n;i+=2) s2[(i+1)/2]=s2[(i+1)/2-1]+a[i];\n    sum1+=s1[n/2];\n    sum2+=s2[n/2];\n    if(sum1>ans1) ans1=sum1,ans2=sum2;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++) a[i]=read();\n    work(a,n);\n    for(int i=1;i<=n;i++) tol[i]=a[n-i+1];\n    for(int i=1;i<=n;i++) a[i]=tol[i];\n    work(a,n);\n    cout<<ans1<<' '<<ans2<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300005;\n\nint n;\nint a[N];\nint sum[2][N];\nint p[N], q[N];\nbool f[N];\n\nbool check(int x) {\n\tint j = -1;\n\tfor (int i = 1; i <= n; i += 2) {\n\t\tif (i > 1 && f[i - 2] && q[i] > q[j + 2]) j = i - 2;\n\t\tf[i] = (sum[1][i] - sum[1][j + 1] + sum[0][j + 1] + sum[0][n] - sum[0][i]) >= x;\n\t}\n\treturn f[n];\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tint all = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i], all += a[i];\n\t\tsum[0][i] = sum[0][i - 1] + (i % 2 == 0) * a[i];\n\t\tsum[1][i] = sum[1][i - 1] + (i % 2 == 1) * a[i];\n\t}\n\tint lim = max(sum[0][n], sum[1][n]);\n\tif (n % 2 == 0) {\n\t\tcout << lim << ' ' << all - lim; return 0;\n\t}\n\tfor (int i = 1; i <= n; ++i) p[i] = i;\n\tsort(p + 1, p + 1 + n, [&] (int x, int y) {\n\t\treturn sum[0][x - 1] - sum[1][x - 1] < sum[0][y - 1] - sum[1][y - 1];\n\t});\n\tfor (int i = 1; i <= n; ++i) q[p[i]] = i;\n\tint l = lim, r = all;\n\twhile (l < r) {\n\t\tint mid = (l + r + 1) >> 1;\n\t\tif (check(mid)) l = mid; else r = mid - 1;\n\t}\n\tcout << l << ' ' << all - l;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint a[333333];\nint S[333333];\nint sum;\n\nvoid out(int diff)\n{\n\tcout<<(sum+diff)/2<<' '<<(sum-diff)/2<<'\\n'; exit(0);\n}\n\nint getS(int l, int r)\n{\n\tif(l==0) return S[r];\n\telse return S[r]-S[l-1];\n}\n\nint dp[333333];\n\nint cost(int i, int j)\n{\n\treturn max((j>=2?dp[j-2]:-int(1e9)), getS(j, i));\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i]; sum+=a[i];\n\t\tif(i%2==0) a[i]*=-1;\n\t\tS[i]=a[i]+(i>0?S[i-1]:0);\n\t}\n\tif(n%2==0) out(abs(S[n-1]));\n\tdp[0] = min(0, getS(0,0));\n\tint ptr = 0;\n\tfor(int i=2;i<n;i+=2)\n\t{\n\t\twhile(ptr+2<=i&&cost(i,ptr+2)<=cost(i,ptr)) ptr+=2;\n\t\tdp[i] = cost(i,ptr);\n\t}\n\tout(S[n-1]-2*dp[n-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nconst int maxN = 300011;\n\nint n, i, a[maxN];\nint B, W;\n\nbool check(ll least) {\n    int i, j, u;\n\n    u = 0;\n    for (i = 1; i <= n; i++) {\n        if (i & 1) {\n            u += a[i];\n        } else {\n            if (u - a[i] < 0 && u >= least) {\n                u = 0;\n                continue;\n            }\n            u -= a[i];\n        }\n    }\n\n    if (u < least) return false;\n    return true;\n}\n\nint main()\n{\n    //freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d\", &n);\n    for (i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n        if (i & 1)\n            B += a[i];\n        else\n            W += a[i];\n    }\n\n    if (n % 2 == 0) {\n        printf(\"%d %d\", max(B, W), min(B, W));\n        return 0;\n    }\n\n\n    ll ans = 0;\n    for (ll step = 1LL << 30; step > 0; step >>= 1)\n        if (check(ans + step))\n            ans += step;\n  \n    printf(\"%lld %lld\", ans + W, B - ans);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 300054;\n\nint n, S, So, Se;\nint a[N], s[N];\n\ninline void down(int &x, const int y) {x > y ? x = y : 0;}\n\ninline bool check(int x) {\n\tint i, min = 0;\n\tfor (i = 2; i < n; i += 2) if (s[i - 1] >= min + x) down(min, s[i]);\n\treturn s[n] >= min + x;\n}\n\nint main() {\n\tint i, ans, L, R, M;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", a + i), S += a[i], s[i] = s[i - 1] + (i & 1 ? (So += a[i], a[i]) : (Se += a[i], -a[i]));\n\tans = (n & 1 ? ({for (L = 0, R = So; L < R; check(M = (L + R + 1) / 2) ? L = M : R = M - 1); Se + L;}) : std::max(So, Se));\n\tprintf(\"%d %d\\n\", ans, S - ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define N 300010\nusing namespace std;\nint num[N],sum[N];\nint n;\nbool check(int x)\n{\n\tint ans=0;\n\tfor(int i=1;i<=n;i+=2)\n\tif(ans+x<=sum[i]) ans=min(ans,sum[i+1]);\n\treturn x+ans<=sum[n];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint a[2]={0,0};\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&num[i]),a[i&1]+=num[i];\n\tif(n&1)\n\t{\n\t\tfor(int i=1;i<=n;i++) sum[i]=sum[i-1]+(i&1?1:-1)*num[i];\n\t\tint l=0,r=a[0]+a[1],ans=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(check(mid)) l=mid+1,ans=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",a[0]+ans,a[1]-ans);\n\t}\n\telse printf(\"%d %d\\n\",max(a[0],a[1]),min(a[0],a[1]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define N 300012\nint n,co[2],a[N],s[N],ans=0;\ninline bool can(int mid){int i,v=0;for(i=2;i<=n;i+=2)if(s[i-1]>=(mid+v))v=min(v,s[i]);return (s[n]>=(mid+v));}\nint main(){\n\tscanf(\"%d\",&n);int i,l,r,mid;for(i=1;i<=n;i++){scanf(\"%d\",&a[i]);co[i&1]+=a[i];}\n\tif(!(n&1)){printf(\"%d %d\",max(co[0],co[1]),min(co[0],co[1]));return 0;}\n\tfor(i=1;i<=n;i++)s[i]=s[i-1]+(i&1)?a[i]:(-a[i]);l=1;r=1e9;\n\twhile(l<=r){mid=(l+r)>>1;if(can(mid)){ans=mid;l=mid+1;}else r=mid-1;}printf(\"%d %d\",co[0]+ans,co[1]-ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F(i, a, b) for (int i = a; i <= b; i ++)\n#define G(i, a, b) for (int i = a; i >= b; i --)\n#define out4(x, y, z, w) { if (debug) printf(#x\" = \"),W(x),printf(\" \"#y\" = \"),W(y),printf(\" \"#z\" = \"),W(z),printf(\" \"#w\" = \"),W(w),putc('\\n'); }\n#define out3(x, y, z) { if (debug) printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), printf(\" \"#z\" = \"), W(z), putc('\\n'); }\n#define out2(x, y) { if (debug) printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), putc('\\n'); }\n#define out1(x) { if (debug) printf(#x\" = \"), W(x), putc('\\n'); }\n#define outline(x) { if (debug) puts(\"-------------------------------------------\"#x\"----------------------------------------\"); }\n#define outarr(a, L, R) { if (debug) { printf(#a\"[%d..%d] = \", L, R); F(i, L, R) W(a[i]), putc(' '); putc('\\n'); } }\n#define Assert(x) { if ((debug) && (!(x))) { puts(\"Wrong Answer\"); exit(0); } }\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define mem(a, b) memset(a, b, sizeof a)\n#define mec(a, b) memcpy(a, b, sizeof a)\n#define mx(a, b) ((a) = max(a, b))\n#define mn(a, b) ((a) = min(a, b))\n#define lowbit(x) ((x) & (-(x)))\n#define abs(x) ((max(x, - (x))))\n#define get getchar()\n#define pb push_back\n#define putc putchar\n\ntemplate <typename Int>\nvoid R(Int &x) {\n\tchar c = get; x = 0; Int t = 1;\n\tfor (; !isdigit(c); c = get) t = (c == '-' ? - 1 : t);\n\tfor (; isdigit(c); x = (x << 3) + (x << 1) + c - '0', c = get); x *= t;\n}\ntemplate <typename Int>\nvoid W(Int x) {\n\tif (x < 0) { putc('-'); x = - x ; }\n\tif (x > 9) W(x / 10); putc(x % 10 + '0');\n}\n\n#define debug (0)\n\nusing namespace std;\n\nconst int N = 3e5 + 10;\nint n, a[N], f[N], S[N];\nint A, B, Ans;\n\nbool ok(int md) {\n\tf[0] = 1; int Min = 0;\n\tF(i, 1, n + 1) {\n\t\tf[i] = 0;\n\t\tif (i % 2 == 0 && S[i - 1] - Min >= md)\n\t\t\tf[i] = 1;\n\t\tif (f[i] && S[i] < Min)\n\t\t\tMin = S[i];\n\t}\n\tout1(md);\n\toutarr(f, 1, n);\n\treturn f[n + 1];\n}\n\nint main() {\n//\tfreopen(\"data.in\",\"r\",stdin);\n\n\tR(n);\n\tF(i, 1, n) R(a[i]), A += a[i] * (i & 1), B += a[i], S[i] = a[i] * (i & 1 ? 1 : (-1));\n\tF(i, 1, n) S[i] += S[i - 1];\n\tB -= A;\n\tif (n & 1) {\n\t\tAns = A;\n\t\tout2(A, B);\n\t\tint l = 0, r = B + A;\n\t\twhile (l <= r) {\n\t\t\tint md = (l + r >> 1);\n\t\t\tif (ok(md))\n\t\t\t\tmx(Ans, B + md), l = md + 1;\n\t\t\telse\n\t\t\t\tr = md - 1;\n\t\t}\n\t}\n\telse\n\t\tAns = max(A, B);\n\tW(Ans), putc(' '), W(A + B - Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 300010;\n\nint n;\nint a[MAX_N];\nint dp[MAX_N];\nint sum[2][MAX_N];\nint s[2];\n\nint quadratic_dp ()\n{\n\n\tdp[0] = +(1 << 30);\n\tfor (int i = 1; i * 2 <= (n + 1); i ++)\n\t{\n\t\tdp[i] = -(1 << 30); /// infinty\n\t\tfor (int j = 0; j < i; j ++)\n        \tdp[i] = max (dp[i], min (dp[j], sum[1][i * 2 - 1] - sum[1][j * 2] - (sum[0][i * 2 - 1] - sum[0][j * 2])));\n\t}\n\n\treturn dp[(n + 1) / 2];\n}\n\nbool check (int x)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; i += 2)\n    {\n        if (sum >= x)\n            sum = max (sum - a[i - 1] + a[i], a[i]);\n        else\n            sum = sum - a[i - 1] + a[i];\n    }\n    return sum >= x;\n}\n\nint nlogn ()\n{\n    int l, r, mid;\n\n    l = -1;\n    r = s[1] + 1;\n    while (r - l > 1)\n    {\n        mid = (l + r) >> 1;\n\n        if (check (mid))\n            l = mid;\n        else\n            r = mid;\n    }\n\n    return l;\n}\n\nint main ()\n{\n\tscanf (\"%d\", &n);\n\tfor (int i = 1; i <= n; i ++)\n\t\tscanf (\"%d\", &a[i]);\n\n\tfor (int i = 1; i <= n; i ++)\n\t\ts[i & 1] += a[i];\n\n\tif (!(n & 1))\n\t{\n\t\tprintf (\"%d %d\\n\", max (s[0], s[1]), min (s[0], s[1]));\n\t\treturn 0;\n\t}\n\n\tsum[0][0] = sum[1][0] = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tsum[0][i] = sum[0][i - 1];\n\t\tsum[1][i] = sum[1][i - 1];\n\t\tsum[i & 1][i] += a[i];\n\t}\n\n\tint ans;\n\n\t///ans = quadratic ();\n\tans = nlogn ();\n\n\tprintf (\"%d %d\\n\", s[0] + ans, s[1] - ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n\n-- This code was written after reading the editorial.\n\nimport qualified Data.ByteString.Lazy.Char8 as B\nimport Data.Maybe\nimport Data.List\nimport Debug.Trace\nimport System.Random\nimport Control.Monad\n\nsolve :: Int -> [Int] -> [Int]\nsolve n as | n `mod` 2 == 0 = reverse $ sort [sum_even, sum_odd]\n           | otherwise = [sum_odd + diff, sum_even - diff]\n  where\n    sum_all = sum as\n    sum_even = f_sum_even as\n    sum_odd = sum_all - sum_even\n    diff = calc_diff (max 0 (sum_even-sum_odd)) (sum_even + 1) as\n\nf_sum_even as = sub 0 as\n  where\n    sub !acc []       = acc\n    sub !acc [a]      = acc + a\n    sub !acc (a:_:as) = sub (acc+a) as\n\ncalc_diff dmin dmax as\n  | dmax == dmin + 1 = dmin\n  | try dmid as = calc_diff dmid dmax as\n  | otherwise = calc_diff dmin dmid as\n  where\n    dmid = (dmax + dmin) `div` 2\n\ntry goal [a] = goal <= a\ntry goal (w0:b0:as@(w1:as'))\n  | w0 >= goal && w0 <= b0 = try goal as\n  | otherwise              = try goal (w1 + (w0-b0) : as')\n\nbsReadInts :: B.ByteString -> [Int]\nbsReadInts = map (fst . fromJust . B.readInt) . B.words\n\nmain = do\n  cont <- B.getContents\n  let (n:as) = bsReadInts cont\n      ans= solve n as\n  putStrLn $ unwords $ map show ans\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf (int)(1e9)\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint main(){\n\tint N, i, evensum = 0, oddsum = 0;\n\tscanf(\"%d\", &N);\n\tint *a = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tif(i % 2 == 0){\n\t\t\tevensum += a[i];\n\t\t}\n\t\telse{\n\t\t\toddsum += a[i];\n\t\t}\n\t}\n\tif(N % 2 == 0){\n\t\tprintf(\"%d %d\\n\", max(evensum, oddsum), min(evensum, oddsum));\n\t\treturn 0;\n\t}\n\tint *dp = (int *)malloc(sizeof(int) * ((N + 1) / 2));\n\tdp[0] = a[0];\n\tint l = -inf, h, r = inf;\n\twhile(r - l > 1){\n\t\th = (l + r) / 2;\n\t\tfor(i = 1; 2 * i < N; i++){\n\t\t\tdp[i] = dp[i - 1] + a[2 * i] - a[2 * i - 1];\n\t\t\tif(dp[i - 1] >= h){\n\t\t\t\tdp[i] = max(dp[i], a[2 * i]);\n\t\t\t}\n\t\t}\n\t\tif(dp[N / 2] >= h){\n\t\t\tl = h;\n\t\t}\n\t\telse{\n\t\t\tr = h;\n\t\t}\n\t}\n\tint ans = max(evensum, oddsum + l);\n\tprintf(\"%d %d\\n\", ans, evensum + oddsum - ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void)\n{\n\n\nreturn 0;\n\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.Scanner\n\nfun main(args:Array<String>){\n    val scanner=Scanner(System.`in`)\n\n    val n=scanner.nextInt()\n    var a=IntArray(n+2)\n    for (i in 1..n){\n        a[i]=scanner.nextInt()\n    }\n    a[0]=0\n    a[n+1]=0\n\n    var su=0\n    var si=0\n\n    var max=0\n    var num=0\n    for (j in 1..n){\n        if (max<a[j]){\n            max=a[j]\n            num=j\n        }\n    }\n    su+=max\n    a[num]=0\n\n    for (k in 1..(n-1)){\n        max=0\n        if (k%2==0){//su\n            if (a[num-1]==0&&a[num+1]==0){\n                for (p in 1..n){\n                    if (max<a[p]){\n                        max=a[p]\n                        num=p\n                    }\n                }\n                su+=a[num]\n                a[num]=0\n            }\n            else {\n                if (a[num-1]<a[num+1]){\n                    su+=a[num+1]\n                    num=num+1\n                    a[num]=0\n                }\n                else{\n                    su+=a[num-1]\n                    num=num-1\n                    a[num]=0\n                }\n            }\n            println(\"su=$su\")\n        }\n        else if (k%2==1){//si\n            if (a[num-1]==0&&a[num+1]==0){\n                for (p in 1..n){\n                    if (max<a[p]){\n                        max=a[p]\n                        num=p\n                    }\n                }\n                si+=a[num]\n                a[num]=0\n            }\n            else {\n                if (a[num-1]<a[num+1]){\n                    si+=a[num+1]\n                    num=num+1\n                    a[num]=0\n                }\n                else{\n                    si+=a[num-1]\n                    num=num-1\n                    a[num]=0\n                }\n            }\n            println(\"si=$si\")\n        }\n    }\n\n    print(\"${su} ${si}\")\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.Scanner\n\nfun main(args:Array<String>){\n    val scanner=Scanner(System.`in`)\n\n    val n=scanner.nextInt()\n    var a=IntArray(n+2)\n    for (i in 1..n){\n        a[i]=scanner.nextInt()\n    }\n    a[0]=0\n    a[n+1]=0\n\n    var su=0\n    var si=0\n\n    var max=0\n    var num=0\n    for (j in 1..n){\n        if (max<a[j]){\n            max=a[j]\n            num=j\n        }\n    }\n    su+=max\n    a[num]=0\n\n    for (k in 1..(n-1)){\n        max=0\n        if (k%2==0){//su\n            if (a[num-1]==0&&a[num+1]==0){\n                for (p in 1..n){\n                    if (max<a[p]){\n                        max=a[p]\n                        num=p\n                    }\n                }\n                su+=a[num]\n                a[num]=0\n            }\n            else {\n                if (a[num-1]<a[num+1]){\n                    su+=a[num+1]\n                    num=num+1\n                    a[num]=0\n                }\n                else{\n                    su+=a[num-1]\n                    num=num-1\n                    a[num]=0\n                }\n            }\n        }\n        else if (k%2==1){//si\n            if (a[num-1]==0&&a[num+1]==0){\n                for (p in 1..n){\n                    if (max<a[p]){\n                        max=a[p]\n                        num=p\n                    }\n                }\n                si+=a[num]\n                a[num]=0\n            }\n            else {\n                if (a[num-1]<a[num+1]){\n                    si+=a[num+1]\n                    num=num+1\n                    a[num]=0\n                }\n                else{\n                    si+=a[num-1]\n                    num=num-1\n                    a[num]=0\n                }\n            }\n        }\n    }\n\n    print(\"${su} ${si}\")\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    int[] a;\n    int[] sum0;\n    int[] sum1;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      a = new int[n];\n      int sum = 0;\n      sum0 = new int[n + 1];\n      sum1 = new int[n + 1];\n      for (int i = 0; i < n; ++i) {\n        a[i] = in.nextInt();\n        sum += a[i];\n        sum0[i + 1] = sum0[i];\n        sum1[i + 1] = sum1[i];\n        if (i % 2 == 0) {\n          sum0[i + 1] += a[i];\n        } else {\n          sum1[i + 1] += a[i];\n        }\n      }\n      int res = calc(0, n - 1, 1);\n      out.printLine(res + \" \" + (sum - res));\n    }\n\n    private int calc(int l, int r, int depth) {\n      int res = Math.max(sum(l, r, l % 2), sum(l, r, r % 2));\n      if (depth == 0) {\n        return res;\n      }\n      for (int i = l + 1; i <= r - 1; ++i) {\n        int cur = Integer.MAX_VALUE;\n        {\n          int val = sum(i, r, i % 2);\n          int osum = sum(l, i - 1, 0) + sum(l, i - 1, 1);\n          if ((r - i) % 2 == 1) {\n            val += calc(l, i - 1, depth - 1);\n          } else {\n            val += osum - calc(l, i - 1, depth - 1);\n          }\n          if (val < cur) {\n            cur = val;\n          }\n        }\n        {\n          int val = sum(l, i, i % 2);\n          int osum = sum(i + 1, r, 0) + sum(i + 1, r, 1);\n          if ((i - l) % 2 == 1) {\n            val += calc(i + 1, r, depth - 1);\n          } else {\n            val += osum - calc(i + 1, r, depth - 1);\n          }\n          if (val < cur) {\n            cur = val;\n          }\n        }\n        if (cur > res) {\n          res = cur;\n        }\n      }\n      return res;\n    }\n\n    private int sum(int l, int r, int odd) {\n      if (odd == 0) {\n        return sum0[r + 1] - sum0[l];\n      } else {\n        return sum1[r + 1] - sum1[l];\n      }\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    int[] a;\n    int[] sum0;\n    int[] sum1;\n    static final Random random = new Random(0xdead);\n    double sampling;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      a = new int[n];\n      sampling = Math.min(1.0, 500.0 / n);\n      int sum = 0;\n      sum0 = new int[n + 1];\n      sum1 = new int[n + 1];\n      for (int i = 0; i < n; ++i) {\n        a[i] = in.nextInt();\n        sum += a[i];\n        sum0[i + 1] = sum0[i];\n        sum1[i + 1] = sum1[i];\n        if (i % 2 == 0) {\n          sum0[i + 1] += a[i];\n        } else {\n          sum1[i + 1] += a[i];\n        }\n      }\n      int res = calc(0, n - 1, 3);\n      out.printLine(res + \" \" + (sum - res));\n    }\n\n    private int calc(int l, int r, int depth) {\n      int res = Math.max(sum(l, r, l % 2), sum(l, r, r % 2));\n      if (depth == 0) {\n        return res;\n      }\n      for (int i = l + 1; i <= r - 1; ++i) {\n        if (random.nextDouble() > sampling) {\n          continue;\n        }\n        int cur = Integer.MAX_VALUE;\n        {\n          int val = sum(i, r, i % 2);\n          int osum = sum(l, i - 1, 0) + sum(l, i - 1, 1);\n          if ((r - i) % 2 == 1) {\n            val += calc(l, i - 1, depth - 1);\n          } else {\n            val += osum - calc(l, i - 1, depth - 1);\n          }\n          if (val < cur) {\n            cur = val;\n          }\n        }\n        {\n          int val = sum(l, i, i % 2);\n          int osum = sum(i + 1, r, 0) + sum(i + 1, r, 1);\n          if ((i - l) % 2 == 1) {\n            val += calc(i + 1, r, depth - 1);\n          } else {\n            val += osum - calc(i + 1, r, depth - 1);\n          }\n          if (val < cur) {\n            cur = val;\n          }\n        }\n        if (cur > res) {\n          res = cur;\n        }\n      }\n      return res;\n    }\n\n    private int sum(int l, int r, int odd) {\n      if (odd == 0) {\n        return sum0[r + 1] - sum0[l];\n      } else {\n        return sum1[r + 1] - sum1[l];\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FManjuGame solver = new FManjuGame();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FManjuGame {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int[] a = in.readIntArray(n);\n            int x = 0;\n            for (int i = 0; i < n; i += 2) {\n                x += a[i];\n            }\n            int y = (int) (ArrayUtils.sumArray(a) - x);\n            if (n % 2 == 0) {\n                out.printLine(Math.max(x, y), Math.min(x, y));\n                return;\n            }\n            int answer = Math.max(x, y);\n            int oddLeft = 0;\n            int evenLeft = a[0];\n            int bestOddLeft = -1;\n            int bestEvenLeft = -1;\n            int bestOddRight = -1;\n            int bestEvenRight = -1;\n            int at = -1;\n            for (int i = 1; i < n; i += 2) {\n                int oddRight = y - oddLeft - a[i];\n                int evenRight = x - evenLeft;\n                if (evenRight + oddLeft > oddRight + evenLeft && at != -1) {\n                    answer = Math.max(answer,\n                            Math.min(Math.min(evenRight + oddLeft + a[i], bestEvenLeft + bestOddRight + a[at]),\n                                    a[i] + a[at] + bestOddLeft + oddRight + x - bestEvenLeft - evenRight));\n                } else {\n                    if (at == -1 || oddLeft - evenLeft > bestOddLeft - bestEvenLeft) {\n                        at = i;\n                        bestOddLeft = oddLeft;\n                        bestEvenLeft = evenLeft;\n                        bestEvenRight = evenRight;\n                        bestOddRight = oddRight;\n                    }\n                }\n                answer = Math.max(answer, a[i] + Math.min(oddLeft + evenRight, oddRight + evenLeft));\n                oddLeft += a[i];\n                evenLeft += a[i + 1];\n            }\n            out.printLine(answer, x + y - answer);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n        default public long sum() {\n            long result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n    }\n\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static long sumArray(int[] array) {\n            return new IntArray(array).sum();\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void removeAt(int index);\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FManjuGame solver = new FManjuGame();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FManjuGame {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = in.nextIntArray(n);\n\n            int[] sum = new int[2];\n            for (int i = 0; i < n; i++) {\n                sum[i % 2] += a[i];\n            }\n\n            if (n % 2 == 0) {\n                int sugim = Math.max(sum[0], sum[1]);\n                int sigma = Math.min(sum[0], sum[1]);\n                out.println(sugim + \" \" + sigma);\n\n                return;\n            }\n\n            int max = Integer.MAX_VALUE / 2;\n            int min = Integer.MIN_VALUE / 2;\n            while (max - min > 1) {\n                int x = (max + min) / 2;\n\n                int[] b = a.clone();\n                for (int i = 0; i < n - 2; i += 2) {\n                    if (b[i] < x || b[i + 1] < b[i]) {\n                        b[i + 2] += b[i] - b[i + 1];\n                    }\n                }\n\n                if (b[n - 1] >= x) {\n                    min = x;\n                } else {\n                    max = x;\n                }\n            }\n\n            int sugim = Math.max(sum[0], sum[1] + min);\n            int sigma = sum[0] + sum[1] - sugim;\n            out.println(sugim + \" \" + sigma);\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public InputReader(InputStream inputStream) {\n            br = new BufferedReader(new InputStreamReader(inputStream));\n            st = new StringTokenizer(\"\");\n        }\n\n        public String nextString() {\n            while (!st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine(), \" \");\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    int[] a;\n    int[] sum0;\n    int[] sum1;\n    static final Random random = new Random(0xdead);\n    double sampling;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      a = new int[n];\n      sampling = Math.min(1.0, 10000.0 / n);\n      int sum = 0;\n      sum0 = new int[n + 1];\n      sum1 = new int[n + 1];\n      for (int i = 0; i < n; ++i) {\n        a[i] = in.nextInt();\n        sum += a[i];\n        sum0[i + 1] = sum0[i];\n        sum1[i + 1] = sum1[i];\n        if (i % 2 == 0) {\n          sum0[i + 1] += a[i];\n        } else {\n          sum1[i + 1] += a[i];\n        }\n      }\n      int res = calc(0, n - 1, 2);\n      out.printLine(res + \" \" + (sum - res));\n    }\n\n    private int calc(int l, int r, int depth) {\n      int res = Math.max(sum(l, r, l % 2), sum(l, r, r % 2));\n      if (depth == 0) {\n        return res;\n      }\n      for (int i = l + 1; i <= r - 1; ++i) {\n        if (random.nextDouble() > sampling) {\n          continue;\n        }\n        int cur = Integer.MAX_VALUE;\n        {\n          int val = sum(i, r, i % 2);\n          int osum = sum(l, i - 1, 0) + sum(l, i - 1, 1);\n          if ((r - i) % 2 == 1) {\n            val += calc(l, i - 1, depth - 1);\n          } else {\n            val += osum - calc(l, i - 1, depth - 1);\n          }\n          if (val < cur) {\n            cur = val;\n          }\n        }\n        {\n          int val = sum(l, i, i % 2);\n          int osum = sum(i + 1, r, 0) + sum(i + 1, r, 1);\n          if ((i - l) % 2 == 1) {\n            val += calc(i + 1, r, depth - 1);\n          } else {\n            val += osum - calc(i + 1, r, depth - 1);\n          }\n          if (val < cur) {\n            cur = val;\n          }\n        }\n        if (cur > res) {\n          res = cur;\n        }\n      }\n      return res;\n    }\n\n    private int sum(int l, int r, int odd) {\n      if (odd == 0) {\n        return sum0[r + 1] - sum0[l];\n      } else {\n        return sum1[r + 1] - sum1[l];\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FManjuGame solver = new FManjuGame();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FManjuGame {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int[] a = in.readIntArray(n);\n            int x = 0;\n            for (int i = 0; i < n; i += 2) {\n                x += a[i];\n            }\n            int y = (int) (ArrayUtils.sumArray(a) - x);\n            if (n % 2 == 0) {\n                out.printLine(Math.max(x, y), Math.min(x, y));\n                return;\n            }\n            int answer = Math.max(x, y);\n            int oddLeft = 0;\n            int evenLeft = a[0];\n            for (int i = 1; i < n; i += 2) {\n                int oddRight = y - oddLeft - a[i];\n                int evenRight = x - evenLeft;\n                answer = Math.max(answer, a[i] + Math.min(oddLeft + evenRight, oddRight + evenLeft));\n                oddLeft += a[i];\n                evenLeft += a[i + 1];\n            }\n            out.printLine(answer, x + y - answer);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n        default public long sum() {\n            long result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n    }\n\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static long sumArray(int[] array) {\n            return new IntArray(array).sum();\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void removeAt(int index);\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i) a[i] = in.nextInt();\n            int s1 = 0;\n            int s2 = 0;\n            for (int i = 0; i < n; ++i) {\n                if (i % 2 == 0)\n                    s1 += a[i];\n                else\n                    s2 += a[i];\n            }\n            if (n % 2 == 0) {\n                out.println(Math.max(s1, s2) + \" \" + Math.min(s1, s2));\n                return;\n            }\n            int left = s1 - s2;\n            int right = s1 + s2 + 1;\n            outer:\n            while (right - left > 1) {\n                int middle = (left + right) / 2;\n                long bestSoFar = s1 - s2;\n                int r1 = s1;\n                int r2 = s2;\n                for (int i = 1; i <= n; i += 2) {\n                    r1 -= a[i - 1];\n                    long cost = bestSoFar - (r1 - r2);\n                    if (i < n) r2 -= a[i];\n                    if (cost >= middle) {\n                        if (i == n) {\n                            left = middle;\n                            continue outer;\n                        } else {\n                            bestSoFar = Math.max(bestSoFar, r1 - r2);\n                        }\n                    }\n                }\n                right = middle;\n            }\n            out.println((s2 + left) + \" \" + (s1 - left));\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    int[] a;\n    int[] sum0;\n    int[] sum1;\n    static final Random random = new Random(0xdead);\n    double sampling;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      a = new int[n];\n      sampling = Math.min(1.0, 2000.0 / n);\n      int sum = 0;\n      sum0 = new int[n + 1];\n      sum1 = new int[n + 1];\n      for (int i = 0; i < n; ++i) {\n        a[i] = in.nextInt();\n        sum += a[i];\n        sum0[i + 1] = sum0[i];\n        sum1[i + 1] = sum1[i];\n        if (i % 2 == 0) {\n          sum0[i + 1] += a[i];\n        } else {\n          sum1[i + 1] += a[i];\n        }\n      }\n      int res = calc(0, n - 1, 2);\n      out.printLine(res + \" \" + (sum - res));\n    }\n\n    private int calc(int l, int r, int depth) {\n      int res = Math.max(sum(l, r, l % 2), sum(l, r, r % 2));\n      if (depth == 0) {\n        return res;\n      }\n      for (int i = l + 1; i <= r - 1; i += Math.max(1, random.nextInt((int) (1.0 / sampling)))) {\n        int cur = Integer.MAX_VALUE;\n        {\n          int val = sum(i, r, i % 2);\n          int osum = sum(l, i - 1, 0) + sum(l, i - 1, 1);\n          if ((r - i) % 2 == 1) {\n            val += calc(l, i - 1, depth - 1);\n          } else {\n            val += osum - calc(l, i - 1, depth - 1);\n          }\n          if (val < cur) {\n            cur = val;\n          }\n        }\n        {\n          int val = sum(l, i, i % 2);\n          int osum = sum(i + 1, r, 0) + sum(i + 1, r, 1);\n          if ((i - l) % 2 == 1) {\n            val += calc(i + 1, r, depth - 1);\n          } else {\n            val += osum - calc(i + 1, r, depth - 1);\n          }\n          if (val < cur) {\n            cur = val;\n          }\n        }\n        if (cur > res) {\n          res = cur;\n        }\n      }\n      return res;\n    }\n\n    private int sum(int l, int r, int odd) {\n      if (odd == 0) {\n        return sum0[r + 1] - sum0[l];\n      } else {\n        return sum1[r + 1] - sum1[l];\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskF solver = new TaskF();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskF {\n\n    int[] a;\n    int[] sum0;\n    int[] sum1;\n    static final Random random = new Random(0xdead);\n    double sampling;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      a = new int[n];\n      sampling = Math.min(1.0, 300.0 / n);\n      int sum = 0;\n      sum0 = new int[n + 1];\n      sum1 = new int[n + 1];\n      for (int i = 0; i < n; ++i) {\n        a[i] = in.nextInt();\n        sum += a[i];\n        sum0[i + 1] = sum0[i];\n        sum1[i + 1] = sum1[i];\n        if (i % 2 == 0) {\n          sum0[i + 1] += a[i];\n        } else {\n          sum1[i + 1] += a[i];\n        }\n      }\n      int res = calc(0, n - 1, 3);\n      out.printLine(res + \" \" + (sum - res));\n    }\n\n    private int calc(int l, int r, int depth) {\n      int res = Math.max(sum(l, r, l % 2), sum(l, r, r % 2));\n      if (depth == 0) {\n        return res;\n      }\n      for (int i = l + 1; i <= r - 1; i += Math.max(1, random.nextInt((int) (1.0 / sampling)))) {\n        int cur = Integer.MAX_VALUE;\n        {\n          int val = sum(i, r, i % 2);\n          int osum = sum(l, i - 1, 0) + sum(l, i - 1, 1);\n          if ((r - i) % 2 == 1) {\n            val += calc(l, i - 1, depth - 1);\n          } else {\n            val += osum - calc(l, i - 1, depth - 1);\n          }\n          if (val < cur) {\n            cur = val;\n          }\n        }\n        {\n          int val = sum(l, i, i % 2);\n          int osum = sum(i + 1, r, 0) + sum(i + 1, r, 1);\n          if ((i - l) % 2 == 1) {\n            val += calc(i + 1, r, depth - 1);\n          } else {\n            val += osum - calc(i + 1, r, depth - 1);\n          }\n          if (val < cur) {\n            cur = val;\n          }\n        }\n        if (cur > res) {\n          res = cur;\n        }\n      }\n      return res;\n    }\n\n    private int sum(int l, int r, int odd) {\n      if (odd == 0) {\n        return sum0[r + 1] - sum0[l];\n      } else {\n        return sum1[r + 1] - sum1[l];\n      }\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "n = input()\nslimes = map(int, input().split())\nres = 0\nlast = -1\ncnt = 0\nfor slime in slimes:\n    if slime != last:\n        res += cnt // 2\n        last = slime\n        cnt = 1\n    else:\n        cnt += 1\n\nres += cnt // 2\n\nprint(res)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = list(map(int, input().split()))\n\ndef completo(l):\n\tfor e in l: \n\t\tif e != 0:\n\t\t\treturn False\n\treturn True\n\ndef solve(turno, a, b, l, index,n):\n\n\tif completo(l):\n\t\tprint(a,b)\n\t\treturn\n\n\tif turno == n:\n\t\tprint(a,b)\n\t\treturn \n\n\tif index == -1: \n\t\tm = max(l)\n\t\tindex = l.index(m)\n\n\telif l[index-1] == 0 and l[index+1] == 0: \n\t\tsolve(turno,a,b,l,-1,n)\n\n\telif l[index-1] > l[index+1]: \n\t\tm = l[index-1]\n\t\tindex = index-1\n\n\telse:\n\t\tm = l[index+1]\n\t\tindex = index+1\n\n\tl[index] = 0\n\n\tif turno % 2 == 0:\n\t\tif index == 0 or index == len(l)-1: \n\t\t\tsolve(turno+1,a+m,b,l,-1,n)\n\t\telse: \n\t\t\tsolve(turno+1,a+m,b,l,index,n)\n\telse:\n\t\tif index == 0 or index == len(l)-1: \n\t\t\tsolve(turno+1,a,b+m,l,-1,n)\n\t\telse: \n\t\t\tsolve(turno+1,a,b+m,l,index,n)\n\nsolve(0,0,0,l,-1,n)"
  },
  {
    "language": "Python",
    "code": "from os import sys\nsys.setrecursionlimit(1000000000)\n\nn = int(input())\nl = list(map(int, input().split()))\n\ndef completo(l):\n\tfor e in l: \n\t\tif e != 0:\n\t\t\treturn False\n\treturn True\n\ndef solve(turno, a, b, l, index,n):\n\n\tif completo(l):\n\t\tprint(a,b)\n\t\treturn\n\n\tif turno == n:\n\t\tprint(a,b)\n\t\treturn \n\n\tif index == -1: \n\t\tm = max(l)\n\t\tindex = l.index(m)\n\n\telif l[index-1] == 0 and l[index+1] == 0: \n\t\tsolve(turno,a,b,l,-1,n)\n\n\telif l[index-1] > l[index+1]: \n\t\tm = l[index-1]\n\t\tindex = index-1\n\n\telse:\n\t\tm = l[index+1]\n\t\tindex = index+1\n\n\tl[index] = 0\n\n\tif turno % 2 == 0:\n\t\tif index == 0 or index == len(l)-1: \n\t\t\tsolve(turno+1,a+m,b,l,-1,n)\n\t\telse: \n\t\t\tsolve(turno+1,a+m,b,l,index,n)\n\telse:\n\t\tif index == 0 or index == len(l)-1: \n\t\t\tsolve(turno+1,a,b+m,l,-1,n)\n\t\telse: \n\t\t\tsolve(turno+1,a,b+m,l,index,n)\n\nsolve(0,0,0,l,-1,n)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a = np.array(a)\n\n    s1 = 0\n    s2 = 0\n\n    for i in range(n):\n        z = i % 2\n\n        if (i == 0):\n            index = np.argmax(a)\n            s1 = a[index]\n            a[index] = -1\n            continue\n        else:\n            if (z == 0):\n                [s1, a, index] = auto(s1, a, index)\n            else:\n                [s2, a, index] = auto(s2, a, index)\n\n    print('{} {}'.format(s1, s2))\n\n\ndef auto(s, a, index):\n    left = 0\n    right = 0\n\n    if (index == 0):\n        left = -1\n        right = a[index+1]\n    elif (index == len(a)-1):\n        left = a[index-1]\n        right = -1\n    else:\n        left = a[index - 1]\n        right = a[index + 1]\n\n    if (left == -1 and right == -1):\n        index = np.argmax(a)\n        s += a[index]\n        a[index] = -1\n    elif (left >= right):\n        s += left\n        index = index-1\n        a[index] = -1\n    elif (left < right):\n        s += right\n        index = index+1\n        a[index] = -1\n\n    return [s, a, index]\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{min,max};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap,BTreeSet};\n#[allow(unused_imports)]\nuse std::ops::*;\n#[allow(unused_imports)]\nuse std::collections::BinaryHeap;\n\n#[allow(unused_macros)]\nmacro_rules! tf {\n    ($c:expr, $t:expr, $f:expr) => {{\n        if $c { $t } else { $f }\n    }};\n}\n\nfn cut_left(xs: &[i64], even_sum: &[i64], odd_sum: &[i64], l: usize, r: usize) -> i64 {\n    if r - l == 1 {\n        return xs[l];\n    }\n    if even_sum[r] - even_sum[l+1] <= xs[l] + odd_sum[r] - odd_sum[l+1] && xs[l+1] - xs[l] >= 0 {\n        //eprintln!(\"cut_left {} {}, cut\", l, r);\n        return min(xs[l] + odd_sum[r] - odd_sum[l+1], cut_left(xs, even_sum, odd_sum, l+2, r) + xs[l+1]);\n    }\n    else {\n        //eprintln!(\"cut_left {} {}, pass\", l, r);\n        return cut_right(xs, even_sum, odd_sum, l, r);\n    }\n}\n\nfn cut_right(xs: &[i64], even_sum: &[i64], odd_sum: &[i64], l: usize, r: usize) -> i64 {\n    if r - l == 1 {\n        return xs[l];\n    }\n    if even_sum[r-1] - even_sum[l] <= xs[r-1] + odd_sum[r-1] - odd_sum[l] && xs[r-2] - xs[r-1] >= 0 {\n        //eprintln!(\"cut_right {} {}, cut\", l, r);\n        return min(xs[r-1] + odd_sum[r-1] - odd_sum[l], cut_right(xs, even_sum, odd_sum, l, r-2) + xs[r-2]);\n    }\n    else {\n        //eprintln!(\"cut_right {} {}, pass\", l, r);\n        return even_sum[r] - even_sum[l];\n    }\n}\n\nfn main() {\n    let n = read_i64() as usize;\n    let xs = read_vec_i64();\n    let mut even_sum = vec![0; n+1];\n    for i in 0..n {\n        even_sum[i+1] = even_sum[i] + tf!(i % 2 == 0, xs[i], 0);\n    }\n    let mut odd_sum = vec![0; n+1];\n    for i in 0..n {\n        odd_sum[i+1] = odd_sum[i] + tf!(i % 2 == 1, xs[i], 0);\n    }\n    if n % 2 == 0 {\n        let even_s = even_sum[n] - even_sum[0];\n        let odd_s  = odd_sum[n] - odd_sum[0];\n        println!(\"{} {}\", max(even_s, odd_s), min(even_s, odd_s));\n    }\n    else {\n        let black = cut_left(&xs, &even_sum, &odd_sum, 0, n);\n        let white = even_sum[n] + odd_sum[n] - black;\n        println!(\"{} {}\", black, white);\n    }\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok();\n    ret.pop();\n    //ret.pop();\n    return ret;\n}\n\n#[allow(dead_code)]\nfn read_i64() -> i64 {\n    let ss = read_line();\n    return ss.parse::<i64>().unwrap();\n}\n\n#[allow(dead_code)]\nfn read_vec_i64() -> Vec<i64> {\n    let mut res = vec![];\n    let ss = read_line();\n    for ts in ss.split_whitespace() {\n        let x = ts.parse::<i64>().unwrap();\n        res.push(x);\n    }\n    return res;\n}\n\nuse std::fmt::Display;\n#[allow(dead_code)]\nfn write_vec<T: Display>(xs: &Vec<T>) {\n    if xs.len() == 0 {\n        println!(\"\");\n        return;\n    }\n    print!(\"{}\", xs[0]);\n    for i in 1..xs.len() {\n        print!(\" {}\", xs[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{min,max};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap,BTreeSet};\n#[allow(unused_imports)]\nuse std::ops::*;\n#[allow(unused_imports)]\nuse std::collections::BinaryHeap;\n\n#[allow(unused_macros)]\nmacro_rules! tf {\n    ($c:expr, $t:expr, $f:expr) => {{\n        if $c { $t } else { $f }\n    }};\n}\n\nfn cut_left(xs: &[i64], even_sum: &[i64], odd_sum: &[i64], l: usize, r: usize) -> i64 {\n    if r - l == 1 {\n        return xs[l];\n    }\n    if even_sum[r] - even_sum[l+1] <= xs[l] + odd_sum[r] - odd_sum[l+1] && xs[l+1] - xs[l] >= 0 {\n        //eprintln!(\"cut_left {} {}, cut\", l, r);\n        return cut_left(xs, even_sum, odd_sum, l+2, r) + xs[l+1];\n    }\n    else {\n        //eprintln!(\"cut_left {} {}, pass\", l, r);\n        return cut_right(xs, even_sum, odd_sum, l, r);\n    }\n}\n\nfn cut_right(xs: &[i64], even_sum: &[i64], odd_sum: &[i64], l: usize, r: usize) -> i64 {\n    if r - l == 1 {\n        return xs[l];\n    }\n    if even_sum[r-1] - even_sum[l] <= xs[r-1] + odd_sum[r-1] - odd_sum[l] && xs[r-2] - xs[r-1] >= 0 {\n        //eprintln!(\"cut_right {} {}, cut\", l, r);\n        return cut_right(xs, even_sum, odd_sum, l, r-2) + xs[r-2];\n    }\n    else {\n        //eprintln!(\"cut_right {} {}, pass\", l, r);\n        return even_sum[r] - even_sum[l];\n    }\n}\n\nfn main() {\n    let n = read_i64() as usize;\n    let xs = read_vec_i64();\n    let mut even_sum = vec![0; n+1];\n    for i in 0..n {\n        even_sum[i+1] = even_sum[i] + tf!(i % 2 == 0, xs[i], 0);\n    }\n    let mut odd_sum = vec![0; n+1];\n    for i in 0..n {\n        odd_sum[i+1] = odd_sum[i] + tf!(i % 2 == 1, xs[i], 0);\n    }\n    if n % 2 == 0 {\n        let even_s = even_sum[n] - even_sum[0];\n        let odd_s  = odd_sum[n] - odd_sum[0];\n        println!(\"{} {}\", max(even_s, odd_s), min(even_s, odd_s));\n    }\n    else {\n        let black = cut_left(&xs, &even_sum, &odd_sum, 0, n);\n        let white = even_sum[n] + odd_sum[n] - black;\n        println!(\"{} {}\", black, white);\n    }\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok();\n    ret.pop();\n    //ret.pop();\n    return ret;\n}\n\n#[allow(dead_code)]\nfn read_i64() -> i64 {\n    let ss = read_line();\n    return ss.parse::<i64>().unwrap();\n}\n\n#[allow(dead_code)]\nfn read_vec_i64() -> Vec<i64> {\n    let mut res = vec![];\n    let ss = read_line();\n    for ts in ss.split_whitespace() {\n        let x = ts.parse::<i64>().unwrap();\n        res.push(x);\n    }\n    return res;\n}\n\nuse std::fmt::Display;\n#[allow(dead_code)]\nfn write_vec<T: Display>(xs: &Vec<T>) {\n    if xs.len() == 0 {\n        println!(\"\");\n        return;\n    }\n    print!(\"{}\", xs[0]);\n    for i in 1..xs.len() {\n        print!(\" {}\", xs[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{min,max};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap,BTreeSet};\n#[allow(unused_imports)]\nuse std::ops::*;\n#[allow(unused_imports)]\nuse std::collections::BinaryHeap;\n\n#[allow(unused_macros)]\nmacro_rules! tf {\n    ($c:expr, $t:expr, $f:expr) => {{\n        if $c { $t } else { $f }\n    }};\n}\n\nfn main() {\n    let n = read_i64() as usize;\n    let xs = read_vec_i64();\n    let even_sum = xs.iter().enumerate().filter(|&(i,&_)| i % 2 == 0).fold(0i64, |s,(_,&x)| s + x);\n    let odd_sum  = xs.iter().enumerate().filter(|&(i,&_)| i % 2 == 1).fold(0i64, |s,(_,&x)| s + x);\n    if n % 2 == 0 {\n        println!(\"{} {}\", max(even_sum, odd_sum), min(even_sum, odd_sum));\n    }\n    else {\n        let mut lower = 0;\n        let mut upper = 1i64 << 29;\n        while upper - lower != 1 {\n            let x = (lower+upper)/2;\n            let mut l = 0;\n            let mut r = n;\n            let mut offset = 0;\n            while r - l != 1 {\n                if xs[l] + offset >= x && xs[l+1] >= xs[l] + offset {\n                    l += 2;\n                    offset = 0;\n                }\n                else {\n                    offset = xs[l] + offset - xs[l+1];\n                    l += 2;\n                }\n            }\n            let yes = xs[l] + offset >= x;\n            if yes {\n                lower = x;\n            }\n            else {\n                upper = x;\n            }\n        }\n        let black = lower + odd_sum;\n        let white = even_sum + odd_sum - black;\n        println!(\"{} {}\", black, white);\n    }\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok();\n    ret.pop();\n    //ret.pop();\n    return ret;\n}\n\n#[allow(dead_code)]\nfn read_i64() -> i64 {\n    let ss = read_line();\n    return ss.parse::<i64>().unwrap();\n}\n\n#[allow(dead_code)]\nfn read_vec_i64() -> Vec<i64> {\n    let mut res = vec![];\n    let ss = read_line();\n    for ts in ss.split_whitespace() {\n        let x = ts.parse::<i64>().unwrap();\n        res.push(x);\n    }\n    return res;\n}\n\nuse std::fmt::Display;\n#[allow(dead_code)]\nfn write_vec<T: Display>(xs: &Vec<T>) {\n    if xs.len() == 0 {\n        println!(\"\");\n        return;\n    }\n    print!(\"{}\", xs[0]);\n    for i in 1..xs.len() {\n        print!(\" {}\", xs[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{min,max};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap,BTreeSet};\n#[allow(unused_imports)]\nuse std::ops::*;\n#[allow(unused_imports)]\nuse std::collections::BinaryHeap;\n\n#[allow(unused_macros)]\nmacro_rules! tf {\n    ($c:expr, $t:expr, $f:expr) => {{\n        if $c { $t } else { $f }\n    }};\n}\n\nfn main() {\n    let n = read_i64() as usize;\n    let xs = read_vec_i64();\n    let even_sum = xs.iter().enumerate().filter(|(i,&_)| i % 2 == 0).fold(0i64, |s,(_,&x)| s + x);\n    let odd_sum  = xs.iter().enumerate().filter(|(i,&_)| i % 2 == 1).fold(0i64, |s,(_,&x)| s + x);\n    if n % 2 == 0 {\n        println!(\"{} {}\", max(even_sum, odd_sum), min(even_sum, odd_sum));\n    }\n    else {\n        let mut lower = 0;\n        let mut upper = 1i64 << 30;\n        while upper - lower != 1 {\n            let x = (lower+upper)/2;\n            let mut l = 0;\n            let mut r = n;\n            let mut offset = 0;\n            while r - l != 1 {\n                if xs[l] + offset >= x && xs[l+1] >= xs[l] + offset {\n                    l += 2;\n                    offset = 0;\n                }\n                else {\n                    offset = xs[l] + offset - xs[l+1];\n                    l += 2;\n                }\n            }\n            let yes = xs[l] + offset >= x;\n            if yes {\n                lower = x;\n            }\n            else {\n                upper = x;\n            }\n        }\n        let black = lower + odd_sum;\n        let white = even_sum + odd_sum - black;\n        println!(\"{} {}\", black, white);\n    }\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok();\n    ret.pop();\n    //ret.pop();\n    return ret;\n}\n\n#[allow(dead_code)]\nfn read_i64() -> i64 {\n    let ss = read_line();\n    return ss.parse::<i64>().unwrap();\n}\n\n#[allow(dead_code)]\nfn read_vec_i64() -> Vec<i64> {\n    let mut res = vec![];\n    let ss = read_line();\n    for ts in ss.split_whitespace() {\n        let x = ts.parse::<i64>().unwrap();\n        res.push(x);\n    }\n    return res;\n}\n\nuse std::fmt::Display;\n#[allow(dead_code)]\nfn write_vec<T: Display>(xs: &Vec<T>) {\n    if xs.len() == 0 {\n        println!(\"\");\n        return;\n    }\n    print!(\"{}\", xs[0]);\n    for i in 1..xs.len() {\n        print!(\" {}\", xs[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{min,max};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap,BTreeSet};\n#[allow(unused_imports)]\nuse std::ops::*;\n#[allow(unused_imports)]\nuse std::collections::BinaryHeap;\n\n#[allow(unused_macros)]\nmacro_rules! tf {\n    ($c:expr, $t:expr, $f:expr) => {{\n        if $c { $t } else { $f }\n    }};\n}\n\nfn main() {\n    let n = read_i64() as usize;\n    let xs = read_vec_i64();\n    let mut even_sum = vec![0; n+1];\n    for i in 0..n {\n        even_sum[i+1] = even_sum[i] + tf!(i % 2 == 0, xs[i], 0);\n    }\n    let mut odd_sum = vec![0; n+1];\n    for i in 0..n {\n        odd_sum[i+1] = odd_sum[i] + tf!(i % 2 == 1, xs[i], 0);\n    }\n    if n % 2 == 0 {\n        let even_s = even_sum[n] - even_sum[0];\n        let odd_s  = odd_sum[n] - odd_sum[0];\n        println!(\"{} {}\", max(even_s, odd_s), min(even_s, odd_s));\n    }\n    else {\n        let mut lower = 0;\n        let mut upper = 1i64 << 30;\n        while upper - lower != 1 {\n            let x = (lower+upper)/2;\n            let mut ys = xs.clone();\n            let mut l = 0;\n            let mut r = n;\n            while r - l != 1 {\n                if ys[l] >= x && ys[l+1] >= ys[l] {\n                    l += 2;\n                }\n                else {\n                    ys[l+2] = ys[l] - ys[l+1] + ys[l+2];\n                    l += 2;\n                }\n            }\n            let yes = ys[l] >= x;\n            if yes {\n                lower = x;\n            }\n            else {\n                upper = x;\n            }\n        }\n        let black = lower + odd_sum[n];\n        let white = even_sum[n] + odd_sum[n] - black;\n        println!(\"{} {}\", black, white);\n    }\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok();\n    ret.pop();\n    //ret.pop();\n    return ret;\n}\n\n#[allow(dead_code)]\nfn read_i64() -> i64 {\n    let ss = read_line();\n    return ss.parse::<i64>().unwrap();\n}\n\n#[allow(dead_code)]\nfn read_vec_i64() -> Vec<i64> {\n    let mut res = vec![];\n    let ss = read_line();\n    for ts in ss.split_whitespace() {\n        let x = ts.parse::<i64>().unwrap();\n        res.push(x);\n    }\n    return res;\n}\n\nuse std::fmt::Display;\n#[allow(dead_code)]\nfn write_vec<T: Display>(xs: &Vec<T>) {\n    if xs.len() == 0 {\n        println!(\"\");\n        return;\n    }\n    print!(\"{}\", xs[0]);\n    for i in 1..xs.len() {\n        print!(\" {}\", xs[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{min,max};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap,BTreeSet};\n#[allow(unused_imports)]\nuse std::ops::*;\n#[allow(unused_imports)]\nuse std::collections::BinaryHeap;\n\n#[allow(unused_macros)]\nmacro_rules! tf {\n    ($c:expr, $t:expr, $f:expr) => {{\n        if $c { $t } else { $f }\n    }};\n}\n\nfn main() {\n    let n = read_i64() as usize;\n    let xs = read_vec_i64();\n    let even_sum = xs.iter().enumerate().filter(|&(i,&_)| i % 2 == 0).fold(0i64, |s,(_,&x)| s + x);\n    let odd_sum  = xs.iter().enumerate().filter(|&(i,&_)| i % 2 == 1).fold(0i64, |s,(_,&x)| s + x);\n    if n % 2 == 0 {\n        println!(\"{} {}\", max(even_sum, odd_sum), min(even_sum, odd_sum));\n    }\n    else {\n        let mut lower = 0;\n        let mut upper = 1i64 << 30;\n        while upper - lower != 1 {\n            let x = (lower+upper)/2;\n            let mut l = 0;\n            let mut r = n;\n            let mut offset = 0;\n            while r - l != 1 {\n                if xs[l] + offset >= x && xs[l+1] >= xs[l] + offset {\n                    l += 2;\n                    offset = 0;\n                }\n                else {\n                    offset = xs[l] + offset - xs[l+1];\n                    l += 2;\n                }\n            }\n            let yes = xs[l] + offset >= x;\n            if yes {\n                lower = x;\n            }\n            else {\n                upper = x;\n            }\n        }\n        let black = lower + odd_sum;\n        let white = even_sum + odd_sum - black;\n        println!(\"{} {}\", black, white);\n    }\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok();\n    ret.pop();\n    //ret.pop();\n    return ret;\n}\n\n#[allow(dead_code)]\nfn read_i64() -> i64 {\n    let ss = read_line();\n    return ss.parse::<i64>().unwrap();\n}\n\n#[allow(dead_code)]\nfn read_vec_i64() -> Vec<i64> {\n    let mut res = vec![];\n    let ss = read_line();\n    for ts in ss.split_whitespace() {\n        let x = ts.parse::<i64>().unwrap();\n        res.push(x);\n    }\n    return res;\n}\n\nuse std::fmt::Display;\n#[allow(dead_code)]\nfn write_vec<T: Display>(xs: &Vec<T>) {\n    if xs.len() == 0 {\n        println!(\"\");\n        return;\n    }\n    print!(\"{}\", xs[0]);\n    for i in 1..xs.len() {\n        print!(\" {}\", xs[i]);\n    }\n    println!(\"\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{min,max};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap,BTreeSet};\n#[allow(unused_imports)]\nuse std::ops::*;\n#[allow(unused_imports)]\nuse std::collections::BinaryHeap;\n\n#[allow(unused_macros)]\nmacro_rules! tf {\n    ($c:expr, $t:expr, $f:expr) => {{\n        if $c { $t } else { $f }\n    }};\n}\n\nfn main() {\n    let n = read_i64() as usize;\n    let xs = read_vec_i64();\n    let mut even_sum = vec![0; n+1];\n    for i in 0..n {\n        even_sum[i+1] = even_sum[i] + tf!(i % 2 == 0, xs[i], 0);\n    }\n    let mut odd_sum = vec![0; n+1];\n    for i in 0..n {\n        odd_sum[i+1] = odd_sum[i] + tf!(i % 2 == 1, xs[i], 0);\n    }\n    if n % 2 == 0 {\n        let even_s = even_sum[n] - even_sum[0];\n        let odd_s  = odd_sum[n] - odd_sum[0];\n        println!(\"{} {}\", max(even_s, odd_s), min(even_s, odd_s));\n    }\n    else {\n        let mut lower = 0;\n        let mut upper = 1i64 << 30;\n        while upper - lower != 1 {\n            let x = (lower+upper)/2;\n            let mut l = 0;\n            let mut r = n;\n            let mut offset = 0;\n            while r - l != 1 {\n                if xs[l] + offset >= x && xs[l+1] >= xs[l] + offset {\n                    l += 2;\n                    offset = 0;\n                }\n                else {\n                    offset = xs[l] + offset - xs[l+1];\n                    l += 2;\n                }\n            }\n            let yes = xs[l] + offset >= x;\n            if yes {\n                lower = x;\n            }\n            else {\n                upper = x;\n            }\n        }\n        let black = lower + odd_sum[n];\n        let white = even_sum[n] + odd_sum[n] - black;\n        println!(\"{} {}\", black, white);\n    }\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok();\n    ret.pop();\n    //ret.pop();\n    return ret;\n}\n\n#[allow(dead_code)]\nfn read_i64() -> i64 {\n    let ss = read_line();\n    return ss.parse::<i64>().unwrap();\n}\n\n#[allow(dead_code)]\nfn read_vec_i64() -> Vec<i64> {\n    let mut res = vec![];\n    let ss = read_line();\n    for ts in ss.split_whitespace() {\n        let x = ts.parse::<i64>().unwrap();\n        res.push(x);\n    }\n    return res;\n}\n\nuse std::fmt::Display;\n#[allow(dead_code)]\nfn write_vec<T: Display>(xs: &Vec<T>) {\n    if xs.len() == 0 {\n        println!(\"\");\n        return;\n    }\n    print!(\"{}\", xs[0]);\n    for i in 1..xs.len() {\n        print!(\" {}\", xs[i]);\n    }\n    println!(\"\");\n}\n"
  }
]