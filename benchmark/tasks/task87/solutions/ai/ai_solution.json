[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char name[21];\n    int w;\n    int s;\n} Food;\n\nint compare(const void *a, const void *b) {\n    Food *foodA = (Food *)a;\n    Food *foodB = (Food *)b;\n    int diff = (foodA->s + foodA->w) - (foodB->s + foodB->w);\n    if (diff != 0) return diff;\n    return (foodA->w) - (foodB->w);\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Food foods[10];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d %d\", foods[i].name, &foods[i].w, &foods[i].s);\n        }\n        qsort(foods, n, sizeof(Food), compare);\n        for (int i = 0; i < n; i++) {\n            printf(\"%s\\n\", foods[i].name);\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:33:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FoodStacking {\n    static class FoodItem {\n        String name;\n        int weight;\n        int capacity;\n\n        FoodItem(String name, int weight, int capacity) {\n            this.name = name;\n            this.weight = weight;\n            this.capacity = capacity;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n\n            List<FoodItem> items = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                String name = scanner.next();\n                int weight = scanner.nextInt();\n                int capacity = scanner.nextInt();\n                items.add(new FoodItem(name, weight, capacity));\n            }\n\n            List<FoodItem> bestOrder = findBestStackOrder(items);\n            for (FoodItem item : bestOrder) {\n                System.out.println(item.name);\n            }\n        }\n        \n        scanner.close();\n    }\n\n    static List<FoodItem> findBestStackOrder(List<FoodItem> items) {\n        List<List<FoodItem>> permutations = generatePermutations(items);\n        List<FoodItem> bestOrder = null;\n        double minGravity = Double.MAX_VALUE;\n\n        for (List<FoodItem> permutation : permutations) {\n            if (isValidStack(permutation)) {\n                double gravity = calculateGravity(permutation);\n                if (gravity < minGravity) {\n                    minGravity = gravity;\n                    bestOrder = permutation;\n                }\n            }\n        }\n\n        return bestOrder;\n    }\n\n    static List<List<FoodItem>> generatePermutations(List<FoodItem> items) {\n        List<List<FoodItem>> result = new ArrayList<>();\n        generatePermutationsHelper(items, new ArrayList<>(), result);\n        return result;\n    }\n\n    static void generatePermutationsHelper(List<FoodItem> remaining, \n                                           List<FoodItem> current, \n                                           List<List<FoodItem>> result) {\n        if (remaining.isEmpty()) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n\n        for (int i = 0; i < remaining.size(); i++) {\n            FoodItem item = remaining.get(i);\n            current.add(item);\n            List<FoodItem> newRemaining = new ArrayList<>(remaining);\n            newRemaining.remove(i);\n            generatePermutationsHelper(newRemaining, current, result);\n            current.remove(current.size() - 1);\n        }\n    }\n\n    static boolean isValidStack(List<FoodItem> stack) {\n        for (int i = 0; i < stack.size(); i++) {\n            int totalWeight = 0;\n            for (int j = i + 1; j < stack.size(); j++) {\n                totalWeight += stack.get(j).weight;\n            }\n            if (stack.get(i).capacity < totalWeight) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static double calculateGravity(List<FoodItem> stack) {\n        double numerator = 0;\n        double denominator = 0;\n        \n        for (int i = 0; i < stack.size(); i++) {\n            numerator += (i + 1) * stack.get(i).weight;\n            denominator += stack.get(i).weight;\n        }\n        \n        return numerator / denominator;\n    }\n}",
    "timestamp": "2025-08-05 18:33:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstruct Food {\n    string name;\n    int weight;\n    int strength;\n};\n\nbool compare(const Food& a, const Food& b) {\n    int a_sum = a.strength - b.weight;\n    int b_sum = b.strength - a.weight;\n    if (a_sum != b_sum) {\n        return a_sum > b_sum;\n    } else {\n        return a.weight < b.weight;\n    }\n}\n\nvoid solve(int n, vector<Food>& foods) {\n    sort(foods.begin(), foods.end(), compare);\n    \n    vector<Food> stack;\n    int total_weight = 0;\n    for (int i = 0; i < n; ++i) {\n        if (foods[i].strength >= total_weight) {\n            stack.push_back(foods[i]);\n            total_weight += foods[i].weight;\n        } else {\n            // Try to find a better arrangement by swapping\n            for (int j = 0; j < i; ++j) {\n                if (stack[j].strength >= total_weight - stack[j].weight + foods[i].weight &&\n                    foods[i].strength >= total_weight - stack[j].weight) {\n                    total_weight = total_weight - stack[j].weight + foods[i].weight;\n                    stack[j] = foods[i];\n                    break;\n                }\n            }\n        }\n    }\n    \n    for (int i = stack.size() - 1; i >= 0; --i) {\n        cout << stack[i].name << endl;\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n && n != 0) {\n        vector<Food> foods(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> foods[i].name >> foods[i].weight >> foods[i].strength;\n        }\n        solve(n, foods);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:34:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_NAME 21\n#define MAX_ITEMS 10\n\ntypedef struct {\n    char name[MAX_NAME];\n    int weight;\n    int capacity;\n} FoodItem;\n\nint is_valid_stack(FoodItem* items, int* order, int n) {\n    for (int i = 0; i < n; i++) {\n        int current_load = 0;\n        for (int j = i + 1; j < n; j++) {\n            current_load += items[order[j]].weight;\n        }\n        if (items[order[i]].capacity < current_load) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ndouble calculate_center_of_gravity(FoodItem* items, int* order, int n) {\n    double total_moment = 0;\n    double total_weight = 0;\n    for (int i = 0; i < n; i++) {\n        total_moment += (i + 1) * items[order[i]].weight;\n        total_weight += items[order[i]].weight;\n    }\n    return total_moment / total_weight;\n}\n\nint main() {\n    int dataset_count = 0;\n    \n    while (1) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        if (n == 0) break;\n        \n        dataset_count++;\n        FoodItem items[MAX_ITEMS];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d %d\", \n                  items[i].name, \n                  &items[i].weight, \n                  &items[i].capacity);\n        }\n        \n        int best_order[MAX_ITEMS];\n        double min_center_of_gravity = 1e9;\n        \n        int perm[MAX_ITEMS];\n        for (int i = 0; i < n; i++) {\n            perm[i] = i;\n        }\n        \n        do {\n            if (is_valid_stack(items, perm, n)) {\n                double cog = calculate_center_of_gravity(items, perm, n);\n                if (cog < min_center_of_gravity) {\n                    min_center_of_gravity = cog;\n                    memcpy(best_order, perm, sizeof(perm));\n                }\n            }\n        } while (next_permutation(perm, perm + n));\n        \n        printf(\"Dataset %d: \", dataset_count);\n        for (int i = 0; i < n; i++) {\n            printf(\"%s \", items[best_order[i]].name);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n\nint next_permutation(int* first, int* last) {\n    if (first == last) return 0;\n    \n    int* i = last - 1;\n    while (true) {\n        int* ii = i;\n        i--;\n        \n        if (*i < *ii) {\n            int* j = last - 1;\n            while (!(*i < *j)) j--;\n            \n            int temp = *i;\n            *i = *j;\n            *j = temp;\n            \n            reverse(ii, last);\n            return 1;\n        }\n        \n        if (i == first) {\n            reverse(first, last);\n            return 0;\n        }\n    }\n}\n\nvoid reverse(int* first, int* last) {\n    while ((first != last) && (first != --last)) {\n        int temp = *first;\n        *first = *last;\n        *last = temp;\n        first++;\n    }\n}",
    "timestamp": "2025-08-05 18:34:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <limits>\n#include <cmath>\n\nusing namespace std;\n\nstruct FoodItem {\n    string name;\n    int weight;\n    int capacity;\n};\n\nbool canStack(const vector<FoodItem>& stack) {\n    for (int i = 0; i < stack.size(); ++i) {\n        int totalWeight = 0;\n        for (int j = i + 1; j < stack.size(); ++j) {\n            totalWeight += stack[j].weight;\n        }\n        if (stack[i].capacity < totalWeight) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndouble calculateGravity(const vector<FoodItem>& stack) {\n    double numerator = 0;\n    double denominator = 0;\n    for (int i = 0; i < stack.size(); ++i) {\n        numerator += (i + 1) * stack[i].weight;\n        denominator += stack[i].weight;\n    }\n    return numerator / denominator;\n}\n\nvoid findOptimalStack(vector<FoodItem>& items) {\n    vector<FoodItem> bestStack;\n    double minGravity = numeric_limits<double>::max();\n    \n    sort(items.begin(), items.end(), [](const FoodItem& a, const FoodItem& b) {\n        return a.weight < b.weight;\n    });\n    \n    do {\n        if (canStack(items)) {\n            double gravity = calculateGravity(items);\n            if (gravity < minGravity) {\n                minGravity = gravity;\n                bestStack = items;\n            }\n        }\n    } while (next_permutation(items.begin(), items.end()));\n    \n    for (const auto& item : bestStack) {\n        cout << item.name << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    int n;\n    while (cin >> n && n != 0) {\n        vector<FoodItem> items(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> items[i].name >> items[i].weight >> items[i].capacity;\n        }\n        findOptimalStack(items);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:34:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass FoodItem {\n    String name;\n    int weight;\n    int strength;\n\n    public FoodItem(String name, int weight, int strength) {\n        this.name = name;\n        this.weight = weight;\n        this.strength = strength;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            List<FoodItem> items = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                String name = scanner.next();\n                int weight = scanner.nextInt();\n                int strength = scanner.nextInt();\n                items.add(new FoodItem(name, weight, strength));\n            }\n\n            List<FoodItem> bestOrder = null;\n            double minG = Double.MAX_VALUE;\n\n            List<List<FoodItem>> permutations = generatePermutations(items);\n            for (List<FoodItem> perm : permutations) {\n                boolean valid = true;\n                int totalWeightAbove = 0;\n                for (int i = perm.size() - 1; i >= 0; i--) {\n                    if (perm.get(i).strength < totalWeightAbove) {\n                        valid = false;\n                        break;\n                    }\n                    totalWeightAbove += perm.get(i).weight;\n                }\n                if (valid) {\n                    double G = calculateG(perm);\n                    if (G < minG) {\n                        minG = G;\n                        bestOrder = new ArrayList<>(perm);\n                    }\n                }\n            }\n\n            for (FoodItem item : bestOrder) {\n                System.out.println(item.name);\n            }\n        }\n    }\n\n    private static List<List<FoodItem>> generatePermutations(List<FoodItem> items) {\n        List<List<FoodItem>> permutations = new ArrayList<>();\n        permute(items, 0, permutations);\n        return permutations;\n    }\n\n    private static void permute(List<FoodItem> items, int start, List<List<FoodItem>> permutations) {\n        if (start == items.size() - 1) {\n            permutations.add(new ArrayList<>(items));\n            return;\n        }\n        for (int i = start; i < items.size(); i++) {\n            Collections.swap(items, start, i);\n            permute(items, start + 1, permutations);\n            Collections.swap(items, start, i);\n        }\n    }\n\n    private static double calculateG(List<FoodItem> order) {\n        double numerator = 0;\n        double denominator = 0;\n        for (int i = 0; i < order.size(); i++) {\n            numerator += (i + 1) * order.get(i).weight;\n            denominator += order.get(i).weight;\n        }\n        return numerator / denominator;\n    }\n}",
    "timestamp": "2025-08-05 18:35:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_food_items(input_data):\n    def is_valid_stack(order):\n        weight_sum = 0\n        for i in range(len(order) - 1, -1, -1):\n            weight_sum += order[i][1]\n            if order[i][2] < weight_sum - order[i][1]:\n                return False\n        return True\n\n    def calculate_center_of_gravity(order):\n        total_weight = sum(item[1] for item in order)\n        weighted_sum = sum((i + 1) * order[i][1] for i in range(len(order)))\n        return weighted_sum / total_weight if total_weight != 0 else float('inf')\n\n    def find_best_order(items):\n        from itertools import permutations\n\n        best_order = None\n        min_gravity = float('inf')\n\n        for perm in permutations(items):\n            if is_valid_stack(perm):\n                gravity = calculate_center_of_gravity(perm)\n                if gravity < min_gravity:\n                    min_gravity = gravity\n                    best_order = perm\n\n        return [item[0] for item in best_order]\n\n    datasets = input_data.strip().split('\\n')\n    index = 0\n    results = []\n\n    while datasets[index] != '0':\n        n = int(datasets[index])\n        index += 1\n        food_items = []\n\n        for _ in range(n):\n            f, w, s = datasets[index].split()\n            food_items.append((f, int(w), int(s)))\n            index += 1\n\n        result = find_best_order(food_items)\n        results.append(result)\n\n    return results\n\ninput_data = \"\"\"3\nBread 200 1500\nMilk 500 1500\nFruit 300 1000\n2\nBanana 200 700\nApple 100 600\n0\"\"\"\n\nfor result in solve_food_items(input_data):\n    print(\"\\n\".join(result))",
    "timestamp": "2025-08-12 23:47:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class FoodStacking {\n    static class FoodItem {\n        String name;\n        int weight;\n        int bearing;\n\n        FoodItem(String name, int weight, int bearing) {\n            this.name = name;\n            this.weight = weight;\n            this.bearing = bearing;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n\n            List<FoodItem> foodItems = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                String name = scanner.next();\n                int weight = scanner.nextInt();\n                int bearing = scanner.nextInt();\n                foodItems.add(new FoodItem(name, weight, bearing));\n            }\n\n            foodItems.sort((f1, f2) -> Double.compare(\n                (double) f2.bearing / f2.weight,\n                (double) f1.bearing / f1.weight));\n\n            List<FoodItem> resultStack = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int currentWeightTotal = foodItems.get(i).weight;\n                boolean canStack = true;\n                for (int j = resultStack.size() - 1; j >= 0; j--) {\n                    currentWeightTotal += resultStack.get(j).weight;\n                    if (resultStack.get(j).bearing < currentWeightTotal) {\n                        canStack = false;\n                        break;\n                    }\n                }\n                if (canStack) {\n                    resultStack.add(foodItems.get(i));\n                }\n            }\n\n            for (FoodItem item : resultStack) {\n                System.out.println(item.name);\n            }\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-12 23:47:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char name[21];\n    int weight;\n    int strength;\n} FoodItem;\n\nint cmp(const void *a, const void *b) {\n    FoodItem *item1 = (FoodItem *)a;\n    FoodItem *item2 = (FoodItem *)b;\n    return (item1->strength - item1->weight) - (item2->strength - item2->weight);\n}\n\nvoid findStackOrder(int n, FoodItem items[]) {\n    qsort(items, n, sizeof(FoodItem), cmp);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", items[i].name);\n    }\n}\n\nint main() {\n    int n;\n    FoodItem items[10];\n    \n    while (scanf(\"%d\", &n) && n != 0) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s %d %d\", items[i].name, &items[i].weight, &items[i].strength);\n        }\n        \n        findStackOrder(n, items);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-12 23:47:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef is_valid_stack(stack):\n    for i in range(len(stack)):\n        total_weight_above = sum(item[1] for item in stack[i+1:])\n        if stack[i][2] < total_weight_above:\n            return False\n    return True\n\ndef calculate_center_of_gravity(stack):\n    total_weight = sum(item[1] for item in stack)\n    weighted_sum = sum((j+1) * item[1] for j, item in enumerate(stack))\n    return weighted_sum / total_weight\n\ndef solve_food_stacking():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        food_items = []\n        for _ in range(n):\n            name, weight, capacity = input().split()\n            food_items.append((name, int(weight), int(capacity)))\n        \n        best_stack = None\n        min_gravity = float('inf')\n        \n        for perm in permutations(food_items):\n            if is_valid_stack(perm):\n                gravity = calculate_center_of_gravity(perm)\n                if gravity < min_gravity:\n                    min_gravity = gravity\n                    best_stack = perm\n        \n        if best_stack:\n            print(' '.join(item[0] for item in best_stack))\n\nsolve_food_stacking()",
    "timestamp": "2025-08-12 23:47:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read().split('\\n')\n    idx = 0\n    while True:\n        line = input[idx].strip()\n        idx += 1\n        if line == '0':\n            break\n        n = int(line)\n        items = []\n        for _ in range(n):\n            parts = input[idx].strip().split()\n            idx += 1\n            f, w, s = parts[0], int(parts[1]), int(parts[2])\n            items.append((f, w, s))\n        \n        # Generate all permutations and check validity\n        from itertools import permutations\n        best_order = None\n        min_g = float('inf')\n        \n        for perm in permutations(items):\n            valid = True\n            total_weight = 0\n            for i in range(len(perm)-1, -1, -1):\n                if i < len(perm)-1:\n                    if perm[i][2] < total_weight:\n                        valid = False\n                        break\n                total_weight += perm[i][1]\n            if valid:\n                # Calculate G\n                numerator = 0\n                denominator = 0\n                for i in range(len(perm)):\n                    numerator += (i+1) * perm[i][1]\n                    denominator += perm[i][1]\n                g = numerator / denominator\n                if g < min_g:\n                    min_g = g\n                    best_order = perm\n        # Output the best order\n        for item in best_order:\n            print(item[0])\n        # Print a blank line between datasets (as per problem statement examples)\n        print()\n\nsolve()",
    "timestamp": "2025-08-12 23:47:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstruct FoodItem {\n    std::string name;\n    int weight;\n    int strength;\n};\n\ndouble calculateCenterOfGravity(const std::vector<FoodItem> &items, const std::vector<int> &order) {\n    double totalWeight = 0;\n    double weightedSum = 0;\n    for (int i = 0; i < order.size(); ++i) {\n        totalWeight += items[order[i]].weight;\n        weightedSum += (i + 1) * items[order[i]].weight;\n    }\n    return weightedSum / totalWeight;\n}\n\nbool isValidOrder(const std::vector<FoodItem> &items, const std::vector<int> &order) {\n    int n = order.size();\n    for (int i = 0; i < n; ++i) {\n        int currentWeightSum = 0;\n        for (int j = i + 1; j < n; ++j) {\n            currentWeightSum += items[order[j]].weight;\n        }\n        if (items[order[i]].strength < currentWeightSum) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    while (true) {\n        int n;\n        std::cin >> n;\n        if (n == 0) break;\n        \n        std::vector<FoodItem> items(n);\n        for (int i = 0; i < n; ++i) {\n            std::cin >> items[i].name >> items[i].weight >> items[i].strength;\n        }\n        \n        std::vector<int> order(n);\n        for (int i = 0; i < n; ++i) {\n            order[i] = i;\n        }\n        \n        std::vector<int> bestOrder;\n        double bestCenterOfGravity = std::numeric_limits<double>::max();\n        \n        do {\n            if (isValidOrder(items, order)) {\n                double currentCenterOfGravity = calculateCenterOfGravity(items, order);\n                if (currentCenterOfGravity < bestCenterOfGravity) {\n                    bestCenterOfGravity = currentCenterOfGravity;\n                    bestOrder = order;\n                }\n            }\n        } while (std::next_permutation(order.begin(), order.end()));\n        \n        for (int idx : bestOrder) {\n            std::cout << items[idx].name << \" \";\n        }\n        std::cout << '\\n';\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:51:24"
  }
]