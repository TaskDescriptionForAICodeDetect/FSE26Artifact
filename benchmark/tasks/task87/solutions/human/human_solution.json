[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<climits>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\nstruct food{\n    string name;\n    int weight;\n    int ue;\n    int id;\n};\nstruct com\n{\n    inline bool operator() (const food& f1, const food& f2){\n        return (f1.id > f2.id);\n    }\n};\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<food>vec,v;\n        int totWeight=0;\n        for(int i=0;i<n;i++){\n            food f;\n            cin>>f.name>>f.weight>>f.ue;\n            f.id=i;\n            totWeight += f.weight;\n            vec.push_back(f);\n            v.push_back(f);\n        }\n        sort(vec.begin(),vec.end(),com());\n        vector<pair<double,vector<int> > >ve;\n        do{\n            bool ok=true;\n            int tot=0;\n            for(int i=n-1;i>=0;i--){\n                if(tot>vec[i].ue){\n                    ok=false;\n                    break;\n                }\n                tot+=vec[i].weight;\n            }\n            if(ok){\n                double x=0;\n                for(int i=0;i<n;i++){\n                    x+=(n-i)*vec[i].weight;\n                }\n                x/=totWeight;\n                vector<int>ids;\n                for(int i=0;i<n;i++){\n                    ids.push_back(vec[i].id);\n                }\n                ve.push_back(make_pair(x, ids));\n            }\n        } while(next_permutation(vec.begin(), vec.end(), com()));\n        sort(ve.begin(),ve.end());\n        for(int i=0;i<n;i++){\n            cout<<v[ve[ve.size()-1].second[i]].name<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint n,sum,ret;\n\tint info[10][10];\n\tvector<int> data;\n\twhile(cin >> n && n){\n\t\tdata.clear();\n\t\trep(i,n)data.push_back(i);\n\t\trep(i,10)rep(j,10)info[i][j] = 0\t;\n\t\trep(i,n)rep(j,n){\n\t\t\tcin >> info[i][j];\n\t\t\tinfo[j][i] = info[i][j] = max(info[i][j],info[j][i]);\n\t\t}\n\t\trep(i,n){\n\t\t\trep(j,n)cout << info[i][j] << \" \"\t;\n\t\t\tcout << endl;\n\t\t}\n\t\tret = INT_MAX;\n\t\tdo{\n\t\t\tsum = 0;\n\t\t\tfor(int i=0;i+1<n;i++){\n\t\t\t\tfor(int i=0;i\n\t\t\t\tsum += info[data[i]][data[i+1]];\n\t\t\t}\n\t\t\tcout << \"(\"<< data[n-1] << \") = \" << sum << endl;\n\t\t\tret = min(ret,sum);\n\t\t}while(next_permutation(data.begin(),data.end()));\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> bool chmin(T &a, T b) {\n    if(a > b) {\n        a = min(a, b);\n        return true;\n    }\n    else return false;\n}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n \nstruct Elem {\n    string name;\n    int weight, limit;\n};\n\nint dp[1 << 11];\nvector<string> vec[1 << 11];\n\nsigned main() {\n    int N;\n    while(cin >> N, N) {\n        vector<Elem> elems;\n        for(int i=0; i<N; i++) {\n            string name; int weight, limit;\n            cin >> name >> weight >> limit;\n            elems.push_back(Elem{name, weight, limit});\n        }\n\n        fill(dp, dp + (1<<N), INF);\n        dp[0] = 0;\n\n        for(int bit=0; bit<(1<<N); bit++) {\n            int coeff = N - __builtin_popcount(bit);\n            int sum = 0;\n            for(int i=0; i<N; i++) {\n                if(bit >> i & 1) sum += elems[i].weight;\n            }\n            for(int i=0; i<N; i++) {\n                if((bit >> i & 1) or (sum > elems[i].limit)) continue;\n                int nbit = bit | (1 << i);\n                if(chmin(dp[nbit], dp[bit] + coeff * elems[i].weight)) {\n                    vec[nbit] = vec[bit];\n                    vec[nbit].push_back(elems[i].name);\n                }\n            }\n        }\n\n        vector<string> ans = vec[(1<<N) - 1];\n        reverse(ans.begin(), ans.end());\n        for(int i=0; i<ans.size(); i++) {\n            cout << ans[i] << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nstruct food {\n\tstring name;\n\tint w;\n\tint s;\n};\nint N;\nvector<food>fs;\npair<int,vector<string>> memo[1024];\n\npair<int,vector<string>> getans(bitset<10>&used,int num,int sum) {\n\tif (memo[used.to_ulong()].first != -1) {\n\t\treturn memo[used.to_ulong()];\n\t}\n\telse {\n\t\tif (used.count() == N)return make_pair(0, vector<string>());\n\t\telse {\n\t\t\tpair<int, vector<string>>ans(int(1e8), vector<string>());\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (!used[i]&&fs[i].s>=sum) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tconst int nextsum = sum + fs[i].w;\n\t\t\t\t\tvector<string>nans;\n\t\t\t\t\tauto p = getans(used, num + 1, nextsum);\n\t\t\t\t\tp.first += (N-num)*fs[i].w;\n\t\t\t\t\tp.second.push_back(fs[i].name);\n\t\t\t\t\tif (p.first < ans.first) {\n\t\t\t\t\t\tans = p;\n\t\t\t\t\t}\n\t\t\t\t\tused[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[used.to_ulong()] = ans;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 1024; ++i) {\n\t\t\tmemo[i] = make_pair(-1,vector<string>(1,\" \"));\n\t\t}\n\t\tcin >> N;\n\t\tif (!N)break;\n\t\tfs.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring name; int w, s; cin >> name >> w >> s;\n\t\t\tfs.push_back(food{ name,w,s });\n\t\t}\n\t\tbitset<10>used;\n\t\tauto ans = getans(used, 0, 0);\n\t\tfor (auto n : ans.second) {\n\t\t\tcout << n << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require sqrt ceil floor\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <stdint.h>\t// require uint64_t\n#include <fstream>\t// require freopen\n\nusing namespace std;\n\ntypedef pair <pair<int, int>, string > ITEM;\t// ACeÌd³AACeÌãÉu¯éd³ÌãÀAACe¼\n\nvector <ITEM> list;\nint N;\nvector <vector <int> > order;\n\nint calcG (map <int, int> item )\n{\n\tint res = 0;\n\n\tfor (int i = 0; i < N; ++i ){\n\t\tres += (i+1)*(list[item[i]].first.first) ;\n\t} // end for\n\n\treturn res;\n}\n\nvoid dfs (vector <int> & used, int depth )\n{\n\tif (depth >= N ){\n\t\torder.push_back(used );\n\t\treturn;\n\t} // end if\n\n\tfor (int i = 0; i < N; ++i ){\n\t\tif (used[i] == -1 ){\n\t\t\tused[i] = depth;\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < N; ++j ){\n\t\t\t\tif (j != i && used[j] == -1 ){\t \n\t\t\t\t\tsum += list[j].first.first;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t\tif (sum <= list[i].first.second ){\n\t\t\t\tdfs (used, depth + 1 );\n\t\t\t} // end if\n\t\t\tused[i] = -1;\n\t\t} // end if\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.lunch\", \"r\", stdin );\n\tint n;\n\n\twhile (cin >> n && n ){\n\t\tN = n;\n\t\torder.clear();\n\t\tlist.clear();\n\t\tlist.resize(n);\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> list[i].second;\n\t\t\tcin >> list[i].first.first;\t// w\n\t\t\tcin >> list[i].first.second;\t// s \n\t\t} // end for\n\n\t\tvector <int> used (n, -1 );\n\n\t\tdfs (used, 0 );\n\n\t\tmultimap <int, map <int, int> > rank;\n\t\tfor (int i = 0; i < order.size(); ++i ){\n\t\t\tmap <int, int> packed;\n\t\t\tfor (int j = 0; j < order[i].size(); ++j ){\n\t\t\t\tpacked[order[i][j]] = j;\n\t\t\t} // end for\n\t\t\tdouble G = calcG (packed );\n\t\t\trank.insert (make_pair (G, packed ) );\n\t\t} // end for\n\n\t\tmultimap <int, map<int, int> >::iterator it = rank.begin();\n\t\tmap <int, int> res = (*it).second;\n\t\tmap <int, int>::iterator jt = res.begin();\n\n\t\tfor (; jt != res.end(); ++jt ){\n\t\t\tcout << list[(*jt).second].second << endl;\n\t\t} // end for\n\n\t} // end while\n\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double inf = 1e10;\n\nint main() {\n  for(int n; cin >> n, n;) {\n    string f[n];\n    int w[n], s[n];\n    for(int i = 0; i < n; ++i) {\n      cin >> f[i] >> w[i] >> s[i];\n    }\n    vector<int> t(n), ans;\n    for(int i = 0; i < n; ++i) t[i] = i;\n    double minG = inf;\n    do {\n      try {\n        for(int i = n-1, sumw = 0; i >= 0; --i) {\n          if(s[t[i]] >= sumw); else throw 0;\n          sumw += w[t[i]];\n        }\n        double G = 0;\n        int a = 0, b = 0;\n        for(int i = 0; i < n; ++i) {\n          a += (i+1) * w[t[i]];\n          b += w[t[i]];\n        }\n        G = (double)a/(double)b;\n        if(G < minG) {\n          ans = t;\n          minG = G;\n        }\n      } catch(...) {}\n    } while(next_permutation(t.begin(),t.end()));\n\n    for(int i = 0; i < n; ++i) {\n      cout << f[ans[i]] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \n#include <sstream>\nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n#define ll long long int\n#define gcd(a,b) __gcd(a,b)\n\nint GCD(int a, int b) {if(!b) return a; return gcd(b, a%b);}\nint lcm(int a, int b) {return a*b / gcd(a, b);}\n\nstruct food{\n  string fn;\n  int g;\n  int s;\n};\nint f[10],an[10],m;\nfood fd[10],sf;\nint ans(int n,int s){\n  if(n==-1){\n    for(int i = m - 1 ; i >= 0 ; i --)\n      cout << fd[an[i]].fn << endl; \n      return 1;\n  }\n for (int i=m-1;i>=0;i--) {\n        if (f[i]==0 && fd[i].s>=s-fd[i].g) {\n            f[i]=1; an[n]=i;\n            if (ans(n-1,s-fd[i].g)==1) return 1; \n            f[i]=0;\n        }\n  }\n  return 0;\n}\n\nint main(void){\n  int i,j,s;\n  while(cin >> m){\n    if (m==0)break;\n    for(i = 0 , s = 0 ; i < m ; i ++){\n      f[i] = 0 ; \n      cin >> fd[i].fn >> fd[i].g >> fd[i].s;\n      s+=fd[i].g;\n    }\n    for(i = 1 ; i < m ; i ++){\n      for(j = 0  ; j < m - i ; j ++){\n\tif(fd[j].g>fd[j+1].g){\n\t  sf=fd[j];\n\t  fd[j] = fd[j+1];\n\t  fd[j+1] = sf;\n\t}\n      }\n    }\n    ans(m-1,s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\nusing namespace std;\nint n, w[1000], s[1000];\nstring S[1000]; vector<int>b; int maxn;\nint main() {\n\twhile (true) {\n\t\tcin >> n; b.clear(); maxn = 1 << 30;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> S[i] >> w[i] >> s[i];\n\t\t}\n\t\tvector<int>a(n, 0);\n\t\tfor (int i = 0; i < n; i++)a[i] = i;\n\t\tdo {\n\t\t\tint sum2 = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tsum += w[a[j]];\n\t\t\t\t}\n\t\t\t\tif (sum > s[a[i]]) goto E;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)sum2 += i*w[a[i]];\n\t\t\tif (maxn > sum2)b = a;\n\t\tE:;\n\t\t} while (next_permutation(a.begin(), a.end()));\n\t\tfor (int i = 0; i < n; i++)cout << S[b[i]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \n#include <sstream>\nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n#define ll long long int\n#define gcd(a,b) __gcd(a,b)\n\nint GCD(int a, int b) {if(!b) return a; return gcd(b, a%b);}\nint lcm(int a, int b) {return a*b / gcd(a, b);}\n\nstruct food{\n  string fn;\n  int g;\n  int s;\n};\nint f[10],an[10],m;\nfood fd[10],sf;\nint ans(int n,int s){\n  if(n==-1){\n    for(int i = m - 1 ; i >= 0 ; i --){\n      cout << fd[an[i]].fn << endl; \n      return 1;\n    }\n  }\n  for(int i = m - 1 ; i >= 0 ; i --){\n    if(f[i] == 0 && fd[i].s >= s-fd[i].g){\n      f[i] = 1; an[n] = i;\n      if(ans(n-1,s-fd[i].g)==1)return 1;\n      f[i] = 0;\n    }\n  }\n  return 0;\n}\n\nint main(void){\n  int i,j,s;\n  while(cin>>m){\n    if(m==0)break;\n    for(i = 0 , s = 0 ; i < m ; i ++){\n      f[i] = 0 ; \n      cin>>fd[i].fn>>fd[i].g>>fd[i].s;\n      s+=fd[i].g;\n    }\n    for(i = 1 ; i < m ; i ++){\n      for(j = 0  ; j < m - i ; j ++){\n\tif(fd[j].g>fd[j+1].g){\n\t  sf=fd[j];\n\t  fd[j] = fd[j+1];\n\t  fd[j+1] = sf;\n\t}\n      }\n    }\n    ans(m-1,s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,a,tmp;\nint s[10],w[10];\nstring f[10],temp;\nint t[10];\nvector<int>ans;\n\nint get_weight(int);\nvoid swap_data(int);\nvoid sort_data();\n\nint main(){\n  while(cin>>n&&n!=0){\n    ans.clear();\n    for(int i=0;i<n;i++){\n      cin>>f[i];\n      cin>>w[i]>>s[i];\n    }    \n    sort_data();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n-1;j++){\n\tif(w[j]<w[j+1]){\n\t  swap_data(j);\n\t  a=get_weight(j+1);\n\t  if(a>s[j])swap_data(j);\n\t}\n      }\n    }\n    for(int i=0;i<n;i++)cout<<f[i]<<endl;\n  }\n  return 0;\n}\n\nint get_weight(int x){\n  int res=0;\n  for(int i=x;i<n;i++)res+=w[i];\n  return res;\n}\n\nvoid swap_data(int x){\n  tmp=w[x];\n  w[x]=w[x+1];\n  w[x+1]=tmp;\n\n  tmp=s[x];\n  s[x]=s[x+1];\n  s[x+1]=tmp;\n\n  temp=f[x];\n  f[x]=f[x+1];\n  f[x+1]=temp;\n}\n\nvoid sort_data(){\n  for(int i=n-1;i>0;i--){\n    for(int j=0;j<i;j++){\n      if(s[j]<s[j+1])swap_data(j);\n      else if(s[j]==s[j+1]&&w[j]<w[j+1])swap_data(j);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < ((k)+(n)); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\nostream &operator<<(ostream &os, const pair<int,int> &p){return(os<<\"(\"<<p.first<<\",\"<<p.second<<\")\");}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nstruct obj {\n    string f;\n    int w, s;\n    obj(string _f, int _w, int _s) : f(_f),w(_w),s(_s){ }\n};\n\n\nvoid dfs(vector<obj> &v, int used, int n, int tw, vector<int> &lst, vector<int> &mn, int &mng){\n    if(used == (1<<n)-1){\n        int g = 0, k = 1;\n        FOREACH(it,lst) g += v[*it].w * k++;\n        if(mng > g){\n            mng = g; mn = lst;\n        }\n        return;\n    }\n    REP(i,n){\n        if(used & (1<<i)) continue;\n        if(tw-v[i].w > v[i].s) continue;\n        lst.pb(i);\n        dfs(v,used | (1<<i), n, tw-v[i].w,lst,mn,mng);\n        lst.pop_back();\n    }\n}\n\nint solve(vector<obj> &v){\n    int n = v.size();\n    int tw = 0;\n    vector<int> lst, mn;\n    int mng = INT_MAX;\n\n    REP(i,n) tw += v[i].w;\n    dfs(v,0,n,tw,lst,mn,mng);\n    FOREACH(it,mn) cout << v[*it].f << endl;\n    return 0;\n}\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        string f; int w, s;\n        vector<obj> v;\n        REP(i,n){\n            cin >> f >> w >> s;\n            v.pb(obj(f,w,s));\n        }\n        solve(v);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring f[11];\nint ans[11];\nint n;\nint w[11],s[11];\n\nvoid solve(){\n\tfor(int i=1; i<=n; i++)\n\t\tans[i] = i;\n\tfor(int k=1; k<=n; k++){\n\t\tfor(int i=n; i>k; i--){\n\t\t\tif(s[ans[i]] > s[ans[i-1]]){\n\t\t\t\tint tmp = ans[i];\n\t\t\t\tans[i] = ans[i-1];\n\t\t\t\tans[i-1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\tbool flag = true;\n\tfor(int i=1; i<=n; i++){\n\t\tif(i==n&&flag)\n\t\t\ti=1;\n\t\telse if(i==n)\n\t\t\tbreak;\n\t\tif(w[ans[i]] < w[ans[i+1]]){\n\t\t\tint tmp = w[ans[i]];\n\t\t\tfor(int k=i+2; k<=n; k++)\n\t\t\t\ttmp += w[ans[k]];\n\t\t\tif(s[ans[i+1]] >= tmp){\n\t\t\t\ttmp = ans[i];\n\t\t\t\tans[i] = ans[i+1];\n\t\t\t\tans[i+1] = tmp;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcin >> f[i] >> w[i] >> s[i];\n\t\tsolve();\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcout << f[ans[i]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define lint long long\n#define P pair<int, int>\n#define LLP pair<long long, long long>\n#define REP(i, x, n) for(int i = (x), i##_len = (int)(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = (int)(n) ; i < i##_len ; ++i)\n#define repr(i, n) for(int i = (int)(n) - 1 ; i >= 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n\nconst int IINF = 1e9 + 10;\nconst long long LLINF = (long long)1e18 + 10;\nconst long long MOD = (long long)1e9 + 7;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin >> n, n){\n\n        vector<int> p(n);\n        rep(i, n){\n            p[i] = i;\n        }\n\n        vector<string> f(n);\n        vector<lint> w(n), s(n);\n        rep(i, n){\n            cin >> f[i] >> w[i] >> s[i];\n        }\n\n        vector<int> ans;\n        lint mini = 1000000000000LL;\n\n        do{\n\n            bool flag = true;\n            lint g = 0, cnt = 0;\n\n            rep(i, n){\n                flag &= cnt <= s[p[i]];\n                cnt += w[p[i]];\n                g += (lint)(n - i) * w[p[i]];\n            }\n\n            if(flag && mini > g){\n                ans = p;\n                mini = g;\n            }\n\n        }while(next_permutation(p.begin(), p.end()));\n\n        repr(i, n){\n            cout << f[ans[i]] << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f));\n\t\tsort(items.begin(),items.end());\n\t\tS=99999;\n\t\tdo{\n\t\t\tfor(s=w=i=0;i<n;i++){\n\t\t\t\tif(items[i].first.second<w)break;\n\t\t\t\tw+=items[i].first.first;\n\t\t\t\ts+=(n-i)*items[i].first.first;\n\t\t\t}\n\t\t\tif(i==n&&s<S)S=s,result=items;\n\t\t}while(next_permutation(items.begin(),items.end()));\n\t\treverse(result.begin(),result.end());\n\t\tfor(i=0;i<n;i++)cout<<result[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nstruct lunch{\n  int w,s;\n  char name[21];\n\n  bool operator < (const lunch &l)const{\n    if(w != l.w){\n      return w < l.w;\n    }else{\n      return s < l.s;\n    }\n  }\n};\n\nlunch N[10],ans[10];\nint n;\n\nvoid make(){\n  for(int i = 0 ; i < n ; i++){\n    ans[i] = N[i];\n  }\n}\n\nbool check(int &G){\n  int Ws1 = 0,Ws2 = 0;\n  for(int i = n-1 ; i >= 0 ; i--){\n    if(N[i].s < Ws2) return false;\n    Ws1 += (i+1)*N[i].w;\n    Ws2 += N[i].w;\n  }\n  G = Ws1 / Ws2;\n\n  return true;\n}\n\nint main(){\n  while(scanf(\"%d\" ,&n) ,n){\n    for(int i = 0 ; i < n ; i++){\n      scanf(\"%s %d %d\" ,N[i].name ,&N[i].w ,&N[i].s);\n    }\n    sort(N,N+n);\n\n    int G = 0,t;\n\n    do{\n      if(check(t)){\n\tif(G <= t){\n\t  make();\n\t  G = t;\n\t}\n      }\n    }while(next_permutation(N,N+n));\n\n    for(int i = 0 ; i < n ; i++){\n      printf(\"%s\\n\" ,ans[i].name);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> choice;\nstring name[10];\nint weight[10];\nint s[10];\nbool done[10];\nint n;\npair<double,vector<int> > ret;\nvoid bt(){\n\tint test;\n\tfor(int i=0;i<choice.size();i++){\n\t\ttest = 0;\n\t\tfor(int j=i+1;j<choice.size();j++){\n\t\t\ttest+=weight[choice[j]];\n\t\t}\n\t\tif(s[choice[i]] < test)return;\n\t}\n\tif(choice.size() == n){\n\t\tdouble G=0,DIV=0;\t\n\t\tfor(int i=0;i<choice.size();i++){\n\t\t\tG += (i+1)*weight[choice[i]];\n\t\t\tDIV += weight[choice[i]];\n\t\t}\n\t\tret = min(ret,make_pair(G/DIV,choice));\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(!done[i]){\n\t\t\tdone[i] = true;\n\t\t\tchoice.push_back(i);\n\t\t\tbt();\n\t\t\tdone[i] = false;\n\t\t\tchoice.pop_back();\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\tret = make_pair(1<<21,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> name[i] >> weight[i] >> s[i];\n\t\t}\n\t\tbt();\n\t\tfor(int i=0;i<ret.second.size();i++){\n\t\t\tcout << name[ret.second[i]] << endl;\n\t\t}\n\t}\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tint w[10],s[10],dp[1 << 10][10],prev[1 << 10][10][2];\n\t\tstring f[10];\n\t\tfor(int i = 0;i < (1 << n);i++){\n\t\t\tfor(int j = 0;j < n;j++) dp[i][j] = INF;\n\t\t}\n\t\tfor(int i = 0;i < n;i++) dp[0][i] = 0;\n\t\tfor(int i = 0;i < n;i++) cin >> f[i] >> w[i] >> s[i];\n\t\tfor(int i = 1;i < (1 << n);i++){\n\t\t\tint sum = 0,cnt = 0;\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif((i >> j) & 1) {\n\t\t\t\t\tsum += w[j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(((i >> j) & 1) && s[j] >= sum - w[j]){\n\t\t\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\t\t\tif(dp[i & ~(1 << j)][k] + (n - cnt + 1) * w[j] < dp[i][j]){\n\t\t\t\t\t\t\tdp[i][j] = dp[i & ~(1 << j)][k] + (n - cnt + 1) * w[j];\n\t\t\t\t\t\t\tprev[i][j][0] = i & ~(1 << j);\n\t\t\t\t\t\t\tprev[i][j][1] = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF,mix;\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tif(mi > dp[(1 << n) - 1][i]){\n\t\t\t\tmi = dp[(1 << n) - 1][i];\n\t\t\t\tmix = i;\n\t\t\t}\n\t\t}\n\t\tcout << f[mix] << endl;\n\t\tint pos = (1 << n) - 1;\n\t\tfor(int i = 0;i < n - 1;i++){\n\t\t\tcout << f[prev[pos][mix][1]] << endl;\n\t\t\tint p = prev[pos][mix][0];\n\t\t\tmix = prev[pos][mix][1];\n\t\t\tpos = p;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct Food{\n  string name;\n  int weight, durability;\n};\n\nint n, minG;\nFood bag[11];\nint order[11], bestOrder[11];\nbool used[11];\n\nvoid dfs(int selectedNum, int totalWeight, int numerG){\n  if(selectedNum != 0 && numerG > minG) return;\n\n  if(selectedNum == n){\n    if(numerG < minG){\n      minG = numerG;\n      for(int i = 1; i <= n; i++) bestOrder[i] = order[i];\n    }\n    return;\n  }\n\n  for(int i = 1; i <= n; i++){\n    if(!used[i] && bag[i].durability >= totalWeight){\n      used[i] = true;\n      order[selectedNum + 1] = i;\n      dfs(selectedNum + 1, totalWeight + bag[i].weight, numerG + (n - selectedNum) * bag[i].weight);\n      used[i] = false;\n    }\n  }\n}\n\nint main(void){\n  while(cin >> n && n != 0){\n    minG = INT_MAX;\n    for(int i = 1; i <= n; i++){\n      cin >> bag[i].name >> bag[i].weight >> bag[i].durability;\n      used[i] = false;\n    }\n    dfs(0, 0, 0);\n    for(int i = n; i >= 1; i--) cout << bag[bestOrder[i]].name << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cfloat>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nstruct Food{\n\tstring name;\n\tint w;\n\tint s;\n\tint id;\n\tFood(string name, int w, int s, int id): name(name), w(w), s(s), id(id) {};\n\n\tbool operator<(const Food& rhs) const{\n\t\treturn id < rhs.id;\n\t}\n};\n\ndouble calc(vector<Food> foods){\n\tint length= foods.size();\n\tint sum = 0;\n\tfor(int i = length - 1; i >= 0; --i){\n\t\tint s = foods[i].s;\n\t\tif(s < sum) return DBL_MAX;\n\t\tsum += foods[i].w;\n\t}\n\tdouble d = 0, n = 0;\n\tREP(i, length){\n\t\tn += (i + 1) * foods[i].w;\n\t\td +=foods[i].w;\n\t}\n\treturn n / d;\n}\n\nint main(int argc, char const *argv[])\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tvector<Food> ans;\n\twhile(cin >> n, n){\n\t\tvector<Food> foods;\n\t\tfoods.reserve(n);\n\t\tstring name;\n\t\tint w, s;\n\t\tREP(i, n){\n\t\t\tcin >> name >> w >> s;\n\t\t\tfoods.emplace_back(name, w, s, i);\n\t\t}\n\t\tdouble min = DBL_MAX;\n\t\tdo{\n\t\t\tdouble value = calc(foods);\n\t\t\tif(min > value){\n\t\t\t\tmin = value;\n\t\t\t\tans = foods;\n\t\t\t}\n\t\t}while(next_permutation(foods.begin(), foods.end()));\n\t\tREP(i, n)\n\t\t\tcout << ans[i].name << endl;\n\t};\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct Tag {\n    string f;\n    int w, s;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        vector<Tag> foods(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> foods[i].f >> foods[i].w >> foods[i].s;\n        }\n        vector<int> order(N);\n        for(int i = 0; i < N; ++i) {\n            order[i] = i;\n        }\n        vector<int> best_ans;\n        double best_G = 1e30;\n        do {\n            int sum_w = 0;\n            int sum_gw = 0;\n            bool ok = true;\n            for(int i = N-1; i >= 0; --i) {\n                if(sum_w > foods[order[i]].s) {\n                    ok = false;\n                    break;\n                }\n                sum_w += foods[order[i]].w;\n                sum_gw += foods[order[i]].w * (i+1);\n            }\n            if(ok) {\n                double G = static_cast<double>(sum_gw) / sum_w;\n                if(G < best_G) {\n                    best_ans = order;\n                    best_G = G;\n                }\n            }\n        } while(next_permutation(order.begin(), order.end()));\n        for(int i = 0; i < N; ++i) {\n            cout << foods[best_ans[i]].f << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef pair<int,string> P;\ntypedef pair<int,P> PP;\n\nint n,a;\nPP in[10],tmp;\nint t[10];\nvector<int>ans;\n\nint get_weight(int);\n\nint main(){\n  while(cin>>n&&n!=0){\n    ans.clear();\n    for(int i=0;i<n;i++)cin>>in[i].second.second>>in[i].second.first>>in[i].first;\n    sort(in,in+n);\n\n    for(int i=n-1;i>=0;i--){\n      for(int j=0;j<i;j++){\n\ta=get_weight(j)+in[j+1].second.first;\n\tif(a<=in[j].first&&in[j].second.first>in[j+1].second.first){\n\t  tmp=in[j];in[j]=in[j+1];in[j+1]=tmp;\n\t}\n\t\nelse if(a<=in[j].first&&(in[j].second.first==in[j+1].second.first&&in[j].first>=in[j+1].first)){\n\t  tmp=in[j];in[j]=in[j+1];in[j+1]=tmp;\n\t}\n\t\n      }\n    }\n    \n    for(int i=n-1;i>=0;i--)cout<<in[i].second.second<<endl;\n    \n    \n  }\n  return 0;\n}\n\nint get_weight(int x){\n  int res=0;\n  for(int i=0;i<x;i++)res+=in[i].second.first;\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    string name[N];\n    int weight[N], strength[N];\n    \n    for(int i=0; i<N; i++)\n      cin >> name[i] >> weight[i] >> strength[i];\n    \n    int per[N]; for(int i=0; i<N; i++) per[i] = i;\n    int save[N]; for(int i=0; i<N; i++) save[i] = i;\n    \n    int mx = 0;\n    int mxG = 0;\n    \n    do {\n      \n      int sum_weight = weight[per[0]];\n      int G = weight[per[0]];\n      bool ok = 1;\n      for(int i=1; i<N; i++) {\n\tif(sum_weight <= strength[per[i]]) {\n\t  sum_weight += weight[per[i]];\n\t  G += (i+1)*weight[per[i]];\n\t}\n\telse {\n\t  ok = 0; break;\n\t}\n      }\n      \n      if(ok) {\n\tif(G > mxG) {\n\t  mxG = G;\n\t  for(int i=0; i<N; i++) save[i] = per[i];\n\t}\n      }\n      \n    } while(next_permutation(per, per+N));\n    \n    for(int i=N-1; i>=0; i--) {\n      cout << name[save[i]] << endl;\n    }\n    \n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f));\n\t\tsort(items.begin(),items.end());\n\t\tS=999999999;\n\t\tdo{\n\t\t\tfor(s=w=i=0;i<n;i++){ //from upper\n\t\t\t\tif(items[i].first.second<w)break;\n\t\t\t\tw+=items[i].first.first;\n\t\t\t\ts+=(n-i)*items[i].first.first;\n\t\t\t}\n\t\t\tif(i==n&&s<S)cout<<s<<endl,S=s,result=items;\n\t\t}while(next_permutation(items.begin(),items.end()));\n\t\treverse(result.begin(),result.end());\n\t\tfor(i=0;i<n;i++)cout<<result[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst double EPS = 1e-6;\n\nint main(void) {\n\tint N;\n\twhile (cin >> N, N) {;\n\t\tvector<string> F(N);\n\t\tVI W(N), S(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> F[i] >> W[i] >> S[i];\n\t\t}\n\n\t\tVI p(N);\n\t\tiota(p.begin(), p.end(), 0);\n\n\t\tdouble ans = 1e+8;\n\t\tVI best_p(p.begin(), p.end());\n\n\t\tdo {\n\t\t\tdouble g = 0, gt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg += (i + 1) * W[p[i]];\n\t\t\t\tgt += W[p[i]];\n\t\t\t}\n\t\t\tg /= gt;\n\n\t\t\tint total = 0;\n\t\t\tbool flg = true;\n\t\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\t\tflg &= total <= S[p[i]];\n\t\t\t\ttotal += W[p[i]];\n\t\t\t}\n\n\t\t\tif (flg && g < ans + EPS) {\n\t\t\t\tans = g;\n\t\t\t\tswap(best_p, p);\n\t\t\t}\n\t\t} while (next_permutation(p.begin(), p.end()));\n\n\t\tfor (auto i : best_p) {\n\t\t\tcout << F[i] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nint main(){\n\tstring str;\n\tint n, s, w, sum=0;\n\twhile(cin >> n, n) {\n\t\tvector<pair<int, pair<int, string> > > v;\n\t\trep(i,n) {\n\t\t\tcin >> str >> w >> s;\n\t\t\tv.push_back(make_pair(w, make_pair(s, str)));\n\t\t\tsum += w;\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tvector<string> ret;\n\t\twhile(!v.empty()) {\n\t\t\tfor(int i = v.size()-1; i>=0; --i) {\n\t\t\t\tif(sum - v[i].first <= v[i].second.first) {\n\t\t\t\t\tret.push_back(v[i].second.second);\n\t\t\t\t\tcout << v[i].second.second << endl;\n\t\t\t\t\tsum -= v[i].first;\n\t\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\ntypedef pair <string, II> NODE;\ntypedef vector <NODE> NODES;\n\nvoid solve( int n, NODES nodes ) {\n    int ming = INT_MAX;\n    VS L;\n    sort( nodes.rbegin(), nodes.rend() );\n    do {\n        int wsum = 0, g = 0;\n        for ( int i = 0; i < n; ++ i ) {\n            if ( wsum > nodes[i].second.second ) goto out_1;\n            wsum += nodes[i].second.first;\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            g += ( n - i ) * nodes[i].second.first;\n            if ( g >= ming ) goto out_1;\n        }\n        if ( g < ming ) {\n            ming = g;\n            VS T;\n            for ( int i = 0; i < n; ++ i ) {\n                T.push_back( nodes[i].first );\n            }\n            L = T;\n        }\n    out_1:;\n    } while ( next_permutation( nodes.rbegin(), nodes.rend() ) );\n\n    reverse( L.begin(), L.end() );\n    for ( int i = 0; i < n; ++ i ) {\n        cout << L[i] << endl;\n    }\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        NODES nodes( n );\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> nodes[i].first >> nodes[i].second.first >> nodes[i].second.second;\n        }\n        solve( n, nodes );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct item\n{\n\tstring str;\n\tint w,s;\n};\nitem it[11];\nint n;\nvector<int> ans,curr;\ndouble G,tmpg;\nbool used[10];\nvoid dfs(int x){\n\tint tmp =0;\n\tfor(int i =curr.size()-1;i >=0;i--){\n\t\tif(tmp >it[curr[i]].s)return;\n\t\ttmp +=it[curr[i]].w;\n\t}\n\tif(curr.size()==n){\n\t\tif(tmpg<G){\n\t\t\tG =tmpg;\n\t\t\tans =curr;\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i =0;i <n;i++){\n\t\tif(!used[i]){\n\t\t\tused[i]=true;\n\t\t\tcurr.push_back(i);\n\t\t\ttmpg +=(x*it[i].w);\n\t\t\tdfs(x+1);\n\t\t\ttmpg -=(x*it[i].w);\n\t\t\tcurr.pop_back();\n\t\t\tused[i]=false;\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main(){\n\twhile(cin>>n,n){\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcin>>it[i].str>>it[i].w>>it[i].s;\n\t\t}\n\t\tG =INF;\n\t\ttmpg = 0;\n\t\tdfs(1);\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcout <<it[ans[i]].str<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint n;\nvi w, s;\nvi array;\n\nint best;\nvi bestarray;\n\nvoid solve(int g, int st, int k)\n{\n\tif(g >= best)\n\t\treturn;\n\t\n\tif(k == n){\n\t\tbest = g;\n\t\tbestarray = array;\n\t\treturn;\n\t}\n\t\n\treep(i, k, n){\n\t\tif(st >= w[array[i]]){\n\t\t\tswap(array[k], array[i]);\n\t\t\tsolve(g+(k+1)*w[array[k]], min(st-w[array[k]], s[array[k]]), k+1);\n\t\t\tswap(array[k], array[i]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<string> f(n);\n\t\tw.resize(n);\n\t\ts.resize(n);\n\t\trep(i, n){\n\t\t\tchar name[32];\n\t\t\tscanf(\"%s%d%d\", name, &w[i], &s[i]);\n\t\t\tf[i] = name;\n\t\t}\n\t\t\n\t\tbest = 100000000;\n\t\tarray.resize(n);\n\t\trep(i, n)\n\t\t\tarray[i] = i;\n\t\tsolve(0, 10000000, 0);\n\t\trep(i, n){\n\t\t\tputs(f[bestarray[i]].c_str());\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\nusing namespace std;\nint n, w[1000], s[1000];\nstring S[1000]; vector<int>b; int maxn;\nint main() {\n\twhile (true) {\n\t\tcin >> n; b.clear(); maxn = 1 << 30;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> S[i] >> w[i] >> s[i];\n\t\t}\n\t\tvector<int>a(n, 0);\n\t\tfor (int i = 0; i < n; i++)a[i] = i;\n\t\tdo {\n\t\t\tint sum2 = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tsum += w[a[j]];\n\t\t\t\t}\n\t\t\t\tif (sum > s[a[i]]) goto E;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tsum2 += i*w[a[i]]; maxn = sum2;\n\t\t\t}\n\t\t\tif (maxn > sum2)b = a;\n\t\tE:;\n\t\t} while (next_permutation(a.begin(), a.end()));\n\t\tfor (int i = 0; i < n; i++) { cout << S[b[i]] << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define MAX_N 1000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nstruct FOOD{\n\tstring name;\n\tint w;\n\tint s;\n};\n\nbool checkWeight(const struct FOOD* food,const int* table,int n){\n\t\n\tint sum=0;\n\tfor(int i=n-1,j=n-2;i>=1,j>=0;i--,j--){\n\t\tsum += food[table[i]].w;\n\t\tif(food[table[j]].s < sum) return false;\n\t}\n\n\treturn true;\n}\n\ndouble getG(const struct FOOD* food,const int* table,int n){\n\n\tdouble G=0;\n\tdouble sum=0;\n\tfor(int i=0;i<n;i++){\n\t\tG += (double)food[table[i]].w * (i+1);\n\t\tsum += (double)food[table[i]].w;\n\t}\n\treturn G / sum;\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tstruct FOOD* food = new struct FOOD[n];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar buf[64];\n\t\t\tint w,s;\n\t\t\tscanf(\"%s %d %d\",buf,&w,&s);\n\t\t\tfood[i].name = buf;\n\t\t\tfood[i].s = s;\n\t\t\tfood[i].w = w;\n\t\t}\n\n\t\tint* table = new int[n];\n\t\tfor(int i=0;i<n;i++) table[i] = i;\n\n\t\tint* res = new int[n]();\n\t\tdouble minG = 1000000.0;\n\n\t\tdo{\n\t\t\tdouble tmpG;\n\t\t\tif(checkWeight(food,table,n) &&\n\t\t\t\tminG > (tmpG = getG(food,table,n))){\n\t\t\t\t\tcopy(table,table+n,res);\n\t\t\t\t\tminG = tmpG;\n\t\t\t}\n\t\t}while(next_permutation(table,table+n));\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tprintf(\"%s\\n\",food[res[i]].name.c_str());\n\t\t}\n\n\t\tdelete[] food;\n\t\tdelete[] table;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstruct food{\n\tstring f;\n\tint w;\n\tint s;\n};\n\nint n;\nvector<food> foods;\nvector<string> res;\npair<int,vector<string> > result;\n\nvoid f(int b,int w,int k){\n\tint i;\n//cout<<b<<\" \"<<w<<endl<<\" \";\n//for(i=0;i<res.size();i++)cout<<res[i]<<endl;\n//cout<<endl;\n\tif(b==(1<<n)-1){\n\t\tif(result.first>k){\n\t\t\tresult.first=k;\n\t\t\tresult.second.clear();\n\t\t\tfor(i=0;i<n;i++)result.second.push_back(res[i]);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tif(foods[i].s<w)continue;\n\t\tres.push_back(foods[i].f);\n\t\tf(b|1<<i,w+foods[i].w,k+w+foods[i].w);\n\t\tres.pop_back();\n\t}\n}\n\nint main() {\n\twhile(n=in()){\n\t\tint i;\n\t\tfoods.clear();\n\t\tfood buf;\n\t\tresult.first=1000000000;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>buf.f>>buf.w>>buf.s;\n\t\t\tfoods.push_back(buf);\n\t\t}\n\t\tres.clear();\n\t\tf(0,0,0);\n\t\tfor(i=0;i<n;i++){\n\t\t\tcout<<result.second[n-i-1]<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;\nvector<int> w, s;\nvector<bool> used;\nvector<int> bestIndex;\nint bestG;\n\nvoid solve(int k, vector<int>& index, int g, int sumW)\n{\n    if(k == n){\n        if(g < bestG){\n            bestG = g;\n            bestIndex = index;\n        }\n        return;\n    }\n\n    for(int i=0; i<n; ++i){\n        if(used[i])\n            continue;\n        used[i] = true;\n        if(s[i] >= sumW){\n            index[k] = i;\n            solve(k+1, index, g+(n-k)*w[i], sumW+w[i]);\n        }\n        used[i] = false;\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<string> name(n);\n        w.resize(n);\n        s.resize(n);\n        for(int i=0; i<n; ++i)\n            cin >> name[i] >> w[i] >> s[i];\n\n        bestG = INT_MAX;\n        used.assign(n, false);\n        vector<int> index(n);\n        solve(0, index, 0, 0);\n        for(int i=n-1; i>=0; --i)\n            cout << name[bestIndex[i]] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nstruct food {\n\tstring f; int w, s;\n};\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tvector<food>v(n);\n\t\tint sum = 0;\n\t\trep(i, n) {\n\t\t\tstring f; int w, s; cin >> f >> w >> s;\n\t\t\tv[i] = { f,w,s }; sum += w;\n\t\t}\n\t\tsort(v.begin(), v.end(), [](food a, food b) {return a.w > b.w; });\n\t\twhile (!v.empty()) {\n\t\t\tint i = 0;\n\t\t\twhile (v[i].s < sum - v[i].w)i++;\n\t\t\tsum -= v[i].w;\n\t\t\tcout << v[i].f << endl;\n\t\t\tv.erase(v.begin() + i);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring f[11];\nint ans[11];\nint n;\nint w[11],s[11];\n\nvoid solve(){\n\tfor(int i=1; i<=n; i++)\n\t\tans[i] = i;\n\tfor(int k=1; k<=n; k++){\n\t\tfor(int i=n; i>k; i--){\n\t\t\tif(s[i] > s[i-1]){\n\t\t\t\tint tmp = s[i];\n\t\t\t\ts[i] = s[i-1];\n\t\t\t\ts[i-1] = tmp;\n\t\t\t\ttmp = ans[i];\n\t\t\t\tans[i] = ans[i-1];\n\t\t\t\tans[i-1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcin >> f[i] >> w[i] >> s[i];\n\t\tsolve();\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcout << f[ans[i]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cfloat>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nstruct Food{\n\tstring name;\n\tint w;\n\tint s;\n\tint id;\n\tFood(string name, int w, int s, int id): name(name), w(w), s(s), id(id) {};\n\n\tbool operator<(const Food& rhs) const{\n\t\treturn id < rhs.id;\n\t}\n};\n\ndouble calc(vector<Food> & foods){\n\tint length= foods.size();\n\tint sum = 0;\n\tfor(int i = length - 1; i >= 0; --i){\n\t\tint s = foods[i].s;\n\t\tif(s < sum) return DBL_MAX;\n\t\tsum += foods[i].w;\n\t}\n\tdouble d = 0, n = 0;\n\tREP(i, length){\n\t\tn += (i + 1) * foods[i].w;\n\t\td +=foods[i].w;\n\t}\n\treturn n / d;\n}\n\nint main(int argc, char const *argv[])\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tvector<Food> ans;\n\twhile(cin >> n, n){\n\t\tvector<Food> foods;\n\t\tfoods.reserve(n);\n\t\tstring name;\n\t\tint w, s;\n\t\tREP(i, n){\n\t\t\tcin >> name >> w >> s;\n\t\t\tfoods.emplace_back(name, w, s, i);\n\t\t}\n\t\tdouble min = DBL_MAX;\n\t\tdo{\n\t\t\tdouble value = calc(foods);\n\t\t\tif(min > value){\n\t\t\t\tmin = value;\n\t\t\t\tans = foods;\n\t\t\t}\n\t\t}while(next_permutation(foods.begin(), foods.end()));\n\t\tREP(i, n)\n\t\t\tcout << ans[i].name << endl;\n\t};\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nmain()\n{\n\tint N;\n\twhile(cin>>N,N)\n\t{\n\t\tvector<pair<string,pair<int,int> > >A;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tstring f;int w,s;cin>>f>>w>>s;\n\t\t\tA.push_back(make_pair(f,make_pair(w,s)));\n\t\t}\n\t\tsort(A.begin(),A.end());\n\t\tvector<string>ans;\n\t\tdouble mG=1e150;\n\t\tdo{\n\t\t\tbool flag=true;\n\t\t\tint T=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(T>A[i].second.second)\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tT+=A[i].second.first;\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tdouble G=0;\n\t\t\t\tfor(int i=0;i<N;i++)G+=A[i].second.first*(N-i);\n\t\t\t\tG/=T;\n\t\t\t\tif(mG>G)\n\t\t\t\t{\n\t\t\t\t\tmG=G;\n\t\t\t\t\tans.clear();\n\t\t\t\t\tfor(int i=N;i--;)ans.push_back(A[i].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(A.begin(),A.end()));\n\t\tfor(int i=0;i<N;i++)cout<<ans[i]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring f[11];\nint ans[11];\nint n;\nint w[11],s[11];\n\nvoid solve(){\n\tfor(int i=1; i<=n; i++)\n\t\tans[i] = i;\n\tfor(int k=1; k<=n; k++){\n\t\tfor(int i=n; i>k; i--){\n\t\t\tif(s[ans[i]] > s[ans[i-1]]){\n\t\t\t\tint tmp = ans[i];\n\t\t\t\tans[i] = ans[i-1];\n\t\t\t\tans[i-1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\tbool flag = true;\n\tfor(int i=1; i<=n; i++){\n\t\tif(i==n&&flag){\n\t\t\ti=1;\n\t\t\tflag = true;\n\t\t}else if(i==n)\n\t\t\tbreak;\n\t\tif(w[ans[i]] < w[ans[i+1]]){\n\t\t\tint tmp = w[ans[i]];\n\t\t\tfor(int k=i+2; k<=n; k++)\n\t\t\t\ttmp += w[ans[k]];\n\t\t\tif(s[ans[i+1]] >= tmp){\n\t\t\t\ttmp = ans[i];\n\t\t\t\tans[i] = ans[i+1];\n\t\t\t\tans[i+1] = tmp;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcin >> f[i] >> w[i] >> s[i];\n\t\tsolve();\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcout << f[ans[i]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nvector<int> w,s,hist;\nvector<string> name;\nint n,tmpn,tmpm;\nint used,ret[10];\nstring str;\ndouble gmin = 1e+10;\n\ninline double calc_g(){\n\tdouble p=0;\n\tdouble q=0;\n\tfor(int i=0;i<n;i++){\n\t\tp += (n-i) * hist[n-1-i];\n\t\tq += hist[i];\n\t}\n\treturn p/q;\n}\n\nvoid solve(int num, int weight){\n\tif(num == n){\t\t\t\n\t\tdouble g = calc_g();\n\t\tif(gmin > g){\n\t\t\tgmin = g;\n\t\t\tfor(int i=0;i<n;i++) ret[i] = hist[i];\n\t\t}\n\t\treturn;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif((used & (1 << i)) == 0){\n\t\t\tif(s[i] >= weight){\n\t\t\t\t//ツ鳴「ツ使ツ用ツづつゥツづつ重ツづ敖づ可妥渉つヲツづァツづェツつスツづァツ静渉づアツづづ敖づゥ\n\t\t\t\tused += 1 << i;\n\t\t\t\thist.push_back(i);\n\t\t\t\tsolve(num+1, weight+w[i]);\n\t\t\t\thist.pop_back();\n\t\t\t\tused -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(cin >> n && n){\n\t\tw.clear();\n\t\ts.clear();\n\t\thist.clear();\n\t\tname.clear();\n\t\tmemset(ret, 0, sizeof(ret));\n\t\tused = 0;\n\t\tgmin = 1e+10;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> str >> tmpn >> tmpm;\n\t\t\tname.push_back(str);\n\t\t\tw.push_back(tmpn);\n\t\t\ts.push_back(tmpm);\n\t\t}\n\t\tsolve(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcout << name[ret[n-i-1]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tint n;\n\tvector<pair<string,pii> > data;\n\tvector<string> ans;\n\twhile(cin>>n,n){\n\t\tdata.clear();\n\t\tans.clear();\n\t\tstring str;\n\t\tint w,s;\n\t\tdouble tmp2 =0;\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcin>>str;\n\t\t\tscanf(\"%d %d\",&w,&s);\n\t\t\tdata.push_back(mp(str,pii(w,s)));\n\t\t\ttmp2 +=data[i].second.first;\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tdouble G =INF;\n\t\tdo{\n\t\t\t//cout <<\"iei\"<<endl;\n\t\t\tint sumw =0;\n\t\t\tdouble tmp1 =0;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\ttmp1 +=(i+1)*data[i].second.first;\n\t\t\t}\n\t\t\tdouble Gtmp =(double)(tmp1/tmp2);\n\t\t\tif(Gtmp>G)continue;\n\t\t\tbool ok =true;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\tif(sumw>data[i].second.second){\n\t\t\t\t\tok =false;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tsumw +=data[i].second.first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok&&Gtmp <G){\n\t\t\t\tG =Gtmp;\n\t\t\t\tans.clear();\n\t\t\t\tfor(int i =0; i<data.size();i++){\n\t\t\t\t\tans.push_back(data[i].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(data.begin(), data.end()));\n\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcout <<ans[i]<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/02/06 Tazoe\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct food{\n\tstring f;\n\tint w;\n\tint s;\n};\n\nint main()\n{\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tstruct food F[10];\n\t\tfor(int i=0; i<n; i++)\n\t\t\tcin >> F[i].f >> F[i].w >> F[i].s;\n\n\t\tfor(int i=0; i<n-1; i++)\n\t\t\tfor(int j=i+1; j<n; j++)\n\t\t\t\tif(F[i].w<F[j].w){\n\t\t\t\t\tstruct food tmp = F[i];\n\t\t\t\t\tF[i] = F[j];\n\t\t\t\t\tF[j] = tmp;\n\t\t\t\t}\n\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j=i+1; j<n; j++)\n\t\t\t\tsum += F[j].w;\n\n\t\t\tif(F[i].s>=sum)\n\t\t\t\tcontinue;\n\n\t\t\tint k;\n\t\t\tfor(k=i+1; k<n; k++)\n\t\t\t\tif(F[k].s>=sum+F[i].w-F[k].w)\n\t\t\t\t\tbreak;\n\n\t\t\tstruct food tmp = F[k];\n\t\t\tfor(int j=k; j>i; j--)\n\t\t\t\tF[j] = F[j-1];\n\t\t\tF[i] = tmp;\n\t\t}\n\n\t\tfor(int i=0; i<n; i++)\n\t\t\tcout << F[i].f << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nvector<int> w,s,hist;\nvector<string> name;\nint n,tmpn,tmpm;\nint used,ret[10];\nstring str;\ndouble gmin = 1e+10;\n\ninline double calc_g(){\n\tdouble p=0;\n\tdouble q=0;\n\tfor(int i=0;i<n;i++){\n\t\tp += (n-i) * hist[n-1-i];\n\t\tq += hist[i];\n\t}\n\treturn p/q;\n}\n\nvoid solve(int num, int weight){\n\tif(num == n){\t\t\t\n\t\tdouble g = calc_g();\n\t\tif(gmin > g){\n\t\t\tgmin = g;\n\t\t\tfor(int i=0;i<n;i++) ret[i] = hist[i];\n\t\t}\n\t\treturn;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif((used & (1 << i)) == 0){\n\t\t\tif(s[i] >= weight){\n\t\t\t\t//ツ鳴「ツ使ツ用ツづつゥツづつ重ツづ敖づ可妥渉つヲツづァツづェツつスツづァツ静渉づアツづづ敖づゥ\n\t\t\t\tused |= 1 << i;\n\t\t\t\thist.push_back(i);\n\t\t\t\tsolve(num+1, weight+w[i]);\n\t\t\t\thist.pop_back();\n\t\t\t\tused ^= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(cin >> n && n){\n\t\tw.clear();\n\t\ts.clear();\n\t\thist.clear();\n\t\tname.clear();\n\t\tmemset(ret, 0, sizeof(ret));\n\t\tused = 0;\n\t\tgmin = 1e+10;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> str >> tmpn >> tmpm;\n\t\t\tname.push_back(str);\n\t\t\tw.push_back(tmpn);\n\t\t\ts.push_back(tmpm);\n\t\t}\n\t\tsolve(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcout << name[ret[n-i-1]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cfloat>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nstruct Food{\n\tstring name;\n\tint w;\n\tint s;\n\tint id;\n\tFood(string name, int w, int s, int id): name(name), w(w), s(s), id(id) {};\n\n\tbool operator<(const Food& rhs) const{\n\t\treturn id < rhs.id;\n\t}\n};\n\ndouble calc(vector<Food> foods){\n\tint length= foods.size();\n\tint sum = 0;\n\tfor(int i = length - 1; i >= 0; --i){\n\t\tint s = foods[i].s;\n\t\tif(s < sum) return DBL_MAX;\n\t\tsum += foods[i].w;\n\t}\n\tdouble d = 0, n = 0;\n\tREP(i, length){\n\t\tn += (i + 1) * foods[i].w;\n\t\td +=foods[i].w;\n\t}\n\treturn n / d;\n}\n\nint main(int argc, char const *argv[])\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tvector<Food> ans;\n\twhile(cin >> n, n){\n\t\tvector<Food> foods;\n\t\tREP(i, n){\n\t\t\tstring name;\n\t\t\tint w, s;\n\t\t\tcin >> name >> w >> s;\n\t\t\tfoods.emplace_back(name, w, s, i);\n\t\t}\n\t\tdouble min = DBL_MAX;\n\t\tdo{\n\t\t\tdouble value = calc(foods);\n\t\t\tif(min > value){\n\t\t\t\tmin = value;\n\t\t\t\tans = foods;\n\t\t\t}\n\t\t}while(next_permutation(foods.begin(), foods.end()));\n\t\tREP(i, n)\n\t\t\tcout << ans[i].name << endl;\n\t};\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\ntypedef pair <string, II> NODE;\ntypedef vector <NODE> NODES;\n\nvoid solve( int n, NODES nodes ) {\n    double ming = -1.0;\n    VS L;\n    sort( nodes.begin(), nodes.end() );\n    do {\n        int wsum = 0;\n        for ( int i = 0; i < n; ++ i ) {\n            if ( wsum > nodes[i].second.second ) goto out_1;\n            wsum += nodes[i].second.first;\n        }\n        double g;\n        for ( int i = 0; i < n; ++ i ) {\n            g += ( n - i ) * nodes[i].second.first;\n        }\n        g /= wsum;\n        if ( ming < -0.5 || g < ming ) {\n            ming = g;\n            VS T;\n            for ( int i = 0; i < n; ++ i ) {\n                T.push_back( nodes[i].first );\n            }\n            L = T;\n        }\n    out_1:;\n    } while ( next_permutation( nodes.begin(), nodes.end() ) );\n\n    reverse( L.begin(), L.end() );\n    for ( int i = 0; i < n; ++ i ) {\n        cout << L[i] << endl;\n    }\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        NODES nodes( n );\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> nodes[i].first >> nodes[i].second.first >> nodes[i].second.second;\n        }\n        solve( n, nodes );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef pair<int,string> P;\ntypedef pair<int,P> PP;\n\nint n,a;\nPP in[10],tmp;\nint t[10];\nvector<int>ans;\n\nint get_weight(int);\n\nint main(){\n  while(cin>>n&&n!=0){\n    ans.clear();\n    for(int i=0;i<n;i++)cin>>in[i].second.second>>in[i].second.first>>in[i].first;\n    sort(in,in+n);\n\n    for(int i=n-1;i>=0;i--){\n      for(int j=0;j<i;j++){\n\ta=get_weight(j)+in[j+1].second.first;\n\tif(a<=in[j].first&&in[j].second.first>in[j+1].second.first){\n\t  tmp=in[j];in[j]=in[j+1];in[j+1]=tmp;\n\t}\n\t/*\nelse if(a<=in[j].first&&(in[j].second.first==in[j+1].second.first&&in[j].first>in[j+1].first)){\n\t  tmp=in[j];in[j]=in[j+1];in[j+1]=tmp;\n\t}\n\t*/\n      }\n    }\n    \n    for(int i=n-1;i>=0;i--)cout<<in[i].second.second<<endl;\n    \n    \n  }\n  return 0;\n}\n\nint get_weight(int x){\n  int res=0;\n  for(int i=0;i<x;i++)res+=in[i].second.first;\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\nusing namespace std;\nint n, w[1000], s[1000];\nstring S[1000]; vector<int>b; int maxn;\nint main() {\n\twhile (true) {\n\t\tcin >> n; b.clear(); maxn = 1 << 30;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> S[i] >> w[i] >> s[i];\n\t\t}\n\t\tvector<int>a(n, 0);\n\t\tfor (int i = 0; i < n; i++)a[i] = i;\n\t\tdo {\n\t\t\tint sum2 = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tsum += w[a[j]];\n\t\t\t\t}\n\t\t\t\tif (sum > s[a[i]]) goto E;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tsum2 += i*w[a[i]];\n\t\t\t}\n\t\t\tif (maxn > sum2) {\n\t\t\t\tb = a; maxn = sum2;\n\t\t\t}\n\t\tE:;\n\t\t} while (next_permutation(a.begin(), a.end()));\n\t\tfor (int i = 0; i < n; i++) { cout << S[b[i]] << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 10;\nconst double inf = 1e10;\n\nint n;\nstring f[MAXN];\nint w[MAXN], s[MAXN];\ndouble minG;\nvector<int> t, ans, used;\n\nvoid rec(int k, int sumww, int sumw) {\n  if(k == -1) {\n    double G = (double)sumww/(double)sumw;\n    if(G < minG) {\n      ans = t;\n      minG = G;\n    }\n    return;\n  }\n  for(int i = 0; i < n; ++i) {\n    t[k] = i;\n    if(used[t[k]]) continue;\n    if(s[t[k]] >= sumw) {\n      used[t[k]] = true;\n      rec(k-1, sumww + (k+1)*w[t[k]], sumw + w[t[k]]);\n      used[t[k]] = false;\n    }\n  }\n}\n\nint main() {\n  for(; cin >> n, n;) {\n    for(int i = 0; i < n; ++i) {\n      cin >> f[i] >> w[i] >> s[i];\n    }\n    minG = inf;\n    t = used = vector<int>(n);\n    rec(n-1, 0, 0);\n    for(int i = 0; i < n; ++i) {\n      cout << f[ans[i]] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int w, s;\n    string name;\n    bool operator<(const Data& d){\n        return s < d.s;\n    }\n};\n\nint n;\nvector<Data> d;\nvector<bool> used;\nvector<int> bestIndex;\nint bestG;\n\nvoid solve(int k, vector<int>& index, int g, int sumW)\n{\n    if(k == n){\n        if(g < bestG){\n            bestG = g;\n            bestIndex = index;\n        }\n        return;\n    }\n\n    for(int i=0; i<n; ++i){\n        if(used[i])\n            continue;\n        if(d[i].s >= sumW){\n            used[i] = true;\n            index[k] = i;\n            solve(k+1, index, g+(n-k)*d[i].w, sumW+d[i].w);\n            used[i] = false;\n        }else{\n            return;\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        d.resize(n);\n        for(int i=0; i<n; ++i)\n            cin >> d[i].name >> d[i].w >> d[i].s;\n        sort(d.begin(), d.end());\n\n        bestG = INT_MAX;\n        used.assign(n, false);\n        vector<int> index(n);\n        solve(0, index, 0, 0);\n        for(int i=n-1; i>=0; --i)\n            cout << d[bestIndex[i]].name << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<pair<string,pii>> v(n);\n\t\trep(i,n) cin>>v[i].F>>v[i].S.F>>v[i].S.S;\n\t\tsort(ALL(v));\n\t\tdouble a=0;\n\t\tvector<string> ans;\n\t\tdo{\n\t\t\tint S=0;\n\t\t\trep(i,n){\n\t\t\t\t// cout<<i<<\" \"<<S<<endl;\n\t\t\t\tif(S>v[i].S.S){\n\t\t\t\t\t// cout<<S<<\" \"<<v[i].S.F<<\" \"<<i<<endl;\n\t\t\t\t\tdouble t=0;\n\t\t\t\t\trep(j,i) t+=(j+1)*v[j].S.F;\n\t\t\t\t\tt/=S;\n\t\t\t\t\tif(a<t){\n\t\t\t\t\t\ta=t;\n\t\t\t\t\t\tans.clear();\n\t\t\t\t\t\trep(j,i) ans.PB(v[j].F);\n\t\t\t\t\t\t// cout<<a<<endl;\n\t\t\t\t\t\t// rep(j,ans.size()) cout<<ans[j]<<\" \";\n\t\t\t\t\t\t// cout<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i==n-1){\n\t\t\t\t\tdouble t=0;\n\t\t\t\t\trep(j,n) t+=(j+1)*v[j].S.F;\n\t\t\t\t\tS+=v[i].S.F;\n\t\t\t\t\tt/=S;\n\t\t\t\t\tif(a<t){\n\t\t\t\t\t\ta=t;\n\t\t\t\t\t\tans.clear();\n\t\t\t\t\t\trep(j,i+1) ans.PB(v[j].F);\n\t\t\t\t\t\t// cout<<a<<endl;\n\t\t\t\t\t\t// rep(j,ans.size()) cout<<ans[j]<<\" \";\n\t\t\t\t\t\t// cout<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tS+=v[i].S.F;\n\t\t\t}\n\t\t}while(next_permutation(ALL(v)));\n\t\treverse(ALL(ans));\n\t\trep(i,ans.size()){\n\t\t\tcout<<ans[i]<<endl;\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst int MOD=1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  while(true){\n      cin>>n;\n      if(n==0) break;\n      std::vector<string> f(n);\n      std::vector<int> w(n),s(n),v(n),res(n);\n      for(int i=0;i<n;i++) cin>>f[i]>>w[i]>>s[i];\n      for(int i=0;i<n;i++) v[i]=i;\n      double mi=INF;\n      do{\n          double g=0,sum=0;\n          for(int i=1;i<=n;i++){\n              g+=i*w[v[i-1]];\n              sum+=w[v[i-1]];\n          }\n          g/=sum;\n          bool flag=true;\n          for(int i=0;i<n;i++){\n              int wa=0;\n              for(int j=i+1;j<n;j++) wa+=w[v[j]];\n              if(s[v[i]]<wa) flag=false;\n          }\n          if(flag){\n              if(g<mi){\n                  for(int i=0;i<n;i++) res[i]=v[i];\n              }\n          }\n      }while(next_permutation(v.begin(),v.end()));\n      for(int i=0;i<n;i++) cout<<f[res[i]]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstruct food {\n\tstring f;\n\tint w, s;\n\n\tfood(string f_, int w_, int s_) {\n\t\tf = f_; w = w_, s = s_;\n\t}\n};\n\nint N;\nvector<food> v;\nconst int INF = 1000000000;\n\nint G[1 << 10][10];\n\nbool withstand(int status, int next) {\n\tint sw = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tif(status & (1 << i)) {\n\t\t\tsw += v[i].w;\n\t\t}\n\t}\n\n\treturn v[next].s >= sw;\n}\n\nint DP(int status, int bottom) {\n\tif(!withstand(status & ~(1 << bottom), bottom))\n\t\treturn INF;\n\n\tif(G[status][bottom] != -1) {\n\t\treturn G[status][bottom];\n\t}\n\n\tG[status][bottom] = INF;\n\n\tint depth = 0;\n\tfor(int i = 0; i < N; i++)\n\t\tif(status & (1 << i))\n\t\t\tdepth++;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tif(status & (1 << i)) {\n\t\t\tG[status][bottom] = min(G[status][bottom], DP(status & ~(1 << bottom), i) + (N - depth + 1) * v[bottom].w);\n\t\t}\n\t}\n\n\treturn G[status][bottom];\n}\n\nint main() {\n\twhile(cin >> N, N) {\n\t\tv.clear();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tstring f;\n\t\t\tint w, s;\n\t\t\tcin >> f >> w >> s;\n\t\t\tv.push_back(food(f, w, s));\n\t\t}\n\t\tfor(int i = 0; i < 1 << N; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tG[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tG[0][i] = 0;\n\t\t}\n\t\tint ret = INF;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint tmp = DP((1 << N) - 1, i);\n\t\t\tret = min(ret, tmp < 0 ? INF : tmp);\n\t\t}\n//\t\tcout << ret << endl;\n\t\tqueue<int> q;\n\t\tint status = (1 << N) - 1;\n\t\twhile(status) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tif(ret == G[status][i] && (status & (1 << i))) {\n\t\t\t\t\tq.push(i);\n\t\t\t\t\tret -= v[i].w * q.size();\n\t\t\t\t\tstatus &= ~(1 << i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!q.empty()) {\n\t\t\tcout << v[q.front()].f << endl;\n\t\t\tq.pop();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 1<<30\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    string f[n];\n    int w[n],s[n];\n    int x[n];\n    REP(i,n) {\n      cin >> f[i] >> w[i] >> s[i];\n      x[i] = i;\n    }\n    int ans[n];\n    double ansg = INF;\n    do {\n      int sum = 0;\n      int ct;\n      for (ct=n-2; ct>=0; --ct) {\n        sum += w[x[ct+1]];\n        if (s[x[ct]] < sum)\n          break;\n      }\n      if (ct >= 0) continue;\n      \n      // REP(i,4) {\n      //   cout << x[i] << \" \";\n      // }\n      // cout << endl;\n      double g = 0, hoge = 0;\n      REP(i,n) {\n        g += w[x[i]] * (i+1);\n        hoge += w[x[i]];\n      }\n      g /= hoge;\n      // cout << g << endl;\n      if (ansg > g) {\n        ansg = g;\n        memcpy(ans,x,sizeof(x));\n      }\n    } while(next_permutation(x, x+n));\n    REP(i,n)\n      //     cout << ans[i] << \" \";\n     cout << f[ans[i]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvector<string> name(n);\n\t\tvector<int> wei(n),safe(n),perm(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar nm[21];\n\t\t\tscanf(\"%s%d%d\",nm,&wei[i],&safe[i]);\n\t\t\tname[i]=nm;\n\t\t\tperm[i]=i;\n\t\t}\n\n\t\tvector<int> opt(n);\n\t\tdouble gopt=-1;\n\t\tdo{\n\t\t\tbool b=true;\n\n\t\t\tint wsum=0,g=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint now=perm[i];\n\t\t\t\tif(wsum>safe[now]){\n\t\t\t\t\tb=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twsum+=wei[now];\n\t\t\t\tg+=(i+1)*wei[now];\n\t\t\t}\n\n\t\t\tif(!b)\tcontinue;\n\n\t\t\tif(gopt<(double)g/wsum){\n\t\t\t\tgopt=(double)g/wsum;\n\t\t\t\topt=perm;\n\t\t\t}\n\t\t}while(next_permutation(perm.begin(),perm.end()));\n\n\t\tfor(int i=n-1;i>=0;i--)\tputs(name[opt[i]].c_str());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double d_INF = 100000000.0;\nconst int I_INF = 1000000000;\n\nint n;\nstring name[100];\nint weight[100];\nint cap[100];\nvector<int> t_path;\nvector<int> path;\ndouble height;\n\nvoid dfs(int s, int c, int sum, double g){\n  if(s == (1<<n)-1){\n    if(height > g){\n      path = t_path;\n      height = g;\n    }\n    return;\n  }\n  if(height < g) return;\n  int pos = 1;\n  int div = 0;\n  for(int i=0;i<n;i++){\n    if((1<<i) & s){\n      ++pos;\n      div += weight[i];\n    }\n  }\n  for(int i=0;i<n;i++){\n    if((1<<i) & s) continue;\n    if(weight[i] > c) continue;\n    t_path.push_back(i);\n    dfs(s|(1<<i), min(c-weight[i], cap[i]), sum+pos*weight[i], (double)(sum+pos*weight[i])/(div+weight[i]));\n    t_path.pop_back();\n  }\n}\n\nvoid solve(){\n  height = d_INF;\n  dfs(0, I_INF, 0, 0.0);\n  for(int i=0;i<path.size();i++){\n    cout << name[path[i]] << endl;\n  }\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> name[i] >> weight[i] >> cap[i];\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<climits>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\nstruct food{\n    string name;\n    int weight;\n    int ue;\n    int id;\n};\nstruct com\n{\n    inline bool operator() (const food& f1, const food& f2){\n        return (f1.id > f2.id);\n    }\n};\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<food>vec,v;\n        int totWeight=0;\n        for(int i=0;i<n;i++){\n            food f;\n            cin>>f.name>>f.weight>>f.ue;\n            f.id=i;\n            totWeight += f.weight;\n            vec.push_back(f);\n            v.push_back(f);\n        }\n        sort(vec.begin(),vec.end(),com());\n        vector<pair<double,vector<int> > >ve;\n        do{\n            bool ok=true;\n            int tot=0;\n            for(int i=n-1;i>=0;i--){\n                if(tot>vec[i].ue){\n                    ok=false;\n                    break;\n                }\n                tot+=vec[i].weight;\n            }\n            if(ok){\n                double x=0;\n                for(int i=1;i<=n;i++){\n                    x+=(n-i)*vec[i].weight;\n                }\n                x/=totWeight;\n                vector<int>ids;\n                for(int i=0;i<n;i++){\n                    ids.push_back(vec[i].id);\n                }\n                ve.push_back(make_pair(x, ids));\n            }\n        } while(next_permutation(vec.begin(), vec.end(), com()));\n        sort(ve.begin(),ve.end());\n        for(int i=0;i<n;i++){\n            cout<<v[ve[ve.size()-1].second[i]].name<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tint n;\n\tvector<pair<string,pii> > data;\n\tvector<pair<string,pii> > ans;\n\twhile(cin>>n,n){\n\t\tdata.clear();\n\t\tans.clear();\n\t\tstring str;\n\t\tint w,s;\n\t\tint tmp2 =0;\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcin>>str;\n\t\t\tscanf(\"%d %d\",&w,&s);\n\t\t\tdata.push_back(mp(str,pii(w,s)));\n\t\t\ttmp2 +=data[i].second.first;\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tdouble G =INF;\n\t\tdo{\n\t\t\t//cout <<\"iei\"<<endl;\n\t\t\tint sumw =0;\n\t\t\tint tmp1 =0;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\ttmp1 +=(i+1)*data[i].second.first;\n\t\t\t}\n\t\t\tdouble Gtmp =(double)((double)tmp1/(double)tmp2);\n\t\t\tif(Gtmp>G)continue;\n\t\t\tbool ok =true;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\tif(sumw>data[i].second.second){\n\t\t\t\t\tok =false;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tsumw +=data[i].second.first;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout <<Gtmp<<endl;\n\t\t\tif(ok&&Gtmp <G){\n\t\t\t\tG =Gtmp;\n\t\t\t\tans=data;\n\t\t\t\t//cout <<\"ge\"<<endl;\n\t\t\t}\n\t\t}while(next_permutation(data.begin(), data.end()));\n\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcout <<ans[i].first<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// 入力\nstring f[10];\nint n, w[10], s[10]; \n// used[i] := i番目を選んだかどうか\nbool used[10];\n// 今まで見つかった中で一番重心が低いもの\ndouble ans_g;\n// 解\nvector<int> ans;\n\n// 重さに耐えられるかチェック\nbool check(vector<int>& v){\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tint weight = 0;\n\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\tweight += w[v[j]];\n\t\t}\n\t\tif( s[v[i]] < weight )\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n// 重心を計算\ndouble gravity(vector<int>& v){\n\tdouble a = 0, b = 0;\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\ta += (i+1) * w[v[i]];\n\t\tb += w[v[i]];\n\t}\n\treturn a / b;\n}\n\n// 順列生成して解を探す (最大で 10! 通り)\nvoid solve(){\n\tvector<int> v(n);\n\tfor(int i=0 ; i < n ; i++ ) v[i] = i;\n\t// 順列生成してチェック\n\tdo{\n\t\tdouble g = gravity(v);\n\t\t// 重心が低い かつ 重さに耐えられるとき\n\t\tif( check(v) && g < ans_g ){\n\t\t\tans_g = g;\n\t\t\tans = v;\n\t\t}\n\t}while( next_permutation(v.begin(),v.end()) );\n}\n\n// 探索\nvoid dfs(vector<int>& v, int num){\n\t// 重さに耐えられるかチェック, 耐えられないときは探索打ち切り\n\tif( !check(v) ) return;\n\t\n\tif( num == n ){\n\t\tdouble g = gravity(v);\n\t\tif( g < ans_g ){ // 重心が低いとき\n\t\t\tans_g = g;\n\t\t\tans = v;\n\t\t}\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( used[i] ) continue;\n\t\t\n\t\tused[i] = true;\n\t\tv.push_back( i );\n\t\tdfs( v , num+1 );\n\t\tv.pop_back();\n\t\tused[i] = false;\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\t// 初期化\n\t\tfor(int i=0 ; i < 10 ; i++ ) used[i] = false;\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tcin >> f[i] >> w[i] >> s[i];\n\t\t}\n\t\t\n\t\tans_g = 1e+9;\n\t\tvector<int> v;\n\t\tdfs( v , 0 );\n\t\t//solve();\n\t\t\n\t\tfor(int i=0 ; i < ans.size() ; i++ ){\n\t\t\tcout << f[ans[i]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct PP{\n\tint f;int w;\n\tstring str;\n};\n\nint main(){\n\t\n\tint a,b;\n\tstring L;\n\tint n;\n\twhile(1){\n\tcin>>n;if(n==0)break;\n\n\tstruct PP  P[12];\n\tfor(int i=0;i<n;i++){\n\t\tcin>>P[i].str>>P[i].w>>P[i].f;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=n-1;j>i;j--)\n\t\t\tif(P[j].f>P[j-1].f){\n\t\t\t\tstruct PP T;\n\t\t\t\tT=P[j-1];P[j-1]=P[j];P[j]=T;\n\t\t\t}\nbool f=true;\n\twhile(1){int s=0;\n\tf=true;\n\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\t\n\t\t\tif(i>0&&P[i].w>P[i-1].w){\n\t\t\t\tif(P[i].f>=P[i-1].w+s){\n\t\t\t\tstruct PP TT;\n\t\t\t\tTT=P[i-1];P[i-1]=P[i];P[i]=TT;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t\t}\n\t\t\t\ts+=P[i].w;\n\t\t}\n\t\tif(f==true)break;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcout<<P[i].str<<endl;\n}\n\treturn 0;\n}\n\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nclass Data{\npublic:\n\tint w,s;\n\tstring name;\n};\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tData d[10];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>d[i].name>>d[i].w>>d[i].s;\n\t\t}\n\t\tvector<int> v;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tv.push_back(i);\n\t\t}\n\t\tdouble minW=100000000;\n\t\tvector<int> p;\n\t\t// ツ全ツ津環づィツづ個渉氾板づ計ツ算ツつキツづゥ\n\t\tdo{\n\t\t\tint sumW=0;\n\t\t\tbool f=true;\n\t\t\tint Bunshi=0;\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\tBunshi+=(i+1)*d[v[i]].w;\n\t\t\t\tif(sumW>d[v[i]].s){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsumW+=d[v[i]].w;\n\t\t\t}\n\t\t\t// ツづつづ板づェツづ按つ「ツ湘ェツ債、ツ全ツ妥個づ個重ツ心ツづーツ更ツ新ツつキツづゥ\n\t\t\tif(f){\n\t\t\t\tdouble G=(double)Bunshi/sumW;\n\t\t\t\tif(G<minW){\n\t\t\t\t\tminW=min(minW,G);\n\t\t\t\t\tp=v;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(v.begin(),v.end()));\n\n\t\tfor(int i = 0; i < p.size(); i++){\n\t\t\tcout<<d[p[i]].name<<endl;\n\t\t}\n\t//\tcout<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cfloat>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nconst int MAX_N = 10;\nint n;\nstring f[MAX_N];\nint w[MAX_N];\nint s[MAX_N];\n\ndouble ming;\nvector<int> minindeies;\n\nvector<int> selected;\nbool used[MAX_N];\nvoid permutation(int r, int limit) {\n\tif (r == 0) {\n\t\tdouble a = 0., b = 0.;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta += w[selected[i]] * (i + 1);\n\t\t\tb += w[selected[i]];\n\t\t}\n\t\tdouble g = a / b;\n\t\tif (g < ming) {\n\t\t\tming = g;\n\t\t\tminindeies = selected;\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i]) continue;\n\t\t\tif (w[i] > limit) continue;\n\t\t\tused[i] = true;\n\t\t\tselected.push_back(i);\n\t\t\tpermutation(r - 1, min(limit - w[i], s[i]));\n\t\t\tselected.pop_back();\n\t\t\tused[i] = false;\n\t\t}\n\t}\n}\n\nint main () {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> f[i] >> w[i] >> s[i];\n\t\t}\n\t\tmemset(used, 0, sizeof(used));\n\t\tming = DBL_MAX;\n\t\tpermutation(n, 0x7ffffff);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcout << f[minindeies[i]] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\nll calc(const vector<pair<int, pll> > &v){\n\tll sum = 0LL, ret = 0LL;\n\trep(i, v.size()){\n\t\tif(v[i].se.se < sum) return LINF;\n\t\tsum += v[i].se.fi;\n\t\tret += (v.size() - i) * v[i].se.fi;\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n = in.nextInt();\n\t\tif(n == 0) break;\n\n\t\tvector<string> s(n);\n\t\tvector<int> ans(n);\n\t\tll w = LINF;\n\t\tvector<pair<int, pll> > v(n);\n\n\t\trep(i, n){\n\t\t\ts[i] = in.next();\n\t\t\tv[i].fi = i;\n\t\t\tv[i].se.fi = in.nextLong();\n\t\t\tv[i].se.se = in.nextLong();\n\t\t}\n\t\tsort(all(v));\n\n\t\tdo{\n\t\t\tll tmp = calc(v);\n\t\t\tif(tmp < w){\n\t\t\t\tw = tmp;\n\t\t\t\trep(i, v.size()) ans[i] = v[i].fi;\n\t\t\t}\n\t\t}while(next_permutation(all(v)));\n\n\t\treverse(all(ans));\n\n\t\trep(i, n) printf(\"%s\\n\", s[ans[i]].c_str());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass FoodInfor {\npublic:\n\tstring name;\n\tint weight;\n\tint limit;\n};\n\nFoodInfor FoodData[10];\nint TableIndex[10], Result[10];\n\n\nbool checkWeight(int n) {\n\tint sum = 0;\n\n#if 0\n\tfor (int i = n-1; i > 0; i--) {\n\t\tsum += FoodData[TableIndex[i]].weight;\n\t\tif (sum > FoodData[TableIndex[i - 1]].limit) {\n\t\t\treturn false;\n\t\t}\n\t}\n#else\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tsum += FoodData[TableIndex[i]].weight;\n\t\tif (sum > FoodData[TableIndex[i + 1]].limit) {\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n\t\n\treturn true;\n}\n\nint getG(int n) {\n\tint G = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tG += FoodData[TableIndex[i]].weight * (n-i);\n\t}\n\treturn G;\n}\n\nint main() {\n\tint n, tmpG, minG;\n\n\twhile (cin>>n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> FoodData[i].name >> FoodData[i].weight >> FoodData[i].limit;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tTableIndex[i] = i;\n\t\t}\n\n\t\tminG = INT_MAX;\n\t\tdo {\n\t\t\tif (checkWeight(n) && minG > (tmpG = getG(n))) {\n\t\t\t\t//copy(TableIndex, TableIndex + n, Result);\t//OK\n\t\t\t\t//memmove(Result, TableIndex, n);\t\t\t//NG\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tResult[i] = TableIndex[i];\n\t\t\t\t}\n\t\t\t\tminG = tmpG;\n\t\t\t}\n\t\t} while (next_permutation(TableIndex, TableIndex + n));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcout << FoodData[Result[n-1-i]].name << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// 入力\nstring f[10];\nint n, w[10], s[10]; \n// used[i] := i番目を選んだかどうか\nbool used[10];\n// 今まで見つかった中で一番重心が低いもの\ndouble ans_g;\n// 解\nvector<int> ans;\n\n// 重さに耐えられるかチェック\nbool check(vector<int>& v){\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tint weight = 0;\n\t\tfor(int j=i+1 ; j < v.size() ; j++ ){\n\t\t\tweight += w[v[j]];\n\t\t}\n\t\tif( s[v[i]] < weight )\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n// 重心を計算\ndouble gravity(vector<int>& v){\n\tdouble a = 0, b = 0;\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\ta += (i+1) * w[v[i]];\n\t\tb += w[v[i]];\n\t}\n\treturn a / b;\n}\n\n// 順列生成して解を探す (最大で 10! 通り)\nvoid solve(){\n\tvector<int> v(n);\n\tfor(int i=0 ; i < n ; i++ ) v[i] = i;\n\t// 順列生成してチェック\n\tdo{\n\t\tdouble g = gravity(v);\n\t\t// 重心が低い かつ 重さに耐えられるとき\n\t\tif( check(v) && g < ans_g ){\n\t\t\tans_g = g;\n\t\t\tans = v;\n\t\t}\n\t}while( next_permutation(v.begin(),v.end()) );\n}\n\n// 探索\nvoid dfs(vector<int>& v, int num){\n\t// 重さに耐えられるかチェック, 耐えられないときは探索打ち切り\n\tif( !check(v) ) return;\n\t\n\tif( num == n ){\n\t\tdouble g = gravity(v);\n\t\tif( g < ans_g ){ // 重心が低いとき\n\t\t\tans_g = g;\n\t\t\tans = v;\n\t\t}\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( used[i] ) continue;\n\t\t\n\t\tused[i] = true;\n\t\tv.push_back( i );\n\t\tdfs( v , num+1 );\n\t\tv.pop_back();\n\t\tused[i] = false;\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\t// 初期化\n\t\tfor(int i=0 ; i < 10 ; i++ ) used[i] = false;\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tcin >> f[i] >> w[i] >> s[i];\n\t\t}\n\t\t\n\t\tans_g = 1e+9;\n\t\tvector<int> v;\n\t\t//dfs( v , 0 );\n\t\tsolve();\n\t\t\n\t\tfor(int i=0 ; i < ans.size() ; i++ ){\n\t\t\tcout << f[ans[i]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<string, P> PP;\n\nvoid solve()\n{\n\tint n;\n\twhile(cin >> n, n)\n\t{\n\t\tvector<PP> Vec;\n\t\tint sum_weight = 0;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tint w, s;\n\t\t\tcin >> w >> s;\n\t\t\tVec.push_back(PP(name, P(w, s)));\n\t\t\tsum_weight += w;\n\t\t}\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tvector<int> ok;\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif(sum_weight - Vec[j].second.first <= Vec[j].second.second)\n\t\t\t\t{\n\t\t\t\t\tok.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok.size() == 1)\n\t\t\t{\n\t\t\t\tcout << Vec[ok[0]].first << endl;\n\t\t\t\tsum_weight -= Vec[ok[0]].second.first;\n\t\t\t\tVec[ok[0]].second.second = -9999999;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint heaviest = 0;\n\t\t\t\tint pos = 0;\n\t\t\t\tfor(int k = 0; k < ok.size(); ++k)\n\t\t\t\t{\n\t\t\t\t\tif(heaviest < Vec[ok[k]].second.first)\n\t\t\t\t\t{\n\t\t\t\t\t\theaviest = Vec[ok[k]].second.first;\n\t\t\t\t\t\tpos = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << Vec[ok[pos]].first << endl;\n\t\t\t\tsum_weight -= Vec[ok[pos]].second.first;\n\t\t\t\tVec[ok[pos]].second.second = -9999999;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_N = 10;\nint n;\nint w[MAX_N], s[MAX_N];\nstring name[MAX_N];\n\nint ans_g;\nvector<int> ans;\n\nvoid dfs(int rest, int used, int g, vector<int> &order) {\n\tif(g >= ans_g) return;\n\tif(rest == 0) {\n\t\tans = order;\n\t\tans_g = g;\n\t\treturn;\n\t}\n\n\tint sum_wait = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tif((1 << i) & used) continue;\n\t\tsum_wait += w[i];\n\t}\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif((1 << i) & used) continue;\n\t\tif(sum_wait - w[i] > s[i]) continue;\n\n\t\torder.emplace_back(i);\n\t\tdfs(rest - 1, used | (1 << i), g + (n - rest + 1) * w[i], order);\n\t\torder.pop_back();\n\t}\n}\n\nint main() {\n\twhile(cin >> n && n) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> name[i] >> w[i] >> s[i];\n\t\t}\n\n\t\tvector<int> tmp;\n\t\tans_g = INT_MAX;\n\t\tans.clear();\n\t\tdfs(n, 0, 0, tmp);\n\n\t\tfor(const auto &idx : ans) {\n\t\t\tcout << name[idx] << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nstruct lunch{\n  int w,s;\n  char name[21];\n\n  bool operator < (const lunch &l)const{\n    if(w != l.w){\n      return w < l.w;\n    }else{\n      return s < l.s;\n    }\n  }\n};\n\nlunch N[10],ans[10];\nint n;\n\nvoid make(){\n  for(int i = 0 ; i < n ; i++){\n    ans[i] = N[i];\n  }\n}\n\nbool check(int &G){\n  int Ws1 = 0,Ws2 = 0;\n  for(int i = 0 ; i < n ; i++){\n    if(N[i].s < Ws2) return false;\n    Ws1 += (i+1)*N[i].w;\n    Ws2 += N[i].w;\n  }\n  G = Ws1;\n\n  return true;\n}\n\nint main(){\n  while(scanf(\"%d\" ,&n) ,n){\n    for(int i = 0 ; i < n ; i++){\n      scanf(\"%s %d %d\" ,N[i].name ,&N[i].w ,&N[i].s);\n    }\n    sort(N,N+n);\n\n    int G = 0,t;\n\n    do{\n      if(check(t)){\n\tif(G < t){\n\t  make();\n\t  G = t;\n\t}\n      }\n    }while(next_permutation(N,N+n));\n\n    for(int i = n-1 ; i >= 0 ; i--){\n      printf(\"%s\\n\" ,ans[i].name);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define eps (1e-9)\n#define equals(a,b) ((fabs((a)-(b))) < eps)\nusing namespace std;\n\nstruct P\n{\n  string name;\n  int w,s,index;\n  P(string name=\"$\",int w=inf,int s=inf,int index=-inf):name(name),w(w),s(s),index(index){}\n  bool operator < (const P& a)const\n  {\n    if(w != a.w)return w < a.w;\n    if(s != a.s)return s < a.s;\n    if(index != a.index)return index < a.index;\n    return name < a.name;\n  }\n};\n\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      P info[n];\n      string names[n];\n      double sum = 0;\n      rep(i,n)\n\t{\n\t  cin >> info[i].name >> info[i].w >> info[i].s;\n\t  info[i].index = i;\n\t  names[i] = info[i].name;\n\t  sum += info[i].w;\n\t}\n      sort(info,info+n);\n      int ans[n],total[n];\n      double G = inf;\n      do\n\t{\n\t  double fac = 0;\n\t  bool skip = false;\n\t  rep(i,n)\n\t    {\n\t      fac += (i+1)*info[i].w;\t  \n\t      total[i] = info[i].w + (i!=0?total[i-1]:0);\n\t    }\n\t  double pG = fac/sum;\n\t  if(equals(G,pG) || G < pG)continue;\n\t  \n\t  rep(i,n)\n\t    {\n\t      int on = (int)sum - total[i];\n\t      if(on > info[i].s)\n\t\t{\n\t\t  skip = true;\n\t\t  break;\n\t\t}\n\t    }       \n\t  if(skip)continue;\n\n\n\t  G = pG;\n\t  rep(i,n)ans[i] = info[i].index;\n\n\t}while(next_permutation(info,info+n));\n      rep(i,n)cout << names[ans[i]] << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n#define EPS (1e-8)\n\nstring name[10];\nint w[10], s[10];\nint num[10], an[10];\ndouble mi;\nint n;\n\nvoid dfs(int pos, double sum, double g) {\n\tif (pos == n) {\n\t\tg /= (double)sum;\n\t\tif (mi > g + EPS) {\n\t\t\tmi = g;\n\t\t\tREP(i, 10) an[i] = num[i];\n\t\t}\n\t}\n\telse {\n\t\tREP(i, n) if (num[i] == -1 && s[i] >= sum - EPS) {\n\t\t\tnum[i] = pos;\n\t\t\tdfs(pos + 1, sum + w[i], g + w[i] * (n - pos));\n\t\t\tnum[i] = -1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tREP(i, n) cin >> name[i] >> w[i] >> s[i];\n\n\t\tfill(num, num + n, -1);\n\t\tfill(an, an + n, -1);\n\t\tmi = INF;\n\n\t\tdfs(0, 0.0, 0.0);\n\t\tvector<int> ans(n);\n\t\tfor (int i = n - 1; i >= 0; i--) REP(j, n) if (an[j] == i) ans[n - i - 1] = j;\n\t\tREP(i, n) cout << name[ans[i]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<float.h>\n#include<algorithm>\nstruct S{char f[32];int w,s;}F[10];\nint main()\n{\n\tint n,w,s,i,a[10],r[10];\n\tdouble g,b;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tb=DBL_MAX;\n\t\tfor(i=0;i<n;++i)scanf(\"%s%d%d\",F[i].f,&F[i].w,&F[i].s),a[i]=i;\n\t\tdo\n\t\t{\n\t\t\tg=w=0;\n\t\t\tfor(i=n-1;i>=0;--i)\n\t\t\t{\n\t\t\t\tif(F[a[i]].s<w)goto N;\n\t\t\t\tw+=F[a[i]].w;\n\t\t\t\tg+=(i+1)*F[a[i]].w;\n\t\t\t}\n\t\t\tif(g<b)b=g,memcpy(r,a,sizeof(a));\nN:;\n\t\t}while(std::next_permutation(a,a+n));\n\t\tfor(i=0;i<n;++i)puts(F[r[i]].f);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[10];\nint use[10];\nchar str[10][21];\nint w[10];\nint s[10];\nint sum;\nint n;\nint best[10];\nint val;\nvoid solve(int a,int b){\n\tif(a==n){\n\t\tint p=0;\n\t\tfor(int i=0;i<n;i++)p+=w[dat[i]]*(i+1);\n\t\tif(p<val){\n\t\t\tval=p;\n\t\t\tfor(int i=0;i<n;i++)best[i]=dat[i];\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!use[i]&&s[i]>=b-w[i]){\n\t\t\t\tuse[i]=1;\n\t\t\t\tdat[a]=i;\n\t\t\t\tsolve(a+1,b-w[i]);\n\t\t\t\tuse[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tval=999999999;\n\t\tfor(int i=0;i<n;i++)scanf(\"%s%d%d\",str[i],w+i,s+i);\n\t\tsum=0;\n\t\tfor(int i=0;i<n;i++)sum+=w[i];\n\t\tsolve(0,sum);\n\t\tfor(int i=0;i<n;i++)printf(\"%s\\n\",str[best[i]]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< VI > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n\ntemplate < typename T > inline void input_n( vector< T > &out ) { copy_n( istream_iterator< T >( cin ), out.size(), out.begin() ); };\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) (c).begin(), (c).end()\n#define AALL( a, t ) (t*)a, (t*)a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define EM( n ) emplace( n )\n#define EB( n ) emplace_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nstruct Food\n{\n\tint id;\n\tstring name;\n\tdouble w, s;\n\n\tFood( const int id, const string &name, const int w, const int s ) :\n\t\tid( id ), name( name ), w( w ), s( s )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator<( const Food &rhs ) const\n\t{\n\t\treturn id < rhs.id;\n\t}\n};\n\ndouble center( const vector< Food > &foods )\n{\n\tconst int N = foods.size();\n\n\tfor ( int i = N - 1, sum = 0; 0 <= i; sum += foods[ i-- ].w )\n\t{\n\t\tif ( foods[i].s < sum )\n\t\t{\n\t\t\treturn numeric_limits< double >::max();\n\t\t}\n\t}\n\n\tdouble g = 0, ss = 0;\n\tREP( i, 0, N )\n\t{\n\t\tg += ( i + 1 ) * foods[i].w;\n\t\tss += foods[i].w;\n\t}\n\n\treturn g / ss;\n}\n\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int n; cin >> n, n; )\n\t{\n\t\tvector< Food > foods;\n\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tstring f;\n\t\t\tint w, s;\n\t\t\tcin >> f >> w >> s;\n\n\t\t\tfoods.emplace_back( i, f, w, s );\n\t\t}\n\n\t\tdouble ming = numeric_limits<double>::max();\n\t\tvector< Food > res;\n\n\t\tdo\n\t\t{\n\t\t\tconst double g = center( foods );\n\t\t\tif ( g < ming )\n\t\t\t{\n\t\t\t\tres = foods;\n\t\t\t\tming = g;\n\t\t\t}\n\t\t}\n\t\twhile ( next_permutation( ALL( foods ) ) );\n\n\t\tFOR( r, res )\n\t\t{\n\t\t\tcout << r.name << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n,a,tmp;\nint s[10],w[10];\nstring f[10],temp;\nint t[10];\nvector<int>ans;\n\nint get_weight(int);\nvoid swap_data(int);\nvoid sort_data();\n\nint main(){\n  while(cin>>n&&n!=0){\n    ans.clear();\n    for(int i=0;i<n;i++){\n      cin>>f[i];\n      cin>>w[i]>>s[i];\n    }\n\n    \n    sort_data();\n\n    //for(int i=0;i<n;i++)cout<<f[i]<<' '<<w[i]<<' '<<s[i]<<endl;\n    //cout<<'='<<endl;\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n-1;j++){\n\t  if(w[j]<w[j+1]){\n\t    swap_data(j);\n\t    \n\t    a=get_weight(j+1);\n\t    if(a>s[j])swap_data(j);\n\t    \n\n\t  }\n\t\n\t}\n      }\n    }\n    for(int i=0;i<n;i++)cout<<f[i]<<endl;\n    \n    \n  }\n  return 0;\n}\n\nint get_weight(int x){\n  int res=0;\n  for(int i=x;i<n;i++)res+=w[i];\n  return res;\n}\n\nvoid swap_data(int x){\n  \n  tmp=w[x];\n  w[x]=w[x+1];\n  w[x+1]=tmp;\n\n  tmp=s[x];\n  s[x]=s[x+1];\n  s[x+1]=tmp;\n\n  temp=f[x];\n  f[x]=f[x+1];\n  f[x+1]=temp;\n}\n\nvoid sort_data(){\n  for(int i=n-1;i>0;i--){\n    for(int j=0;j<i;j++){\n      if(s[j]<s[j+1])swap_data(j);\n      else if(s[j]==s[j+1]&&w[j]<w[j+1])swap_data(j);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<cmath>\n#include<sstream>\nusing namespace std;\n#define all(a) a.begin(),a.end()\ntypedef vector<int> vi;\nstruct food\n{\n\tstring name;\n\tint w,s;\n};\ntypedef vector<food> vf;\nint n;\nint main()\n{\n\twhile(cin>>n&&n)\n\t{\n\t\tvf a;\n\t\tvi ans,s;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfood f;\n\t\t\ts.push_back(i);\n\t\t\tcin>>f.name>>f.w>>f.s;\n\t\t\ta.push_back(f);\n\t\t}\n\t\tdouble t=9999999999999;\n\t\tdo\n\t\t{\n\t\t\tvi sum;\n\t\t\tdouble r=0,f=0;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tsum.push_back(a[s[i]].w);\n\t\t\t\tr+=(i+1)*a[s[i]].w;\n\t\t\t\tf+=a[s[i]].w;\n\t\t\t}\n\t\t\tfor(int i=n-1;i>0;i--)sum[i-1]+=sum[i];\n\t\t\tsum.push_back(0);\n\t\t\tbool ok=true;\n\t\t\tfor(int i=0;i<n;i++){if(sum[i+1]>a[s[i]].s)ok=false;}\n\t\t\tif(!ok)continue;\n\t\t\tif(t>r/f)\n\t\t\t{\n\t\t\t\tt=r/f;\n\t\t\t\tans=s;\n\t\t\t}\n\t\t}while(next_permutation(all(s)));\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcout<<a[ans[i]].name<<endl;\t\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<list>\n#include<map>\nusing namespace std;\n\nconst int MAX_F = 15;\n\nclass tabemono{\nprivate:\n\tint No;\n\tint W;\n\tint S;\npublic:\n\tint retS();\n\tint retW();\n\tint retNo();\n\tvoid setNo(int no);\n\tvoid setW(int w);\n\tvoid setS(int s);\n};\n\nint tabemono::retS(){\n\treturn S;\n}\n\nint tabemono::retW(){\n\treturn W;\n}\n\nint tabemono::retNo(){\n\treturn No;\n}\n\nvoid tabemono::setNo(int no){\n\tNo = no;\n}\n\nvoid tabemono::setW(int w){\n\tW = w;\n}\n\nvoid tabemono::setS(int s){\n\tS = s;\n}\n\nint main(){\n\tint n;\n\twhile(cin >>n){\n\t\tif(n == 0) break;\n\t\t\n\t\tlist<tabemono> hukuro;\n\t\tmultimap<int, int, greater<int> > tmpmap;\n\t\tstring food[MAX_F];\n\t\tint weight[MAX_F], strenght[MAX_F], sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >>food[i] >>weight[i] >>strenght[i];\n\t\t\tsum += weight[i];\n\t\t\ttmpmap.insert( map<int, int, greater<int> >::value_type(strenght[i], i) );\n\t\t}\n\t\t\n\t\tmap<int, int, greater<int> >::iterator itm;\n\t\tfor(itm = tmpmap.begin(); itm != tmpmap.end(); itm++){\n\t\t\ttabemono t;\n\t\t\tt.setNo((*itm).second);\n\t\t\tt.setW(weight[(*itm).second]);\n\t\t\tt.setS(strenght[(*itm).second]);\n\t\t\thukuro.push_back(t);\n\t\t}\n\t\t\n\t\twhile(hukuro.empty() != 1){\n\t\t\tint max = -1;\n\t\t\tlist<tabemono>::iterator maxit = hukuro.begin();\n\t\t\tlist<tabemono>::iterator itl;\n\t\t\tif(hukuro.size() != 1){\n\t\t\t\tfor(itl = hukuro.begin(); itl != hukuro.end(); itl++){\n\t\t\t\t\tint tmp = (*itl).retW();\n \t\t\t\t\tif((*itl).retS() < (sum - tmp)){\n\t\t\t\t\t\titl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp > max){\n\t\t\t\t\t\tmax = tmp;\n\t\t\t\t\t\tmaxit = itl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout <<food[(*maxit).retNo()] <<endl;\n\t\t\tsum -= (*maxit).retW();\n\t\t\thukuro.erase(maxit);\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nstruct edge {\n  string Name;\n  int weight, deep;\n  bool operator<(const edge& e) const {\n    return(weight > e.weight);\n  }\n};\n\nint main()\n{\n  int n;\n  while(cin >> n, n) {\n    list< edge > edges;\n    int ALL = 0;\n    for(int i = 0; i < n; i++) {\n      edge e;\n      cin >> e.Name >> e.weight >> e.deep;\n      ALL += e.weight;\n      edges.push_back(e);\n    }\n    edges.sort();\n    while(!edges.empty()) {\n      for(list< edge >::iterator it = edges.begin(); ; ++it) {\n        if(ALL - it -> weight <= it -> deep) {\n          cout << it -> Name << endl;\n          ALL -= it -> weight;\n          edges.erase(it);\n          break;\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\nusing namespace std;\nint n, w[1000], s[1000];\nstring S[1000]; vector<int>b; int maxn = 100000000;\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i] >> w[i] >> s[i];\n\t}\n\tvector<int>a(n, 0);\n\tfor (int i = 0; i < n; i++)a[i] = i;\n\tdo {\n\t\tint sum2 = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tsum += w[a[j]];\n\t\t\t}\n\t\t\tif (sum > s[i]) goto E;\n\t\t}\n\t\tfor (int i = 0; i < n; i++)sum2 += i*w[i];\n\t\tif (maxn > sum2)b = a;\n\tE:;\n\t} while (next_permutation(a.begin(), a.end()));\n\tfor (int i = 0; i < n; i++)cout << S[a[i]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <numeric>\nusing namespace std;\n\nstring F[10];\nint W[10], S[10];\n\nint main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    int N; cin >> N;\n    if(N == 0) break;\n    for(int i = 0; i < N; ++i) {\n      cin >> F[i] >> W[i] >> S[i];\n    }\n    vector<int> ord(N);\n    for(int i = 0; i < N; ++i) ord[i] = i;\n    double ansG = 1e9;\n    vector<int> ansOrd;\n    do {\n      bool ok = true;\n      for(int i = 0; i < N; ++i) {\n        int w = 0;\n        for(int j = i + 1; j < N; ++j) w += W[ord[j]];\n        if(w > S[ord[i]]) ok = false;\n      }\n      if(ok) {\n        int g = 0;\n        for(int i = 0; i < N; ++i) {\n          g += (i + 1) * W[ord[i]];\n        }\n        double G = 1.0 * g / accumulate(W, W + N, 0);\n        if(ansG > G) {\n          ansG = G;\n          ansOrd = ord;\n        }\n      }\n    } while(next_permutation(ord.begin(), ord.end()));\n    for(int item : ansOrd) {\n      cout << F[item] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \n#include <sstream>\nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n#define ll long long int\n#define gcd(a,b) __gcd(a,b)\n\nint GCD(int a, int b) {if(!b) return a; return gcd(b, a%b);}\nint lcm(int a, int b) {return a*b / gcd(a, b);}\n\nstruct food{\n  string fn;\n  int g;\n  int s;\n};\nint f[10],an[10],m;\nfood fd[10],sf;\nint ans(int n,int s){\n  if(n==-1){\n    for(int i = m - 1 ; i >= 0 ; i --)\n      cout << fd[an[i]].fn << endl; \n      return 1;\n  }\n for (int i=m-1;i>=0;i--) {\n        if (f[i]==0 && fd[i].s>=s-fd[i].g) {\n            f[i]=1; an[n]=i;\n            if (ans(n-1,s-fd[i].g)==1) return 1; \n            f[i]=0;\n        }\n  }\n  return 0;\n}\n\nint main(void){\n  int i,j,s;\n  while(cin >> m){\n    if (m==0)break;\n    for(i = 0 , s = 0 ; i < m ; i ++){\n      f[i] = 0 ; \n      cin >> fd[i].fn >> fd[i].g >> fd[i].s;\n      s+=fd[i].g;\n    }\n    for(i = 1 ; i < m ; i ++){\n      for(j = 0  ; j < m - i ; j ++){\n\tif(fd[j].g>fd[j+1].g){\n\t  sf=fd[j];\n\t  fd[j] = fd[j+1];\n\t  fd[j+1] = sf;\n\t}\n      }\n    }\n    ans(m-1,s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef pair<int,string> P;\ntypedef pair<int,P> PP;\n\nint n,a;\nPP in[10],tmp;\nint t[10];\nvector<int>ans;\n\nint get_weight(int);\n\nint main(){\n  while(cin>>n&&n!=0){\n    ans.clear();\n    for(int i=0;i<n;i++)cin>>in[i].second.second>>in[i].second.first>>in[i].first;\n    sort(in,in+n);\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n-1;j++){\n\ta=get_weight(j)+in[j+1].second.first;\n\tif(a<=in[j].first&&in[j].second.first>=in[j+1].second.first){\n\t  tmp=in[j];in[j]=in[j+1];in[j+1]=tmp;\n\t}\n      }\n    }\n    \n    for(int i=n-1;i>=0;i--)cout<<in[i].second.second<<endl;\n    \n    \n  }\n  return 0;\n}\n\nint get_weight(int x){\n  int res=0;\n  for(int i=0;i<x;i++)res+=in[i].second.first;\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<functional>\n\nconst int MAX_N = 10;\n\nstruct Data {\n\tstd::string name;\n\tint weight, max_weight;\n\tData() = default;\n\tData(int _w, int _m, const std::string& _n) : weight(_w), max_weight(_m), name(_n) {}\n\n\tbool operator<(const Data& rhs) const {\n\t\treturn (weight == rhs.weight) ? \n\t\t\t(max_weight==rhs.max_weight)? \n\t\t\tname < rhs.name : max_weight < rhs.max_weight : weight < rhs.weight;\n\t}\n\tbool operator>(const Data& rhs) const{\n\t\treturn (weight == rhs.weight) ?\n\t\t\t(max_weight == rhs.weight) ?\n\t\t\tname > rhs.name : max_weight > rhs.max_weight : weight > rhs.weight;\n\t}\n};\n\n\nint n, sum;\nstd::vector<Data> data;\nstd::string ans[MAX_N];\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n;\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tsum = 0;\n\t\tint _w, _m;\n\t\tstd::string _n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstd::cin >> _n >> _w >> _m;\n\t\t\tdata.push_back(Data(_w, _m, _n));\n\t\t\tsum += data[i].weight;\n\t\t}\n\n\t\tstd::sort(data.begin(), data.end(), std::greater<Data>());\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < data.size(); ++j) {\n\t\t\t\tif (data[j].max_weight >= sum - data[j].weight) {\n\t\t\t\t\tsum -= data[j].weight;\n\t\t\t\t\tans[i] = data[j].name;\n\t\t\t\t\tdata.erase(data.begin() + j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tstd::cout << ans[i] << std::endl;\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\nlong n,i,j,k,w[10],s[10],sw;\nstring f[10];\nwhile(cin>>n){\nif(n==0)break;\nfor(i=0;i<n;i++)cin>>f[i]>>w[i]>>s[i];\nfor(sw=0,i=0;i<n;i++)sw+=w[i];\nfor(k=0;k<n;k++){\nfor(j=-1,i=0;i<n;i++){\nif(sw-w[i]<=s[i]){\nif(j==-1)j=i;else if(w[j]<w[i])j=i;\n}\n}\ncout<<f[j]<<endl;\nsw-=w[j];w[j]=0;\n}\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<string>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<complex>\nusing namespace std ;\ntypedef vector<int> vi ;\ntypedef vector<vi> vvi ;\ntypedef vector<string> vs ;\ntypedef pair<int, int> pii; \ntypedef long long ll ;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n\nstruct food{\n\tstring n;\n\tint w;\n\tint s;\n\tint used;\n};\n\nint main(void){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<food> vf;\n\t\trep(i,n){\n\t\t\tfood f;\n\t\t\tcin >> f.n >> f.w >> f.s;\n\t\t\tf.used = 0;\n\t\t\tvf.push_back(f);\n\t\t}\n\t\t\n\t\tint weight = 0 ;\n\t\trep(i,n)weight += vf[i].w;\n\t\trep(i,n){\n\t\t\tvi vec;\n\t\t\trep(j,n){\n\t\t\t\tif(!vf[j].used && vf[j].s >= weight - vf[j].w){\n\t\t\t\t\tvec.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wmax = -1;\n\t\t\tint u;\n\t\t\trep(j,vec.size()){\n\t\t\t\tif(wmax < vf[vec[j]].w){\n\t\t\t\t\twmax = vf[vec[j]].w;\n\t\t\t\t\tu = vec[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<< vf[u].n << endl;\n\t\t\tvf[u].used = 1;\n\t\t\tweight -= vf[u].w;\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <iomanip>\n#include <utility>\n#include <cstdlib>\n#include <sstream>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <ctime>\n#include <queue>\n#include <deque>\n#include <cmath>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nint n;\nstring f[20];\nint w[20],s[20];\n\nbool isOK(vi num){\n    int cap=99999999;\n    \n    rep(i,num.size()){\n        cap=min(cap-w[num[i]],s[num[i]]);\n    }\n    if(cap>=0)return true;\n    else return false;\n}\n\ndouble solve(vi num){\n    \n    int up=0;\n    rep(i,num.size()){\n        up+=(i+1)*w[num[i]];\n    }\n\n    int div=0;\n    rep(i,num.size()){\n        div+=w[num[i]];\n    }\n\n    return (double)up/div;\n}\n\n\nint main() {\n    \n    while(cin>>n){\n        if(n==0)break;\n        \n        vi num;\n        rep(i,n){\n            num.pb(i);\n            cin>>f[i]>>w[i]>>s[i];\n        }\n        \n        double Gmin=99999999;\n        vi ans;\n        do{\n            if( isOK(num) ){\n                double res=solve(num);\n                \n                \n                if(Gmin>res){\n                    Gmin=res;\n                    ans=num;\n                    \n                }\n            }\n        }while( next_permutation(all(num)) );\n        \n        rep(i,n){\n            cout<<f[ans[i]]<<endl;\n        }\n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require sqrt ceil floor\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <stdint.h>\t// require uint64_t\n#include <fstream>\t// require freopen\n\nusing namespace std;\n\ntypedef pair <pair<int, int>, string > ITEM;\t// ACeÌd³AACeÌãÉu¯éd³ÌãÀAACe¼\n\nint memo[10][10];\t\t// s: ACe¼ ñ:½iÚ© -1: Ü¾ãÉÏßé©Ç¤©¢èA0:ÏßÈ¢ 1: Ïßé\nvector <ITEM> list;\nint N;\nint minG;\nvector <int> minorder;\nint total;\n\nint getG (vector <int> order )\n{\n\tint res = 0;\n\n\tfor (int i = 0; i < order.size(); ++i ){\n\t\tres += (i+1)*(list[order[i]].first.first);\n\t} // end for\n\n\treturn res;\n}\n\nvoid bt (vector <int> & order, int curr )\n{\n\tif (curr == N ){\n\t\tint currG = getG (order );\n\t\tif (currG < minG ){\n\t\t\tminorder = order;\n\t\t\tminG = currG;\n\t\t} // end if\n\t\treturn;\n\t} // end if\n\n\tif (order[curr] != -1 && memo[order[curr]][curr] == 0 ){\n\t\treturn;\n\t} // end if\n\n\tif (order[curr] == -1 ){\n\t\tvector <bool> used (N, false );\n\t\tfor (int i = 0; i < curr; ++i ){\n\t\t\tused[order[i]] = true;\n\t\t} // end if\n\n\t\tfor (int i = 0; i < N; ++i ){\n\t\t\tif (!used[i] ) {\n\t\t\t\torder[curr] = i;\n\t\t\t\tint curr_w = total;\n\t\t\t\tfor (int j = 0; j <= curr; ++j ){\n\t\t\t\t\tcurr_w -= list[order[j]].first.first;\n\t\t\t\t} // end for\n\t\t\t\tif (curr_w <= list[order[curr]].first.second ){\n\t\t\t\t\tmemo[order[curr]][curr] = 1;\n\t\t\t\t\tbt (order, curr + 1 );\n\t\t\t\t}else{\n\t\t\t\t\tmemo[order[curr]][curr] = 0;\n\t\t\t\t}// end if\n\t\t\t\torder[curr] = -1;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end if\n\n}\n\nvoid init (int n )\n{\n\tN = n;\n\tlist.clear();\n\tlist.resize(n);\n\tminorder.clear();\n\tminorder.resize(n);\n\ttotal = 0;\n\tminG = INT_MAX;\n\tmemset (memo, -1, sizeof(memo) );\n}\t\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.lunch\", \"r\", stdin );\n\tint n;\n\n\twhile (cin >> n && n ){\n\t\tinit (n );\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> list[i].second;\n\t\t\tcin >> list[i].first.first;\t// w\n\t\t\tcin >> list[i].first.second;\t// s\n\t\t\ttotal += list[i].first.first; \n\t\t} // end for\n\t\tvector <int> order(n, -1 );\n\n\t\tbt (order, 0 );\n\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\tcout << list[minorder[i]].second << endl;\n\t\t} // end for\n\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    vector<int> ans(n), per(n), w(n), s(n);\n    vector<string> name(n);\n    int g = INT_MAX;\n    REP(i,n){\n      cin>>name[i]>>w[i]>>s[i];\n      per[i] = i;\n    }\n    do{\n      int gg = 0;\n      int ww = 0;\n      bool flag = true;\n      for(int i=n-1; i>=0; i--){\n\tint pp = per[i];\n\tif(s[pp] < ww){\n\t  flag = false;\n\t  break;\n\t}\n\tww += w[pp];\n\tgg += (i+1) * w[pp];\n      }\n      if(flag && g > gg){\n\tg = gg;\n\tans = per;\n      }\n    }while(next_permutation(per.begin(), per.end()));\n    \n    REP(i,n) cout << name[ans[i]] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define MAX_N 1000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nstruct FOOD{\n\tstring name;\n\tint w;\n\tint s;\n};\n\nbool checkWeight(const struct FOOD* food,const int* table,int n){\n\tfor(int i=0;i<n;i++){\n\t\tint sum = 0;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tsum += food[table[j]].w;\n\t\t}\n\t\tif(food[table[i]].s < sum) return false;\n\t}\n\n\treturn true;\n}\n\ndouble getG(const struct FOOD* food,const int* table,int n){\n\n\tdouble G=0;\n\tdouble sum=0;\n\tfor(int i=0;i<n;i++){\n\t\tG += (double)food[table[i]].w * (i+1);\n\t\tsum += (double)food[table[i]].w;\n\t}\n\treturn G / sum;\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tstruct FOOD* food = new struct FOOD[n];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar buf[64];\n\t\t\tint w,s;\n\t\t\tscanf(\"%s %d %d\",buf,&w,&s);\n\t\t\tfood[i].name = buf;\n\t\t\tfood[i].s = s;\n\t\t\tfood[i].w = w;\n\t\t}\n\n\t\tint* table = new int[n];\n\t\tfor(int i=0;i<n;i++) table[i] = i;\n\n\t\tint* res = new int[n]();\n\t\tdouble minG = 1000000.0;\n\n\t\tdo{\n\t\t\tdouble tmpG;\n\t\t\tif(checkWeight(food,table,n) &&\n\t\t\t\tminG > (tmpG = getG(food,table,n))){\n\t\t\t\t\tcopy(table,table+n,res);\n\t\t\t\t\tminG = tmpG;\n\t\t\t}\n\t\t}while(next_permutation(table,table+n));\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tprintf(\"%s\\n\",food[res[i]].name.c_str());\n\t\t}\n\n\t\tdelete[] food;\n\t\tdelete[] table;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int INF = 1e9;\ntypedef vector<int> iv;\n\ndouble G;\nint N;\nvector<int> u;\n\nbool check(int n, iv &used, iv &w, iv &s){\n  int sum = 0;\n  REP(i, N) if(used[i] != -1) sum += w[i];\n  return sum <= s[n];\n}\n\nvoid dfs(int sum, int cnt, iv &used, iv &w, iv &s, vector<string> &f){\n  if(cnt <= 0){\n    double a = 0, b = 0;\n    REP(i, N){\n      a += used[i] * w[i];\n      b += w[i];\n    }\n    if(a / b < G){\n      G = a / b;\n      u = used;\n    }\n    return ;\n  }\n  REP(i, N){\n    if(used[i] != -1 || !check(i, used, w, s)) continue;\n    used[i] = cnt;\n    dfs(sum + w[i], cnt - 1, used, w, s, f);\n    used[i] = -1;\n  }\n}\n\nint main() {\n  while(cin >>N){\n    G = INF;\n    u = vector<int>(N, -1);\n    vector<int> w(N), s(N), used(N, -1);\n    vector<string> f(N);\n    REP(i, N) cin >>f[i] >>w[i]>>s[i];\n    dfs(0, N, used, w, s, f);\n    FOR(i, 1, N + 1) REP(j, N) if(u[j] == i) cout <<f[j] <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \n#include <sstream>\nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n#define ll long long int\n#define gcd(a,b) __gcd(a,b)\n#define pb(a) push_back(a)\nint GCD(int a, int b) {if(!b) return a; return gcd(b, a%b);}\nint lcm(int a, int b) {return a*b / gcd(a, b);}\n\nstruct Food{\n  vector<int> num;\n  double g;\n  bool operator<(const Food& f) const{\n    return g < f.g;\n  }\n};\n\nint main(void){\n  vector<int> num;\n  vector<pair<int,int> > a;\n  vector<string> name;\n  int n;\n  while(cin>>n,n){\n    num.clear();\n    a.clear();\n    name.clear();\n    rep(i,n){\n      string f;\n      int w,s;\n      cin>>f>>w>>s;\n      a.push_back(make_pair(w,s));\n      name.push_back(f);\n      num.push_back(i);\n    }\n    vector<Food> food;\n\n    do{\n      bool flag = true;\n      rep(i,num.size() - 1){\n\tint count = 0;\n\tloop(j,i+1,num.size()){\n\t  count  += a[num[j]].first;\n\t}\n\tif(a[num[i]].second < count){\n\t  flag = false;\n\t}\n      }\n      if(flag){\n\tFood f;\n\tcopy(num.begin(),num.end(),back_inserter(f.num));\n\n\tdouble t_a = 0, t_b = 0;\n\tint j = 1;\n\trep(i,num.size()){\n\t  t_a += j*a[num[i]].first;\n\t  t_b += a[num[i]].first;\n\t  j ++;\n\t}\n\tf.g = t_a / t_b;\n\tfood.push_back(f);\n      }\n    }while(next_permutation(num.begin(),num.end()));\n    sort(food.begin(),food.end());\n    rep(i,food[0].num.size())\n      cout<<name[food[0].num[i]]<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\nusing namespace std;\nstring s[12];\nint n,a[11],an[11];\ndouble v[12],w[12];\nmain(){\n  while(cin>>n,n){\n    double ans=1e9,t,x,y;\n    r(i,n)a[i]=i;\n    r(i,n)cin>>s[i]>>w[i]>>v[i];\n    do{\n      int f=0;\n      r(i,n){t=0;\n        R(j,i+1,n)t+=w[a[j]];\n        if(v[a[i]]<t)f++;\n      }\n      if(f)continue;\n      y=x=0;\n      r(i,n)x+=w[a[i]]*(i+1),y+=w[a[i]];\n      if(x/y<ans){\n        ans=x/y;\n        r(i,n)an[i]=a[i];\n      }\n    }while(next_permutation(a,a+n));\n    r(i,n)cout<<s[an[i]]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cfloat>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        vector<string> f(n);\n        vector<int> w(n), s(n), a(n);\n        double wsum = 0;\n        for(int i = 0; i < n; i++){\n            cin >> f[i] >> w[i] >> s[i];\n            a[i] = i;\n            wsum += w[i];\n        }\n        vector<int> ans(n);\n        double g = DBL_MAX;\n        do{\n            double accw = 0, tmpg = 0;\n            bool valid = true;\n            for(int i = 0; i < n; i++){\n                if(s[a[i]] < accw){\n                    valid = false;\n                    break;\n                }\n                accw += w[a[i]];\n                tmpg += (n-i)*w[a[i]];\n            }\n            if(valid && tmpg/wsum < g){\n                g = tmpg/wsum;\n                ans = a;\n            }\n        }while(next_permutation(a.begin(), a.end()));\n        for(int i = n-1; i >= 0; i--){\n            cout << f[ans[i]] << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(2e5 + 5);\nconst double EPS = 1e-8;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nint main() {\n    while(1){\n        int n, w[15], s[15], mi=IINF;\n        string f[15];\n        vector<int> v, ans;\n        cin >> n;\n        if(n==0)break;\n        REP(i,n){\n            cin >> f[i] >> w[i] >> s[i];\n            v.push_back(i);\n        }\n        while(1){\n            int cum[15]{}, tmp=0;\n            REP(i,n) cum[i+1] += cum[i] + w[v[i]];\n            bool ok = true;\n            REP(i,n) ok &= s[v[i]] >= cum[n]-cum[i+1];\n            if(ok){\n                REP(i,n){\n                    tmp += w[v[i]]*(i+1);\n                }\n                if(tmp < mi){\n                    mi = tmp;\n                    ans = v;\n                }\n            }\n            if(!next_permutation(ALL(v)))break;\n        }\n        for(auto i : ans){\n            cout << f[i] << endl;\n        }\n    }\n    return 0;\n}   \n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<set>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\n#define MOD 1000000007\n#define ARRAY_MAX 100005\n\nconst int INF = 1e9+7;\n\n\nint main(){\n\n    int n;\n    while(cin >> n,n){\n\n        vector<int> p(n);//配列のインデックス\n        vector<string> f(n);\n        vector<int> w(n),s(n),ans(n);\n        int mini = INF;\n\n        for(int i = 0;i < n;i++){\n            p[i] = i;\n        }\n\n        for(int i = 0;i < n;i++){\n            cin >> f[i] >> w[i] >> s[i];\n        }\n\n        do{\n\n            bool flag = true;\n            int cnt = 0,g = 0;\n\n            for(int i = 0;i < n;i++){\n\n                flag &= (cnt <= s[p[i]]);//上から見る\n                cnt += w[p[i]];\n                g += (n-i)*w[p[i]];\n            }\n\n            if(flag == true && g < mini){\n                ans = p;\n                mini = g;\n            }\n\n        }while(next_permutation(p.begin(),p.end()));\n\n        for(int i = n-1;i >= 0;i--){\n            cout << f[ans[i]] << endl;\n        }\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,j,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f));\n\t\tsort(items.begin(),items.end());\n\t\tS=99999;\n\t\tdo{\n\t\t\tfor(s=w=i=0;i<n;i++){\n\t\t\t\tif(items[i].first.second<w)break;\n\t\t\t\tw+=items[i].first.first;\n\t\t\t\ts+=(n-i)*items[i].first.first;\n\t\t\t}\n\t\t\tif(i==n){\n\t\t\t\tif(s<S)S=s,result=items;\n\t\t\t}else{\n\t\t\t\tfor(s=w=1;i<n;w++,i++)s*=w;\n\t\t\t\tfor(i=0;i<s-1;i++)next_permutation(items.begin(),items.end());\n\t\t\t}\n\t\t}while(next_permutation(items.begin(),items.end()));\n\t\treverse(result.begin(),result.end());\n\t\tfor(i=0;i<n;i++)cout<<result[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tfor(string f;cin>>n,n;){\n\t\tvector<item>items;\n\t\tvector<int>num,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f)),num.push_back(i);\n\t\tS=99999;\n\t\tdo{\n\t\t\tfor(s=w=0,i=n-1;~i;i--){\n\t\t\t\tpair<int,int> weight=items[num[i]].first;\n\t\t\t\tif(weight.second<w)break;\n\t\t\t\tw+=weight.first;\n\t\t\t\ts+=(i+1)*weight.first;\n\t\t\t}\n\t\t\tif(i<0&&s<S)S=s,result=num;\n\t\t}while(next_permutation(num.begin(),num.end()));\n\t\tfor(i=0;i<n;i++)cout<<items[result[i]].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\nusing namespace std;\nint n, w[1000], s[1000];\nstring S[1000]; vector<int>b; int maxn;\nint main() {\n\twhile (true) {\n\t\tcin >> n; b.clear(); maxn = 1 << 30;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> S[i] >> w[i] >> s[i];\n\t\t}\n\t\tvector<int>a(n, 0);\n\t\tfor (int i = 0; i < n; i++)a[i] = i;\n\t\tdo {\n\t\t\tint sum2 = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tsum += w[a[j]];\n\t\t\t\t}\n\t\t\t\tif (sum > s[i]) goto E;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)sum2 += i*w[i];\n\t\t\tif (maxn > sum2)b = a;\n\t\tE:;\n\t\t} while (next_permutation(a.begin(), a.end()));\n\t\tfor (int i = 0; i < n; i++)cout << S[a[i]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f));\n\t\tsort(items.begin(),items.end());\n\t\tS=999999999;\n\t\tdo{\n\t\t\tfor(s=w=i=0;i<n;i++){ //from upper\n\t\t\t\tif(items[i].first.second<w)break;\n\t\t\t\tw+=items[i].first.first;\n\t\t\t\ts+=(n-i)*items[i].first.first;\n\t\t\t}\n\t\t\tif(i==n&&s<S)S=s,result=items;\n\t\t}while(next_permutation(items.begin(),items.end()));\n\t\treverse(result.begin(),result.end());\n\t\tfor(i=0;i<n;i++)cout<<result[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\ntypedef pair <string, II> NODE;\ntypedef vector <NODE> NODES;\n\nvoid solve( int n, NODES nodes ) {\n    int ming = INT_MAX;\n    VS L;\n    sort( nodes.begin(), nodes.end() );\n    do {\n        int wsum = 0, g = 0;\n        for ( int i = 0; i < n; ++ i ) {\n            if ( wsum > nodes[i].second.second ) goto out_1;\n            wsum += nodes[i].second.first;\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            g += ( n - i ) * nodes[i].second.first;\n            if ( g >= ming ) goto out_1;\n        }\n        if ( g < ming ) {\n            ming = g;\n            VS T;\n            for ( int i = 0; i < n; ++ i ) {\n                T.push_back( nodes[i].first );\n            }\n            L = T;\n        }\n    out_1:;\n    } while ( next_permutation( nodes.begin(), nodes.end() ) );\n\n    reverse( L.begin(), L.end() );\n    for ( int i = 0; i < n; ++ i ) {\n        cout << L[i] << endl;\n    }\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        NODES nodes( n );\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> nodes[i].first >> nodes[i].second.first >> nodes[i].second.second;\n        }\n        solve( n, nodes );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstruct lunch {\n    int w, s;\n    char name[21];\n \n    bool operator < (const lunch &l) const {\n\tif (w != l.w) {\n\t    return w < l.w;\n\t} else {\n\t    return s < l.s;\n\t}\n    }\n};\n \nlunch N[10], ans[10];\nint n;\n \nvoid make()\n{\n    for (int i = 0; i < n; i++) {\n\tans[i] = N[i];\n    }\n}\n \nbool check(int &G)\n{\n    int Ws1 = 0, Ws2 = 0;\n    for (int i = 0; i < n; i++) {\n\tif (N[i].s < Ws2) return false;\n\tWs1 += (i+1)*N[i].w;\n\tWs2 += N[i].w;\n    }\n    G = Ws1;\n    return true;\n}\n \nint main()\n{\n    while (scanf(\"%d\", &n), n) {\n\tfor (int i = 0; i < n; i++) {\n\t    scanf(\"%s %d %d\", N[i].name, &N[i].w, &N[i].s);\n\t}\n\tsort(N, N+n);\n \n\tint G = 0,t;\n \n\tdo {\n\t    if (check(t)) {\n\t\tif (G < t) {\n\t\t    make();\n\t\t    G = t;\n\t\t}\n\t    }\n\t} while (next_permutation(N, N+n));\n \n\tfor (int i = n-1; i >= 0; i--) {\n\t    printf(\"%s\\n\", ans[i].name);\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\nusing namespace std;\nint n, w[1000], s[1000];\nstring S[1000]; vector<int>b; int maxn = 100000000;\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S[i] >> w[i] >> s[i];\n\t}\n\tvector<int>a(n, 0);\n\tfor (int i = 0; i < n; i++)a[i] = i;\n\tdo {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint sum = 0;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tsum += w[a[j]];\n\t\t\t}\n\t\t\tif (sum > s[i]) goto E;\n\t\t}\n\t\tint sum2 = 0;\n\t\tfor (int i = 0; i < n; i++)sum2 += i*w[i];\n\t\tif (maxn > sum2)b = a;\n\tE:;\n\t} while (next_permutation(a.begin(), a.end()));\n\tfor (int i = 0; i < n; i++)cout << S[a[i]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst double EPS = 1e-6;\n\nint main(void) {\n\tint N;\n\twhile (cin >> N, N) {;\n\t\tvector<string> F(N);\n\t\tVI W(N), S(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> F[i] >> W[i] >> S[i];\n\t\t}\n\n\t\tVI p(N);\n\t\tiota(p.begin(), p.end(), 0);\n\n\t\tdouble ans = 1e+8;\n\t\tVI best_p(p.begin(), p.end());\n\n\t\tdo {\n\t\t\tdouble g = 0, gt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg += (i + 1) * W[p[i]];\n\t\t\t\tgt += W[p[i]];\n\t\t\t}\n\t\t\tg /= gt;\n\n\t\t\tbool flg = true;\n\t\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\t\tsum += W[p[j]];\n\t\t\t\t}\n\t\t\t\tflg &= sum <= S[p[i]];\n\t\t\t}\n\n\t\t\tif (flg && g < ans + EPS) {\n\t\t\t\tans = g;\n\t\t\t\tswap(best_p, p);\n\t\t\t}\n\t\t} while (next_permutation(p.begin(), p.end()));\n\n\t\tfor (auto i : best_p) {\n\t\t\tcout << F[i] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <complex>\n\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define tr(c, i) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define rtr(c, i) for (typeof((c).rbegin()) i = (c).rbegin(); i != (c).rend(); --i)\n#define contains(c, x) ((c).find(x) != (c).end())\n#define Contains(c, x) (find(all(c), x) != (c).end())\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) REP(i, 0, (n))\n#define To_String to_string< char,std::char_traits<char>,std::allocator<char> >\n\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<string> f(n);\n\t\tvector<int> w(n), s(n);\n\t\trep(i, n) cin >> f[i] >> w[i] >> s[i];\n\t\tvector<int> a(n), res;\n\t\tint maxg = 0;\n\t\trep(i, n) a[i] = i;\n\t\tdo {\n\t\t\tint sw = 0, g = 0;\n\t\t\tbool ok = true;\n\t\t\trep(i, n) {\n\t\t\t\tif (sw > s[a[i]]) { ok = false; break; }\n\t\t\t\tsw += w[a[i]];\n\t\t\t\tg += (i+1) * w[a[i]];\n\t\t\t}\n\t\t\tif (maxg < g) { maxg = g; res = a; }\n\t\t} while (next_permutation(all(a)));\n\t\treverse(all(res));\n\t\trep(i, n) cout << f[res[i]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <iterator>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nstruct Food\n{\n\tvector<int> num;\n\tdouble g;\n\n\tbool operator < (const Food& f) const\n\t{\n\t\treturn g < f.g;\n\t}\n};\n\nint main()\n{\n\tvector<int> num;\n\tvector<pair<int,int> > a;\n\tvector<string> name;\n\tint n;\n\twhile(cin >> n && n)\n\t{\n\t\tnum.clear();\n\t\ta.clear();\n\t\tname.clear();\n\t\trep(i,n)\n\t\t{\n\t\t\tstring f;\n\t\t\tint w,s;\n\t\t\tcin >> f >> w >> s;\n\n\t\t\ta.push_back(make_pair(w,s));\n\t\t\tname.push_back(f);\n\t\t\tnum.push_back(i);\n\t\t}\n\n\t\tvector<Food> food;\n\n\t\tdo\n\t\t{\n\t\t\tbool flag = true;\n\n\t\t\trep(i,num.size()-1)\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tREP(j,i+1,num.size())\n\t\t\t\t{\n\t\t\t\t\tcount += a[num[j]].first;\n\t\t\t\t}\n\n\t\t\t\tif(a[num[i]].second < count)\n\t\t\t\t{\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tFood f;\n\t\t\t\tcopy(num.begin(),num.end(),back_inserter(f.num));\n\t\t\t\t\n\t\t\t\tdouble t_a = 0,t_b = 0;\n\t\t\t\tint j = 1;\n\t\t\t\trep(i,num.size())\n\t\t\t\t{\n\t\t\t\t\tt_a += j*a[num[i]].first;\n\t\t\t\t\tt_b += a[num[i]].first;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tf.g = t_a / t_b;\n\t\t\t\tfood.push_back(f);\n\t\t\t}\n\t\t}while(next_permutation(num.begin(),num.end()));\n\t\t\n\t\tsort(food.begin(),food.end());\n\n\t\trep(i,food[0].num.size())\n\t\t{\n\t\t\tcout << name[food[0].num[i]] << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items;\n\t\tvector<int> num,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f)),num.push_back(i);\n\t\tS=99999;\n\t\tdo{\n\t\t\tfor(s=w=0,i=n-1;~i;i--){\n\t\t\t\tif(items[num[i]].first.second<w)break;\n\t\t\t\tw+=items[num[i]].first.first;\n\t\t\t\ts+=(i+1)*items[num[i]].first.first;\n\t\t\t}\n\t\t\tif(i<0&&s<S)S=s,result=num;\n\t\t}while(next_permutation(num.begin(),num.end()));\n\t\tfor(i=0;i<n;i++)cout<<items[result[i]].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint n;\nstring name[15];\nint f[11],w[11],s[11];\nint order[11],flag[11],res[11];\nint ming,sumw;\n\nvoid func(int x,int g,int lw){\n\tif(x==n){\n\t\tif(ming>g){\n\t\t\tfor(int i=0;i<n;i++)res[i]=order[i];\n\t\t\tming=g;\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!flag[i]){\n\t\t\t\tflag[i]=1;\n\t\t\t\torder[x]=i;\n\t\t\t\tif(lw-w[i]<=s[i])func(x+1,g+(x+1)*w[i],lw-w[i]);\n\t\t\t\tflag[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(order,0,sizeof(int));\n\t\tmemset(res,0,sizeof(int));\n\t\tmemset(flag,0,sizeof(int));\n\t\tming=99999999;\n\t\tsumw=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> name[i] >> w[i] >> s[i];\n\t\t\tsumw+=w[i];\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tflag[i]=1;\n\t\t\torder[0]=i;\n\t\t\tif(sumw-w[i]<=s[i])func(1,w[i],sumw-w[i]);\n\t\t\tflag[i]=0;\n\t\t}\n\t\tfor(int i=0;i<n;i++)cout << name[res[i]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define EPS 1e-9\nusing namespace std;\nstring str;\nint w[10], s[10];\nint main() {\n    int n;\n    while (scanf(\"%d\",&n)) {\n        if (n==0) break;\n        string h[n];\n        int perm[n];\n        for (int i=0; i<n; i++) {\n            cin>>str>>w[i]>>s[i];\n            h[i]=str;\n            perm[i]=i;\n        }\n        double G=INT_MAX/2.0;\n        string res[n];\n        do {\n            int sum=w[perm[0]];\n            bool flag=true;\n            for (int i=1; i<n; i++) {\n                int x=perm[i];\n                if (s[x]<sum) {\n                    flag=false;\n                    break;\n                }\n                sum+=w[x];\n            }\n            if (flag) {\n                int sum2=0;\n                for (int i=0; i<n; i++) sum2+=(n-i)*w[perm[i]];\n                if (G-EPS>(double)sum2/(double)sum) {\n                    G=(double)sum2/(double)sum;\n                    for (int i=0; i<n; i++) res[i]=h[perm[i]];\n                }\n            }\n        } while (next_permutation(perm, perm+n));\n        for (int i=n-1; i>=0; i--) cout<<res[i]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require sqrt ceil floor\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <stdint.h>\t// require uint64_t\n#include <fstream>\t// require freopen\n\nusing namespace std;\n\ntypedef pair <pair<int, int>, string > ITEM;\t// ACeÌd³AACeÌãÉu¯éd³ÌãÀAACe¼\n\n//int memo[10][10];\t\t// s: ACe¼ ñ:½iÚ© -1: Ü¾ãÉÏßé©Ç¤©¢èA0:ÏßÈ¢ 1: Ïßé\nvector <ITEM> list;\nint N;\nint minG;\nvector <int> minorder;\nint total;\n\nint getG (vector <int> order )\n{\n\tint res = 0;\n\n\tfor (int i = 0; i < order.size(); ++i ){\n\t\tres += (i+1)*(list[order[i]].first.first);\n\t} // end for\n\n\treturn res;\n}\n\nvoid bt (vector <int> & order, int curr )\n{\n\tif (curr == N ){\n\t\tint currG = getG (order );\n\t\tif (currG < minG ){\n\t\t\tminorder = order;\n\t\t\tminG = currG;\n\t\t} // end if\n\t\treturn;\n\t} // end if\n\n//\tif (order[curr] != -1 && memo[order[curr]][curr] == 0 ){\n//\t\treturn;\n//\t} // end if\n\n//\tif (order[curr] == -1 ){\n\tvector <bool> used (N, false );\n\tfor (int i = 0; i < curr; ++i ){\n\t\tused[order[i]] = true;\n\t} // end if\n\n\tfor (int i = 0; i < N; ++i ){\n\t\tif (!used[i] ) {\n\t\t\torder[curr] = i;\n\t\t\tint curr_w = total;\n\t\t\tfor (int j = 0; j <= curr; ++j ){\n\t\t\t\tcurr_w -= list[order[j]].first.first;\n\t\t\t} // end for\n\t\t\tif (curr_w <= list[order[curr]].first.second ){\n\t//\t\t\tmemo[order[curr]][curr] = 1;\n\t\t\t\tbt (order, curr + 1 );\n\t//\t\t}else{\n\t//\t\t\tmemo[order[curr]][curr] = 0;\n\t\t\t}// end if\n\t\t\torder[curr] = -1;\n\t\t} // end if\n\t} // end for\n}\n\nvoid init (int n )\n{\n\tN = n;\n\tlist.clear();\n\tlist.resize(n);\n\tminorder.clear();\n\tminorder.resize(n);\n\ttotal = 0;\n\tminG = INT_MAX;\n//\tmemset (memo, -1, sizeof(memo) );\n}\t\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.lunch\", \"r\", stdin );\n\tint n;\n\n\twhile (cin >> n && n ){\n\t\tinit (n );\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> list[i].second;\n\t\t\tcin >> list[i].first.first;\t// w\n\t\t\tcin >> list[i].first.second;\t// s\n\t\t\ttotal += list[i].first.first; \n\t\t} // end for\n\t\tvector <int> order(n, -1 );\n\n\t\tbt (order, 0 );\n\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\tcout << list[minorder[i]].second << endl;\n\t\t} // end for\n\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct Food{\n  string name;int w,s;\n  Food(string a,int b,int c){name=a;w=b;s=c;};\n};\n\nint main()\n{\n  int n;\n  string f;\n  int w,s;\n  while(cin>>n,n){\n    vector<Food>food;\n    vector<int>v;\n    vector<int>ans;\n    for(int i=0;i<n;i++){\n      v.push_back(i);\n      cin>>f>>w>>s;\n      food.push_back(Food(f,w,s));\n    }\n\n    double res=1e10;\n    do{\n      bool ok=true;\n      double sum=food[v[n-1]].w;\n      double sum2=n*food[v[n-1]].w;\n      for(int i=n-2;i>=0;i--){\n\tif(food[v[i]].s<sum){\n\t  ok=false;\n\t  break;\n\t}\n\tsum+=food[v[i]].w;\n\tsum2+=(i+1)*food[v[i]].w;\n      }\n      if(ok && res>sum2/sum){\n\tres=sum2/sum;\n\tans=v;\n      }\n    }while(next_permutation(v.begin(),v.end()));\n\n    for(int i=0;i<n;i++){\n      cout<<food[ans[i]].name<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ndouble getcog(vi& ps,vi& ws)\n{\n\tint size=ps.size();\n\tint temp=0;\n\trep(i,size)\n\t\ttemp+=(i+1)*ws[ps[i]];\n\treturn (double)temp/accumulate(allof(ws),0);\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvs ns(n);\n\t\tvi ws(n),cs(n);\n\t\trep(i,n)\n\t\t\tcin>>ns[i]>>ws[i]>>cs[i];\n\t\t\n\t\tdouble cog=1e10;\n\t\tvi ps(n),res(n);\n\t\tvi ss(n);\n\t\trep(i,n) ps[i]=i;\n\t\tdo{\n\t\t\tfor(int i=n-2;i>=0;i--)\n\t\t\t\tss[i]=ss[i+1]+ws[ps[i+1]];\n\t\t\tbool ok=true;\n\t\t\trep(i,n)\n\t\t\t\tok&=ss[i]<=cs[ps[i]];\n\t\t\tif(ok){\n\t\t\t\tdouble temp=getcog(ps,ws);\n\t\t\t\tif(temp<cog){\n\t\t\t\t\tcog=temp;\n\t\t\t\t\tres=ps;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(allof(ps)));\n\t\t\n\t\trep(i,n)\n\t\t\tcout<<ns[res[i]]<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nstruct P\n{\n\tint w, s; \n\tstring name;\n};\n\nint main()\n{\n    for(int n; cin >> n && n;)\n\t{\n\t\tvector<P> v(n);\n\t\t\n\t\trep(i, n) cin >> v[i].name >> v[i].w >> v[i].s;\n\t\t\n\t\tvint p(n), ans;\n\t\trep(i, n) p[i] = i;\n\t\t\n\t\tdouble suit = 100000;\n\t\t\n\t\tdo \n\t\t{\n\t\t\tdouble sum = 0;\n\t\t\tdouble num = 0;\n\t\t\t\n\t\t\tfor(int i = n - 1; 0 <= i; i--)\n\t\t\t{\n\t\t\t\tP &e = v[p[i]];\n\t\t\t\t\n\t\t\t\tif(e.s < sum) break;\n\t\t\t\t\n\t\t\t\tsum += e.w;\n\t\t\t\tnum += (i + 1) * e.w;\n\t\t\t\t\n\t\t\t\tif(i == 0)\n\t\t\t\t{\n\t\t\t\t\tdouble sub = num / sum;\n\t\t\t\t\t\n\t\t\t\t\tif(sub < suit)\n\t\t\t\t\t{\n\t\t\t\t\t\tans = p;\n\t\t\t\t\t\tsuit = sub;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(next_permutation(ALL(p)));\n\t\t\n\t\trep(i, n) cout << v[ans[i]].name << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint n;\nvi w, s;\nint array[10];\n\nint best;\nint bestarray[10];\n\nvoid solve(int g, int st, int k)\n{\n\tif(g >= best)\n\t\treturn;\n\t\n\tif(k == n){\n\t\tbest = g;\n\t\tcopy(array, array+n, bestarray);\n\t\treturn;\n\t}\n\t\n\treep(i, k, n){\n\t\tif(st >= w[array[i]]){\n\t\t\tswap(array[k], array[i]);\n\t\t\tsolve(g+(k+1)*w[array[k]], min(st-w[array[k]], s[array[k]]), k+1);\n\t\t\tswap(array[k], array[i]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<string> f(n);\n\t\tw.resize(n);\n\t\ts.resize(n);\n\t\trep(i, n){\n\t\t\tchar name[32];\n\t\t\tscanf(\"%s%d%d\", name, &w[i], &s[i]);\n\t\t\tf[i] = name;\n\t\t}\n\t\t\n\t\tbest = 100000000;\n\t\trep(i, n)\n\t\t\tarray[i] = i;\n\t\tsolve(0, 10000000, 0);\n\t\trep(i, n){\n\t\t\tputs(f[bestarray[i]].c_str());\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Item\n{\n\tstring name;\n\tint w;\n\tint s;\n};\n\nclass ShieldDesc\n{\npublic:\n\tbool operator()( const Item& a, const Item& b ) const\n\t{\n\t\tif( a.s > b.s ) return true;\n\t\treturn false;\n\t}\n};\n\ndouble calcG( vector< Item >& v, vector< int > p )\n{\n\tdouble num = 0.0, den = 0.0;\n\tfor( int i = 0; i < (int)p.size(); ++i ){\n\t\tnum += ( v[ p[ i ] ].w * ( i + 1 ) );\n\t\tden += v[ p[ i ] ].w;\n\t}\n\treturn num / den;\n}\n\nvector< int > rec( vector< Item >& v, int used, vector< int > p, vector< int > r, vector< int >& a )\n{\n\tint rest = v.size() - p.size();\n\tif( rest == 0 ){\n\t\tif( a.empty() || calcG( v, p ) < calcG( v, a ) ){\n\t\t\ta = p;\n\t\t}\n\t\treturn a;\n\t}\n\n\tint shift = 0;\n\tfor( int i = 0; i < rest; ++i ){\n\t\tint bit = 1;\n\t\twhile( used & bit << shift ){\n\t\t\t++shift;\n\t\t}\n\t\tvector< int > pp = p;\n\t\tvector< int > rr = r;\n\t\tint w = v[ shift ].w;\n\t\tbool failed = false;\n\t\tfor( int j = p.size() - 1; j >= 0; --j ){\n\t\t\trr[ j ] -= w;\n\t\t\tif( rr[ j ] < 0 ){\n\t\t\t\tfailed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( failed ){\n\t\t\t++shift;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpp.push_back( shift );\n\t\trr.push_back( v[ shift ].s );\n\t\trec( v, used | ( 1 << shift ), pp, rr, a );\n\t\t++shift;\n\t}\n\treturn a;\n}\n\nvector< int > stack( vector< Item >& v )\n{\n\tvector< int > p, r, a;\n\treturn rec( v, 0, p, r, a );\n}\n\nint main()\n{\n\tint n;\n\n\twhile( cin >> n && n ){\n\t\tvector< Item > v;\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tItem item;\n\t\t\tcin >> item.name >> item.w >> item.s;\n\t\t\tv.push_back( item );\n\t\t}\n\t\tsort( v.begin(), v.end(), ShieldDesc() );\n\n\t\tvector< int > ans = stack( v );\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tcout << v[ ans[ i ] ].name << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tint n;\n\tvector<pair<string,pii> > data;\n\tvector<pair<string,pii> > ans;\n\twhile(cin>>n,n){\n\t\tdata.clear();\n\t\tans.clear();\n\t\tstring str;\n\t\tint w,s;\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcin>>str>>w>>s;\n\t\t\tdata.push_back(mp(str,pii(w,s)));\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tdouble G =INF;\n\t\tdo{\n\t\t\t//cout <<\"iei\"<<endl;\n\t\t\tint sumw =0;\n\t\t\tdouble tmp1 =0;\n\t\t\tdouble tmp2 =0;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\ttmp1 +=(i+1)*data[i].second.first;\n\t\t\t\ttmp2 +=data[i].second.first;\n\t\t\t}\n\t\t\tdouble Gtmp =(double)(tmp1/tmp2);\n\t\t\tif(Gtmp>G)continue;\n\t\t\tbool ok =true;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\tif(sumw>data[i].second.second){\n\t\t\t\t\tok =false;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tsumw +=data[i].second.first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok&&Gtmp <G){\n\t\t\t\tG =Gtmp;\n\t\t\t\tans =data;\n\t\t\t}\n\t\t}while(next_permutation(data.begin(), data.end()));\n\n\t\tfor(int i =0;i <ans.size();i++){\n\t\t\tcout <<ans[i].first<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst int MOD=1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  while(true){\n      cin>>n;\n      if(n==0) break;\n      std::vector<string> f(n);\n      std::vector<int> w(n),s(n),v(n),res(n);\n      for(int i=0;i<n;i++) cin>>f[i]>>w[i]>>s[i];\n      for(int i=0;i<n;i++) v[i]=i;\n      double mi=1e9;\n      do{\n          double g=0;//,sum=0;\n          for(int i=1;i<=n;i++){\n              g+=i*w[v[i-1]];\n             // sum+=w[v[i-1]];\n          }\n          bool flag=true;\n          for(int i=0;i<n;i++){\n              int wa=0;\n              for(int j=i+1;j<n;j++) wa+=w[v[j]];\n              if(s[v[i]]<wa) flag=false;\n          }\n          if(flag){\n              if(g<mi){\n                  for(int i=0;i<n;i++) res[i]=v[i];\n                  mi=g;\n              }\n          }\n      }while(next_permutation(v.begin(),v.end()));\n      for(int i=0;i<n;i++) cout<<f[res[i]]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tchar name[30][21];\n\tint wei[30],safe[30],perm[30];\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%s%d%d\",name[i],&wei[i],&safe[i]);\n\t\t\tperm[i]=i;\n\t\t}\n\n\t\tint opt[30];\n\t\tdouble gopt=-1;\n\t\tdo{\n\t\t\tbool b=true;\n\n\t\t\tint wsum=0,g=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint now=perm[i];\n\t\t\t\tif(wsum>safe[now]){\n\t\t\t\t\tb=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twsum+=wei[now];\n\t\t\t\tg+=(i+1)*wei[now];\n\t\t\t}\n\n\t\t\tif(!b)\tcontinue;\n\n\t\t\tif(gopt<(double)g/wsum){\n\t\t\t\tgopt=(double)g/wsum;\n\t\t\t\tfor(int i=0;i<n;i++)\topt[i]=perm[i];\n\t\t\t}\n\t\t}while(next_permutation(perm,perm+n));\n\n\t\tfor(int i=n-1;i>=0;i--)\tputs(name[opt[i]]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f));\n\t\tsort(items.begin(),items.end());\n\t\tS=99999;\n\t\tdo{\n\t\t\tfor(s=w=0,i=n-1;~i;i--){\n\t\t\t\tif(items[i].first.second<w)break;\n\t\t\t\tw+=items[i].first.first;\n\t\t\t\ts+=(i+1)*items[i].first.first;\n\t\t\t}\n\t\t\tif(i<0&&s<S)S=s,result=items;\n\t\t}while(next_permutation(items.begin(),items.end()));\n\t\tfor(i=0;i<n;i++)cout<<result[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \n#include <sstream>\nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n#define ll long long int\n#define gcd(a,b) __gcd(a,b)\n\nint GCD(int a, int b) {if(!b) return a; return gcd(b, a%b);}\nint lcm(int a, int b) {return a*b / gcd(a, b);}\n\nstruct food{\n  string fn;\n  int g;\n  int s;\n};\nint f[10],an[10],m;\nfood fd[10],sf;\nint ans(int n,int s){\n  if(n==-1){\n    for(int i = m - 1 ; i >= 0 ; i --)\n      cout << fd[an[i]].fn << endl; \n      return 1;\n  }\n for (i=m-1;i>=0;i--) {\n        if (f[i]==0 && fd[i].s>=s-fd[i].g) {\n            f[i]=1; an[n]=i;\n            if (ans(n-1,s-fd[i].g)==1) return 1; \n            f[i]=0;\n        }\n  }\n  return 0;\n}\n\nint main(void){\n  int i,j,s;\n  while(cin>>m){\n    if(m==0)break;\n    for(i = 0 , s = 0 ; i < m ; i ++){\n      f[i] = 0 ; \n      cin>>fd[i].fn>>fd[i].g>>fd[i].s;\n      s+=fd[i].g;\n    }\n    for(i = 1 ; i < m ; i ++){\n      for(j = 0  ; j < m - i ; j ++){\n\tif(fd[j].g>fd[j+1].g){\n\t  sf=fd[j];\n\t  fd[j] = fd[j+1];\n\t  fd[j+1] = sf;\n\t}\n      }\n    }\n    ans(m-1,s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items;\n\t\tvector<int> num,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f)),num.push_back(i);\n\t\tS=99999;\n\t\tdo{\n\t\t\tfor(s=w=0,i=n-1;~i;i--){\n\t\t\t\tpair<int,int> weight=items[num[i]].first;\n\t\t\t\tif(weight.second<w)break;\n\t\t\t\tw+=weight.first;\n\t\t\t\ts+=(i+1)*weight.first;\n\t\t\t}\n\t\t\tif(i<0&&s<S)S=s,result=num;\n\t\t}while(next_permutation(num.begin(),num.end()));\n\t\tfor(i=0;i<n;i++)cout<<items[result[i]].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\n#include<functional>\nusing namespace std;\n\nstruct Food{\n\tstring f;\n\tint w,s;\n\tbool operator <(const Food &a)const{\n\t\tif(w==a.w) return s>a.s;\n\t\treturn w>a.w;\n\t}\n};\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tint sumW = 0;\n\t\tFood food[10];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>food[i].f>>food[i].w>>food[i].s;\n\t\t\tsumW += food[i].w;\n\t\t}\n\t\tsort(food,food+N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(food[j].w == -1) continue;\n\t\t\t\tif(food[j].s >= sumW-food[j].w){\n\t\t\t\t\tcout<<food[j].f<<endl;\n\t\t\t\t\tsumW -= food[j].w; food[j].w = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#include<string>\n#include<algorithm>\n#define repb(i,n) for(int i=n;i--;)\nusing namespace std;\nint main(){\n\tint n,s,w,W; string f;\n\twhile(cin>>n,n){\n\t\tvector<pair<int,pair<int, string> > > t; W=0;\n\t\trepb(i,n){\n\t\t\tcin>>f>>w>>s;\n\t\t\tt.push_back(make_pair(w,make_pair(s,f)));\n\t\t\tW+=w;\n\t\t}\n\t\tsort(t.begin(),t.end());\n\t\tvector<string> fukuro;\n\t\twhile(!t.empty()){\n\t\t\trepb(i,t.size())if(W-t[i].first<=t[i].second.first){\n\t\t\t\tfukuro.push_back(t[i].second.second);cout<<t[i].second.second<<endl;\n\t\t\t\tW-=t[i].first;\n\t\t\t\tt.erase(t.begin()+i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct food{\n\tstring n;\n\tint w;\n\tint s;\n\tint used;\n};\n\nint main(){\n\tint n;\n\twhile(cin >> n){\n\t\tvector<food> vf;\n\t\tif(n == 0 ) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfood f;\n\t\t\tcin >> f.n >> f.w >> f.s;\n\t\t\tf.used = 0;\n\t\t\tvf.push_back(f);\n\t\t}\n\t\tint weight = 0;\n\t\tfor(int i = 0; i < n; i++) weight += vf[i].w;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tvector<int> vi;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(!vf[j].used && vf[j].s >= weight - vf[j].w){\n\t\t\t\t\tvi.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wmax = -1;\n\t\t\tint u;\n\t\t\tfor(int j = 0; j < vi.size(); j++){\n\t\t\t\tif(wmax <vf[vi[j]].w){\n\t\t\t\t\twmax = vf[vi[j]].w;\n\t\t\t\t\tu = vi[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << vf[u].n << endl;\n\t\t\tvf[u].used = 1;\n\t\t\tweight -= vf[u].w;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tint n;\n\tvector<pair<string,pii> > data;\n\tvector<pair<string,pii> > ans;\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\twhile(cin>>n,n){\n\t\tdata.clear();\n\t\tans.clear();\n\t\tstring str;\n\t\tint w,s;\n\t\tint tmp2 =0;\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcin>>str;\n\t\t\tscanf(\"%d %d\",&w,&s);\n\t\t\tdata.push_back(mp(str,pii(w,s)));\n\t\t\ttmp2 +=data[i].second.first;\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tdouble G =INF;\n\t\tdo{\n\t\t\t//cout <<\"iei\"<<endl;\n\t\t\tint sumw =0;\n\t\t\tint tmp1 =0;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\ttmp1 +=(i+1)*data[i].second.first;\n\t\t\t}\n\t\t\tdouble Gtmp =(double)((double)tmp1/(double)tmp2);\n\t\t\tif(Gtmp>G)continue;\n\t\t\tbool ok =true;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\tif(sumw>data[i].second.second){\n\t\t\t\t\tok =false;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tsumw +=data[i].second.first;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout <<Gtmp<<endl;\n\t\t\tif(ok&&Gtmp <G){\n\t\t\t\tG =Gtmp;\n\t\t\t\tans=data;\n\t\t\t\t//cout <<\"ge\"<<endl;\n\t\t\t}\n\t\t}while(next_permutation(data.begin(), data.end()));\n\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcout <<ans[i].first<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint n;\nbool use[10];\nint w[10],s[10];\nvector<int> tmp,ans;\nint maximam,total;\n\nvoid rec(int pos){\n  if(pos==n){\n    int g;\n    g = 0;\n    for(int i=0;i<n;i++)g+=(i+1)*w[tmp[i]];\n    if(maximam<g){\n      maximam = g;\n      ans = tmp;\n    }\n    return;\n  }\n\n  for(int i=0;i<n;i++){\n    if(!use[i]){\n      if(s[i]>=total){\n\tuse[i] = true;\n\ttotal += w[i];\n\ttmp.push_back(i);\n\trec(pos+1);\n\ttmp.pop_back();\n\tuse[i] = false;\n\ttotal -= w[i];\n      }\n    }\n  }\n}\n\nint main(){\n  string f[10];\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++){\n      cin >> f[i] >> w[i] >> s[i];\n      use[i] = false;\n    }\n\n    total = 0;\n    ans.clear();\n    tmp.clear();\n    maximam = 0;\n\n    rec(0);\n\n    for(int i=ans.size()-1;i>=0;i--)cout << f[ans[i]] << endl;\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pdl = pair<double,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr ll inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nll numofbits5(long bits)\n{\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\nvector<string> f;\nvector<ll> w,s;\nint n;\nll sumW;\ndouble g = inf;\nvector<int> ans;\nvoid rdp(int st,int k,vector<vector<pdl>> &dp,vector<int> v){\n  int bfr = st & ~(1 <<k);\n  ll W = dp[st][k].se ;\n  W -= w[k];\n  v.push_back(k);\n  if(bfr == 0){\n    ans = v;\n    return ;\n  }\n  ll G = dp[st][k].fi ;\n  REP(i,0,n){\n    if(bfr & (1 << i) && G - numofbits5(st) * w[k] == dp[bfr][i].fi){\n      rdp(bfr,i,dp,v);\n    }\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin>>n&&n){\n    f.clear(); f.resize(n); w.clear(); w.resize(n); s.clear(); s.resize(n);\n    sumW =0;\n    rep(i,n){\n      cin >> f[i] >> w[i] >> s[i];\n      sumW += w[i];\n    }\n    vector<vector<pdl>> dp(1 << n,vector<pdl>(n,mp(inf,1)));\n    rep(i,n){\n      if(sumW - w[i] <= s[i]){\n        dp[1 << i][i] = mp(w[i],w[i]);\n      }\n    }\n    rep(i,1 << n){\n      rep(j,n){\n        if((i & (1 << j)) == 0 || dp[i][j].fi == inf) continue;\n        rep(k,n){\n          if(i & (1 << k)) continue;\n          int nxt = i | (1 << k);\n          double G = dp[i][j].fi + (numofbits5(nxt)) * w[k];\n          ll W = dp[i][j].se + w[k];\n          if(1.0 * G / W < 1.0 * dp[nxt][k].fi / dp[nxt][k].se && sumW - W <= s[k]){\n            dp[nxt][k] = mp(G,W);\n          }\n        }\n      }\n    }\n    int st = (1 << n) -1;\n    double ansg = inf;\n    int suf = -1;\n    REP(i,0,n){\n      if(1.0 * dp[st][i].fi / dp[st][i].se < ansg){\n        ansg = 1.0 * dp[st][i].fi / dp[st][i].se ;\n        suf = i;\n      }\n    }\n    vector<int> v(0);\n    rdp(st,suf,dp,v);\n    reverse(all(ans));\n    rep(i,ans.size()){\n      cout << f[ans[i]] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cfloat>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nstruct Food{\n\tstring name;\n\tint w;\n\tint s;\n\tint id;\n\tFood(string name, int w, int s, int id): name(name), w(w), s(s), id(id) {};\n\n\tbool operator<(const Food& rhs) const{\n\t\treturn id < rhs.id;\n\t}\n};\n\ndouble calc(vector<Food> foods){\n\tint length= foods.size();\n\tint sum = 0;\n\tfor(int i = length - 1; i >= 0; --i){\n\t\tint s = foods[i].s;\n\t\tif(s < sum) return DBL_MAX;\n\t\tsum += foods[i].w;\n\t}\n\tdouble d = 0, n = 0;\n\tREP(i, length){\n\t\tn += (i + 1) * foods[i].w;\n\t\td +=foods[i].w;\n\t}\n\treturn n / d;\n}\n\nint main(int argc, char const *argv[])\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tvector<Food> ans;\n\twhile(cin >> n, n){\n\t\tvector<Food> foods;\n\t\tREP(i, n){\n\t\t\tstring name;\n\t\t\tint w, s;\n\t\t\tcin >> name >> w >> s;\n\t\t\tfoods.emplace_back(name, w, s, i);\n\t\t}\n\t\tdouble min = DBL_MAX;\n\t\tdo{\n\t\t\tdouble value = calc(foods);\n\t\t\tif(min > value){\n\t\t\t\tmin = value;\n\t\t\t\tans = foods;\n\t\t\t}\n\t\t}while(next_permutation(foods.begin(), foods.end()));\n\t\tREP(i, n)\n\t\t\tcout << ans[i].name << endl;\n\t};\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n#include<iostream>\n#include<cmath>\n\nstruct Lunch {\n\tint id, weight, strongth;\n\tbool operator<(const Lunch that) const { return id < that.id; }\n};\n\nbool is_not_crash(const std::vector<Lunch>& lunch) {\n\tint sum_weight = 0;\n\tfor (auto r = lunch.rbegin(); r != lunch.rend(); ++r) {\n\t\tif (sum_weight > r->strongth) return false;\n\t\tsum_weight += r->weight;\n\t}\n\treturn true;\n}\ndouble cal_center(const std::vector<Lunch>& lunch) {\n\tdouble denominator = 0, numerator = 0;\n\tfor (auto i = 0; i < lunch.size(); ++i) {\n\t\tdenominator += lunch[i].weight;\n\t\tnumerator += lunch[i].weight * (i + 1.0);\n\t}\n\treturn numerator / denominator;\n}\nint factorial(const int n) {\n\tint result = 1;\n\tfor (auto i = 2; i <= n; ++i) {\n\t\tresult *= i;\n\t}\n\treturn result;\n}\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tstd::vector<std::string> names(n);\n\t\tstd::vector<Lunch> lunches(n), result; \n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tlunches[i].id = i;\n\t\t\tstd::cin >> names[i] >> lunches[i].weight >> lunches[i].strongth;\n\t\t}\n\t\tdouble min_center = DBL_MAX;\n\t\tfor (auto i = factorial(n); i > 0; --i) {\n\t\t\tif (is_not_crash(lunches)) {\n\t\t\t\tauto temp = cal_center(lunches);\n\t\t\t\tif (temp < min_center) {\n\t\t\t\t\tmin_center = temp;\n\t\t\t\t\tresult = lunches;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::next_permutation(lunches.begin(), lunches.end());\n\t\t}\n\t\tfor (const auto i : result) {\n\t\t\tstd::cout << names[i.id] << '\\n';\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,j,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f));\n\t\tsort(items.begin(),items.end());\n\t\tS=99999;\n\t\tdo{\n\t\t\tfor(s=w=i=0;i<n;i++){\n\t\t\t\tif(items[i].first.second<w)break;\n\t\t\t\tw+=items[i].first.first;\n\t\t\t\ts+=(n-i)*items[i].first.first;\n\t\t\t}\n\t\t\tif(i==n){\n\t\t\t\tif(s<S)S=s,result=items;\n\t\t\t}else if(i>0){\n\t\t\t\treverse(items.begin()+i,items.end());\n\t\t\t}\n\t\t}while(next_permutation(items.begin(),items.end()));\n\t\treverse(result.begin(),result.end());\n\t\tfor(i=0;i<n;i++)cout<<result[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nvector<int> w,s,hist;\nvector<string> name;\nint n,tmpn,tmpm;\nint used,ret[10];\nstring str;\ndouble gmin = 1e+10;\n\ninline double calc_g(){\n\tdouble p=0;\n\tdouble q=0;\n\tfor(int i=0;i<n;i++){\n\t\tp += (i+1) * w[hist[n-1-i]];\n\t\tq += w[hist[i]];\n\t\t\n\t}\n\treturn p/q;\n}\n\nvoid solve(int num, int weight){\n\tif(num == n){\n\t\tdouble g = calc_g();\n\t\tif(gmin > g){\n\t\t\tgmin = g;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tret[i] = hist[i];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif((used & (1 << i)) == 0){\n\t\t\tif(s[i] >= weight){\n\t\t\t\t//ツ鳴「ツ使ツ用ツづつゥツづつ重ツづ敖づ可妥渉つヲツづァツづェツつスツづァツ静渉づアツづづ敖づゥ\n\t\t\t\tused |= 1 << i;\n\t\t\t\thist.push_back(i);\n\t\t\t\tsolve(num+1, weight+w[i]);\n\t\t\t\thist.pop_back();\n\t\t\t\tused ^= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(cin >> n && n){\n\t\tw.clear();\n\t\ts.clear();\n\t\thist.clear();\n\t\tname.clear();\n\t\tmemset(ret, 0, sizeof(ret));\n\t\tused = 0;\n\t\tgmin = 1e+10;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> str >> tmpn >> tmpm;\n\t\t\tname.push_back(str);\n\t\t\tw.push_back(tmpn);\n\t\t\ts.push_back(tmpm);\n\t\t}\n\t\tsolve(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcout << name[ret[n-i-1]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<int> w,s,hist,ret;\nvector<string> name;\nint n,tmpn,tmpm;\nint used;\nstring str;\ndouble gmin = 1e+10;\n\ndouble calc_g(){\n\tdouble p=0;\n\tdouble q=0;\n\tfor(int i=0;i<n;i++){\n\t\tp += (n-i-i) * hist[n-1-i];\n\t\tq += hist[i];\n\t}\n\treturn p/q;\n}\n\nvoid solve(int num, int weight){\n\tif(num == n){\t\t\t\n\t\tdouble g = calc_g();\n\t\tif(gmin > g){\n\t\t\tcout << g << endl;\n\t\t\tgmin = g;\n\t\t\tret = hist;\n\t\t}\n\t\treturn;\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif((used & (1 << i)) == 0){\n\t\t\tif(s[i] >= weight){\n\t\t\t\t//ツ鳴「ツ使ツ用ツづつゥツづつ重ツづ敖づ可妥渉つヲツづァツづェツつスツづァツ静渉づアツづづ敖づゥ\n\t\t\t\tused += 1 << i;\n\t\t\t\thist.push_back(i);\n\t\t\t\tsolve(num+1, weight+w[i]);\n\t\t\t\thist.pop_back();\n\t\t\t\tused -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(cin >> n && n){\n\t\tw.clear();\n\t\ts.clear();\n\t\thist.clear();\n\t\tret.clear();\n\t\tname.clear();\n\t\tused = 0;\n\t\tgmin = 1e+10;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> str >> tmpn >> tmpm;\n\t\t\tname.push_back(str);\n\t\t\tw.push_back(tmpn);\n\t\t\ts.push_back(tmpm);\n\t\t}\n\t\tsolve(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcout << name[ret[n-i-1]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<int> w,s,hist;\nvector<string> name;\nint n,tmpn,tmpm;\nint used,ret[10];\nstring str;\ndouble gmin = 1e+10;\n\ninline double calc_g(){\n\tdouble p=0;\n\tdouble q=0;\n\tfor(int i=0;i<n;i++){\n\t\tp += (n-i) * hist[n-1-i];\n\t\tq += hist[i];\n\t}\n\treturn p/q;\n}\n\nvoid solve(int num, int weight){\n\tif(num == n){\t\t\t\n\t\tdouble g = calc_g();\n\t\tif(gmin > g){\n\t\t\tgmin = g;\n\t\t\tfor(int i=0;i<n;i++) ret[i] = hist[i];\n\t\t}\n\t\treturn;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tif((used & (1 << i)) == 0){\n\t\t\tif(s[i] >= weight){\n\t\t\t\t//ツ鳴「ツ使ツ用ツづつゥツづつ重ツづ敖づ可妥渉つヲツづァツづェツつスツづァツ静渉づアツづづ敖づゥ\n\t\t\t\tused += 1 << i;\n\t\t\t\thist.push_back(i);\n\t\t\t\tsolve(num+1, weight+w[i]);\n\t\t\t\thist.pop_back();\n\t\t\t\tused -= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(cin >> n && n){\n\t\tw.clear();\n\t\ts.clear();\n\t\thist.clear();\n\t\tname.clear();\n\t\tused = 0;\n\t\tgmin = 1e+10;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> str >> tmpn >> tmpm;\n\t\t\tname.push_back(str);\n\t\t\tw.push_back(tmpn);\n\t\t\ts.push_back(tmpm);\n\t\t}\n\t\tsolve(0,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcout << name[ret[n-i-1]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\nusing namespace std;\nusing LL = long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = 1000000000;\nconst double PI = acos(-1);\n\nint main() {\n\tint n;\n\tstring s;\n\tint a, b;\n\twhile (cin >> n&&n) {\n\t\tvector<pair<int, string>>v;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> s >> a >> b;\n\t\t\tv.emplace_back(make_pair(b, s));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tcout << v[i].second << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int w, s;\n    string name;\n    bool operator<(const Data& d) const{\n        return s < d.s;\n    }\n};\n\nint n;\nvector<Data> d;\nvector<bool> used;\nvector<int> bestIndex;\nint bestG;\n\nvoid solve(int k, vector<int>& index, int g, int sumW)\n{\n    if(k == n){\n        if(g < bestG){\n            bestG = g;\n            bestIndex = index;\n        }\n        return;\n    }\n\n    for(int i=0; i<n; ++i){\n        if(used[i])\n            continue;\n        if(d[i].s >= sumW){\n            used[i] = true;\n            index[k] = i;\n            solve(k+1, index, g+(n-k)*d[i].w, sumW+d[i].w);\n            used[i] = false;\n        }else{\n            return;\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        d.resize(n);\n        for(int i=0; i<n; ++i)\n            cin >> d[i].name >> d[i].w >> d[i].s;\n        sort(d.begin(), d.end());\n\n        bestG = INT_MAX;\n        used.assign(n, false);\n        vector<int> index(n);\n        solve(0, index, 0, 0);\n        for(int i=n-1; i>=0; --i)\n            cout << d[bestIndex[i]].name << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cfloat>\nusing namespace std;\n\nchar f[10][21];\nint n, w[10], s[10], a[10], b[10];\nbool u[10];\ndouble maxg;\n\nvoid dfs(int x, int tw, int m, double g) {\n  if (m == n) {\n    if (maxg < g) {\n      maxg = g;\n      for (int i=0; i<n; i++) {\n        b[i] = a[i];\n      }\n    }\n    return;\n  }\n  if (x>=n) {\n    return;\n  }\n  if (!u[x] && tw <= s[x]) {\n    u[x] = true;\n    tw += w[x];\n    a[m] = x;\n    dfs(0, tw, m+1, g + w[x]*(m+1));\n    tw -= w[x];\n    u[x] = false;\n  }\n  dfs(x+1, tw, m, g);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (!n) break;\n    for (int i=0; i<n; i++) {\n      scanf(\"%s %d %d\", f[i], &w[i], &s[i]);\n    }\n    for (int i=0; i<n; i++) {\n      u[i] = false;\n    }\n    maxg = -DBL_MAX;\n    dfs(0, 0, 0, 0.);\n    for (int i=n-1; i>=0; i--) {\n      printf(\"%s\\n\", f[b[i]]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring f[11]; int n, s[11], w[11], p[11], q[11];\nbool ok() {\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint r = 0;\n\t\tfor (int j = i + 1; j < n; j++) r += w[j];\n\t\tif (r > s[i]) return false;\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) cin >> f[i] >> w[i] >> s[i];\n\t\tfor (int i = 0; i < n; i++) p[i] = i, q[i] = -1;\n\t\tdo {\n\t\t\tif (ok()) {\n\t\t\t\tif (q[0] == -1) for (int i = 0; i < n; i++) q[i] = p[i];\n\t\t\t\telse {\n\t\t\t\t\tint sum1 = 0, sum2 = 0;\n\t\t\t\t\tfor (int i = 0; i < n; i++) sum1 += w[p[i]] * (i + 1), sum2 += w[q[i]] * (i + 1);\n\t\t\t\t\tif (sum1 < sum2) for (int i = 0; i < n; i++) q[i] = p[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} while (p, p + n);\n\t\tfor (int i = 0; i < n; i++) cout << s[q[i]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#define P pair<int,string>\n#define PV(w,s,n) multimap< int,P >::value_type((w), P((s),(n)))\nusing namespace std;\nint main()\n{\n  int n;\n  for(;;){\n    cin >> n;\n    if(n==0) break;\n    multimap< int,P,greater<int> > m;\n    string l;\n    int w,s,t=0;\n    while(n--){\n      cin >> l >> w >> s;\n      m.insert( PV(w,s,l) );\n      t += w;\n    }\n    multimap< int,P >::iterator it;\n    while(!m.empty()){\n      it = m.begin();\n      while(it != m.end()){\n\tif((*it).second.first >= t - (*it).first){\n\t  cout << (*it).second.second << endl;\n\t  t -= (*it).first;\n\t  m.erase(it);\n\t  break;\n\t}\n\tit++;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst double EPS = 1e-6;\n\nint main(void) {\n\tint N;\n\twhile (cin >> N, N) {;\n\t\tvector<string> F(N);\n\t\tVI W(N), S(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> F[i] >> W[i] >> S[i];\n\t\t}\n\n\t\tVI p(N);\n\t\tiota(p.begin(), p.end(), 0);\n\n\t\tdouble ans = 1e+8;\n\t\tVI best_p(p.begin(), p.end());\n\n\t\tdo {\n\t\t\tdouble g = 0, gt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg += (i + 1) * W[p[i]];\n\t\t\t\tgt += W[p[i]];\n\t\t\t}\n\t\t\tg /= gt;\n\n\t\t\tif (g - EPS > ans) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbool flg = true;\n\t\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\t\tsum += W[p[j]];\n\t\t\t\t}\n\t\t\t\tflg &= sum <= S[p[i]];\n\t\t\t}\n\n\t\t\tif (flg && g < ans + EPS) {\n\t\t\t\tans = g;\n\t\t\t\tswap(best_p, p);\n\t\t\t}\n\t\t} while (next_permutation(p.begin(), p.end()));\n\n\t\tfor (auto i : best_p) {\n\t\t\tcout << F[i] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nint main(){\n\t\n\twhile(true){\n\t\t\n\t\tint n;\n\t\t\n\t\tcin >> n;\n\t\t\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tstring name[10];\n\t\tint index[10], index_ans[10];\n\t\tdouble w[10], s[10];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> name[i] >> w[i] >> s[i];\n\t\t\tindex[i] = i;\n\t\t}\n\t\t\n\t\tdouble G_min = 100000;\n\t\t\n\t\tdo{\n\t\t\tdouble weight_sum = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(weight_sum > s[index[i]]){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tweight_sum += w[index[i]];\n\t\t\t\tif(i == n - 1){\n\t\t\t\t\tint G_cur = 0;\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tG_cur += w[index[j]] * (n - j);\n\t\t\t\t\t}\n\t\t\t\t\tif(G_cur < G_min){\n\t\t\t\t\t\tG_min = G_cur;\n\t\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\t\tindex_ans[j] = index[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(index, index + n));\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout << name[index_ans[n - i - 1]] << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nstruct Food{\n    std::string name;\n    ull w, s;\n};\n\nconst int MAX_N = 10;\nint N;\nstd::vector<Food> F;\nint order[MAX_N], fact[11];\n\nint main(){\n    fact[0] = 1;\n    FOR(i, 1, 11){\n        fact[i] = fact[i-1] * i;\n    }\n\n    std::cin >> N;\n    \n    REP(i, N){\n        std::string name;\n        ull w, s;\n        std::cin >> name >> w >> s;\n        \n        F.push_back({name, w, s});\n    }\n\n    REP(i, N){\n        order[i] = i;\n    }\n    \n    ull min_cost = INF;\n    int min_order[MAX_N];\n    REP(_, fact[N]){\n        // for(int i=0;i<N;i++){\n        //     printf(\"%d, \", order[i]);\n        // }\n        // puts(\"\");\n\n        bool f = true;\n        ull cost = 0, sum = 0;\n        REP(i, N){\n            int index = order[i];\n            if(sum <= F[index].s);\n            else{f = false;}\n\n            cost += (N-i) * F[index].w;\n            sum += F[index].w;\n        }\n        //std::cout << cost << std::endl;\n\n        if(f && min_cost > cost){\n            min_cost = cost;\n            std::copy(order, order+N, min_order);\n        }\n\n        std::next_permutation(order, order+N);\n    }\n\n    //std::cout << min_cost << std::endl;\n    for(int i=N-1;i>=0;i--){\n        int index = min_order[i];\n        std::cout << F[index].name << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//30\n#include<iostream>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    string f[10];\n    int w[10],s[10];\n    for(int i=0;i<n;i++){\n      cin>>f[i]>>w[i]>>s[i];\n    }\n    int x[]={0,1,2,3,4,5,6,7,8,9};\n    int ans[10];\n    double g=1<<30;\n    do{\n      bool f=true;\n      for(int i=0;i<n;i++){\n\tint ws=0;\n\tfor(int j=i+1;j<n;j++){\n\t  ws+=w[x[j]];\n\t}\n\tf&=s[x[i]]>=ws;\n      }\n      if(f){\n\tdouble ww=0;\n\tdouble ws=0;\n\tfor(int i=0;i<n;i++){\n\t  ww+=(i+1)*w[x[i]];\n\t  ws+=w[i];\n\t}\n\tif(ww/ws<g){\n\t  g=ww/ws;\n\t  copy(x,x+n,ans);\n\t}\n      }\n    }while(next_permutation(x,x+n));\n    for(int i=0;i<n;i++){\n      cout<<f[ans[i]]<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint n,used[10],w[10],s[10];\nstring name[10];\ndouble ansg;\nint ansnum[10],tansnum[10];\n\nvoid dfs(int weight,int up){\n  if(up==n){\n    int tw=0;\n    rep(i,n)tw+=(n-i)*w[tansnum[i]];\n    if(ansg>1.0*tw/weight){\n      ansg=1.0*tw/weight;\n      rep(i,n)ansnum[i]=tansnum[i];\n    }\n    return;\n  }\n  \n  rep(i,n){\n    if(used[i])continue;\n    if(s[i]<weight)return;\n  }\n  \n  rep(i,n){\n    if(used[i])continue;\n    if(s[i]<weight)return;\n    used[i]=1;\n    tansnum[up]=i;\n    dfs(weight+w[i],up+1);\n    used[i]=0;\n  }\n}\n\nmain(){\n  while(cin>>n,n){\n    ansg=100;\n    rep(i,n){\n      cin>>name[i]>>w[i]>>s[i];\n    }\n\n    dfs(0,0);\n    rep(i,n){\n      cout<<name[ansnum[n-1-i]]<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(int w[],int k[],int b[],int a[],int c,int n,int e,int g){\n  int i,j;\n  int bb[10];\n  if(c==n){\n    if(a[10]==0||a[10]>g){\n      a[10]=g;\n      memcpy(a,b,10*sizeof(int));\n    }\n  }else{\n    for(i=0;i<n;i++){\n      if(k[i]>=e){\n\tfor(j=0;j<c;j++){\n\t  if(i==b[j])\n\t    break;\n\t}\n\tif(j==c){\n\t  memcpy(bb,b,sizeof(bb));\n\t  bb[c]=i;\n\t  f(w,k,bb,a,c+1,n,e+w[i],g+w[i]*(n-c));\n\t}\n      }else\n\tbreak;\n    }\n  }\n  return;\n}\nint main(){\n  int h,i;\n  int w[10],k[10],b[10],a[11],n;\n  char s[10][64];\n  for(;;){\n    cin>>n;\n    if(n==0)\n      break;\n    for(i=0;i<n;i++)\n      cin>>s[i]>>w[i]>>k[i];\n    do{\n      h=0;\n      for(i=1;i<n;i++){\n\tif(k[i-1]<k[i]){\n\t  swap(k[i-1],k[i]);\n\t  swap(w[i-1],w[i]);\n\t  swap(s[i-1],s[i]);\n\t  h=1;\n\t}\n      }\n    }while(h);\n    memset(b,0,sizeof(b));\n    memset(a,0,sizeof(a));\n    f(w,k,b,a,0,n,0,0);\n    for(i=0;i<n;i++)\n      cout<<s[a[n-i-1]]<<endl;\n  }\n  return 0;\n}\n\t  \n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f));\n\t\tsort(items.begin(),items.end());\n\t\tS=99999;\n\t\tdo{\n\t\t\tfor(s=w=0,i=n-1;i>=0;i--){\n\t\t\t\tif(items[i].first.second<w)break;\n\t\t\t\tw+=items[i].first.first;\n\t\t\t\ts+=(i+1)*items[i].first.first;\n\t\t\t}\n\t\t\tif(i<0&&s<S)S=s,result=items;\n\t\t}while(next_permutation(items.begin(),items.end()));\n\t\tfor(i=0;i<n;i++)cout<<result[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require sqrt ceil floor\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <stdint.h>\t// require uint64_t\n#include <fstream>\t// require freopen\n\nusing namespace std;\n\ntypedef pair <pair<int, int>, string > ITEM;\t// ACeÌd³AACeÌãÉu¯éd³ÌãÀAACe¼\n\nint memo[10][10];\t\t// s: ACe¼ ñ:½iÚ© -1: Ü¾ãÉÏßé©Ç¤©¢èA0:ÏßÈ¢ 1: Ïßé\nvector <ITEM> list;\nint N;\n\nint dfs (vector <int> order, int curr )\n{\n\tif (curr == N ){\n\t\treturn 1;\n\t} // end if\n\n\tif (memo[order[curr]][curr] == 0 ){\n\t\treturn 0;\n\t} // end if\n\t\t\n\tint total_wight = 0;\n\n\tfor (int i = curr + 1; i < N; ++i ){\n\t\ttotal_wight += list[order[i]].first.first;\n\t} // end if\n\n\tif (total_wight <= list[order[curr]].first.second ){\n\t\tmemo[order[curr]][curr] = 1;\n\t\treturn dfs (order, curr + 1 );\n\t}else{\n\t\treturn (memo[order[curr]][curr] = 0);\n\t} // end if\n\n\treturn 0;\n}\n\nint getG (vector <int> order )\n{\n\tint res = 0;\n\n\tfor (int i = 0; i < order.size(); ++i ){\n\t\tres += (i+1)*(list[order[i]].first.first);\n\t} // end for\n\n\treturn res;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.lunch\", \"r\", stdin );\n\tint n;\n\n\twhile (cin >> n && n ){\n\t\tN = n;\n\t\tlist.clear();\n\t\tlist.resize(n);\n\t\tmemset (memo, -1, sizeof(memo) );\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> list[i].second;\n\t\t\tcin >> list[i].first.first;\t// w\n\t\t\tcin >> list[i].first.second;\t// s \n\t\t} // end for\n\t\tvector <int> order(n, 0 );\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\torder[i] = i;\n\t\t} // end for\n\n\t\tvector <int> minorder;\n\t\tint minG = INT_MAX;\n\t\tdo{\n\t\t\tif (dfs (order, 0) > 0){\n\t\t\t\tint currG = getG (order );\n\t\t\t\tif (currG < minG ){\n\t\t\t\t\tminorder = order;\n\t\t\t\t\tminG = currG;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t}while (next_permutation (order.begin(), order.end() ) );\n\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\tcout << list[minorder[i]].second << endl;\n\t\t} // end for\n\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f));\n\t\tsort(items.begin(),items.end());\n\t\tS=99999;\n\t\tdo{\n\t\t\tfor(s=w=i=0;i<n;i++){\n\t\t\t\tif(items[i].first.second<w)break;\n\t\t\t\tw+=items[i].first.first;\n\t\t\t\ts+=(n-i)*items[i].first.first;\n\t\t\t}\n\t\t\tif(i==n){\n\t\t\t\tif(s<S)S=s,result=items;\n\t\t\t}else{\n\t\t\t\treverse(items.begin()+i,items.end());\n\t\t\t}\n\t\t}while(next_permutation(items.begin(),items.end()));\n\t\treverse(result.begin(),result.end());\n\t\tfor(i=0;i<n;i++)cout<<result[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint n;\nchar name[10][25];\nint w[10], s[10];\n\nint per[10], used[10];\ndouble bestscore;\nint bestper[10];\n\nvoid dfs(int dep) {\n\tint i;\n\tif ( dep == n ) {\n\t\tfor(i = 0; i < n; i++ ) {\n\t\t\tint noww = 0;\n\t\t\tfor(int j = i+1; j < n; j++ )\n\t\t\t\tnoww += w[per[j]];\n\t\t\tif ( s[per[i]] < noww ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdouble s1 = 0, s2 = 0;\n\t\tdouble score = 0;\n\t\tfor(i = 0; i < n; i++ ) {\n\t\t\ts1 += (i+1)*w[per[i]];\n\t\t\ts2 += w[per[i]];\n\t\t}\n\t\tscore = s1/s2;\n\t\tif ( score < bestscore ) {\n\t\t\tbestscore = score;\n\t\t\tfor(i = 0; i < n; i++ )\n\t\t\t\tbestper[i] = per[i];\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tfor( i = 0; i < n; i++ ) {\n\t\tif ( used[i] == 0 ) {\n\t\t\tper[dep] = i;\n\t\t\tused[i] = 1;\n\t\t\tdfs(dep+1);\n\t\t\tused[i] = 0;\n\t\t}\n\t}\n}\nint main() {\n\twhile(cin >> n) {\n\t\tif ( !n ) break;\n\t\tint i;\n\t\tbestscore = 252521833;\n\t\tfor(i = 0; i < n; i++ )\n\t\t\tcin >> name[i] >> w[i] >> s[i];\n\t\tdfs(0);\n\t\tfor(i = 0; i < n; i++ )\n\t\t\tcout << name[bestper[i]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ndouble getcog(vi& ps,vi& ws)\n{\n\tint size=ps.size();\n\tint temp=0;\n\trep(i,size)\n\t\ttemp+=(i+1)*ws[ps[i]];\n\treturn (double)temp/accumulate(allof(ws),0);\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvs ns(n);\n\t\tvi ws(n),cs(n);\n\t\trep(i,n)\n\t\t\tcin>>ns[i]>>ws[i]>>cs[i];\n\t\t\n\t\tdouble cog=1e10;\n\t\tvi ps(n),res(n);\n\t\trep(i,n) ps[i]=i;\n\t\tdo{\n\t\t\tvi ss(n);\n\t\t\tfor(int i=n-2;i>=0;i--)\n\t\t\t\tss[i]=ss[i+1]+ws[ps[i+1]];\n\t\t\tbool ok=true;\n\t\t\trep(i,n)\n\t\t\t\tok&=ss[i]<=cs[ps[i]];\n\t\t\tif(ok){\n\t\t\t\tdouble temp=getcog(ps,ws);\n\t\t\t\tif(temp<cog){\n\t\t\t\t\tcog=temp;\n\t\t\t\t\tres=ps;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(allof(ps)));\n\t\t\n\t\trep(i,n)\n\t\t\tcout<<ns[res[i]]<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<tuple<string, int, int>> v(n);\n        for(int i=0; i<n; ++i) {\n            string name;\n            int w, s;\n            cin >> name >> w >> s;\n            v[i] = make_tuple(name, w, s);\n        }\n        vector<int> id(n);\n        for(int i=0; i<n; ++i) {\n            id[i] = i;\n        }\n        vector<string> res(n);\n        double g = 1e9;\n        do {\n            bool ok = true;\n            int sum = 0;\n            for(int i=n-1; i>=0; --i) {\n                ok &= sum <= get<2>(v[id[i]]);\n                sum += get<1>(v[id[i]]);\n            }\n            if(ok) {\n                double g2 = 0;\n                for(int i=0; i<n; ++i) {\n                    g2 += get<1>(v[id[i]]) * (i+1);\n                }\n                if(g2 < g) {\n                    g = g2;\n                    for(int i=0; i<n; ++i) {\n                        res[i] = get<0>(v[id[i]]);\n                    }\n                }\n            }\n        } while(next_permutation(id.begin(), id.end()));\n        \n        for(auto& x : res) {\n            cout << x << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\ntypedef pair<double, vi> P;\nstruct food\n{\n\tstring name;\n\tint w;\n\tint s;\n};\nint n;\nvector<food> a;\n\nP calc(int bit, int s, double g, double d)\n{\n\tif (s < 0)return P(-1, {});\n\tint _n = __builtin_popcount(bit);\n\tif (_n == n)\n\t\treturn P(g / d, {});\n\n\tP ans = P(9999999999.0, {});\n\tFOR(i, n)\n\t{\n\t\tif (bit & 1 << i)continue;\n\t\tint nbit = bit | 1 << i;\n\t\tint ns = min(s - a[i].w, a[i].s);\n\t\tdouble ng = g + (_n + 1)*a[i].w;\n\t\tdouble nd = d + a[i].w;\n\t\tP x = calc(nbit, ns, ng, nd);\n\t\tif (x.first < 0)continue;\n\t\tif (ans.first > x.first)\n\t\t{\n\t\t\tans = x;\n\t\t\tans.second.insert(ans.second.begin(), i);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile (cin >> n&&n)\n\t{\n\t\ta.clear();\n\t\tFOR(i, n)\n\t\t{\n\t\t\tfood f;\n\t\t\tcin >> f.name >> f.w >> f.s;\n\t\t\ta.push_back(f);\n\t\t}\n\t\tP ans = calc(0, INT_MAX, 0, 0);\n\t\tFOR(i, n)\n\t\t{\n\t\t\tcout << a[ans.second[i]].name << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tstring name[11];\n\t\tint\tw[11],s[11];\n\t\tREP(i,n)cin>>name[i]>>w[i]>>s[i];\n\t\tvector<int> seq(n);\n\t\tREP(i,n)seq[i] = i;\n\t\tint minG = INF;\n\t\tvector<int> ans;\n\t\tdo{\n\t\t\tint sum = 0;\n\t\t\tint G = 0;\n\t\t\tbool ng = false;\n\t\t\tREP(i,n){\n\t\t\t\tint j = seq[i];\n\t\t\t\tif(s[j] < sum)ng = true;\n\t\t\t\tsum += w[j];\n\t\t\t}\n\t\t\tif(ng)continue;\n\t\t\tREP(i,n){\n\t\t\t\tint j = seq[i];\n\t\t\t\tG += (n - i) * w[j];\n\t\t\t}\n\t\t\tif(G < minG){\n\t\t\t\tminG = G;\n\t\t\t\tans = seq;\n\t\t\t}\n\t\t}while(next_permutation(seq.begin(), seq.end()));\n\t\tREP(i,n){\n\t\t\tint j = ans[n - 1 - i];\n\t\t\tcout<<name[j]<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Food {\n\tint id;\n\tstring name;\n\tint w, s;\n\t\n\tFood(){id = 0; w = 0; s = 0;}\n\t\n\tbool operator < (const Food &t) const {\n\t\treturn id < t.id;\n\t}\n};\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n), n){\n\t\tvector<Food> f(n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tf[i].id = i;\n\t\t\tcin >> f[i].name >> f[i].w >> f[i].s;\n\t\t}\n\t\t\n\t\tvector<Food> res(n);\n\t\tint minG = 1001001001;\n\t\t\n\t\tdo {\n\t\t\tint sum = 0;\n\t\t\tbool fl = false;\n\t\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\t\tif (f[i].s < sum){\n\t\t\t\t\tfl = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsum += f[i].w;\n\t\t\t}\n\t\t\t\n\t\t\tif (!fl){\n\t\t\t\tint G = 0;\n\t\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\t\tG += f[i].w * (i + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (minG > G){\n\t\t\t\t\tres = f;\n\t\t\t\t\tminG = G;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} while (next_permutation(f.begin(), f.end()));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcout << res[i].name << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\nusing namespace std;\nint n, w[1000], s[1000];\nstring S[1000]; vector<int>b; int maxn;\nint main() {\n\twhile (true) {\n\t\tcin >> n; b.clear(); maxn = 1 << 30;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> S[i] >> w[i] >> s[i];\n\t\t}\n\t\tvector<int>a(n, 0);\n\t\tfor (int i = 0; i < n; i++)a[i] = i;\n\t\tdo {\n\t\t\tint sum2 = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tsum += w[a[j]];\n\t\t\t\t}\n\t\t\t\tif (sum > s[a[i]]) goto E;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)sum2 += i*w[i];\n\t\t\tif (maxn > sum2)b = a;\n\t\tE:;\n\t\t} while (next_permutation(a.begin(), a.end()));\n\t\tfor (int i = 0; i < n; i++)cout << S[b[i]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\n#define N 11\n\nusing namespace std;\n\nstruct food{\n\tstring name;\n\tint w;\n\tint s;\n};\n\nvoid dfs(int n, const vector<food> &f, bool flag[N], vector<food> &now, double &bestG, vector<food> &ans){\n\tint sumwG_denom = 0;\n\tint sumwG_numer = 0;\n\tdouble nowG = 0;\n\n\tfor(unsigned int i = 0; i < now.size(); ++i){\n\t\tint sumw = 0;\n\t\tsumwG_numer += (i+1)*now[i].w;\n\t\tsumwG_denom += now[i].w;\n\t\tfor(unsigned int j = i + 1; j < now.size(); ++j){\n\t\t\tsumw += now[j].w;\n\t\t}\n\t\tif( sumw > now[i].s )\n\t\t\treturn ;\n\t}\n\tif( sumwG_denom > 0 ){\n\t\tnowG = sumwG_numer / (double)sumwG_denom;\n\t\t\n\t\t\n\t\t/*if( now.size() == n ){\n\t\t\tcout << \" ------------------ \\n\";\n\t\t\tfor(unsigned int i = 0; i < now.size(); ++i){\n\t\t\t\tcout << now[i].name << endl;\n\t\t\t}\n\t\t\tcout << \"BEST : \" << bestG << \" G: \" << nowG << endl;\n\t\t}*/\n\t\t\n\n\t\tif( now.size() == n && nowG < bestG ){\n\t\t\tbestG = nowG;\n\t\t\tans = now;\n\t\t}\n\t}\n\t\n\tfor(unsigned int i = 0; i < f.size(); ++i){\n\t\tif( !flag[i] ){\n\t\t\tflag[i] = true;\n\t\t\tnow.push_back( f[i] );\n\t\t\tdfs( n, f, flag, now, bestG, ans );\n\t\t\tnow.erase( now.end() - 1 );\n\t\t\tflag[i] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tdouble bestG = 1000000;\n\t\tbool flag[N] = {false,};\n\t\tvector< food > vfoods, init, ans;\n\t\t\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfood f;\n\t\t\tcin>>f.name>>f.w>>f.s;\n\t\t\tvfoods.push_back( f );\n\t\t}\n\t\tdfs( n, vfoods, flag, init, bestG, ans );\n\t\tfor(unsigned int i = 0; i < ans.size(); ++i){\n\t\t\tcout << ans[i].name << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define rep(i,n) for(int i=0; i<n; i++)\n#define INF (1<<20)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n) \n\t{\n\t\tvector<pair<pair<int, int>,string> > v;\n\t\tbool used[20] = {0};\n\t\tint sum = 0;\n\t\trep(i,n){\n\t\t\tstring f;\n\t\t\tint w, s;\n\t\t\tcin >> f >> w >> s;\n\t\t\tv.push_back({{w,s},f });\n\t\t\tsum += w;\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\t\treverse(v.begin(),v.end());\n\n\t\trep(j,n){\n\t\t\trep(i, n) {\n\t\t\t\tif (!used[i]) {\n\t\t\t\t\tif (v[i].first.second >= sum - v[i].first.first) {\n\t\t\t\t\t\tcout << v[i].second << endl;\n\t\t\t\t\t\tsum -= v[i].first.first;\n\t\t\t\t\t\tused[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(v.begin(), v.end());\n\t\t\treverse(v.begin(), v.end());\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint N;\nstring F[10];\nint W[10], S[10];\n\nbool isValid(int id[]) {\n  int sumW = 0;\n  for(int i = N-1; i >= 0; --i) {\n    if(S[id[i]] < sumW) return false;\n    sumW += W[id[i]];\n  }\n  return true;\n}\n\ndouble getG(int id[]) {\n  int a, b;\n  a = b = 0;\n  for(int i = 0; i < N; ++i) {\n    a += W[id[i]]*(i+1);\n    b += W[id[i]];\n  }\n  return (double)a/b;\n}\n\nvoid solve() {\n  int id[N], ans[N];\n  double g = -1;\n  for(int i = 0; i < N; ++i) id[i] = i;\n  do {\n    if(isValid(id)) {\n      double newG = getG(id);\n      if(g == -1 || newG < g) {\n\tg = newG;\n\tfor(int i = 0; i < N; ++i) ans[i] = id[i];\n      }\n    }\n  } while(next_permutation(id, id+N));\n  for(int i = 0; i < N; ++i) cout << F[ans[i]] << endl;\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i)\n      cin >> F[i] >> W[i] >> S[i];\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef pair<int,string> P;\ntypedef pair<int,P> PP;\n\nint n,a;\nPP in[10],tmp;\nint t[10];\nvector<int>ans;\n\nint get_weight(int);\n\nint main(){\n  while(cin>>n&&n!=0){\n    ans.clear();\n    for(int i=0;i<n;i++)cin>>in[i].second.second>>in[i].second.first>>in[i].first;\n    sort(in,in+n);\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n-1;j++){\n\ta=get_weight(j)+in[j+1].second.first;\n\tif(a<=in[j].first&&in[j].second.first>in[j+1].second.first){\n\t  tmp=in[j];in[j]=in[j+1];in[j+1]=tmp;\n\t}\n      }\n    }\n    \n    for(int i=n-1;i>=0;i--)cout<<in[i].second.second<<endl;\n    \n    \n  }\n  return 0;\n}\n\nint get_weight(int x){\n  int res=0;\n  for(int i=0;i<x;i++)res+=in[i].second.first;\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require sqrt ceil floor\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <stdint.h>\t// require uint64_t\n#include <fstream>\t// require freopen\n\nusing namespace std;\n\ntypedef pair <pair<int, int>, string > ITEM;\n\n\ndouble getG (vector <ITEM> item )\n{\n\tint size = item.size();\n\n\tdouble total_w = 0., ans = 0.;\n\tfor (int i = 0; i < size; ++i ){\n\t\ttotal_w += (double)item[i].first.second;\n\t} // end for\n\tfor (int i = 0; i < size; ++i ){\n\t\tans += (double)( (i+1)*(item[i].first.second) );\n\t} // end for\n\n\tans /= total_w;\n\n\treturn ans;\n}\n\nbool is_gain_up (vector <ITEM> cand )\n{\n\tint size = cand.size();\n\n\tfor (int i = 0; i < size - 1; ++i ){\n\t\tint total_w = 0;\n\t\tfor (int j = i + 1; j < size; ++j ){\n\t\t\ttotal_w += cand[j].first.second;\n\t\t} // end if\n\t\tif (total_w <= cand[i].first.first ) {\n\t\t\tcontinue;\n\t\t}else{\n\t\t\treturn false;\n\t\t} // end if\n\t} // end for\n\t\n\treturn true;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.lunch\", \"r\", stdin );\n\tint n;\n\n\twhile (cin >> n && n ){\n\t\tvector <ITEM> list(n);\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> list[i].second;\n\t\t\tcin >> list[i].first.second;\n\t\t\tcin >> list[i].first.first;\n\t\t} // end for\n\n\t\tvector <int> order(n, 0 );\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\torder[i] = i;\n\t\t} // end for\n\t\tvector <ITEM> res;\n\t\tvector <ITEM> cand;\n\t\tdouble minG = DBL_MAX;\n\t\tdo{\n\t\t\tcand.clear();\n\t\t\tcand.resize(n);\n\t\t\tfor (int i = 0; i < n; ++i ){\n\t\t\t\tcand[i] = list[order[i]];\n\t\t\t} // end for\n\t\t\tif (is_gain_up(cand) ){\n\t\t\t\tif (minG > getG(cand ) ){\n\t\t\t\t\tminG = getG(cand );\n\t\t\t\t\tres = cand;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t}while (next_permutation (order.begin(), order.end() ) );\n\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\tcout << res[i].second << endl;\n\t\t} // end for\n\t\n\t} // end while\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nbool debug = true;\n\nstruct food {\n    string name;\n    int w, s;\n    bool operator<(const food& o) const {\n        return w == o.w ? (s == o.s ? name < o.name : s < o.s) : w < o.w;\n    }\n};\n\nint sum(vector<food> ns) {\n    int ret = 0;\n    for (int i = 0; i < ns.size(); i++) \n        ret += ns[i].w;\n    return ret;\n}\n\nbool compare_result(const vector<food>& a, const vector<food>& b) {\n    //for (int i = 0; i < a.size(); i++) cout << a[i].w << ' '; cout << endl;\n    //for (int i = 0; i < b.size(); i++) cout << b[i].w << ' '; cout << endl;\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i].w > b[i].w) return true;\n        if (a[i].w == b[i].w) continue;\n        else return false;\n    }\n    return true;\n}\n\nint n;\nint main() {\n    while (cin >> n, n != 0) {\n        vector<food> foods(n);\n        for (int i = 0; i < n; i++) {\n            food f;\n            cin >> f.name >> f.w >> f.s;\n            foods[i] = f;\n        }\n        sort(foods.begin(), foods.end());\n        int total_weight = sum(foods);\n        vector<food> res(foods);\n        do {\n            //for (int i = 0; i < n; i++) cout << foods[i].name << ' '; cout << endl;\n            int weight_above = total_weight;\n            bool found = true;\n            for (int i = 0; i < n; i++) {\n                weight_above -= foods[i].w;\n//                cout << foods[i].name << ' ' << foods[i].s << ' ' << weight_above << endl;\n                if (foods[i].s < weight_above) {\n                    found = false;\n                    break;\n                }\n            }\n            if (!found) {\n                //cout << weight_above << endl;\n                continue;\n            } else {\n                if (compare_result(foods, res)) {\n                    res = foods;\n                    //for (int i = 0; i < n; i++) cout << res[i].name << ' '; cout << endl;\n                }\n                //for (int i = 0; i < n; i++) \n                //    cout << foods[i].name << ' '\n                //         << foods[i].w    << ' '\n                //         << foods[i].s    << ' ' << endl;\n                //if (debug) cout << endl;\n            }\n        } while (next_permutation(foods.begin(), foods.end()));\n        for (int i = 0; i < n; i++) \n            //cout << res[i].name << ' '\n            //     << res[i].w    << ' '\n            //     << res[i].s    << ' ' << endl;\n            cout << res[i].name << endl;\n        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring f[11]; int n, s[11], w[11], p[11], q[11];\nbool ok() {\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint r = 0;\n\t\tfor (int j = i + 1; j < n; j++) r += w[p[j]];\n\t\tif (r > s[p[i]]) return false;\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) cin >> f[i] >> w[i] >> s[i];\n\t\tfor (int i = 0; i < n; i++) p[i] = i, q[i] = -1;\n\t\tdo {\n\t\t\tif (ok()) {\n\t\t\t\tif (q[0] == -1) for (int i = 0; i < n; i++) q[i] = p[i];\n\t\t\t\telse {\n\t\t\t\t\tint sum1 = 0, sum2 = 0;\n\t\t\t\t\tfor (int i = 0; i < n; i++) sum1 += w[p[i]] * (i + 1), sum2 += w[q[i]] * (i + 1);\n\t\t\t\t\tif (sum1 < sum2) for (int i = 0; i < n; i++) q[i] = p[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} while (next_permutation(p, p + n));\n\t\tfor (int i = 0; i < n; i++) cout << s[q[i]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef struct i{char f[21];int s,w;} i;\ni g[10];\nint n,t[10],f[10],ans[10],max;\nvoid rec(int d)\n{\n\tint i,w=0,G=0;\n\tif(d==n)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(w>g[t[i]].s)\n\t\t\t\treturn;\n\t\t\tw+=g[t[i]].w;\n\t\t\tG+=g[t[i]].w*(i+1);\n\t\t}\n\t\tif(max<G)\n\t\t{\n\t\t\tmax=G;\n\t\t\tmemcpy(ans,t,40);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(!f[i])\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tt[d]=i;\n\t\t\t\trec(d+1);\n\t\t\t\tf[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i;\n\tfor(;;)\n\t{\n\t\tmemset(ans,0,40);\n\t\tmemset(f,0,40);\n\t\tmax=0;\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%s %d%d\",g[i].f,&g[i].w,&g[i].s);\n\t\trec(0);\n\t\twhile(-- n>=0)\n\t\t\tputs(g[ans[n]].f);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef pair<int,string> P;\ntypedef pair<int,P> PP;\n\nint n,a;\nPP in[10],tmp;\nint t[10];\nvector<int>ans;\n\nint get_weight(int);\n\nint main(){\n  while(cin>>n&&n!=0){\n    ans.clear();\n    for(int i=0;i<n;i++)cin>>in[i].second.second>>in[i].second.first>>in[i].first;\n    sort(in,in+n);\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n-1;j++){\n\ta=get_weight(j)+in[j+1].second.first;\n\tif(a<=in[j].first&&in[j].second.first>in[j+1].second.first){\n\t  tmp=in[j];in[j]=in[j+1];in[j+1]=tmp;\n\t}else if(a<=in[j].first&&(in[j].second.first==in[j+1].second.first&&in[j].first>in[j+1].first)){\n\t  tmp=in[j];in[j]=in[j+1];in[j+1]=tmp;\n\t}\n      }\n    }\n    \n    for(int i=n-1;i>=0;i--)cout<<in[i].second.second<<endl;\n    \n    \n  }\n  return 0;\n}\n\nint get_weight(int x){\n  int res=0;\n  for(int i=0;i<x;i++)res+=in[i].second.first;\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint me[10],soft[10],n;\nchar str[10][21];\nvoid serch(int num,int now,int sum,int point,int co)\n{\n    if(num==0)return;\n    else if(n==now){\n        soft[point]=-10000;\n        cout<<str[point]<<endl;;\n        serch(num-1,0,sum-me[point],0,0);\n    }\n    else if(sum-me[now]<=soft[now]&&co==0)serch(num,now+1,sum,now,1);\n    else if(sum-me[now]<=soft[now]&&me[point]<me[now])serch(num,now+1,sum,now,1);\n    else serch(num,now+1,sum,point,co);\n}\nint main()\n{\n    while(cin>>n,n){\n        int sum=0;\n        for(int i=0;i<n;i++){\n            cin>>str[i]>>me[i]>>soft[i];\n            sum+=me[i];\n        }\n        serch(n,0,sum,0,0);\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\nstruct food {\n\tchar fn[21];\n\tint g;\n\tint s;\n};\nint f[10],an[10],m;\nfood fd[10],sf;\n\nint ans(int n,int s) {\n\tint i;\n\tif (n==-1) { for (i=m-1;i>=0;i--) cout << fd[an[i]].fn << endl; return 1;}\n\tfor (i=m-1;i>=0;i--) {\n\t\tif (f[i]==0 && fd[i].s>=s-fd[i].g) {\n\t\t\tf[i]=1; an[n]=i;\n\t\t\tif (ans(n-1,s-fd[i].g)==1) return 1; \n\t\t\tf[i]=0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint i,j,s;\n\twhile(cin >> m) {\n\t\tif (m==0) break;\n\t\tfor (i=0,s=0;i<m;i++) { f[i]=0; cin >> fd[i].fn >> fd[i].g >> fd[i].s;  s+=fd[i].g;}\n\t\tfor (i=1;i<m;i++) for (j=0;j<m-i;j++) if (fd[j].g>fd[j+1].g) { sf=fd[j]; fd[j]=fd[j+1]; fd[j+1]=sf;}\n        ans(m-1,s);\t\t\n\t}\n return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint n;\nbool co[10]={false};\nstring in[10]={\"\"};\nint in1[10]={0};\nint in2[10]={0};\nint out[10]={0};\ndouble mini=-1.0;\nvoid solve(int a,vector<int>tmp){\n\t//cout<<a<<endl;\n\t//if(a==3)rep(i,n)cout<<\" \"<<co[i];\n\tif(a==n){\n\t\tdouble sum=0;\n\t\tdouble sum1=0;\n\t\trep(i,n){\n\t\t\tsum+=(i+1)*in1[tmp[i]];\n\t\t\tsum1+=in1[tmp[i]];\n\t\t}\n\t\tdouble g=sum/sum1;\n\t\tif(mini<0||mini>g){\n\t\t\tmini=g;\n\t\t\trep(i,n)out[i]=tmp[i];\n\t\t}\n\t}else{\n\trep(i,n){\n\t\tif(co[i])continue;\n\t\tint sum=in1[i];\n\t\tbool h=true;\n\t\tfor(int j=tmp.size()-1;j>=0;j--){\n\t\t\tif(in2[tmp[j]]<sum){h=false;break;}\n\t\t\tsum+=in1[tmp[j]];\n\t\t}\n\t\tif(h){\n\t\t\ttmp.pb(i);\n\t\t\tco[i]=true;\n\t\t\tsolve(a+1,tmp);\n\t\t\ttmp.erase(tmp.begin()+tmp.size()-1);\n\t\t\tco[i]=false;\n\t\t}\n\t}}\n\t//cout<<a<<endl;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tmini=-1.0;\n\t\trep(i,n)co[i]=false;\n\t\trep(i,n)cin>>in[i]>>in1[i]>>in2[i];\n\t\tvector<int>tmp;\n\t\tsolve(0,tmp);\n\t\trep(i,n)cout<<in[out[i]]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n \nint n,a,tmp;\nint s[10],w[10];\nstring f[10],temp;\nint t[10];\nvector<int>ans;\n \nint get_weight(int);\nvoid swap_data(int);\nvoid sort_data();\n \nint main(){\n  while(cin>>n&&n!=0){\n    ans.clear();\n    for(int i=0;i<n;i++){\n      cin>>f[i];\n      cin>>w[i]>>s[i];\n    }\n \n     \n    sort_data();\n \n    //for(int i=0;i<n;i++)cout<<f[i]<<' '<<w[i]<<' '<<s[i]<<endl;\n    //cout<<'='<<endl;\n\n      for(int i=0;i<n;i++){\n    for(int j=0;j<n-1;j++){\n      if(w[j]<w[j+1]){\n        swap_data(j);\n         \n        a=get_weight(j+1);\n        if(a>s[j])swap_data(j);\n         \n \n      \n     \n    }\n      }\n    }\n    for(int i=0;i<n;i++)cout<<f[i]<<endl;\n     \n     \n  }\n  return 0;\n}\n \nint get_weight(int x){\n  int res=0;\n  for(int i=x;i<n;i++)res+=w[i];\n  return res;\n}\n \nvoid swap_data(int x){\n   \n  tmp=w[x];\n  w[x]=w[x+1];\n  w[x+1]=tmp;\n \n  tmp=s[x];\n  s[x]=s[x+1];\n  s[x+1]=tmp;\n \n  temp=f[x];\n  f[x]=f[x+1];\n  f[x+1]=temp;\n}\n \nvoid sort_data(){\n  for(int i=n-1;i>0;i--){\n    for(int j=0;j<i;j++){\n      if(s[j]<s[j+1])swap_data(j);\n      else if(s[j]==s[j+1]&&w[j]<w[j+1])swap_data(j);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Entry {\n\tEntry(){ }\n\tEntry(const Entry &obj) : name(obj.name), w(obj.w), s(obj.s) { }\n\tEntry &operator=(const Entry &obj){ name = obj.name; w = obj.w; s = obj.s; return *this; }\n\tstring name;\n\tint w, s;\n};\n\nstruct WeightComparator {\n\tbool operator()(const Entry &a, const Entry &b){ return a.w < b.w; }\n};\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<Entry> entries;\n\t\tint wsum = 0;\n\t\twhile(n--){\n\t\t\tEntry e;\n\t\t\tcin >> e.name >> e.w >> e.s;\n\t\t\twsum += e.w;\n\t\t\tentries.push_back(e);\n\t\t}\n\t\tpriority_queue<Entry, vector<Entry>, WeightComparator> q;\n\t\twhile(!entries.empty() || !q.empty()){\n\t\t\tvector<Entry>::iterator it = entries.begin();\n\t\t\twhile(it != entries.end()){\n\t\t\t\tif((*it).s >= wsum - (*it).w){\n\t\t\t\t\tq.push(*it);\n\t\t\t\t\tit = entries.erase(it);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t\twsum -= q.top().w;\n\t\t\tcout << q.top().name << endl;\n\t\t\tq.pop();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n;\n  while (cin >> n, n) {\n    vector<string> f(n);\n    vector<int> w(n), s(n), ord(n);\n    for (int i = 0; i < n; i++) {\n      cin >> f[i] >> w[i] >> s[i];\n      ord[i] = i;\n    }\n    double G = 1e9;\n    vector<int> ans(n);\n    do {\n      int sum = 0, no = 0;\n      for (int i = n - 1; i >= 0; i--) {\n        if (s[ord[i]] < sum) no++;\n        sum += w[ord[i]];\n      }\n      if (no) continue;\n      int tmp = 0;\n      for (int i = 0; i < n; i++) {\n        tmp += (i + 1) * w[ord[i]];\n      }\n      double g = 1. * tmp / sum;\n      if (G - g > 1e-10) {\n        G = g;\n        ans = ord;\n      }\n    } while (next_permutation(ord.begin(), ord.end()));\n    for (int i = 0; i < n; i++) {\n      cout << f[ans[i]] << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f));\n\t\tsort(items.begin(),items.end());\n\t\tS=999999999;\n\t\tdo{\n\t\t\tfor(s=w=i=0;i<n;i++){ //from upper\n\t\t\t\tif(items[i].first.second<w)break;\n\t\t\t\tw+=items[i].first.first;\n\t\t\t\ts+=(n-i)*items[i].first.first;\n\t\t\t}\n\t\t\tif(i==n&&s<S)cout<<s<<endl,S=s,result=items;\n\t\t}while(next_permutation(items.begin(),items.end()));\n\t\treverse(result.begin(),result.end());\n\t\tfor(i=0;i<n;i++)cout<<result[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<class T> bool chmin(T &a, const T &b){ return a > b && (a = b, true);}\ntemplate<class T> bool chmax(T &a, const T &b){ return a < b && (a = b, true);}\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        vector<string> S(n);\n        vector<int> W(n), A(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> S[i] >> W[i] >> A[i];\n        }\n        vector<int> T(1 << n), cnt(1 << n);\n        for (int i = 0; i < (1 << n); ++i) {\n            for (int j = 0; j < n; ++j) {\n                if(i&(1 << j)) {\n                    T[i] = T[i^(1 << j)]+W[j];\n                    cnt[i] = cnt[i^(1 << j)]+1;\n                }\n            }\n        }\n        vector<int> dp(1 << n, INF<int>), top(1 << n, INF<int>);\n        dp[0] = 0;\n        for (int i = 0; i < (1 << n); ++i) {\n            for (int j = 0; j < n; ++j) {\n                if(!(i & (1 << j)) && A[j] >= T[i]){\n                    if(chmin(dp[i^(1 << j)], dp[i]+(n+1-cnt[i])*W[j])){\n                        top[i^(1 << j)] = j;\n                    }\n                }\n            }\n        }\n        int cur = (1 << n)-1;\n        queue<string> ans;\n        while(cur){\n            ans.emplace(S[top[cur]]);\n            cur -= 1 << top[cur];\n        }\n        while(!ans.empty()){\n            cout << ans.front() << \"\\n\"; ans.pop();\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct C {\n  int id;\n  int w;\n  int s;\n  static bool compare(const C &l, const C &r) {\n    if (l.w > r.w) {\n      return true;\n    } else if (l.w < r.w) {\n      return false;\n    } else {\n      return (l.s > r.s);\n    }\n  }\n};\n\nint main() {\n  C c[10];\n  char f[10][21];\n  int n, tw, a[10];\n  bool u[10];\n  while (1) {\n    scanf(\"%d\", &n);\n    if (!n) break;\n    for (int i=0; i<n; i++) {\n      c[i].id = i;\n      scanf(\"%s %d %d\", f[i], &c[i].w, &c[i].s);\n    }\n    sort(c, c+n, C::compare);\n    tw = 0;\n    for (int i=0; i<n; i++) {\n      tw += c[i].w;\n    }\n    for (int i=0; i<n; i++) {\n      u[i] = false;\n    }\n    for (int i=0; i<n; i++) {\n      for (int j=0; j<n; j++) {\n        if (!u[j] && tw - c[j].w <= c[j].s) {\n          tw -= c[j].w;\n          a[i] = c[j].id;\n          u[j] = true;\n          break;\n        }\n      }\n    }\n    for (int i=0; i<n; i++) {\n      printf(\"%s\\n\", f[a[i]]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n\tint n,k,s[105],b[105],i,j,x;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&k);\n\t\tif(n==0 && k==0)break;\n\t\tfor(i=0;i<k+1;i++)scanf(\"%d\",&s[i]),b[i]=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<k;j++){\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tb[j]+=x;\n\t\t\t}\n\t\t}\n\t\tx=0;\n\t\tfor(i=0;i<n;i++)\n\t\t\tif(b[i]>s[i]){x=1;break;}\n\t\tif(x==1)printf(\"No\\n\");\n\t\telse printf(\"Yes\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<functional>\n\nconst int MAX_N = (int)1e6;\nstruct Data {\n\tstd::string name;\n\tint weight, max_weight;\n\tData() = default;\n\tData(int _w, int _m, const std::string& _n) : weight(_w), max_weight(_m), name(_n) {}\n\n\tbool operator<(const Data& rhs) const {\n\t\treturn (weight == rhs.weight) ? \n\t\t\t(max_weight==rhs.max_weight)? \n\t\t\tname < rhs.name : max_weight < rhs.max_weight : weight < rhs.weight;\n\t}\n\tbool operator>(const Data& rhs) const{\n\t\treturn (weight == rhs.weight) ?\n\t\t\t(max_weight == rhs.weight) ?\n\t\t\tname > rhs.name : max_weight > rhs.max_weight : weight > rhs.weight;\n\t}\n};\n\n\nint n, sum;\nstd::vector<Data> data;\nstd::string ans[MAX_N];\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n;\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tsum = 0;\n\t\tint _w, _m;\n\t\tstd::string _n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstd::cin >> _n >> _w >> _m;\n\t\t\tdata.push_back(Data(_w, _m, _n));\n\t\t\tsum += data[i].weight;\n\t\t}\n\n\t\tstd::sort(data.begin(), data.end(), std::greater<Data>());\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < data.size(); ++j) {\n\t\t\t\tif (data[j].max_weight >= sum - data[j].weight) {\n\t\t\t\t\tsum -= data[j].weight;\n\t\t\t\t\tans[i] = data[j].name;\n\t\t\t\t\tdata.erase(data.begin() + j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tstd::cout << ans[i] << std::endl;\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\nstruct food\n{\n\tint w;\n\tint s;\n\tstring name;\n\n\tbool operator < (const food& right) const {\n\t\treturn w >= right.w;\n\t}\n};\n\nint n;\nfood fd[10];\nstring f;\nint tw, ts;\nbool used[10];\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> n;\n\t\tif (n == 0) break;\n \t\trep(i,n)\n\t\t{\n\t\t\tcin >> f >> tw >> ts;\n\t\t\tfd[i].name = f;\n\t\t\tfd[i].w = tw;\n\t\t\tfd[i].s = ts;\n\t\t}\n\n\t\tsort(fd, fd + n);\n\t\tint wsum = 0;\n\t\trep(i,n) wsum += fd[i].w;\n\n\t\trep(i,n) used[i] = false;\n\t\trep(i,n)\n\t\t{\n\t\t\trep(j,n)\n\t\t\t{\n\t\t\t\tif (!used[j] && fd[j].s >= wsum - fd[j].w)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"%s\\n\", fd[j].name);\n\t\t\t\t\tcout << fd[j].name << endl;\n\t\t\t\t\twsum -= fd[j].w;\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst double EPS = 1e-6;\n\nint main(void) {\n\tint N;\n\twhile (cin >> N, N) {;\n\t\tvector<string> F(N);\n\t\tVI W(N), S(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> F[i] >> W[i] >> S[i];\n\t\t}\n\n\t\tVI p(N);\n\t\tiota(p.begin(), p.end(), 0);\n\n\t\tdouble ans = 1e+8;\n\t\tVI best_p(p.begin(), p.end());\n\n\t\tdo {\n\t\t\tdouble g = 0, gt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg += (i + 1) * W[p[i]];\n\t\t\t\tgt += W[p[i]];\n\t\t\t}\n\t\t\tg /= gt;\n\n\t\t\tif (g - EPS > ans) { continue; }\n\n\t\t\tint total = 0;\n\t\t\tbool flg = true;\n\t\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\t\tflg &= total <= S[p[i]];\n\t\t\t\ttotal += W[p[i]];\n\t\t\t}\n\n\t\t\tif (flg && g < ans + EPS) {\n\t\t\t\tans = g;\n\t\t\t\tswap(best_p, p);\n\t\t\t}\n\t\t} while (next_permutation(p.begin(), p.end()));\n\n\t\tfor (auto i : best_p) {\n\t\t\tcout << F[i] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstruct food{\n\tstring f;\n\tint w;\n\tint s;\n};\n\nint n;\nvector<food> foods;\nvector<string> res;\npair<int,vector<string> > result;\n\nvoid f(int b,int w,int k){\n\tint i;\n//cout<<b<<\" \"<<w<<endl<<\" \";\n//for(i=0;i<res.size();i++)cout<<res[i]<<endl;\n//cout<<endl;\n\tif(b==(1<<n)-1){\n\t\tif(result.first>k){\n\t\t\tresult.first=k;\n\t\t\tresult.second.clear();\n\t\t\tfor(i=0;i<n;i++)result.second.push_back(res[i]);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tif(b&1<<i)continue;\n\t\tif(foods[i].s<w)continue;\n\t\tres.push_back(foods[i].f);\n\t\tf(b|1<<i,w+foods[i].w,k+w+foods[i].w);\n\t\tres.pop_back();\n\t}\n}\n\nint main() {\n\twhile(n=in()){\n\t\tint i;\n\t\tfoods.clear();\n\t\tfood buf;\n\t\tresult.first=1000000000;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>buf.f>>buf.w>>buf.s;\n\t\t\tfoods.push_back(buf);\n\t\t}\n\t\tres.clear();\n\t\tf(0,0,0);\n\t\tfor(i=0;i<n;i++){\n\t\t\tcout<<result.second[n-i-1]<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\nusing namespace std;\nint n, w[1000], s[1000];\nstring S[1000]; vector<int>b; int maxn;\nint main() {\n\twhile (true) {\n\t\tcin >> n; b.clear(); maxn = 1 << 30;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> S[i] >> w[i] >> s[i];\n\t\t}\n\t\tvector<int>a(n, 0);\n\t\tfor (int i = 0; i < n; i++)a[i] = i;\n\t\tdo {\n\t\t\tint sum2 = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tsum += w[a[j]];\n\t\t\t\t}\n\t\t\t\tif (sum > s[i]) goto E;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)sum2 += i*w[i];\n\t\t\tif (maxn > sum2)b = a;\n\t\tE:;\n\t\t} while (next_permutation(a.begin(), a.end()));\n\t\tfor (int i = 0; i < n; i++)cout << S[a[i]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint me[10],rigidity[10],n;\nchar str[10][21];\nvoid serch(int num,int now,int sum,int point,int co)\n{\n    if(num==0)return;\n    else if(n==now){\n        rigidity[point]=-10000;\n        cout<<str[point]<<endl;;\n        serch(num-1,0,sum-me[point],0,0);\n    }\n    else if(sum-me[now]<=rigidity[now]&&co==0)serch(num,now+1,sum,now,1);\n    else if(sum-me[now]<=rigidity[now]&&me[point]<me[now])serch(num,now+1,sum,now,1);\n    else serch(num,now+1,sum,point,co);\n}\nint main()\n{\n    while(cin>>n,n){\n        int sum=0;\n        for(int i=0;i<n;i++){\n            cin>>str[i]>>me[i]>>rigidity[i];\n            sum+=me[i];\n        }\n        serch(n,0,sum,0,0);\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst double EPS = 1e-6;\n\nint main(void) {\n\tint N;\n\twhile (cin >> N, N) {;\n\t\tvector<string> F(N);\n\t\tVI W(N), S(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> F[i] >> W[i] >> S[i];\n\t\t}\n\n\t\tVI p(N);\n\t\tiota(p.begin(), p.end(), 0);\n\n\t\tdouble ans = 1e+8;\n\t\tVI best_p(p.begin(), p.end());\n\n\t\tdo {\n\t\t\tdouble g = 0, gt = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg += (i + 1) * W[p[i]];\n\t\t\t\tgt += W[p[i]];\n\t\t\t}\n\t\t\tg /= gt;\n\n\t\t\tint total = 0;\n\t\t\tbool flg = true;\n\t\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\t\tflg &= total <= S[p[i]];\n\t\t\t\ttotal += W[p[i]];\n\t\t\t}\n\n\t\t\tif (flg && g < ans + EPS) {\n\t\t\t\tans = g;\n\t\t\t\tswap(best_p, p);\n\t\t\t}\n\t\t} while (next_permutation(p.begin(), p.end()));\n\n\t\tfor (auto i : best_p) {\n\t\t\tcout << F[i] << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\n#include<functional>\nusing namespace std;\n\nstruct Food{\n\tstring f;\n\tint w,s;\n\tbool operator <(const Food &a)const{\n\t\tif(w==a.w) return s>a.s;\n\t\treturn w>a.w;\n\t}\n};\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tint sumW = 0;\n\t\tFood food[10];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>food[i].f>>food[i].w>>food[i].s;\n\t\t\tsumW += food[i].w;\n\t\t}\n\t\tsort(food,food+N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(food[j].w == -1) continue;\n\t\t\t\tif(food[j].s >= sumW-food[j].w){\n\t\t\t\t\tcout<<food[j].f<<endl;\n\t\t\t\t\tsumW -= food[j].w; food[j].w = -1; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\nusing namespace std;\n\nstruct data{\n    string name;\n    int w, s;\n};\n\nbool cmp(data d1, data d2){\n    if(d1.w == d2.w){\n        return d1.s > d2.s;\n    }\n    return d1.w > d2.w;\n};\n\nsigned main(){\n    int n;\n    while(cin >> n, n){\n        vector<data> in(n);\n        int sum = 0;\n        rep(i, 0, n){\n            cin >> in[i].name >> in[i].w >> in[i].s;\n            sum += in[i].w;\n        }\n        vector<string> ans;\n        rep(i, 0, n){\n            sort(all(in), cmp);\n            rep(j, 0, in.size()){\n                if(in[j].s >= sum - in[j].w){\n                    ans. push_back(in[j].name);\n                    sum -= in[j].w;\n                    in[j].w = -1;\n                    in[j].s = -1;\n                }\n            }\n        }\n        rep(i, 0, n){\n            cout << ans[i] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct lunch{\n    string name;\n    int omosa,genkai;\n    };\nlunch a[10];\nsigned main(){\n    int b;\n    while(cin>>b,b){\n\tfor(int c=0;c<b;c++){\n\t    string d;int e,f;cin>>d>>e>>f;\n\t    a[c]={d,e,f};\n\t    }\n\t    vector<int>c;\n\t    for(int i=0;i<b;i++){c.push_back(i);}\n\t    int MIN=1<<29;\n\t    do{\n\t\tint sum=0;\n\t\tbool S=true;\n\t\tfor(int i=b-1;i>=0;i--){\n\t\t    if(sum>a[c[i]].genkai)S=false;\n\t\t    sum+=a[c[i]].omosa;\n\t\t    }\n\t\t if(S){\n\t\t     int zyuusin=0;\n\t\t     for(int i=0;i<b;i++){\n\t\t\t zyuusin+=(i+1)*a[c[i]].omosa;\n\t\t\t }\n\t\t\t MIN=min(MIN,zyuusin);\n\t\t     }   \n\t\t}while(next_permutation(c.begin(),c.end()));\n\t\tdo{\n\t\tint sum=0;\n\t\tbool S=true;\n\t\tfor(int i=b-1;i>=0;i--){\n\t\t    if(sum>a[c[i]].genkai)S=false;\n\t\t    sum+=a[c[i]].omosa;\n\t\t    }\n\t\t if(S){\n\t\t     int zyuusin=0;\n\t\t     for(int i=0;i<b;i++){\n\t\t\t zyuusin+=(i+1)*a[c[i]].omosa;\n\t\t\t }\n\t\t\t if(zyuusin==MIN){\n\t\t\t     for(int i=0;i<b;i++){\n\t\t\t\t cout<<a[c[i]].name<<endl;\n\t\t\t\t }\n\t\t\t     }\n\t\t     }   \n\t\t}while(next_permutation(c.begin(),c.end()));\n\t}\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring f[11];\nint ans[11];\nint n;\nint w[11],s[11];\n\nvoid solve(){\n\tfor(int i=1; i<=n; i++)\n\t\tans[i] = i;\n\tfor(int k=1; k<=n; k++){\n\t\tfor(int i=n; i>k; i--){\n\t\t\tif(s[ans[i]] > s[ans[i-1]]){\n\t\t\t\tint tmp = ans[i];\n\t\t\t\tans[i] = ans[i-1];\n\t\t\t\tans[i-1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\tbool flag = true;\n\tfor(int i=1; i<=n; i++){\n\t\tif(i==n&&!flag){\n\t\t\ti=1;\n\t\t\tflag = true;\n\t\t}else if(i==n)\n\t\t\tbreak;\n\t\tif(w[ans[i]] < w[ans[i+1]]){\n\t\t\tint tmp = w[ans[i]];\n\t\t\tfor(int k=i+2; k<=n; k++)\n\t\t\t\ttmp += w[ans[k]];\n\t\t\tif(s[ans[i+1]] >= tmp){\n\t\t\t\ttmp = ans[i];\n\t\t\t\tans[i] = ans[i+1];\n\t\t\t\tans[i+1] = tmp;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcin >> f[i] >> w[i] >> s[i];\n\t\tsolve();\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcout << f[ans[i]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nint n;\nstring f[10];\nint w[10], s[10];\nbool used[10];\n\nvoid dfs(int sum, int G, int &minG, vector<string> &v, vector<string> &ans) {\n\tif ((int)v.size() == n) {\n\t\tif (G < minG) {\n\t\t\tminG = G;\n\t\t\tans = v;\n\t\t}\n\t\treturn ;\n\t}\n\tfor (int i=0; i<n; ++i) {\n\t\tif ( ! used[i] && sum - w[i] <= s[i]) {\n\t\t\tused[i] = true;\n\t\t\tv.push_back(f[i]);\n\t\t\tdfs(sum-w[i], G+v.size()*w[i], minG, v, ans);\n\t\t\tused[i] = false;\n\t\t\tv.pop_back();\n\t\t}\n\t}\n\treturn ;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tint sum = 0;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> f[i] >> w[i] >> s[i];\n\t\t\tsum += w[i];\n\t\t}\n\t\tmemset(used, false, sizeof used);\n\t\tint minG = INT_MAX;\n\t\tvector<string> v, ans;\n\t\tdfs(sum, 0, minG, v, ans);\n\t\tfor (int i=0; i<(int)ans.size(); ++i) {\n\t\t\tcout << ans[i] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-10;\n\ntypedef struct\n{\n  string f;\n  int w, s;\n} Food;\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    if (n == 0)\n      break;\n\n    vector<Food> foods(n);\n    for (int i = 0; i < n; ++i)\n      cin >> foods[i].f >> foods[i].w >> foods[i].s;\n\n    vector<int> index(n);\n    for (int i = 0; i < n; ++i)\n      index[i] = i;\n\n    double bestG = 1e10;\n    vector<string> ans(n);\n    do {\n      int w = 0, kw = 0;\n      bool valid = true;\n      for (int i = 0; i < n && valid; ++i) {\n\tif (foods[index[i]].s < w)\n\t  valid = false;\n\tw += foods[index[i]].w;\n\tkw += (n-i) * foods[index[i]].w;\n      }\n\n      if (valid) {\n\tdouble G = kw * 1.0 / w;\n\tif (bestG - G > EPS) {\n\t  bestG = G;\n\t  for (int i = 0; i < n; ++i)\n\t    ans[i] = foods[index[i]].f;\n\t}\n      }\n    } while (next_permutation(index.begin(), index.end()));\n\n    reverse(ans.begin(), ans.end());\n    for (int i = 0; i < n; ++i)\n      cout << ans[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nconst ull INF = 1001001001001001001;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct Food{\n    std::string name;\n    ull w, s;\n};\n\nconst int MAX_N = 10;\nint N;\nstd::vector<Food> F;\nint order[MAX_N], fact[11];\n\nint main(){\n    fact[0] = 1;\n    FOR(i, 1, 11){\n        fact[i] = fact[i-1] * i;\n    }\n\n    while(std::cin >> N, N){\n        F.clear();\n\n        REP(i, N){\n            std::string name;\n            ull w, s;\n            std::cin >> name >> w >> s;\n        \n            F.push_back({name, w, s});\n        }\n\n        REP(i, N){\n            order[i] = i;\n        }\n    \n        ull min_cost = INF;\n        int min_order[MAX_N];\n        REP(_, fact[N]){\n            // for(int i=0;i<N;i++){\n            //     printf(\"%d, \", order[i]);\n            // }\n            // puts(\"\");\n\n            bool f = true;\n            ull cost = 0, sum = 0;\n            REP(i, N){\n                int index = order[i];\n                if(sum <= F[index].s);\n                else{f = false;}\n\n                cost += (N-i) * F[index].w;\n                sum += F[index].w;\n            }\n            //std::cout << cost << std::endl;\n\n            if(f && min_cost > cost){\n                min_cost = cost;\n                std::copy(order, order+N, min_order);\n            }\n\n            std::next_permutation(order, order+N);\n        }\n\n        //std::cout << min_cost << std::endl;\n        for(int i=N-1;i>=0;i--){\n            int index = min_order[i];\n            std::cout << F[index].name << std::endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\ntypedef pair <string, II> NODE;\ntypedef vector <NODE> NODES;\n\nvoid solve( int n, NODES nodes ) {\n    int ming = INT_MAX;\n    VS L;\n    VI ID(n);\n    for ( int i = 0; i < n; ++ i ) {\n        ID[i] = i;\n    }\n    do {\n        int wsum = 0, g = 0;\n        for ( int i = 0; i < n; ++ i ) {\n            if ( wsum > nodes[ID[i]].second.second ) goto out_1;\n            wsum += nodes[ID[i]].second.first;\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            g += ( n - i ) * nodes[ID[i]].second.first;\n            if ( g >= ming ) goto out_1;\n        }\n        if ( g < ming ) {\n            ming = g;\n            VS T;\n            for ( int i = 0; i < n; ++ i ) {\n                T.push_back( nodes[ID[i]].first );\n            }\n            L = T;\n        }\n    out_1:;\n    } while ( next_permutation( ID.begin(), ID.end() ) );\n\n    reverse( L.begin(), L.end() );\n    for ( int i = 0; i < n; ++ i ) {\n        cout << L[i] << endl;\n    }\n}\n\nint main() {\n    int n;\n    while ( cin >> n && n ) {\n        NODES nodes( n );\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> nodes[i].first >> nodes[i].second.first >> nodes[i].second.second;\n        }\n        solve( n, nodes );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstruct itm{\n\tstring str;\n\tint w;\n\tint s;\n\tbool f;\n};\n\nint main()\n{\n\tint n, w, p;\n\titm it[11];\n\tstring st[11];\n\tbool f;\n\t\n\twhile(cin >> n && n){\n\t\tw = p = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> it[i].str >> it[i].w >> it[i].s;\n\t\t\tw += it[i].w;\n\t\t\tit[i].f = true;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf = false;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(it[j].f && it[j].s >= (w-it[j].w)){\n\t\t\t\t\tf = true;\n\t\t\t\t\tp = j;\n\t\t\t\t\tfor(int k = j+1; k < n; k++){\n\t\t\t\t\t\tif(it[k].w > it[p].w && it[k].f && it[k].s >= (w-it[k].w)){\n\t\t\t\t\t\t\tp = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tst[i] = it[p].str;\n\t\t\t\tw -= it[p].w;\n\t\t\t\tit[p].f = false;\n\t\t\t\tcout << it[p].str << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint main(){\n    int n;\n    while(cin>>n,n){\n        string Name[10];\n        double w[10],s[10];\n        for(int i=0;i<n;i++)cin>>Name[i]>>w[i]>>s[i];\n        vector<int>p(n),ans;\n        for(int i=0;i<n;i++)p[i]=i;\n        double mi=1<<25;\n        do{\n            double gu=0.0,gl=0.0,t=0.0;\n            bool flag=true;\n            for(int i=0;i<n;i++){\n                int pos=p[i];\n                gu+=(n-i)*w[pos];gl+=w[pos];\n                if(s[pos]<t){\n                    flag=false;\n                    break;\n                }\n                t+=w[pos];\n\n            }\n            if(flag){\n                double g=gu/gl;\n                if(mi>g){\n                    ans=p;\n                    mi=g;\n                }\n            }\n        }while(next_permutation(p.begin(),p.end()));\n\n        reverse(ans.begin(),ans.end());\n        for(int i=0;i<n;i++)cout<<Name[ans[i]]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define ll long long\n#define P pair<int,int>\n#define pb push_back\n\nint n,w[10],s[10],used[10],g;\nstring F[10];\nvector<int> ans;\n\nvoid f(vector<int> order){\n\tif(order.size()==n){\n\t\tint x=0;\n\t\trep(i,n)x+=w[order[i]]*(n-i);\n\t\tif(x<g){\n\t\t\tg=x;\n\t\t\tans=order;\n\t\t}\n\t\treturn;\n\t}\n\tint x=0;\n\trep(i,order.size())x+=w[order[i]];\n\trep(i,n)if(!used[i]&&s[i]>=x){\n\t\torder.pb(i);\n\t\tused[i]=1;\n\t\tf(order);\n\t\tused[i]=0;\n\t\torder.pop_back();\n\t}\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(used,used+n,0);\n\t\tg=INF;\n\t\trep(i,n)cin>>F[i]>>w[i]>>s[i];\n\t\tvector<int> v;\n\t\tf(v);\n\t\trep(i,n)cout<<F[ans[n-1-i]]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<pair<int,int>,string> item;\nmain(){\n\tint n,i,w,s,S;\n\tstring f;\n\tfor(;cin>>n,n;){\n\t\tvector<item> items,result;\n\t\tfor(i=0;i<n;i++)cin>>f>>w>>s,items.push_back(make_pair(make_pair(w,s),f));\n\t\tsort(items.begin(),items.end());\n\t\tS=99999;\n\t\tdo{\n\t\t\tfor(s=w=0,i=n-1;i>=0;i--){\n\t\t\t\tif(items[i].first.second<w)break;\n\t\t\t\tw+=items[i].first.first;\n\t\t\t\ts+=(i+1)*items[i].first.first;\n\t\t\t}\n\t\t\tif(i<0&&s<S)S=s,result=items;\n\t\t}while(next_permutation(items.begin(),items.end()));\n\t\tfor(i=0;i<n;i++)cout<<result[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef pair<int,string> P;\ntypedef pair<int,P> PP;\n\nint n,a;\nPP in[10],tmp;\nint t[10];\nvector<int>ans;\n\nint get_weight(int);\n\nint main(){\n  while(cin>>n&&n!=0){\n    ans.clear();\n    for(int i=0;i<n;i++)cin>>in[i].second.second>>in[i].second.first>>in[i].first;\n    sort(in,in+n);\n\n    for(int i=n-1;i>=0;i--){\n      for(int j=0;j<i;j++){\n       \n\tif(in[j].second.first>in[j+1].second.first){\n\t  tmp=in[j];in[j]=in[j+1];in[j+1]=tmp;\n\t\n\t  a=get_weight(j+1);\n\t  if(a>in[j+1].first){tmp=in[j];in[j]=in[j+1];in[j+1]=tmp;}\n\t}\n\t\n\t\n      }\n    }\n    \n    for(int i=n-1;i>=0;i--)cout<<in[i].second.second<<endl;\n    \n    \n  }\n  return 0;\n}\n\nint get_weight(int x){\n  int res=0;\n  for(int i=0;i<x;i++)res+=in[i].second.first;\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(int w[],int k[],int b[],int a[],int c,int n,int e,int g){\n  int i,j;\n  int bb[10];\n  if(c==n){\n    if(a[10]==0||a[10]>g){\n      a[10]=g;\n      memcpy(a,b,10*sizeof(int));\n    }\n  }else{\n    for(i=0;i<n;i++){\n      if(k[i]>=e){\n\tfor(j=0;j<c;j++){\n\t  if(i==b[j])\n\t    break;\n\t}\n\tif(j==c){\n\t  memcpy(bb,b,sizeof(bb));\n\t  bb[c]=i;\n\t  f(w,k,bb,a,c+1,n,e+w[i],g+w[i]*(n-c));\n\t}\n      }else\n\tbreak;\n    }\n  }\n  return;\n}\nint main(){\n  int h,i;\n  int w[10],k[10],b[10],a[11],n;\n  char s[10][64];\n  for(;;){\n    cin>>n;\n    if(n==0)\n      break;\n    for(i=0;i<n;i++)\n      cin>>s[i]>>w[i]>>k[i];\n    do{\n      h=0;\n      for(i=1;i<n;i++){\n\tif(k[i-1]<k[i]){\n\t  swap(k[i-1],k[i]);\n\t  swap(w[i-1],w[i]);\n\t  swap(s[i-1],s[i]);\n\t  h=1;\n\t}\n      }\n    }while(h);\n    memset(b,0,sizeof(b));\n    memset(a,0,sizeof(a));\n    f(w,k,b,a,0,n,0,0);\n    for(i=0;i<n;i++)\n      cout<<s[a[n-i-1]]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\nstruct food\n{\n\tint f, w, s;\n};\nstruct Sorter\n{\n\tbool operator()(const food& a, const food& b)\n\t{\n\t\treturn a.f < b.f;\n\t}\n};\nint main()\n{\n\tchar name[10][32];\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfood foods[10];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint w, s;\n\t\t\tscanf(\"%s %d %d\", name[i], &w, &s);\n\t\t\tfoods[i].f = i;\n\t\t\tfoods[i].w = w;\n\t\t\tfoods[i].s = s;\n\t\t}\n\n\t\tconst double Inf = 1e12;\n\t\tdouble minG = Inf;\n\t\tint order[10];\n\t\tdo\n\t\t{\n\t\t\tint sumW = 0;\n\t\t\tdouble g = 0;\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif (sumW > foods[i].s)\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsumW += foods[i].w;\n\t\t\t\tg += (n-i) * foods[i].w;\n\t\t\t}\n\t\t\tg /= sumW;\n\t\t\tif (ok && g < minG)\n\t\t\t{\n\t\t\t\tminG = g;\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\torder[i] = foods[i].f;\n\t\t\t}\n\t\t} while (next_permutation(foods, foods+n, Sorter()));\n\t\tfor (int i = n-1; i >= 0; --i)\n\t\t\tprintf(\"%s\\n\", name[order[i]]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring f[11]; int n, s[11], w[11], p[11], q[11];\nbool ok() {\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint r = 0;\n\t\tfor (int j = i + 1; j < n; j++) r += w[p[j]];\n\t\tif (r > s[p[i]]) return false;\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) cin >> f[i] >> w[i] >> s[i];\n\t\tfor (int i = 0; i < n; i++) p[i] = i, q[i] = -1;\n\t\tdo {\n\t\t\tif (ok()) {\n\t\t\t\tif (q[0] == -1) for (int i = 0; i < n; i++) q[i] = p[i];\n\t\t\t\telse {\n\t\t\t\t\tint sum1 = 0, sum2 = 0;\n\t\t\t\t\tfor (int i = 0; i < n; i++) sum1 += w[p[i]] * (i + 1), sum2 += w[q[i]] * (i + 1);\n\t\t\t\t\tif (sum1 < sum2) for (int i = 0; i < n; i++) q[i] = p[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} while (next_permutation(p, p + n));\n\t\tfor (int i = 0; i < n; i++) cout << f[q[i]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// 入力\nstring f[10];\nint n, w[10], s[10]; \n// used[i] := i番目を選んだかどうか\nbool used[10];\n// 今まで見つかった中で一番重心が低いもの\ndouble ans_g;\n// 解\nvector<int> ans;\n\n// 重さに耐えられるかチェック\nbool check(vector<int>& v){\n\tint g[10] = {0};\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tfor(int j=0 ; j < i ; j++ ){\n\t\t\tg[j] += w[v[i]];\n\t\t}\n\t}\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tif( g[i] > s[v[i]] )\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n// 重心を計算\ndouble gravity(vector<int>& v){\n\tint a = 0, b = 0;\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\ta += (i+1) * w[v[i]];\n\t\tb += w[v[i]];\n\t}\n\treturn (double) a / b;\n}\n\n// 探索\nvoid dfs(vector<int>& v, int num){\n\tif( num == n ){\n\t\tdouble g = gravity(v);\n\t\tif( g < ans_g ){\n\t\t\tans = v;\n\t\t}\n\t\treturn;\n\t}\n\t\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( used[i] ) continue;\n\t\t\n\t\tused[i] = true;\n\t\tv.push_back( i );\n\t\t// 重さに耐えられるかチェック\n\t\tif( check(v) ){\n\t\t\tdfs( v , num+1 );\n\t\t}\n\t\tv.pop_back();\n\t\tused[i] = false;\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tfor(int i=0 ; i < 10 ; i++ ) used[i] = false;\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tcin >> f[i] >> w[i] >> s[i];\n\t\t}\n\t\tans_g = 1e+9;\n\t\tvector<int> v;\n\t\tdfs( v , 0 );\n\t\tfor(int i=0 ; i < ans.size() ; i++ ){\n\t\t\tcout << f[ans[i]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, string> P;\ntypedef pair<int, P> Q;\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tQ q;\n\t\tpriority_queue<Q, vector<Q>, greater<Q> > pq;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> (q.second).second >> (q.second).first >> q.first;\n\t\t\tpq.push(q);\n\t\t}\n\t\tvector<Q> data;\n\t\tq = pq.top();\n\t\tpq.pop();\n\t\tdata.push_back(q);\n\t\tint w = (q.second).first;\n\t\twhile (!pq.empty()) {\n\t\t\tdata.push_back(pq.top());\n\t\t\tpq.pop();\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < data.size()-1; i++) {\n\t\t\t\tsum += (data[i].second).first;\n\t\t\t}\n\t\t\tfor (int i = data.size()-1; i > 0; i--) {\n\t\t\t\tif ((data[i].second).first < (data[i-1].second).first) {\n\t\t\t\t\tif (sum-(data[i-1].second).first+(data[i].second).first <= data[i-1].first) {\n\t\t\t\t\t\tsum -= (data[i-1].second).first;\n\t\t\t\t\t\tswap(data[i], data[i-1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = data.size()-1; i >= 0; i--) {\n\t\t\tcout << (data[i].second).second << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nconst ull INF = 1001001001001001001;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct Food{\n    std::string name;\n    ull w, s;\n};\n\nconst int MAX_N = 10;\nint N;\nstd::vector<Food> F;\nint order[MAX_N], fact[11];\n\nint main(){\n    fact[0] = 1;\n    FOR(i, 1, 11){\n        fact[i] = fact[i-1] * i;\n    }\n\n    std::cin >> N;\n    \n    REP(i, N){\n        std::string name;\n        ull w, s;\n        std::cin >> name >> w >> s;\n        \n        F.push_back({name, w, s});\n    }\n\n    REP(i, N){\n        order[i] = i;\n    }\n    \n    ull min_cost = INF;\n    int min_order[MAX_N];\n    REP(_, fact[N]){\n        // for(int i=0;i<N;i++){\n        //     printf(\"%d, \", order[i]);\n        // }\n        // puts(\"\");\n\n        bool f = true;\n        ull cost = 0, sum = 0;\n        REP(i, N){\n            int index = order[i];\n            if(sum <= F[index].s);\n            else{f = false;}\n\n            cost += (N-i) * F[index].w;\n            sum += F[index].w;\n        }\n        //std::cout << cost << std::endl;\n\n        if(f && min_cost > cost){\n            min_cost = cost;\n            std::copy(order, order+N, min_order);\n        }\n\n        std::next_permutation(order, order+N);\n    }\n\n    //std::cout << min_cost << std::endl;\n    for(int i=N-1;i>=0;i--){\n        int index = min_order[i];\n        std::cout << F[index].name << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nstring name[10];\nint w[10];\nint s[10];\n\nvector<int> answer,current;\nint used[10];\nint n;\nint sum = 0;\ndouble jushin = 0 , curr = 0;\nint dfs(int x){\n\tint chksum = 0;\n\tfor(int i = current.size() - 1 ; i >= 0 ; i--){\n\t\tif( chksum > s[current[i]] ) return 0;\n\t\tchksum += w[current[i]];\n\t}\n\t\n\tif( current.size() == n ) {\n\t\tif( jushin < curr ){\n\t\t\tanswer = current;\n\t\t\tcurr = jushin;\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !used[i] ){\n\t\t\tused[i] = true;\n\t\t\tcurrent.push_back(i);\n\t\t\tjushin += x * w[i];\n\t\t\tdfs(x+1);\n\t\t\tjushin -= x * w[i];\n\t\t\tcurrent.pop_back();\n\t\t\tused[i] = false;\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> name[i] >> w[i] >> s[i];\n\t\t}\n\t\tcurr = 1e9;\n\t\tanswer.clear();\n\t\tdfs(1);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcout << name[answer[i]] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define MAX_N 1000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nstruct FOOD{\n\tstring name;\n\tint w;\n\tint s;\n};\n\nstruct DATA{\n\tdouble G;\n\tvector<FOOD> mFoods;\n};\n\nstruct DATA dp[1<<10][10];\n\nbool checkWeight(const vector<FOOD>& vf){\n\tfor(int i=0;i<vf.size();i++){\n\t\tint sum = 0;\n\t\tfor(int j=i+1;j<vf.size();j++){\n\t\t\tsum += vf[j].w;\n\t\t}\n\t\tif(vf[i].s < sum) return false;\n\t}\n\n\treturn true;\n}\n\ndouble getG(const vector<FOOD>& vf){\n\n\tdouble G=0;\n\tdouble sum=0;\n\tfor(int i=0;i<vf.size();i++){\n\t\tG += vf[i].w * (i+1);\n\t\tsum += vf[i].w;\n\t}\n\treturn G / sum;\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tstruct FOOD* food = new struct FOOD[n];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar buf[64];\n\t\t\tint w,s;\n\t\t\tscanf(\"%s %d %d\",buf,&w,&s);\n\t\t\tfood[i].name = buf;\n\t\t\tfood[i].s = s;\n\t\t\tfood[i].w = w;\n\t\t}\n\n\t\tint* table = new int[n];\n\t\tfor(int i=0;i<n;i++) table[i] = i;\n\n\t\tvector<FOOD> Foods;\n\n\t\tstruct DATA res;\n\t\tres.G = 1000000;\n\t\tdo{\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tFoods.push_back(food[table[i]]);\n\t\t\t}\n\n\t\t\tdouble tmpG;\n\t\t\tif(checkWeight(Foods) &&\n\t\t\t\tres.G > (tmpG = getG(Foods))){\n\t\t\t\t\tres.mFoods = Foods;\n\t\t\t\t\tres.G = tmpG;\n\t\t\t}\n\t\t\tFoods.clear();\n\t\t}while(next_permutation(table,table+n));\n\n\t\tfor(int i=0;i<res.mFoods.size();i++){\n\t\t\tprintf(\"%s\\n\",res.mFoods[i].name.c_str());\n\t\t}\n\n\t\tdelete[] food;\n\t\tdelete[] table;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint n;\nbool use[10];\nint w[10],s[10];\nvector<int> tmp,ans;\nint maximam;\n\nvoid rec(int pos){\n  if(pos==n){\n    int weight,g;\n    bool f;\n    weight = 0;\n    f = true;\n    for(int i=0;i<tmp.size();i++){\n      if(s[tmp[i]] < weight){\n\tf = false;\n\tbreak;\n      }\n      weight += w[tmp[i]];\n    }\n    if(!f)return;\n    g = 0;\n    for(int i=0;i<n;i++)g+=(i+1)*w[tmp[i]];\n    if(maximam<g){\n      maximam = g;\n      ans = tmp;\n    }\n    return;\n  }\n\n  for(int i=0;i<n;i++){\n    if(!use[i]){\n      use[i] = true;\n      tmp.push_back(i);\n      rec(pos+1);\n      tmp.pop_back();\n      use[i] = false;\n    }\n  }\n}\n\nint main(){\n  string f[10];\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++){\n      cin >> f[i] >> w[i] >> s[i];\n      use[i] = false;\n    }\n\n    ans.clear();\n    tmp.clear();\n    maximam = 0;\n    rec(0);\n\n    for(int i=ans.size()-1;i>=0;i--)cout << f[ans[i]] << endl;\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define MAX_N 1000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nstruct FOOD{\n\tstring name;\n\tint w;\n\tint s;\n};\n\nstruct DATA{\n\tdouble G;\n\tvector<FOOD> mFoods;\n};\n\nstruct DATA dp[1<<10][10];\n\nbool checkWeight(vector<FOOD> vf){\n\tfor(int i=0;i<vf.size();i++){\n\t\tint sum = 0;\n\t\tfor(int j=i+1;j<vf.size();j++){\n\t\t\tsum += vf[j].w;\n\t\t}\n\t\tif(vf[i].s < sum) return false;\n\t}\n\n\treturn true;\n}\n\ndouble getG(vector<FOOD> vf){\n\n\tdouble G=0;\n\tdouble sum=0;\n\tfor(int i=0;i<vf.size();i++){\n\t\tG += vf[i].w * (i+1);\n\t\tsum += vf[i].w;\n\t}\n\treturn G / sum;\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tstruct FOOD* food = new struct FOOD[n];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar buf[64];\n\t\t\tint w,s;\n\t\t\tscanf(\"%s %d %d\",buf,&w,&s);\n\t\t\tfood[i].name = buf;\n\t\t\tfood[i].s = s;\n\t\t\tfood[i].w = w;\n\t\t}\n\n\t\tint* table = new int[n];\n\t\tfor(int i=0;i<n;i++) table[i] = i;\n\n\t\tvector<FOOD> Foods;\n\n\t\tstruct DATA res;\n\t\tres.G = 1000000;\n\t\tdo{\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tFoods.push_back(food[table[i]]);\n\t\t\t}\n\n\t\t\tdouble tmpG;\n\t\t\tif(checkWeight(Foods) &&\n\t\t\t\tres.G > (tmpG = getG(Foods))){\n\t\t\t\t\tres.mFoods = Foods;\n\t\t\t\t\tres.G = tmpG;\n\t\t\t}\n\t\t\tFoods.clear();\n\t\t}while(next_permutation(table,table+n));\n\n\t\tfor(int i=0;i<res.mFoods.size();i++){\n\t\t\tprintf(\"%s\\n\",res.mFoods[i].name.c_str());\n\t\t}\n\n\t\tdelete[] food;\n\t\tdelete[] table;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n\nint n;\ndouble minimum;\n\nusing namespace std;\n\nstruct Data{\n\tchar name[21];\n\tint self_weight,bearable_weight,index;\n\tbool FLG;\n};\n\nData final_data[10];\n\nvoid recursive(Data data[10],int sum,int index){\n\n\tif(index == n){\n\t\tdouble bunshi = 0,bunbo = 0,result;\n\n\t\tfor(int i = 1; i <= n-1; i++){\n\t\t\tfor(int k = n-1; k >= i; k--){\n\t\t\t\tif(data[k].index > data[k-1].index)swap(data[k],data[k-1]);\n\t\t\t}\n\t\t}\n\n\n\t\tfor(int i = 0; i < n; i++)bunshi += (i+1)*data[i].self_weight;\n\t\tfor(int i = 0; i < n; i++)bunbo += data[i].self_weight;\n\t\tresult = bunshi/bunbo;\n\n\t\tif(result < minimum){\n\t\t\tminimum = result;\n\t\t\tfor(int k = 0; k < n; k++)final_data[k] = data[k];\n\t\t}\n\t\treturn;\n\t}\n\n\tbool tmpFLG;\n\n\tfor(int i = 0; i < n; i++){\n\t\tif(data[i].FLG == false && data[i].bearable_weight >= sum){\n\t\t\ttmpFLG = true;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(i != k && data[k].FLG == false && data[k].bearable_weight < sum + data[i].self_weight){\n\t\t\t\t\ttmpFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(tmpFLG){\n\t\t\t\tData new_data[10];\n\t\t\t\tfor(int k = 0; k < n;k++)new_data[k] = data[k];\n\t\t\t\tnew_data[i].FLG = true;\n\t\t\t\tnew_data[i].index = index;\n\t\t\t\trecursive(new_data,sum+data[i].self_weight,index+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tData data[10];\n\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\n\t\tminimum = 2000000000;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdata[i].FLG = false;\n\t\t\tscanf(\"%s %d %d\",data[i].name,&data[i].self_weight,&data[i].bearable_weight);\n\t\t}\n\n\t\trecursive(data,0,0);\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tprintf(\"%s\\n\",final_data[i].name);\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double real;\ntypedef pair<int, string> duo;\n\n#define TT template<typename T>\nTT T    sq(T x){ return x*x; }\nTT int  ubnd(vector<T>& v,T x){ return upper_bound(v.begin(), v.end(), x) - v.begin(); }\nTT int  lbnd(vector<T>& v,T x){ return lower_bound(v.begin(), v.end(), x) - v.begin(); }\nTT void sort(T& v){ sort(v.begin(), v.end()); }\nTT void revs(T& v){ reverse(v.begin(), v.end()); }\nTT void uniq(T& v){ sort(v); v.erase(unique(v.begin(), v.end()), v.end()); }\nTT void show(T& v,char d=' ',char e='\\n'){for(int i=0;i<v.size();++i)cout<<v[i]<<((i==v.size()-1)?e:d);}\nTT void inpt(vector<T>& v,int n){ v.reserve(n);for(int i=0;i<n;++i){T x; cin>>x; v.push_back(x);} }\nTT T In(){ T x; cin >> x; return x; }\n\nstatic inline void fast_io(){ ios::sync_with_stdio(0); cin.tie(0); }\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\nstatic inline string instr(){ string x; cin >> x; return x; }\nstatic inline ll pow_mod(ll a, ll k, ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\nstatic inline ll mod_inv(ll a, ll p){ return pow_mod(a,p-2,p); }\nstatic const int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nstatic const int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nstatic const int Mod = 1000000000;\n\nstatic inline int popcnt(int x){ return __builtin_popcount(x); }\n\nstruct Food {\n  string f;\n  int w, s;\n  Food(){}\n  void read(){\n    cin >> f >> w >> s;\n  }\n  bool operator<(const Food& f) const {\n    if (f.s == s) return f.w < w;\n    return f.s < s;\n  }\n};\n\nstruct Solver {\n  vector<Food> fs;\n  vector<Food> best;\n  vector<Food> cur;\n  bool used[16];\n  int best_cg;\n  int total_w;\n  const int N;\n\n  Solver(int n) : N(n), fs(n) {}\n  void init(){\n    for (int i = 0; i < N; i++) fs[i].read();\n    sort(fs);\n    memset(used, 0, sizeof(used));\n    best_cg = 1 << 25;\n    total_w = 0;\n    for (int i = 0; i < N; i++){\n      total_w += fs[i].w;\n    }\n  }\n  void solve(int cg=0, int tw=0, int t=1){\n    if (t == N + 1){\n      if (best_cg > cg){\n        best = cur;\n        best_cg = cg;\n      }\n      return;\n    }\n    if (cg > best_cg) return;\n    for (int i = 0; i < N; i++){\n      if (used[i]) continue;\n      if (fs[i].s < total_w - (tw + fs[i].w)) continue;\n      used[i] = true;\n      cur.push_back(fs[i]);\n      solve(cg + t * fs[i].w, tw + fs[i].w, t + 1);\n      cur.pop_back();\n      used[i] = false;\n    }\n  }\n  void show(){\n    for (int i = 0; i < N; i++) cout << best[i].f << \"\\n\";\n  }\n};\n\nint main()\n{\n  int n;\n  while (n = in()){\n    Solver solver(n);\n    solver.init();\n    solver.solve();\n    solver.show();\n  }\n  return (0);\n}\n\n// priority_queue queue deque first second front top push pop map set stringstream max_element min_element insert count find"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tint n;\n\tvector<pair<string,pii> > data;\n\tvector<pair<string,pii> > ans;\n\twhile(cin>>n,n){\n\t\tdata.clear();\n\t\tans.clear();\n\t\tstring str;\n\t\tint w,s;\n\t\tdouble tmp2 =0;\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcin>>str;\n\t\t\tscanf(\"%d %d\",&w,&s);\n\t\t\tdata.push_back(mp(str,pii(w,s)));\n\t\t\ttmp2 +=data[i].second.first;\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tdouble G =INF;\n\t\tdo{\n\t\t\t//cout <<\"iei\"<<endl;\n\t\t\tint sumw =0;\n\t\t\tdouble tmp1 =0;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\ttmp1 +=(i+1)*data[i].second.first;\n\t\t\t}\n\t\t\tdouble Gtmp =(double)(tmp1/tmp2);\n\t\t\tif(Gtmp>G)continue;\n\t\t\tbool ok =true;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\tif(sumw>data[i].second.second){\n\t\t\t\t\tok =false;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tsumw +=data[i].second.first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok&&Gtmp <G){\n\t\t\t\tG =Gtmp;\n\t\t\t\tans =data;\n\t\t\t}\n\t\t}while(next_permutation(data.begin(), data.end()));\n\n\t\tfor(int i =0;i <ans.size();i++){\n\t\t\tcout <<ans[i].first<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nint main(){\n\tint n;\n\tvector<pair<string,pii> > data;\n\tvector<pair<string,pii> > ans;\n\twhile(scanf(\"%d\",&n)){\n\t\tif(n==0)break;\n\t\tdata.clear();\n\t\tans.clear();\n\t\tstring str;\n\t\tint w,s;\n\t\tint tmp2 =0;\n\t\tfor(int i =0;i <n;i++){\n\t\t\tcin>>str;\n\t\t\tscanf(\"%d %d\",&w,&s);\n\t\t\tdata.push_back(mp(str,pii(w,s)));\n\t\t\ttmp2 +=data[i].second.first;\n\t\t}\n\t\tsort(data.begin(),data.end());\n\t\tdouble G =1145141;\n\t\tdo{\n\t\t\t//cout <<\"iei\"<<endl;\n\t\t\tint sumw =0;\n\t\t\tint tmp1 =0;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\ttmp1 +=(i+1)*data[i].second.first;\n\t\t\t}\n\t\t\tdouble Gtmp =(double)((double)tmp1/(double)tmp2);\n\t\t\tif(Gtmp>G)continue;\n\t\t\tbool ok =true;\n\t\t\tfor(int i =n-1;i >=0;i--){\n\t\t\t\tif(sumw>data[i].second.second){\n\t\t\t\t\tok =false;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tsumw +=data[i].second.first;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout <<Gtmp<<endl;\n\t\t\tif(ok&&Gtmp <G){\n\t\t\t\tG =Gtmp;\n\t\t\t\tans=data;\n\t\t\t\t//cout <<\"ge\"<<endl;\n\t\t\t}\n\t\t}while(next_permutation(data.begin(), data.end()));\n\n\t\tfor(int i =0;i <n;i++){\n\t\t\tprintf(\"%s\\n\",ans[i].first.c_str());\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require sqrt ceil floor\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <stdint.h>\t// require uint64_t\n#include <fstream>\t// require freopen\n\nusing namespace std;\n\ntypedef pair <pair<int, int>, string > ITEM;\n\n\ndouble getG (ITEM add, vector <ITEM> res )\n{\n\tint size = res.size();\n\n\tdouble total_w = (double)add.first.second;\n\tfor (int i = 0; i < size; ++i ){\n\t\ttotal_w += (double)res[i].first.second;\n\t} // end for\n\n\tdouble ans = (double)(add.first.second);\n\tfor (int i = 0; i < size; ++i ){\n\t\tans += (double)( (size + 1 - i)*(res[i].first.second) );\n\t} // end for\n\n\tans /= total_w;\n\n\treturn ans;\n}\n\nbool is_gain_up (int n, vector <ITEM> list, vector <bool> used)\n{\n\tint size = list.size();\n\tvector <ITEM> remain;\n\n\tfor (int i = 0; i < size; ++i ){\n\t\tif (i != n && !used[i] ){\n\t\t\tremain.push_back(list[i] );\n\t\t} // end if\n\t} // end for\n\n\tint total_w = 0;\n\tfor (int i = 0; i < remain.size(); ++i ){\n\t\ttotal_w += remain[i].first.second;\n\t} // end for\n\n\treturn  (total_w <= list[n].first.first );\n}\n\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.lunch\", \"r\", stdin );\n\tint n;\n\n\twhile (cin >> n && n ){\n\t\tvector <ITEM> list(n);\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tcin >> list[i].second;\n\t\t\tcin >> list[i].first.second;\n\t\t\tcin >> list[i].first.first;\n\t\t} // end for\n\n\t\tsort (list.begin(), list.end() );\n\t\n\t\tvector <bool> used (n, false );\n\t\tused[n-1] = true;\n\t\tvector <ITEM> res;\n\t\tres.push_back(list[n-1]);\n\n\t\tfor (int j = 0; j < n - 1; ++j ){\n\t\t\tdouble minG = DBL_MAX;\n\t\t\tint minindex = -1;\n\t\t\tfor (int i = 0; i < n - 1; ++i ){\n\t\t\t\tif (i != j && !used[i] && is_gain_up(i, list, used) && minG > getG (list[i], res ) ){\n\t\t\t\t\t\tminG = getG (list[i], res );\t\t\t\n\t\t\t\t\t\tminindex = i;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t\tif (minindex != -1){\n\t\t\t\tused[minindex] = true;\n\t\t\t\tres.push_back(list[minindex] );\n\t\t\t} // end if\n\t\t} // end for\n\n\t\tfor (int i = 0; i < res.size(); ++i ){\n//\t\t\tcout << res[i].first.first << ':' << res[i].first.second << ':' << res[i].second << endl;\n\t\t\tcout << res[i].second << endl;\n\t\t} // end for\n//\t\tcout << endl;\n\t\n\t} // end while\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \n#include <sstream>\nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n#define ll long long int\n#define gcd(a,b) __gcd(a,b)\n\nint GCD(int a, int b) {if(!b) return a; return gcd(b, a%b);}\nint lcm(int a, int b) {return a*b / gcd(a, b);}\n\nstruct food{\n  string fn;\n  int g;\n  int s;\n};\nint f[10],an[10],m;\nfood fd[10],sf;\nint ans(int n,int s){\n  if(n==-1){\n    for(int i = m - 1 ; i >= 0 ; i --){\n      cout << fd[an[i]].fn << endl; \n      return 1;\n    }\n  }\n  for(int i = m - 1 ; i >= 0 ; i --){\n    if(f[i] == 0 && fd[i].s >= s-fd[i].g){\n      f[i] = 1; an[n] = i;\n      if(ans(n-1,s-fd[i].g)==1)return 1;\n      f[i] = 0;\n    }\n  }\n  return 0;\n}\n\nint main(void){\n  int i,j,s;\n  while(cin>>m){\n    if(m==0)break;\n    for(i = 0 , s = 0 ; i < m ; i ++){\n      f[i] = 0 ; \n      cin>>fd[i].fn>>fd[i].g>>fd[i].s;\n      s+=fd[i].g;\n    }\n    for(i = 1 ; i < m ; i ++){\n      for(j = 0  ; j < m - i ; j ++){\n\tif(fd[j].g>fd[j+1].g){\n\t  sf=fd[j];\n\t  fd[j] = fd[j+1];\n\t  fd[j+1] = sf;\n\t}\n      }\n    }\n    ans(m-1,s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n \nstruct Elem {\n    string name;\n    int weight, limit;\n};\n\nsigned main() {\n    int N;\n    while(cin >> N, N) {\n        vector<Elem> elems;\n        for(int i=0; i<N; i++) {\n            string name; int weight, limit;\n            cin >> name >> weight >> limit;\n            elems.push_back(Elem{name, weight, limit});\n        }\n\n        vector<int> perm(N);\n        iota(perm.begin(), perm.end(), 0);\n\n        double g = INF;\n        vector<Elem> ans;\n        do {\n            vector<Elem> cur;\n            for(int i=0; i<N; i++) cur.push_back(elems[ perm[i] ]);\n\n            int sum = 0, ok = true, weighted_sum = 0;\n            for(int i=N-1; i>=0; i--) {\n                if(cur[i].limit < sum) ok = false;\n                sum += cur[i].weight;\n                weighted_sum += (i+1) * cur[i].weight;\n            }\n\n            double tmp_g = 1.0 * weighted_sum / sum;\n            if(ok and g > tmp_g) {\n                g = tmp_g;\n                ans = cur;\n            }\n        }while(next_permutation(perm.begin(), perm.end()));\n    \n        for(int i=0; i<ans.size(); i++) {\n            cout << ans[i].name << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\n-- templete\n\ntype Food = (String, Int, Int)\ngetName :: Food -> String\ngetName (f,_,_) = f\ngetWeight :: Food -> Int\ngetWeight (_,w,_) = w\ngetLimit :: Food -> Int\ngetLimit (_,_,s) = s\n\nf :: (Int,Int,Int,[Food]) -> [Food] -> [(Int,[String])]\nf (g, i, t, l) [] = [(g, map getName l)]\nf (g, i, t, l) fs = ff [] fs\n  where\n    ff yys [] = []\n    ff yys (x:xs) = let w = getWeight x in let limit = getLimit x in if (t<=limit) then f (g+i*w, i+1, t+w, (x:l)) (yys ++ xs) ++ ff (x:yys) xs else ff (x:yys) xs\n    \ncalc :: [Food] -> [String]\ncalc fs = snd $ maximumBy (comparing fst) $ f (0,1,0,[]) fs\n\nmain = do\n    n <- getInt\n    when (n/=0) $ do\n        fs <- map ((\\[f,w,s] -> (f, readInt w, readInt s)) . words) <$> replicateM n getLine\n        mapM_ putStrLn $ calc fs\n        main\n    \n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nans'' _ [] = []\nans'' _ (x:[]) = [x]\nans'' t ((f,w,s):xs) =\n  if s >= (t-w)\n  then (f,w,s):(ans'' (t-w) xs)\n  else\n    let b1 = takeWhile (\\ (f1,w1,s1) -> s1 < t-w1) xs\n        b2 = dropWhile (\\ (f1,w1,s1) -> s1 < t-w1) xs\n        (f2,w2,s2) = head b2\n        y  = (f,w,s):(b1 ++ (drop 1 b2))\n    in\n      (f2,w2,s2):(ans'' (t-w2) y)\n\nans' x =\n  let s = sortBy (\\ (f1,w1,s1) (f2,w2,s2) -> compare w2 w1) x\n      t = foldr (\\ (f1,w1,s1) a -> w1+a) 0 x\n  in\n    ans'' t s\n\nans ([\"0\"]:_) = []\nans ([n]:x) = \n  let n' = read n :: Int\n      d  = map (\\[f,w,s] -> (f,(read w), (read s)) ) $ take n' x :: [(String,Int,Int)]\n      r  = drop n' x\n      a  = ans' d\n  in\n    a  ++ (ans r)\n\nmain = do\n  c <- getContents\n  let i = map words $ lines c\n      o = ans i\n  mapM_ putStrLn $ map (\\(f,w,s) -> f) o\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>))\nimport Control.Monad (replicateM, unless)\nimport Data.List (permutations, minimumBy)\nimport Data.Function (on)\n\nmain :: IO ()\nmain = do\n  n <- readLn\n  unless (n == 0) $ do\n    solve n\n    main\n\nsolve :: Int -> IO ()\nsolve n = do\n  xs <- replicateM n $ food <$> getLine\n  let fs = minimumBy (compare `on` cog) . filter f . permutations $ xs\n  mapM_ print fs\n  where f :: [Food] -> Bool\n        f fs = maybe False (const True) . foldr g (Just 0) $ fs\n          where g _ Nothing = Nothing\n                g fd (Just w) | w <= (sp fd) = Just (w + (wt fd))\n                              | otherwise = Nothing\ncog :: [Food] -> Double\ncog fs = sum (zipWith (\\a b -> (fromIntegral a) * (fromIntegral b)) (map wt fs) [1 ..]) / fromIntegral (sum (map wt fs))\n\ndata Food = Food {nm :: String, wt :: Int, sp :: Int}\n\ninstance Show Food where\n  show (Food n _ _) = n\n  \nfood :: String -> Food\nfood s = let (n:w:p:_) = words s\n         in Food n (read w) (read p)\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint n,i,j,sum,ans,www,w[21],s[21];\nchar name[21][21];\n\nint main(){\n\twhile(scanf(\"%d\",&n)*n){\n\t\tsum=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%s %d %d\",name[i],&w[i],&s[i]);\n\t\t\tsum+=w[i];\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\twww=0;\n\t\t\tfor(j=0;j<n;j++){if(sum-w[j]<=s[j] && w[j]>www){ans=j;www=w[j];}}\n\t\t\tprintf(\"%s\\n\",name[ans]);\n\t\t\ts[ans]=-99999999;\n\t\t\tsum-=w[ans];\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char S[10][21];\nw[10],s[10];\nW[1<<10],B[1<<10],G[10][1<<10];\nn,N;\nR(f,F){\n\tint i,g,gm;\n\tif(F==0)\n\t\treturn w[f];\n\tif(G[f][F])\n\t\treturn G[f][F];\n\tgm=1e9;\n\tfor(i=0;i<n;i++){\n\t\tif(F&1<<i&&s[i]>=W[F-(1<<i)]){\n\t\t\tg=R(i,F-(1<<i));\n\t\t\tif(g<gm){\n\t\t\t\tgm=g;\n\t\t\t\tB[F]=i;\n\t\t\t}\n\t\t}\n\t}\n\treturn G[f][F]=gm+W[F];\n}\nmain(){\n\tint F,f,b;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tN=(1<<n)-1;\n\t\tfor(f=0;f<n;f++)\n\t\t\tscanf(\"%s%d%d\",S[f],w+f,s+f);\n\t\tfor(F=0;F<=N;F++){\n\t\t\tW[F]=0;\n\t\t\tfor(f=0;f<n;f++){\n\t\t\t\tif(F&1<<f)\n\t\t\t\t\tW[F]+=w[f];\n\t\t\t\tG[f][F]=0;\n\t\t\t}\n\t\t}\n\t\tR(0,N);\n\t\tfor(F=N;F;F-=1<<b){\n\t\t\tb=B[F];\n\t\t\tputs(S[b]);\n\t\t}\n\t}\n\tputs(\"\");\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef struct i{char f[21];int s,w;} i;\ni g[10];\nint n,t[10],f[10]={0},ans[10],max=0;\nvoid rec(int d)\n{\n\tint i,w=0,G=0;\n\tif(d==n)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(w>g[t[i]].s)\n\t\t\t\treturn;\n\t\t\tw+=g[t[i]].w;\n\t\t\tG+=g[t[i]].w*(i+1);\n\t\t}\n\t\tif(max<G)\n\t\t{\n\t\t\tmax=G;\n\t\t\tmemcpy(ans,t,sizeof(t));\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(!f[i])\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tt[d]=i;\n\t\t\t\trec(d+1);\n\t\t\t\tf[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i;\n\t\n\tfor(;;)\n\t{\n\t\tmemset(ans,0,40);\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%s %d%d\",g[i].f,&g[i].w,&g[i].s);\n\t\trec(0);\n\t\twhile(--n>=0)\n\t\t\tputs(g[ans[n]].f);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nint n, m;\ntypedef struct {\n    char name[256];\n    int weight;\n    int limit;\n} FOODS;\n\nchar answer[10][256];\nFOODS lunch[10];\ndouble G;\n\nvoid editPermutation(int *p)\n{\n\tint i, j, k;\n    int sum[10], deno;\n    \n    memset(sum, 0, sizeof(sum));\n    for (i = n - 2; i >= 0; i--){\n        sum[i] = sum[i + 1] + lunch[p[i + 1]].weight;\n        if (lunch[p[i]].limit < sum[i]){\n            return;\n        }\n    }\n    \n    sum[0] += lunch[p[0]].weight;\n    \n    deno = 0;\n    for (i = 0; i < n; i++){\n        deno += (i + 1) * lunch[p[i]].weight;\n    }\n    \n    if (G > deno * 1.0 / sum[0]){\n        G = deno * 1.0 / sum[0];\n        for (i = 0; i < n; i++){\n            strcpy(answer[i], lunch[p[i]].name);\n        }\n    }\n}\n\nint ok[10];\n\nvoid put(int *p, int pos, int k)\n{\n\tint j;\n\n\tp[pos] = k;\n\tif (pos == n - 1){\n        editPermutation(p);\n\t}\n\telse {\n\t\tok[k] = 0;\n\t\tfor (j = 0; j < n; j++){\n            if (ok[j] == 1){\n                put(p, pos + 1, j);\n            }\n\t\t}\n\t\tok[k] = 1;\n\t}\n}\n/*\nvoid makePermutation(int *p){\n\tint k;\n\n\tfor (k = 0; k < n; k++){\n        ok[k] = 1;\n    }\n    \n\tfor(k = 0; k < n; k++){\n        put(p, 0, k);\n\t}\n}\n*/\n\nvoid makePermutation(int *p)\n{\n    int c[10], *pc, *q;\n\tint k, t;\n    \n    q = p;\n    pc = c;\n    \n\tfor (k = 0; k < n; k++){\n        *q++ = *pc++ = k;\n\t}\n\tk = 1;\n\tpc = c;\n\tdo\n\t{\n\t\tt = *(p + k);\n\t\t*(p + k) = *(q = p + ((k & 1) ? *pc: 0));\n\t\t*q = t;\n\t\teditPermutation(p);\n\t\tk = 1;\n\t\tpc = c;\n\t\twhile (*pc == 0){\n            *pc++ = k++;\n\t\t}\n\t\t(*pc)--;\n\t} while (k < n);\n}\n\nint main(void)\n{\n    int p[10];\n    int i, j;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%s%d%d\", lunch[i].name, &lunch[i].weight, &lunch[i].limit);\n        }\n        G = 1000000000;\n        makePermutation(p);\n        for (i = 0; i < n; i++){\n            printf(\"%s\\n\", answer[i]);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint n, m;\ntypedef struct {\n    char name[256];\n    int weight;\n    int limit;\n} FOODS;\n\nchar answer[10][256];\nFOODS lunch[10];\ndouble G;\n\nvoid editPermutation(int *p)\n{\n\tint i, j, k;\n    int sum[10], deno;\n    \n    memset(sum, 0, sizeof(sum));\n    for (i = n - 2; i >= 0; i--){\n        sum[i] = sum[i + 1] + lunch[p[i + 1]].weight;\n        if (lunch[p[i]].limit < sum[i]){\n            return;\n        }\n    }\n    \n    sum[0] += lunch[p[0]].weight;\n    \n    deno = 0;\n    for (i = 0; i < n; i++){\n        deno += (i + 1) * lunch[p[i]].weight;\n    }\n    \n    if (G > deno * 1.0 / sum[0]){\n        G = deno * 1.0 / sum[0];\n        for (i = 0; i < n; i++){\n            strcpy(answer[i], lunch[p[i]].name);\n        }\n    }\n}\n\nint ok[10];\n\nvoid put(int *p, int pos, int k)\n{\n\tint j;\n\n\tp[pos] = k;\n\tif (pos == n - 1){\n        editPermutation(p);\n\t}\n\telse {\n\t\tok[k] = 0;\n\t\tfor (j = 0; j < n; j++){\n            if (ok[j] == 1){\n                put(p, pos + 1, j);\n            }\n\t\t}\n\t\tok[k] = 1;\n\t}\n}\n\nvoid makePermutation(int *p){\n\tint k;\n\n\tfor (k = 0; k < n; k++){\n        ok[k] = 1;\n    }\n    \n\tfor(k = 0; k < n; k++){\n        put(p, 0, k);\n\t}\n}\n\nint main(void)\n{\n    int p[10];\n    int i, j;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%s%d%d\", lunch[i].name, &lunch[i].weight, &lunch[i].limit);\n        }\n        G = 1000000000;\n        makePermutation(p);\n        for (i = 0; i < n; i++){\n            printf(\"%s\\n\", answer[i]);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef struct i{char f[21];int s,w;} i;\ni g[10];\nint n,t[10],f[10],ans[10],max;\nvoid rec(int d)\n{\n\tint i,w=0,G=0;\n\tif(d==n)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(w>g[t[i]].s)\n\t\t\t\treturn;\n\t\t\tw+=g[t[i]].w;\n\t\t\tG+=g[t[i]].w*(i+1);\n\t\t}\n\t\tif(max<G)\n\t\t{\n\t\t\tmax=G;\n\t\t\tmemcpy(ans,t,40);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(!f[i])\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tt[d]=i;\n\t\t\t\trec(d+1);\n\t\t\t\tf[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i;\n\tfor(;;)\n\t{\n\t\tmemset(ans,0,40);\n\t\tmemset(f,0,40);\n\t\tmax=0;\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%s %d%d\",g[i].f,&g[i].w,&g[i].s);\n\t\trec(0);\n\t\twhile(-- n>=0)\n\t\t\tputs(g[ans[n]].f);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef struct i{char f[21];int s,w;} i;\ni g[10];\nint n,t[10],f[10]={0},ans[10],max=0;\n\nvoid rec(int d)\n{\n\tint i,w=0,G=0;\n\tif(d==n)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(w>g[t[i]].s)\n\t\t\t\treturn;\n\t\t\tw+=g[t[i]].w;\n\t\t\tG+=g[t[i]].w*(i+1);\n\t\t}\n\t\tif(max<G)\n\t\t{\n\t\t\tmax=G;\n\t\t\tmemcpy(ans,t,sizeof(t));\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tif(!f[i])\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tt[d]=i;\n\t\t\t\trec(d+1);\n\t\t\t\tf[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i;\n\tfor(;;)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%s %d%d\",g[i].f,&g[i].w,&g[i].s);\n\t\trec(0);\n\t\twhile(--n>=0)\n\t\t\tputs(g[ans[n]].f);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n  int w[11], s[11], i, j, n, wmax, res, sum;\n  char f[11][21];\n\n  while(scanf(\"%d\", &n) && n){\n    sum = 0;\n    for(i = 0; i < n; ++i){\n      scanf(\"%s %d %d\", f[i], &w[i], &s[i]);\n      sum += w[i];\n    }\n\n    for(j = 0; j < n; ++j){\n      wmax = 0;\n      for(i = 0; i < n; ++i)\n\tif(sum - w[i] <= s[i] && wmax <= w[i])\n\t  res = i, wmax = w[i];\n      \n      puts(f[res]);\n      s[res] = -999999;\n      sum -= w[res];\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N_MAX 10\n\ntypedef struct {\n\tchar name[32];\n\tint w,s;\n} food_t;\n\nstatic int n;\nstatic food_t foods[N_MAX];\nstatic int ans_index[N_MAX];\nstatic int ans_buffer[N_MAX];\nstatic int ans_score;\n\nvoid search(int pos,int left,int cur_weight) {\n\tint i;\n\tif(pos<=0) {\n\t\tint cur_score=0;\n\t\tfor(i=0;i<n;i++) {\n\t\t\tcur_score+=(i+1)*foods[ans_buffer[i]].w;\n\t\t}\n\t\tif(ans_score<0 || cur_score<ans_score) {\n\t\t\tans_score=cur_score;\n\t\t\tfor(i=0;i<n;i++)ans_index[i]=ans_buffer[i];\n\t\t}\n\t} else {\n\t\tfor(i=0;i<n;i++) {\n\t\t\tif((left&(1<<i))!=0) {\n\t\t\t\tif(cur_weight<=foods[i].s) {\n\t\t\t\t\tans_buffer[pos-1]=i;\n\t\t\t\t\tsearch(pos-1,left&~(1<<i),cur_weight+foods[i].w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i;\n\twhile(scanf(\"%d\",&n)==1 && n!=0) {\n\t\tfor(i=0;i<n;i++) {\n\t\t\tif(scanf(\"%s%d%d\",foods[i].name,&foods[i].w,&foods[i].s)!=3)return 1;\n\t\t}\n\t\tans_score=-1;\n\t\tsearch(n,(1<<n)-1,0);\n\t\tfor(i=0;i<n;i++)puts(foods[ans_index[i]].name);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nstruct Data{\n\tchar name[24];\n\tint w,s;\n}t[10],now[10],ans[10];\n\nint n;\ndouble min;\nchar used[10];\n\nvoid solve(int idx,int rem,int sum,int G){\n\tint i,j;\n\n\tif(t[idx].s < sum) return;\n\n\tnow[rem] = t[idx];\n\tsum += t[idx].w;\n\tG += t[idx].w * (rem + 1);\n\n\tif(rem == 0){\n\t\tdouble tmp = (double)G / sum;\n\t\tif(min > tmp){\n\t\t\tmin = tmp;\n\t\t\tfor(i=0;i<n;i++) ans[i] = now[i];\n\t\t}\n\t\treturn;\n\t}\n\tif(rem < 0) return;\n\n\tused[idx] = 1;\n\tfor(i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tsolve(i,rem-1,sum,G);\n\t\t}\n\t}\n\tused[idx] = 0;\n}\n\nint main(void){\n\tint i;\n\n\twhile(scanf(\"%d\",&n) && n){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%s%d%d\",t[i].name,&t[i].w,&t[i].s);\n\t\t}\n\n\t\tmin = 999999999;\n\t\tmemset(used,0,sizeof(used));\n\n\t\tfor(i=0;i<n;i++){\n\t\t\tsolve(i,n-1,0,0);\n\t\t}\n\n\t\tfor(i=0;i<n;i++){\n\t\t\tprintf(\"%s\\n\",ans[i].name);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ Volume 1 Problem 0170 Lunch\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[21];\n    int weight;\n    int strength;\n    int use;\n} FOOD;\n\nint min_g;\nint best_order[11];\n\nvoid stack(FOOD *food, int n, int level, int total_weight, int *order)\n{\n    int i;\n    int g;\n    \n    if (level >= n){\n        g = 0;\n        for (i = n - 1; i >= 0; i--){\n            g += food[order[i]].weight * (n - i);\n        }\n        if ((min_g == -1) || (min_g > g)){\n            min_g = g;\n            memcpy(best_order, order, sizeof(best_order));\n        }\n        return;\n    }\n    \n    for (i = 0; i < n; i++){\n        if (food[i].use == 0){\n            if (food[i].strength >= total_weight){\n                food[i].use = 1;\n                order[level] = i;\n                stack(food, n, level + 1, total_weight + food[i].weight, order);\n                food[i].use = 0;\n            }\n        }\n    }\n    \n    return;\n}\n\nint main(void)\n{\n    FOOD food[10];\n    int n;\n    int order[11];\n    int i;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%s%d%d\", food[i].name, &food[i].weight, &food[i].strength);\n            food[i].use = 0;\n        }\n        \n        min_g = -1;\n        stack(food, n, 0, 0, order);\n        for (i = n - 1; i >= 0; i--){\n            printf(\"%s\\n\", food[best_order[i]].name);\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0170: Lunch\n   2017.8.15 bal4u@uu\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct { char *f; int w, s; } T; T f[12];\nchar ss[12][22];\nint n, sw, g[12], ans[12];\n\nint cmp(T *a, T *b)\n{\n\tif (a->w != b->w) return b->w - a->w;\n\treturn b->w - a->w;\n}\n\nint combi(int j, int w)\n{\n\tint i;\n\tT *p;\n\n\tif (j >= n) return 1;\n\tfor (p = f, i = 0; i < n; i++, p++) {\n\t\tif (g[i] || (sw - w - p->w) > p->s) continue;\n\t\tg[i] = 1;\n\t\tans[j] = i;\n\t\tif (combi(j + 1, w + p->w)) return 1;\n\t\tg[i] = 0;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i;\n\n\twhile (1) {\n\t\tscanf(\"%d\", &n); if (!n) break;\n\t\tfor (sw = i = 0; i < n; i++) {\n\t\t\tscanf(\"%s%d%d\", ss + i, &f[i].w, &f[i].s);\n\t\t\tf[i].f = ss[i], sw += f[i].w;\n\t\t\tg[i] = 0;\n\t\t}\n\t\tqsort(f, n, sizeof(T), cmp);\n\t\tcombi(0, 0);\n\t\tfor (i = 0; i < n; i++) printf(\"%s\\n\", f[ans[i]].f);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,w[10],h[10],a[10];\nlong long min;\nvoid f(int d,int t[10],int c[10],int y[10]){\n  int i,j;\n  if(!d){\n    long long g=0;\n    for(i=0;i<n;i++)g+=w[t[i]]*i;\n    if(min>g){\n      min=g;\n      for(i=0;i<n;i++)a[i]=t[i];\n    }\n    return;\n  }\n  for(i=0;i<n;i++){\n    if(c[i])continue;//printf(\"%d %d\\n\",d,i);\n    t[n-d]=i;\n    c[i]=1;\n    y[n-d]=h[i];\n    for(j=0;j<n-d;j++){\n      y[j]-=w[i];\n      if(y[j]<0)break;\n    }\n    if((n-d)-j==0)f(d-1,t,c,y);\n    c[i]=0;\n    for(j=0;j<n-d;j++)y[j]+=w[i];      \n  }\n  return;\n}      \nint main(){\n  char s[10][12];\n  int i;\n  while(scanf(\"%d\",&n),n){\n    min=2100000000;\n    int t[10]={0};\n    int c[10]={0};\n    int y[10]={0};\n    for(i=0;i<n;i++){\n      scanf(\"%s %d %d\",s[i],&w[i],&h[i]);\n      a[i]=0;\n    }\n    f(n,t,c,y);\n    for(i=0;i<n;i++)printf(\"%s\\n\",s[a[i]]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint n, m;\ntypedef struct {\n    char name[256];\n    int weight;\n    int limit;\n} FOODS;\n\nchar answer[10][256];\nFOODS lunch[10];\ndouble G;\n\nvoid editPermutation(int *p)\n{\n\tint i, j, k;\n    int sum[10], deno;\n    \n    memset(sum, 0, sizeof(sum));\n    for (i = n - 2; i >= 0; i--){\n        sum[i] = sum[i + 1] + lunch[p[i + 1]].weight;\n        if (lunch[p[i]].limit < sum[i]){\n            return;\n        }\n    }\n    \n    sum[0] += lunch[p[0]].weight;\n    \n    deno = 0;\n    for (i = 0; i < n; i++){\n        deno += (i + 1) * lunch[p[i]].weight;\n    }\n    \n    if (G > deno * 1.0 / sum[0]){\n        G = deno * 1.0 / sum[0];\n        for (i = 0; i < n; i++){\n            strcpy(answer[i], lunch[p[i]].name);\n        }\n    }\n}\n\nint ok[10];\n\nvoid put(int *p, int pos, int k)\n{\n\tint j;\n\n\tp[pos] = k;\n\tif (pos == n - 1){\n        editPermutation(p);\n\t}\n\telse {\n\t\tok[k] = 0;\n\t\tfor (j = 0; j < n; j++){\n            if (ok[j] == 1){\n                put(p, pos + 1, j);\n            }\n\t\t}\n\t\tok[k] = 1;\n\t}\n}\n/*\nvoid makePermutation(int *p){\n\tint k;\n\n\tfor (k = 0; k < n; k++){\n        ok[k] = 1;\n    }\n    \n\tfor(k = 0; k < n; k++){\n        put(p, 0, k);\n\t}\n}\n*/\n\nvoid makePermutation(int *p)\n{\n    int c[10], *pc, *q;\n\tint k, t;\n    \n    q = p;\n    pc = c;\n    \n\tfor (k = 0; k < n; k++){\n        *q++ = *pc++ = k;\n\t}\n\tk = 0;\n\tpc = c;\n\tdo\n\t{\n\t\tt = *(p + k);\n\t\t*(p + k) = *(q = p + ((k & 1) ? *pc: 0));\n\t\t*q = t;\n\t\teditPermutation(p);\n\t\tk = 0;\n\t\tpc = c;\n\t\twhile (*pc == 0){\n            *pc++ = k++;\n\t\t}\n\t\t(*pc)--;\n\t} while (k < n);\n}\n\nint main(void)\n{\n    int p[10];\n    int i, j;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%s%d%d\", lunch[i].name, &lunch[i].weight, &lunch[i].limit);\n        }\n        G = 1000000000;\n        makePermutation(p);\n        for (i = 0; i < n; i++){\n            printf(\"%s\\n\", answer[i]);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid f(int w[],int k[],int b[],int a[],int c,int n,int e,int g){\n  int i,j;\n  int bb[10];\n  if(c==n){\n    if(a[10]==0||a[10]>g){\n      a[10]=g;\n      memcpy(a,b,sizeof(bb));\n    }\n  }else{\n    for(i=0;i<n;i++){\n      if(k[i]>=e){\n\tfor(j=0;j<c;j++){\n\t  if(i==b[j])\n\t    break;\n\t}\n\tif(j==c){\n\t  memcpy(bb,b,sizeof(bb));\n\t  bb[c]=i;\n\t  f(w,k,bb,a,c+1,n,e+w[i],g+w[i]*(n-c));\n\t}\n      }else\n\tbreak;\n    }\n  }\n  return;\n}\nint main(){\n  int h,i;\n  int w[10],k[10],b[10],a[11],swap,n;\n  char s[11][64];\n  for(;;){\n    scanf(\"%d\",&n);\n    if(n==0)\n      break;\n    for(i=0;i<n;i++)\n      scanf(\"%s%d%d\",s[i],&w[i],&k[i]);\n    do{\n      h=0;\n      for(i=1;i<n;i++){\n\tif(k[i-1]<k[i]){\n\t  swap=k[i-1];\n\t  k[i-1]=k[i];\n\t  k[i]=swap;\n\t  swap=w[i-1];\n\t  w[i-1]=w[i];\n\t  w[i]=swap;\n\t  sprintf(s[10],\"%s\",s[i-1]);\n\t  sprintf(s[i-1],\"%s\",s[i]);\n\t  sprintf(s[i],\"%s\",s[10]);\n\t  h=1;\n\t}\n      }\n    }while(h);\n    memset(b,0,sizeof(b));\n    memset(a,0,sizeof(a));\n    f(w,k,b,a,0,n,0,0);\n    for(i=0;i<n;i++)\n      printf(\"%s\\n\",s[a[n-i-1]]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,w[10],h[10],a[10];\nlong long min;\nvoid f(int d,int t[10],int c[10],int y[10]){\n  int i,j;\n  if(!d){\n    long long g=0;\n    for(i=0;i<n;i++)g+=w[t[i]]*i;\n    if(min>g){\n      min=g;\n      for(i=0;i<n;i++)a[i]=t[i];\n    }\n    return;\n  }\n  for(i=0;i<n;i++){\n    if(c[i])continue;//printf(\"%d %d\\n\",d,i);\n    t[n-d]=i;\n    c[i]=1;\n    y[n-d]=h[i];\n    for(j=0;j<n-d;j++){\n      y[j]-=w[i];\n      if(y[j]<0)break;\n    }\n    if((n-d)-j==0)f(d-1,t,c,y);\n    c[i]=0;\n    for(j=0;j<n-d;j++)y[j]+=w[i];      \n  }\n  return;\n}      \nint main(){\n  char s[10][12];\n  int i;\n  while(scanf(\"%d\",&n),n){\n    min=2100000000;\n    int t[10]={0};\n    int c[10]={0};\n    int y[10]={0};\n    for(i=0;i<n;i++){\n      scanf(\"%s %d %d\",s[i],&w[i],&h[i]);\n      a[i]=0;\n    }\n    f(n,t,c,y);\n    for(i=0;i<n;i++)printf(\"%s\\n\",s[a[i]]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "n,S[10][6];w[10],s[10];W[1024],B[1024],G[10][1024];R(f,F){int*p=G[f]+F,i,g,m;m=F?*p?*p:1e9:w[f];for(i=m==1e9?n:0;i--;F&g&&s[i]>=W[F^g]&&(g=R(i,F^g)+W[F])<m?B[m=g,F]=i:0)g=1<<i;return*p=m;}main(f,F){for(;~scanf(\"%d\",&n);){for(f=n;f--;)scanf(\"%s%d%d\",S[f],w+f,s+f);for(F=1<<n;F--;)for(W[F]=f=0;f<n;G[f++][F]=0)F&1<<f?W[F]+=w[f]:0;for(R(0,F=(1<<n)-1);F;F^=1<<f)puts(S[f=B[F]]);}}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint n;\n\tdouble G;\n\tItem[] item;\n\tint[] perm, ans;\n\tboolean[] used;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) return;\n\t\t\titem = new Item[n];\n\t\t\tans = new int[n];\n\t\t\tperm = new int[n];\n\t\t\tused = new boolean[n];\n\t\t\tG = Double.MAX_VALUE;\n\n\t\t\tfor (int i = 0; i < n; i++) item[i] = new Item(sc.next(), sc.nextInt(), sc.nextInt());\n\n\t\t\tpermutation(0, 0);\n\n\t\t\tfor (int i = n - 1; i >= 0; i--) System.out.println(item[ans[i]].name);\n\t\t}\n\t}\n\n\tvoid permutation(int pos, int weight) {\n\t\tif (pos == n) {\n\t\t\tdouble tmp = 0;\n\t\t\tfor (int i = 0; i < n; i++) tmp += item[perm[i]].w * (n - i);\n\t\t\tif (tmp / weight < G) {\n\t\t\t\tG = tmp / weight;\n\t\t\t\tfor (int i = 0; i < n; i++) ans[i] = perm[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!used[i]) {\n\t\t\t\tif (weight > item[i].s) {\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tperm[pos] = i;\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tpermutation(pos + 1, weight + item[i].w);\n\t\t\t\t\tused[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass Item {\n\t\tString name;\n\t\tint w;\n\t\tint s;\n\n\t\tpublic Item(String name, int w, int s) {\n\t\t\tsuper();\n\t\t\tthis.name = name;\n\t\t\tthis.w = w;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Lunch implements Comparable<Lunch>{\n\t\tString name;\n\t\tint weight;\n\t\tint capacity;\n\t\tint number;\n\n\t\tLunch (String name, int weight, int capacity) {\n\t\t\tthis.name = name;\n\t\t\tthis.weight = weight;\n\t\t\tthis.capacity = capacity;\n\t\t\tthis.number = 0;\n\t\t}\n\n\t\tpublic int compareTo(Lunch o) {\n\t\t\tif (o.number != this.number) {\n\t\t\t\treturn this.number - o.number;\n\t\t\t} else {\n\t\t\t\treturn o.weight - this.weight;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tLunch lunch[];\n\t\tint sumWeight;\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlunch = new Lunch[n];\n\t\t\tsumWeight = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint weight = sc.nextInt();\n\t\t\t\tint capacity = sc.nextInt();\n\t\t\t\tlunch[i] = new Lunch(name, weight, capacity);\n\t\t\t\tsumWeight += weight;\n\t\t\t}\n\t\t\tArrays.sort(lunch);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (lunch[j].number == 0 && sumWeight - lunch[j].weight <= lunch[j].capacity) {\n\t\t\t\t\t\tlunch[j].number = i + 1;\n\t\t\t\t\t\tsumWeight -= lunch[j].weight;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(lunch);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tSystem.out.println(lunch[i].name);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tString[] f = new String[n];\n\t\t\tint[] w = new int[n];\n\t\t\tint[] s = new int[n];\n\t\t\tint smax = 0;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tf[i] = sc.next();\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tsmax = Math.max(s[i], smax);\n\t\t\t}\n\t\t\tData[][] dp = new Data[(1 << n)][smax+1];\n\t\t\t\n\t\t\tdp[0][smax] = new Data();\n\t\t\tdp[0][smax].G = 0;\n\t\t\tdp[0][smax].ix = 1;\n\t\t\tdp[0][smax].id = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < (1 << n); i++) {\n\t\t\t\tfor(int j = smax; j >= 0; j--) {\n\t\t\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\t\t\tif(dp[i][j] == null) continue;\n\t\t\t\t\t\tif((i & (1 << k)) == 0 && (j - w[k]) >= 0) {\n\t\t\t\t\t\t\tData a = dp[i|(1 << k)][Math.min(j - w[k], s[k])];\n\t\t\t\t\t\t\tData b = new Data();\n\t\t\t\t\t\t\tb.id = k;\n\t\t\t\t\t\t\tb.ix = dp[i][j].ix;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tb.G = dp[i][j].G + b.ix * w[k];\n\t\t\t\t\t\t\tb.ix++;\n\t\t\t\t\t\t\tb.down = dp[i][j];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(a == null || a.G > b.G) {\n\t\t\t\t\t\t\t\tif(b.ix == 2) {\n\t\t\t\t\t\t\t\t\tdp[i|(1 << k)][s[k]] = b;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tdp[i|(1 << k)][Math.min(j - w[k], s[k])] = b;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint id = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < smax+1; i++) {\n\t\t\t\tif(dp[(1 << n)-1][i] != null && min > dp[(1 << n)-1][i].G) {\n\t\t\t\t\tmin = dp[(1 << n) -1][i].G;\n\t\t\t\t\tid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrayDeque<Data> sxx = new ArrayDeque<Data>();\n\t\t\tData p = dp[(1 << n) -1][id];\n\t\t\tsxx.add(p);\n\t\t\twhile(p.down != null) {\n\t\t\t\tsxx.add(p.down);\n\t\t\t\tp = p.down;\n\t\t\t}\n\t\t\tsxx.pollLast();\n\t\t\twhile(!sxx.isEmpty()) {\n\t\t\t\tSystem.out.println(f[sxx.pollLast().id]);\n\t\t\t}\n\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic class Data {\n\t\tint id;\n\t\tData down;\n\t\tint G;\n\t\tint ix;\n\t}\n\t\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tScanner sc = new Scanner(System.in);\n\tString [] name;\n\tint [] s,w;\n\tString ans;\n\tint n, value;\n\tboolean [] used;\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tname = new String[n];\n\t\t\ts = new int[n];\n\t\t\tw = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t}\n\t\t\tused = new boolean[n];\n\t\t\tans = \"\";\n\t\t\tvalue = 1 << 24;\n\t\t\tdfs(0,0,0, new StringBuilder());\n\t\t\tfor(int i = ans.length() - 1; i >= 0; i--){\n\t\t\t\tint ind = ans.charAt(i) - '0';\n\t\t\t\tSystem.out.println(name[ind]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void dfs(int deep, int wsum, int gsum,  StringBuilder order) {\n\t\tif(deep == n){\n\t\t\tif(gsum < value){\n\t\t\t\tvalue = gsum;\n\t\t\t\tans = new String(order.toString());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < n;i++){\n\t\t\tif(! used[i] && s[i] >= wsum){\n\t\t\t\tused[i] = true;\n\t\t\t\torder.append(i);\n\t\t\t\tdfs(deep + 1, wsum + w[i], gsum + w[i] * (n - deep),order);\n\t\t\t\torder.deleteCharAt(order.length() - 1);\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<String> Ans = new ArrayList<String>();\n\t\tString line;\n\t\t\n\t\twhile((line = in.readLine()) != null){\n\t\t\tint size = Integer.parseInt(line);\n\t\t\tif(size == 0) break;\n\t\t\tfood[] lunch = new food[size];\n\t\t\tfor(int i=0; i<size; i++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] dst = line.split(\" \");\n\t\t\t\tint w = Integer.parseInt(dst[1]);\n\t\t\t\tint s = Integer.parseInt(dst[2]);\n\t\t\t\tlunch[i] = new food(dst[0], w, s);\n\t\t\t}\n\t\t\tLunchSort(lunch);\n\t\t\t\n\t\t\tfor(int i=0; i<size; i++){\n\t\t\t\tAns.add(lunch[i].name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<Ans.size(); i++){\n\t\t\tSystem.out.println(Ans.get(i));\n\t\t}\n\t}\n\t\n\tpublic void LunchSort(food[] lunch){\n\t\tint size = lunch.length;\n\t\tList<food> foods = new ArrayList<food>();\n\t\tint sum = 0;\n\t\tfor(int i=0; i<size; i++){\n\t\t\tfoods.add(lunch[i]);\n\t\t\tsum += lunch[i].w;\n\t\t}\n\t\t\n\t\twhile(foods.size() != 0){\n\t\t\tint max_w = 0;\n\t\t\tint index = -1;\n\t\t\tfor(int i=0; i<foods.size(); i++){\n\t\t\t\tif(sum-foods.get(i).w <= foods.get(i).s && max_w < foods.get(i).w){\n\t\t\t\t\tmax_w = foods.get(i).w;\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlunch[size - foods.size()] = foods.get(index);\n\t\t\tsum -= foods.get(index).w;\n\t\t\tfoods.remove(index);\n\t\t}\t\t\n\t}\n}\n\nclass food{\n\tString name;\n\tint w;\n\tint s;\n\t\n\tpublic food(String name, int w, int s){\n\t\tthis.name = name;\n\t\tthis.w = w;\n\t\tthis.s = s;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Lunch\npublic class Main {\n\n\tstatic int[] ans;\n\tstatic String[] name;\n\tstatic int n;\n\tstatic int[] w;\n\tstatic int[] s;\n\tstatic int[] order;\n\tstatic boolean[] used;\n\tstatic double best;\n\t\n\tstatic void dfs(int k, int num, int total){\n\t\tif(k==0){\n\t\t\tdouble g = num*1.0/total;\n\t\t\tif(g<best){\n\t\t\t\tbest = g;\n\t\t\t\tfor(int i=1;i<=n;i++)ans[i-1]=order[i];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!used[i]&&total<=s[i]){\n\t\t\t\tused[i] = true;\n\t\t\t\torder[k] = i;\n\t\t\t\tdfs(k-1, num+k*w[i], total+w[i]);\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tname = new String[n];\n\t\t\tw = new int[n];\n\t\t\ts = new int[n];\n\t\t\torder = new int[n+1];\n\t\t\tbest = Integer.MAX_VALUE;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t}\n\t\t\tused = new boolean[n];\n\t\t\tans = new int[n];\n\t\t\tdfs(n, 0, 0);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tSystem.out.println(name[ans[i]]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic String f[], nf[];\n\tstatic int w[], s[], nw[], ns[];\n\tstatic int a[];\n\tstatic int ans[];\n\tstatic double min;\n\n\tpublic static void f(int k) {\n\t\tif (k == n) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (a[j] == i) {\n\t\t\t\t\t\tnf[i] = f[j];\n\t\t\t\t\t\tnw[i] = w[j];\n\t\t\t\t\t\tns[i] = s[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tsum += nw[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tif (ns[i] < sum) {\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t\tsum -= nw[i + 1];\n\t\t\t}\n\n\t\t\tdouble gc = 0, gm = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tgm += nw[i];\n\t\t\t\tgc += nw[i] * (i + 1);\n\t\t\t}\n\t\t\tif (gc / gm < min) {\n\t\t\t\tmin = gc / gm;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tans[i] = a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (a[i] == -1) {\n\t\t\t\t\ta[i] = k;\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\ta[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tf = new String[n];\n\t\t\tw = new int[n];\n\t\t\ts = new int[n];\n\t\t\tnf = new String[n];\n\t\t\tnw = new int[n];\n\t\t\tns = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tf[i] = sc.next();\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t}\n\t\t\ta = new int[n];\n\t\t\tans = new int[n];\n\t\t\tmin = Double.MAX_VALUE;\n\t\t\tArrays.fill(a,  -1);\n\t\t\tf(0);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (ans[j] == i) {\n\t\t\t\t\t\tSystem.out.println(f[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Food implements Comparable<Food>{\n\tString f;\n\tint w;\n\tint s;\n\tFood(String f,int w,int s){\n\t\tthis.f=f;\n\t\tthis.w=w;\n\t\tthis.s=s;\n\t}\n\t@Override\n\t//あえて逆順。いわゆる重い順。\n\tpublic int compareTo(Food o) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tif(this.w<w){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(this.w>w){\n\t\t\treturn -1;\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t}\n}\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t\t//new AOJ0170().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0) break;\n\n\t\t\tint sum=0;\n\t\t\tFood food[]=new Food[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfood[i]=new Food(sc.next(), sc.nextInt(), sc.nextInt());\n\t\t\t\tsum+=food[i].w;\n\t\t\t}\n\t\t\tint max=-1;\n\t\t\t\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint k=j;\n\t\t\t\tmax=-1;\n\t\t\t\tfor(int i=j;i<n;i++){\n\t\t\t\t\tif((sum-food[i].w<=food[i].s) && (max<food[i].w)){\n\t\t\t\t\t\tmax=food[i].w;\n\t\t\t\t\t\tk=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//change\n\t\t\t\tsum-=food[k].w;\n\t\t\t\tFood temp=food[j];\n\t\t\t\tfood[j]=food[k];\n\t\t\t\tfood[k]=temp;\n\t\t\t}\n\t\t\tArrays.sort(food);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tSystem.out.println(food[i].f);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    static boolean used[];\n    static int nums[];\n    static String fs[];\n    static int ws[];\n    static int ss[];\n    static double g;\n    static int[] ans;\n    static int total;\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            nums = new int[n];\n            used = new boolean[n];\n            fs = new String[n];\n            ws = new int[n];\n            ss = new int[n];\n            ans = new int[n];\n            total = 0;\n            for (int i = 0; i < n; i++) {\n                String f = sc.next();\n                int w = sc.nextInt();\n                int s = sc.nextInt();\n                fs[i] = f;\n                ws[i] = w;\n                ss[i] = s;\n                total += w;\n            }\n            g = Double.MAX_VALUE;\n            permutation(0, n, 0);\n            for (int i = n - 1; i >= 0; i--) {\n                System.out.println(fs[ans[i]]);\n            }\n        }\n    }\n\n    public static void permutation(int pos, int n, int sum) {\n        if (pos == n) {\n            int a = 0;\n            for (int i = 0; i < n; i++) {\n                a += (n - i) * ws[nums[i]];\n            }\n            double G = 1.0 * a / total;\n            if (G < g) {\n                for (int i = 0; i < n; i++) {\n                    ans[i] = nums[i];\n                }\n                g = G;\n            }\n            return;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (used[i])\n                continue;\n            if (ss[i] < sum)\n                continue;\n            nums[pos] = i;\n            used[i] = true;\n            permutation(pos + 1, n, sum + ws[i]);\n            used[i] = false;\n        }\n        return;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint n;\n\tItem[] item;\n\tint[] ans;\n\tdouble G;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\titem = new Item[n];\n\t\t\tans = new int[n];\n\t\t\tperm = new int[n];\n\t\t\tused = new boolean[n];\n\t\t\tG = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\titem[i] = new Item(sc.next(), sc.nextInt(), sc.nextInt());\n\t\t\t}\n\n\t\t\tpermutation(0);\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tSystem.out.println(item[ans[i]].name);\n\t\t\t}\n\t\t}\n\t}\n\n\t// make permutation (N<=11)\n\tboolean[] used;\n\tint[] perm;\n\n\tvoid permutation(int pos) {\n\t\tif (pos == n) {\n\n\t\t\tint W = 0;\n\t\t\tdouble tmp = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (item[perm[i]].s < W) return;\n\t\t\t\tW += item[perm[i]].w;\n\t\t\t\ttmp += item[perm[i]].w * (n - i);\n\t\t\t}\n\t\t\tif (tmp / W < G) {\n\t\t\t\tG = tmp / W;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tans[i] = perm[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!used[i]) {\n\t\t\t\tperm[pos] = i;\n\t\t\t\tused[i] = true;\n\t\t\t\tpermutation(pos + 1);\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Item {\n\t\tString name;\n\t\tint w;\n\t\tint s;\n\n\t\t/**\n\t\t * @param name\n\t\t * @param w\n\t\t * @param s\n\t\t */\n\t\tpublic Item(String name, int w, int s) {\n\t\t\tsuper();\n\t\t\tthis.name = name;\n\t\t\tthis.w = w;\n\t\t\tthis.s = s;\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Food {\n\tString name;\n\tint w;\n\tint s;\n\n\tpublic Food(String name, int w, int s) {\n\t\tthis.name = name;\n\t\tthis.w = w;\n\t\tthis.s = s;\n\t}\n\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif(n==0)\n\t\t\t\tbreak;\n\t\t\tint max = 0;\n\t\t\tList<Food> list = new ArrayList<Food>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString l = scanner.next();\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tlist.add(new Food(l, a, b));\n\t\t\t\tmax += a;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint l = 0;\n\t\t\t\tint k = 0;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tint m = max - list.get(j).w;\n\t\t\t\t\tint ss = list.get(j).s;\n\t\t\t\t\tif (m <= ss) {\n\t\t\t\t\t\tif (list.get(j).w > k) {\n\t\t\t\t\t\t\tk = list.get(j).w;\n\t\t\t\t\t\t\tl = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax -= list.get(l).w;\n\t\t\t\tSystem.out.println(list.get(l).name);\n\t\t\t\tlist.get(l).s = -10;\n\t\t\t\tlist.get(l).w = 0;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic String f[];\n\tstatic int w[], s[];\n\tstatic int a[];\n\tstatic int ans[];\n\tstatic double min;\n\n\tpublic static void f(int k) {\n\t\tif (k == n) {\n\t\t\tString nf[] = new String[n];\n\t\t\tint nw[] = new int[n];\n\t\t\tint ns[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (a[j] == i) {\n\t\t\t\t\t\tnf[i] = f[j];\n\t\t\t\t\t\tnw[i] = w[j];\n\t\t\t\t\t\tns[i] = s[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tsum += nw[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tif (ns[i] < sum) {\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t\tsum -= nw[i + 1];\n\t\t\t}\n\n\t\t\tdouble gc = 0, gm = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tgm += nw[i];\n\t\t\t\tgc += nw[i] * (i + 1);\n\t\t\t}\n\t\t\tif (gc / gm < min) {\n\t\t\t\tmin = gc / gm;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tans[i] = a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (a[i] == -1) {\n\t\t\t\t\ta[i] = k;\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\ta[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tf = new String[n];\n\t\t\tw = new int[n];\n\t\t\ts = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tf[i] = sc.next();\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t}\n\t\t\ta = new int[n];\n\t\t\tans = new int[n];\n\t\t\tmin = Double.MAX_VALUE;\n\t\t\tArrays.fill(a,  -1);\n\t\t\tf(0);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (ans[j] == i) {\n\t\t\t\t\t\tSystem.out.println(f[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport static java.util.Arrays.deepToString;\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\titems = new Item[n]; \n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\titems[i] = new Item();\n\t\t\t\titems[i].name = sc.next();\n\t\t\t\titems[i].w = sc.nextInt();\n\t\t\t\titems[i].s = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint totalWeight = 0;\n\t\t\tfor (Item item : items) totalWeight += item.w;\n\t\t\t\n\t\t\tbestG = Integer.MAX_VALUE;\n\t\t\tbestSeq = new Item[n];\n\t\t\tseq = new Item[n];\n\t\t\tdfs(0, 0, totalWeight);\n\t\t\t\n\t\t\tfor (Item item: bestSeq) {\n\t\t\t\tSystem.out.println(item.name);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(int depth, int curG, int remainWeight) {\n\t\tif (depth == items.length) {\n\t\t\tif (bestG > curG) {\n\t\t\t\tbestG = curG;\n\t\t\t\tbestSeq = seq.clone();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor (Item item : items) {\n\t\t\tif (!item.used && remainWeight - item.w <= item.s) {\n\t\t\t\titem.used = true;\n\t\t\t\tseq[depth] = item;\n\t\t\t\tdfs(depth + 1, curG + item.w * (depth+1), remainWeight - item.w);\n\t\t\t\titem.used = false;\n\t\t\t\tseq[depth] = null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tItem[] items;\n\tint bestG;\n\tItem[] bestSeq;\n\tItem[] seq;\n\t\n\tclass Item {\n\t\tString name;\n\t\tint w;\n\t\tint s;\n\t\tboolean used;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.concurrent.LinkedBlockingDeque;\n\npublic class Main {\n\t\n\tpublic static class Item{\n\t\tString name;\n\t\tint weight, strong;\n\t\t\n\t\tpublic Item(String name, int weight, int strong) {\n\t\t\tsuper();\n\t\t\tthis.name = name;\n\t\t\tthis.weight = weight;\n\t\t\tthis.strong = strong;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn name;\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Item> input = new ArrayList<Item>(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tinput.add(new Item(sc.next(), sc.nextInt(), sc.nextInt()));\n\t\t\t}\n\t\t\t\n\t\t\tHashSet<Item> collect = new HashSet<Item>(n);\n\t\t\tLinkedList<Item> list = new LinkedList<Item>();\n\t\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\tstack.add(0);\n\t\t\t\n\t\t\tLinkedList<Item> answer = null;\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\t\n\t\t\tLOOP:\n\t\t\twhile(!stack.isEmpty()){\n\t\t\t\t//System.out.println(stack);\n\t\t\t\t//System.out.println(\"using : \" +  collect);\n\t\t\t\t\n\t\t\t\tint cur = stack.pop();\n\t\t\t\t\n\t\t\t\tif(collect.size() == n){\n\t\t\t\t\tdouble g = 0;\n\t\t\t\t\tint up = 0;\n\t\t\t\t\tint down = 0;\n\t\t\t\t\tint count = 1;\n\t\t\t\t\tfor(Item item : list){\n\t\t\t\t\t\tup += count * item.weight;\n\t\t\t\t\t\tdown += item.weight;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tg = up / (double)down;\n\t\t\t\t\t\n\t\t\t\t\tif(min > g){\n\t\t\t\t\t\tmin = g;\n\t\t\t\t\t\tanswer = (LinkedList<Item>) list.clone();\n\t\t\t\t\t}\n\t\t\t\t\tcollect.remove(list.removeLast());\n\t\t\t\t\tcontinue LOOP;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = cur; i < n; i++){\n\t\t\t\t\tif(!collect.contains(input.get(i))){\n\t\t\t\t\t\tint w = 0;\n\t\t\t\t\t\tfor(Item item : list){\n\t\t\t\t\t\t\tw += item.weight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw += input.get(i).weight;\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean flag = true;\n\t\t\t\t\t\tfor(Item item : list){\n\t\t\t\t\t\t\tw -= item.weight;\n\t\t\t\t\t\t\tif(item.strong < w){\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(flag){\n\t\t\t\t\t\t\tcollect.add(input.get(i));\n\t\t\t\t\t\t\tstack.push(i + 1);\n\t\t\t\t\t\t\tstack.push(0);\n\t\t\t\t\t\t\tlist.add(input.get(i));\n\t\t\t\t\t\t\tcontinue LOOP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//System.out.println(list);\n\t\t\t\t\n\t\t\t\tif(list.size() != 0){\n\t\t\t\t\tcollect.remove(list.removeLast());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(Item item : answer){\n\t\t\t\tSystem.out.println(item.name);\n\t\t\t}\n\t\t}\t\t\t\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tString[] f;\n\tint[] w, s;\n\tint[] a, best;\n\tdouble bestG;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf=new String[n];\n\t\t\tw=new int[n];\n\t\t\ts=new int[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tf[i]=sc.next();\n\t\t\t\tw[i]=sc.nextInt();\n\t\t\t\ts[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\ta=new int[n];\n\t\tbest=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\ta[i]=i;\n\t\t}\n\t\tbestG=INF;\n\t\trec(0);\n\t\tfor(int e : best){\n\t\t\tprintln(f[e]);\n\t\t}\n\t}\n\n\tvoid rec(int j){\n\t\tif(j==n){\n\t\t\t// 0ツつェツ暗ェツ氾板可コ\n\t\t\tint sumW=0;\n\t\t\tint nW=0;\n\t\t\tfor(int i=n-1; i>=0; i--){\n\t\t\t\tif(s[a[i]]<sumW){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsumW+=w[a[i]];\n\t\t\t\tnW+=(i+1)*w[a[i]];\n\t\t\t}\n\t\t\tdouble g=(double)nW/sumW;\n\t\t\tif(g+EPS<bestG){\n\t\t\t\tSystem.arraycopy(a, 0, best, 0, n);\n\t\t\t\tbestG=g;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfor(int i=j; i<n; i++){\n\t\t\tint t=a[i];\n\t\t\ta[i]=a[j];\n\t\t\ta[j]=t;\n\t\t\trec(j+1);\n\t\t\tt=a[i];\n\t\t\ta[i]=a[j];\n\t\t\ta[j]=t;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint max = 0;\n\t\t\tList<Food> list = new ArrayList<Food>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString l = scanner.next();\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tlist.add(new Food(l, a, b));\n\t\t\t\tmax += a;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint l = 0;\n\t\t\t\tint k = 0;\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\tint m = max - list.get(j).w;\n\t\t\t\t\tint ss = list.get(j).s;\n\t\t\t\t\tif (m <= ss) {\n\t\t\t\t\t\tif (list.get(j).w > k) {\n\t\t\t\t\t\t\tk = list.get(j).w;\n\t\t\t\t\t\t\tl = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax -= list.get(l).w;\n\t\t\t\tSystem.out.println(list.get(l).name);\n\t\t\t\tlist.remove(l);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Food {\n\t\tString name;\n\t\tint w;\n\t\tint s;\n\n\t\tpublic Food(String name, int w, int s) {\n\t\t\tthis.name = name;\n\t\t\tthis.w = w;\n\t\t\tthis.s = s;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Food{\n\tString f;\n\tint w;\n\tint s;\n\tFood(String f,int w,int s){\n\t\tthis.f=f;\n\t\tthis.w=w;\n\t\tthis.s=s;\n\t}\n}\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t\t//new AOJ0170().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0) break;\n\n\t\t\tint sum=0;\n\t\t\tFood food[]=new Food[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfood[i]=new Food(sc.next(), sc.nextInt(), sc.nextInt());\n\t\t\t\tsum+=food[i].w;\n\t\t\t}\n\t\t\tint max=-1;\n\t\t\t\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint k=j;\n\t\t\t\tmax=-1;\n\t\t\t\tfor(int i=j;i<n;i++){\n\t\t\t\t\tif((sum-food[i].w<=food[i].s) && (max<food[i].w)){\n\t\t\t\t\t\tmax=food[i].w;\n\t\t\t\t\t\tk=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//change\n\t\t\t\tsum-=food[k].w;\n\t\t\t\tFood temp=food[j];\n\t\t\t\tfood[j]=food[k];\n\t\t\t\tfood[k]=temp;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tSystem.out.println(food[i].f);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n\tpublic static final int BIG_NUM = 2000000000;\n\tpublic static final int MOD = 1000000007;\n\tpublic static final long HUGE_NUM = 99999999999999999L;\n\tpublic static final double EPS = 0.000000001;\n\n\n\tpublic static double value;\n\tpublic static int N;\n\tpublic static final int SIZE = 10;\n\tpublic static Info info[];\n\tpublic static int table[];\n\tpublic static boolean used[];\n\tpublic static int ANS[];\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\n\t\t//BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tinfo = new Info[SIZE];\n\t\ttable = new int[SIZE];\n\t\tused = new boolean[SIZE];\n\t\tANS = new int[SIZE];\n\n\t\tfor(int i = 0; i < SIZE; i++){\n\n\t\t\tinfo[i] = new Info();\n\t\t}\n\n\t\tStringBuffer ans = new StringBuffer();\n\n\t\twhile(true){\n\n\t\t\tN = scanner.nextInt();\n\t\t\tif(N == 0)break;\n\n\t\t\tdouble total_weight = 0;\n\n\t\t\tfor(int i = 0; i < N; i++){\n\n\t\t\t\tinfo[i].set(scanner.next(), scanner.nextInt(), scanner.nextInt());\n\t\t\t\ttotal_weight += info[i].weight;\n\t\t\t}\n\n\t\t\tvalue = (double)HUGE_NUM;\n\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(total_weight-info[i].weight > info[i].can_stand)continue;\n\n\t\t\t\ttable[0] = i;\n\t\t\t\tused[i] = true;\n\t\t\t\trecursive(1);\n\t\t\t\tused[i] = false;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < N; i++){\n\n\t\t\t\tans.append(info[ANS[i]].name).append(\"\\n\");\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.print(ans.toString());\n\t}\n\n\tpublic static void recursive(int index){\n\n\t\tif(index == N){\n\n\t\t\tdouble numerator = 0,denominator = 0;\n\t\t\tfor(int i = 1; i <= N; i++){\n\n\t\t\t\tnumerator += (double)i*info[table[i-1]].weight;\n\t\t\t}\n\t\t\tfor(int i = 0; i < N; i++){\n\n\t\t\t\tdenominator += info[table[i]].weight;\n\t\t\t}\n\n\t\t\tdouble tmp = numerator/denominator;\n\n\t\t\tif(value > tmp){\n\t\t\t\tvalue = tmp;\n\n\t\t\t\tfor(int i = 0; i < N; i++){\n\n\t\t\t\t\tANS[i] = table[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t//残っている人の体重の和\n\t\tdouble rest_weight = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i])continue;\n\n\t\t\trest_weight += info[i].weight;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(used[i])continue;\n\t\t\tif(rest_weight-info[i].weight > info[i].can_stand)continue;\n\n\t\t\ttable[index] = i;\n\t\t\tused[i] = true;\n\t\t\trecursive(index+1);\n\t\t\tused[i] = false;\n\t\t}\n\t}\n}\n\nclass Info{\n\n\tpublic String name;\n\tpublic int weight;\n\tpublic int can_stand;\n\n\tvoid set(String arg_name,int arg_weight,int arg_can_stand){\n\t\tname = arg_name;\n\t\tweight = arg_weight;\n\t\tcan_stand = arg_can_stand;\n\t}\n}\n\nclass UTIL{\n\n\t//最大公約数\n\tpublic static long gcd(long x,long y){\n\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\n\t\tif(x < y){\n\n\t\t\tlong tmp = y;\n\t\t\ty = x;\n\t\t\tx = tmp;\n\t\t}\n\n\t\tif(y == 0){\n\n\t\t\treturn x;\n\t\t}else{\n\n\t\t\treturn gcd(y,x%y);\n\t\t}\n\t}\n\n\t//最小公倍数\n\tpublic static long lcm(long x,long y){\n\n\t\treturn (x*y)/gcd(x,y);\n\t}\n\n\t//String→intへ変換\n    public static int getNUM(String tmp_str){\n\n        return Integer.parseInt(tmp_str);\n    }\n\n    //文字が半角数字か判定する関数\n    public static boolean isNumber(String tmp_str){\n\n        if(tmp_str == null || tmp_str.length() == 0){\n\n            return false;\n        }\n\n        Pattern pattern = Pattern.compile(\"\\\\A[0-9]+\\\\z\");\n        Matcher matcher = pattern.matcher(tmp_str);\n        return matcher.matches();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Food {\n\tString name;\n\tint w;\n\tint s;\n\n\tpublic Food(String name, int w, int s) {\n\t\tthis.name = name;\n\t\tthis.w = w;\n\t\tthis.s = s;\n\t}\n\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint max = 0;\n\t\t\tList<Food> list = new ArrayList<Food>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString l = scanner.next();\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tlist.add(new Food(l, a, b));\n\t\t\t\tmax += a;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint l = 0;\n\t\t\t\tint k = 0;\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\tint m = max - list.get(j).w;\n\t\t\t\t\tint ss = list.get(j).s;\n\t\t\t\t\tif (m <= ss) {\n\t\t\t\t\t\tif (list.get(j).w > k) {\n\t\t\t\t\t\t\tk = list.get(j).w;\n\t\t\t\t\t\t\tl = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax -= list.get(l).w;\n\t\t\t\tSystem.out.println(list.get(l).name);\n\t\t\t\tlist.get(l).s = -10;\n\t\t\t\tlist.get(l).w = 0;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint n, sum;\n\tString[] f;\n\tint[] w, s, memo, ans;\n\tdouble min;\n\t\n\tpublic void loop(int m, int gsum, int wsum){\n\t\tif(m==n){\n\t\t\tif(min>(double)gsum/wsum){\n\t\t\t\tmin = (double)gsum/wsum;\n\t\t\t\tfor(int i=0;i<n;i++) ans[i] = memo[i];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tboolean flag = true;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(memo[j]==i) flag = false;\n\t\t\t}\n\t\t\tif(flag==true){\n\t\t\t\tmemo[m] = i;\n\t\t\t\tif(sum-wsum-w[i]<=s[i]){\n\t\t\t\t\tloop(m+1, gsum+(m+1)*w[i], wsum+w[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tf = new String[n];\n\t\t\tw = new int[n];\n\t\t\ts = new int[n];\n\t\t\tmemo = new int[n];\n\t\t\tArrays.fill(memo, -1);\n\t\t\tans = new int[n];\n\t\t\tsum = 0;\n\t\t\tmin = Integer.MAX_VALUE;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tf[i] = sc.next();\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tsum += w[i];\n\t\t\t}\n\t\t\tloop(0,0,0);\n\t\t\tfor(int i=0;i<n;i++) System.out.println(f[ans[i]]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tvoid doIt() { \n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tString str[] = new String[n];\n\t\t\tint a[] = new int [n];\n\t\t\tint b[] = new int [n];\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tstr[i] = sc.next();\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\tmax = max + a[i];\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tint k = 0;\n\t\t\t\tint l = 0;\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tif(max - a[j] <= b[j]){\n\t\t\t\t\t\tif(a[j] > k){\n\t\t\t\t\t\t\tk = a[j];\n\t\t\t\t\t\t\tl = j;\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax = max - a[l];\n\t\t\t\ta[l] = 0;\n\t\t\t\tb[l] = -10;\n\t\t\t\tSystem.out.println(str[l]);\n\t\t\t}\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\t\n\tpublic static class Item{\n\t\tString name;\n\t\tint weight, strong;\n\t\t\n\t\tpublic Item(String name, int weight, int strong) {\n\t\t\tsuper();\n\t\t\tthis.name = name;\n\t\t\tthis.weight = weight;\n\t\t\tthis.strong = strong;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn name;\n\t\t}\n\t\t\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Item> input = new ArrayList<Item>(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tinput.add(new Item(sc.next(), sc.nextInt(), sc.nextInt()));\n\t\t\t}\n\t\t\t\n\t\t\tHashSet<Item> collect = new HashSet<Item>(n);\n\t\t\tLinkedList<Item> list = new LinkedList<Item>();\n\t\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\tstack.add(0);\n\t\t\t\n\t\t\tLinkedList<Item> answer = null;\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\t\n\t\t\tLOOP:\n\t\t\twhile(!stack.isEmpty()){\n\t\t\t\t//System.out.println(stack);\n\t\t\t\t//System.out.println(\"using : \" +  collect);\n\t\t\t\t\n\t\t\t\tint cur = stack.pop();\n\t\t\t\t\n\t\t\t\tif(collect.size() == n){\n\t\t\t\t\tdouble g = 0;\n\t\t\t\t\tint up = 0;\n\t\t\t\t\tint down = 0;\n\t\t\t\t\tint count = 1;\n\t\t\t\t\tfor(Item item : list){\n\t\t\t\t\t\tup += count * item.weight;\n\t\t\t\t\t\tdown += item.weight;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tg = up / (double)down;\n\t\t\t\t\t\n\t\t\t\t\tif(min > g){\n\t\t\t\t\t\tmin = g;\n\t\t\t\t\t\tanswer = (LinkedList<Item>) list.clone();\n\t\t\t\t\t}\n\t\t\t\t\tcollect.remove(list.removeLast());\n\t\t\t\t\tcontinue LOOP;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = cur; i < n; i++){\n\t\t\t\t\tif(!collect.contains(input.get(i))){\n\t\t\t\t\t\tint w = 0;\n\t\t\t\t\t\tfor(Item item : list){\n\t\t\t\t\t\t\tw += item.weight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw += input.get(i).weight;\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean flag = true;\n\t\t\t\t\t\tfor(Item item : list){\n\t\t\t\t\t\t\tw -= item.weight;\n\t\t\t\t\t\t\tif(item.strong < w){\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(flag){\n\t\t\t\t\t\t\tcollect.add(input.get(i));\n\t\t\t\t\t\t\tstack.push(i + 1);\n\t\t\t\t\t\t\tstack.push(0);\n\t\t\t\t\t\t\tlist.add(input.get(i));\n\t\t\t\t\t\t\tcontinue LOOP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//System.out.println(list);\n\t\t\t\t\n\t\t\t\tif(list.size() != 0){\n\t\t\t\t\tcollect.remove(list.removeLast());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(Item item : answer){\n\t\t\t\tSystem.out.println(item.name);\n\t\t\t}\n\t\t}\t\t\t\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Lunch\npublic class Main{\n\n\tstatic int[] ans;\n\tstatic String[] name;\n\tstatic int n;\n\tstatic int[] w;\n\tstatic int[] s;\n\tstatic int[] order;\n\tstatic boolean[] used;\n\tstatic double best;\n\t\n\tstatic void dfs(int k, int num, int total){\n\t\tif(k==0){\n\t\t\tdouble g = num*1.0/total;\n\t\t\tif(g<best){\n\t\t\t\tbest = g;\n\t\t\t\tfor(int i=1;i<=n;i++)ans[i-1]=order[i];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!used[i]&&total<=s[i]){\n\t\t\t\tused[i] = true;\n\t\t\t\torder[k] = i;\n\t\t\t\tdfs(k-1, num+k*w[i], total+w[i]);\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tname = new String[n];\n\t\t\tw = new int[n];\n\t\t\ts = new int[n];\n\t\t\torder = new int[n+1];\n\t\t\tbest = Integer.MAX_VALUE;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t}\n\t\t\tused = new boolean[n];\n\t\t\tans = new int[n];\n\t\t\tdfs(n, 0, 0);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tSystem.out.println(name[ans[i]]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tstatic Food[] f,ans;\n\tstatic int n;\n\tstatic double min;\n\tstatic Stack<Food> stack;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn=cin.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tf=new Food[n];\n\t\t\tans=new Food[n];\n\t\t\tmin=1<<30;\n\t\t\tstack=new Stack<Food>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tf[i]=new Food(cin.next(),cin.nextInt(),cin.nextInt());\n\t\t\t}\n//\t\t\tArrays.sort(f);\n\t\t\tdfs(0,0);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tSystem.out.println(ans[i].name);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tstatic void dfs(int sum,int depth){\n//\t\tSystem.out.println(sum+\" \"+depth);\n\t\tif(depth==n){\n\t\t\tint ue=0,sita=0;\n\t\t\tint cnt=n;\n\t\t\tfor(Food food:stack){\n\t\t\t\tue+=food.w*cnt;\n\t\t\t\tsita+=food.w;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\tif(min>(double)ue/(double)sita){\n\t\t\t\tmin=(double)ue/(double)sita;\n\t\t\t\tcnt=n-1;\n\t\t\t\tfor(Food food:stack){\n\t\t\t\t\tans[cnt--]=food;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<f.length;i++){\n\t\t\tif(f[i].f)continue;\n\t\t\tif(sum<=f[i].s){\n\t\t\t\tf[i].f=true;\n\t\t\t\tstack.add(f[i]);\n\t\t\t\tdfs(sum+f[i].w,depth+1);\n\t\t\t\tstack.pop();\n\t\t\t\tf[i].f=false;\n\t\t\t}\n\t\t}\n\t}\n\tstatic class Food implements Comparable<Food>{\n\t\tString name;\n\t\tint w,s;\n\t\tboolean f;\n\t\tFood(String s,int a,int b){\n\t\t\tname=s;\n\t\t\tw=a;\n\t\t\tthis.s=b;\n\t\t\tf=false;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Food o) {\n\t\t\t\n\t\t\treturn this.s-o.s;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint max = 0;\n\t\t\tList<Food> list = new ArrayList<Food>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString l = scanner.next();\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tlist.add(new Food(l, a, b));\n\t\t\t\tmax += a;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint l = 0;\n\t\t\t\tint k = 0;\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\tint m = max - list.get(j).w;\n\t\t\t\t\tint ss = list.get(j).s;\n\t\t\t\t\tif (m <= ss) {\n\t\t\t\t\t\tif (list.get(j).w > k) {\n\t\t\t\t\t\t\tk = list.get(j).w;\n\t\t\t\t\t\t\tl = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmax -= list.get(l).w;\n\t\t\t\tSystem.out.println(list.get(l).name);\n\t\t\t\tlist.get(l).s=-10;\n\t\t\t\tlist.get(l).w=0;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Food {\n\t\tString name;\n\t\tint w;\n\t\tint s;\n\n\t\tpublic Food(String name, int w, int s) {\n\t\t\tthis.name = name;\n\t\t\tthis.w = w;\n\t\t\tthis.s = s;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic String f[];\n\tstatic int w[], s[], nw[], ns[];\n\tstatic int a[];\n\tstatic int ans[];\n\tstatic double min;\n\n\tpublic static void f(int k) {\n\t\tif (k == n) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (a[j] == i) {\n\t\t\t\t\t\tnw[i] = w[j];\n\t\t\t\t\t\tns[i] = s[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tsum += nw[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tif (ns[i] < sum) {\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t\tsum -= nw[i + 1];\n\t\t\t}\n\n\t\t\tdouble gc = 0, gm = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tgm += nw[i];\n\t\t\t\tgc += nw[i] * (i + 1);\n\t\t\t}\n\t\t\tif (gc / gm < min) {\n\t\t\t\tmin = gc / gm;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tans[i] = a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (a[i] == -1) {\n\t\t\t\t\ta[i] = k;\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\ta[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tf = new String[n];\n\t\t\tw = new int[n];\n\t\t\ts = new int[n];\n\t\t\tnw = new int[n];\n\t\t\tns = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tf[i] = sc.next();\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t}\n\t\t\ta = new int[n];\n\t\t\tans = new int[n];\n\t\t\tmin = Double.MAX_VALUE;\n\t\t\tArrays.fill(a,  -1);\n\t\t\tf(0);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (ans[j] == i) {\n\t\t\t\t\t\tSystem.out.println(f[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint n, sum;\n\tString[] f;\n\tint[] w, s, memo, ans;\n\tdouble min;\n\t\n\tpublic void loop(int m, int gsum, int wsum){\n\t\tif(m==n){\n\t\t\tif(min>(double)gsum/wsum){\n\t\t\t\tmin = (double)gsum/wsum;\n\t\t\t\tfor(int i=0;i<n;i++) ans[i] = memo[i];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tboolean flag = true;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(memo[j]==i) flag = false;\n\t\t\t}\n\t\t\tif(flag==true){\n\t\t\t\tmemo[m] = i;\n\t\t\t\tif(sum-wsum-w[i]<=s[i]){\n\t\t\t\t\tloop(m+1, gsum+(m+1)*w[i], wsum+w[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tf = new String[n];\n\t\t\tw = new int[n];\n\t\t\ts = new int[n];\n\t\t\tmemo = new int[n];\n\t\t\tArrays.fill(memo, -1);\n\t\t\tans = new int[n];\n\t\t\tsum = 0;\n\t\t\tmin = Integer.MAX_VALUE;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tf[i] = sc.next();\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\tsum += w[i];\n\t\t\t}\n\t\t\tloop(0,0,0);\n\t\t\tfor(int i=0;i<n;i++) System.out.println(f[ans[i]]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass t{\n\t\tdouble v = 0;\n\t\tString a = \"\";\n\t}\n\t\n\tint w[];\n\tint s[];\n\tString f[];\n\t\n\tt g(boolean[] reaming, double rw, int depth) {\n\t\tif (depth == w.length) {\n\t\t\treturn new t();\n\t\t}\n\t\tdouble res = Double.MAX_VALUE;\n\t\tint dv = 0;\n\t\tString ans= \"\";\n\t\tfor (int i = 0; i < reaming.length; i++) {\n\t\t\tif (reaming[i]) {\n\t\t\t\tif (rw - w[i] <= s[i]) {\n\t\t\t\t\t// System.out.println(i + \" \" +rw+\" \" + depth);\n\t\t\t\t\treaming[i] = false;\n\t\t\t\t\tt gz = g(reaming, rw - w[i],  depth + 1) ;\n\t\t\t\t\tgz.v += rw;\n\t\t\t\t\treaming[i] = true;\n\t\t\t\t\tif (res > gz.v) {\n\t\t\t\t\t\tres = gz.v;\n\t\t\t\t\t\tans = gz.a;\n\t\t\t\t\t\tdv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = f[dv]+\"\\n\"+ans;\n\t\tt ret = new t();\n\t\tret.v = res;\n\t\tret.a = ans;\n\t\treturn ret;\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf = new String[n];\n\t\t\tw = new int[n];\n\t\t\ts = new int[n];\n\n\t\t\tdouble rw = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tf[i] = sc.next();\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\ts[i] = sc.nextInt();\n\t\t\t\trw += w[i];\n\t\t\t}\n\n\t\t\tboolean reaming[] = new boolean[n];\n\t\t\tArrays.fill(reaming, true);\n\t\t\tt ans = g(reaming, rw, 0);\n\n\t\t\tSystem.out.print(ans.a);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0170\n{\n    public class Program\n\n    {\n        public class Food\n        {\n            public string Name { get; set; }\n            public int Weight { get; set; }\n            public int Capacity { get; set; }\n            public Food(string[] line)\n            {\n                Name = line[0];\n                Weight = int.Parse(line[1]);\n                Capacity = int.Parse(line[2]);\n            }\n        }\n\n        public static Food[] foods;\n        public static bool[] used;\n        public static int[] candidates;\n        public static int[] res;\n        public static double centerOfG = double.MaxValue;\n        public static double sumOfW;\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int n = RInt();\n                if (n == 0) break;\n\n                foods = new Food[n];\n                for (int i = 0 ; i < n ; i++) foods[i] = new Food(RStAr());\n                Init(n);\n                SetFoods(0);\n                foreach (var item in res.Reverse()) Console.WriteLine(foods[item].Name);\n            }\n\n        }\n\n        private static void Init(int n)\n        {         \n            candidates = new int[n];\n            res = new int[n];\n            used = new bool[n];\n            centerOfG = double.MaxValue;\n            sumOfW = foods.Sum(x => x.Weight);\n        }\n\n        //上から順次食べ物を追加\n        private static void SetFoods(int k)\n        {\n            if (k == foods.Length)\n            {\n                double curG = CalcGravity();\n                if (centerOfG > curG)\n                {\n                    centerOfG = curG;\n                    Array.Copy(candidates, res, res.Length);\n                }\n                return;\n            }\n\n            for (int i = 0 ; i < foods.Length ; i++)\n            {\n                if ((!used[i]) && CanPutUnder(k, i))\n                {\n                    used[i] = true;\n                    candidates[k] = i;\n                    SetFoods(k + 1);\n                    used[i] = false;\n                }\n            }\n        }\n\n        private static bool CanPutUnder(int k, int i)\n        {\n            return candidates.Take(k).Select(x => foods[x].Weight).Sum() <= foods[i].Capacity;\n        }\n\n        private static double CalcGravity()\n        {\n            return candidates.Select((x, i) => foods[x].Weight * (candidates.Length - i)).Sum() / sumOfW;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace PokerPlaying {\n    class Class2 {\n        \n        static void Main(string[] args) {\n            new Class2().solve();\n        }\n        void solve() {\n            while (true) {\n                int num_Food = int.Parse(Console.ReadLine());\n                if (num_Food == 0) {\n                    return;\n                }\n                string[][] input = new string[num_Food][]; \n                for (int i = 0; i < num_Food; i++) {\n                    string[] miniImput = Console.ReadLine().Split(' ');\n                    input[i] = new string[miniImput.Length];\n                    for (int j = 0; j < miniImput.Length; j++) {\n                        input[i][j] = miniImput[j];\n                    }\n                }\n                printOrder(input);\n            }\n        }\n\n        void printOrder(string[][] foodList) {\n            List<int> order = new List<int>();\n\n            for (int i = 0; i < foodList.Length; i++) {\n                int nextOrder = 0;\n                double g = -1;\n                for (int j = 0; j < foodList.Length; j++) {\n                    if (order.Contains(j)) continue;\n                    if (isPossible(j, foodList, order) && calcG(j, foodList, order) > g) {\n                        nextOrder = j;\n                        g = calcG(j, foodList, order);\n                    }\n                }\n                order.Add(nextOrder);\n            }\n            for (int i = 0; i < foodList.Length; i++) {\n                Console.WriteLine(foodList[order[i]][0]);\n            }\n        }\n\n        bool isPossible(int idx, string[][] list, List<int> skipList) {\n            int weigh = 0;\n            for (int i = 0; i < list.Length; i++) {\n                if (i == idx || skipList.Contains(i)) continue;\n                weigh += int.Parse(list[i][1]);\n            }\n            if (int.Parse(list[idx][2]) >= weigh) {\n                return true;\n            } else return false;\n        }\n\n        double calcG(int idx, string[][] list, List<int> checkedList) {\n            double weightedW = 0;\n            double naturalW = 0;\n            if (checkedList.Count != 0) {\n                for (int i = 0; i < checkedList.Count; i++) {\n                    naturalW += double.Parse(list[checkedList[i]][1]);\n                    weightedW += (i + 1) * double.Parse(list[checkedList[i]][1]);\n                }\n                naturalW += double.Parse(list[idx][1]);\n                weightedW += (checkedList.Count + 1) * double.Parse(list[idx][1]);\n            } else {\n                naturalW = double.Parse(list[idx][1]);\n                weightedW = double.Parse(list[idx][1]);\n            }\n            return weightedW/naturalW;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Food\n    {\n        internal string name;\n        internal int wt, cap;\n\n        public override string ToString()\n        {\n            return name;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                int n = int.Parse(Console.ReadLine());\n\n                if (n == 0) break;\n\n                Food[] foods = new Food[n];\n                Food temp;\n\n                for (int i = 0; i < n; i++)\n                {\n                    string[] input = Console.ReadLine().Split(' ');\n                    temp.name = input[0];\n                    temp.wt = int.Parse(input[1]);\n                    temp.cap = int.Parse(input[2]);\n                    foods[i] = temp;\n                }\n\n                var sumW = foods.Sum(f => f.wt);\n                bool[] used = new bool[n];\n\n                for (int i = 0; i < n; i++)\n                {\n                    int maxWt = 0;\n                    int maxIdx = 0;\n\n                    for (int j = 0; j < n; j++)\n                    {\n                        if (used[j] || foods[j].cap < sumW - foods[j].wt) continue;\n\n                        if (foods[j].wt > maxWt)\n                        {\n                            maxWt = foods[j].wt;\n                            maxIdx = j;\n                        }\n                    }\n                    sb.AppendLine(foods[maxIdx].ToString());\n                    sumW -= foods[maxIdx].wt;\n                    used[maxIdx] = true;\n                }\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Food\n    {\n        internal string name;\n        internal int id, wt, cap;\n\n        public override string ToString()\n        {\n            return name;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                int n = int.Parse(Console.ReadLine());\n\n                if (n == 0) break;\n\n                Food[] foods = new Food[n];\n                Food temp;\n\n                for (int i = 0; i < n; i++)\n                {\n                    string[] input = Console.ReadLine().Split(' ');\n                    temp.name = input[0];\n                    temp.id = i;\n                    temp.wt = int.Parse(input[1]);\n                    temp.cap = int.Parse(input[2]);\n                    foods[i] = temp;\n                }\n\n                var sumW = foods.Sum(f => f.wt);\n                bool[] used = new bool[n];\n\n                for (int i = 0; i < n; i++)\n                {\n                    List<Food> candidate = new List<Food>();\n\n                    for (int j = 0; j < n; j++)\n                    {\n                        if (used[foods[j].id] || foods[j].cap < sumW - foods[j].wt) continue;\n                        candidate.Add(foods[j]);\n                    }\n                    candidate.Sort((a, b) => b.wt - a.wt);\n                    sb.AppendLine(candidate[0].ToString());\n                    sumW -= candidate[0].wt;\n                    used[candidate[0].id] = true;\n                }\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace PokerPlaying {\n    class Class2 {\n        \n        static void Main(string[] args) {\n            new Class2().solve();\n        }\n        void solve() {\n            while (true) {\n                int num_Food = int.Parse(Console.ReadLine());\n                if (num_Food == 0) {\n                    return;\n                }\n                string[][] input = new string[num_Food][]; \n                for (int i = 0; i < num_Food; i++) {\n                    string[] miniImput = Console.ReadLine().Split(' ');\n                    input[i] = new string[miniImput.Length];\n                    for (int j = 0; j < miniImput.Length; j++) {\n                        input[i][j] = miniImput[j];\n                    }\n                }\n                printOrder(input);\n            }\n        }\n\n        void printOrder(string[][] foodList) {\n            List<int> order = new List<int>();\n            for (int i = 0; i < foodList.Length; i++) {\n                int nextOrder = 0;\n                double g = 0;\n                for (int j = 0; j < foodList.Length; j++) {\n                    if (order.Contains(j)) continue;\n                    if (isPossible(j, foodList, order) && int.Parse(foodList[j][1]) > g) {\n                        nextOrder = j;\n                        g = int.Parse(foodList[j][1]);\n                    }\n                }\n                order.Add(nextOrder);\n            }\n            for (int i = 0; i < foodList.Length; i++) {\n                Console.WriteLine(foodList[order[i]][0]);\n            }\n        }\n\n        bool isPossible(int idx, string[][] list, List<int> skipList) {\n            int weigh = 0;\n            for (int i = 0; i < list.Length; i++) {\n                if (i == idx || skipList.Contains(i)) continue;\n                weigh += int.Parse(list[i][1]);\n            }\n            if (int.Parse(list[idx][2]) >= weigh) {\n                return true;\n            } else return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Food\n    {\n        internal string name;\n        internal int id, wt, cap;\n\n        public override string ToString()\n        {\n            return name;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                int n = int.Parse(Console.ReadLine());\n\n                if (n == 0) break;\n\n                Food[] foods = new Food[n];\n                Food temp;\n\n                for (int i = 0; i < n; i++)\n                {\n                    string[] input = Console.ReadLine().Split(' ');\n                    temp.name = input[0];\n                    temp.id = i;\n                    temp.wt = int.Parse(input[1]);\n                    temp.cap = int.Parse(input[2]);\n                    foods[i] = temp;\n                }\n\n                var sumW = foods.Sum(f => f.wt);\n                Array.Sort(foods, (a, b) => b.cap - a.cap);\n                bool[] used = new bool[n];\n\n                for (int i = 0; i < n; i++)\n                {\n                    List<Food> candidate = new List<Food>();\n\n                    for (int j = 0; j < n; j++)\n                    {\n                        if (used[foods[j].id]) continue;\n                        if (foods[j].cap < sumW - foods[j].wt) break;\n                        candidate.Add(foods[j]);\n                    }\n                    candidate.Sort((a, b) => b.wt - a.wt);\n                    sb.AppendLine(candidate[0].ToString());\n                    sumW -= candidate[0].wt;\n                    used[candidate[0].id] = true;\n                }\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tvar n = int.Parse(Console.ReadLine().Trim());\n\t\t\tif (n == 0) break;\n\t\t\tvar f1 = new string[n];\n\t\t\tvar f2 = new int[n, 2];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tf1[i] = line[0];\n\t\t\t\tf2[i, 0] = int.Parse(line[1]);\n\t\t\t\tf2[i, 1] = int.Parse(line[2]);\n\t\t\t}\n\t\t\tgetAns(f1, f2, n);\n\t\t}\n\t}\n\tstatic List<int> getCDD (int[,] f2, int n , string a)\n\t{\n\t\tvar c = new List<int>();\n\t\tvar csum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!a.Contains(i.ToString()))\n\t\t\t{\n\t\t\t\tc.Add(i);\n\t\t\t\tcsum += f2[i, 0];\n\t\t\t}\n\t\tvar ans = new List<int>();\n\t\tforeach (var x in c)\n\t\t{\n\t\t\tvar w = csum - f2[x, 0];\n\t\t\tif (w <= f2[x, 1]) ans.Add(x);\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic string getFinal(int[,] f2, int n , List<string> Lc)\n\t{\n\t\tvar gmin = int.MaxValue;\n\t\tvar gs = \"\";\n\t\tforeach (var x in Lc)\n\t\t{\n\t\t\tvar g = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tvar t = x[i] - '0';\n\t\t\t\tg += f2[t, 0] * (i + 1);\n\t\t\t\tif (g > gmin) goto next;\n\t\t\t}\n\t\t\tif (g < gmin) { gmin = g; gs = x; }\n\t\tnext:;\n\t\t}\n\t\treturn gs;\n\t}\n\tstatic void print (string[] f1,string a)\n\t{\n\t\tforeach (var x in a)\n\t\t\tConsole.WriteLine(f1[x-'0']);\n\t}\n\tstatic void getAns (string[] f1, int[,] f2, int n)\n\t{\n\t\tvar q = new Queue<string>();\n\t\tvar c = getCDD(f2, n, \"\");\n\t\tforeach (var x in c) q.Enqueue(x.ToString());\n\t\tvar Lc = new List<string>();\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar w = q.Dequeue();\n\t\t\tif (w.Length == n)  Lc.Add(w);\n\t\t\tvar tt = getCDD(f2, n, w);\n\t\t\tif (tt.Count() > 0)\n\t\t\t\tforeach (var x in tt) q.Enqueue(w + x);\n\t\t}\n\t\tvar ans = getFinal(f2, n, Lc);\n\t\tprint(f1, ans);\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Food\n    {\n        internal string name;\n        internal int wt, cap;\n\n        public override string ToString()\n        {\n            return name;\n        }\n    }\n\n    class Problem\n    {\n        readonly int n;\n\n        Food[] foods;\n        bool[] used;\n        double minBal;\n        string minPath;\n\n        public Problem(int n)\n        {\n            this.n = n;\n            foods = new Food[n];\n            used = new bool[n];\n            minBal = double.MaxValue;\n            minPath = \"\";\n        }\n\n        public void Solve()\n        {\n            Food temp;\n            for (int i = 0; i < n; i++)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                temp.name = input[0];\n                temp.wt = int.Parse(input[1]);\n                temp.cap = int.Parse(input[2]);\n                foods[i] = temp;\n            }\n\n            DFS(0, 0, 0, \"\");\n\n            StringBuilder sb = new StringBuilder();\n            string[] ans = minPath.Split(' ');\n\n            for (int i = n - 1; i >= 0; i--)\n            {\n                sb.AppendLine(ans[i].ToString());\n            }\n            Console.Write(sb);\n        }\n\n        private void DFS(int depth, int sumWt, int sumB, string path)\n        {\n            if (depth == n)\n            {\n                double bal = (double)sumB / sumWt;\n\n                if (minBal > bal)\n                {\n                    minBal = bal;\n                    minPath = path;\n                }\n                return;\n            }\n\n            for (int i = 0; i < n; i++)\n            {\n                if (used[i] || sumWt > foods[i].cap) continue;\n\n                used[i] = true;\n\n                DFS(depth + 1, sumWt + foods[i].wt, sumB + foods[i].wt * (n - depth), path + foods[i].name + \" \");\n\n                used[i] = false;\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int n = int.Parse(Console.ReadLine());\n\n                if (n == 0) break;\n\n                Problem p = new Problem(n);\n                p.Solve();\n            }\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "/*参考 higuma/ArrayPermutation.js*/\nfunction zunretu(n) {\n   var saiki = function(perm, pre, post, n) {\n      if (n > 0) {\n         for (var i = 0; i < post.length; i++) {\n            var rest = post.slice(0);\n            var elem = rest.splice(i, 1);\n            saiki(perm, pre.concat(elem), rest, n - 1);\n         }\n      } else perm.push(pre);\n   };\n   var arr = [];\n   for (var i = 0; i < n; i++) arr.push(i);\n   var perm = [];\n   saiki(perm, [], arr, n);\n   return perm;\n};\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var nww=[];\n   for(var i=0;i<n;i++)nww[i]=arr.shift().split(\" \");\n   nww=nww.map(v=>[v[0],v[1]-0,v[2]-0]);\n   var all=zunretu(n);\n   var max=0;\n   var ans=\"\";\n   all.forEach(v=>{\n      var flag=true;\n      var sum=0;\n      var g=0;\n      v.forEach((i,j)=>{\n         if(sum>nww[i][2])flag=false;\n         sum+=nww[i][1];\n         g+=nww[i][1]*(j+1);\n      });\n      if(flag && g/sum>max){\n         max=g/sum;\n         ans=v;\n      }\n   });\n   console.log(ans.map(v=>nww[v][0]).reverse().join(\"\\n\"));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var all=[\"\"];\nfor(var n=1;n<=10;n++){\n   all[n]=[];\n   var flag=[];\n   for(var i=0;i<n;i++)flag[i]=true;\n   var loop=function(str){\n      if(str.length==n)all[n].push(str);\n      else{\n         for(var i=0;i<n;i++){\n            if(flag[i]){\n               flag[i]=false;\n               loop(str+i);\n               flag[i]=true;\n            }\n         }\n      }\n   };\n   loop(\"\");\n}   \nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var food=[];\n   for(var i=0;i<n;i++)food[i]=arr.shift().split(\" \");\n   var G=Infinity;\n   var min;\n   all[n].forEach(function(v,allIndex){\n      var sum=0;\n      var g=0;\n      var flag=true;\n      for(var i=0;i<n;i++){\n         var value=v[i]-0;\n         var w=food[value][1]-0;\n         var s=food[value][2]-0;\n         if(sum>s){flag=false;break;}\n         sum+=w;\n         g+=w*(n-i);\n      }\n      if(flag){\n         g=g/sum;\n         if(G>g){\n            min=allIndex;\n            G=g;\n         }\n      }\n   });\n   all[n][min].split(\"\").map(Number).reverse().forEach(function(v){\n      console.log(food[v][0]);\n   });\n}"
  },
  {
    "language": "JavaScript",
    "code": "function permute(permutation) {\n  var length = permutation.length,\n      result = [permutation.slice()],\n      c = new Array(length).fill(0),\n      i = 1, k, p;\n\n  while (i < length) {\n    if (c[i] < i) {\n      k = i % 2 && c[i];\n      p = permutation[i];\n      permutation[i] = permutation[k];\n      permutation[k] = p;\n      ++c[i];\n      i = 1;\n      result.push(permutation.slice());\n    } else {\n      c[i] = 0;\n      ++i;\n    }\n  }\n  return result;\n}\n\nvar allArr=[0];\nfor(var i=0;i<9;i++){\n   var arr=[];\n   for(var j=0;j<i+1;j++)arr.push(j);\n   allArr[i+1]=permute(arr);\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var nww=[];\n   for(var i=0;i<n;i++)nww[i]=arr.shift().split(\" \");\n   nww=nww.map(v=>[v[0],v[1]-0,v[2]-0]);\n   nww.sort(function(a,b){\n      if(a[1]==b[1])return a[2]-b[2];\n      else return a[1]-b[1];\n   });\n   var saisyo=nww.shift();\n   var all=allArr[n-1];\n   var max=0;\n   var ans=\"\";\n   for(var k=0;k<all.length;k++){\n      var v=all[k];\n      var flag=true;\n      var sum=saisyo[1];\n      var g=saisyo[2];\n      for(var j=0;j<v.length;j++){\n         var i=v[j];\n         if(sum>nww[i][2]){\n            flag=false;\n            break;\n         }\n         sum+=nww[i][1];\n         g+=nww[i][1]*(j+1);\n      }\n      if(flag && g/sum>max){\n         max=g/sum;\n         ans=v;\n      }\n   }\n   console.log(ans.map(v=>nww[v][0]).reverse().join(\"\\n\")+\"\\n\"+saisyo[0]);\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var all=[\"\"];\nfor(var n=1;n<=10;n++){\n   all[n]=[];\n   var flag=[];\n   for(var i=0;i<n;i++)flag[i]=true;\n   var loop=function(str){\n      if(str.length==n)all[n].push(str.split(\"\").map(Number));\n      else{\n         for(var i=0;i<n;i++){\n            if(flag[i]){\n               flag[i]=false;\n               loop(str+i);\n               flag[i]=true;\n            }\n         }\n      }\n   };\n   loop(\"\");\n}   \nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var food=[];\n   for(var i=0;i<n;i++)food[i]=arr.shift().split(\" \");\n   var G=Infinity;\n   var min;\n   all[n].forEach(function(v,allIndex){\n      var sum=0;\n      var g=0;\n      var flag=v.some(function(value,i){\n         var w=food[value][1]-0;\n         var s=food[value][2]-0;\n         if(sum>s)return true;\n         sum+=w;\n         g+=w*(n-i);\n      });\n      if(flag==false){\n         g=g/sum;\n         if(G>g){\n            min=allIndex;\n            G=g;\n         }\n      }\n   });\n   all[n][min].reverse().forEach(function(v){\n      console.log(food[v][0]);\n   });\n}"
  },
  {
    "language": "JavaScript",
    "code": "function permute(permutation) {\n  var length = permutation.length,\n      result = [permutation.slice()],\n      c = new Array(length).fill(0),\n      i = 1, k, p;\n\n  while (i < length) {\n    if (c[i] < i) {\n      k = i % 2 && c[i];\n      p = permutation[i];\n      permutation[i] = permutation[k];\n      permutation[k] = p;\n      ++c[i];\n      i = 1;\n      result.push(permutation.slice());\n    } else {\n      c[i] = 0;\n      ++i;\n    }\n  }\n  return result;\n}\n\nvar allArr=[0];\nfor(var i=0;i<10;i++){\n   var arr=[];\n   for(var j=0;j<i+1;j++)arr.push(j);\n   allArr[i+1]=permute(arr);\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var nww=[];\n   for(var i=0;i<n;i++)nww[i]=arr.shift().split(\" \");\n   nww=nww.map(v=>[v[0],v[1]-0,v[2]-0]);\n   var all=allArr[n];\n   var max=0;\n   var ans=\"\";\n   for(var k=0;k<all.length;k++){\n      var v=all[k];\n      var flag=true;\n      var sum=0;\n      var g=0;\n      for(var j=0;j<v.length;j++){\n         var i=v[j];\n         if(sum>nww[i][2]){\n            flag=false;\n            break;\n         }\n         sum+=nww[i][1];\n         g+=nww[i][1]*(j+1);\n      }\n      if(flag && g/sum>max){\n         max=g/sum;\n         ans=v;\n      }\n   }\n   console.log(ans.map(v=>nww[v][0]).reverse().join(\"\\n\"));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function permute(permutation) {\n  var length = permutation.length,\n      result = [permutation.slice()],\n      c = new Array(length).fill(0),\n      i = 1, k, p;\n \n  while (i < length) {\n    if (c[i] < i) {\n      k = i % 2 && c[i];\n      p = permutation[i];\n      permutation[i] = permutation[k];\n      permutation[k] = p;\n      ++c[i];\n      i = 1;\n      result.push(permutation.slice());\n    } else {\n      c[i] = 0;\n      ++i;\n    }\n  }\n  return result;\n}\n \nvar allArr=[0];\nfor(var i=0;i<9;i++){\n   var arr=[];\n   for(var j=0;j<i+1;j++)arr.push(j);\n   allArr[i+1]=permute(arr);\n}\n \nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n}\nconsole.log(\"\");\n"
  },
  {
    "language": "JavaScript",
    "code": "var all=[\"\"];\nfor(var n=1;n<=10;n++){\n   all[n]=[];\n   var flag=[];\n   for(var i=0;i<n;i++)flag[i]=true;\n   var loop=function(str){\n      if(str.length==n)all[n].push(str);\n      else{\n         for(var i=0;i<n;i++){\n            if(flag[i]){\n               flag[i]=false;\n               loop(str+i);\n               flag[i]=true;\n            }\n         }\n      }\n   };\n   loop(\"\");\n}   \nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var food=[];\n   for(var i=0;i<n;i++)food[i]=arr.shift().split(\" \");\n   var G=Infinity;\n   var min;\n   all[n].forEach(function(v,allIndex){\n      var sum=0;\n      var g=0;\n      var flag=true;\n      for(var i=0;i<n;i++){\n         var value=v[i]-0;\n         var w=food[value][1]-0;\n         var s=food[value][2]-0;\n         if(sum>s){flag=false;break;}\n         sum+=w;\n         g+=w*(n-i);\n      }\n      if(flag==false){\n         g=g/sum;\n         if(G>g){\n            min=allIndex;\n            G=g;\n         }\n      }\n   });\n   all[n][min].split(\"\").map(Number).reverse().forEach(function(v){\n      console.log(food[v][0]);\n   });\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr = input.trim().split(\"\\n\");\nwhile (true) {\n   var n = arr.shift() - 0;\n   if (n == 0) break;\n   var nww = [];\n   for (var i = 0; i < n; i++) nww[i] = arr.shift().split(\" \");\n   nww = nww.map(v => [v[0], v[1] - 0, v[2] - 0]);\n   var max = 0;\n   var ans = [];\n   var bomb = function (arrA, arrB, sum, g) {\n      if (arrB.length == 0) {\n         if (max < g / sum) {\n            ans = arrA;\n            max = g / sum;\n         }\n         return;\n      }\n      arrB.forEach(v => {\n         if (sum <= nww[v][2]) {\n            var a = arrA.concat(v);\n            var b = arrB.slice().filter(n => v != n);\n            var c = sum + nww[v][1];\n            var d = g + nww[v][1] * (arrA.length + 1);\n            bomb(a, b, c, d);\n         }\n      });\n   };\n   var bombArr = [];\n   for (var i = 0; i < n; i++) bombArr.push(i);\n   bomb([], bombArr, 0, 0);\n   console.log(ans.map(v => nww[v][0]).reverse().join(\"\\n\"));\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function permute(permutation) {\n  var length = permutation.length,\n      result = [permutation.slice()],\n      c = new Array(length).fill(0),\n      i = 1, k, p;\n\n  while (i < length) {\n    if (c[i] < i) {\n      k = i % 2 && c[i];\n      p = permutation[i];\n      permutation[i] = permutation[k];\n      permutation[k] = p;\n      ++c[i];\n      i = 1;\n      result.push(permutation.slice());\n    } else {\n      c[i] = 0;\n      ++i;\n    }\n  }\n  return result;\n}\n\nvar allArr=[0];\nfor(var i=0;i<9;i++){\n   var arr=[];\n   for(var j=0;j<i+1;j++)arr.push(j);\n   allArr[i+1]=permute(arr);\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var nww=[];\n   for(var i=0;i<n;i++)nww[i]=arr.shift().split(\" \");\n   nww=nww.map(v=>[v[0],v[1]-0,v[2]-0]);\n   if(n==1){\n      console.log(nww[0][0]);\n      continue;\n   }\n   nww.sort(function(a,b){\n      if(a[1]==b[1])return a[2]-b[2];\n      else return a[1]-b[1];\n   });\n   var saisyo=nww.shift();\n   var all=allArr[n-1];\n   var max=0;\n   var ans=\"\";\n   for(var k=0;k<all.length;k++){\n      var v=all[k];\n      var flag=true;\n      var sum=saisyo[1];\n      var g=saisyo[2];\n      for(var j=0;j<v.length;j++){\n         var i=v[j];\n         if(sum>nww[i][2]){\n            flag=false;\n            break;\n         }\n         sum+=nww[i][1];\n         g+=nww[i][1]*(j+1);\n      }\n      if(flag && g/sum>max){\n         max=g/sum;\n         ans=v;\n      }\n   }\n   console.log(ans.map(v=>nww[v][0]).reverse().join(\"\\n\"));\n   console.log(saisyo[0]);\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr = input.trim().split(\"\\n\");\nwhile (true) {\n   var n = arr.shift() - 0;\n   if (n == 0) break;\n   var nww = [];\n   for (var i = 0; i < n; i++) nww[i] = arr.shift().split(\" \");\n   nww = nww.map(v => [v[0], v[1] - 0, v[2] - 0]);\n   nww.sort((a,b)=>{\n      return b[1]-a[1];\n   });\n   var max = 0;\n   var ans = [];\n   var bomb = function (arrA, arrB, sum, g) {\n      if (arrB.length == 0) {\n         if (max < g / sum) {\n            ans = arrA;\n            max = g / sum;\n         }\n         return;\n      }\n      for(var i=0;i<arrB.length;i++){\n         var v=arrB[i];\n         if (sum <= nww[v][2]) {\n            var a = arrA.concat(v);\n            var b = arrB.filter(n => v != n);\n            bomb(a, b, sum + nww[v][1], g + nww[v][1] * (arrA.length + 1));\n         }\n      }\n   };\n   var bombArr = [];\n   for (var i = 0; i < n; i++) bombArr.push(i);\n   bomb([], bombArr, 0, 0);\n   console.log(ans.map(v => nww[v][0]).reverse().join(\"\\n\"));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "/*参考 higuma/ArrayPermutation.js*/\nfunction zunretu(n) {\n   var saiki = function(perm, pre, post, n) {\n      if (n > 0) {\n         for (var i = 0; i < post.length; i++) {\n            var rest = post.slice(0);\n            var elem = rest.splice(i, 1);\n            saiki(perm, pre.concat(elem), rest, n - 1);\n         }\n      } else perm.push(pre);\n   };\n   var arr = [];\n   for (var i = 0; i < n; i++) arr.push(i);\n   var perm = [];\n   saiki(perm, [], arr, n);\n   return perm;\n};\n\nvar allArr=[];\nfor(var i=0;i<=10;i++)allArr[i]=zunretu(i);\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var nww=[];\n   for(var i=0;i<n;i++)nww[i]=arr.shift().split(\" \");\n   nww=nww.map(v=>[v[0],v[1]-0,v[2]-0]);\n   var all=allArr[n];\n   var max=0;\n   var ans=\"\";\n   all.forEach(v=>{\n      var flag=true;\n      var sum=0;\n      var g=0;\n      v.forEach((i,j)=>{\n         if(sum>nww[i][2])flag=false;\n         sum+=nww[i][1];\n         g+=nww[i][1]*(j+1);\n      });\n      if(flag && g/sum>max){\n         max=g/sum;\n         ans=v;\n      }\n   });\n   console.log(ans.map(v=>nww[v][0]).reverse().join(\"\\n\"));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function permute(permutation) {\n  var length = permutation.length,\n      result = [permutation.slice()],\n      c = new Array(length).fill(0),\n      i = 1, k, p;\n\n  while (i < length) {\n    if (c[i] < i) {\n      k = i % 2 && c[i];\n      p = permutation[i];\n      permutation[i] = permutation[k];\n      permutation[k] = p;\n      ++c[i];\n      i = 1;\n      result.push(permutation.slice());\n    } else {\n      c[i] = 0;\n      ++i;\n    }\n  }\n  return result;\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var nww=[];\n   for(var i=0;i<n;i++)nww[i]=arr.shift().split(\" \");\n   nww=nww.map(v=>[v[0],v[1]-0,v[2]-0]);\n   var pp=[];\n   for(var i=0;i<n;i++)pp.push(i);\n   var all=permute(pp);\n   var max=0;\n   var ans=\"\";\n   all.forEach(v=>{\n      var flag=true;\n      var sum=0;\n      var g=0;\n      v.forEach((i,j)=>{\n         if(sum>nww[i][2])flag=false;\n         sum+=nww[i][1];\n         g+=nww[i][1]*(j+1);\n      });\n      if(flag && g/sum>max){\n         max=g/sum;\n         ans=v;\n      }\n   });\n   console.log(ans.map(v=>nww[v][0]).reverse().join(\"\\n\"));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function zyunretu(n) {\n   var permArr = [];\n   var usedChars = [];\n   var permute = function(input) {\n      var i, ch;\n      for (i = 0; i < input.length; i++) {\n         ch = input.splice(i, 1)[0];\n         usedChars.push(ch);\n         if (input.length == 0) {\n            permArr.push(usedChars.slice());\n         }\n         permute(input);\n         input.splice(i, 0, ch);\n         usedChars.pop();\n      }\n      return permArr\n   };\n   var arr = [];\n   for (var i = 0; i < n; i++) arr.push(i);\n   return permute(arr);\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var nww=[];\n   for(var i=0;i<n;i++)nww[i]=arr.shift().split(\" \");\n   nww=nww.map(v=>[v[0],v[1]-0,v[2]-0]);\n   var all=zyunretu(n);\n   var max=0;\n   var ans=\"\";\n   all.forEach(v=>{\n      var flag=true;\n      var sum=0;\n      var g=0;\n      v.forEach((i,j)=>{\n         if(sum>nww[i][2])flag=false;\n         sum+=nww[i][1];\n         g+=nww[i][1]*(j+1);\n      });\n      if(flag && g/sum>max){\n         max=g/sum;\n         ans=v;\n      }\n   });\n   console.log(ans.map(v=>nww[v][0]).reverse().join(\"\\n\"));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr = input.trim().split(\"\\n\");\nwhile (true) {\n   var n = arr.shift() - 0;\n   if (n == 0) break;\n   var nww = [];\n   for (var i = 0; i < n; i++) nww[i] = arr.shift().split(\" \");\n   nww = nww.map(v => [v[0], v[1] - 0, v[2] - 0]);\n   nww.sort((a,b)=>{\n      return b[1]-a[1];\n   });\n   var max = 0;\n   var ans = \"\";\n   var bomb = function (strA, strB, sum, g) {\n      if (strB.length == 0) {\n         if (max < g ) {\n            ans = strA;\n            max = g ;\n         }\n         return;\n      }\n      for(var i=0;i<strB.length;i++){\n         var v=strB[i];\n         if (sum <= nww[v][2]) {\n            var a = strA+v;\n            var b = strB.replace(v,\"\");\n            bomb(a, b, sum + nww[v-0][1], g + nww[v-0][1] * (strA.length + 1));\n         }\n      }\n   };\n   var str = \"\";\n   for (var i = 0; i < n; i++) str+=i;\n   bomb(\"\", str, 0, 0);\n   console.log(ans.split(\"\").map(v => nww[v-0][0]).reverse().join(\"\\n\"));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var all=[];\n   var flag=[];\n   for(var i=0;i<n;i++)flag[i]=true;\n   var loop=function(ary){\n      if(ary.length==n)all.push(ary);\n      else{\n         for(var i=0;i<n;i++){\n            if(flag[i]){\n               flag[i]=false;\n               loop(ary.concat(i));\n               flag[i]=true;\n            }\n         }\n      }\n   };\n   loop([]);\n   var food=[];\n   for(var i=0;i<n;i++)food[i]=arr.shift().split(\" \");\n   var G=Infinity;\n   var min;\n   all.forEach(function(v,allIndex){\n      var sum=0;\n      var g=0;\n      var flag=v.some(function(value,i){\n         var w=food[value][1]-0;\n         var s=food[value][2]-0;\n         if(sum>s)return true;\n         sum+=w;\n         g+=w*(n-i);\n      });\n      if(flag==false){\n         g=g/sum;\n         if(G>g){\n            min=allIndex;\n            G=g;\n         }\n      }\n   });\n   all[min].reverse().forEach(function(v){\n      console.log(food[v][0]);\n   });\n}"
  },
  {
    "language": "JavaScript",
    "code": "var all=[\"\"];\nfor(var n=1;n<=9;n++){\n   all[n]=[];\n   var flag=[];\n   for(var i=0;i<n;i++)flag[i]=true;\n   var loop=function(ary){\n      if(ary.length==n)all[n].push(ary);\n      else{\n         for(var i=0;i<n;i++){\n            if(flag[i]){\n               flag[i]=false;\n               loop(ary.concat(i));\n               flag[i]=true;\n            }\n         }\n      }\n   };\n   loop([]);\n}   \nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var food=[];\n   for(var i=0;i<n;i++)food[i]=arr.shift().split(\" \");\n   var G=Infinity;\n   var min;\n   all[n].forEach(function(v,allIndex){\n      var sum=0;\n      var g=0;\n      var flag=v.some(function(value,i){\n         var w=food[value][1]-0;\n         var s=food[value][2]-0;\n         if(sum>s)return true;\n         sum+=w;\n         g+=w*(n-i);\n      });\n      if(flag==false){\n         g=g/sum;\n         if(G>g){\n            min=allIndex;\n            G=g;\n         }\n      }\n   });\n   all[n][min].reverse().forEach(function(v){\n      console.log(food[v][0]);\n   });\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr = input.trim().split(\"\\n\");\nwhile (true) {\n   var n = arr.shift() - 0;\n   if (n == 0) break;\n   var nww = [];\n   for (var i = 0; i < n; i++) nww[i] = arr.shift().split(\" \");\n   nww = nww.map(v => [v[0], v[1] - 0, v[2] - 0]);\n   nww.sort((a,b)=>{\n      return b[1]-a[1];\n   });\n   var max = 0;\n   var ans = [];\n   var bomb = function (strA, strB, sum, g) {\n      if (strB.length == 0) {\n         if (max < g / sum) {\n            ans = strA;\n            max = g / sum;\n         }\n         return;\n      }\n      for(var i=0;i<strB.length;i++){\n         var v=strB[i];\n         if (sum <= nww[v][2]) {\n            var a = strA+v;\n            var b = strB.replace(v,\"\");\n            bomb(a, b, sum + nww[v-0][1], g + nww[v-0][1] * (strA.length + 1));\n         }\n      }\n   };\n   var str = \"\";\n   for (var i = 0; i < n; i++) str+=i;\n   bomb(\"\", str, 0, 0);\n   console.log(ans.split(\"\").map(v => nww[v-0][0]).reverse().join(\"\\n\"));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var all=[\"\"];\nfor(var n=1;n<=10;n++){\n   all[n]=[];\n   var flag=[];\n   for(var i=0;i<n;i++)flag[i]=true;\n   var loop=function(str){\n      if(str.length==n)all[n].push(str);\n      else{\n         for(var i=0;i<n;i++){\n            if(flag[i]){\n               flag[i]=false;\n               loop(str+i);\n               flag[i]=true;\n            }\n         }\n      }\n   };\n   loop(\"\");\n}   \nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var food=[];\n   for(var i=0;i<n;i++)food[i]=arr.shift().split(\" \");\n   var G=Infinity;\n   var min;\n   all[n].forEach(function(v,allIndex){\n      v=v.split(\"\").map(Number);\n      var sum=0;\n      var g=0;\n      var flag=v.some(function(value,i){\n         var w=food[value][1]-0;\n         var s=food[value][2]-0;\n         if(sum>s)return true;\n         sum+=w;\n         g+=w*(n-i);\n      });\n      if(flag==false){\n         g=g/sum;\n         if(G>g){\n            min=allIndex;\n            G=g;\n         }\n      }\n   });\n   all[n][min].split(\"\").map(Number).reverse().forEach(function(v){\n      console.log(food[v][0]);\n   });\n}"
  },
  {
    "language": "JavaScript",
    "code": "var all=[\"\"];\nfor(var n=1;n<=10;n++){\n   all[n]=[];\n   var flag=[];\n   for(var i=0;i<n;i++)flag[i]=true;\n   var loop=function(ary){\n      if(ary.length==n)all[n].push(ary.join(\"\"));\n      else{\n         for(var i=0;i<n;i++){\n            if(flag[i]){\n               flag[i]=false;\n               loop(ary.concat(i));\n               flag[i]=true;\n            }\n         }\n      }\n   };\n   loop([]);\n}   \nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var food=[];\n   for(var i=0;i<n;i++)food[i]=arr.shift().split(\" \");\n   var G=Infinity;\n   var min;\n   all[n].forEach(function(v,allIndex){\n      v=v.split(\"\").map(Number);\n      var sum=0;\n      var g=0;\n      var flag=v.some(function(value,i){\n         var w=food[value][1]-0;\n         var s=food[value][2]-0;\n         if(sum>s)return true;\n         sum+=w;\n         g+=w*(n-i);\n      });\n      if(flag==false){\n         g=g/sum;\n         if(G>g){\n            min=allIndex;\n            G=g;\n         }\n      }\n   });\n   all[n][min].split(\"\").map(Number).reverse().forEach(function(v){\n      console.log(food[v][0]);\n   });\n}"
  },
  {
    "language": "JavaScript",
    "code": "function permute(permutation) {\n  var length = permutation.length,\n      result = [permutation.slice()],\n      c = new Array(length).fill(0),\n      i = 1, k, p;\n\n  while (i < length) {\n    if (c[i] < i) {\n      k = i % 2 && c[i];\n      p = permutation[i];\n      permutation[i] = permutation[k];\n      permutation[k] = p;\n      ++c[i];\n      i = 1;\n      result.push(permutation.slice());\n    } else {\n      c[i] = 0;\n      ++i;\n    }\n  }\n  return result;\n}\n\nvar allArr=[0];\nfor(var i=0;i<10;i++){\n   var arr=[];\n   for(var j=0;j<i+1;j++)arr.push(j);\n   allArr[i+1]=permute(arr);\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var nww=[];\n   for(var i=0;i<n;i++)nww[i]=arr.shift().split(\" \");\n   nww=nww.map(v=>[v[0],v[1]-0,v[2]-0]);\n   var all=allArr[n];\n   var max=0;\n   var ans=\"\";\n   all.forEach(v=>{\n      var flag=true;\n      var sum=0;\n      var g=0;\n      v.forEach((i,j)=>{\n         if(sum>nww[i][2])flag=false;\n         sum+=nww[i][1];\n         g+=nww[i][1]*(j+1);\n      });\n      if(flag && g/sum>max){\n         max=g/sum;\n         ans=v;\n      }\n   });\n   console.log(ans.map(v=>nww[v][0]).reverse().join(\"\\n\"));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var all=[\"\"];\nfor(var n=1;n<=10;n++){\n   all[n]=[];\n   var flag=[];\n   for(var i=0;i<n;i++)flag[i]=true;\n   var loop=function(ary){\n      if(ary.length==n)all[n].push(ary);\n      else{\n         for(var i=0;i<n;i++){\n            if(flag[i]){\n               flag[i]=false;\n               loop(ary.concat(i));\n               flag[i]=true;\n            }\n         }\n      }\n   };\n   loop([]);\n}  \n\nconsole.log(\"\"); "
  },
  {
    "language": "JavaScript",
    "code": "\nfunction permute(permutation) {\n  var length = permutation.length,\n      result = [permutation.slice()],\n      c = new Array(length).fill(0),\n      i = 1, k, p;\n\n  while (i < length) {\n    if (c[i] < i) {\n      k = i % 2 && c[i];\n      p = permutation[i];\n      permutation[i] = permutation[k];\n      permutation[k] = p;\n      ++c[i];\n      i = 1;\n      result.push(permutation.slice());\n    } else {\n      c[i] = 0;\n      ++i;\n    }\n  }\n  return result;\n}\n\nvar allArr=[0];\nfor(var i=0;i<9;i++){\n   var arr=[];\n   for(var j=0;j<i+1;j++)arr.push(j);\n   allArr[i+1]=permute(arr);\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var nww=[];\n   for(var i=0;i<n;i++)nww[i]=arr.shift().split(\" \");\n   nww=nww.map(v=>[v[0],v[1]-0,v[2]-0]);\n   nww.sort(function(a,b){\n      if(a[1]==b[1])return a[2]-b[2];\n      else return a[1]-b[1];\n   });\n   var saisyo=nww.shift();\n   var all=allArr[n-1];\n   var max=0;\n   var ans=\"\";\n   for(var k=0;k<all.length;k++){\n      var v=all[k];\n      var flag=true;\n      var sum=saisyo[1];\n      var g=saisyo[2];\n      for(var j=0;j<v.length;j++){\n         var i=v[j];\n         if(sum>nww[i][2]){\n            flag=false;\n            break;\n         }\n         sum+=nww[i][1];\n         g+=nww[i][1]*(j+1);\n      }\n      if(flag && g/sum>max){\n         max=g/sum;\n         ans=v;\n      }\n   }\n   console.log(ans.map(v=>nww[v][0]).reverse().join(\"\\n\")+\"\\n\"+saisyo[0]);\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr = input.trim().split(\"\\n\");\nwhile (true) {\n   var n = arr.shift() - 0;\n   if (n == 0) break;\n   var nww = [];\n   for (var i = 0; i < n; i++) nww[i] = arr.shift().split(\" \");\n   nww = nww.map(v => [v[0], v[1] - 0, v[2] - 0]);\n   nww.sort((a,b)=>{\n      return b[1]-a[1];\n   });\n   var max = 0;\n   var ans = \"\";\n   var bomb = function (str, arrB, sum, g) {\n      if (arrB.length == 0) {\n         if (max < g / sum) {\n            ans = str;\n            max = g / sum;\n         }\n         return;\n      }\n      for(var i=0;i<arrB.length;i++){\n         var v=arrB[i];\n         if (sum <= nww[v][2]) {\n            var a = str+v;\n            var b = arrB.filter(n => v != n);\n            bomb(a, b, sum + nww[v][1], g + nww[v][1] * (str.length + 1));\n         }\n      }\n   };\n   var bombArr = [];\n   for (var i = 0; i < n; i++) bombArr.push(i);\n   bomb(\"\", bombArr, 0, 0);\n   console.log(ans.split(\"\").map(v => nww[v-0][0]).reverse().join(\"\\n\"));\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function permute(permutation) {\n  var length = permutation.length,\n      result = [permutation.slice()],\n      c = new Array(length).fill(0),\n      i = 1, k, p;\n\n  while (i < length) {\n    if (c[i] < i) {\n      k = i % 2 && c[i];\n      p = permutation[i];\n      permutation[i] = permutation[k];\n      permutation[k] = p;\n      ++c[i];\n      i = 1;\n      result.push(permutation.slice());\n    } else {\n      c[i] = 0;\n      ++i;\n    }\n  }\n  return result;\n}\n\nvar allArr=[0];\nfor(var i=0;i<10;i++){\n   var arr=[];\n   for(var j=0;j<i+1;j++)arr.push(j);\n   allArr[i+1]=permute(arr);\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr= input.trim().split(\"\\n\") ;\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n}\nconsole.log(\"\");\n"
  },
  {
    "language": "JavaScript",
    "code": "var all=[\"\"];\nfor(var n=1;n<=10;n++){\n   all[n]=[];\n   var flag=[];\n   for(var i=0;i<n;i++)flag[i]=true;\n   var loop=function(ary){\n      if(ary.length==n)all[n].push(ary);\n      else{\n         for(var i=0;i<n;i++){\n            if(flag[i]){\n               flag[i]=false;\n               loop(ary.concat(i));\n               flag[i]=true;\n            }\n         }\n      }\n   };\n   loop([]);\n}   \n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var food=[];\n   for(var i=0;i<n;i++)food[i]=arr.shift().split(\" \");\n   var G=Infinity;\n   var min;\n   all[n].forEach(function(v,allIndex){\n      var sum=0;\n      var g=0;\n      var flag=v.some(function(value,i){\n         var w=food[value][1]-0;\n         var s=food[value][2]-0;\n         if(sum>s)return true;\n         sum+=w;\n         g+=w*(n-i);\n      });\n      if(flag==false){\n         g=g/sum;\n         if(G>g){\n            min=allIndex;\n            G=g;\n         }\n      }\n   });\n   all[n][min].reverse().forEach(function(v){\n      console.log(food[v][0]);\n   });\n}"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n = gets.to_i\n    break if n == 0\n    names, weights, powers = (1..n).map { gets.split }.transpose.map.with_index {|a, i| i > 0 ? a.map(&:to_i) : a}\n    weight_sum = (0..2**n-1).map {|x| (0..n-1).map {|i| x[i] == 1 ? weights[i] : 0}.inject(:+)}\n\n    g = Array.new(2**n, Float::INFINITY)\n    g[0] = 0.0\n    min_by = Array.new(2**n)\n    min_by[0] = []\n\n    (1..2**n-1).each do |x|\n        (0..n-1).each do |i|\n            if x[i] == 1\n                y = x - (1 << i)\n                next unless g[y]\n                w = weight_sum[y]\n                next if powers[i] < w\n                m = w * (g[y] + 1.0) / (weights[i] + w)\n                if m < g[x]\n                    g[x] = m\n                    min_by[x] = [i] + min_by[y]\n                end\n            end\n        end\n    end\n    puts min_by[-1].map {|i| names[i]}\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "until (n = $<.gets.to_i).zero?\n  data = n.times.map {$<.gets.split}.map {|a, *b| [a] + b.map(&:to_i)}\n  selected = []\n  all = [*0...n]\n  solve = ->(left, order) {\n    return if data[order.last][2] < (all - order).map {|i| data[i][1]}.sum\n    if left.empty?\n      selected << order\n    else\n      left.each {|i| solve.(left - [i], order + [i])}\n    end\n  }\n  all.each {|i| solve.(all - [i], [i])}\n  result = selected.sort_by do |order|\n    w = order.map {|i| data[i][1]}\n    [*1..order.size].zip(w).map {|a, b| a * b}.sum / w.sum.to_f\n  end.first\n  puts result.map {|i| data[i][0]}\nend\n"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 31 - 1\n\n### global variables\n\n$g_cache = []\n\n### subroutines\n\ndef check_grv(bits, wsum, fs)\n  return $g_cache[bits] if ! $g_cache[bits].nil?\n  return ($g_cache[bits] = [0, []]) if bits == 0\n\n  n = fs.length\n\n  min_gw = MAX_INT\n  min_ids = []\n\n  for i in (0...n)\n    b = 1 << i\n    if (bits & b) != 0\n      fi, wi, si = fs[i]\n      if si >= wsum - wi\n        gw0, ids0 = check_grv(bits & ~b, wsum - wi, fs)\n        gw = gw0 + wsum\n\n        if min_gw > gw\n          min_gw = gw\n          min_ids = [i] + ids0\n        end\n      end\n    end\n  end\n\n  $g_cache[bits] = [min_gw, min_ids]\nend\n\n### main\n\nwhile true\n  n = gets.strip.to_i\n  break if n == 0\n\n  fs = []\n  n.times.each do\n    fi, wi, si = gets.strip.split(' ')\n    fs << [fi, wi.to_i, si.to_i]\n  end\n\n  $g_cache = []\n\n  wsum = fs.inject(0){|s, f| s + f[1]}\n\n  gw, ids = check_grv((1 << n) - 1, wsum, fs)\n  #p ids\n  #p (gw.to_f / w)\n\n  ids.each do |i|\n    puts fs[i][0]\n    #p fs[i]\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def g l,x;l[0]?($h[l.sort]||=l.map{(f,w,s),*a=l.rotate!;s<x-w ?[0,1e9]:(a,b=g(a,x-w);[[f]+a,b+x])}.min_by{|i,j|j}):[[],0]end\nwhile(n=gets.to_i)>x=0\nl=(1..n).map{f,w,s=gets.split;x+=w=w.to_i;[f,w,s.to_i]}\n$h={}\nputs g(l,x)[0]end"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"fmt\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\nvar f = make([]string, 10)\nvar s, w = make([]int, 10), make([]int, 10)\nvar n int\nfunc main() {\n\tfor scanner.Scan() {\n\t\tn, _ = strconv.Atoi(scanner.Text())\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t\tfor i := 0; i < n; i++ {\n\t\t\tscanner.Scan()\n\t\t\tbuf := strings.Split(scanner.Text(), \" \")\n\t\t\ttmpf :=buf[0]\n\t\t\ttmpw, _ := strconv.Atoi(buf[1])\n\t\t\ttmps, _ := strconv.Atoi(buf[2])\n\t\t\tf[i] = tmpf\n\t\t\ts[i] = tmps\n\t\t\tw[i] = tmpw\n\t\t}\n\t\tsort()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tfor j := 0; j < n-1; j++ {\n\t\t\t\tif w[j]<w[j+1] {\n\t\t\t\t\tswap(j)\n\t\t\t\t\ta := get_weight(j+1)\n\t\t\t\t\tif a>s[j] {\n\t\t\t\t\t\tswap(j)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor i := 0; i < n; i++ {\n\t\t\tfmt.Println(f[i])\n\t\t}\n\t}\n}\n\nfunc sort() {\n\tfor i := n-1; i > 0; i-- {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tif s[j]<s[j+1] {\n\t\t\t\tswap(j)\n\t\t\t} else if s[j]==s[j+1]&&w[j]<w[j+1] {\n\t\t\t\tswap(j)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc swap(x int) {\n\tw[x], w[x+1] = w[x+1], w[x]\n\ts[x], s[x+1] = s[x+1], s[x]\n\tf[x], f[x+1] = f[x+1], f[x]\n}\n\nfunc get_weight(x int) int {\n\tret := 0\n\tfor i := x; i < n; i++ {\n\t\tret += w[i]\n\t}\n\treturn ret\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\n\nvoid main(){\n    while(true) {\n        auto n = readInt();\n        if(n == 0) {\n            return;\n        }\n        string[] f;\n        int[] w, s;\n        foreach(i; iota(n)) {\n            auto l = readln().chomp().split(\" \");\n            f ~= l[0];\n            w ~= l[1].to!int;\n            s ~= l[2].to!int;\n        }\n\n        auto ans = new int[](n);\n        auto cMin = int.max;\n        void calc(int k, int[] l) {\n            if(k < n) {\n                foreach(i; iota(k, n)) {\n                    swap(l[k], l[i]);\n                    calc(k+1, l);\n                    swap(l[k], l[i]);\n                }\n            } else {\n                int sf;\n                foreach_reverse(i; iota(n)) {\n                    if(s[l[i]] < sf) {\n                        return;\n                    }\n                    sf += w[l[i]];\n                }\n                auto g = zip(iota(1, n+1), l).map!(a => a[0] * w[a[1]]).sum;\n                if(g < cMin) {\n                    cMin = g;\n                    ans[] = l[];\n                }\n            }\n        }\n        calc(0, iota(n).array);\n        ans.map!(a => f[a]).each!writeln();\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\n\nvoid main(){\n    while(true) {\n        auto n = readInt();\n        if(n == 0) {\n            return;\n        }\n        string[] f;\n        int[] w, s;\n        foreach(i; iota(n)) {\n            auto l = readln().chomp().split(\" \");\n            f ~= l[0];\n            w ~= l[1].to!int;\n            s ~= l[2].to!int;\n        }\n\n        auto ans = new int[](n);\n        auto cMin = int.max;\n        void calc(int k, int[] l) {\n            if(k < n) {\n                foreach(i; iota(k, n)) {\n                    swap(l[k], l[i]);\n                    calc(k+1, l);\n                    swap(l[k], l[i]);\n                }\n            } else {\n                int sf;\n                foreach_reverse(i; iota(n)) {\n                    if(s[l[i]] < sf) {\n                        return;\n                    }\n                    sf += w[l[i]];\n                }\n                auto g = zip(iota(1, n+1), l).map!(a => a[0] * w[a[1]]).sum;\n                if(g < cMin) {\n                    cMin = g;\n                    ans[] = l[];\n                }\n            }\n        }\n        calc(0, iota(n).array);\n        ans.each!(a => writeln(f[a]));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\n\nvoid main(){\n    while(true) {\n        auto n = readInt();\n        if(n == 0) {\n            return;\n        }\n        string[] f;\n        int[] w, s;\n        foreach(i; iota(n)) {\n            auto l = readln().chomp().split(\" \");\n            f ~= l[0];\n            w ~= l[1].to!int;\n            s ~= l[2].to!int;\n        }\n\n        zip(w, s, f).sort;\n        auto sf = w.sum;\n        int ans[];\n        while(ans.length < n) {\n            foreach_reverse(j; iota(n)) {\n                if(ans.canFind(j)) {\n                    continue;\n                }\n\n                if(sf - w[j] <= s[j]) {\n                    ans ~= j;\n                    sf -= w[j];\n                    break;\n                }\n            }\n        }\n        ans.each!(a => writeln(f[a]));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\n\nstruct Food {\n\tstring f;\n\tint w, s;\n\tbool used;\n\tint opCmp(ref const Food f) const{\n\t\treturn f.w > w;\n\t}\n}\n\nFood[10] f;\n\nvoid main(){\n\tint n, sum;\n\twhile (readf(\"%d\\n\", &n), n) {\n\t\tsum = 0;\n\t\tforeach (i; 0..n) {\n\t\t\treadf(\"%s %d %d\\n\", &f[i].f, &f[i].w, &f[i].s);\n\t\t\tf[i].used = false;\n\t\t\tsum += f[i].w;\n\t\t}\n\t\tf[0..n].sort;\n\t\tforeach (j; 0..n) {\n\t\t\tforeach (i; 0..n) {\n\t\t\t\tif (f[i].s >= sum - f[i].w && !f[i].used) {\n\t\t\t\t\twriteln(f[i].f);\n\t\t\t\t\tsum -= f[i].w;\n\t\t\t\t\tf[i].used = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "D",
    "code": "\nimport std.stdio, std.typecons, std.algorithm, std.conv;\n\nalias Tuple!(int, \"weight\", int, \"limit\", string, \"name\") Food;\n\nint[] ans;\ndouble value;\n\ndouble center_grav(Food[] foods, int[] arr) {\n  int v, sum;\n  for(int i = 0; i < arr.length; i++) {\n    v += i * foods[arr[i]].weight;\n    sum += foods[arr[i]].weight;\n  }\n  return v.to!double / sum.to!double;\n}\n\nvoid solve(Food[] foods, int mask, int sum, int[] order) {\n  if (mask == 0) {\n    double res = center_grav(foods, order.dup);\n    if (res < value) {\n      value = res;\n      ans = order;\n    }\n  }\n  for(int i = 0; i < foods.length; i++) {\n    if (((mask >> i) & 1) == 1) {\n      if (foods[i].limit < (sum - foods[i].weight)) continue;\n      solve(foods, mask & ~(1 << i), sum - foods[i].weight, order ~ [i]);\n    }\n  }\n}\n\nvoid main() {\n  for(int times; readf(\"%d\\n\", &times), times != 0;) {\n    Food[] foods;\n    for(int t = 0; t < times; t++) {\n      string name;\n      int weight, limit;\n      readf(\"%s %d %d\\n\", &name, &weight, &limit);\n      foods ~= Food(weight, limit, name);\n    }\n    int[] res;\n    int mask = 0;\n    foreach(int i, f; foods) mask |= (1 << i);\n    ans = [];\n    value = double.max;\n    int sum = reduce!((accum, x) => accum + x.weight)(0, foods);\n    solve(foods, mask, sum, res);\n    foreach(i; ans) {\n      writeln(foods[i].name);\n    }\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\n\nint[10] w, s;\nstring[10] f;\nint n, sum;\nint[] ans;\ndouble best;\n\nvoid main(){\n\twhile (readf(\"%d\\n\", &n), n) {\n\t\tsum = 0;\n\t\tbest = double.max;\n\t\tforeach (i; 0..n) {\n\t\t\treadf(\"%s %d %d\\n\", &f[i], &w[i], &s[i]);\n\t\t\tsum += w[i];\n\t\t}\n\t\tsolve(0, [], 0, sum, 1);\n\t\tforeach (i; ans) writeln(f[i]);\n\t}\n}\n\nvoid solve(int b, int[] order, double g, int weight, int pos){\n\tforeach (i; 0..n) {\n\t\tif (!((1<<i) & b) && s[i] >= weight-w[i]) {\n\t\t\tsolve(b | (1<<i), order ~ i, g+w[i]*pos, weight-w[i], pos+1); \n\t\t}\n\t}\n\tif (b+1 == (1<<n) && best > g/sum) {\n\t\tbest = g/sum;\n\t\tans = order;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\n\nvoid main(){\n    while(true) {\n        auto n = readInt();\n        if(n == 0) {\n            return;\n        }\n        string[] f;\n        int[] w, s;\n        foreach(i; iota(n)) {\n            auto l = readln().chomp().split(\" \");\n            f ~= l[0];\n            w ~= l[1].to!int;\n            s ~= l[2].to!int;\n        }\n        Tuple!(int, int[]) calc(int n, int k, int[] l, bool[] used) {\n            if(k < n) {\n                auto ret = tuple(int.max, new int[](0));\n                foreach(i; iota(n)) {\n                    if(!used[i]) {\n                        used[i] = true;\n                        auto tmp = calc(n, k+1, l ~ i, used);\n                        ret = min(ret, tmp);\n                        used[i] = false;\n                    }\n                }\n                return ret;\n            } else {\n                int sf;\n                foreach_reverse(i; iota(n)) {\n                    if(s[l[i]] < sf) {\n                        return tuple(int.max, new int[](0));\n                    }\n                    sf += w[l[i]];\n                }\n                return tuple(zip(iota(1, n+1), l).map!(a => a[0] * w[a[1]]).sum, l);\n            }\n        }\n        auto ans = calc(n, 0, new int[](0), new bool[](n))[1];\n        ans.map!(a => f[a]).each!writeln();\n    }\n}"
  },
  {
    "language": "Python",
    "code": "from collections import namedtuple\n\nData = namedtuple(\"Data\", \"name weight limit\")\n\n\ndef search(food_list, select_list, total_weight):\n    if len(food_list) == 0:\n        return select_list\n\n    limit = select_list[len(select_list) - 1].limit\n\n    for lp, food in enumerate(food_list):\n\n        if total_weight <= limit:\n\n            select_list.append(food)\n            food_list.remove(food)\n            total_weight -= food.weight\n\n            search(food_list, select_list, total_weight)\n\n            if len(food_list) == 0:\n                return select_list\n            else:\n                select_list.pop()\n                food_list.insert(lp, food)\n                total_weight += food.weight\n\n    return None\n\n\nwhile True:\n    input_count = int(input())\n\n    if input_count == 0:\n        break\n\n    input_data = [input().split(\" \") for _ in range(input_count)]\n    input_data = [Data(item[0], int(item[1]), int(item[2])) for item in input_data]\n\n    input_data.sort(key=lambda x: (x.weight, x.limit), reverse=True)\n\n    total_weight = sum([item.weight for item in input_data])\n\n    result = search(input_data, [Data(\"sentinel\", 0, 999999)], total_weight)\n    del result[0]\n\n    output = [item.name for item in result]\n    print(\"\\n\".join(output))\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = []\n    for i in range(n):\n        f, w, s = raw_input().split()\n        L.append([f, int(w), int(s)])\n    else:\n        L = sorted(L, key=lambda x: x[1], reverse=True)\n    \n    ans = []\n    while len(L) != 1:\n        for i in range(len(L)):\n            _L = copy.deepcopy(L)\n            f = _L[i][0]\n            s = _L[i][2]\n            del _L[i]\n            t = sum([_L[o][1] for o in range(len(_L))])\n            if t <= s:\n                ans.append(f)\n                del L[i]\n                break\n    else:\n        ans.append(L[0][0])\n        for f in ans:\n            print f"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0170\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom collections import namedtuple\nfrom itertools import permutations\n\n\ndef solve(items):\n    total_weight = 0\n    for i in items:\n        total_weight += i.w\n\n    best_ans = []\n    best_gp = float('inf')\n    # ???????????????????????????????????????????????°?????????????????§????????????\n    for perm in permutations(items):\n        ans = []\n        squashed = False\n        cw = 0\n        gp = 0\n        n = len(items)\n\n        for p in perm:\n            if p.s < cw:\n                squashed = True\n                break\n            cw += p.w\n            ans.append(p.name)\n            gp += n * p.w\n            n -= 1\n        # ????????°???????????£?????´????????????????¨???????????????????????????????????????£?????????????????§????????????\n        if not squashed:\n            gp /= total_weight\n            if gp < best_gp:\n                best_gp = gp\n                best_ans = ans[:]\n    # ????????????????????????????????£??????????????§?????????????±?????????????????????????????????????????????????\n    best_ans.reverse()\n    return best_ans\n\n\nitem = namedtuple('item', ['name', 'w', 's'])\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        items = []\n        for _ in range(n):\n            name, w, s = input().split()\n            items.append(item(name, int(w), int(s)))\n\n        result = solve(items)\n        print('\\n'.join(result))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "import copy\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = []\n    for i in range(n):\n        f, w, s = raw_input().split()\n        L.append([f, int(w), int(s)])\n    else:\n        L = sorted(L, key=lambda x: int(x[1]), reverse=True)\n    \n    ans = []\n    while len(L) != 1:\n        for i in range(len(L)):\n            _L = copy.deepcopy(L)\n            f = _L[i][0]\n            s = _L[i][2]\n            del _L[i]\n            t = sum([_L[o][1] for o in range(len(_L))])\n            if t <= s:\n                ans.append(f)\n                del L[i]\n                break\n    else:\n        ans.append(L[0][0])\n        for line in ans:\n            print line"
  },
  {
    "language": "Python",
    "code": "def solve(placed, w1, w2):\n  global weight, D\n  n = len(N) - len(placed)\n  x = list(set(N) - set(placed))\n  if x == []:\n    if weight > w1:\n      D = placed\n      weight = w1\n    return\n   \n  for e in x:\n    w = W[e]\n    if w2 > S[e]: return\n    a = w1 + w * n\n    if a > weight: return\n    b = w2 + w\n    solve(placed+[e], a, b)\n  return\n \nwhile 1:\n  n = input()\n  if n==0: break\n  D = []\n  weight = 1e9\n  N = range(n)\n  f = lambda x: [int(x[1]),int(x[2]),x[0]]\n  x = [f(raw_input().split()) for _ in [0]*n]\n  W, S, Name = zip(*sorted(x))\n  solve([], 0, 0)\n  for e in D[::-1]:\n    print Name[e]"
  },
  {
    "language": "Python",
    "code": "def solve(placed, w1, w2):\n  global ans\n  n = len(N) - len(placed)\n  if n==0:\n    ans = min(ans, [w1, placed])\n    return\n\n  for e in N:\n    if e in placed: continue\n    w, lim, s = Food[e]\n    if w2 > lim: return\n    a = w1 + w * n\n    if a > ans[0]: return\n    solve(placed+[e], a, w2 + w)\n  return\n \nwhile 1:\n  n = input()\n  if n==0: break\n  ans = [1e9, []]\n  N = range(n)\n  f = lambda x: map(int, x[1:3]) + [x[0]]\n  Food = [f(raw_input().split()) for _ in [0]*n]\n  solve([], 0, 0)\n  for e in ans[1][::-1]:\n    print Food[e][2]"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef isOK(array):\n\tfor i in range(n-1):\n\t\tif int(array[i][2])<sum([int(array[i][1]) for x in range(i+1,n)]):\n\t\t\treturn False\n\treturn G(array)\n\ndef G(array):\n\tnume=sum([(i+1)*int(array[i][1]) for i in range(n)])*1.0\n\tdenomi=sum([int(array[i][1]) for i in range(n)])\n\treturn nume/denomi\n\t\nwhile 1:\n\tn=input()\n\tif n==0:break\n\tlunch=[raw_input().split() for i in range(n)]\n\tans,minG=[],10000\n\tfor order in itertools.permutations(lunch,n):\n\t\tprint order\n\t\tval=isOK(order)\n\t\tif val is not False and val<minG:\n\t\t\tans=[order[i][:] for i in range(n)]\n\t\t\tminG=val\n\tfor i in range(n):\n\t\tprint ans[i][0]"
  },
  {
    "language": "Python",
    "code": "def solve(placed, w1, w2):\n  n = len(N) - len(placed)\n  x = list(set(N) - set(placed))\n  if x == []:\n    a = tuple(placed)\n    D1[a] = w1\n    D2[a] = w2\n    return 1\n  \n  for e in x:\n    w = Food[e]\n    if w2 > Lim[e]: return 0\n    a = w1 + w * n\n    b = w2 + w\n    f = solve(placed+[e], a, b)\n    if f: return 1\n  return 0\n\nwhile 1:\n  n = input()\n  if n==0: break\n  D1 = {}\n  D2 = {}\n  N = range(n)\n  x = []\n  for i in N:\n    a = raw_input().split()\n    x.append(map(int, a[1:])+[a[0]])\n  x = zip(*sorted(x))\n  Name = list(x[2])\n  Food = list(x[0])\n  Lim = list(x[1])\n  solve([], 0, 0)\n  \n  Index, e = sorted(D1.items(), key = lambda x: x[1])[0]\n  for e in list(Index)[::-1]:\n    print Name[e]"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0170\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom collections import namedtuple\n\n\ndef solve(items):\n    from itertools import permutations\n    total_weight = 0\n    for i in items:\n        total_weight += i.w\n    best_ans = []\n    best_gp = float('inf')\n    # ???????????????????????????????????????????????°?????????????????§????????????\n    for perm in permutations(items):\n        ans = []\n        squashed = False\n        cw = 0\n        gp = 0\n        n = len(items)\n        for p in perm:\n            if p.s < cw:\n                squashed = True\n                break\n            cw += p.w\n            ans.append(p.name)\n            gp += n * p.w\n            n -= 1\n        # ????????°???????????£?????´????????????????¨???????????????????????????????????????£?????????????????§????????????\n        if not squashed:\n            gp /= total_weight\n            if gp < best_gp:\n                best_gp = gp\n                best_ans = ans[:]\n    # ????????????????????????????????£??????????????§?????????????±?????????????????????????????????????????????????\n    best_ans.reverse()\n    return best_ans\n\n\ndef solve2(items):\n    items.sort(key=lambda x:x.w, reverse=True) # ??????????????????????????????\n    total_weight = 0            #  ??¢?????????????????????\n    for i in items:\n        total_weight += i.w\n    ans = []\n    # ?????£???????????¢??????????????????????????????????????????????????§???????????¢??????????????????????????????????????????????????????????????????????????¢?????????????????????????????§??°????????????\n    while items:\n        cap = [x.s - total_weight + x.w for x in items] #  ????????\\??????????????¢?????????????????????????????¨????????°??????????????????????????????????????????????????????0??\\?????????OK\n        for i in range(len(items)):\n            if cap[i] >= 0:     #  ??°???????????????????????????????????????????????????????????????????????????\n                ans.append(items[i].name)\n                i = items.pop(i)\n                total_weight -= i.w #  ???????????¢?????????????????????????????????\n                break\n    return ans\n\n\nitem = namedtuple('item', ['name', 'w', 's'])\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        items = []\n        for _ in range(n):\n            name, w, s = input().split()\n            items.append(item(name, int(w), int(s)))\n        result = solve2(items)\n        print('\\n'.join(result))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def solve(placed, w1, w2):\n  global weight, D\n  n = len(N) - len(placed)\n  x = list(set(N) - set(placed))\n  if x == []:\n    if weight > w1:\n      D = placed\n      weight = w1\n    return\n   \n  for e in x:\n    w = Food[0][e]\n    if w2 > Food[1][e]: return\n    a = w1 + w * n\n    if a > weight: return\n    b = w2 + w\n    solve(placed+[e], a, b)\n  return\n \nwhile 1:\n  n = input()\n  if n==0: break\n  Food = {}\n  weight = 1e9\n  N = range(n)\n  x = []\n  for i in N:\n    a = raw_input().split()\n    x.append(map(int, a[1:])+[a[0]])\n  Food = zip(*sorted(x))\n  solve([], 0, 0)\n  for e in D[::-1]:\n    print Food[2][e]"
  },
  {
    "language": "Python",
    "code": "def solve(G1, G2, w1, w2):\n  global ans\n  n = len(G2)\n  for e in G2:\n    w, lim, s = Food[e]\n    if w2 > lim:\n      return\n    a = w1 + w * n\n    if a > ans[0]:\n      return\n    if n==1:\n      ans = min(ans, [w1, G1+[e]])\n    else:\n      x = G2[:]\n      x.remove(e)\n      solve(G1+[e], x, a, w2 + w)\n  return\n \nwhile 1:\n  n = input()\n  if n == 0: break\n  ans = [1e9, []]\n  N = range(n)\n  f = lambda x: map(int, x[1:3]) + [x[0]]\n  Food = [f(raw_input().split()) for _ in [0] * n]\n  solve([], N, 0, 0)\n  for e in ans[1][::-1]:\n    print Food[e][2]"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    F = [0]*n\n    W = [0]*n\n    S = [0]*n\n\n    def dfs(c, state, used, su):\n        if c == n:\n            return [sum((1+i)*W[state[n-1-i]] for i in xrange(n)), state[::-1]]\n        mi = [10**9, None]\n        for i in xrange(n):\n            if not used[i] and S[i] >= su:\n                state[c] = i\n                used[i] = 1\n                mi = min(mi, dfs(c+1, state, used, su + W[i]))\n                used[i] = 0\n        return mi\n\n    for i in xrange(n):\n        F[i], w, s = raw_input().split()\n        W[i] = int(w)\n        S[i] = int(s)\n    for i in dfs(0, [0]*n, [0]*n, 0)[1]:\n        print F[i]"
  },
  {
    "language": "Python",
    "code": "def stuck(array):\n\torder=[]\n\twhile array:\n\t\tr = len(array)\n\t\tw = sum([array[i][1] for i in range(r)])\n\t\tmx = 0\n\t\tfor i in range(r):\n\t\t\tif array[i][2] >= w-array[i][1] and array[i][1] > mx:\n\t\t\t\tmx = array[i][1]\n\t\t\t\tid = i\n\t\torder.append(array.pop(id)[0])\n\treturn order\n\ndef change(a):\n\treturn a[0],int(a[1]),int(a[2])\n\t\nwhile 1:\n\tn = input()\n\tif n == 0:break\n\tlunch = [change(raw_input().split()) for i in range(n)]\n\tans = stuck(lunch)\n\tfor i in range(n):\n\t\tprint ans[i]"
  },
  {
    "language": "Python",
    "code": "def solve(placed, w1, w2):\n  global weight, D\n  n = len(N) - len(placed)\n  x = list(set(N) - set(placed))\n  if x == []:\n    if weight > w1:\n      D = placed\n      weight = w1\n    return\n   \n  for e in x:\n    w = W[e]\n    if w2 > S[e]: return\n    a = w1 + w * n\n    if a > weight: return 1\n    b = w2 + w\n    if solve(placed+[e], a, b): return 1\n  return\n \nwhile 1:\n  n = input()\n  if n==0: break\n  D = []\n  weight = 1e9\n  N = range(n)\n  f = lambda x: [int(x[1]),int(x[2]),x[0]]\n  x = [f(raw_input().split()) for _ in [0]*n]\n  W, S, Name = zip(*sorted(x))\n  solve([], 0, 0)\n  for e in D[::-1]:\n    print Name[e]"
  },
  {
    "language": "Python",
    "code": "a=list(map(int, input().split()))\nx=[\"A\",\"B\",\"C\"]\nprint(x[a.index(max(a))])\n"
  },
  {
    "language": "Python",
    "code": "def solve(placed, w1, w2):\n  n = len(N) - len(placed)\n  x = list(set(N) - set(placed))\n  if x == []:\n    a = tuple(placed)\n    D1[a] = w1\n    D2[a] = w2\n    return\n  \n  for e in x:\n    w = Food[e][0]\n    if w2 > Food[e][1]: return\n    a = w1 + w * n\n    b = w2 + w\n    solve(placed+[e], a, b)\n  return\n\nwhile 1:\n  n = input()\n  if n==0: break\n  D1 = {}\n  D2 = {}\n  Name = {}\n  Food = {}\n  N = range(n)\n  for i in N:\n    a = raw_input().split()\n    Food[i] = map(int, a[1:])\n    Name[i] = a[0]\n    \n  solve([], 0, 0)\n  \n  Index, e = sorted(D1.items(), key = lambda x: x[1])[0]\n  for e in list(Index)[::-1]:\n    print Name[e]"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 20\nwhile True:\n  n = int(input())\n  if n == 0:\n    break\n  names = []\n  weights = []\n  safes = []\n  for _ in range(n):\n    f, w, s = input().split()\n    names.append(f)\n    weights.append(int(w))\n    safes.append(int(s))\n  all_weight = sum(weights)\n  dic = [None] * (2 ** n)\n  \n  def score(rest, total_weight, count):\n    if dic[rest] != None:\n      return dic[rest]\n    if rest == 0:\n      return (0, [])\n\n    ret = (INF, [])\n    mask = 1\n    for i in range(n):\n      if rest & mask:\n        if safes[i] >= all_weight - total_weight - weights[i]:\n          temp = score(rest & ~mask, total_weight + weights[i], count + 1) \n          ret = min(ret, (temp[0] + weights[i] * (count + 1), [names[i]] + temp[1]))\n      mask <<= 1\n    dic[rest] = ret\n    return ret\n\n  print(*score(2 ** n - 1, 0, 0)[1], sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nfrom copy import deepcopy\n\ndef stuck(array):\n\torder=[]\n\twhile array:\n\t\tr = len(array)\n\t\tw = sum([array[i][1] for i in range(r)])\n\t\tmx = 0\n\t\tfor i in range(r):\n\t\t\tif array[i][2] >= w-array[i][1] and array[i][2] > mx:\n\t\t\t\tmx = array[i][2]\n\t\t\t\tid=i\n\t\torder.append(array.pop(id)[0])\n\treturn order\n\ndef change(a):\n\treturn a[0],int(a[1]),int(a[2])\n\t\nwhile 1:\n\tn=input()\n\tif n==0:break\n\tlunch=[change(raw_input().split()) for i in range(n)]\n\tans=stuck(lunch)\n\tfor i in range(n):\n\t\tprint ans[i]"
  },
  {
    "language": "Python",
    "code": "import itertools\nfrom copy import deepcopy\n\ndef stuck(Array,Order):\n\tremain = len(Array)\n\tif remain == 0: return G(Order),Order\n\tminG,minOrder = 9999999,[]\n\tw = sum([int(Array[i][1]) for i in range(remain)])\n\tfor i in range(remain):\n\t\tif int(Array[i][2]) >= w-int(Array[i][1]):\n\t\t\tarray = deepcopy(Array)\n\t\t\torder = deepcopy(Order)\n\t\t\torder[n-remain] = array.pop(i)\n\t\t\tcurG,curOrder = stuck(array,order)\n\t\t\tif curG < minG:\n\t\t\t\tminG = curG\n\t\t\t\tminOrder = curOrder\n\treturn minG,minOrder\n\ndef G(array):\n\tnume=sum([(i+1)*int(array[i][1]) for i in range(n)])*1.0\n\tdenomi=sum([int(array[i][1]) for i in range(n)])\n\treturn nume/denomi\n\t\nwhile 1:\n\tn=input()\n\tif n==0:break\n\tlunch=[raw_input().split() for i in range(n)]\n\tminG,ans=stuck(lunch,[0]*n)\n\tfor i in range(n):\n\t\tprint ans[i][0]"
  },
  {
    "language": "Python",
    "code": "def solve(G1, G2, w1, w2):\n  global ans\n  n = len(G2)\n  for e in G2:\n    w, lim, s = Food[e]\n    a = w1 + w * n\n    if w2 > lim or a > ans[0]: return\n    b = G1 + [e]\n    if n == 1:\n      ans = min(ans, [a, b])\n    else:\n      x = G2[:]\n      x.remove(e)\n      solve(b, x, a, w2 + w)\n  return\n \nwhile 1:\n  n = input()\n  if n==0: break\n  ans = [1e9, []]\n  N = range(n)\n  f = lambda x: map(int, x[1:3]) + [x[0]]\n  Food = [f(raw_input().split()) for _ in [0]*n]\n  solve([], N, 0, 0)\n  for e in ans[1][::-1]:\n    print Food[e][2]"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0170\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom collections import namedtuple\nfrom itertools import permutations\n\n\ndef solve(items):\n    total_weight = 0\n    for i in items:\n        total_weight += i.w\n    best_ans = []\n    best_gp = float('inf')\n    # ???????????????????????????????????????????????°?????????????????§????????????\n    for perm in permutations(items):\n        ans = []\n        squashed = False\n        cw = 0\n        gp = 0\n        n = len(items)\n        for p in perm:\n            if p.s < cw:\n                squashed = True\n                break\n            cw += p.w\n            ans.append(p.name)\n            gp += n * p.w\n            n -= 1\n        # ????????°???????????£?????´????????????????¨???????????????????????????????????????£?????????????????§????????????\n        if not squashed:\n            gp /= total_weight\n            if gp < best_gp:\n                best_gp = gp\n                best_ans = ans[:]\n    # ????????????????????????????????£??????????????§?????????????±?????????????????????????????????????????????????\n    best_ans.reverse()\n    return best_ans\n\n\ndef solve2(items):\n    items.sort(key=lambda x:x.w, reverse=True)\n    ans = []\n    while items:\n        total_weight = 0\n        for i in items:\n            total_weight += i.w\n        cap = [x.s - total_weight + x.w for x in items]\n        for i in range(len(items)):\n            if cap[i] >= 0:\n                ans.append(items[i].name)\n                items.pop(i)\n                break\n    return ans\n\n\n\nitem = namedtuple('item', ['name', 'w', 's'])\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        items = []\n        for _ in range(n):\n            name, w, s = input().split()\n            items.append(item(name, int(w), int(s)))\n        result = solve2(items)\n        print('\\n'.join(result))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Rust",
    "code": "fn main(){\n  loop {\n    let n: usize = read();\n    if n == 0 { break; }\n\n    let mut fd: Vec<(String, usize, usize)> = Vec::new();\n\n    for _ in 0 .. n {\n      let buf: Vec<String> = read_vec();\n      fd.push((buf[0].parse().unwrap(), buf[1].parse().unwrap(), buf[2].parse().unwrap()));\n    }\n\n    let mut iv: Vec<usize> = (0..n).collect();\n\n    let mut miv: Vec<usize> = vec![0;n];\n    let mut mcg: usize = 100000;\n\n    if let Some(cg) = calc_cg(&fd, &iv) {\n      if mcg > cg {\n        mcg = cg;\n        miv = iv.clone();\n      }\n    }\n    \n    while next_permutation(&mut iv) {\n      if let Some(cg) = calc_cg(&fd, &iv) {\n        if mcg > cg {\n          mcg = cg;\n          miv = iv.clone();\n        }\n      }\n    }\n\n    for i in miv {\n      println!(\"{}\", fd[i].0);\n    }\n  }\n}\n\nfn read<T>() -> T\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.trim().parse().unwrap()\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\nfn next_permutation(v: &mut Vec<usize>) -> bool {\n  let ln = v.len();\n  let mut u: usize = ln;\n  for i in (0 .. ln-1).rev() {\n    if v[i] < v[i+1] { u = i; break;}\n  }\n  if u == ln { false }\n  else {\n    let mut w: usize = u + 1;\n    for i in (u+1 .. ln).rev() {\n      if v[i] > v[u] { w = i; break; }\n    }\n    v.swap(u, w);\n    u += 1;\n    w = ln - 1;\n    while u < w {\n      v.swap(u, w);\n      u += 1;\n      w -= 1;\n    }\n    true\n  }\n}\n\nfn calc_cg(fd: &Vec<(String, usize, usize)>, iv: &Vec<usize>) -> Option<usize> {\n  let mut cg: Option<usize> = Some(0);\n  let mut aw: usize = 0;\n  \n  for (i, &j) in iv.iter().enumerate().rev() {\n    if fd[j].2 >= aw {\n      aw += fd[j].1;\n      cg = Some (cg.unwrap() + (i + 1) * fd[j].1);\n    } else {\n      cg = None;\n      break;\n    }\n  }\n  \n  cg\n}\n\n"
  }
]