[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int colors[6];\n} Cube;\n\nvoid rotateX(Cube *cube) {\n    int temp = cube->colors[1];\n    cube->colors[1] = cube->colors[5];\n    cube->colors[5] = cube->colors[3];\n    cube->colors[3] = cube->colors[4];\n    cube->colors[4] = temp;\n}\n\nvoid rotateY(Cube *cube) {\n    int temp = cube->colors[0];\n    cube->colors[0] = cube->colors[4];\n    cube->colors[4] = cube->colors[2];\n    cube->colors[2] = cube->colors[5];\n    cube->colors[5] = temp;\n}\n\nvoid rotateZ(Cube *cube) {\n    int temp = cube->colors[0];\n    cube->colors[0] = cube->colors[1];\n    cube->colors[1] = cube->colors[2];\n    cube->colors[2] = cube->colors[3];\n    cube->colors[3] = temp;\n}\n\nvoid normalize(Cube *cube) {\n    Cube min = *cube;\n    Cube temp;\n\n    for (int x = 0; x < 4; x++) {\n        for (int y = 0; y < 4; y++) {\n            for (int z = 0; z < 4; z++) {\n                temp = *cube;\n                for (int i = 0; i < x; i++) rotateX(&temp);\n                for (int i = 0; i < y; i++) rotateY(&temp);\n                for (int i = 0; i < z; i++) rotateZ(&temp);\n\n                for (int i = 0; i < 6; i++) {\n                    if (temp.colors[i] < min.colors[i]) {\n                        min = temp;\n                        break;\n                    } else if (temp.colors[i] > min.colors[i]) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    *cube = min;\n}\n\nint compareCubes(const void *a, const void *b) {\n    Cube *cubeA = (Cube *)a;\n    Cube *cubeB = (Cube *)b;\n    for (int i = 0; i < 6; i++) {\n        if (cubeA->colors[i] != cubeB->colors[i]) {\n            return cubeA->colors[i] - cubeB->colors[i];\n        }\n    }\n    return 0;\n}\n\nint countDistinct(Cube *cubes, int n) {\n    for (int i = 0; i < n; i++) {\n        normalize(&cubes[i]);\n    }\n    qsort(cubes, n, sizeof(Cube), compareCubes);\n    int count = 1;\n    for (int i = 1; i < n; i++) {\n        if (compareCubes(&cubes[i], &cubes[i-1]) != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Cube *cubes = malloc(n * sizeof(Cube));\n    char color[10];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 6; j++) {\n            scanf(\"%s\", color);\n            switch (color[0]) {\n                case 'R': cubes[i].colors[j] = 0; break;\n                case 'Y': cubes[i].colors[j] = 1; break;\n                case 'B': cubes[i].colors[j] = 2; break;\n                case 'M': cubes[i].colors[j] = 3; break;\n                case 'G': cubes[i].colors[j] = 4; break;\n                case 'C': cubes[i].colors[j] = 5; break;\n            }\n        }\n    }\n    int distinct = countDistinct(cubes, n);\n    printf(\"%d\\n\", 6 - distinct);\n    free(cubes);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShinagawaCubes {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        \n        Set<String> uniqueCubes = new HashSet<>();\n        \n        for (int i = 0; i < n; i++) {\n            String[] colors = new String[6];\n            for (int j = 0; j < 6; j++) {\n                colors[j] = scanner.next();\n            }\n            \n            String canonicalRepresentation = getCanonicalRepresentation(colors);\n            uniqueCubes.add(canonicalRepresentation);\n        }\n        \n        System.out.println(n - uniqueCubes.size());\n        scanner.close();\n    }\n    \n    private static String getCanonicalRepresentation(String[] colors) {\n        List<String> allRotations = generateAllRotations(colors);\n        Collections.sort(allRotations);\n        return allRotations.get(0);\n    }\n    \n    private static List<String> generateAllRotations(String[] colors) {\n        List<String> rotations = new ArrayList<>();\n        \n        int[][] rotationIndices = {\n            {0, 1, 2, 3, 4, 5},\n            {0, 2, 4, 1, 3, 5},\n            {0, 3, 1, 4, 2, 5},\n            {0, 4, 3, 2, 1, 5},\n            {1, 0, 3, 2, 5, 4},\n            {1, 2, 0, 5, 3, 4},\n            {1, 3, 5, 0, 2, 4},\n            {1, 5, 2, 3, 0, 4},\n            {2, 0, 1, 5, 4, 3},\n            {2, 1, 5, 0, 3, 4},\n            {2, 3, 0, 4, 1, 5},\n            {2, 5, 3, 1, 0, 4},\n            {3, 0, 4, 1, 5, 2},\n            {3, 1, 0, 5, 2, 4},\n            {3, 4, 5, 0, 1, 2},\n            {3, 5, 1, 4, 0, 2},\n            {4, 0, 2, 3, 5, 1},\n            {4, 2, 5, 0, 3, 1},\n            {4, 3, 0, 5, 2, 1},\n            {4, 5, 3, 2, 0, 1},\n            {5, 1, 3, 2, 4, 0},\n            {5, 2, 1, 4, 3, 0},\n            {5, 3, 4, 1, 2, 0},\n            {5, 4, 2, 3, 1, 0}\n        };\n        \n        for (int[] indices : rotationIndices) {\n            String[] rotatedColors = new String[6];\n            for (int i = 0; i < 6; i++) {\n                rotatedColors[i] = colors[indices[i]];\n            }\n            rotations.add(String.join(\",\", rotatedColors));\n        }\n        \n        return rotations;\n    }\n}",
    "timestamp": "2025-08-05 18:36:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Cube {\n    vector<string> faces;\n\n    void normalize() {\n        vector<string> minOrder = faces;\n        vector<string> current = faces;\n\n        // Generate all possible rotations and find the minimal ordering\n        for (int i = 0; i < 4; ++i) {\n            // Rotate around vertical axis (front, right, back, left)\n            rotateY(current);\n            if (current < minOrder) {\n                minOrder = current;\n            }\n        }\n\n        // Rotate top to front and compare\n        current = rotateX(faces);\n        if (current < minOrder) {\n            minOrder = current;\n        }\n        for (int i = 0; i < 4; ++i) {\n            rotateY(current);\n            if (current < minOrder) {\n                minOrder = current;\n            }\n        }\n\n        // Rotate top to back and compare\n        current = rotateX(rotateX(faces));\n        if (current < minOrder) {\n            minOrder = current;\n        }\n        for (int i = 0; i < 4; ++i) {\n            rotateY(current);\n            if (current < minOrder) {\n                minOrder = current;\n            }\n        }\n\n        // Rotate top to right and compare\n        current = rotateZ(faces);\n        if (current < minOrder) {\n            minOrder = current;\n        }\n        for (int i = 0; i < 4; ++i) {\n            rotateY(current);\n            if (current < minOrder) {\n                minOrder = current;\n            }\n        }\n\n        // Rotate top to left and compare\n        current = rotateZ(rotateZ(rotateZ(faces)));\n        if (current < minOrder) {\n            minOrder = current;\n        }\n        for (int i = 0; i < 4; ++i) {\n            rotateY(current);\n            if (current < minOrder) {\n                minOrder = current;\n            }\n        }\n\n        // Rotate top to bottom and compare\n        current = rotateX(rotateX(rotateX(faces)));\n        if (current < minOrder) {\n            minOrder = current;\n        }\n        for (int i = 0; i < 4; ++i) {\n            rotateY(current);\n            if (current < minOrder) {\n                minOrder = current;\n            }\n        }\n\n        faces = minOrder;\n    }\n\n    vector<string> rotateX(const vector<string>& f) {\n        return {f[4], f[1], f[0], f[3], f[5], f[2]};\n    }\n\n    vector<string> rotateY(const vector<string>& f) {\n        return {f[0], f[2], f[3], f[1], f[4], f[5]};\n    }\n\n    vector<string> rotateZ(const vector<string>& f) {\n        return {f[3], f[0], f[1], f[2], f[4], f[5]};\n    }\n\n    bool operator<(const Cube& other) const {\n        return faces < other.faces;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    set<Cube> distinctCubes;\n\n    for (int i = 0; i < n; ++i) {\n        Cube cube;\n        for (int j = 0; j < 6; ++j) {\n            string color;\n            cin >> color;\n            cube.faces.push_back(color);\n        }\n        cube.normalize();\n        distinctCubes.insert(cube);\n    }\n\n    cout << 6 - distinctCubes.size() << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:37:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_CUBES 100\n#define MAX_COLOR_LEN 10\n\ntypedef struct {\n    char colors[6][MAX_COLOR_LEN];\n} Cube;\n\nint areCubesEqual(Cube *cube1, Cube *cube2) {\n    int used1[6] = {0}, used2[6] = {0};\n    \n    for (int i = 0; i < 6; i++) {\n        for (int j = 0; j < 6; j++) {\n            if (!used1[i] && !used2[j] && strcmp(cube1->colors[i], cube2->colors[j]) == 0) {\n                used1[i] = 1;\n                used2[j] = 1;\n                break;\n            }\n        }\n    }\n    \n    for (int i = 0; i < 6; i++) {\n        if (!used1[i] || !used2[i]) return 0;\n    }\n    \n    return 1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Cube cubes[MAX_CUBES];\n    int uniqueCubes = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 6; j++) {\n            scanf(\"%s\", cubes[i].colors[j]);\n        }\n        \n        int isUnique = 1;\n        for (int j = 0; j < i; j++) {\n            if (areCubesEqual(&cubes[i], &cubes[j])) {\n                isUnique = 0;\n                break;\n            }\n        }\n        \n        if (isUnique) uniqueCubes++;\n    }\n    \n    printf(\"%d\\n\", n - uniqueCubes);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:37:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> generateAllRotations(vector<int>& cube) {\n    vector<vector<int>> rotations;\n    set<vector<int>> uniqueRotations;\n\n    // Generate all possible rotations of the cube\n    vector<vector<int>> rotationIndices = {\n        {0,1,2,3,4,5}, {0,2,4,1,3,5}, {0,3,1,4,2,5}, {0,4,3,2,1,5},\n        {1,0,3,2,5,4}, {1,2,0,5,3,4}, {1,3,5,0,2,4}, {1,5,2,3,0,4},\n        {2,0,1,5,4,3}, {2,1,5,0,3,4}, {2,3,0,4,1,5}, {2,5,3,1,0,4},\n        {3,0,4,1,5,2}, {3,1,0,5,4,2}, {3,4,5,0,1,2}, {3,5,1,4,0,2},\n        {4,0,2,5,3,1}, {4,2,5,0,1,3}, {4,3,0,1,5,2}, {4,5,3,2,0,1},\n        {5,1,3,2,4,0}, {5,2,1,4,3,0}, {5,3,4,1,2,0}, {5,4,2,3,1,0}\n    };\n\n    for (auto& indices : rotationIndices) {\n        vector<int> rotatedCube(6);\n        for (int i = 0; i < 6; i++) {\n            rotatedCube[i] = cube[indices[i]];\n        }\n        \n        sort(rotatedCube.begin(), rotatedCube.end());\n        uniqueRotations.insert(rotatedCube);\n    }\n\n    for (auto& rotation : uniqueRotations) {\n        rotations.push_back(rotation);\n    }\n\n    return rotations;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    set<vector<int>> distinctCubes;\n\n    for (int i = 0; i < n; i++) {\n        vector<int> cube(6);\n        for (int j = 0; j < 6; j++) {\n            cin >> cube[j];\n        }\n\n        vector<vector<int>> rotations = generateAllRotations(cube);\n        bool isNewCube = true;\n\n        for (auto& rotation : rotations) {\n            if (distinctCubes.count(rotation)) {\n                isNewCube = false;\n                break;\n            }\n        }\n\n        if (isNewCube) {\n            distinctCubes.insert(rotations[0]);\n        }\n    }\n\n    cout << distinctCubes.size() << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:37:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine(); // consume the remaining newline\n        Set<String> uniqueConfigs = new HashSet<>();\n\n        for (int i = 0; i < n; i++) {\n            String[] faces = scanner.nextLine().split(\" \");\n            List<String> colors = Arrays.asList(faces);\n            String normalized = normalizeConfig(colors);\n            uniqueConfigs.add(normalized);\n        }\n\n        System.out.println(6 - uniqueConfigs.size());\n    }\n\n    private static String normalizeConfig(List<String> colors) {\n        List<String> allRotations = new ArrayList<>();\n        for (int i = 0; i < 6; i++) {\n            for (int j = 0; j < 4; j++) {\n                String rotation = getRotation(colors, i, j);\n                allRotations.add(rotation);\n            }\n        }\n        return Collections.min(allRotations);\n    }\n\n    private static String getRotation(List<String> colors, int top, int frontRot) {\n        // Define the cube faces based on top and front rotations\n        String[] cube = new String[6];\n        cube[0] = colors.get(top);\n        cube[1] = colors.get(getBottom(top));\n        \n        int[] frontIndices = getFrontIndices(top);\n        int frontIndex = frontIndices[frontRot % frontIndices.length];\n        cube[2] = colors.get(frontIndex);\n        cube[3] = colors.get(getBack(frontIndex, top));\n        \n        int[] sideIndices = getSideIndices(top, frontIndex);\n        cube[4] = colors.get(sideIndices[0]);\n        cube[5] = colors.get(sideIndices[1]);\n        \n        Arrays.sort(cube, 2, 6); // Sort the side faces to normalize\n        return Arrays.toString(cube);\n    }\n\n    private static int getBottom(int top) {\n        return (top + 3) % 6;\n    }\n\n    private static int getBack(int front, int top) {\n        if (front < 3) {\n            return (front + 3) % 6;\n        } else {\n            return (front + 3) % 6;\n        }\n    }\n\n    private static int[] getFrontIndices(int top) {\n        if (top == 0) return new int[]{1, 2, 4, 5};\n        if (top == 1) return new int[]{0, 2, 3, 5};\n        if (top == 2) return new int[]{0, 1, 3, 4};\n        if (top == 3) return new int[]{1, 2, 4, 5};\n        if (top == 4) return new int[]{0, 2, 3, 5};\n        if (top == 5) return new int[]{0, 1, 3, 4};\n        return new int[]{};\n    }\n\n    private static int[] getSideIndices(int top, int front) {\n        Set<Integer> used = new HashSet<>();\n        used.add(top);\n        used.add(getBottom(top));\n        used.add(front);\n        used.add(getBack(front, top));\n        int[] sides = new int[2];\n        int idx = 0;\n        for (int i = 0; i < 6; i++) {\n            if (!used.contains(i)) {\n                sides[idx++] = i;\n            }\n        }\n        return sides;\n    }\n}",
    "timestamp": "2025-08-05 18:37:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef are_cubes_equivalent(cube1, cube2):\n    rotations = [\n        (0, 1, 2, 3, 4, 5), (0, 2, 4, 1, 5, 3), (0, 4, 5, 2, 3, 1), (0, 5, 3, 4, 1, 2), # Top face\n        (1, 0, 3, 2, 5, 4), (1, 3, 5, 0, 4, 2), (1, 5, 4, 3, 2, 0), (1, 4, 2, 5, 0, 3), # Bottom face\n        (2, 0, 1, 5, 3, 4), (2, 1, 3, 0, 4, 5), (2, 3, 4, 1, 5, 0), (2, 4, 0, 3, 2, 1), # Front face\n        (3, 0, 4, 1, 2, 5), (3, 4, 5, 0, 5, 2), (3, 5, 2, 4, 1, 0), (3, 2, 0, 5, 4, 1), # Back face\n        (4, 0, 5, 3, 1, 2), (4, 5, 1, 0, 2, 3), (4, 1, 2, 5, 3, 0), (4, 2, 3, 1, 0, 5), # Left face\n        (5, 0, 2, 4, 3, 1), (5, 2, 1, 0, 4, 3), (5, 1, 3, 2, 5, 0), (5, 3, 0, 1, 2, 4)  # Right face\n    ]\n    \n    for rotation in rotations:\n        if all(cube1[i] == cube2[rotation[i]] for i in range(6)):\n            return True\n    return False\n\ndef distinct_cubes_count(cubes):\n    distinct_cubes = []\n    \n    for cube in cubes:\n        is_new = True\n        for distinct in distinct_cubes:\n            if are_cubes_equivalent(cube, distinct):\n                is_new = False\n                break\n        if is_new:\n            distinct_cubes.append(cube)\n    \n    return len(distinct_cubes)\n\ndef more_distinct_pieces_needed(current_cubes, n):\n    current_distinct_count = distinct_cubes_count(current_cubes)\n    return max(0, n - current_distinct_count)\n\n# Sample Usage\n# Number of artworks required\nn = 5\n# Listing color configurations of current artworks as list of tuples\ncurrent_cubes = [\n    ('Red', 'Blue', 'Yellow', 'Green', 'Magenta', 'Cyan'),\n    ('Yellow', 'Red', 'Cyan', 'Magenta', 'Blue', 'Green'),\n    ('Green', 'Yellow', 'Magenta', 'Red', 'Blue', 'Cyan')\n]\n\n# Output the number of additional distinct pieces needed\nprint(more_distinct_pieces_needed(current_cubes, n))",
    "timestamp": "2025-08-13 00:04:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class DistinctArtwork {\n    private static final int[][] ROTATIONS = {\n        {0, 1, 2, 3, 4, 5}, {0, 4, 2, 5, 3, 1}, {0, 3, 2, 4, 1, 5}, {0, 5, 2, 1, 4, 3},\n        {1, 0, 4, 5, 2, 3}, {1, 2, 4, 3, 0, 5}, {1, 3, 4, 0, 5, 2}, {1, 5, 4, 2, 3, 0},\n        {2, 1, 5, 4, 0, 3}, {2, 4, 5, 3, 1, 0}, {2, 3, 5, 0, 4, 1}, {2, 0, 5, 1, 3, 4},\n        {3, 0, 1, 5, 2, 4}, {3, 2, 1, 4, 5, 0}, {3, 4, 1, 2, 0, 5}, {3, 5, 1, 0, 4, 2},\n        {4, 1, 3, 2, 0, 5}, {4, 2, 3, 0, 1, 5}, {4, 0, 3, 5, 2, 1}, {4, 5, 3, 1, 0, 2},\n        {5, 1, 0, 3, 2, 4}, {5, 2, 0, 4, 3, 1}, {5, 3, 0, 1, 4, 2}, {5, 0, 0, 2, 1, 3}\n    };\n\n    private static String normalizeCube(String[] faces) {\n        String min = null;\n        for (int[] rot : ROTATIONS) {\n            StringBuilder sb = new StringBuilder();\n            for (int i : rot) {\n                sb.append(faces[i]).append(\" \");\n            }\n            String current = sb.toString().trim();\n            if (min == null || current.compareTo(min) < 0) {\n                min = current;\n            }\n        }\n        return min;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        Set<String> distinctCubes = new HashSet<>();\n        \n        for (int i = 0; i < n; i++) {\n            String[] colors = new String[6];\n            for (int j = 0; j < 6; j++) {\n                colors[j] = sc.next();\n            }\n            String normalized = normalizeCube(colors);\n            distinctCubes.add(normalized);\n        }\n        \n        int distinct = distinctCubes.size();\n        int needed = (int) Math.pow(6, 3) - distinct; // Total unique ways of painting a cube is 6^3.\n        System.out.println(needed);\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 00:04:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define NUM_FACES 6\n#define MAX_COLORS 6\n\nchar* colors[MAX_COLORS] = {\"Red\", \"Yellow\", \"Blue\", \"Magenta\", \"Green\", \"Cyan\"};\n\nint colorIndex(char* color) {\n    for (int i = 0; i < MAX_COLORS; i++) {\n        if (strcmp(color, colors[i]) == 0) return i;\n    }\n    return -1;\n}\n\nvoid rotateCube(int arr[]) {\n    int temp = arr[0];\n    arr[0] = arr[1];\n    arr[1] = arr[5];\n    arr[5] = arr[4];\n    arr[4] = temp;\n}\n\nvoid rotateHorizontal(int arr[]) {\n    int temp = arr[2];\n    arr[2] = arr[1];\n    arr[1] = arr[3];\n    arr[3] = arr[4];\n    arr[4] = temp;\n}\n\nvoid rotateVertical(int arr[]) {\n    int temp = arr[0];\n    arr[0] = arr[2];\n    arr[2] = arr[5];\n    arr[5] = arr[3];\n    arr[3] = temp;\n}\n\nvoid generatePermutations(int colorArr[MAX_COLORS], int permutations[24][MAX_COLORS]) {\n    int index = 0;\n    for (int a = 0; a < 2; a++) {\n        for (int b = 0; b < 4; b++) {\n            int temp[MAX_COLORS];\n            memcpy(temp, colorArr, sizeof(temp));\n            for (int c = 0; c < a; c++) rotateCube(temp);\n            for (int d = 0; d < b; d++) rotateHorizontal(temp);\n            memcpy(permutations[index++], temp, sizeof(temp));\n        }\n        rotateVertical(colorArr);\n        rotateHorizontal(colorArr);\n        rotateVertical(colorArr);\n    }\n}\n\nint cubeEquals(int a[MAX_COLORS], int b[MAX_COLORS]) {\n    int perms[24][MAX_COLORS];\n    generatePermutations(b, perms);\n    for (int i = 0; i < 24; i++) {\n        if (memcmp(a, perms[i], sizeof(int) * MAX_COLORS) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint isUnique(int artworks[MAX_COLORS][NUM_FACES], int n, int current) {\n    for (int i = 0; i < current; i++) {\n        if (cubeEquals(artworks[i], artworks[current])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int artworks[n][NUM_FACES];\n    \n    for (int i = 0; i < n; i++) {\n        char color[10];\n        for (int j = 0; j < NUM_FACES; j++) {\n            scanf(\"%s\", color);\n            artworks[i][j] = colorIndex(color);\n        }\n    }\n    \n    int uniqueCount = 0;\n    for (int i = 0; i < n; i++) {\n        if (isUnique(artworks, n, i)) {\n            uniqueCount++;\n        }\n    }\n    \n    printf(\"%d\\n\", n - uniqueCount);\n    return 0;\n}",
    "timestamp": "2025-08-13 00:04:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_unique_cubes(n, color_configs):\n    unique_cubes = set()\n    \n    for config in color_configs:\n        cube_rotations = generate_all_rotations(config)\n        unique_cubes.add(min(cube_rotations))\n    \n    return max(0, n - len(unique_cubes))\n\ndef generate_all_rotations(cube):\n    rotations = set()\n    \n    # Generate all possible rotations\n    for _ in range(24):  # 24 possible unique orientations of a cube\n        cube = rotate_cube(cube)\n        rotations.add(tuple(sorted(cube)))\n    \n    return rotations\n\ndef rotate_cube(cube):\n    # Simulating cube rotation\n    rotated = cube.copy()\n    temp = rotated[0]\n    rotated[0] = rotated[1]\n    rotated[1] = rotated[2]\n    rotated[2] = rotated[3]\n    rotated[3] = temp\n    \n    return rotated\n\n# Example usage\nn = int(input())\ncolor_configs = []\nfor _ in range(n):\n    config = list(input().split())\n    color_configs.append(config)\n\nresult = count_unique_cubes(n, color_configs)\nprint(result)",
    "timestamp": "2025-08-13 00:04:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef normalize(cube):\n    # The normalized form is the lexicographically smallest tuple of sorted colors\n    return tuple(sorted(cube))\n\ndef main():\n    n = int(sys.stdin.readline())\n    seen = defaultdict(int)\n    for _ in range(n):\n        cube = sys.stdin.readline().strip().split()\n        norm = normalize(cube)\n        seen[norm] += 1\n    # The answer is 6! (720) minus the number of distinct cubes seen\n    total_possible = 720  # 6! since colors are distinct\n    distinct_seen = len(seen)\n    print(total_possible - distinct_seen)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:06:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <array>\n#include <algorithm>\n\nconst int NUM_FACES = 6;\nconst std::array<std::string, NUM_FACES> COLORS = {\"Red\", \"Yellow\", \"Blue\", \"Magenta\", \"Green\", \"Cyan\"};\n\nstd::array<int, NUM_FACES> mapColorsToIndexes(const std::array<std::string, NUM_FACES>& colors) {\n    std::array<int, NUM_FACES> indexes{};\n    for (int i = 0; i < NUM_FACES; ++i) {\n        indexes[i] = std::distance(COLORS.begin(), std::find(COLORS.begin(), COLORS.end(), colors[i]));\n    }\n    return indexes;\n}\n\nstd::vector<std::array<int, NUM_FACES>> generateRotations(const std::array<int, NUM_FACES>& cube) {\n    std::vector<std::array<int, NUM_FACES>> rotations;\n    for (int r = 0; r < 4; ++r) {\n        auto rotated = cube;\n        std::rotate(rotated.begin(), rotated.begin() + 4, rotated.end());\n        rotations.push_back(rotated);\n        std::rotate(rotated.begin(), rotated.begin() + 1, rotated.begin() + 4);\n        rotations.push_back(rotated);\n        std::rotate(rotated.begin(), rotated.begin() + 2, rotated.begin() + 4);\n        rotations.push_back(rotated);\n        std::rotate(rotated.begin(), rotated.begin() + 3, rotated.begin() + 4);\n        rotations.push_back(rotated);\n        std::rotate(rotated.begin(), rotated.begin() + 4, rotated.end());\n    }\n    return rotations;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::set<std::vector<int>> uniqueCubes;\n\n    for (int i = 0; i < n; ++i) {\n        std::array<std::string, NUM_FACES> colors;\n        for (auto& color : colors) {\n            std::cin >> color;\n        }\n        \n        auto cube = mapColorsToIndexes(colors);\n        auto rotations = generateRotations(cube);\n        \n        std::sort(rotations.begin(), rotations.end());\n        uniqueCubes.insert(rotations.front());\n    }\n\n    int neededDistinctPieces = 6 - uniqueCubes.size();\n    std::cout << neededDistinctPieces << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:52:14"
  }
]