[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n\n#define EPSILON 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point p1, Point p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint is_intersecting(double a1, double b1, double c1, double a2, double b2, double c2, Point *intersect) {\n    double det = a1 * b2 - a2 * b1;\n    if (fabs(det) < EPSILON) return 0;\n\n    intersect->x = (b2 * c1 - b1 * c2) / det;\n    intersect->y = (a1 * c2 - a2 * c1) / det;\n    return 1;\n}\n\nvoid find_optimal_exhibition(int n, double *a, double *b, double *c, Point *result) {\n    Point *intersections = malloc(n * (n - 1) / 2 * sizeof(Point));\n    int intersection_count = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            Point intersect;\n            if (is_intersecting(a[i], b[i], c[i], a[j], b[j], c[j], &intersect)) {\n                intersections[intersection_count++] = intersect;\n            }\n        }\n    }\n\n    double min_total_distance = DBL_MAX;\n    Point optimal_point = {0, 0};\n\n    for (int k = 0; k < intersection_count; k++) {\n        double total_distance = 0;\n        for (int l = 0; l < intersection_count; l++) {\n            total_distance += distance(intersections[k], intersections[l]);\n        }\n\n        if (total_distance < min_total_distance || \n            (fabs(total_distance - min_total_distance) < EPSILON && \n             (intersections[k].x < optimal_point.x || \n              (fabs(intersections[k].x - optimal_point.x) < EPSILON && intersections[k].y < optimal_point.y)))) {\n            min_total_distance = total_distance;\n            optimal_point = intersections[k];\n        }\n    }\n\n    *result = optimal_point;\n    free(intersections);\n}",
    "timestamp": "2025-08-05 23:13:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nPoint compute_optimal_point(int N, double A[], double B[], double C[]) {\n    Point *intersections = malloc(N * N * sizeof(Point));\n    int count = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            double det = A[i] * B[j] - A[j] * B[i];\n            if (fabs(det) < 1e-10) continue; // Parallel lines, no intersection\n\n            double x = (B[j] * C[i] - B[i] * C[j]) / det;\n            double y = (A[i] * C[j] - A[j] * C[i]) / det;\n            intersections[count++] = (Point){x, y};\n        }\n    }\n\n    if (count == 0) {\n        free(intersections);\n        return (Point){0.0, 0.0};\n    }\n\n    double min_total_dist = DBL_MAX;\n    Point best_point = intersections[0];\n\n    for (int i = 0; i < count; i++) {\n        double total_dist = 0.0;\n        for (int j = 0; j < count; j++) {\n            double dx = intersections[i].x - intersections[j].x;\n            double dy = intersections[i].y - intersections[j].y;\n            total_dist += sqrt(dx * dx + dy * dy);\n        }\n\n        if (total_dist < min_total_dist) {\n            min_total_dist = total_dist;\n            best_point = intersections[i];\n        } else if (fabs(total_dist - min_total_dist) < 1e-10) {\n            if (intersections[i].x < best_point.x || \n                (fabs(intersections[i].x - best_point.x) < 1e-10 && intersections[i].y < best_point.y)) {\n                best_point = intersections[i];\n            }\n        }\n    }\n\n    free(intersections);\n    return best_point;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    double *A = malloc(N * sizeof(double));\n    double *B = malloc(N * sizeof(double));\n    double *C = malloc(N * sizeof(double));\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf %lf\", &A[i], &B[i], &C[i]);\n    }\n\n    Point result = compute_optimal_point(N, A, B, C);\n    printf(\"%.6lf %.6lf\\n\", result.x, result.y);\n\n    free(A);\n    free(B);\n    free(C);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\npair<double, double> findOptimalExhibition(int N, const vector<double>& A, const vector<double>& B, const vector<double>& C) {\n    vector<pair<double, double>> intersections;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            double a1 = A[i], b1 = B[i], c1 = C[i];\n            double a2 = A[j], b2 = B[j], c2 = C[j];\n\n            double determinant = a1 * b2 - a2 * b1;\n            if (fabs(determinant) < 1e-9) {\n                continue; // Parallel lines, no intersection\n            }\n\n            double x = (b2 * c1 - b1 * c2) / determinant;\n            double y = (a1 * c2 - a2 * c1) / determinant;\n            intersections.emplace_back(x, y);\n        }\n    }\n\n    if (intersections.empty()) {\n        return {0.0, 0.0}; // No intersections, default to origin\n    }\n\n    auto medianSelector = [](const vector<pair<double, double>>& points, bool getX) {\n        vector<double> values;\n        for (const auto& p : points) {\n            values.push_back(getX ? p.first : p.second);\n        }\n        sort(values.begin(), values.end());\n        int n = values.size();\n        if (n % 2 == 1) {\n            return values[n / 2];\n        } else {\n            return (values[n / 2 - 1] + values[n / 2]) / 2.0;\n        }\n    };\n\n    double medianX = medianSelector(intersections, true);\n    double medianY = medianSelector(intersections, false);\n\n    // Find the point with minimal total distance, preferring smallest x and y in case of tie\n    double minDist = numeric_limits<double>::max();\n    pair<double, double> bestPoint = {medianX, medianY};\n\n    auto totalDistance = [&](double x, double y) {\n        double total = 0.0;\n        for (const auto& p : intersections) {\n            total += hypot(p.first - x, p.second - y);\n        }\n        return total;\n    };\n\n    // Check nearby points to handle ties\n    vector<pair<double, double>> candidates = {\n        {medianX, medianY},\n        {medianX - 1e-5, medianY},\n        {medianX + 1e-5, medianY},\n        {medianX, medianY - 1e-5},\n        {medianX, medianY + 1e-5}\n    };\n\n    for (const auto& candidate : candidates) {\n        double dist = totalDistance(candidate.first, candidate.second);\n        if (dist < minDist || \n            (dist == minDist && (candidate.first < bestPoint.first || \n                                (candidate.first == bestPoint.first && candidate.second < bestPoint.second)))) {\n            minDist = dist;\n            bestPoint = candidate;\n        }\n    }\n\n    return bestPoint;\n}",
    "timestamp": "2025-08-05 23:14:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class OptimalExhibitionLocation {\n    public static double[] findOptimalLocation(int N, int[][] lines) {\n        List<double[]> intersections = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                double A1 = lines[i][0], B1 = lines[i][1], C1 = lines[i][2];\n                double A2 = lines[j][0], B2 = lines[j][1], C2 = lines[j][2];\n                \n                double det = A1 * B2 - A2 * B1;\n                if (Math.abs(det) > 1e-9) {\n                    double x = (B2 * C1 - B1 * C2) / det;\n                    double y = (A1 * C2 - A2 * C1) / det;\n                    intersections.add(new double[]{x, y});\n                }\n            }\n        }\n        \n        if (intersections.isEmpty()) {\n            return new double[]{0.0, 0.0};\n        }\n        \n        double[] median = findMedian(intersections);\n        return median;\n    }\n    \n    private static double[] findMedian(List<double[]> points) {\n        List<Double> xCoords = new ArrayList<>();\n        List<Double> yCoords = new ArrayList<>();\n        \n        for (double[] point : points) {\n            xCoords.add(point[0]);\n            yCoords.add(point[1]);\n        }\n        \n        Collections.sort(xCoords);\n        Collections.sort(yCoords);\n        \n        int n = xCoords.size();\n        double medianX, medianY;\n        \n        if (n % 2 == 1) {\n            medianX = xCoords.get(n / 2);\n            medianY = yCoords.get(n / 2);\n        } else {\n            medianX = (xCoords.get(n / 2 - 1) + xCoords.get(n / 2)) / 2.0;\n            medianY = (yCoords.get(n / 2 - 1) + yCoords.get(n / 2)) / 2.0;\n        }\n        \n        return new double[]{medianX, medianY};\n    }\n}",
    "timestamp": "2025-08-05 23:14:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public double[] findOptimalExhibitionLocation(int N, int[][] lines) {\n        if (N <= 0) return new double[]{0, 0};\n        \n        List<double[]> intersections = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                double[] point = findIntersection(lines[i], lines[j]);\n                if (point != null) {\n                    intersections.add(point);\n                }\n            }\n        }\n        \n        return findMinimumTotalDistancePoint(intersections);\n    }\n    \n    private double[] findIntersection(int[] line1, int[] line2) {\n        int a1 = line1[0], b1 = line1[1], c1 = line1[2];\n        int a2 = line2[0], b2 = line2[1], c2 = line2[2];\n        \n        double determinant = a1 * b2 - a2 * b1;\n        \n        if (determinant == 0) return null;\n        \n        double x = (b2 * c1 - b1 * c2) / determinant;\n        double y = (a1 * c2 - a2 * c1) / determinant;\n        \n        return new double[]{x, y};\n    }\n    \n    private double[] findMinimumTotalDistancePoint(List<double[]> points) {\n        if (points.isEmpty()) return new double[]{0, 0};\n        \n        double minTotalDistance = Double.MAX_VALUE;\n        double[] optimalLocation = new double[2];\n        \n        for (double[] candidate : points) {\n            double totalDistance = calculateTotalDistance(candidate, points);\n            \n            if (totalDistance < minTotalDistance || \n                (totalDistance == minTotalDistance && \n                 (candidate[0] < optimalLocation[0] || \n                  (candidate[0] == optimalLocation[0] && candidate[1] < optimalLocation[1])))) {\n                minTotalDistance = totalDistance;\n                optimalLocation = candidate;\n            }\n        }\n        \n        return optimalLocation;\n    }\n    \n    private double calculateTotalDistance(double[] point, List<double[]> points) {\n        double totalDistance = 0;\n        for (double[] p : points) {\n            totalDistance += Math.sqrt(Math.pow(point[0] - p[0], 2) + Math.pow(point[1] - p[1], 2));\n        }\n        return totalDistance;\n    }\n}",
    "timestamp": "2025-08-05 23:15:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <limits>\n#include <cmath>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<double> findOptimalLocation(int N, std::vector<std::vector<int>>& lines) {\n        auto det = [](double a, double b, double c, double d) {\n            return a * d - b * c;\n        };\n\n        auto intersect = [&](const std::vector<int>& line1, const std::vector<int>& line2) {\n            double a1 = line1[0], b1 = line1[1], c1 = line1[2];\n            double a2 = line2[0], b2 = line2[1], c2 = line2[2];\n            double det_val = det(a1, b1, a2, b2);\n            \n            if (std::abs(det_val) < 1e-9) return std::vector<double>{std::numeric_limits<double>::max(), std::numeric_limits<double>::max()};\n            \n            double x = det(c1, b1, c2, b2) / det_val;\n            double y = det(a1, c1, a2, c2) / det_val;\n            return std::vector<double>{x, y};\n        };\n\n        std::vector<std::vector<double>> points;\n        for (int i = 0; i < N; ++i) {\n            for (int j = i + 1; j < N; ++j) {\n                auto point = intersect(lines[i], lines[j]);\n                if (point[0] != std::numeric_limits<double>::max()) {\n                    points.push_back(point);\n                }\n            }\n        }\n\n        if (points.empty()) return {0.0, 0.0};\n\n        auto minDistance = [&](const std::vector<double>& point) {\n            double totalDist = 0.0;\n            for (const auto& p : points) {\n                totalDist += std::sqrt(std::pow(point[0] - p[0], 2) + std::pow(point[1] - p[1], 2));\n            }\n            return totalDist;\n        };\n\n        std::vector<double> optimalPoint = points[0];\n        double minDist = minDistance(optimalPoint);\n\n        for (const auto& point : points) {\n            double dist = minDistance(point);\n            if (dist < minDist || \n                (std::abs(dist - minDist) < 1e-9 && \n                 (point[0] < optimalPoint[0] || \n                  (std::abs(point[0] - optimalPoint[0]) < 1e-9 && point[1] < optimalPoint[1])))) {\n                optimalPoint = point;\n                minDist = dist;\n            }\n        }\n\n        return optimalPoint;\n    }\n};",
    "timestamp": "2025-08-05 23:15:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lines_intersection(A1, B1, C1, A2, B2, C2):\n    det = A1 * B2 - A2 * B1\n    if det == 0:\n        return None\n    x = (C1 * B2 - C2 * B1) / det\n    y = (A1 * C2 - A2 * C1) / det\n    return (x, y)\n\ndef optimal_exhibition_location(N, lines):\n    intersections = []\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            A1, B1, C1 = lines[i]\n            A2, B2, C2 = lines[j]\n            point = lines_intersection(A1, B1, C1, A2, B2, C2)\n            if point:\n                intersections.append(point)\n    \n    if not intersections:\n        return None\n\n    unique_points = list(set(intersections))\n    unique_points.sort(key=lambda p: (p[0], p[1]))\n\n    optimal_location = None\n    min_distance_sum = float('inf')\n\n    for ox, oy in unique_points:\n        distance_sum = 0\n        for x, y in intersections:\n            distance_sum += abs(ox - x) + abs(oy - y)\n        \n        if distance_sum < min_distance_sum:\n            min_distance_sum = distance_sum\n            optimal_location = (ox, oy)\n\n    return optimal_location",
    "timestamp": "2025-08-13 14:13:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ExhibitionPoint {\n\n    public static double[] findOptimalLocation(int N, int[][] lines) {\n        // To store all intersection points\n        List<double[]> intersections = new ArrayList<>();\n\n        // Calculate all intersection points for unique pairs of lines\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int A1 = lines[i][0], B1 = lines[i][1], C1 = lines[i][2];\n                int A2 = lines[j][0], B2 = lines[j][1], C2 = lines[j][2];\n                \n                // Calculate determinant\n                int det = A1 * B2 - A2 * B1;\n                \n                // If not parallel\n                if (det != 0) {\n                    double x = (double)(C1 * B2 - C2 * B1) / det;\n                    double y = (double)(A1 * C2 - A2 * C1) / det;\n                    intersections.add(new double[]{x, y});\n                }\n            }\n        }\n\n        // Initialize variables to store best point and minimum distance\n        double minDistance = Double.MAX_VALUE;\n        double[] bestPoint = new double[2];\n\n        // Checking each intersection point to find the optimal exhibition point\n        for (double[] p : intersections) {\n            double totalDistance = 0;\n\n            // Calculate total distance for this point\n            for (double[] q : intersections) {\n                totalDistance += Math.abs(p[0] - q[0]) + Math.abs(p[1] - q[1]);\n            }\n\n            // If a new minimum is found, update bestPoint\n            if (totalDistance < minDistance \n                || (totalDistance == minDistance && \n                (p[0] < bestPoint[0] || (p[0] == bestPoint[0] && p[1] < bestPoint[1])))) {\n                minDistance = totalDistance;\n                bestPoint = p;\n            }\n        }\n\n        return bestPoint;\n    }\n\n    public static void main(String[] args) {\n        int N = 3;\n        int[][] lines = {{1, -1, 0}, {1, 1, 0}, {1, 0, -1}};\n        double[] result = findOptimalLocation(N, lines);\n        System.out.printf(\"Optimal location: (%.2f, %.2f)\\n\", result[0], result[1]);\n    }\n}",
    "timestamp": "2025-08-13 14:13:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <float.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nPoint findOptimalLocation(int N, double A[], double B[], double C[]) {\n    Point points[N * (N - 1) / 2];\n    int index = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            double det = A[i] * B[j] - A[j] * B[i];\n            if (fabs(det) < 1e-9) continue; // Lines are parallel\n            double x = (C[i] * B[j] - C[j] * B[i]) / det;\n            double y = (A[i] * C[j] - A[j] * C[i]) / det;\n            points[index++] = (Point){x, y};\n        }\n    }\n\n    Point optimal = (Point){DBL_MAX, DBL_MAX};\n    double minDistance = DBL_MAX;\n\n    for (int i = 0; i < index; ++i) {\n        Point current = points[i];\n        double totalDistance = 0;\n        for (int j = 0; j < index; ++j) {\n            totalDistance += fabs(current.x - points[j].x) + fabs(current.y - points[j].y);\n        }\n        if (totalDistance < minDistance || \n            (totalDistance == minDistance && current.x < optimal.x) || \n            (totalDistance == minDistance && current.x == optimal.x && current.y < optimal.y)) {\n            minDistance = totalDistance;\n            optimal = current;\n        }\n    }\n\n    return optimal;\n}\n\n// Function to handle input and output\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    double A[N], B[N], C[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%lf %lf %lf\", &A[i], &B[i], &C[i]);\n    }\n\n    Point optimalLocation = findOptimalLocation(N, A, B, C);\n    printf(\"%lf %lf\\n\", optimalLocation.x, optimalLocation.y);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:14:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function optimalExhibitionLocation(N, lines) {\n    function intersection(A1, B1, C1, A2, B2, C2) {\n        const det = A1 * B2 - A2 * B1;\n        if (det === 0) return null; // Lines are parallel\n        const x = (C1 * B2 - C2 * B1) / det;\n        const y = (A1 * C2 - A2 * C1) / det;\n        return { x, y };\n    }\n  \n    const intersectionPoints = [];\n    for (let i = 0; i < N; i++) {\n        for (let j = i + 1; j < N; j++) {\n            const { x, y } = intersection(\n              lines[i][0], lines[i][1], lines[i][2],\n              lines[j][0], lines[j][1], lines[j][2]\n            );\n            if (x !== null && y !== null) {\n                intersectionPoints.push({ x, y });\n            }\n        }\n    }\n\n    if (intersectionPoints.length === 0) {\n        return null;\n    }\n\n    let minTotalDistance = Infinity;\n    let optimalPoint = null;\n\n    for (const point of intersectionPoints) {\n        let totalDistance = 0;\n        for (const otherPoint of intersectionPoints) {\n            const dx = point.x - otherPoint.x;\n            const dy = point.y - otherPoint.y;\n            totalDistance += Math.sqrt(dx * dx + dy * dy);\n        }\n        if (totalDistance < minTotalDistance || \n           (totalDistance === minTotalDistance && \n            (point.x < optimalPoint.x || \n             (point.x === optimalPoint.x && point.y < optimalPoint.y)))) {\n            minTotalDistance = totalDistance;\n            optimalPoint = point;\n        }\n    }\n\n    return { x: optimalPoint.x, y: optimalPoint.y };\n}",
    "timestamp": "2025-08-13 14:14:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_optimal_exhibition_location(N, A, B, C):\n    def calculate_total_distance(x, y):\n        return sum(abs(A[i] * x + B[i] * y - C[i]) / ((A[i] ** 2 + B[i] ** 2) ** 0.5) for i in range(N))\n\n    def ternary_search_x(low, high):\n        while high - low > 1e-9:\n            mid1 = low + (high - low) / 3\n            mid2 = high - (high - low) / 3\n            \n            dist1 = calculate_total_distance(mid1, find_optimal_y(mid1))\n            dist2 = calculate_total_distance(mid2, find_optimal_y(mid2))\n            \n            if dist1 <= dist2:\n                high = mid2\n            else:\n                low = mid1\n        return low\n\n    def find_optimal_y(x):\n        def total_y_distance(y):\n            return calculate_total_distance(x, y)\n        \n        low, high = -1e9, 1e9\n        while high - low > 1e-9:\n            mid1 = low + (high - low) / 3\n            mid2 = high - (high - low) / 3\n            \n            dist1 = total_y_distance(mid1)\n            dist2 = total_y_distance(mid2)\n            \n            if dist1 <= dist2:\n                high = mid2\n            else:\n                low = mid1\n        return low\n\n    x = ternary_search_x(-1e9, 1e9)\n    y = find_optimal_y(x)\n    \n    return [x, y]",
    "timestamp": "2025-08-13 14:14:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findOptimalExhibitionLocation(N, lines) {\n    const points = [];\n    \n    for (let i = 0; i < N; i++) {\n        for (let j = i + 1; j < N; j++) {\n            const [A1, B1, C1] = lines[i];\n            const [A2, B2, C2] = lines[j];\n            \n            const det = A1 * B2 - A2 * B1;\n            \n            if (det !== 0) {\n                const x = (B2 * C1 - B1 * C2) / det;\n                const y = (A1 * C2 - A2 * C1) / det;\n                points.push([x, y]);\n            }\n        }\n    }\n    \n    function calculateTotalDistance(x, y) {\n        return points.reduce((total, point) => \n            total + Math.abs(point[0] - x) + Math.abs(point[1] - y), 0);\n    }\n    \n    let minDistance = Infinity;\n    let optimalLocation = null;\n    \n    for (const [x, y] of points) {\n        const distance = calculateTotalDistance(x, y);\n        \n        if (distance < minDistance || \n            (distance === minDistance && \n             (x < optimalLocation[0] || \n              (x === optimalLocation[0] && y < optimalLocation[1])))) {\n            minDistance = distance;\n            optimalLocation = [x, y];\n        }\n    }\n    \n    return optimalLocation;\n}",
    "timestamp": "2025-08-13 14:14:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline())\n    lines = []\n    for _ in range(N):\n        A, B, C = map(int, sys.stdin.readline().split())\n        lines.append((A, B, C))\n    \n    intersections = []\n    \n    for i in range(N):\n        A1, B1, C1 = lines[i]\n        for j in range(i + 1, N):\n            A2, B2, C2 = lines[j]\n            # Check if lines are not parallel\n            denominator = A1 * B2 - A2 * B1\n            if denominator == 0:\n                continue  # parallel lines, no intersection\n            x = (B2 * C1 - B1 * C2) / denominator\n            y = (A1 * C2 - A2 * C1) / denominator\n            intersections.append((x, y))\n    \n    if not intersections:\n        # All lines are parallel, pick any point on the first line\n        A, B, C = lines[0]\n        if B != 0:\n            x = 0.0\n            y = C / B\n        else:\n            x = C / A\n            y = 0.0\n        print(\"{0:.6f} {1:.6f}\".format(x, y))\n        return\n    \n    # Find the median x and y\n    intersections.sort()\n    n = len(intersections)\n    median_x = intersections[(n - 1) // 2][0]\n    \n    # Now find median y for the x-optimal candidates\n    candidates = []\n    for x, y in intersections:\n        if x == median_x:\n            candidates.append(y)\n    \n    candidates.sort()\n    median_y = candidates[(len(candidates) - 1) // 2]\n    \n    print(\"{0:.6f} {1:.6f}\".format(median_x, median_y))\n\nsolve()",
    "timestamp": "2025-08-13 14:14:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findOptimalExhibitionLocation(N, A, B, C) {\n    let intersectionPoints = [];\n\n    for (let i = 0; i < N; i++) {\n        for (let j = i + 1; j < N; j++) {\n            const a1 = A[i], b1 = B[i], c1 = C[i];\n            const a2 = A[j], b2 = B[j], c2 = C[j];\n\n            const denominator = a1 * b2 - a2 * b1;\n\n            if (denominator !== 0) {\n                const x = (b2 * c1 - b1 * c2) / denominator;\n                const y = (a1 * c2 - a2 * c1) / denominator;\n                intersectionPoints.push([x, y]);\n            }\n        }\n    }\n\n    if (intersectionPoints.length === 0) {\n        return [0, 0];\n    }\n\n    intersectionPoints.sort((a, b) => {\n        if (a[0] !== b[0]) return a[0] - b[0];\n        return a[1] - b[1];\n    });\n\n    let minTotalDist = Infinity;\n    let optimalPoint = [0, 0];\n\n    for (const [x, y] of intersectionPoints) {\n        let totalDist = 0;\n        for (const [px, py] of intersectionPoints) {\n            totalDist += Math.sqrt((px - x) ** 2 + (py - y) ** 2);\n        }\n\n        if (totalDist < minTotalDist || \n            (totalDist === minTotalDist && (x < optimalPoint[0] || \n            (x === optimalPoint[0] && y < optimalPoint[1])))) {\n            minTotalDist = totalDist;\n            optimalPoint = [x, y];\n        }\n    }\n\n    return optimalPoint;\n}",
    "timestamp": "2025-08-13 14:15:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\npair<double, double> carExhibition(int N, vector<int> A, vector<int> B, vector<int> C) {\n    map<pair<double, double>, int> freq;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            int A1 = A[i], B1 = B[i], C1 = C[i];\n            int A2 = A[j], B2 = B[j], C2 = C[j];\n            int det = A1 * B2 - A2 * B1;\n            if (det != 0) {\n                double x = (double)(B2 * C1 - B1 * C2) / det;\n                double y = (double)(A1 * C2 - A2 * C1) / det;\n                freq[{x, y}]++;\n            }\n        }\n    }\n\n    pair<double, double> bestPoint = {1e9, 1e9};\n    for (auto &p : freq) {\n        if (p.second == (N * (N - 1)) / 2) {\n            if (p.first < bestPoint) bestPoint = p.first;\n        }\n    }\n    return bestPoint;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N), B(N), C(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i] >> B[i] >> C[i];\n    }\n    pair<double, double> result = carExhibition(N, A, B, C);\n    cout << result.first << \" \" << result.second << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:42:51"
  }
]