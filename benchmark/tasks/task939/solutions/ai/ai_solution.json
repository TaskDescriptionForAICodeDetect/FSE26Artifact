[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 100\n\nint parent[MAX_N * MAX_N + 1];\nbool graph[MAX_N + 1][MAX_N + 1];\n\nint find(int x) {\n    if (parent[x] == x) return x;\n    return parent[x] = find(parent[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x != y) parent[x] = y;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    memset(graph, false, sizeof(graph));\n\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = graph[v][u] = true;\n    }\n\n    for (int i = 1; i <= N * N; i++) {\n        parent[i] = i;\n    }\n\n    for (int a1 = 1; a1 <= N; a1++) {\n        for (int b1 = 1; b1 <= N; b1++) {\n            for (int a2 = 1; a2 <= N; a2++) {\n                for (int b2 = 1; b2 <= N; b2++) {\n                    if (graph[a1][a2] && graph[b1][b2]) {\n                        int node1 = (a1 - 1) * N + b1;\n                        int node2 = (a2 - 1) * N + b2;\n                        unite(node1, node2);\n                    }\n                }\n            }\n        }\n    }\n\n    int components = 0;\n    for (int i = 1; i <= N * N; i++) {\n        if (parent[i] == i) components++;\n    }\n\n    printf(\"%d\\n\", components);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:24:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100\n\ntypedef struct {\n    int parent[MAX_N * MAX_N];\n    int rank[MAX_N * MAX_N];\n    int size;\n} DSU;\n\nvoid init_dsu(DSU *dsu, int size) {\n    dsu->size = size;\n    for (int i = 0; i < size; ++i) {\n        dsu->parent[i] = i;\n        dsu->rank[i] = 0;\n    }\n}\n\nint find(DSU *dsu, int x) {\n    if (dsu->parent[x] != x) {\n        dsu->parent[x] = find(dsu, dsu->parent[x]);\n    }\n    return dsu->parent[x];\n}\n\nvoid union_sets(DSU *dsu, int x, int y) {\n    int x_root = find(dsu, x);\n    int y_root = find(dsu, y);\n    if (x_root == y_root) return;\n    if (dsu->rank[x_root] < dsu->rank[y_root]) {\n        dsu->parent[x_root] = y_root;\n    } else if (dsu->rank[x_root] > dsu->rank[y_root]) {\n        dsu->parent[y_root] = x_root;\n    } else {\n        dsu->parent[y_root] = x_root;\n        dsu->rank[x_root]++;\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int adj[MAX_N + 1][MAX_N + 1] = {0};\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        adj[u][v] = 1;\n        adj[v][u] = 1;\n    }\n    \n    DSU dsu;\n    init_dsu(&dsu, N * N);\n    \n    for (int a = 1; a <= N; ++a) {\n        for (int b = 1; b <= N; ++b) {\n            for (int a2 = 1; a2 <= N; ++a2) {\n                for (int b2 = 1; b2 <= N; ++b2) {\n                    if (adj[a][a2] && adj[b][b2]) {\n                        int u = (a - 1) * N + (b - 1);\n                        int v = (a2 - 1) * N + (b2 - 1);\n                        union_sets(&dsu, u, v);\n                    }\n                }\n            }\n        }\n    }\n    \n    int components = 0;\n    for (int i = 0; i < N * N; ++i) {\n        if (find(&dsu, i) == i) {\n            components++;\n        }\n    }\n    \n    printf(\"%d\\n\", components);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:25:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent;\n    UnionFind(int n) {\n        parent.resize(n);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n    int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n    void unite(int u, int v) {\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) {\n            parent[pu] = pv;\n        }\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    UnionFind uf(N * N);\n\n    for (int a = 1; a <= N; ++a) {\n        for (int b = 1; b <= N; ++b) {\n            for (int a2 : adj[a]) {\n                for (int b2 : adj[b]) {\n                    int u = (a - 1) * N + (b - 1);\n                    int v = (a2 - 1) * N + (b2 - 1);\n                    uf.unite(u, v);\n                }\n            }\n        }\n    }\n\n    int components = 0;\n    for (int i = 0; i < N * N; ++i) {\n        if (uf.find(i) == i) {\n            components++;\n        }\n    }\n\n    cout << components << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:25:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class DSU {\n        int[] parent;\n        int[] rank;\n\n        public DSU(int size) {\n            parent = new int[size];\n            rank = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        public void union(int x, int y) {\n            int xRoot = find(x);\n            int yRoot = find(y);\n            if (xRoot == yRoot) return;\n            if (rank[xRoot] < rank[yRoot]) {\n                parent[xRoot] = yRoot;\n            } else if (rank[yRoot] < rank[xRoot]) {\n                parent[yRoot] = xRoot;\n            } else {\n                parent[yRoot] = xRoot;\n                rank[xRoot]++;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        Set<Integer>[] originalAdj = new Set[N + 1];\n        for (int i = 1; i <= N; i++) {\n            originalAdj[i] = new HashSet<>();\n        }\n        for (int i = 0; i < M; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            originalAdj[u].add(v);\n            originalAdj[v].add(u);\n        }\n\n        DSU dsu = new DSU(N * N + 1);\n\n        for (int a = 1; a <= N; a++) {\n            for (int b = 1; b <= N; b++) {\n                int current = (a - 1) * N + (b - 1);\n                for (int aPrime : originalAdj[a]) {\n                    for (int bPrime : originalAdj[b]) {\n                        int neighbor = (aPrime - 1) * N + (bPrime - 1);\n                        dsu.union(current, neighbor);\n                    }\n                }\n            }\n        }\n\n        Set<Integer> components = new HashSet<>();\n        for (int a = 1; a <= N; a++) {\n            for (int b = 1; b <= N; b++) {\n                int node = (a - 1) * N + (b - 1);\n                components.add(dsu.find(node));\n            }\n        }\n\n        System.out.println(components.size());\n    }\n}",
    "timestamp": "2025-08-05 23:25:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphComponents {\n    static int N;\n    static boolean[][] adjacencyMatrix;\n    static boolean[][] visited;\n\n    public static int countConnectedComponents(int[][] edges) {\n        adjacencyMatrix = new boolean[N + 1][N + 1];\n        for (int[] edge : edges) {\n            adjacencyMatrix[edge[0]][edge[1]] = true;\n            adjacencyMatrix[edge[1]][edge[0]] = true;\n        }\n\n        visited = new boolean[N + 1][N + 1];\n        int componentCount = 0;\n\n        for (int a = 1; a <= N; a++) {\n            for (int b = 1; b <= N; b++) {\n                if (!visited[a][b]) {\n                    dfs(a, b);\n                    componentCount++;\n                }\n            }\n        }\n\n        return componentCount;\n    }\n\n    static void dfs(int a, int b) {\n        visited[a][b] = true;\n\n        for (int a1 = 1; a1 <= N; a1++) {\n            for (int b1 = 1; b1 <= N; b1++) {\n                if (!visited[a1][b1] && \n                    adjacencyMatrix[a][a1] && \n                    adjacencyMatrix[b][b1]) {\n                    dfs(a1, b1);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        int[][] edges = new int[M][2];\n        for (int i = 0; i < M; i++) {\n            edges[i][0] = scanner.nextInt();\n            edges[i][1] = scanner.nextInt();\n        }\n\n        System.out.println(countConnectedComponents(edges));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:26:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return;\n        \n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else {\n            parent[py] = px;\n            if (rank[px] == rank[py]) {\n                rank[px]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<vector<int>> graph(N);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    \n    UnionFind uf(N * N);\n    \n    for (int a = 0; a < N; a++) {\n        for (int b = 0; b < N; b++) {\n            for (int a1 : graph[a]) {\n                for (int b1 : graph[b]) {\n                    int u = a * N + b;\n                    int v = a1 * N + b1;\n                    uf.unite(u, v);\n                }\n            }\n        }\n    }\n    \n    set<int> components;\n    for (int i = 0; i < N * N; i++) {\n        components.insert(uf.find(i));\n    }\n    \n    cout << components.size() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_parent(parents, node):\n    if parents[node] != node:\n        parents[node] = find_parent(parents, parents[node])\n    return parents[node]\n\ndef union(parents, rank, node1, node2):\n    root1 = find_parent(parents, node1)\n    root2 = find_parent(parents, node2)\n    \n    if root1 != root2:\n        if rank[root1] > rank[root2]:\n            parents[root2] = root1\n        elif rank[root1] < rank[root2]:\n            parents[root1] = root2\n        else:\n            parents[root2] = root1\n            rank[root1] += 1\n\ndef count_connected_components(N, edges):\n    parents = { (a, b): (a, b) for a in range(1, N+1) for b in range(1, N+1) }\n    rank = { (a, b): 0 for a in range(1, N+1) for b in range(1, N+1) }\n    \n    for u1, v1 in edges:\n        for u2, v2 in edges:\n            if u1 == u2 and v1 == v2:\n                continue\n            union(parents, rank, (u1, v1), (u2, v2))\n    \n    component_set = set(find_parent(parents, node) for node in parents)\n    return len(component_set)\n\n# Example usage\nN = 3\nedges = [(1, 2), (2, 3), (1, 3)]\nprint(count_connected_components(N, edges))",
    "timestamp": "2025-08-13 15:11:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphComponents {\n    private static List<Integer>[] graph;\n    private static boolean[] visited;\n    private static int N;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        N = sc.nextInt();\n        int M = sc.nextInt();\n        graph = new List[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        \n        // New graph with N^2 vertices\n        int nSquared = N * N;\n        visited = new boolean[nSquared];\n        \n        int componentCount = 0;\n        \n        for (int a = 1; a <= N; a++) {\n            for (int b = 1; b <= N; b++) {\n                int node = convertToSingleIndex(a, b);\n                if (!visited[node]) {\n                    componentCount++;\n                    dfs(a, b);\n                }\n            }\n        }\n        \n        System.out.println(componentCount);\n    }\n\n    private static int convertToSingleIndex(int a, int b) {\n        return (a - 1) * N + (b - 1);\n    }\n\n    private static void dfs(int a, int b) {\n        int node = convertToSingleIndex(a, b);\n        visited[node] = true;\n        \n        int aIndex = a - 1;\n        int bIndex = b - 1;\n        \n        for (int neighborA : graph[a]) {\n            for (int neighborB : graph[b]) {\n                int neighborNode = convertToSingleIndex(neighborA, neighborB);\n                if (!visited[neighborNode]) {\n                    dfs(neighborA, neighborB);\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 15:12:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 50\n\nint N;\nint originalGraph[MAX_N][MAX_N];\nint visited[MAX_N][MAX_N];\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nvoid dfs(int x, int y) {\n    visited[x][y] = 1;\n\n    for (int i = 0; i < N; i++) {\n        if (originalGraph[x][i]) {  // Check edge from x to i\n            for (int j = 0; j < N; j++) {\n                if (originalGraph[y][j] && !visited[i][j]) {  // Check edge from y to j\n                    dfs(i, j);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int M, u, v, components = 0;\n    scanf(\"%d %d\", &N, &M);\n\n    memset(originalGraph, 0, sizeof(originalGraph));\n    memset(visited, 0, sizeof(visited));\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &u, &v);\n        originalGraph[u - 1][v - 1] = 1;\n        originalGraph[v - 1][u - 1] = 1;\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (!visited[i][j]) {\n                dfs(i, j);\n                components++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", components);\n    return 0;\n}",
    "timestamp": "2025-08-13 15:12:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid bfs(vector<vector<int>>& pairs, vector<vector<int>>& adj, vector<vector<vector<int>>>& visited, int N, int a, int b) {\n    queue<pair<int, int>> q;\n    q.push({a, b});\n    visited[a][b] = true;\n    \n    while (!q.empty()) {\n        auto [u, v] = q.front(); q.pop();\n        for (int nu : adj[u]) {\n            for (int nv : adj[v]) {\n                if (!visited[nu][nv]) {\n                    visited[nu][nv] = true;\n                    q.push({nu, nv});\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> adj(N + 1);\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    vector<vector<vector<int>>> visited(N + 1, vector<vector<int>>(N + 1, vector<int>(N + 1, false)));\n    int components = 0;\n    \n    for (int a = 1; a <= N; a++) {\n        for (int b = 1; b <= N; b++) {\n            if (!visited[a][b]) {\n                bfs(adj, adj, visited, N, a, b);\n                components++;\n            }\n        }\n    }\n    \n    cout << components << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:12:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef count_connected_components(N, edges):\n    # Create adjacency list for original graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Track visited status for new graph vertices\n    visited = set()\n    \n    def bfs(start_vertex):\n        queue = deque([start_vertex])\n        component_visited = set([start_vertex])\n        \n        while queue:\n            curr_a, curr_b = queue.popleft()\n            \n            # Check neighbors in original graph for a and b\n            for next_a in graph[curr_a]:\n                for next_b in graph[curr_b]:\n                    next_vertex = (next_a, next_b)\n                    if next_vertex not in component_visited:\n                        queue.append(next_vertex)\n                        component_visited.add(next_vertex)\n        \n        return component_visited\n    \n    # Count connected components\n    components = 0\n    for a in range(1, N+1):\n        for b in range(1, N+1):\n            vertex = (a, b)\n            if vertex not in visited:\n                component = bfs(vertex)\n                visited.update(component)\n                components += 1\n    \n    return components\n\n# Read input\nN, M = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Solve and print result\nprint(count_connected_components(N, edges))",
    "timestamp": "2025-08-13 15:12:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        u = int(input[ptr])\n        v = int(input[ptr+1])\n        ptr += 2\n        adj[u].append(v)\n        adj[v].append(u)\n\n    parent = [i for i in range(N*N + 1)]\n    rank = [1] * (N*N + 1)\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return\n        if rank[u_root] > rank[v_root]:\n            parent[v_root] = u_root\n            rank[u_root] += rank[v_root]\n        else:\n            parent[u_root] = v_root\n            rank[v_root] += rank[u_root]\n\n    for a in range(1, N+1):\n        for b in range(1, N+1):\n            u = (a-1)*N + b\n            for a2 in adj[a]:\n                for b2 in adj[b]:\n                    v = (a2-1)*N + b2\n                    union(u, v)\n\n    components = set()\n    for a in range(1, N+1):\n        for b in range(1, N+1):\n            u = (a-1)*N + b\n            components.add(find(u))\n\n    print(len(components))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 15:12:46"
  }
]