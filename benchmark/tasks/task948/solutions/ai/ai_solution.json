[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    int count = 0;\n    for (int first = 0; first < (1 << N); first++) {\n        for (int remove = 0; remove < (1 << N); remove++) {\n            int deque[N];\n            int front = 0, rear = 0;\n            int card[N + 1];\n            int eaten[N];\n            int valid = 1;\n\n            for (int i = 1; i <= N; i++) {\n                card[i] = i;\n            }\n\n            for (int i = 0; i < N; i++) {\n                if (first & (1 << i)) {\n                    deque[rear++] = card[i + 1];\n                } else {\n                    deque[rear++] = card[N - i];\n                }\n            }\n\n            for (int i = 0; i < N; i++) {\n                if (remove & (1 << i)) {\n                    if (front >= rear) {\n                        valid = 0;\n                        break;\n                    }\n                    eaten[i] = deque[front++];\n                } else {\n                    if (front >= rear) {\n                        valid = 0;\n                        break;\n                    }\n                    eaten[i] = deque[--rear];\n                }\n            }\n\n            if (valid && eaten[K - 1] == 1) {\n                count++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count % MOD);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 2005\n\nlong long comb[MAX_N][MAX_N];\n\nvoid precompute_comb() {\n    for (int i = 0; i < MAX_N; i++) {\n        comb[i][0] = 1;\n        for (int j = 1; j <= i; j++) {\n            comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n        }\n    }\n}\n\nlong long solve(int N, int K) {\n    precompute_comb();\n    long long res = 0;\n    for (int a = K; a <= N; a++) {\n        int b = N - a + 1;\n        if (b < K) continue;\n        res = (res + comb[a-1][K-1] * comb[b-1][K-1] % MOD) % MOD;\n    }\n    return res;\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    printf(\"%lld\\n\", solve(N, K));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nlong long modpow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nlong long comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    static vector<long long> fact(1, 1), inv_fact(1, 1);\n    while (fact.size() <= n) {\n        fact.push_back(fact.back() * fact.size() % MOD);\n        inv_fact.push_back(modpow(fact.back(), MOD - 2));\n    }\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    long long ans = 0;\n    for (int m = 0; m <= N - K; ++m) {\n        ans = (ans + comb(N - K, m)) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    private static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        sc.close();\n\n        if (N == 1) {\n            System.out.println(1);\n            return;\n        }\n\n        long[][] dp = new long[N + 2][N + 2];\n        dp[0][0] = 1;\n\n        for (int len = 1; len <= N - 1; len++) {\n            for (int l = 0; l <= len; l++) {\n                int r = len - l;\n                if (l > 0) {\n                    dp[l][r] = (dp[l][r] + dp[l - 1][r]) % MOD;\n                }\n                if (r > 0) {\n                    dp[l][r] = (dp[l][r] + dp[l][r - 1]) % MOD;\n                }\n            }\n        }\n\n        long result = 0;\n        for (int l = 0; l <= K - 1; l++) {\n            int r = N - K;\n            if (l <= K - 1 && r <= N - K) {\n                result = (result + dp[l][r]) % MOD;\n            }\n        }\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:27:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class SnukeCards {\n    static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int K = Integer.parseInt(st.nextToken());\n        \n        System.out.println(solve(N, K));\n    }\n\n    static int solve(int N, int K) {\n        long result = 0;\n        \n        for (int mask = 0; mask < (1 << (2 * N)); mask++) {\n            if (Integer.bitCount(mask) != N) continue;\n            \n            Deque<Integer> deque = new ArrayDeque<>();\n            int[] card = new int[N];\n            int[] eaten = new int[N];\n            int eatenIndex = 0;\n            \n            for (int i = 1; i <= N; i++) {\n                boolean left = (mask & (1 << (i - 1))) > 0;\n                if (left) {\n                    deque.addFirst(i);\n                } else {\n                    deque.addLast(i);\n                }\n            }\n            \n            for (int i = 0; i < N; i++) {\n                boolean fromLeft = (mask & (1 << (N + i))) > 0;\n                if (fromLeft) {\n                    eaten[eatenIndex++] = deque.removeFirst();\n                } else {\n                    eaten[eatenIndex++] = deque.removeLast();\n                }\n            }\n            \n            if (eaten[K - 1] == 1) {\n                result++;\n            }\n        }\n        \n        return (int)(result % MOD);\n    }\n}",
    "timestamp": "2025-08-05 23:27:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    \n    int count = 0;\n    \n    for (int insertion_pattern = 0; insertion_pattern < (1 << (2 * N)); insertion_pattern++) {\n        deque<int> dq;\n        vector<int> sequence;\n        bool valid = true;\n        \n        for (int i = 1; i <= N; i++) {\n            int insert_side = (insertion_pattern >> (2 * (i - 1))) & 3;\n            \n            if (insert_side == 0) {\n                dq.push_front(i);\n            } else if (insert_side == 1) {\n                dq.push_back(i);\n            } else if (insert_side == 2) {\n                if (!dq.empty() && dq.front() == i) {\n                    sequence.push_back(dq.front());\n                    dq.pop_front();\n                } else {\n                    valid = false;\n                    break;\n                }\n            } else {\n                if (!dq.empty() && dq.back() == i) {\n                    sequence.push_back(dq.back());\n                    dq.pop_back();\n                } else {\n                    valid = false;\n                    break;\n                }\n            }\n        }\n        \n        if (valid && sequence.size() == N && sequence[K - 1] == 1) {\n            count++;\n        }\n    }\n    \n    cout << count % MOD << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef count_sequences(N, K):\n    # Initialize DP arrays\n    dp1 = [0] * (N + 1)  # DP for the number of sequences with the target at the start\n    dp2 = [0] * (N + 1)  # DP for the number of sequences with the target at the end\n\n    # Base Case: When 1 is in the deque by itself\n    dp1[1] = 1\n    dp2[1] = 1\n\n    # Fill DP tables\n    for n in range(2, N + 1):\n        dp1[n] = (dp1[n - 1] * (N - n + 1) + dp2[n - 1]) % MOD\n        dp2[n] = (dp2[n - 1] * (N - n + 1) + dp1[n - 1]) % MOD\n\n    # The result is the number of valid sequences with target in the K-th position\n    return dp1[N] if K == 1 else dp2[N]\n\n# Example usage:\n# N - number of cards, K - desired position of number 1\nN = 4\nK = 2\nprint(count_sequences(N, K))",
    "timestamp": "2025-08-13 15:21:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SnukeEatenCards {\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n\n        System.out.println(findSequences(N, K));\n    }\n\n    private static long findSequences(int N, int K) {\n        // dp[i][j] means the number of sequences of length i where the j-th element is 1\n        long[][] dp = new long[N + 1][N + 1];\n        dp[1][1] = 1; // Only one way to have sequence of length 1 with first element being 1\n\n        for (int i = 2; i <= N; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\n            }\n        }\n\n        return dp[N][K];\n    }\n}",
    "timestamp": "2025-08-13 15:22:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    long long dp[N+1][N+1];\n    dp[1][1] = 1;\n\n    for (int i = 2; i <= N; ++i) {\n        dp[i][1] = dp[i-1][1];\n        for (int j = 2; j <= i; ++j) {\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", dp[N][K]);\n    return 0;\n}",
    "timestamp": "2025-08-13 15:22:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    \n    vector<vector<int>> dp(N + 1, vector<int>(N + 1));\n    dp[0][0] = 1;\n    \n    for (int i = 1; i <= N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            dp[i][j] = dp[i - 1][j];\n            if (j > 0) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\n            }\n        }\n    }\n    \n    cout << dp[N][K - 1] << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 15:22:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, K):\n    MOD = 10**9 + 7\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, N + 1):\n        for j in range(i + 1):\n            if j > 0:\n                dp[i][j] += dp[i-1][j-1]\n            if j < i:\n                dp[i][j] += dp[i-1][j]\n            dp[i][j] %= MOD\n\n    result = 0\n    for insert_order in range(1 << (2 * N)):\n        if bin(insert_order).count('1') != N:\n            continue\n\n        deque = []\n        used = [False] * (N + 1)\n        valid = True\n\n        for step in range(2 * N):\n            if step < N:\n                card = step + 1\n                if insert_order & (1 << step):\n                    deque.append(card)\n                else:\n                    deque.insert(0, card)\n            else:\n                idx = step - N\n                if (insert_order & (1 << step)) and deque:\n                    eaten = deque.pop()\n                elif not (insert_order & (1 << step)) and deque:\n                    eaten = deque.pop(0)\n                else:\n                    valid = False\n                    break\n\n                if eaten == 1 and idx + 1 == K:\n                    result += 1\n                used[eaten] = True\n\n        if not valid:\n            continue\n\n        result %= MOD\n\n    return result\n\nN, K = map(int, input().split())\nprint(solve(N, K))",
    "timestamp": "2025-08-13 15:22:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N, K = map(int, sys.stdin.readline().split())\n    if K == 1 or K == N:\n        print(pow(2, N-1, MOD))\n    else:\n        res = pow(2, N - K, MOD) * pow(2, K - 2, MOD) % MOD\n        print(res)\n\nsolve()",
    "timestamp": "2025-08-13 15:22:22"
  }
]