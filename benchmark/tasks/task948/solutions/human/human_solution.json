[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e3+7,p=1e9+7;\nint n,k,f[N][N];\nint main(){\n\tcin>>n>>k,f[0][n]=1;\n\tif(n==1&&k==1) {cout<<1<<endl;}\n\tfor(int i=1;i<k;i++){\n\t\tfor(int j=1;j<=n-i+1;j++) f[i][j]=(f[i-1][n]-f[i-1][j-1]+p)%p;\n\t\tfor(int j=1;j<=n;j++) f[i][j]=(f[i][j]+f[i][j-1])%p;\n\t}\n\tint ans=(f[k-1][n]-f[k-1][1]+p)%p,c=n-k-1; while(c>0) ans=ans*2%p,c--; cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 3000;\nint dp[N][N], s[N][N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n, k;\n    cin >> n >> k;\n    int x = 1;\n    for (int j = 1; j < n - k; j++) x = (x + x) % mod;\n    for (int j = 1; j <= n - k + 1; j++){\n        dp[n - k + 1][j] = x;\n        s[n - k + 1][j] = (s[n - k + 1][j - 1] + x) % mod;\n    }\n    for (int i = n - k + 2; i <= n; i++){\n        for (int j = 1; j <= i; j++){\n            dp[i][j] = dp[i - 1][max(1LL, j - 1)];\n            dp[i][j] = (dp[i][j] + s[i - 1][i - 2] - s[i - 1][j - 1]) % mod;\n            s[i][j] = (s[i][j - 1] + dp[i][j]) % mod;\n         //   for (int l = i - j; l >= 2; l--){\n           //     dp[i][j] = (dp[i][j] + dp[i - 1][i - l]) % mod;\n         //   }\n        }\n    }\n    cout << dp[n][1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,k,f[10001],mod=1000000007;\nlong long f1(long long p)\n{\n\tif(p==0)\n\t\treturn 1;\n\tint tmp=f1(p/2)%mod;\n\ttmp=(tmp*tmp)%mod;\n\tif(p%2==1)\n\t\ttmp=(tmp*2)%mod;\n\treturn tmp;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0]=1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tfor(int j=i; j>0; j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%mod;\n\t\tf[0]=f[1];\n\t}\n\tprintf(\"%lld\",f[n-k]*f1(n-k-1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2000;\nconst int mod=1e9+7;\nint n,k,ans;\nint f[maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    f[0]=1;\n    for (int i=1;i<n;i++)\n\t{\n\t    for (int j=i;j;j--)\n\t        f[j]=(f[j+1]+f[j-1])%mod;\n\t    f[0]=(f[1]+f[0])%mod;\n\t}\n    f[n-k]=((f[n-k]-f[n-k+1])%mod+mod)%mod;\n    ans=1ll*f[n-k]*power(2,max(n-k-1,0))%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mo=1e9+7;\nint n,k,dp[2010][2010][2];\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i,j;\n\tscanf(\"%d%d\",&n,&k);\n\tdp[n][0][0]=1;\n\tfor (i=n;i>=1;i--)\n\t{\n\t\tfor (j=n;j>=0;j--)\n\t\t\t(dp[i][j][1]+=dp[i][j+1][1])%=mo;\n\t\tfor (j=0;j<=n;j++)\n\t\t{\n\t\t\t(dp[i-1][j+1][0]+=dp[i][j][0])%=mo;\n\t\t\t(dp[i-1][j+1][0]+=dp[i][j][1])%=mo;\n\t\t\t(dp[i-1][j][1]+=dp[i][j][0])%=mo;\n\t\t\t(dp[i-1][j][1]+=dp[i][j][1])%=mo;\n\t\t}\n\t}\n\tint Ans=(dp[1][n-k][0]+dp[1][n-k][1])%mo;\n\tfor (i=1;i<n-k;i++) Ans=(Ans+Ans)%mo;\n\tprintf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define N 2010\n#define mod 1000000007\nusing namespace std;\nint f[N];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tf[n+1]=1;\n\tfor(int i=1;i<=m-1;i++)\n\t\tfor(int j=n-i+1;j>=2;j--)\n\t\t\tf[j]=(f[j]+f[j+1])%mod;\n    int ans=0;\n\tfor(int i=2;i<=n-m+2;i++) (ans+=f[i])%=mod;\n\tif(m==1) ans=1;\n\tfor(int i=1;i<=n-m-1;i++) ans=2ll*ans%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n#define drp(i,st,ed) for (int i=st;i>=ed;--i)\n\nconst int MOD=1e9+7;\nconst int N=4005;\n\nint f[N][N],s[N][N];\n\nint add(int x,int y) {\n\tx+=y; (x>=MOD)?(x-=MOD):0;\n\treturn x;\n}\n\nint dec(int x,int y) {\n\tx+=MOD-y; (x>=MOD)?(x-=MOD):0;\n\treturn x;\n}\n\nint ksm(int x,int dep) {\n\tint res=1;\n\tfor (;dep;dep>>=1,x=1LL*x*x%MOD) {\n\t\t(dep&1)?(res=1LL*res*x%MOD):0;\n\t}\n\treturn res;\n}\n\nint main(void) {\n\tint n,k; scanf(\"%d%d\",&n,&k);\n\tf[0][n+1]=1;\n\tdrp(j,n+1,1) s[0][j]=add(s[0][j+1],f[0][j]);\n\trep(i,1,k) {\n\t\trep(j,1,n-i+1) f[i][j]=s[i-1][j];\n\t\tdrp(j,n+1,1) s[i][j]=add(s[i][j+1],f[i][j]);\n\t}\n\tint ans=dec(f[k][1],f[k-1][1]);\n\tans=ans*ksm(2,n-k-1)%MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 29.12.2019 21:06:20       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  if (n == 1) { cout << 1 << '\\n';return 0;}\n  vector<vector<Mint>> C(n + 1, vector<Mint>(n + 1));\n  for (int i = 0; i <= n; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++) C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n  }\n  vector<vector<Mint>> dp(n + 1, vector<Mint>(n + 1));\n  dp[1][1] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int j = 1; j <= i; j++) {\n      dp[i + 1][j + 1] += dp[i][j];\n    }\n    Mint sum = 0;\n    for (int k = i; k >= 1; k--) {\n      sum += dp[i][k];\n      dp[i + 1][k] += sum;\n    }\n/*      for (int k = 0; k <= i; k++) {\n        if (k > j) {\n          continue;\n        }\n        if (k == 0) {\n        } else {\n          dp[i + 1][k] += dp[i][j];\n        }\n      }*/\n//    }\n  }\n  Mint ans = 0;\n/*  for (int j = 0; j <= n; j++) {\n    ans += dp[k - 1][j];\n  }\n  if (k == 1) ans += 1;\n  ans *= C[n - 1][k - 1] * (k == n ? 1 : power(Mint(2), n - k - 1));*/\n  for (int j = 1; j <= k - 1; j++) {\n    Mint cur = dp[k - 1][j];\n    cur *= C[j + (n - k)][n - k];\n    cur *= (k == n ? 1 : power(Mint(2), n - k - 1));\n//    debug(j, cur);\n    ans += cur;\n  }\n  if (k == 1) ans = power(Mint(2), n - 2);\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, ll> pil;\ntypedef pair<int, ll> pli;\ntypedef pair<double,double> pdd;\n#define SQ(i) ((i)*(i))\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define SZ(i) int(i.size())\n#define FOR(i, j, k, in) for (int i=j ; i<k ; i+=in)\n#define RFOR(i, j, k, in) for (int i=j ; i>=k ; i-=in)\n#define REP(i, j) FOR(i, 0, j, 1)\n#define REP1(i,j) FOR(i, 1, j+1, 1)\n#define RREP(i, j) RFOR(i, j, 0, 1)\n#define ALL(_a) _a.begin(),_a.end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n#ifdef tmd\n#define TIME(i) Timer i(#i)\n#define debug(...) do{\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\" ,\";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,deque<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define TIME(i)\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n#endif\nclass Timer {\nprivate:\n    string scope_name;\n    chrono::high_resolution_clock::time_point start_time;\npublic:\n    Timer (string name) : scope_name(name) {\n        start_time = chrono::high_resolution_clock::now();\n    }\n    ~Timer () {\n        auto stop_time = chrono::high_resolution_clock::now();\n        auto length = chrono::duration_cast<chrono::microseconds>(stop_time - start_time).count();\n        double mlength = double(length) * 0.001;\n        debug(scope_name, mlength);\n    }\n};\n\nconst ll MOD = 1000000007;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int iNF = 0x3f3f3f3f;\nconst ll MAXN = 2003;\n\nint n, k;\nll dp[MAXN][MAXN];\n/********** Good Luck :) **********/\nint main () {\n    TIME(main);\n    IOS();\n\n    cin >> n >> k;\n    if (k == 1) {\n        ll ans = 1;\n        REP (i, n-2) {\n            (ans <<= 1) %= MOD;\n        }\n        cout << ans << endl;\n    } else {\n        dp[0][n+1] = 1;\n        REP1 (i, k-1) {\n            ll pre = 0;\n            for (int j=n; j>=2; j--) {\n                (pre += dp[i-1][j+1]) %= MOD;\n                dp[i][j] = (pre + (n-j+1>=i?dp[i-1][j]:0)) % MOD;\n            }\n        }\n        ll ans = 0;\n        pary(dp[k-1], dp[k-1]+n+1);\n        REP1 (i, n) {\n            (ans += dp[k-1][i]) %= MOD;\n        }\n        debug(ans);\n        REP (i, n-k-1) {\n            (ans <<= 1) %= MOD;\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= MOD;\n\tif(k%2 == 1){\n\t\tret *= x;\n\t\tret %= MOD;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tll n,k;\n\tcin >> n >> k;\n\t\n\tll dp[2][2002] = {};\n\tll t = 0, t_ = 1;\n\tdp[t][1] = 1;\n\tfor(int i = k-1 ; i >= 1 ; i --){\n\t\tfor(int j = 1 ; j <= n-i ; j ++){\n\t\t\tdp[t_][j] = dp[t_][j-1]+dp[t][j];\n\t\t\tif(dp[t_][j] >= MOD)dp[t_][j] -= MOD;\n\t\t}\n\t\tswap(t,t_);\n\t}\n\tll ret = 0;\n\tfor(int i = 0 ; i < 2002 ; i ++){\n\t\tret += dp[t][i];\n\t}\n\tret %= MOD;\n\tif(k < n){\n\t\tret *= modpow(2,n-k-1);\n\t\tret %= MOD;\n\t}\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define ll long long \nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2010;\nint n,K;\nll dp[maxn][maxn],sum[maxn];\nint main() \n{\n\tscanf(\"%d%d\",&n,&K);\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;++i) sum[i]=1;\n\tfor(int i=1;i<=K;++i) {\n\t\tfor(int j=i;j<=n;++j) {\n\t\t\tif(j!=n)\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tdp[i][j]=(dp[i][j]+sum[j-1])%mod;\n\t\t}sum[0]=dp[i][0];\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tsum[j]=(sum[j-1]+dp[i][j])%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=n-K-1;++i) dp[K][n]=dp[K][n]*2%mod;\n\tcout<<dp[K][n]<<\"\\n\";\n\treturn 0;\n} \n/**/\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=1e9+7,N=2005;\nint n,k,dp[N][N];\ninline int ksm(int x,int y)\n{\n\tint gg=1ll;\n\twhile(y)\n\t{\n\t\tif(y&1)(gg*=x)%=mod;\n\t\t(x*=x)%=mod;  y>>=1ll;\n\t}\n\treturn gg;\n}\nsigned main(signed argc, char const *argv[])\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>k;\n\tdp[0][n+1]=1ll;\n\tfor(signed i=1;i<=k;i++)\n\t{\n\t\tint sum=dp[i-1][n+1];\n\t\tfor(signed j=n;j>=1;j--)\n\t\t{\n\t\t\t(sum+=dp[i-1][j])%=mod;\n\t\t\tif(j<=n-i+1)dp[i][j]=sum;\n\t\t}\n\t}\n\tint res=(dp[k][1]-dp[k-1][1]+mod)%mod;\n\tcout<<res*ksm(2,n-k-1)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=2000+19;\nconst int p=1e9+7;\n\nint Pow(int a,int b){\n\tint res=1;\n\tfor (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;\n\treturn res;\n}\n\nint f[N][N],g[N][N],C[N][N];\nint n,K,res;\n\nint main(){\n\tFor(i,0,N){\n\t\tC[i][0]=1;\n\t\tFor(j,1,i+1) C[i][j]=(C[i-1][j-1]+C[i-1][j])%p;\n\t}\n\tn=IN(),K=IN();\n\tif (n==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tif (K==1){\n\t\tprintf(\"%d\\n\",Pow(2,n-2));\n\t\treturn 0;\n\t}\n\tf[1][2]=1;\n\tFor(i,1,K){\n\t\tFor(j,1,N){\n\t\t\tg[i][j]=(g[i][j-1]+f[i][j])%p;\n\t\t}\n\t\tfor (int j=1;j<=i+1;j++){\n\t\t\tf[i+1][j+1]=(f[i+1][j+1]+f[i][j])%p;\n\t\t}\n\t\tfor (int k=2;k<=i+1;k++){\n\t\t\tf[i+1][k]=(0ll+f[i+1][k]+g[i][i+1]-g[i][k-1]+p)%p;\n\t\t}\n\t}\n\tif (n==K){\n\t\tres=1ll*C[n-2][K-1]*f[K-1][K]%p;\n\t\tres=(res+1ll*C[n-2][K-2]*f[K-1][K])%p;\n\t\tFor(i,2,K){\n\t\t\tres=(res+1ll*C[n-2][K-2]*f[K-1][i])%p;\n\t\t}\n\t} else{\n\t\tres=1ll*C[n-2][K-1]*f[K-1][K]%p*Pow(2,n-K-1)%p;\n\t\tres=(res+1ll*C[n-2][K-2]*f[K-1][K]%p*Pow(2,n-K-1))%p;\n\t\tFor(i,2,K){\n\t\t\tres=(res+1ll*C[i-1+n-K][i-1]*f[K-1][i]%p*Pow(2,n-K-1))%p;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define rep(i,s,t) for(int i=s;i<=t;i++)\n#define dwn(i,s,t) for(int i=s;i>=t;i--)\nusing namespace std;\nconst int mod=1000000007;\nint n,k,f[2010];\nint main() {\n\tscanf(\"%d%d\",&n,&k);f[1]=1;\n\tdwn(i,n-1,1) dwn(j,n-i+1,1) f[j]=(f[j+1]+f[j-1])%mod;\n\tint ans=f[n-k+1];\n\trep(i,1,n-k-1) ans=(ans+ans)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nmint Catalan(int n){\n\treturn Choose(n+n,n)/(n+1);\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\tInitFact(10000);\n\n\tint N,K; cin >> N >> K; K--;\n\n\tV<mint> dp = {1};\n\trep(i,K){\n\t\tV<mint> ndp(i+2);\n\t\trep(x,i+1){\n\t\t\tndp[x+1] += dp[x];\n//\t\t\trep1(v,x) ndp[v] += dp[x];\n\t\t}\n\t\tmint s = 0;\n\t\tper1(x,i){\n\t\t\ts += dp[x];\n\t\t\tndp[x] += s;\n\t\t}\n\t\tswap(dp,ndp);\n\t}\n\n\tmint ans = 0;\n\trep(x,K+1){\n\t\tans += dp[x] * Choose(x+N-1-K,x);\n\t}\n\tans *= mint(2).pow(N-1-K);\n\tif(K != N-1) ans /= 2;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t data;\n    mint() = default;\n    mint(int64_t value) : data(value) {}\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->data + other.data; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->data * int64_t(other.data) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->data += other.data; if (this->data >= MOD) this->data -= MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->data = this->data * int64_t(other.data) % MOD; if (this->data < 0) this->data += MOD; return *this; }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this;\n        mint<MOD> y = 1;\n        for (uint64_t i = 1; i and (i <= k); i <<= 1) {\n            if (k & i) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n};\n\nconstexpr int MOD = 1e9 + 7;\n\nmint<MOD> solve(int n, int k) {\n    auto dp = vectors(k + 1, n + 1, mint<MOD>());\n    dp[0][0] = 1;\n    REP (i, k) {\n        mint<MOD> acc = 0;\n        REP3 (j, 1, n + 1) {\n            acc += dp[i][j - 1];\n            dp[i + 1][j] += acc;  // extend the primary chain\n            if (j > i and j != n) {\n                dp[i + 1][j] += dp[i][j];  // extend the secondary chain\n            }\n        }\n    }\n    return dp[k][n] * mint<MOD>(2).pow(n - k - 1);\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    cout << solve(n, k).data << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nvoid read(int &x) {\n\tchar ch; bool ok;\n\tfor(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;\n\tfor(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;\n}\n#define rg register\nconst int maxn=1e5+10,mod=1e9+7;\nint n,k,fac[maxn],inv[maxn],ans,las;\nint mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint del(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mi(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=mul(ans,a);\n\t\tb>>=1,a=mul(a,a);\n\t}\n\treturn ans;\n}\nint c(int x,int y){return mul(fac[x],mul(inv[y],inv[x-y]));}\nint main(){\n\tread(n),read(k);fac[0]=inv[0]=1;\n\tfor(rg int i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tinv[n]=mi(fac[n],mod-2);\n\tfor(rg int i=n-1;i;i--)inv[i]=mul(inv[i+1],i+1);\n\tfor(rg int i=1;i<=k;i++)\n\t{\n\t\tif(i>1)ans=del(ans,las);\n\t\tans=add(ans,las=mul(c(n-1,i-1),mul(c(k-1,i-1),mi(2,n-k-1))));\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int INF=0x3f3f3f3f;\nconst int maxn=2e3+7;\nconst int mod=1e9+7;\nll quick(ll a,ll b)\n{\n\tif(b<0) return 1;\n\tll ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nll dp[maxn][maxn];\nint main()\n{\n\tint n,k;\n\tcin>>n>>k;\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tvc<ll> suf(n+3);\n\t\tfor(int j=n+1;j>=1;j--)\n\t\t\tsuf[j]=(suf[j+1]+dp[i-1][j])%mod;\n\t\tfor(int j=1;j<=n-i+1;j++)\n\t\t{\n\t\t\tif(i==k) dp[i][j]=suf[j+1];\n\t\t\telse\n\t\t\t\tdp[i][j]=(dp[i-1][j]+suf[j+1])%mod;\n\t\t\t//dbg(i,j,dp[i][j]);\n\t\t}\n\t}\n\tcout<<dp[k][1]*quick(2,n-k-1)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\nint power(int x,int y)\n{\n\tif(y<0)return 0;\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nint getcomb(int x,int y)\n{\n\tif(x<y||y<0)return 0;\n\tint ret=1;\n\tfor(int i=1;i<=y;i++)ret=1ll*ret*(x-i+1)%mod*power(i,mod-2)%mod;\n\treturn ret;\n}\nint n,k;\nint main()\n{\n\tget2(n,k);\n\tprintendl(1ll*(getcomb(n+k-2,k-1)-getcomb(n+k-2,k-2)+mod)*power(2,max(0,n-k-1))%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,k,f[10001],mod=1000000007;\nlong long f1(long long p)\n{\n\tif(p==0)\n\t\treturn 1;\n\tlong long tmp=f1(p/2)%mod;\n\ttmp=(tmp*tmp)%mod;\n\tif(p%2==1)\n\t\ttmp=(tmp*2)%mod;\n\treturn tmp;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0]=1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tfor(int j=i; j>0; j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%mod;\n\t\tf[0]=f[1];\n\t}\n\tprintf(\"%lld\",f[n-k]*f1(n-k-1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=2005;\nconst int mod=1e9+7;\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\t\n}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nint f[MAXN][MAXN],g[MAXN],n,K;\nint pre[MAXN],inv[MAXN];\nint C(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN-1]=pow_mod(pre[MAXN-1],mod-2);\n\tfor(int i=MAXN-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();K=read();\n\tif(K==1)\n\t{\n\t\tif(n>=2)return pr2(pow_mod(2,n-2)),0;\n\t\treturn pr2(1),0;\n\t}\n\tfor(int i=n;i>=2;i--)f[i][1]=1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=1;j<=(n-i+1);j++)if(f[i][j])\n\t\t{\n\t\t\tad(f[i][j],g[j]);\n\t\t\tif((n-i+1)-j)ad(f[i][j+1],f[i][j]);\n\t\t}\n\t\tfor(int j=1;j<=(n-i+1);j++)ad(g[j+1],f[i][j]);\n\t}int ans=0;\n\tfor(int i=n;i>=1;i--)ad(ans,f[i][K-1]);\n\tif(K!=n)ans=1LL*ans*pow_mod(2,n-K-1)%mod;\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,k,f[10001],mod=1000000007;\nlong long f1(long long p)\n{\n\tif(p==0)\n\t\treturn 1;\n\tint tmp=f1(p/2)%mod;\n\ttmp=(tmp*tmp)%mod;\n\tif(p%2==1)\n\t\ttmp=(tmp*2)%mod;\n\treturn tmp;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0]=1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tfor(int j=i; j>0; j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%mod;\n\t\tf[0]=f[1];\n\t}\n\tprintf(\"%lld\",f[n-k]*f1(n-k-1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,k;\n  cin>>n>>k;\n  using M = Mint<int>;\n  vector<M> dp(n+1,0);\n  dp[0]=M(1);\n  for(int i=0;i<k-1;i++){\n    for(int j=1;j<=n;j++) dp[j]+=dp[j-1];\n    dp[i]=M(0);    \n  }\n  M ans;\n  for(int i=0;i<n;i++) ans+=dp[i];\n  ans*=M(2).pow(n==k?0:n-k-1);\n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n\tstatic long long comb[2001][2001];\n\tstatic long long pow2[2001];\n\tmemset(comb, 0, sizeof(comb));\n\tcomb[0][0] = 1;\n\tfor(int i=1;i<=2000;i++){\n\t\tcomb[i][0] = 1;\n\t\tfor(int j=1;j<i;j++) comb[i][j] = (comb[i-1][j] + comb[i-1][j-1])%MOD;\n\t\tcomb[i][i] = 1;\n\t}\n\tpow2[0] = 1;\n\tfor(int i=1;i<=2000;i++) pow2[i] = (pow2[i-1]*2)%MOD;\n\tstatic long long dp[2][2010][2010];\n\tmemset(dp, 0, sizeof(dp));\n\tfor(int i=0;i<=2000;i++){\n\t\tfor(int j=0;j<=2000;j++){\n\t\t\tif(i==0 && j==0){\n\t\t\t\tdp[0][i][j] = 1;\n\t\t\t\tdp[1][i][j] = 0;\n\t\t\t} else {\n\t\t\t\tif(i > 0) dp[0][i][j] = (dp[0][i][j] + dp[0][i-1][j]) % MOD;\n\t\t\t\tif(i > 0) dp[0][i][j] = (dp[0][i][j] + dp[1][i-1][j]) % MOD;\n\t\t\t\tif(j > 0) dp[0][i][j] = (dp[0][i][j] + dp[0][i][j-1]) % MOD;\n\t\t\t\tif(i > 0) dp[1][i][j] = (dp[1][i][j] + dp[0][i-1][j+1]) % MOD;\n\t\t\t\tif(i > 0) dp[1][i][j] = (dp[1][i][j] + dp[1][i-1][j+1]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tint N, K;\n\twhile(cin >> N >> K){\n\t\tlong long res = 0;\n\t\tfor(int end=N-K+1;end<=N;end++){\n\t\t\tint all = end-1;\n\t\t\tint sel = N-K;\n\t\t\tlong long add = (sel > 0 ? comb[all-1][sel-1] * pow2[sel-1] % MOD : 1);\n\t\t\tint b = end-(N-K+1);\n\t\t\tint r = K-1-b;\n\t\t\tadd = (add * dp[0][r][b]) % MOD;\n\t\t\tres = (res + add) % MOD;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int p=1e9+7;\nconst int maxn=1e5+5;\nll n,k,f[maxn],ans;\nll quickpow(ll a,ll t)\n{\n\tif(!t) return 1;\n\tll res=1;\n\twhile(t)\n\t{\n\t\tif(t&1) res=(res*a)%p;\n\t\ta=(a*a)%p;\n\t\tt>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0]=1;\n\tfor(ll i=1;i<n;i++)\n\t{\n\t\tfor(ll j=i;j>0;j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%p;\n\t\tf[0]=f[1];\n\t}\n\tans=(f[n-k]*quickpow(2,n-k-1))%p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll _v) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M(0) - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return (*this).pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<1000000007>;\n\nconst int MN = 2333;\nint n, k;\nMint dp[MN], ndp[MN];\nMint two[MN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    two[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        two[i] = Mint(2) * two[i - 1];\n    }\n\n    cin >> n >> k;\n    if (n == 1) {\n        cout << 1 << \"\\n\";\n        return 0;\n    }\n    if (k == 1) {\n        cout << two[n - 2] << \"\\n\";\n        return 0;\n    }\n    fill(dp + 2, dp + n + 1, 1);\n    for (int i = 1; i < k - 1; i++) {\n        copy(dp + 2, dp + n - i + 2, ndp + 2);\n        for (int j = n - i; j >= 2; j--) {\n            ndp[j] += ndp[j + 1];\n        }\n        copy(ndp + 2, ndp + n - i + 1, dp + 2);\n    }\n\n    Mint ans = accumulate(dp + 2, dp + n - k + 3, Mint(0));\n    ans *= two[max(0, n - k - 1)];\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#define maxn 20005\n#define mod 1000000007\nusing namespace std;\nlong long n, k;\nlong long f[maxn];\n\nlong long pow(long long x, long long k) {\n\tif(k < 0) return 1;\n\tlong long res = 1ll;\n\twhile(k) {\n\t\tif(k & 1) res = (long long)(res * x) % mod;\n\t\tx = (long long)(x * x) % mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tf[0] = 1ll;\n\tscanf(\"%lld%lld\", &n, &k);\n\tfor(int i = 1; i < n; i ++) {\n\t\tfor(int j = i; j; j --)\n\t\t\tf[j] = (long long)(f[j + 1] + f[j - 1]) % mod;\n\t\tf[0] = f[1];\n\t}\n\tprintf(\"%lld\\n\", (long long)f[n - k] * pow(2ll, n - k - 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "/* Generated by powerful Codeforces Tool\n * You can download the binary file in here https://github.com/xalanq/cf-tool (win, osx, linux)\n * Author: step_by_step\n * Time: 2020-03-19 17:35:03\n**/\n\n//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n  \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define prev fhsgfhjf\n#define plus fsghsf\n#define minus ytryr\n  \nusing namespace std;\n  \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n  \nconst int N = 2000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nint dp[N + 1][N + 1];\nint sum[N + 1];\n\nint main()\n{\n    //freopen(\"circus.in\", \"r\", stdin);\n    //freopen(\"circus.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n, k;\n    cin >> n >> k;\n    dp[0][0] = 1;\n    rep(i, 0, n + 1) { // number of core items, number i+1 is not present\n        rep(j, 0, n - i + 1) { // length of tail\n            if (i == 0 && j == 0) {\n                continue;\n            }\n            int alr = n - i - j;\n            if (alr == k - 1) {\n                // need to put 1\n                if (i != 0) {\n                    add(dp[i][j], dp[0][j + (i - 1)]);\n                }\n            } else {\n                if (j > 0) {\n                    add(dp[i][j], dp[i][j - 1]);\n                    if (i == 0 && j > 1) {\n                        add(dp[i][j], dp[i][j - 1]);\n                    }\n                }\n                /*rep(t, 2, i + 1) {\n                    add(dp[i][j], dp[t - 1][j + (i - t)]);\n                }*/\n                add(dp[i][j], sum[i + j - 1]);\n            }\n        }\n        if (i > 0) {\n            rep(j, 0, n - i + 1) {\n                add(sum[i + j], dp[i][j]);\n            }\n        }\n    }\n    cout << dp[n][0] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll int64_t\n\n// the resulting sequence after putting N cards looks like a valley, where 1 is the bottom number\n// and the sequence that we have to construct is made of two decreasing sequences\n// let dp[i][j] = # ways to construct the two chains, where the first i positions is determined, and the minimum is j\n// a0         a_n-1\n// \ta1      ...\n//   a2    a_k+1\n//    a3  a_k\n//     ...\n//      1\n\nconst ll mod=1e9+7;\nconst int N=2005;\nint n,k;\nll dp[N][N];\n\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>k;\n\tdp[0][0]=1;\n\tfor(int i=0;i<k;++i){\n\t\tll sum=0;\n\t\tfor(int j=1;j<=n;++j){\n\t\t\t(sum+=dp[i][j-1])%=mod;\n\t\t\t(dp[i+1][j]+=sum)%=mod;\n\t\t\tif(j>i&&j!=n) (dp[i+1][j]+=dp[i][j])%=mod;\n\t\t}\n\t}\n\tll res=dp[k][n];\n\tfor(int i=0;i<n-k-1;++i)\n\t\tres=res*2LL%mod;\n\tcout<<res<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (2009)\n#define MOD (1000000007)\nusing namespace std;\n\nint n,k,ans,f[N][N],s[N];\n\nint main()\n{\n\tcin>>n>>k;\n\tif (k==1) {puts(\"1\"); return 0;}\n\tfor (int i=2; i<=n; ++i) f[1][i]=1;\n\tfor (int i=n; i>=1; --i) s[i]=s[i+1]+f[1][i];\n\tfor (int i=2; i<=k-1; ++i)\n\t{\n\t\tfor (int j=1; j<=n-i+1; ++j) f[i][j]=s[j];\n\t\ts[n]=f[i][n];\n\t\tfor (int j=n; j>=1; --j) s[j]=(s[j+1]+f[i][j])%MOD;\n\t}\n\tfor (int i=2; i<=n; ++i) (ans+=f[k-1][i])%=MOD;\n\tfor (int i=1; i<=n-k-1; ++i) (ans*=2)%=MOD; \n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nusing mint = mod_int<>;\n\ntemplate<typename M>\nstruct fenwick_tree {\n    using T = typename M::T;\n    int n;\n    std::vector<T> data;\n    fenwick_tree(int n) : n(n), data(n + 1, M::id()) {}\n    void add(int i, const T &x) { for (i++; i <= n; i += i & -i) { data[i] = M::op(data[i], x); }}\n    T get_sum(int i) const {\n        T ret = M::id();\n        for (; i > 0; i -= i & -i) { ret = M::op(ret, data[i]); }\n        return ret;\n    }\n    T get_sum(int l, int r) const {\n        return M::op(get_sum(r), M::inv(get_sum(l)));\n    }\n};\n\nstruct rsq {\n    using T = mint;\n    static T id() { return 0; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static T inv(const T &a) { return -a; }\n};\n\nsigned main() {\n    int N, K;\n    cin >> N >> K;\n    vector dp(N + 10, fenwick_tree<rsq>(N + 10));\n    dp[0].add(N, 1);\n    reps(i, K - 1) {\n        reps(j, N - i) {\n            dp[i].add(j, dp[i - 1].get_sum(j, N + 1));\n        }\n    }\n    mint ans = dp[K - 1].get_sum(0, N + 1);\n    if (N != K) { ans *= mint(2).pow(N - K - 1); }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010,Mod=1e9+7;\nint f[N][N];\nint qpow(int a,int b){int ret=1;while(b){if(b&1)ret=1ll*ret*a%Mod;b>>=1;a=1ll*a*a%Mod;}return ret;}\nint n,k;\nint main(){\n\tn=gi();k=gi();\n\tf[0][n+1]=1;\n\tfor(int i=1;i<k;i++){\n\t\tint sum=f[i-1][n-i+2];\n\t\tfor(int j=n-i+1;j>=2;j--){\n\t\t\tsum=(sum+f[i-1][j])%Mod;\n\t\t\tf[i][j]=sum;\n\t\t}\n\t}\n\tint sum=0;\n\tfor(int i=2;i<=n-k+2;i++)sum=(sum+f[k-1][i])%Mod;\n\tif(k==1)sum=1;\n\tprintf(\"%lld\\n\",1ll*qpow(2,max(0,n-k-1))*sum%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 29.12.2019 21:06:20       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  if (n == 1) {\n    cout << 1 << '\\n';\n    return 0;\n  }\n  vector<Mint> fact(2 * n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= 2 * n; i++) {\n    fact[i] = fact[i - 1] * i;\n  }\n  vector<Mint> inv_fact(2 * n + 1);\n  inv_fact[n] = 1 / fact[n];\n  for (int i = n - 1; i >= 0; i--) {\n    inv_fact[i] = inv_fact[i + 1] * (i + 1);\n  }\n  Mint ans = 0;\n  for (int j = 0; j < k - 1; j++) {\n    ans += fact[k - 2 + j] * inv_fact[j] * fact[n - 1 - j] * inv_fact[k - 2 - j];\n  }\n  ans *= inv_fact[k - 1] * inv_fact[n - k];\n  ans *= (k == n ? 1 : power(Mint(2), n - k - 1));\n  if (k == 1) {\n    ans = power(Mint(2), n - 2);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nconst in mdl=1000000007;\nVVI wy;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n,k;\n  cin>>n>>k;\n  wy.resize(k+1,VI(n+1,0));\n  wy[0][n]=1;\n  for(in i=1;i<=k;++i){\n    for(in j=n-1;j>=0;--j){\n      wy[i][j]=wy[i][j+1]+wy[i-1][j+1];\n    }\n    forn(j,n){\n      if(n-j>=i)\n\twy[i][j]+=wy[i-1][j];\n      wy[i][j]%=mdl;\n    }\n    if(i<k){\n      wy[i][0]=0;\n    }\n  }\n  in rs=wy[k][0];\n  if(k<n){\n    forn(z,n-k-1){\n      rs*=2;\n      rs%=mdl;\n    }\n  }\n  cout<<rs<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 2000\n#define P 1000000007\nusing namespace std;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nint n, m, f[2][MAX_N+5];\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n+1; i++) f[0][i] = 1;\n\tfor (int i = 1, c = 1; i < m; i++, c ^= 1) {\n\t\tmemset(f[c], 0, sizeof f[c]);\n\t\tfor (int j = 1; j <= n-i+1; j++) f[c][j] = f[c^1][j];\n\t\tfor (int j = n; j; j--) f[c][j] = (f[c][j]+f[c][j+1])%P;\n\t}\n\tint ans = f[(m-1)&1][2];\n\tfor (int i = 1; i <= n-m-1; i++)\n\t\tans = (ans<<1)%P;\n\treturn printf(\"%d\\n\", ans), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2010, mod = 1e9 + 7;\ntypedef long long LL;\n\ninline int Pow(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n\treturn res;\n}\n\nint dp[N][N], g[N][N];\n\ninline void Inc(int &x, int y) {\n\tx += y, x -= x >= mod ? mod : 0;\n}\n\nint main() {\n\tint n, k; scanf(\"%d%d\", &n, &k), dp[0][n + 1] = g[0][n + 1] = 1;\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tdp[i][j] = g[i - 1][n + 1] - g[i - 1][j] + mod, Inc(dp[i][j], 0);\n\t\t\tif (i - 1 < n - j + 1) Inc(dp[i][j], dp[i - 1][j]); \n\t\t}\n\t\tfor (int j = 1; j <= n + 1; j++) \n\t\t\tg[i][j] = g[i][j - 1] + dp[i][j], Inc(g[i][j], 0);\n\t}\n\tprintf(\"%d\\n\", (LL)(dp[k][1] - dp[k - 1][1] + mod) * Pow(2, n - k - 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll n,k;\nll f[2002][2002],s[2005],ans;\ninline ll fpow(ll b,ll p,ll mod)\n{\n\tll ans=1,tmp=b;\n\twhile(p)\n\t{\n\t\tif(p&1)ans=ans*tmp%mod;\n\t\ttmp=tmp*tmp%mod;\n\t\tp>>=1;\n\t}\n\treturn ans%mod;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0][n+1]=1;\t\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=n+1;j;j--)\n\t\t\ts[j]=(s[j+1]+f[i-1][j])%mod,f[i][j]=(j<=n-i+1)?s[j]:0;\n\tans=(f[k][1]-f[k-1][1]+mod)%mod;\n\tprintf(\"%lld\\n\",ans*fpow(2,n-k-1,mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 2100;\nconst ll MOD = 1e9 + 7;\n\nint N, K;\nll dp[MAXN][MAXN]; // my loc / loc + # of people left above me\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N >> K;\n    dp[N][N] = 1;\n    for (int i = N; i >= 1; i--)\n    {\n        ll ctot = 0;\n        for (int j = i; j >= 0; j--)\n        {\n            ctot += dp[j][i];\n            dp[j][i-1] = ctot % MOD;\n        }\n    }\n\n    int cloc = N - K + 1;\n    ll ans = dp[0][cloc-1] - dp[0][cloc] + MOD;\n    for (int i = 0; i < cloc - 2; i++)\n        ans = (ans * 2) % MOD;\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2000 +10;\nconst long long mod = (long long)1000000007;\nint read(){\n\tint x=0,flag=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*flag;\n}\nint n,k;\nlong long f[maxn][maxn],g[maxn][maxn],h[maxn];\nlong long Pow(long long x,int t){\n\tif( t < 0 )return 1LL;\n\tlong long ans = 1LL;\n\twhile(t){\n\t\tif(t&1)ans=ans*x%mod;\n\t\tx=x*x%mod;t>>=1;\n\t}\n\treturn ans%mod;\n}\nlong long Add(long long x,long long y){\n\tif( x + y >= mod) return x + y - mod;\n\treturn x +y;\n}\nint main(){\n\n//\tfreopen(\"test.in\",\"r\",stdin),freopen(\"test.out\",\"w\",stdout);\n\tn=read();k=read();\t\n\tf[1][n-k]=Pow(2LL,n-k-1);\n\tg[1][0]=f[1][0];\n\tfor(int j=1;j<=n;j++)g[1][j] = Add( g[1][j-1] , f[1][j] );\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=0;n-i>=j;j++){\n\t\t\tf[i][j] = Add( f[i-1][j+1] , g[i-1][j] ) ;\n\t\t\tg[i][j] = Add( g[i][j-1] , f[i][j] );\n\t\t}\n\t}\n\tcout << f[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=2020,mo=1e9+7;\n\nll f[N][N][2];\n\nint n,k,l,o,p;\n\nint main()\n{\n\tcin>>n>>k;\n\tf[n][0][1]=f[n][1][2]=1;\n\tfd(i,n-1,1){\n\t\tfd(l,n,0)f[i+1][l][1]=(f[i+1][l][1]+f[i+1][l+1][1])%mo;\n\t\tfo(l,0,n){\n\t\t\tf[i][l+1][2]=(f[i][l+1][2]+f[i+1][l][2]+f[i+1][l][1])%mo;\n\t\t\tf[i][l][1]=(f[i][l][1]+f[i+1][l][1]+f[i+1][l][2])%mo;\n\t\t}\n\t}\n\tll ans=f[1][n-k][1];\n\tfo(i,1,n-k-1)ans=ans*2%mo;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mo = 1e9 + 7, MAXN = 1e5 + 10;\ntemplate <class T>\ninline void _read(T &x)\n{\n\tx = 0;\n\tchar t = getchar();\n\twhile (!isdigit(t) && t != '-') t = getchar();\n\tif (t == '-')\n\t{\n\t\t_read(x);\n\t\tx *= -1;\n\t\treturn ;\n\t}\n\twhile (isdigit(t))\n\t{\n\t\tx = x * 10 + t - '0';\n\t\tt = getchar();\n\t}\n}\nll n, k, f[MAXN];\ninline ll fpm(ll a, ll b = mo - 2)\n{\n\tif (b < 0) return 1;\n\tll res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) res = res * a % mo;\n\t\ta = a * a % mo;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\t_read(n), _read(k);\n\tf[0] = 1ll;\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tfor(int j = i; j; --j)f[j] = (f[j + 1] + f[j - 1]) % mo;\n\t\tf[0] = f[1];\n\t}\n\tprintf(\"%lld\", f[n - k] * fpm(2, n - k - 1) % mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc() {\n    // return getchar();\n    static char buf[100000], *l = buf, *r = buf;\n    return l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x) {\n    x = 0; int f = 1, ch = nc();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n    while(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n    x *= f;\n}\ntypedef long long LL;\nconst int mod = 1e9 + 7;\nconst int maxn = 2000 + 50;\nint n, k;\nint f[maxn][maxn][2];\ninline int add(int x) {return x >= mod ? x - mod : x;}\nLL power(LL x, LL y) {\n    LL re = 1;\n    while(y) {\n        if(y & 1) re = re * x % mod;\n        x = x * x % mod;\n        y >>= 1;\n    }\n    return re;\n}\nint solve() {\n    f[n][0][0] = f[n][1][1] = 1;\n    for(int i = n; i >= 1; --i) {\n        for(int j = n; j >= 0; --j) {\n            f[i][j][0] = add(f[i][j][0] + f[i][j + 1][0]);\n            for(int t = 0; t < 2; ++t) {\n                f[i - 1][j][0] = add(f[i - 1][j][0] + f[i][j][t]);\n                f[i - 1][j + 1][1] = add(f[i - 1][j + 1][1] + f[i][j][t]);\n            }\n        }\n    }\n    return f[1][n - k][0] * power(2, max(n - k - 1, 0)) % mod;\n}\nint main() {\n    read(n), read(k);\n    printf(\"%d\\n\", solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define mdn 1000000007\n#define N 2010\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint f[N][N],suf[N];\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;} \nint main()\n{\n\tint n=read(),k=read(),res=1; f[0][n+1]=1;\n\tfor(int i=1;i<=n-k-1;i++)\tres=(res<<1)%mdn;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tfor(int j=n+1;j;j--)\tsuf[j]=(suf[j+1]+f[i-1][j])%mdn;\n\t\tfor(int j=n+1,val;j;j--)\n\t\t{\n\t\t\tf[i][j]=suf[j+1];\n\t\t\tif(n+2-j-i>0)\tupd(f[i][j],f[i-1][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",1ll*(f[k][1]-f[k-1][1]+mdn)%mdn*res%mdn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,dp[2005];\nlong long power(long long x,int k) {\n\tlong long y=1;\n\twhile(k) if(k&1) (y*=x)%=mod,(x*=x)%=mod,k>>=1; else (x*=x)%=mod,k>>=1;\n\treturn y;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&k),dp[0]=1;\n\tfor(int i=1;i<n;i++,dp[0]=dp[1]) for(int j=i;j;j--) dp[j]=(dp[j+1]+dp[j-1])%mod;\n\treturn !printf(\"%d\\n\",1ll*dp[n-k]*power(2,n-k-1)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=4000+10;\nconst int mod=1e9+7;\n\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\nint fac[N],ifac[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n}\ninline int C(int n,int m) { return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod; }\n\nint main() { int n=read(),k=read(); init(n+k);\n    printf(\"%lld\\n\",1ll*(C(n+k-2,k-1)-C(n+k-2,k-2)+mod)*qpow(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int N, K;\n   cin >> N >> K;\n   vector<int> dp(N + 1);\n   dp[N] = 1;\n   for (int i = 0; i < K; ++i) {\n      vector<int> ndp(N + 1);\n      int suff = 0;\n      for (int j = N - 1; j >= 0; --j) {\n         suff += dp[j + 1];\n         if (suff >= MOD) suff -= MOD;\n         ndp[j] += suff;\n         if (ndp[j] >= MOD) ndp[j] -= MOD;\n         if (j < N - i && j) {\n            ndp[j] += dp[j];\n            if (ndp[j] >= MOD) ndp[j] -= MOD;\n         }\n      }\n      dp = move(ndp);\n   }\n   int ans = dp[0];\n   for (int i = K + 1; i <= N - 1; ++i) {\n      ans += ans;\n      if (ans >= MOD) ans -= MOD;\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std; \n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define sc(x) scanf(\"%d\",&x);\n#define rep2(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\nconst ll mod=1e9+7;\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\nll dp[2005][2005],sum[2005][2005];\nll ap(ll a,ll b)\n{\n\treturn ((a%mod)*(b%mod))%mod;\n}\nll ad(ll a,ll b)\n{\n\treturn ((a%mod)+(b%mod))%mod;\n}\nll ksm(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b%2==1)res=ap(res,a);\n\t\ta=ap(a,a);\n\t\tb/=2;\n\t}\n\treturn res;\n}\nll jc[2005];\nint n;\nvoid init()\n{\n\tjc[0]=1;\n\trep(i,1,n)jc[i]=ap(jc[i-1],i);\n}\nll ny(ll x)\n{\n\treturn ksm(x,mod-2);\n}\nll C(ll n,ll m)\n{\n\treturn ap(jc[n],ap(ny(jc[n-m]),ny(jc[m])));\n}\nint main(int argc, char** argv) {\n\tint k;\n\t\n\tsc(n);\n\tinit();\n\tsc(k);\n\tll ans=0;\t\n\t\n\tdp[0][n]=1; \n\trep(i,0,k-1)//k-1次 ,假设选k-1个元素 \n\t{\n\t\trep(j,2,n)\n\t\t{\n\t\t\tif(i==0)break;\n\t\t//\tcout<<k-1<<\" \"<<(j-1)<<\" \"<<i<<endl;\n\t\t\tif(n-(j-1)<i)continue;\n\t\t\t\n\t\t\tdp[i][j]=sum[i-1][j+1];//往下更新最小值算在最小队列头上 \n\n\t\t\tdp[i][j]=ad(dp[i-1][j],dp[i][j]); //肯定是按顺序往下走 \n\t\t}\n\t\trep2(j,n,2)\n\t\t{\n\t\t\tsum[i][j]=ad(sum[i][j+1],dp[i][j]); \n\t\t}\n\t\t//cout<<ksm(2,n-k)<<endl;\n\t\t\n\t}\n\trep(i,2,n)\n\tans=ad(ans,ap(ksm(2,n-k-1),dp[k-1][i]));\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=2e3+5,mod=1e9+7;\nint n,k;\nint binom[maxn][maxn],f[maxn][maxn][2];\nvoid upd(int &x,int y){\n\tx=(x+y)%mod;\n}\nint main(){\n\tread(n);read(k);\n\trep(i,0,n)rep(j,0,i)binom[i][j]=!j?1:(binom[i-1][j-1]+binom[i-1][j])%mod;\n\tf[n][0][0]=1;\n\tper(i,n,1)per(j,n,0){\n\t\tupd(f[i-1][j][0],f[i][j][0]);\n\t\tupd(f[i-1][j][0],f[i][j][1]);\n\t\tupd(f[i-1][j+1][1],f[i][j][0]);\n\t\tupd(f[i-1][j+1][1],f[i][j][1]);\n\t\tif(j)upd(f[i][j-1][0],f[i][j][0]);\n\t}\n\tint res=(f[1][n-k][0]+f[1][n-k][1])%mod;\n\tif(n-k-1>=0)res=1ll*res*power(2,n-k-1,mod)%mod;\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 1e9 + 7;\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n, k; cin >> n >> k;\n\tvi dp(n + 1);\n\tdp[0] = 1;\n\t\n\tfor(int i = 1; i < k; i++){\n\t\tfor(int j = 0, sum = dp[0]; j + i < n; j++)\n\t\t\tdp[j] = (sum += dp[j + 1]) %= mod;\n\t\tdp[n - i] = 0;\n\t}\n\tll ans = accumulate(all(dp), 0ll);\n\trep(i, n - k - 1) ans = ans * 2 % mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int nmax = 2e3 + 10;\n\nint n, k;\nint dp[nmax];\n\nint sum(int a, int b) {\n    a += b; if (a >= mod) a -= mod; return a;\n}\n\nint mul(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint lgpow(int a, int b) {\n    if (b <= 0) return 1;\n    int res = 1;\n    for (int i = 0; (1 << i) <= b; ++i) {\n        if (b & (1 << i))\n            res = mul(res, a);\n        a = mul(a, a);\n    }\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &k);\n    dp[0] = 1;\n    for (int i = n - 1; i; --i)\n        for (int j = n - i + 1; j >= 0; --j)\n            dp[j] = sum(dp[j-1], dp[j+1]);\n\n    int ans = mul(dp[n-k], lgpow(2, n - k - 1));\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 2010;\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint n, K;\nint f[MAXN][MAXN], g[MAXN][MAXN], suc[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> K;\n\tf[n + 1][0] = 1;\n\tfor (int i = n; i; --i) {\n\t\tfor (int j = n; ~j; --j) {\n\t\t\treduce(suc[j] = f[i + 1][j] + g[i + 1][j] - mod);\n\t\t\tif (i != 1) reduce(suc[j] += suc[j + 1] - mod);\n\t\t\treduce(g[i][j + 1] += g[i + 1][j] - mod);\n\t\t\treduce(g[i][j + 1] += f[i + 1][j] - mod);\n\t\t\treduce(f[i][j] += suc[j] - mod);\n\t\t}\n\t}\n\tstd::cout << pow(2, std::max(n - K - 1, 0), f[1][n - K]) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std; \n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define sc(x) scanf(\"%d\",&x);\n#define rep2(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\nconst ll mod=1e9+7;\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\nll dp[2005][2005],sum[2005][2005];\nll ap(ll a,ll b)\n{\n\treturn ((a%mod)*(b%mod))%mod;\n}\nll ad(ll a,ll b)\n{\n\treturn ((a%mod)+(b%mod))%mod;\n}\nll ksm(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b%2==1)res=ap(res,a);\n\t\ta=ap(a,a);\n\t\tb/=2;\n\t}\n\treturn res;\n}\nll jc[2005];\nint n;\nvoid init()\n{\n\tjc[0]=1;\n\trep(i,1,n)jc[i]=ap(jc[i-1],i);\n}\nll ny(ll x)\n{\n\treturn ksm(x,mod-2);\n}\nll C(ll n,ll m)\n{\n\treturn ap(jc[n],ap(ny(jc[n-m]),ny(jc[m])));\n}\nint main(int argc, char** argv) {\n\tint k;\n\t\n\tsc(n);init();\n\tsc(k);\n\n\tll ans=0;\t\n\tif(k==1)\n\t{\n\t\tputs(\"1\");\n\t\texit(0);\n\t}\n\trep(i,1,k-1)//k-1次 ,假设选k-1个元素 \n\t{\n\t\trep(j,2,n)\n\t\t{\n\t\t//\tcout<<k-1<<\" \"<<(j-1)<<\" \"<<i<<endl;\n\t\t\tif(n-(j-1)<i)continue;\n\t\t\tif(i==1)\n\t\t\t{\n\t\t\tdp[i][j]=1;\n\t\t//\tcout<<i<<\" \"<<j<<endl;\n\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i][j]=sum[i-1][j+1];//往下更新最小值算在最小队列头上 \n\n\t\t\tdp[i][j]=ad(dp[i-1][j],dp[i][j]); //肯定是按顺序往下走 \n\t\t}\n\t\trep2(j,n,2)\n\t\t{\n\t\t\tsum[i][j]=ad(sum[i][j+1],dp[i][j]); \n\t\t}\n\t\t//cout<<ksm(2,n-k)<<endl;\n\t\t\n\t}\n\trep(i,2,n)\n\tans=ad(ans,ap(ksm(2,n-k-1),dp[k-1][i]));\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nint64 power_mod(int64 a, int64 n, int p = MOD) {\n  int64 ret = 1;\n  for (; n; n >>= 1) {\n    if (n & 1) ret = ret * a % p;\n    a = a * a % p;\n  }\n  return ret;\n}\n\nconst int N = 2e3 + 10;\nint dp[N][N], pre[N << 1];\n\nvoid add(int& x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  int ret = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; i + j < n; ++j) {\n      if (i == 0) {\n        dp[i][j] = i + j == n - m;\n      } else {\n        add(dp[i][j], pre[i + j - 1]);\n      }\n      if (i + j == n - 1) add(ret, dp[i][j]);\n      add(pre[i + j], dp[i][j]);\n    }\n  }\n  for (int i = 0; i < n - m - 1; ++i) {\n    ret = ret * 2 % MOD;\n  }\n  cout << ret << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <deque>\n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vecll v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\n\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nconst ll MOD=1e9+7;\nconst int N=500000;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nmain(){\n    mint n=in(),k=in();\n    vector<vector<mint>> dp(k.a+10,vector<mint>(n.a+10));\n    dp[0][0]=1;\n    rep(i,k.a-1){\n        vector<mint> next(n.a+10);\n        rep2(j,0,n.a-1){\n            next[j+1]+=dp[i][j];\n            next[n.a]-=dp[i][j];\n        }\n        rep(j,n.a){\n            next[j+1]+=next[j];\n            dp[i+1][j]+=next[j];\n        }\n        rep(j,n.a){\n            if(j!=i){\n                dp[i+1][j]+=dp[i][j];\n            }\n        }\n        // rep(j,n.a)cout<<dp[i+1][j].a<<\" \";\n        // cout<<endl;\n    }\n    mint ans;\n    rep(i,n.a){\n        ans+=dp[k.a-1][i];\n    }\n    ans*=modpow(2,n.a-k.a-1);\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2000;\nconst int mod=1e9+7;\nint n,k,ans;\nint f[maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    f[0]=1;\n    for (int i=1;i<n;i++)\n\t{\n\t    for (int j=i;j;j--)\n\t        f[j]=(f[j+1]+f[j-1])%mod;\n\t    f[0]=(f[1]+f[0])%mod;\n\t}\n    f[n-k]=((f[n-k]-f[n-k+1])%mod+mod)%mod;\n    ans=1ll*f[n-k]*power(2,max(n-k-1,0))%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<set>\nusing namespace std;\n#define N 500002\ntypedef long long ll;\nconst int p=1e9+7;\nint n,k,f[2010][2012],bin[2012],s[2012][2012];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);bin[0]=1;\n\tfor(int i=1;i<=2000;i++)bin[i]=2ll*bin[i-1]%p;\t\n\tf[0][n+1]=1;\n\tfor(int i=n+1;i;i--)s[0][i]=(s[0][i+1]+f[0][i])%p;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tfor(int j=1;j<=n-i+1;j++)f[i][j]=s[i-1][j];\n\t\tfor(int j=n+1;j;j--)s[i][j]=(s[i][j+1]+f[i][j])%p;\n\t}\n\tint ans=(f[k][1]-f[k-1][1]+p)%p;if(n^k)ans=1ll*ans*bin[n-k-1]%p;\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n\nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = (ans + f[K-1][i]) % MM;\n\tcout<<((K!=n)?(ans * pw[n-K-1] % MM):ans)<<endl;\n}\n\nvoid printans(){\n\n}\n\n\nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N, K;\nll ans = 1;\n\nll inv (ll a) {\n        ll e = MOD-2, r = 1ll;\n        while (e) {\n                if (e&1) r = r * a % MOD;\n                e /= 2, a = a * a % MOD;\n        }\n        return r;\n}\n\nint main () {\n        scanf(\"%d %d\", &N, &K);\n\n        ll x = (ll) N-K+1;\n\n        ans = x % MOD;\n        for (ll i = (ll) K; i < (ll) K + (K-2); i++) {\n                ans = ans * (x+i) % MOD;\n        }\n        for (ll i = 1ll; i < (ll) K; i++) ans = ans * inv(i) % MOD;\n\n        if (x > 2) {\n                for (ll i = 0; i < x-2; i++) ans = ans * 2 % MOD;\n        }\n\n        printf(\"%lld\\n\", ans);\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2020;\nconst int mod = 1e9 + 7;\n\nLL f[N][N][2], s[N];\n\nLL qpow(LL a, LL b)\n{\n\tLL ret = 1, base = a;\n\twhile (b) {\n\t\tif (b & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, b >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tf[n + 1][0][0] = 1;\n\tfor (int i = n + 1; i >= 2; i --) {\n\t\tfor (int j = n - i + 1; j >= 0; j --) s[j] = s[j + 1], upd(s[j], f[i][j][0]);\n\t\t\n\t\tfor (int j = n - i + 1; j >= 0; j --) {\n\n\t\t\tupd(f[i - 1][j + 1][1], s[j] + f[i][j][1]);\n\t\t\tupd(f[i - 1][j][0], s[j] + f[i][j][1]);\n\t\t}\n\t}\n\t\n\t//printf(\"%lld\\n\", f[1][n - k][0] * qpow(2, n - k - 1) % mod);\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n#define N 5055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,k,f[N][N][2],ans;\ninline void add(int &x,int k){\n\tx+=k;x-=(x>=mod)?mod:0;\n}\nsigned main(){\n\tn=read();k=read();\n\tf[n+1][0][2]=1;\n\tD(i,n+1,2){\n\t\tD(j,n-1,0) add(f[i][j][1],f[i][j+1][1]);\n\t\tF(j,0,n){\n\t\t\tF(t,1,2){\n\t\t\t\tadd(f[i-1][j+1][2],f[i][j][t]);\n\t\t\t\tadd(f[i-1][j][1],f[i][j][t]);\n\t\t\t}\n\t\t}\n\t}\n\tans=f[1][n-k][1];\n\tF(i,1,n-k-1) ans=ans*2%mod;\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\nll dp[N];\n\nll uni[N];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        uni[i] = dp[i - 1];\n        for (int last = 1; last <= i; last++)\n        {\n            dp[i] = (dp[i] + dp[i - last] * uni[last]) % MOD;\n        }\n        //cout << i << \": \" << \" \" << uni[i] << \" \" << dp[i] << endl;\n    }\n    if (n == k)\n    {\n        cout << dp[n - 1];\n        return 0;\n    }\n    ll ans = 0;\n    for (int fixed_limit = n - k + 1; fixed_limit <= n; fixed_limit++)\n    {\n        //cout << fixed_limit << \" \" << n << \" \" << endl;\n        //cout << \" \" << fixed_limit - 2 << \" \" << n - k - 1 << endl;\n        ll C = cnk(fixed_limit - 2, n - k - 1) * inq(2, n - k - 1) % MOD;\n        //cout << \"added : \" << C << \" \" << dp[n - fixed_limit] << endl;\n        ans = (ans + C * dp[n - fixed_limit]) % MOD;\n    }\n    cout << ans;\n    return 0;\n    {\n        ll ans = 0;\n        vector<int> p;\n        for (int i = 0; i < n; i++) p.push_back(i + 1);\n        int cnt = 0;\n        while (1)\n        {\n            int t = (p[0] == 1);\n            for (int i = 1; i < n; i++)\n            {\n                for (int j = i + 1; j < n; j++)\n                {\n                    for (int k = j + 1; k < n; k++)\n                    {\n                        if (p[i] > p[j] && p[j] > p[k]) t = 0;\n                    }\n                }\n            }\n            int w = 0;\n            for (int i = 1; i < n; i++)\n            {\n                int t = 1;\n                for (int j = i; j < n; j++)\n                {\n                    if (p[j] <= i) t = 0;\n                }\n                if (t) w = i;\n            }\n            if (w == 1 && t == 1)\n            {\n                for (auto e : p) cout << e;\n                cout << endl;\n                cnt++;\n            }\n            if (t) ans++;\n            if (!next_permutation(all(p))) break;\n        }\n        cout << cnt << \"\\n\";\n        cout << ans << \"\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\n\n//負数がないMOD関数\ninline long long imod(long long a, long long b)\n{\n\treturn (a >= 0) ? (a % b) : (a % b + b);\n}\n\n//mint_base型用の累乗関数\ntemplate <long long MOD> class mint_base;\ntemplate <long long MOD> mint_base<MOD> m_pow(long long x, long long n);\n\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <long long MOD = 1000000007>\nclass mint_base\n{\npublic:\n\tmint_base<MOD> operator+(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a + other.a, MOD));\n\t}\n\tmint_base<MOD> operator-(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a - other.a, MOD));\n\t}\n\tmint_base<MOD> operator*(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a * other.a, MOD));\n\t}\n\tmint_base<MOD> operator+=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a + other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator-=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a - other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator*=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a * other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator+()const\n\t{\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator-()const\n\t{\n\t\treturn mint_base<MOD>(-a);\n\t}\n\tmint_base<MOD>& operator++()\n\t{\n\t\t*this += 1;\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator++(int)\n\t{\n\t\tauto tmp = *this;\n\t\t*this += 1;\n\t\treturn tmp;\n\t}\n\tmint_base<MOD>& operator--()\n\t{\n\t\t*this -= 1;\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator--(int)\n\t{\n\t\tauto tmp = *this;\n\t\t*this -= 1;\n\t\treturn tmp;\n\t}\n\tmint_base<MOD> operator~()const\n\t{\n\t\treturn m_pow<MOD>(a, (long long)e_phi - 1);\n\t}\n\tmint_base<MOD>& operator=(const mint_base<MOD> &other)\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\texplicit operator long long()const\n\t{\n\t\treturn a;\n\t}\n\texplicit operator int()const\n\t{\n\t\treturn (int)a;\n\t}\n\n\t//無効な数値を指定された場合\n\tstatic_assert(MOD >= 2, \"MOD cannot be below 2.\");\n\tmint_base(long long a_) :a(imod(a_, MOD))\n\t{\n\t\tif (e_phi > 0)return;\n\t\t//オイラー値の導出\n\t\te_phi = MOD;\n\t\tlong long m_ = MOD;\n\t\tfor (int i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\te_phi = e_phi / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)e_phi = e_phi / m_ * (m_ - 1);\n\t}\n\tmint_base() :a(0) {}\nprivate:\n\tstatic long long e_phi;\n\tlong long a;\n};\n\n//mint_base型用の累乗関数\ntemplate<long long MOD>mint_base<MOD> m_pow(long long x, long long n)\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tx %= MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<long long MOD>mint_base<MOD> fact(mint_base<MOD> x)\n{\n\tmint_base<MOD> res(1);\n\tfor (long long i = 1; i <= (long long)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n\n//mint_baseの階乗計算\n//0からxまでの階乗をsetに出力する\ntemplate<long long MOD>void fact_set(std::vector<mint_base<MOD>> &set, mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tset.push_back(1);\n\tfor (long long i = 1; i <= (long long)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset.push_back(res);\n\t}\n}\n\ntemplate<long long MOD>long long mint_base<MOD>::e_phi = -1;\n\n//mint_base型のstreamへの出力\ntemplate<long long MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (long long)i;\n\treturn os;\n}\n\n//mint_base型のstreamからの入力\ntemplate<long long MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tlong long tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\n\ntypedef mint_base<> mint;\n\n\nmap<pair<int, int>, mint>memo;\nmint dp(int s, int t)\n{\n\tif (memo.count({ s,t }))return memo[{s, t}];\n\tif (s < t || t < 0)return 0;\n\treturn memo[{s, t}] = dp(s - 1, t) + dp(s, t - 1);\n}\n\nint main(void)\n{\n\tint N, K;\n\tcin >> N >> K;\n\tint dif = N - K - 1;\n\t//dif = max(dif, 0);\n\tvector<mint>vec;\n\tfact_set<1000000007>(vec, 2345);\n\tauto comb = [&vec](int n, int k)\n\t{\n\t\tif (n < k || n < 0 || k < 0)return mint(0);\n\t\treturn vec[n] * ~vec[k] * ~vec[n - k];\n\t};\n\tmint ans = 0;\n\tmemo[{0, 0}] = 1;\n\tfor (int m = 0; m <= N; ++m)\n\t{\n\t\tmint res = comb(m - 2, max(dif, 0));\n\t\tres *= m_pow<1000000007>(2, max(dif, 0));\n\t\tif (N == K)res *= dp(K - 1, 0);\n\t\telse res *= dp(K - 1, N - m);\n\t\tans += res;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cout << #x\" = \" << x;\n\n#define st first\n#define nd second\n\nusing namespace std;\nusing namespace placeholders;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\nconst int MAXN = 2E3 + 10;\nconst int MOD = 1E9 + 7;\n\nll inv[MAXN], fac[MAXN], facinv[MAXN];\n\nll modExp(ll e, ll n, ll m = MOD){\n\tll ret = 1;\n\tfor (; n; n >>= 1, e = e * e % m)\n\t\tif (n & 1)\n\t\t\tret = ret * e % m;\n\treturn ret;\n}\n\nvoid getInv(int n = MAXN - 1, int m = MOD){\n\tinv[0] = 0, inv[1] = 1;\n\tfac[0] = fac[1] = 1;\n\tfacinv[0] = facinv[1] = 1;\n\tfor (int i = 2; i <= n; ++i){\n\t\tinv[i] = inv[m % i] * (m - m / i) % m;\n\t\tfac[i] = fac[i - 1] * i % m;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % m;\n\t}\n}\n\nll C(int n, int m){\n\treturn m < 0 || n < m ? 0 : fac[n] * facinv[m] % MOD * facinv[n - m] % MOD;\n}\n\ninline void update(int &x, int y){\n\tif ((x += y) >= MOD)\n\t\tx -= MOD;\n}\n\nint f[MAXN][MAXN];\n\nint main(){\n\tgetInv();\n\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= k - 1; ++i){\n\t\tint s = f[i - 1][i - 1];\n\t\tfor (int j = i; j < n; ++j){\n\t\t\tupdate(f[i][j], s);\n\t\t\tupdate(f[i][j], f[i - 1][j]);\n\t\t\tupdate(s, f[i - 1][j]);\n//\t\t\tprintf(\"%d %d %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tupdate(ans, f[k - 1][i]);\n\tprintf(\"%d\\n\", (int)(ans * modExp(2, max(0, n - k - 1)) % MOD));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n,k;\nint pw[4010];\nconst int md=1e9+7;\nint qmul(int x,int p)\n{\n\tif(p<=0)return 1;\n\tif(p==1)return x;\n\tint res=qmul(x,p>>1);\n\tres=1LL*res*res%md;\n\tif(p&1)res=1LL*res*x%md;\n\treturn res;\n}\nint C(int x,int y)\n{\n\tif(x<y || x<0 || y<0)return 0;\n\treturn 1LL*pw[x]*qmul(pw[x-y],md-2)%md*qmul(pw[y],md-2)%md;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tpw[0]=1;\n\tfor(int i=1;i<=4000;i++)pw[i]=1LL*pw[i-1]*i%md;\n\tprintf(\"%d\",1LL*(C(n+k-2,n-1)+md-C(n+k-2,n))*qmul(2,n-k-1)%md);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define LL long long\nusing namespace std;\nconst int Maxn = 2010;\nconst int Mod = 1e9+7;\nint n, K;\nint f[Maxn][Maxn], C[Maxn][Maxn], g[Maxn];\nvoid up(int &x, int y) { x = x + y >= Mod ? x+y-Mod : x+y; }\nint main() {\n\tint i, j, k;\n\tscanf(\"%d%d\", &n, &K);\n\tC[0][0] = 1;\n\tfor(i = 1; i <= n; i++){\n\t\tC[i][0] = 1;\n\t\tfor(j = 1; j <= i; j++) C[i][j] = (C[i-1][j-1]+C[i-1][j])%Mod;\n\t}\n\tf[1][1] = 1; g[0] = 1;\n\tfor(i = 1; i < K; i++){\n\t\tfor(j = 1; j <= i; j++) up(f[i+1][j+1], f[i][j]);\n\t\tint sum = 0;\n\t\tfor(j = i; j >= 1; j--){\n\t\t\tup(sum, f[i][j]);\n\t\t\tup(f[i+1][j], sum);\n\t\t}\n\t\tg[i] = sum;\n\t}\n\tint ans = g[K-1];\n\tfor(i = 1; i < K; i++){\n\t\tj = K-1-i;\n\t\tif(n-2-j >= i){\n\t\t\tint p = C[n-2-j][i];\n\t\t\tif(!j) up(ans, p);\n\t\t\telse {\n\t\t\t\tfor(k = 1; k <= j; k++) up(ans, 1ll*p*f[j][k]%Mod*C[i+k][i]%Mod);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 1; i < n-K; i++) ans = ans*2%Mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint const N = 4e3 + 41;\nint const MOD = 1e9 + 7;\n\nint n, k, dp[N][N], pref[N][N];\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MOD){\n\t\ta -= MOD;\n\t}\n}\n\nint bp(int x, int d){\n\tif(!d){\n\t\treturn 1;\n\t}\n\tif(d&1){\n\t\treturn x * 1LL * bp(x, d-1) % MOD;\n\t}\n\tint r = bp(x, d/2);\n\treturn r * 1LL * r % MOD;\n}\n\nvoid recalcPref(int id){\n\tfor(int i=0;i<N;++i){\n\t\tpref[id][i] = dp[id][i];\n\t\tif(i > 0){\n\t\t\tadd(pref[id][i], pref[id][i-1]);\n\t\t}\n\t}\n}\n\nint getPref(int l, int r, int id){\n\tint ret = pref[id][r];\n\tif(l > 0){\n\t\tret -= pref[id][l-1];\n\t\tif(ret < 0){\n\t\t\tret += MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tif(k == n){\n\t\tk = 1;\n\t}\n\tdp[1][k-1] = bp(2, n - k - 1);\n\tfor(int i=2;i<=n;++i){\n\t\trecalcPref(i-1);\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tint rem = n - i - j + 1;\n\t\t\tadd(dp[i][j], getPref(j, j + rem, i-1));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[n][0]);\n}\n\nvoid read(){\n\tscanf(\"%d %d\",&n,&k);\n}\n\n\n\nvoid prepare(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n}\n\nint main(){\n\tprepare();\n\tread();\n\tsolve();\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2005;\nconst LL mod = 1000000007LL;\n\nLL dp[N][N], C[N][N], pref[N];\n\ninline LL pow(LL x, LL exp) {\n  if (exp < 0) return 1;\n  LL res = 1;\n  for (; exp; exp >>= 1, x = x * x % mod)\n    if (exp & 1) res = res * x % mod;\n  return res;\n}\n\ninline void pre() {\n  for (int i = 0; i < N; i ++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j ++) {\n      C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n      if (C[i][j] >= mod) C[i][j] -= mod;\n    }\n  }\n}\n\ninline LL DP(int n) {\n  pref[0] = 1;\n  for (int i = 2; i <= n; i ++) {\n    for (int j = 1; j < i; j ++) {\n      pref[j] = pref[j - 1] + dp[i - 1][j];\n      if (pref[j] >= mod) pref[j] -= mod;\n      dp[i][j] = pref[j];\n    }\n  }\n  LL ans = 1;\n  for (int i = 1; i <= n; i ++) {\n    ans += dp[n][i];\n    if (ans >= mod) ans -= mod;\n  }\n  return ans;\n}\n\nint main() {\n    cout << DP(39) << endl;\n  int n, k;\n  pre();\n  scanf(\"%d%d\", &n, &k);\n  if (k == 1) return printf(\"%lld\\n\", pow(2LL, n - 2)), 0;\n  if (k == 2) {\n    LL ans = pow(2LL, n - k - 1) * (n - 1) % mod;\n    return printf(\"%lld\\n\", ans), 0;\n  }\n  LL ans = DP(k - 1);\n  ans = ans * C[n - 1][k - 1] % mod * pow(2LL, n - k - 1) % mod;\n  printf(\"%lld\\n\", ans);\n  return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define F(i,l,r) for(int i=l;i<=r;i++)\nint m=1e9+7,n,k,d[2333][2333];main(){scanf(\"%d%d\",&n,&k);d[1][1]=1;F(i,2,n)F(j,1,i)d[i][j]=(d[i][j-1]+d[i-1][j])%m;F(i,1,n-k-1)(d[n][k]*=2)%=m;printf(\"%d\\n\",d[n][k]);}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rg register\n#define file(x) freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout);\nusing namespace std;\nconst int mod=1e9+7;\nint read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();\n    return f*x;\n}\nint ksm(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint f[2010][2010];//\nint sum[10001];\nmain(){\n\tint n=read(),k=read();\n\tf[0][n+1]=1;\n\tfor(int i=1;i<=k;i++){\n\t\tsum[n+1]=f[i-1][n+1];\n\t\tfor(int j=n;j>=1;j--) sum[j]=(sum[j+1]+f[i-1][j])%mod;\n\t\tfor(int z=1;z<=n-i+1;z++)\n\t\t\tf[i][z]=sum[z];\n\t}\n\tcout<<(f[k][1]-f[k-1][1]+mod)%mod*ksm(2,n-k-1)%mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(int n){\n    if(n+1<=(signed)fact.size()) return;\n    fact.assign(n+1,1);\n    finv.assign(n+1,1);\n    invs.assign(n+1,1);\n    \n    for(int i=1;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(int i=n;i>=1;i--) finv[i-1]=finv[i]*Mint(i);\n    for(int i=1;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(int n,int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(int n,int k){\n    Mint res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(int n,int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(int n,int k){\n    Mint res;\n    for(int j=1;j<=k;j++) res+=S(n,j);\n    return res;\n  }\n\n  static Mint montmort(int n){\n    Mint res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,k;\n  cin>>n>>k;\n  using M = Mint<int>;\n  vector<M> dp(n+1,0);\n  dp[0]=M(1);\n  for(int i=0;i<k-1;i++){\n    for(int j=1;j<=n;j++) dp[j]+=dp[j-1];\n    dp[i]=M(0);    \n  }\n  M ans;\n  for(int i=0;i<n;i++) ans+=dp[i];\n  ans*=M(2).pow(n==k?0:n-k-1);\n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\ntypedef long long LL;\n\nconst int mod = 1e9 + 7;\nconst int NMAX = 10005;\n\nint N, K;\nint fct[NMAX], ifct[NMAX], p2[NMAX];\n\nint power(int x, int y)\n{\n    if(y <= 0)  return 1;\n    int ans = power( (1LL * x * x) % mod, y >> 1 );\n    if(y & 1) ans = (1LL * ans * x) % mod;\n    return ans;\n}\n\nint pw2(int x) { if(x < 0) return 1; return p2[x]; }\n\nint C(int N, int K)\n{\n    if(N < K)   return 0;\n    int ans = (1LL * fct[N] * ifct[K]) % mod;\n    ans = (1LL * ans * ifct[N - K]) % mod;\n    return ans;\n}\n\nvoid pre(int N)\n{\n    fct[0] = 1;\n    for(int i = 1; i <= N; i++) fct[i] = (1LL * fct[i - 1] * i) % mod;\n\n    ifct[N] = power(fct[N], mod - 2);\n    for(int i = N - 1; i >= 0; i--) ifct[i] = (1LL * ifct[i + 1] * (i + 1)) % mod;\n\n    p2[0] = 1;\n    for(int i = 1; i <= N; i++) p2[i] = (2LL * p2[i - 1]) % mod;\n}\n\nvoid calcMod(int N, int K)\n{\n    map<LL, int> mp;\n    int cnt = 0;\n    for(int msk = 0; msk < 1 << N; msk++)\n    {\n        vector<int> st, dr;\n        for(int i = 0; i < N; i++)\n            if( (msk >> i) & 1 )    dr.push_back(i);\n            else    st.push_back(i);\n        for(int i = N; i < N + K; i++)\n            dr.push_back(i);\n\n        for(int msk2 = 0; msk2 < 1 << (N + K); msk2++)\n        {\n            int b = __builtin_popcount(msk2);\n            if(b != st.size())  continue;\n\n            LL h = 0;\n            vector<int> stt = st, drr = dr;\n            for(int i = 0; i < N + K; i++)\n                if( (msk2 >> i) & 1 )\n                {\n                    h = 1LL * h * (N + K) + stt.back(); stt.pop_back();\n                }\n                else\n                {\n                    h = 1LL * h * (N + K) + drr.back(); drr.pop_back();\n                }\n            if(!mp.count(h)) { cnt++; mp[h]; }\n        }\n    }\n    printf(\"%d\\n\", cnt);\n    cerr << cnt << '\\n';\n    exit(0);\n}\n\nint getNumberOfWays(int N, int M)\n{\n    if(N == 0)  return 1;\n    M++;\n    if(N == 1)  return M;\n    int ans = (1LL * fct[M + 2 * N - 1] * ifct[M + N]) % mod;\n    ans = (1LL * ans * M) % mod;\n    ans = (1LL * ans * ifct[N]) % mod;\n    return ans;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    pre(10000);\n\n    scanf(\"%d%d\", &N, &K);\n    if(N == K)\n    {\n        printf(\"%d\\n\", getNumberOfWays(N - 1, 0));\n        return 0;\n    }\n\n    int ans = 0;\n    for(int i = 0; i < K; i++)\n    {\n        int sol = getNumberOfWays(i, K - 1 - i);\n        sol = (1LL * sol * C(N - 2 - i, K - 1 - i)) % mod;\n        ans = (ans + sol) % mod;\n    }\n    ans = (1LL * ans * pw2(N - K - 1)) % mod;\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long int64;\nstatic const int MAXN = 2003;\nstatic const int MODULUS = 1e9 + 7;\n#define _  %  MODULUS\n#define __ %= MODULUS\n \nint binom[MAXN * 2][MAXN * 2] = {{ 0 }};\ninline void preprocess_binomials()\n{\n    binom[0][0] = 1;\n    for (int i = 1; i < MAXN * 2; ++i) {\n        binom[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j])_;\n    }\n}\ninline int fpow(int64 base, int exp)\n{\n    int64 ans = 1;\n    for (; exp; exp >>= 1, (base *= base)__) if (exp & 1) (ans *= base)__;\n    return ans;\n}\ninline int catalan(int n) { return (int64)binom[2 * n][n] * fpow(n + 1, MODULUS - 2)_; }\n \nint n, k;\n// f[# of total elements][# of red elements] - nnumber of ways to distribute to two sides\nint f[MAXN * 2][MAXN * 2] = {{ 0 }};\n \ninline void preprocess_transitions()\n{\n    f[0][0] = 1;\n    for (int i = 0; i < MAXN * 2 - 1; ++i) {\n        f[i + 1][0] = f[i][0];\n        for (int j = 1; j <= i + 1; ++j)\n            f[i + 1][j] = (f[i + 1][j - 1] + f[i][j])_;\n    }\n}\n \nint main()\n{\n    preprocess_binomials();\n    scanf(\"%d%d\", &n, &k);\n    if (n == k) { printf(\"%d\\n\", catalan(n - 1)); return 0; }\n \n    preprocess_transitions();\n    int64 ans = 0;\n    for (int m = n - k + 1; m <= n; ++m) {\n        int akai = n - m, aoi = m - 1 - (n - k);\n        int64 inc = f[akai + aoi][akai];\n        (inc *= binom[m - 2][n - k - 1])__;\n        (inc *= fpow(2, n - k - 1))__;\n        ans += inc;\n    }\n    printf(\"%lld\\n\", ans _);\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,k;\nll dp[2005][2005][2];\n\nll mod_pow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1)res=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nll extgcd(ll a,ll b,ll& x,ll& y){\n\tll d=a;\n\tif(b!=0){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\n\nint main(void){\n\tscanf(\"%d%d\",&n,&k);\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>=1;i--){\n\t\tfor(int j=n;j>=0;j--){\n\t\t\tdp[i-1][j][0]+=(dp[i][j][0]+dp[i][j][1])%MOD;\n\t\t\tdp[i-1][j][0]%=MOD;\n\t\t\tdp[i-1][j+1][1]+=(dp[i][j][0]+dp[i][j][1])%MOD;\n\t\t\tdp[i-1][j+1][1]%=MOD;\n\t\t\tif(j>0){\n\t\t\t\tdp[i][j-1][0]+=dp[i][j][0];\n\t\t\t\tdp[i][j-1][0]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll res=(dp[1][n-k][0]+dp[1][n-k][1])%MOD;\n\tres=res*mod_pow(2,n-k-1)%MOD;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tstatic llint dp[2002][2002]={0};\n\tstatic llint ep[2002][2002]={0};\n\tllint i,j,n,K;cin>>n>>K;\n\tdp[0][n+1-K]=1;\n\tfor(i=0;i<n-K-1;i++){dp[0][n+1-K]*=2;dp[0][n+1-K]%=mod;}\n\tep[0][n+1-K]=dp[0][n+1-K];\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tdp[i][j]=(dp[i][j-1]+ep[i-1][j])%mod;\n\t\t\tep[i][j]=(dp[i][j]+ep[i-1][j+1])%mod;\n\t\t}\n\t}\n\tcout<<dp[n][1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2010\n#define ll long long\n#define For(i,x,y) for(int i=(x);i<=(y);++i)\n#define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n#define Edge(x) for(int i=head[x];i;i=e[i].nxt)\n#define mset(x,y) memset(x,y,sizeof(x))\n#define strL strlen\n#define p_b push_back\n#define mcpy(x,y) memcpy(x,y,sizeof(x))\n#define lson l,mid,(o<<1)\n#define rson mid+1,r,((o<<1)|1)\n#define Ls (t[o].ls)\n#define Rs (t[o].rs)\n#define mod 1000000007\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\nusing namespace std;\nint _2[N],f[N][N],sub[N][N];\nvoid init(int n){_2[0]=1;For(i,1,n) _2[i]=(_2[i-1]+_2[i-1])%mod;}\nint main(){\n\tint n,k,ans=0;\n\tscanf(\"%d%d\",&n,&k);\n\tinit(n);\n\tFor(i,2,n+1) sub[0][i]=1;\n\tFor(i,1,k-1) Rof(j,n-i+1,2){\n\t\tif(j<=n-i+1) (f[i][j]+=sub[i-1][j])%=mod;\n\t\tsub[i][j]=(sub[i][j+1]+f[i][j])%mod;\n\t}\n\tFor(i,2,n-k+2) (ans+=1ll*f[k-1][i])%=mod;\n\tif(k==1) ans=1;\n\tans=1ll*ans*_2[n-k-1]%mod; \n\tprintf(\"%d\\n\",ans); \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define ll long long\nconst ll mod = 1e9+7; \nusing namespace std;\nint read(){\n\tint x=0,pos=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;\n\tfor(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn pos?x:-x;\n}\nconst int N = 3001;\nint n,k;\nll f[N][N];\nint main(){\n\tn=read(),k=read();\n\tfor(int i=2;i<=n;i++){\n\t\tf[1][i]=1;\n\t}\n\tfor(int i=1;i<k-1;i++){\n\t\tll sum=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--){\n\t\t\tsum=(sum+f[i][j])%mod;\n\t\t\tf[i+1][j]=sum;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=2;i<=n;i++){\n\t\tans=(ans+f[k-1][i])%mod;\n\t}\n\tif(k==1){\n\t\tans=1;\n\t}else if(k!=n){\n\t\tll pm=1;\n\t\tfor(int i=1;i<=n-k-1;i++){\n\t\t\tpm=pm*2ll%mod;\n\t\t}\n\t\tans=ans*((pm)%mod)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nconst long long P=1000000007ll;\nlong long n,k,f[10001];\n\nlong long qpow(long long a,int x){\n    if(x<0)return 1;\n    long long s=1ll;\n    while(x){if(x&1)(s*=a)%=P;(a*=a)%=P;x>>=1;}\n    return s;\n}\n\nint main(){\n    scanf(\"%lld%lld\",&n,&k);\n    f[0]=1ll;\n    for(int i=1;i<n;++i){for(int j=i;j;--j)f[j]=(f[j+1]+f[j-1])%P;f[0]=f[1];}\n    printf(\"%lld\",f[n-k]*qpow(2ll,n-k-1)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef ONLINE_JUDGE\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n//#include <atcoder/all>\n//using namespace atcoder;\n//using mint = modint998244353;\n//using mint = modint1000000007;\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//using namespace __gnu_pbds;\n//using i128 = __int128_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\nconstexpr char ln = '\\n';\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) {if (a > b) {a = b; return true;} return false;}\ninline int topbit(int x) {return x == 0 ? -1 : 31-__builtin_clz(x);}\ninline int topbit(long long x) {return x == 0 ? -1 : 63-__builtin_clzll(x);}\ninline int botbit(int x) {return x == 0 ? 32 : __builtin_ctz(x);}\ninline int botbit(long long x) {return x == 0 ? 64 : __builtin_ctzll(x);}\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\ninline int kthbit(long long x, int k) {return (x>>k)&1;}\ninline void print() {cout << \"\\n\";}\ntemplate<class T>\ninline void print(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cout << *itr << \" \";\n    print();\n}\ntemplate<class T, class... Args>\ninline void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n#ifdef MINATO_LOCAL\n#define dump(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\ninline void debug() {cerr << endl;}\ntemplate<class T>\ninline void debug(const vector<T> &v) {\n    for (auto itr = v.begin(); itr != v.end(); ++itr) cerr << *itr << \" \";\n    debug();\n}\ntemplate<class T, class... Args>\ninline void debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n#else\n#define dump(x) void(0)\ninline void debug() {}\ntemplate<class T> inline void debug(const vector<T> &v) {}\ntemplate<class T, class... Args> inline void debug(const T &x, const Args &... args) {}\n#endif\nstruct Fast_ios {Fast_ios() {cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20);};} fast_ios;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate <uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept {return a;}\n    constexpr const u64 &value() const noexcept {return a;}\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr bool operator==(const ModInt &rhs) const noexcept {return a == rhs.a;}\n    constexpr bool operator!=(const ModInt &rhs) const noexcept {return a != rhs.a;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt rhs = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n\n    friend ostream &operator<<(ostream& os, const ModInt& rhs) noexcept {return os << rhs.a;}\n    friend istream &operator>>(istream& is, ModInt& rhs) noexcept {long long a; is >> a; rhs = a; return is;}\n};\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\n\nusing mint = ModInt<MOD>;\n\n\nstruct ModCombination {\n    vector<mint> Fac,Facinv;\n\n    ModCombination(int x) {\n        Fac.resize(x+1);\n        Facinv.resize(x+1);\n        Fac[0] = 1;\n        for (int i = 0; i < x; ++i) Fac[i+1] = Fac[i]*(i+1);\n        Facinv[x] = Fac[0]/Fac[x];\n        for (int i = x; i > 0; --i) Facinv[i-1] = Facinv[i]*i;\n    }\n\n    mint get(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return Fac[n]*Facinv[k]*Facinv[n-k];\n    }\n};\n\nint main() {\n    int N,K; cin >> N >> K;\n\n    vector<vector<mint>> dp(N+1, vector<mint>(N+1));\n    dp[0][0] = 1;\n    rep(i,N) {\n        for (int j = 2; j <= i; j++) {\n            dp[i+1][2] += dp[i][j];\n            if (j+1 <= N) dp[i+1][j+1] -= dp[i][j];\n        }\n        rep(j,N) dp[i+1][j+1] += dp[i+1][j];\n        for (int j = 2; j <= i; j++) dp[i+1][j+1] += dp[i][j];\n        dp[i+1][0] += dp[i][0];\n        for (int j = 2; j <= i+1; j++) dp[i+1][j] += dp[i][0];\n    }\n\n    ModCombination MC(100000);\n    mint val = 2;\n    if (N==K) val = 1;\n    else val ^= (N-K-1);\n    mint ans = MC.get(N-1,N-K);\n    for (int i = 2; i <= K-1; i++) ans += dp[K-1][i]*MC.get(N-1-(K-i),N-K);\n\n    ans *= val;\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\nconst int N = 2010;\nconst int Mod = 1e9 + 7;\n\nint n, k;\nint dp[N][N], S[N][N];\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tdp[1][n - k] = 1;\n\tFor(i, 2, n){\n\t\tS[i - 1][0] = dp[i - 1][0];\n\t\tFor(j, 1, n + 1) S[i - 1][j] = (S[i - 1][j - 1] + dp[i - 1][j]) % Mod;\n\t\tFor(j, 0, n) dp[i][j] = S[i - 1][j + 1];\n\t}\n\tint ans = dp[n][0];\n\tFor(i, 1, n - k - 1) ans = ans * 2 % Mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb push_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int N = 2000;\nconst int oo = 0x3f3f3f3f;\nconst int mo = 1e9 + 7;\n \ntemplate<typename T> T read() {\n    T n(0), f(1);\n    char ch = getchar();\n    for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nint n, k;\nint dp[N + 5][N + 5];\n\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif \n\n    cin >> n >> k;\n    dp[1][n - k] = 1;\n    for(int i = 2; i <= n; ++i) {\n        int sum = 0;\n        for(int j = 0; j <= n; ++j) {\n            sum = (sum + dp[i-1][j]) % mo;\n            dp[i][j] = (sum + dp[i-1][j+1]) % mo;\n        }\n    }\n\n    int ans = dp[n][0];\n    for(int i = 0; i < n - k - 1; ++i) ans = (ans << 1) % mo;\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "int f[2003],n,k,ans;\nconst int md=1e9+7;\nint main(){\n\t__builtin_scanf(\"%d%d\",&n,&k);\n\tf[n+1]=1;\n\tfor(int i=1;i<k;++i)for(int j=n-i+1;j>1;--j)(f[j]+=f[j+1])%=md;\n\tfor(int i=2;i<=n-k+2;++i)ans=(ans+f[i])%md;\n\tfor(int i=n-k-1;i>=0;--i)ans=ans*2%md;\n\t__builtin_printf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2e3+10;\nint n,m,dp[maxn][maxn];\nint Pow(int a,long long k)\n{\n\tint ret=1;\n\tif(k==-1)return 1;\n\twhile(k)\n\t{\n\t\tif(k&1)ret=ret*1LL*a%mod;\n\t\tk>>=1,a=a*1LL*a%mod;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint sum=dp[i-1][n+1];\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tsum+=dp[i-1][j],sum%=mod;\n\t\t\tif(n-i+1>=j)dp[i][j]=sum;\n\t\t}\n\t}\n\tint ret=(dp[m][1]-dp[m-1][1]+mod)%mod;\n\tprintf(\"%lld\\n\",ret*1LL*Pow(2,n-m-1)%mod);\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint n,f[2005][2005],s[2005],k,P=1e9+7,a;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);f[0][n+1]=1;\n\tfor(int i=1;i<=k;i++) for(int j=n+1;j;j--) s[j]=(s[j+1]+f[i-1][j])%P,f[i][j]=(j<=n-i+1?s[j]:0);\n\ta=(f[k][1]-f[k-1][1]+P)%P;\n\tfor(int i=1;i<=n-k-1;i++) a=(a+a)%P;\n\tprintf(\"%d\\n\",a);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fm, to)    for (int i = fm; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 2e3, mod = 1e9 + 7;\nint n, k, dp[2][nsz + 5], suf[2][nsz + 5];\nnum ans;\n\nint inline qpow(int a, int p) {\n\tint res = 1;\n\tfor (; p > 0; p >>= 1) {\n\t\t(p & 1) && (res = (num) res * a % mod);\n\t\ta = (num) a * a % mod;\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin >> n >> k;\n\tint o = 0, x = 1;\n\tdp[o][n + 1] = 1;\n\tfor (int j = n + 1; j >= 1; --j) {\n\t\tsuf[o][j] = (suf[o][j + 1] + dp[o][j]) % mod;\n\t}\n\tcont (i, k - 1) {\n\t\tfor (int j = n; j >= 1; --j) {\n\t\t\tdp[x][j] = suf[o][j + 1];\n\t\t\tif (j + i - 1 <= n) {\n\t\t\t\tdp[x][j] = (dp[x][j] + dp[o][j]) % mod;\n\t\t\t}\n\t\t\tsuf[x][j] = (suf[x][j + 1] + dp[x][j]) % mod;\n\t\t}\n\t\tswap(o, x);\n\t\tdp[x][n + 1] = suf[x][n + 1] = 0;\n\t}\n\tcirc (j, 2, n + 1) {\n\t\tans = (ans + dp[o][j]) % mod;\n\t}\n\tans = ans * qpow(2, n - k - 1) % mod;\n\tcout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst long long MOD = 1e9+7;\nconst long long MAXN = 2e3+5;\nlong long dp[MAXN][MAXN];\nlong long suff[MAXN];\nint main(){\n    long long n,k;\n    cin>>n>>k;\n    dp[0][n] = 1;\n    for(long long i=1;i<=k;i++){\n        for(long long j=n;j>=1;j--){\n            suff[j] = suff[j+1]+dp[i-1][j];\n            suff[j]%=MOD;\n            if(j<=(n-i+1)){\n                dp[i][j] =suff[j];\n                dp[i][j]%=MOD;\n            }\n            //cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n        }\n        \n    }\n    \n    long long ans = (dp[k][1] - dp[k-1][1] + MOD)%MOD;\n    //cout<<ans<<endl;\n    for(long long i=1;i<=n-k-1;i++){\n        ans*=2;\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=2005;\nconst int MOD=1000000007;\n\nint n,k,f[N][N][3];\n\nvoid updata(int &x,int y)\n{\n\tx+=y;x-=x>=MOD?MOD:0;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tf[n+1][0][2]=1;\n\tfor (int i=n+1;i>1;i--)\n\t{\n\t\tfor (int j=n;j>=0;j--) updata(f[i][j][1],f[i][j+1][1]);\n\t\tfor (int j=0;j<=n;j++)\n\t\t\tfor (int t=1;t<=2;t++)\n\t\t\t{\n\t\t\t\tupdata(f[i-1][j+1][2],f[i][j][t]);\n\t\t\t\tupdata(f[i-1][j][1],f[i][j][t]);\n\t\t\t}\n\t}\n\tint ans=f[1][n-k][1];\n\tfor (int j=1;j<=n-k-1;j++) updata(ans,ans);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=2010;\nconst int mod=1e9+7;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,k;\nint dp[N][N],S[N][N];\nint main()\n{\n\tfile();\n\tread(n),read(k);\n\tdp[1][n-k]=1;\n\tFor(i,1,n)S[1][i]=S[1][i-1]+dp[1][i];\n\tFor(i,2,n)\n\t\tFor(j,0,n)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j+1];\n\t\t\tdp[i][j]=(dp[i][j]+S[i-1][j])%mod;\n\t\t\tS[i][j]=((j?S[i][j-1]:0)+dp[i][j])%mod;\n\t\t}\n\tint ans=dp[n][0];\n\tFor(i,1,n-k-1)ans=(ans<<1)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 20010\n#define mo 1000000007ll\nint f[N];\nint n,k;\nll qp(ll x,ll y){\n\tll r=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1)r=r*x%mo;\n\treturn r;\n}\nsigned main(){\n\tcin>>n>>k;\n\tf[0]=1;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i;j;j--){\n\t\t\tf[j]=(f[j+1]+f[j-1]);\n\t\t\tif(f[j]>=mo)f[j]-=mo;\n\t\t}\n\t\tf[0]=f[1];\n\t}\n\tcout<<f[n-k]*qp(2,n-k-1)%mo;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> PII;\n \nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n \nint n, m;\nint K;\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n \nvoid solve(int casi){\n\tcin>>n>>K;\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tcout<<((K!=n)?(sum[K - 1][n - K] * pw[n-K-1] % MM):ans)<<endl;\n}\n \n \nint main(){\n\tsolve(1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll N = 5010;\nconst ll M = 210;\ninline ll read()\n{\n  ll p=0; ll f=1; char ch=getchar();\n  while(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n  while(ch>='0' && ch<='9'){p=p*10+ch-'0'; ch=getchar();}\n  return p*f;\n}\nll a[N],b[N][M]; ll s[N]; ll top; ll sum[N][N]; ll l[N],r[N]; ll pre[N];\nint main()\n{\n  ll n=read(),m=read();\n\n  for(ll i=2;i<=n;i++) a[i] = read();\n  for(ll i=1;i<=n;i++) for(ll j=1;j<=m;j++) b[i][j] = read();\n\n  for(ll i=1;i<=m;i++)\n  {\n    top = 0; s[top] = 0;\n    for(ll j=1;j<=n;j++) l[j] = r[j] = 0;\n    for(ll j=1;j<=n;j++)\n    {\n      while(top && b[j][i] > b[s[top]][i]) top--;\n      l[j] = s[top] + 1; s[++top] = j;\n    }\n\n    top = 0; s[top] = n+1;\n    for(ll j=n;j>=1;j--)\n    {\n      while(top && b[j][i] > b[s[top]][i]) top--;\n      r[j] = s[top] - 1; s[++top] = j;\n    }\n\n    for(ll j=1;j<=n;j++)\n    {\n      sum[l[j]][j] += b[j][i];\n      sum[j+1][j] -= b[j][i] ;\n      sum[l[j]][r[j]+1] -= b[j][i];\n      sum[j+1][r[j]+1] += b[j][i];\n    }\n  }\n\n  for(ll i=2;i<=n;i++) pre[i] = pre[i-1] + a[i];\n\n  ll maxx = 0;\n  for(ll i=1;i<=n;i++) for(ll j=1;j<=n;j++)\n  {\n    sum[i][j] = sum[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n      if(i<=j) maxx = max(maxx , sum[i][j] - pre[j] + pre[i]);\n  }\n\n  return printf(\"%lld\\n\",maxx),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint DP[N][N], PS[N][N], n, k, tav;\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\ttav = 1;\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n - k - 1; i++) tav = tav * 2ll % MOD;\n\tDP[1][0] = 1;\n\tPS[1][0] = PS[1][1] = 1;\n\tfor (int i = 2; i <= n - 1; i++){\n\t\tfor (int j = 0; j <= i - 1; j++){\n\t\t\tDP[i][j] = DP[i - 1][j];\n\t\t\tif (j != 0) DP[i][j] = (DP[i][j] + PS[i - 1][j - 1]) % MOD;\n\t\t}\n\t\tfor (int j = 0; j <= i; j++) PS[i][j] = (j == 0?DP[i][j]:(DP[i][j] + PS[i][j - 1]) % MOD);\n\t}\n\tcout << PS[n - 1][k - 1] * 1ll * tav % MOD << '\\n';\n\t//cout << (n - 1) * 1ll * tav % MOD;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n, k;\nconst int mod = (int)1e9 + 7;\n\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\n\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nconst int maxN = 2005;\n\nint fact[maxN], invfact[maxN], inv[maxN];\n\nvoid init() {\n    inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n}\n\nint cnk(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return mult(fact[n], mult(invfact[k], invfact[n - k]));\n}\n\n\nint dp[maxN][maxN];\nint cat[maxN];\nvoid solve(int x) {\n    dp[1][1] = 1;\n    for (int i = 1; i < x; i++) {\n        for (int suf = 1; suf <= i; suf++) {\n            dp[i + 1][1] = sum(dp[i + 1][1], dp[i][suf]);\n            if (suf < i) dp[i + 1][suf + 2] = sub(dp[i + 1][suf + 2], dp[i][suf]);\n        }\n        for (int suf = 2; suf <= i + 1; suf++) {\n            dp[i + 1][suf] = sum(dp[i + 1][suf], dp[i + 1][suf - 1]);\n        }\n    }\n    for (int i = 1; i <= x; i++) {\n        for (int j = 1; j <= i; j++) {\n            cat[i] = sum(cat[i], dp[i][j]);\n        }\n    }\n    cat[0] = 1;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    init();\n    cin >> n >> k;\n    dp[0][0] = 1;\n    int cnt = n - k;\n    for (int i = 0; i < (k - 1); i++) {\n        for (int suf = 0; suf <= i; suf++) {\n            dp[i + 1][1] = sum(dp[i + 1][1], dp[i][suf]);\n            if (suf < i) dp[i + 1][suf + 2] = sub(dp[i + 1][suf + 2], dp[i][suf]);\n        }\n        for (int suf = 2; suf <= i + 1; suf++) {\n            dp[i + 1][suf] = sum(dp[i + 1][suf], dp[i + 1][suf - 1]);\n        }\n        dp[i + 1][i + 1] = sum(dp[i + 1][i + 1], cnk(i + 1 + cnt - 1, cnt - 1));\n    }\n    int ans = 0;\n    for (int i = 0; i <= k - 1; i++) {\n        ans = sum(ans, dp[k - 1][i]);\n    }\n    cout << mult(ans, pw(2, max(0, n - k - 1)));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int, T mod = 1'000'000'007, typename U = long long>\nstruct umod{\n        T val;\n        umod(): val(0){}\n        umod(U x){ x %= mod; if(x < 0) x += mod; val = x;}\n        umod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\tumod& operator *= (umod oth){ val = ((U)val) * oth.val % mod; return *this; }\n\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n        umod& operator ^= (U oth){ return *this = pwr(*this, oth); }\n\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n        umod operator ^ (long long oth) const { return umod(*this) ^= oth; }\n\tbool operator < (umod oth) const { return val < oth.val; }\n\tbool operator > (umod oth) const { return val > oth.val; }\n\tbool operator <= (umod oth) const { return val <= oth.val; }\n\tbool operator >= (umod oth) const { return val >= oth.val; }\n\tbool operator == (umod oth) const { return val == oth.val; }\n\tbool operator != (umod oth) const { return val != oth.val; }\n        umod pwr(umod a, U b) const { umod r = 1; for(; b; a *= a, b >>= 1) if(b&1) r *= a; return r; }\n        umod inverse() const {\n\t\tU a = val, b = mod, u = 1, v = 0;\n\t\twhile(b){\n\t\t\tU t = a/b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tif(u < 0)\n\t\t\tu += mod;\n\t\treturn u;\n        }\n};\nusing U = umod<>;\nconst int maxn = 2020;\nU f[maxn][maxn][2], ans;\nint main(){\n\tint n, k; cin >> n >> k;\n\tf[0][0][0] = 1;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i; j >= 0; j--){\n\t\t\tfor(int r = 0; r < 2; r++){\n\t\t\t\tif(!f[i][j][r].val) continue;\n\t\t\t\tif(i - j == k - 1){\n\t\t\t\t\tans += f[i][j][r];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tf[i + 1][j][0] += f[i][j][r];\n\t\t\t\tf[i + 1][j + 1][1] += f[i][j][r];\n\t\t\t\tif(!r && j > 0){\n\t\t\t\t\tf[i][j - 1][0] += f[i][j][r];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\tfor(int j = 0; j < n - k - 1; j++) ans *= 2;\n\tcout << ans.val << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n     \n#define LL long long\n#define RG register\n     \nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 2010, Mod = 1e9 + 7;\nint f[N][N], sum[N];\nint fpow(int a, int b) {\n\tif (b < 0) return 1;\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, k; read(n), read(k);\n\tf[0][n + 1] = 1;\n\tfor (int i = 1; i <= k; i++) {\n\t\tsum[n + 1] = f[i - 1][n + 1];\n\t\tfor (int j = n; j; j--) sum[j] = (sum[j + 1] + f[i - 1][j]) % Mod;\n\t\tfor (int j = 1; j <= n - i + 1; j++) f[i][j] = sum[j];\n\t}\n\tprintf(\"%lld\\n\", 1ll * fpow(2, n - k - 1) * sum[2] % Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fm, to)    for (int i = fm; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 2e3, mod = 1e9 + 7;\nint n, k, dp[nsz + 5][nsz + 5], suf[nsz + 5][nsz + 5], ans;\n\nint inline qpow(int a, int p) {\n    int res = 1;\n    for (; p > 0; p >>= 1) {\n        (p & 1) && (res = (num) res * a % mod);\n        a = (num) a * a % mod;\n    }\n    return res;\n}\n\nvoid inline upd(int &a, int b) {\n    (a += b) && (a >= mod) && (a -= mod);\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin >> n >> k;\n    dp[0][n + 1] = 1;\n    for (int j = n + 1; j >= 1; --j) {\n        suf[0][j] = 1;\n    }\n    cont (i, k - 1) {\n        cont (j, n) {\n            dp[i][j] = suf[i - 1][j + 1];\n            if (j + i - 1 <= n) {\n                upd(dp[i][j], dp[i - 1][j]);\n            }\n        }\n        for (int j = n; j >= 1; --j) {\n            upd(suf[i][j], (suf[i][j + 1] + dp[i][j]) % mod);\n        }\n    }\n    circ (j, 2, n + 1) {\n        upd(ans, dp[k - 1][j]);\n    }\n    ans = (num) ans * qpow(2, n - k - 1) % mod;\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        //\n        friend bool operator<(const mint& lhs, const mint& rhs) {\n            return lhs._v < rhs._v;\n        }\n        //\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        //\n        friend bool operator<(const mint& lhs, const mint& rhs) {\n            return lhs._v < rhs._v;\n        }\n        //\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=1000000007,MAX=2005;\nconst ll INF=1LL<<50;\n\nusing mint=atcoder::modint1000000007;\n\nmint inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=-inv[mod%i]*(mod/i);\n        fac[i]=fac[i-1]*i;\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\n\nmint comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*finv[b]*finv[a-b];\n}\n\nmint perm(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*finv[a-b];\n}\n\nmint dp[MAX][MAX],S[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    \n    int N,K;cin>>N>>K;\n    \n    if(N==1){\n        cout<<1<<endl;\n        return 0;\n    }\n    \n    if(K==N) K--;\n    mint ans=0;\n    \n    dp[0][0]=1;\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            dp[i+1][j+1]+=dp[i][j];\n        }\n        for(int j=1;j<=N;j++){\n            dp[i+1][j]+=S[i][i]-S[i][j-1];\n        }\n        for(int j=1;j<=N;j++) S[i+1][j]=S[i+1][j-1]+dp[i+1][j];\n    }\n    \n    for(int Y=N-K+1;Y<=N;Y++){\n        int gomi=(Y-1)-(N-K);\n        \n        mint sum=0;\n        for(int j=0;j<=N-Y;j++){\n            sum+=comb(j+gomi,gomi)*dp[N-Y][j];\n        }\n        ans+=sum*comb(Y-2,N-K-1);\n    }\n    \n    ans*=mint(2).pow(N-K-1);\n    \n    cout<<ans.val()<<endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define fin \"\\n\"\n\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntemplate <typename T>\ninline void chmin(T &l,T r){l=min(l,r);}\n\ntemplate <typename T>\ninline void chmax(T &l,T r){l=max(l,r);}\n\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\nconst int MOD=1e9+7;\n#define SZ 5123\nLL comb[SZ][SZ];\nLL pow2[SZ];\nLL C[SZ][SZ];\nstruct latte{\n    latte(){\n        pow2[0]=1;\n        FOR(i,1,SZ)(pow2[i]=pow2[i-1]<<1)%=MOD;\n        REP(i,SZ)comb[i][0]=comb[i][i]=1;\n        FOR(i,2,SZ){\n            FOR(j,1,SZ){\n                comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n            }\n        }\n        REP(i,SZ)REP(j,SZ)C[i][j]=0;\n        C[0][0]=1;\n        REP(i,SZ-1){\n            FOR(j,0,SZ-1){\n                C[i+1][j+1]+=C[i][j];\n                C[i+1][0]+=MOD-C[i][j];\n            }\n            for(int j=SZ-1;j>0;j--)\n                (C[i+1][j-1]+=C[i+1][j])%=MOD;\n        }\n    }\n}malta;\n\ninline LL nHr(LL n,LL r){\n    return comb[n+r-1][r];\n}\nint main(){\n    int N,K;\n    cin>>N>>K;\n    LL res=0;\n    REP(i,K){\n        int n=i;\n        int r=K-i-1;\n        LL ans=0;\n        REP(j,n+1)ans+=C[n][j]*nHr(j+1,r)%MOD;    \n        ans%=MOD;\n        (res+=ans*comb[N-n-2][r]%MOD)%=MOD;\n    }\n    cout<<res*pow2[N-K-1]%MOD<<endl;\n    return 0;\n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\") \n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS 1e-10\n#define set0(x) memset((x),0,sizeof(x))\n#define setINF(x) memset((x),63,sizeof(x))\nusing namespace std;\nconst int N=2005;\nint n,k;\nlong long dp[N][N],ans;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n>>k;\n\tdp[1][1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++)dp[i][j]=(dp[i-1][j]+dp[i][j-1])%MOD;\n\t}\n\tans=dp[n][k];\n\tfor(int i=1;i<n-k;++i)(ans*=2ll)%=MOD;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n    if (k&1)\n        sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;i<=n;i++) g[0][i]=1;\n    for (int i=1;i<k;i++)\n\t    for (int j=1;j<=n+i;j++)\n\t\tg[i][j]=(g[i-1][j+1]+g[i][j-1])%mod;\n    printf(\"%lld\\n\",1ll*g[k-1][n-k+1]*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007ll\n//作者:中国江苏南京丁天行\nusing namespace std;\nll f[2005][2005],b[2005];\nint n,k;\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    b[0]=b[1]=1;\n    for(int i=2;i<=n;++i)b[i]=b[i-1]*2ll%orz;\n    for(int i=1;i<=n;++i)f[1][i]=1;\n    for(int i=2;i<=k;++i){\n        f[i][i]=f[i-1][i];\n        for(int j=i+1;j<=n;++j)f[i][j]=(f[i-1][j]+f[i][j-1])%orz;\n    }\n    printf(\"%lld\\n\",f[k][n]*b[n-k]%orz);\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N,K;\nll mod = 1000000007;\nll dp[2010][2010];\nll ans;\n\nint main()\n{\n    scanf(\"%d%d\",&N,&K);\n\n    ll p = 1;\n    for(int i = 0; i < N - K - 1; i++)p = p * 2 % mod;\n\n    dp[0][0] = 1;\n    for(int i = 1; i < N; i++)\n    {\n        for(int j = N; j >= 0; j--)\n        {\n            dp[i][j] = dp[i][j + 1];\n            dp[i][j] += dp[i - 1][j];\n            dp[i][j] %= mod;\n            if(i - j == K - 1)\n            {\n                ans += dp[i][j];\n                ans %= mod;\n            }\n        }\n        for(int j = 0; j < N; j++)\n        {\n            if(j)dp[i][j] += dp[i - 1][j - 1];\n            dp[i][j] %= mod;\n        }\n    }\n    ans += (K == 1);\n\n    printf(\"%lld\\n\",ans * p % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,jc[3333],injc[3333],ans;\nint binpow(int a,int t)\n{\n\tint res=1,p=a;\n\tfor (int i=t;i;i>>=1)\n\t{\n\t\tif (i&1) res=1ll*res*p%mod;\n\t\tp=1ll*p*p%mod;\n\t}\n\treturn res;\n}\nvoid Init()\n{\n\tjc[0]=injc[0]=1;\n\tfor (int i=1;i<=3000;i++)\n\t{\n\t\tjc[i]=1ll*jc[i-1]*i%mod;\n\t\tinjc[i]=1ll*injc[i-1]*binpow(i,mod-2)%mod;\n\t}\n}\nint C(int n,int k)\n{\n\tif (n<k) return 0;\n\treturn 1ll*jc[n]*injc[k]%mod*injc[n-k]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tInit();\n\tans=C(n+k-2,n-1)-C(n+k-2,n);\n\tif (n>k) ans=1ll*ans*binpow(2,n-k-1)%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\n\nconst ll MOD = 1000000007;\nconst int MN = 2010;\n\ninline void add(ll &x, ll y) { x += y; if (x >= MOD) x -= MOD; }\n\nll dp[MN][MN][2];\n\nint main() {\n\tint N, K; cin >> N >> K;\n\n\tdp[N][0][0] = 1;\n\n\tfor (int i = N; i >= 1; --i) {\n\t\tfor (int j = N; j >= 0; --j) {\n\t\t\tadd(dp[i-1][j][0], dp[i][j][0] + dp[i][j][1]);\n\t\t\tif (j > 0) {\n\t\t\t\tadd(dp[i][j-1][0], dp[i][j][0]);\n\t\t\t}\n\t\t\tadd(dp[i-1][j+1][1], dp[i][j][0] + dp[i][j][1]);\n\t\t}\n\t}\n\n\tll ans = (dp[1][N-K][0] + dp[1][N-K][1]) % MOD;\n\trep(i, N-K-1) ans = ans * 2 % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7,N=2005;\nint n,k,dp[N][N];\ninline long long ksm(long long x,long long y)\n{\n\tlong long gg=1ll;\n\twhile(y)\n\t{\n\t\tif(y&1ll)(gg*=x)%=mod;\n\t\t(x*=x)%=mod;  y>>=1ll;\n\t}\n\treturn gg;\n}\nsigned main(signed argc, char const *argv[])\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>k;\n\tdp[0][n+1]=1ll;\n\tfor(signed i=1;i<=k;i++)\n\t{\n\t\tint sum=dp[i-1][n+1];\n\t\tfor(signed j=n;j>=1;j--)\n\t\t{\n\t\t\t(sum+=dp[i-1][j])%=mod;\n\t\t\tif(j<=n-i+1)dp[i][j]=sum;\n\t\t}\n\t}\n\tlong long res=(dp[k][1]-dp[k-1][1]+mod)%mod;\n\tcout<<1ll*res*ksm(2ll,n-k-1)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define ll long long\nconst ll mod = 1e9+7; \nusing namespace std;\nint read(){\n\tint x=0,pos=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;\n\tfor(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn pos?x:-x;\n}\nconst int N = 3001;\nint n,k;\nll f[N][N];\nint main(){\n\tn=read(),k=read();\n\tfor(int i=2;i<=n;i++){\n\t\tf[1][i]=1;\n\t}\n\tfor(int i=1;i<k-1;i++){\n\t\tll sum=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--){\n\t\t\tsum=(sum+f[i][j])%mod;\n\t\t\tf[i+1][j]=sum;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=2;i<=n;i++){\n\t\tans=(ans+f[k-1][i])%mod;\n\t}\n\tif(k==1){\n\t\tans=1;\n\t}\n\tif(k!=n){\n\t\tll pm=1;\n\t\tfor(int i=1;i<=n-k-1;i++){\n\t\t\tpm=pm*2ll%mod;\n\t\t}\n\t\tans=ans*((pm)%mod)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\nconst int P=1e9+7,maxn=2e3+10;\nint n,k,dp[maxn],tot;\ninline void upd(int &x,int y){x+=y;(x>=P)&&(x-=P);}\ninline int ksm(int a,int b){\n\tint ans=1;if(b<0) return 1;\n\tfor(;b;b>>=1,a=1ll*a*a%P) if(b&1) ans=1ll*ans*a%P;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);dp[n+1]=1;\n\trep(i,1,k-1) per(j,n-i+1,2) upd(dp[j],dp[j+1]);\n\trep(i,2,n-k+2) upd(tot,dp[i]);\n\tprintf(\"%lld\\n\",1ll*tot*ksm(2,n-k-1)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nconst int N = 2005;\nconst int mo = 1e+9+7;\n\nint c[N*2][N*2];\nint f[N][N];\nint g[N];\nint n,k;\n\nint add(int x,int y){return x+y>=mo?x+y-mo:x+y;}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfo(i,0,4000){\n\t\tc[i][0]=1;\n\t\tfo(j,1,i)c[i][j]=add(c[i-1][j-1],c[i-1][j]);\n\t}\n\tf[1][1]=1;\n\tfo(i,2,k){\n\t\tfo(j,1,i-1)f[i][j+1]=add(f[i][j+1],f[i-1][j]);\n\t\tint sum=0;\n\t\tfd(j,i-1,1){\n\t\t\tsum=add(sum,f[i-1][j]);\n\t\t\tf[i][j]=add(f[i][j],sum);\n\t\t}\n\t\tg[i-1]=sum;\n\t}\n\tg[0]=1;\n\tint ans=g[k-1];\n\tif (n-2>=k-1)\n\tfo(i,1,k-1){\n\t\tif (i==k-1)ans=add(ans,c[n-2-(k-1-i)][i]);\n\t\telse{\n\t\t\tint tmp=c[n-2-(k-1-i)][i];\n\t\t\tfo(x,1,k-1-i)\n\t\t\tans=add(ans,1ll*tmp*f[k-1-i][x]%mo*c[x+i][i]%mo);\n\t\t}\n\t}\n\tfo(i,1,n-k-1)ans=ans*2%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,dp[2005];\ninline int ksm(int x,int y)\n{\n\tint g=1ll;\n\twhile(y)\n\t{\n\t\tif(y&1)g=g*x%mod;\n\t\tx=x*x%mod; y>>=1;\n\t}\n\treturn g;\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>k; dp[0]=1ll;\n\tfor(int i=1;i<n;i++,dp[0]=dp[1])\n\tfor(int j=i;j>=1;j--)dp[j]=(dp[j+1]+dp[j-1])%mod;\n\tcout<<dp[n-k]*ksm(2,n-k-1)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n\nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = (ans + f[K-1][i]) % MM;\n\tcout<<((K!=n)?(ans * pw[n-K-1] % MM):ans)<<endl;\n}\n\nvoid printans(){\n\n}\n\n\nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 29.12.2019 21:06:20       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<vector<Mint>> C(n + 1, vector<Mint>(n + 1));\n  for (int i = 0; i <= n; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++) C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n  }\n  vector<vector<Mint>> dp(n + 1, vector<Mint>(n + 1));\n  dp[1][1] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int j = 1; j <= i; j++) {\n      dp[i + 1][j + 1] += dp[i][j];\n    }\n    Mint sum = 0;\n    for (int k = i; k >= 1; k--) {\n      sum += dp[i][k];\n      dp[i + 1][k] += sum;\n    }\n/*      for (int k = 0; k <= i; k++) {\n        if (k > j) {\n          continue;\n        }\n        if (k == 0) {\n        } else {\n          dp[i + 1][k] += dp[i][j];\n        }\n      }*/\n//    }\n  }\n  Mint ans = 0;\n/*  for (int j = 0; j <= n; j++) {\n    ans += dp[k - 1][j];\n  }\n  if (k == 1) ans += 1;\n  ans *= C[n - 1][k - 1] * (k == n ? 1 : power(Mint(2), n - k - 1));*/\n  for (int j = 1; j <= k - 1; j++) {\n    Mint cur = dp[k - 1][j];\n    cur *= C[j + (n - k)][n - k];\n    cur *= (k == n ? 1 : power(Mint(2), n - k - 1));\n//    debug(j, cur);\n    ans += cur;\n  }\n  if (k == 1) ans = power(Mint(2), n - 2);\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\n\n//負数がないMOD関数\ninline long long imod(long long a, long long b)\n{\n\treturn (a >= 0) ? (a % b) : (a % b + b);\n}\n\n//mint_base型用の累乗関数\ntemplate <long long MOD> class mint_base;\ntemplate <long long MOD> mint_base<MOD> m_pow(long long x, long long n);\n\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <long long MOD = 1000000007>\nclass mint_base\n{\npublic:\n\tmint_base<MOD> operator+(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a + other.a, MOD));\n\t}\n\tmint_base<MOD> operator-(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a - other.a, MOD));\n\t}\n\tmint_base<MOD> operator*(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a * other.a, MOD));\n\t}\n\tmint_base<MOD> operator+=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a + other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator-=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a - other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator*=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a * other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator+()const\n\t{\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator-()const\n\t{\n\t\treturn mint_base<MOD>(-a);\n\t}\n\tmint_base<MOD>& operator++()\n\t{\n\t\t*this += 1;\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator++(int)\n\t{\n\t\tauto tmp = *this;\n\t\t*this += 1;\n\t\treturn tmp;\n\t}\n\tmint_base<MOD>& operator--()\n\t{\n\t\t*this -= 1;\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator--(int)\n\t{\n\t\tauto tmp = *this;\n\t\t*this -= 1;\n\t\treturn tmp;\n\t}\n\tmint_base<MOD> operator~()const\n\t{\n\t\treturn m_pow<MOD>(a, (long long)e_phi - 1);\n\t}\n\tmint_base<MOD>& operator=(const mint_base<MOD> &other)\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\texplicit operator long long()const\n\t{\n\t\treturn a;\n\t}\n\texplicit operator int()const\n\t{\n\t\treturn (int)a;\n\t}\n\n\t//無効な数値を指定された場合\n\tstatic_assert(MOD >= 2, \"MOD cannot be below 2.\");\n\tmint_base(long long a_) :a(imod(a_, MOD))\n\t{\n\t\tif (e_phi > 0)return;\n\t\t//オイラー値の導出\n\t\te_phi = MOD;\n\t\tlong long m_ = MOD;\n\t\tfor (int i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\te_phi = e_phi / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)e_phi = e_phi / m_ * (m_ - 1);\n\t}\n\tmint_base() :a(0) {}\nprivate:\n\tstatic long long e_phi;\n\tlong long a;\n};\n\n//mint_base型用の累乗関数\ntemplate<long long MOD>mint_base<MOD> m_pow(long long x, long long n)\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tx %= MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<long long MOD>mint_base<MOD> fact(mint_base<MOD> x)\n{\n\tmint_base<MOD> res(1);\n\tfor (long long i = 1; i <= (long long)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n\n//mint_baseの階乗計算\n//0からxまでの階乗をsetに出力する\ntemplate<long long MOD>void fact_set(std::vector<mint_base<MOD>> &set, mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tset.push_back(1);\n\tfor (long long i = 1; i <= (long long)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset.push_back(res);\n\t}\n}\n\ntemplate<long long MOD>long long mint_base<MOD>::e_phi = -1;\n\n//mint_base型のstreamへの出力\ntemplate<long long MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (long long)i;\n\treturn os;\n}\n\n//mint_base型のstreamからの入力\ntemplate<long long MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tlong long tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\n\ntypedef mint_base<> mint;\n\n\nmap<pair<int, int>, mint>memo;\nmint dp(int s, int t)\n{\n\tif (memo.count({ s,t }))return memo[{s, t}];\n\tif (s < t || t < 0)return 0;\n\treturn memo[{s, t}] = dp(s - 1, t) + dp(s, t - 1);\n}\n\nint main(void)\n{\n\tint N, K;\n\tcin >> N >> K;\n\tint dif = N - K - 1;\n\tdif = max(dif, 0);\n\tvector<mint>vec;\n\tfact_set<1000000007>(vec, 2345);\n\tauto comb = [&vec](int n, int k)\n\t{\n\t\tif (n < k || n < 0 || k < 0)return mint(0);\n\t\treturn vec[n] * ~vec[k] * ~vec[n - k];\n\t};\n\tmint ans = 0;\n\tmemo[{0, 0}] = 1;\n\tfor (int m = 0; m <= N; ++m)\n\t{\n\t\tmint res = comb(m - 2, dif);\n\t\tres *= m_pow<1000000007>(2, dif);\n\t\tres *= dp(K - 1, N - m);\n\t\tans += res;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nconst int N = 2010;\nconst int MOD = 1e9 + 7;\nint f[N][N], ans;\nint main()\n{\n    cin >> n >> k;\n    f[0][n + 1] = 1;\n    for (int i = 1; i < k; ++ i)\n        for (int j = n + 1, s = 0; j > 1; s = (s + f[i - 1][j --]) % MOD)\n            f[i][j] = (1ll * f[i - 1][j] * max(min(1, n - j - i + 2), 0) + s) % MOD;\n    for (int i = 2; i <= n + 1; ++ i) ans = (ans + f[k - 1][i]) % MOD;\n    for (int i = 1; i < n - k; ++ i) ans = (ans + ans) % MOD;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e3+7,p=1e9+7;\nint n,k,f[N][N];\nint main(){\n\tcin>>n>>k,f[0][n]=1;\n\tfor(int i=1;i<k;i++){\n\t\tfor(int j=1;j<=n-i+1;j++) f[i][j]=(f[i-1][n]-f[i-1][j-1]+p)%p;\n\t\tfor(int j=1;j<=n;j++) f[i][j]=(f[i][j]+f[i][j-1])%p;\n\t}\n\tint ans=(f[k-1][n]-f[k-1][1]+p)%p,c=n-k-1; while(c>0) ans=ans*2%p,c--; cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100000\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define SI 2002\n#define ADD(X,Y) (X) = ((X)+(Y))%MOD\n\nint n, k;\nll dp[SI][SI];\n\nint main(){\n    cin >> n >> k;\n    if(n == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    for(int i = 2; i <= n; i++) dp[1][i] = 1;\n    for(int i = 2; i <= k-1; i++){\n        ll sum = 0;\n        for(int j = n; j >= 2; j--){\n            if(i <= n-j) ADD(dp[i][j],dp[i-1][j]);\n            ADD(dp[i][j],sum);\n            ADD(sum,dp[i][j]);\n        }\n    }\n    ll ans = 0;\n    if(k == 1){\n        ans = 1;\n    } else{\n        for(int i = 2; i <= n; i++) ADD(ans,dp[k-1][i]);\n    }\n    rep(i,n-k-1) ADD(ans,ans);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=4000;\nconst int mod=1e9+7;\nint n,k;\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if(k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint fac[maxn+10],ifac[maxn+10],inv[maxn+10];\n\nint C(int a,int b){return (a<0)||(b<0)||(a<b)?0:1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\n\nint F(int i,int j){return 1ll*C(i+j,i)*(i-j+1)%mod*inv[i+1]%mod;}\n\nint main()\n{\n    fac[0]=inv[0]=inv[1]=ifac[0]=1;\n    for(int i=1; i<=maxn; ++i)\n\t{\n\t    fac[i]=1ll*fac[i-1]*i%mod;\n\t}\n    for(int i=2; i<=maxn; ++i) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=1; i<=maxn; ++i) ifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n    n=read(),k=read();\n    printf(\"%lld\\n\",1ll*F(n-1,k-1)*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<0>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\nvec fact,inv;\nvoid init(int n){\n  fact.assign(n+1,1);\n  inv.assign(n+1,1);\n  REP(i,n) fact[i+1] = fact[i]*(i+1), inv[i+1] /= fact[i+1];\n}\n\nmint cmb(int n, int r){\n  if(n < r) return 0;\n  return fact[n]*inv[r]*inv[n-r];\n}\n\nmint dp[2020][2020][2];\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int N,K;\n  cin >> N >> K;\n\n  dp[N-1][0][0] = 1;\n  RFOR(i,1,N){\n    REP(j,N-1){\n      dp[i-1][j][0] += dp[i][j][0]+dp[i][j][1];\n      dp[i-1][j+1][1] += dp[i][j][0]+dp[i][j][1];\n    }\n    RFOR(j,1,N) dp[i-1][j-1][0] += dp[i-1][j][0];\n  }\n\n  cout << (dp[0][N-K][0]+dp[0][N-K][1])*modpow((mint)2,max(0LL,N-K-1)) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long P=1000000007ll;\nlong long n,k,f[10001];\nlong long w(long long ,int );\nint main( )\n{\n    int i,j;\n    cin>>n>>k;\n    f[0]=1ll;\n    for(i=1;i<n;++i)\n        for(j=i;j;--j)\n            f[j]=(f[j+1]+f[j-1])%P,f[0]=f[1];\n    cout<<f[n-k]*w(2ll,n-k-1)%P;\n    return 0;\n}\nlong long w(long long a,int x)\n{\n    if(x<0)\n        return 1;\n    long long s=1ll;\n    while(x)\n        if(x&1)\n            (s*=a)%=P,(a*=a)%=P,x>>=1;\n    return s;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e3 + 5;\nconst int MOD = 1e9 + 7;\n\nint N, K;\n\nvoid input()\n{\n    read(N); read(K);\n}\n\nLL fpm(LL base, LL exp)\n{\n    LL ret = 1;\n    for (; exp; exp >>= 1) {\n        if (exp & 1)\n            (ret *= base) %= MOD;\n        (base *= base) %= MOD;\n    }\n    return ret;\n}\n\nLL fac[MAXN], ifac[MAXN], pow2[MAXN];\n\ninline LL binom(int n, int k)\n{\n    assert(0 <= k && k <= n);\n    return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;\n}\n\nvoid solve()\n{\n    fac[0] = 1;\n    for (int i = 1; i <= N; ++i) {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n    ifac[N] = fpm(fac[N], MOD - 2);\n    for (int i = N; i >= 1; --i) {\n        ifac[i - 1] = ifac[i] * i % MOD;\n    }\n\n    static LL dp[MAXN][MAXN];\n\n    for (int i = 0; i <= N; ++i) {\n        dp[i][0] = 1;\n        for (int j = 1; j < i; ++j) {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < K; ++i) {\n        (ans += dp[K - 1][i] * binom(N - 1 - i, K - 1 - i) % MOD) %= MOD;\n    }\n    for (int i = 0; i < N - K - 1; ++i) {\n        (ans *= 2) %= MOD;\n    }\n\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 醉别西楼醒不记。春梦秋云，聚散真容易。\n//     -- 晏几道《蝶恋花·醉别西楼醒不记》\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RANK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2005;\nconst int mod = 1e9+7;\nint fac[maxn],inv[maxn],n,k;\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\ninline int C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\ninline int calc(int x,int y){\n\treturn C(x+y,x);\n}\nint main(){\n\tn = rd(),k = rd();\n\tfac[0] = 1;\n\tRep(i,1,n+k) fac[i] = 1ll * fac[i-1] * i % mod;\n\tinv[n+k] = qpow(fac[n+k],mod-2);\n\tDep(i,n+k-1,0) inv[i] = 1ll * inv[i+1] * (i+1) % mod;\n\tll ans = calc(n,k-1)-2*calc(n,k-2);\n\tRep(i,1,n-k-1)ans=ans*2%mod;\n\twriteln(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll; \nll dp[2005][2005], ans; \nint main()\n{\n\t// freopen(\"ARC068-F.in\", \"r\", stdin);\n\tint n, k; \n\tscanf(\"%d%d\", &n, &k); \n\tdp[0][n] = 1; \n\tfor (int i = 0; i < k - 1; i++)\n\t{\n\t\tll cur = dp[i][n - i]; \n\t\tfor (int j = n - i - 1; j >= 1; j--)\n\t\t{\n\t\t\t(cur += dp[i][j]) %= MOD; \n\t\t\t(dp[i + 1][j] += cur) %= MOD; \n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\t(ans += dp[k - 1][i]) %= MOD; \n\tfor (int i = 1; i < n - k; i++)\n\t\tans = ans * 2 % MOD; \n\tprintf(\"%lld\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2345, mod = 1e9 + 7;\n\nvoid add(int& x, int y) {\n  x += y;\n  if (x >= mod) {\n    x -= mod;\n  }\n}\n\nint n, k, dp[N][N][2];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  dp[n + 1][0][0] = 1;\n  for (int i = n + 1; i > 1; --i) {\n    for (int j = n; ~j; --j) {\n      add(dp[i][j][0], dp[i][j + 1][0]);\n      for (int k = 0; k < 2; ++k) {\n        add(dp[i - 1][j][0], dp[i][j][k]);\n        add(dp[i - 1][j + 1][1], dp[i][j][k]);\n      }\n    }\n  }\n  int answer = dp[1][n - k][0];\n  for (int i = 1; i <= n - k - 1; ++i) {\n    answer = (answer << 1) % mod;\n  }\n  cout << answer << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define ll long long\nconst ll mod = 1e9+7; \nusing namespace std;\nint read(){\n\tint x=0,pos=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;\n\tfor(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn pos?x:-x;\n}\nconst int N = 2001;\nint n,k;\nll f[N][N];\nint main(){\n\tn=read(),k=read();\n\tfor(int i=2;i<=n;i++){\n\t\tf[1][i]=1;\n\t}\n\tfor(int i=1;i<k-1;i++){\n\t\tll sum=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--){\n\t\t\tsum=(sum+f[i][j])%mod;\n\t\t\tf[i+1][j]=sum;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=2;i<=n-k+2;i++){\n\t\tans=(ans+f[k-1][i])%mod;\n\t}\n\tif(k==1){\n\t\tans=1;\n\t}else if(k!=n){\n\t\tll pm=1;\n\t\tfor(int i=1;i<=n-k-1;i++){\n\t\t\tpm=pm*2ll%mod;\n\t\t}\n\t\tans=ans*((pm)%mod)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e3+5,mod=1e9+7;\nint n,k;\nlong long ans=0,f[maxn][maxn],dp[maxn][maxn];\nlong long qpow(long long x,int i){\n\tlong long res=1;\n\twhile(i){\n\t\tif(i&1){res=res*x%mod;}\n\t\tx=x*x%mod;i/=2;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tmemset(f,0,sizeof(f));\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][2]=1;\n\tfor(int i=n;i>=2;i--){f[1][i]=1;dp[1][i]=(f[1][i]+dp[1][i+1])%mod;}\n\tfor(int i=2;i<k;i++){\n\t\tfor(int j=n-i+1;j>=2;j--){\n\t\t    f[i][j]=(f[i-1][j]+dp[i-1][j+1])%mod;\n\t\t\tdp[i][j]=(f[i][j]+dp[i][j+1])%mod;\n\t\t}\n\t}\n\tans=dp[k-1][2];\n\tans=ans*qpow(2,max(n-k-1,0))%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int MM=1e3+10;\n\tll fac[MM],facinv[MM],Inv[MM];ll Comb(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,MM-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[MM-1]=invm(fac[MM-1]);fd(i,MM-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,MM-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=2e3+10;\n\t//------------------FIXED------------------\n\tint dp[N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),k=qread();dp[0][n+1]=1;\n\t\tfo(i,1,k-1)\n\t\t{\n\t\t\tint sum=dp[i-1][n+1];\n\t\t\tfd(j,n,2) dp[i][j]=(sum+((n-j+1)>(i-1))*dp[i-1][j])%MOD,add(sum,dp[i-1][j]);\n\t\t}int ans=0;fo(j,2,n+1) add(ans,dp[k-1][j]);fo(t,1,n-1-k) ans=ans*2%MOD;write(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();\n\tmine::main();\n\tdebug(\"\\n------------------------------------------\\nTime: %.2lf s\\n\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define FORD(i,b,a) for (int i = (int)(b) - 1; i >= a; --i)\n#define REP(i,N) FOR(i,0,N)\n#define st first\n#define nd second\n#define pb push_back\n\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\nconst int MOD = 1000000007;\nLL DP[2005][2005];\n\nint main() {\n  int N, K;\n  scanf(\"%d%d\", &N, &K);\n  FOR(i,1,N-K+2) DP[N-K+1][i] = 1;\n  FOR(i,N-K+2,N+1) {\n    LL su = 0;\n    REP(j,i+1) {\n      su += DP[i-1][j];\n      DP[i][j] = su % MOD;\n    }\n  }\n  LL res = DP[N][N];\n  REP(i,max(0, N-K-1)) res = 2 * res % MOD;\n  printf(\"%lld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RANK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2005;\nconst int mod = 1e9+7;\nint f[maxn],n,k;\nint main(){\n\tn = rd(),k = rd();\n\tmem(f,0);\n\tf[n+1] = 1;\n\tDep(i,n,n-k+1){\n\t\tDep(j,n,i+1)f[j]=0;\n\t\tDep(j,i,1) f[j] = (f[j] + f[j+1]) % mod;\n\t}\n\tll ans = f[1];\n\tRep(i,1,n-k-1)ans=ans*2%mod;\n\twriteln(ans);\n}\n//看不懂题解233"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvoid solve() {\n  int n, k; cin >> n >> k;\n\n  Graph<int> dp(k, vi(n, 0));\n  rep(i,n) dp[0][i] = 1;\n\n  rep1(i,k) {\n    int sum = dp[i-1][n-i];\n    rrep(j,n-i) {\n      dp[i][j] = (sum += dp[i-1][j]) %= MOD;\n    }\n  }\n\n  ll ans = dp[k-1][0] - (k == 1 ? 0 : dp[k-2][0]);\n  if (ans < 0) ans += MOD;\n\n  if (k < n) ans = ans * modpow(2, n - k - 1) % MOD;\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int N=2005,mo=1000000007;\nint f[N][N],fac[N],inv[N];\nint ksm(int x,int y){\n\tint i=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mo)\n\t\tif (y&1) i=1ll*i*x%mo;\n\treturn i;\n}\nlong long C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tf[0][0]=1;\n\tfor (int i=0;i<=k;i++)\n\t\tfor (int j=0;i+j<=k;j++){\n\t\t\tif (j) f[i][j]=f[i][j-1];\n\t\t\tif (i) (f[i][j]+=f[i-1][j+1])%=mo;\n\t\t}\n\tint ans=0;\n\tif (k==n) ans=f[n-1][0];\n\telse{\n\t\tfac[0]=1;\n\t\tfor (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mo;\n\t\tinv[n]=ksm(fac[n],mo-2);\n\t\tfor (int i=n;i;i--) inv[i-1]=1ll*inv[i]*i%mo;\n\t\tfor (int m=n-k+1;m<=n;m++)\n\t\t\tans=(ans+C(m-2,n-k-1)*f[n-m][k-1-n+m])%mo;\n\t}\n\tfor (int i=1;i<n-k;i++) (ans<<=1)%=mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod dp[MAX_N][MAX_N], sm[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, K;\n    cin >> n >> K;\n    dp[0][n] = sm[n+1] = 1;\n    rep(i,K){\n        if(i < K - 1){\n            srep(j,1,n-i){\n                dp[i+1][j] = sm[n-i+1] - sm[j];\n            }\n            rep(j,n){\n                sm[j+1] = sm[j] + dp[i+1][j];\n            }\n        }else{\n            dp[i+1][0] = sm[n-i+1] - sm[1];\n        }\n    }\n    cout << dp[K][0] * mod_pow((mod)2, max(0, n-K-1)) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (2009)\n#define MOD (1000000007)\nusing namespace std;\n\nint n,k,ans,f[N][N],s[N];\n\nint main()\n{\n\tcin>>n>>k;\n\tf[0][n+1]=1; s[n+1]=1;\n\tfor (int i=n; i>=1; --i) s[i]=s[i+1]+f[0][i];\n\tfor (int i=1; i<=k-1; ++i)\n\t{\n\t\tfor (int j=1; j<=n-i+1; ++j) f[i][j]=s[j];\n\t\ts[n+1]=f[i][n+1];\n\t\tfor (int j=n; j>=1; --j) s[j]=(s[j+1]+f[i][j])%MOD;\n\t}\n\tfor (int i=2; i<=n+1; ++i) (ans+=f[k-1][i])%=MOD;\n\tfor (int i=1; i<=n-k-1; ++i) (ans*=2)%=MOD; \n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int mod=1000000007;\nint N,K,fac[4010],ifac[4010];\nll inv(int a,int p=mod){return a==1?1:(1+p*(a-inv(p%a,a)))/a%p;}\nint C(int n,int m){return m<0||m>n?0:1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nint main(){\n\tscanf(\"%d%d\",&N,&K);\n\tfor(int i=*fac=1;i<=N+K;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[N+K]=inv(fac[N+K]);\n\tfor(int i=N+K;i;i--)ifac[i-1]=1ll*ifac[i]*i%mod;\n\tint ans=(C(N+K-2,N-1)-C(N+K-2,N)+mod)%mod;\n\tfor(int i=N-K;--i>0;)ans=ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=2005,M=4005,P=1e9+7;\n\nint n,k,fac[M],ifac[M],inv[M],a,m,f[N];\n\ninline int catalan(int n){\n\treturn (ll)fac[n<<1]*ifac[n]%P*ifac[n]%P*inv[n+1]%P;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfac[0]=ifac[0]=1;inv[1]=1;\n\tfor(int i=2;i<=2*n;i++)\n\t\tinv[i]=P-(ll)(P/i)*inv[P%i]%P;\n\tfor(int i=1;i<=2*n;i++){\n\t\tfac[i]=(ll)fac[i-1]*i%P;\n\t\tifac[i]=(ll)ifac[i-1]*inv[i]%P;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=catalan(i-1);\n\t\tfor(int j=2,l=min(i,k+1);j<l;j++)(f[j]+=f[j-1])%=P; \n\t}\n\ta=f[k];m=n-k-1;\n\twhile(m>0)(a<<=1)%=P,m--;\n\tprintf(\"%d\",a); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\nll dp[2500][2500];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    k--;\n    dp[0][0] = 1;\n    for (int i = 0; i < k; i++)\n    {\n        ll s = dp[i][0];\n        for (int j = 0; j < n - i - 1; j++)\n        {\n            s = s + dp[i][j + 1];\n            if (s >= MOD) s -= MOD;\n            dp[i + 1][j] = s;\n        }\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; i++) ans += dp[k][i];\n    ans %= MOD;\n    for (int i = 0; i < n - k - 2; i++) ans = (ans + ans >= MOD ? ans + ans - MOD : ans + ans);\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define ll long long\n#define mod 1000000007\n#define N 4010\nusing namespace std;\nll f[N][N],g[N][N];\nint main()\n{\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tg[n+1][0]=1;\n\tll res=1;\n\tfor(int i=1;i<=n-k-1;i++) res=res*2%mod;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\t(g[i][j+1]+=f[i+1][j]+g[i+1][j])%=mod;\n\t\t\t(f[i][j]+=f[i+1][j]+g[i+1][j])%=mod;\n\t\t}\n\t\tif(i!=1) for(int j=n;j>=0;j--) (f[i][j]+=f[i][j+1])%=mod;\n\t}\n\tprintf(\"%lld\\n\",f[1][n-k]*res%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\nusing namespace std;\ntypedef long long LL;\nconst LL O = 1000000007;\nconst int maxN = 2007;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nint n, m;\nint f[maxN][maxN];\n\nLL pwr(LL x, LL tms) {\n\tLL res = 1;\n\tfor (; tms > 0; tms >>= 1, x = (x * x) % O)\n\t\tif (tms & 1) res = (res * x) % O;\n\treturn res;\n}\n\nint main() {\n\n\tn = ri(), m = ri();\n\tf[0][0] = 1;\n\tFor (i, 1, n) {\n\t\trep (j, 0, i-1) f[i][j] = f[i-1][j];\n\t\tper (j, i-1, 0) (f[i][j] +=  f[i][j+1]) %= O;\n\t\trep (j, 1, i) (f[i][j] += f[i-1][j-1]) %= O;\n\t\trep (j, 0, i) printf(\"%d%c\", f[i][j], \" \\n\"[j == i]);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2010,p=1e9+7;\nint inc(int x,int y){x+=y;return x>=p?x-p:x;}\nint dec(int x,int y){x-=y;return x<0?x+p:x;}\nint n,k,dp[N][N];\n//dp[i][j]表示两个单调序列最后一个删掉的分别是i,j的方案数\nint main()\n{\n    cin>>n>>k;\n    dp[n+1][n+1]=1;\n    for (int i=n+1;i;i--)\n    for (int j=1;j<=i;j++){//钦定i>=j\n        dp[i][j]=inc(dp[i][j],dp[i][j-1]);\n        int v=dp[i][j];\n        if (!v) continue;\n        dp[i-1][1]=inc(dp[i-1][1],v);dp[i-1][j]=dec(dp[i-1][j],v);\n        if (i!=j) dp[i-1][j]=inc(dp[i-1][j],v),dp[i-1][j+1]=dec(dp[i-1][j+1],v);\n    }\n    int ans=0;\n    for (int i=2;i<=n+2-k;i++) ans=inc(ans,dp[n+2-k][i]);\n    for (int i=1;i<n-k;i++) ans=inc(ans,ans);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define fin \"\\n\"\n\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntemplate <typename T>\ninline void chmin(T &l,T r){l=min(l,r);}\n\ntemplate <typename T>\ninline void chmax(T &l,T r){l=max(l,r);}\n\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\nconst int MOD=1e9+7;\n#define SZ 2123\nLL comb[2*SZ][2*SZ];\nLL C[SZ][SZ];\nstruct latte{\n    latte(){\n        REP(i,2*SZ)comb[i][0]=comb[i][i]=1;\n        FOR(i,2,2*SZ){\n            FOR(j,1,2*SZ){\n                comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n            }\n        }\n        REP(i,SZ)REP(j,SZ)C[i][j]=0;\n        C[0][0]=1;\n        REP(i,SZ-1){\n            FOR(j,0,SZ-1){\n                C[i+1][j+1]+=C[i][j];\n                C[i+1][0]+=MOD-C[i][j];\n            }\n            for(int j=SZ-1;j>0;j--)\n                (C[i+1][j-1]+=C[i+1][j])%=MOD;\n        }\n    }\n}malta;\n\ninline LL nHr(LL n,LL r){\n    //if(r<0||n<r)return 0;\n    return comb[n+r-1][r];\n}\nint main(){\n    int N,K;\n    cin>>N>>K;\n    LL res=0;\n    if(N==K)return -1;\n    REP(i,K){\n        int n=i;\n        int r=K-i-1;\n        LL ans=0;\n        REP(j,n+1)\n            ans+=C[n][j]*nHr(j+1,r)%MOD;\n        ans%=MOD;\n        (res+=ans*comb[N-n-2][r]%MOD)%=MOD;\n    }\n    REP(i,N-K-1)(res<<=1)%=MOD;\n    cout<<res<<endl;\n    return 0;\n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=1e9+7,N=2005;\nint n,k,dp[N][N];\ninline int ksm(int x,int y)\n{\n\tint gg=1;\n\twhile(y)\n\t{\n\t\tif(y&1)(gg*=x)%=mod;\n\t\t(x*=x)%=mod;  y>>=1;\n\t}\n\treturn gg;\n}\nsigned main(signed argc, char const *argv[])\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>k;\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tint sum=dp[i-1][n+1];\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\t(sum+=dp[i-1][j])%=mod;\n\t\t\tif(j<=n-i+1)dp[i][j]=sum;\n\t\t}\n\t}\n\tint res=(dp[k][1]-dp[k-1][1]+mod)%mod;\n\tcout<<res*ksm(2,n-k-1)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k,ans;\nconst int N=2005;\nconst int mo=1e9+7;\nint f[N][N],sum[N][N];\nvoid upd(int &x,int y){\n\t(x+=y)>=mo?x-=mo:233;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tf[n+1][0]=1;\n\tfor (int i=n+1;i>=0;i--)\n\t\tfor (int j=n-k;j>=0;j--){\n\t\t\tif (i==1&&j==n-k) ans=sum[i+1][j];\n\t\t\tupd(f[i][j],f[i][j+1]);\n\t\t\tupd(f[i][j],sum[i+1][j]);\n\t\t\tsum[i][j]=(j?sum[i+1][j-1]:0);\n\t\t\tupd(sum[i][j],f[i][j]);\n\t\t}\n\tfor (int i=1;i<=n-k-1;i++)\n\t\tans=1ll*ans*2%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2000 + 10;\nconst ll MOD = 1000000007;\n\nint n, k;\nll fac[maxn], inv[maxn];\n\nint power(int x, int k) {\n  if(k < 0) return 1;\n  if(k == 0) return 1;\n  int tmp = 1LL;\n  while(k) {\n    if(k & 1) tmp = 1LL * tmp * x % MOD;\n    x = 1LL * x * x % MOD;\n    k >>= 1;\n  }\n  return tmp;\n}\n\nll dp[maxn][maxn], s[maxn];\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for(int i = 1;i <= n + 1;i ++) s[i] = 1;\n  for(int i = 1;i < k;i ++) {\n    for(int j = 1;j <= n - i + 1;j ++) dp[i][j] = (dp[i - 1][j] + s[j + 1]) % MOD;\n    for(int j = n - i;j <= n + 1;j ++) s[j] = 0;\n    for(int j = n - i + 1;j >= 0;j --) s[j] = (s[j + 1] + dp[i][j]) % MOD;\n  }\n  ll ans = 0;\n  for(int i = 2;i <= n;i ++) ans = (ans + dp[k - 1][i]) % MOD;\n  if(k == 1) ans = 1;\n  ans = 1LL * ans * power(2,n - k - 1) % MOD;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\n\nint C[2222][2222];\n\nint dp[2222][2222];\n\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nsigned main(){\n    for(int i=0;i<2222;i++){\n        C[i][i]=C[i][0]=1;\n        for(int j=1;j<i;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n\n    int N,K;\n    cin>>N>>K;\n\n    for(int i=2;i<=N;i++)dp[1][i]=1;\n    for(int i=1;i+1<K;i++){\n        int sum=0;\n        for(int j=N;j>=2;j--){\n            if(N-j+1-i>0)add(dp[i+1][j],dp[i][j]);\n            add(dp[i+1][j],sum);\n            add(sum,dp[i][j]);\n        }\n    }\n\n    int ans=0;\n    if(K==1){\n        ans=1;\n    }\n    else{\n        for(int i=2;i<=N;i++)add(ans,dp[K-1][i]);\n    }\n\n    for(int i=0;i<N-K-1;i++)ans=ans*2%mod;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long ll;\n\nconst int MAXN = 2E3 + 10;\nconst int MOD = 1E9 + 7;\n\nll modExp(ll e, ll n, ll m = MOD){\n\tll ret = 1;\n\tfor (; n; n >>= 1, e = e * e % m)\n\t\tif (n & 1)\n\t\t\tret = ret * e % m;\n\treturn ret;\n}\n\ninline void update(int &x, int y){\n\tif ((x += y) >= MOD)\n\t\tx -= MOD;\n}\n\nint f[MAXN][MAXN];\n\nint main(){\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= k - 1; ++i){\n\t\tint s = f[i - 1][i - 1];\n\t\tfor (int j = i; j < n; ++j){\n\t\t\tupdate(f[i][j], s);\n\t\t\tupdate(f[i][j], f[i - 1][j]);\n\t\t\tupdate(s, f[i - 1][j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tupdate(ans, f[k - 1][i]);\n\tprintf(\"%d\\n\", (int)(ans * modExp(2, n == k ? 1 : n - k - 1) % MOD));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int p=1e9+7;\nconst int maxn=1e5+5;\nll n,k,f[maxn],ans;\nll quickpow(ll a,ll t)\n{\n\tif(!t) return 1;\n\tll res=1;\n\twhile(t)\n\t{\n\t\tif(t&1) res=(res*a)%p;\n\t\tt>>=1;\n\t\ta=(a*a)%p;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0]=1;\n\tfor(ll i=1;i<n;i++)\n\t{\n\t\tfor(ll j=i;j>0;j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%p;\n\t\tf[0]=f[1];\n\t}\n\tans=f[n-k]*quickpow(2,n-k-1)%p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nconst long long P=1000000007ll;\nlong long n,k,f[10001];\n\nlong long qpow(long long a,int x){\n\tif(x<0)return 1;\n\tlong long s=1ll;\n\twhile(x){if(x&1)(s*=a)%=P;(a*=a)%=P;x>>=1;}\n\treturn s;\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0]=1ll;\n\tfor(int i=1;i<n;++i){for(int j=i;j;--j)f[j]=(f[j+1]+f[j-1])%P;f[0]=f[1];}\n\tprintf(\"%lld\",f[n-k]*qpow(2ll,n-k-1)%P);\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nlong long dp[2100][2100];\n\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tdp[0][a]=1;\n\tfor(int i=1;i<=b;i++){\n\t\tlong long tmp=0;\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tif(i<b&&j==0)continue;\n\t\t\ttmp=(tmp+dp[i-1][j+1])%mod;\n\t\t\tdp[i][j]=(dp[i][j]+tmp)%mod;\n\t\t\tif(j<=a-i)dp[i][j]=(dp[i][j]+dp[i-1][j])%mod;\n\t\t}\n\t}\n\tlong long ret=dp[b][0];\n\tret%=mod;\n\tret=ret*pw(2,max(0,a-b-1))%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "//Create Time: 2018-05-09 20:51:48\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cctype>\n#include <ctime>\n#include <utility>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <iterator>\n#include <tuple>\nusing namespace std;\n#define snuke(i,x) for (__typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)\n#define rep(i,a,n) for (int i=(a);i<(n);i++)\n#define per(i,n,a) for (int i=(n)-1;i>=(a);i--)\n// #define OUT(x) std::cout<<(#x)<<\":\"<<(x)<<std::endl\n// #define TST(x) std::cout<<(#x)<<\":\"<<(x)<<\" \"\n#define OUT(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\\n\",_it,args);}\n#define TST(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\",_it,args);}\n#define SZ(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define unq(x) sort(all(x)),(x).erase(unique(all(x)),(x).end())\n#define mem(f,x) memset((f), (x), sizeof(f))\n#define clr(f) mem(f,0)\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define eb emplace_back\n#define DEBUG\nvoid OUT_TST(string s,istream_iterator<string> it) {cerr<<s;}\ntemplate<typename T, typename... Args> void OUT_TST(string s,istream_iterator<string> it,T a,Args... args){cerr<<*it<<\"=\"<<a<<\" \";OUT_TST(s,++it,args...);}\ntemplate<class T> void rd(T&ret){ret=0;bool ok=0,u=0;for(;;){int c=getchar();if(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+c-'0',ok=1;else if(c=='-')u=1;else if(ok){if(u)ret*=-1;return;}}}\nlong long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\ntemplate <class T> bool chmin(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntemplate <class T> bool chmax(T& a, const T &b) {return b > a? a = b, 1: 0;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii > vii;\ntypedef tuple<int,int,int> tp;\n/****head****/\nconst int N=2005;\nconst ll mod=(ll)1e9+7;\ntemplate<int sz> struct Comb{\n    const long long mod = ::mod;\n    long long *fac, *ifac, *inv;\n    long long mem_fac[sz+5],mem_ifac[sz+5],mem_inv[sz+5];\n\n    // long long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\n\n    Comb(long long *fa=0,long long *ifa=0,long long *iv=0){\n        fac=fa?fa:mem_fac;\n        ifac=ifa?ifa:mem_ifac;\n        inv=iv?iv:mem_inv;\n        fac[0]=fac[1]=1;\n        ifac[0]=ifac[1]=1;\n        inv[0]=inv[1]=1;  // set inv[0]=?\n        for(int i=2;i<sz;++i){\n            fac[i]=i*fac[i-1]%mod;\n            inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n            ifac[i]=ifac[i-1]*inv[i]%mod;\n        }\n    }\n    long long C(long long n,long long m){  // n >= m\n        if(n<m)return 0;\n        return (fac[n]*ifac[m]%mod)*ifac[n-m]%mod;\n    }\n    long long A(long long n,long long m){\n        if(n<m)return 0;\n        return fac[n]*ifac[n-m]%mod;\n    }\n};\n\n// const int N=1<<17;\nlong long fac[N<<1],ifac[N<<1],inv[N<<1];\nComb<(N<<1)> comb(fac,ifac,inv);\n\nint f[N][N],sum[N][N],n,K;\nvoid add(int &a,int b){\n    a+=b;if(a>=mod)a-=mod;\n}\nint main(){\n    cin>>n>>K;\n    if(K==1){\n        cout<<powmod(2,max(n-2,0),mod)<<endl;\n        return 0;\n    }\n    if(K==n){\n        f[2][1]=1;\n    } else{\n        f[n-K+2][1]=1;\n        rep(i,n-K+2,n+1){\n            add(f[i][i-(n-K)-1],comb.C(i-2,n-K-1));\n        }\n    }\n    sum[2][2]=f[2][2];\n    sum[2][1]=sum[2][2];add(sum[2][1],f[2][1]);\n    rep(i,3,n+1)per(j,i+1,1){\n        add(f[i][j],sum[i-1][max(1,j-1)]);\n        sum[i][j]=sum[i][j+1];\n        add(sum[i][j],f[i][j]);\n    }\n    ll ans=0;\n    rep(i,1,n+1)ans+=f[n][i];\n    ans=ans%mod*powmod(2,max(n-K-1,0),mod)%mod;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2000 +10;\nconst long long mod = (long long)1000000007;\nint read(){\n\tint x=0,flag=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*flag;\n}\nint n,k;\nlong long f[maxn][maxn],g[maxn][maxn];\nlong long Pow(long long x,int t){\n\tlong long ans = 1LL;\n\twhile(t){\n\t\tif(t&1)ans=ans*x%mod;\n\t\tx=x*x%mod;t>>=1;\n\t}\n\treturn ans%mod;\n}\nlong long Add(long long x,long long y){\n\tif( x + y >= mod) return x + y - mod;\n\treturn x +y;\n}\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin),freopen(\"test.out\",\"w\",stdout);\n#endif\n\tn=read();k=read();\t\n\tf[1][n-k]=Pow(2LL,n-k-1);\n\n\tg[1][0]=0;\n\tfor(int j=1;j<=n;j++)g[1][j] = Add( g[1][j-1] , f[1][j] );\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif( n-i >= j )\n\t\t\t\tf[i][j] = Add( f[i-1][j+1] , g[i-1][j] ) ;\n\t\t\tg[i][j] = Add( g[i][j-1] , f[i][j] );\n\t\t}\n\tcout << f[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MOD=1000000007;\nconst int MAXN=2000;\n\n\nint n,pos;\nint p2[MAXN+1];\nint dp[MAXN+1][MAXN+1][2];\n\nint bf() {\n\tset<vector<int> > res;\n\tREP(i,1<<(n-1)) REP(j,1<<(n-1)) {\n\t\tdeque<int> q;\n\t\tq.push_back(0); REP(k,n-1) if(i&(1<<k)) q.push_back(k+1); else q.push_front(k+1);\n\t\tvector<int> cur;\n\t\tREP(k,n-1) if(j&(1<<k)) cur.PB(q.back()),q.pop_back(); else cur.PB(q.front()),q.pop_front(); cur.PB(q.back()),q.pop_back();\n\t\tif(cur[pos]!=0) continue;\n\t\tres.insert(cur);\n\t}\n\t//for(set<vector<int> >::iterator it=res.begin();it!=res.end();++it) { printf(\"sol:\"); REPSZ(i,*it) printf(\" %d\",(*it)[i]); puts(\"\"); }\n\treturn SZ(res);\n}\n\nint solve() {\n\tp2[0]=1; FORE(i,1,n) p2[i]=(ll)p2[i-1]*2%MOD;\n\tint nafter=n-pos-1;\n\tmemset(dp,0,sizeof(dp));\n\tREPE(j,n-1) {\n\t\tif(j>=nafter) dp[1][j][1]=nafter==0?1:p2[nafter-1];\n\t\tif(j==nafter) dp[1][j][0]=nafter==0?1:p2[nafter-1];\n\t}\n\tFORE(i,2,n) REPE(j,n-i) {\n\t\tdp[i][j][0]=((ll)dp[i-1][j+1][0]+dp[i-1][j][1])%MOD;\n\t\tdp[i][j][1]=((ll)dp[i-1][j+1][0]+dp[i-1][j][1]+(j==0?0:dp[i][j-1][1]))%MOD;\n\t}\n\t//REPE(i,n) REPE(j,n-i) REP(k,2) if(dp[i][j][k]!=0) printf(\"dp[%d][%d][%d]=%d\\n\",i,j,k,dp[i][j][k]);\n\tint ret=dp[n][0][0];\n\t/*if(n<=10) {\n\t\tint chk=bf();\n\t\tif(chk!=ret) printf(\"have %d want %d\\n\",ret,chk);\n\t}*/\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&pos); --pos;\n\tprintf(\"%d\\n\",solve());\n\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int inf = 2147483647;\nconst int mod = 1e9 + 7;\nconst int N = 2001;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(cr x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(cr x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(cr x) {put(x), putchar(' ');}\nI void pr2(cr x) {put(x), puts(\"\");}\n\nint f[N];\n\nint main() {\n\treg n = read(), k = read();\n\tf[n + 1] = 1;\n\tfo(i, 1, k - 1) {\n\t\treg sum = f[n - i + 2];\n\t\tfd(j, n - i + 1, 1) {\n\t\t\tsum = (sum + f[j]) % mod;\n\t\t\tf[j] = sum;\n\t\t}\n\t} f[1] = f[n - k + 2]; fo(i, 2, n - k + 1) f[1] = (f[1] + f[i]) % mod;\n\tfo(i, 1, n - k - 1) f[1] = 2 * f[1] % mod;\n\tpr2(f[1]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, K, mod = 1e9 + 7, c[2017][2017];\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint substract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\n\nint pow (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nvoid PrintSet (set < vector < int > > S)\n{\n    for (auto it = S.begin (); it != S.end (); it ++, printf (\"\\n\"))\n        for (auto it2 = (*it).begin (); it2 != (*it).end (); it2 ++)\n            printf (\"%d \", *it2);\n}\n\nvoid Brute2 ()\n{\n    int p[20];\n    set < vector < int > > S;\n    for (int i=1; i<=N; i++)\n        p[i] = i + 1;\n    do {\n        bool ok = 1;\n        for (int i=1; i<=N; i++)\n            for (int j=i + 1; j<=N; j++)\n                if (p[i] < p[j])\n                    for (int k=j + 1; k<=N; k++)\n                        if (p[j] < p[k])\n                        {\n                            ok = 0;\n                            i = j = N + 2;\n                            break;\n                        }\n        if (ok)\n        {\n            vector < int > curr;\n            for (int i=1; i<=N; i++)\n                curr.push_back (p[i]);\n            S.insert (curr);\n        }\n    }while (next_permutation (p + 1, p + N + 1));\n    //PrintSet (S);\n    printf (\"%d\\n\", S.size ());\n}\n\nint cnt[20];\nvoid Brute (int N, int K)\n{\n    set < vector < int > > S;\n    for (int i=0; i<(1 << (N - 1)); i++)\n        for (int j=0; j<(1 << (N - 1)); j++)\n        {\n            deque < int > dq;\n            dq.push_back (1);\n            for (int k=0; k<(N - 1); k++)\n                if (i & (1 << k)) dq.push_back (k + 2);\n                else dq.push_front (k + 2);\n            vector < int > curr;\n            for (int k=0; k<N - 1; k++)\n                if (j & (1 << k)) curr.push_back (dq.front ()), dq.pop_front ();\n                else curr.push_back (dq.back ()), dq.pop_back ();\n            curr.push_back (dq.back ());\n            S.insert (curr);\n        }\n    for (auto it = S.begin (); it != S.end (); it ++)\n        if ((K != 0 &&(*it) [K - 1] == 1) || K == 0)\n        {\n            int pos = 0;\n            for (auto it2 = (*it).begin (); it2 != (*it).end (); it2 ++)\n            {\n                pos ++;\n                if ((*it2) == 1) cnt[pos] ++;\n                printf (\"%d \", *it2);\n            }\n            printf (\"\\n\");\n        }\n    printf (\"\\n%d = \\n\", S.size ());\n    for (int i=1; i<=N; i++)\n        printf (\"%d \", cnt[i]);\n    printf (\"\\n\");\n}\n\nint dp0[] = {1, 1,2,5,14,42,132,429};\nint dp[2017][2017], fac[2017], put2[2017];\n\nvoid doDp (int N)\n{\n    dp[N][0] = 1;\n    for (int i=N; i>1; i--)\n        for (int j=N - i + 1; j>=0; j--)\n            if (dp[i][j])\n            {\n                ///dau push, si apoi eventual mai scot cateva numere din lista si le bag si pe alea\n                for (int p=0; p<=j; p++)\n                    dp[i - 1][j - p] = add (dp[i - 1][j - p], dp[i][j]);\n                ///daca adaug unu pe lista, fix la momentul asta, imi permit sa si scot\n                dp[i - 1][j + 1] = add (dp[i - 1][j + 1], dp[i][j]);\n            }\n}\n\nint solve (int N, int K)\n{\n    int ans = mul (dp[1][N - K], put2[max (N - K - 1, 0)]);\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &K);\n//Brute2 ();\n//Brute (8, 0);\nc[0][0] = 1, fac[0] = 1, put2[0] = 1;\nfor (int i=1; i<=N; i++)\n{\n    c[i][0] = 1, fac[i] = mul (fac[i - 1], i), put2[i] = add (put2[i - 1], put2[i - 1]);\n    for (int j=1; j<=i; j++)\n        c[i][j] = add (c[i - 1][j - 1], c[i - 1][j]);\n}\ndoDp (N);\nprintf (\"%d\\n\", solve (N, K));\n/*for (int i=1; i<=N; i++)\n    printf (\"%d \", solve (N, i));\nprintf (\"\\n\");*/\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2000 + 10;\nconst ll mod = 1e9 + 7;\nll fac[maxn], inv[maxn], facinv[maxn], bin[maxn];\nll f[maxn][maxn];\nvoid pre()\n{\n\tfac[0] = 1; for(int i = 1; i < maxn; ++i) fac[i] = fac[i - 1] * i % mod;\n\tinv[1] = 1; for(int i = 2; i < maxn; ++i) inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\tfacinv[0] = 1; for(int i = 1; i < maxn; ++i) facinv[i] = facinv[i - 1] * inv[i] % mod;\n\tbin[0] = 1; for(int i = 1; i < maxn; ++i) bin[i] = bin[i - 1] * 2 % mod;\n}\nll C(int n, int m) { return n < m ? 0 : fac[n] * facinv[m] % mod * facinv[n - m] % mod;}\nint main()\n{\n\tpre();\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tfor(int j = 1; j <= n; ++j) f[1][j] = 1;\n\tfor(int i = 2; i < k; ++i)\n\t{\n\t\tll sum = 0;\n\t\tfor(int j = n; j; --j)\n\t\t{\n\t\t\tif(n - j + 1 > i - 1) f[i][j] = f[i - 1][j];\n\t\t\tf[i][j] = (f[i][j] + sum) % mod;\n\t\t\tsum = (sum + f[i - 1][j]) % mod;\n\t\t}\n\t}\n\tll ans = 0;\n\tif(k > 1) for(int j = 2; j <= n; ++j) ans = (ans + f[k - 1][j]) % mod;\n\telse ans = 1;\n\tif(k < n) ans = ans * bin[n - k - 1] % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc() {\n    return getchar();\n    static char buf[100000], *l = buf, *r = buf;\n    return l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x) {\n    x = 0; int f = 1, ch = nc();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n    while(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n    x *= f;\n}\ntypedef long long LL;\nconst int mod = 1e9 + 7;\nconst int maxn = 2000 + 50;\nint n, k;\nint f[maxn][maxn][2];\ninline int add(int x) {return x >= mod ? x - mod : x;}\nLL power(LL x, LL y) {\n    LL re = 1;\n    while(y) {\n        if(y & 1) re = re * x % mod;\n        x = x * x % mod;\n        y >>= 1;\n    }\n    return re;\n}\nint solve() {\n    f[n][0][0] = f[n][1][1] = 1;\n    for(int i = n; i > 1; --i) {\n        for(int j = n; j >= 0; --j) {\n            f[i][j][0] = add(f[i][j][0] + f[i][j + 1][0]);\n            for(int t = 0; t < 2; ++t) {\n                f[i - 1][j][0] = add(f[i - 1][j][0] + f[i][j][t]);\n                f[i - 1][j + 1][1] = add(f[i - 1][j + 1][1] + f[i][j][t]);\n            }\n        }\n    }\n    return f[1][n - k][0] * power(2, max(n - k - 1, 0)) % mod;\n}\nint main() {\n    read(n), read(k);\n    printf(\"%d\\n\", solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//lewlew orz\nconst int N=2e3+2;\nconst int mod=1e9+7;\nint dp[N],ndp[N];\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=mod){\n\t\tx-=mod;\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,num;\n\tcin>>n>>num;\n\tdp[n+1]=1;\n\tfor(i=1;i<=num;i++){\n\t\tk=0;\n\t\tfor(j=n;j>0;j--){\n\t\t\tadd(k,dp[j+1]);\n\t\t\tndp[j]=k;\n\t\t\tif(i-1<n-j+1&&j>1){\n\t\t\t\tadd(ndp[j],dp[j]);\n\t\t\t}\n\t\t}\n\t\tfor(j=1;j<=n+1;j++){\n\t\t\tdp[j]=ndp[j];\n\t\t}\n\t}\n\tfor(i=1;i<=n-num-1;i++){\n\t\tadd(dp[1],dp[1]);\n\t}\n\tcout<<dp[1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\nusing namespace std;\ntypedef long long LL;\nconst LL O = 1000000007;\nconst int maxN = 2007;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nint n, m;\nint f[maxN][maxN];\n\nLL pwr(LL x, LL tms) {\n\tLL res = 1;\n\tfor (; tms > 0; tms >>= 1, x = (x * x) % O)\n\t\tif (tms & 1) res = (res * x) % O;\n\treturn res;\n}\n\nint main() {\n\n\tn = ri(), m = ri();\n\tf[0][0] = 1;\n\tFor (i, 1, n) {\n\t\trep (j, 0, i-1) f[i][j] = f[i-1][j];\n\t\tper (j, i-1, 0) (f[i][j] +=  f[i][j+1]) %= O;\n\t\trep (j, 1, i) (f[i][j] += f[i-1][j-1]) %= O;\n\t}\n\tprintf(\"%lld\\n\", (f[n-1][n-m] * pwr(2, n-m-1) % O));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n \n#define xx first\n#define yy second\n \ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n \n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n \nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int P=1000000007;\n\nint n,m,f[2005][2005];\n\nint main()\n{\n\tin,n,m;\n\tf[1][1]=1;\n\tfo(i,2,n)fo1(j,i)\n\t{\n\t\tif(j<i-1)f[i][j]=(f[i-1][j]*2ll+(ll)((P+1)/2)*f[i][j-1])%P;\n\t\telse if(j==i-1)f[i][j]=(f[i-1][j]+(ll)((P+1)/2)*f[i][j-1])%P;\n\t\telse f[i][j]=f[i][j-1];\n\t}\n\tout,f[n][m],'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint mod_pow(int n, int k) {\n    int res = 1;\n    for(; k>0; k>>=1) {\n        if(k & 1) (res *= n) %= MOD;\n        (n *= n) %= MOD;\n    }\n    return res;\n}\n\nint comb[2010][2010];\nint dp[2010][2010][2];\n\nsigned main() {\n    int N, K; scanf(\"%lld%lld\", &N, &K);\n    for(int i=0; i<=N; i++) {\n        comb[i][0] = 1;\n        for(int j=1; j<=i; j++) {\n            comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n        }\n    }\n\n    int ans = 0;\n    dp[N][0][0] = 1;\n    for(int i=N; i>=1; i--) {\n        for(int j=N; j>=0; j--) {\n            int processed_num = N - i;\n            int pending_num = j;\n            if(processed_num - pending_num == K-1) {\n                (ans += dp[i][j][0] + dp[i][j][1]) %= MOD;\n                continue;\n            }\n            \n            // 今見たものをそのまま使う\n            (dp[i-1][j][0] += dp[i][j][0] + dp[i][j][1]) %= MOD;\n\n            // 今見たものをためる\n            (dp[i-1][j+1][1] += dp[i][j][0] + dp[i][j][1]) %= MOD;\n\n            // ためていたものを使う\n            if(j > 0) (dp[i][j-1][0] += dp[i][j][0]) %= MOD;\n        }\n    }\n\n    /*\n    int M = N - K;\n    dp2[0][M] = 1;\n    for(int len=M; len>=1; len--) {\n        int used = M - len;\n        for(int l=0; l<M-len+1; l++) {\n            int r = l + len;\n            // fprintf(stderr, \"dp2[%lld][%lld] = %lld\\n\", l, r, dp2[l][r]);\n            (dp2[l+1][r] += dp2[l][r]) %= MOD;\n            (dp2[l][r-1] += dp2[l][r]) %= MOD;\n        }\n    }\n    */\n    /*\n    int ans = 0;\n    for(int i=0; i<M; i++) {\n        (ans += dp2[i][i+1]) %= MOD;\n    }\n    */\n    // fprintf(stderr, \"ans = %lld\\n\", ans);\n    /*\n    for(int i=1; i<=N; i++) {\n        fprintf(stderr, \"i = %lld, comb = %lld, rec = %lld\\n\", i, comb[N-1][i-1], rec[i]);\n        (ans += comb[N-1][i-1] * rec[i]) %= MOD;\n    }\n    */\n    // (ans *= dp[N-1][K-1]) %= MOD;\n    (ans *= mod_pow(2, N - K - 1)) %= MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\n\nconst int N_MAX = 2005;\n\nint N, K;\nmod_int dp[N_MAX][N_MAX];\n\nint main() {\n    cin >> N >> K;\n    dp[0][N] = 1;\n\n    for (int len = 0; len < K; len++) {\n        mod_int sum = 0;\n\n        for (int under = N - len - 1; under >= 0; under--) {\n            sum += dp[len][under + 1];\n            dp[len + 1][under] = sum;\n        }\n\n        for (int minimum = 1; minimum < N - len; minimum++)\n            dp[len + 1][minimum] += dp[len][minimum];\n    }\n\n    mod_int answer = dp[K][0] * mod_int(2).pow(max(N - K - 1, 0));\n    cout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 2010\n#define mod 1000000007\nusing namespace std;\nint n, k, f[N][N], s[N], ans;\n//f[i][j]=填完了1~i，当前填入的最小数=j，方案数\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tmemset(f, 0, sizeof(f)); f[0][n+1]=1;\n\ts[n+1]=1; for(int i=n; i; i--)s[i]=(s[i+1]+f[0][i])%mod;\n\tfor(int i=1; i<=k-1; i++){\n\t\tfor(int j=1; j<=n+1-i; j++)f[i][j]=s[j];\n\t\ts[n+1]=f[i][n+1]; for(int j=n; j; j--)s[j]=(s[j+1]+f[i][j])%mod;\n\t}\n\tans=0; for(int i=2; i<=n+1; i++)ans=(ans+f[k-1][i])%mod;\n\tfor(int i=1; i<=n-k-1; i++)ans=ans*2%mod;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nusing mint = mod_int<>;\n\ntemplate<typename M>\nstruct fenwick_tree {\n    using T = typename M::T;\n    int n;\n    std::vector<T> data;\n    fenwick_tree(int n) : n(n), data(n + 1, M::id()) {}\n    void add(int i, const T &x) { for (i++; i <= n; i += i & -i) { data[i] = M::op(data[i], x); }}\n    T get_sum(int i) const {\n        T ret = M::id();\n        for (; i > 0; i -= i & -i) { ret = M::op(ret, data[i]); }\n        return ret;\n    }\n    T get_sum(int l, int r) const {\n        return M::op(get_sum(r), M::inv(get_sum(l)));\n    }\n};\n\nstruct rsq {\n    using T = mint;\n    static T id() { return 0; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static T inv(const T &a) { return -a; }\n};\n\nsigned main() {\n    int N, K;\n    cin >> N >> K;\n    assert(N!=K);\n    vector dp(N + 10, fenwick_tree<rsq>(N + 10));\n    dp[0].add(N, 1);\n    reps(i, K - 1) {\n        reps(j, N - i) {\n            dp[i].add(j, dp[i - 1].get_sum(j, N + 1));\n        }\n    }\n    cout << dp[K - 1].get_sum(0, N + 1) * mint(2).pow(N - K - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr long long LINF=334ll<<53; constexpr int INF=15<<26; constexpr long long MOD=1E9+7;\n\nlong long modpow(long long a, long long n,long long mod=MOD){\n    long long i=1,ret=1,p=a;\n    while(i<=n){\n        if(i&n) ret=(ret*p)%mod;\n        i=(i<<1);\n        p=(p*p)%mod;\n    }\n    return ret;\n}\nvector<long long> fac(3030),two(3030),inv(3030);\n\nLL modcomb(LL a, LL b){\n    if(a==0 and b==-1){\n        return 1;\n    }else if(a<b){\n        return 0;\n    }else{\n        return (fac[a]*inv[b]%MOD)*inv[a-b]%MOD;\n    }\n}\nLL pow2(LL a){\n    if(a==-1)return 1;\n    else return two[a];\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    int n,k;\n    cin >> n >> k;\n    fac[0]=1;\n    two[0]=1;\n    const int lim=3030;\n    for(int i=1; i<lim; ++i){\n        fac[i]=fac[i-1]*i%MOD;\n        two[i]=two[i-1]*2%MOD;\n    }\n    inv[lim-1]=modpow(fac[lim-1],MOD-2);\n    for(int i=lim-2; i>=0; --i){\n        inv[i]=inv[i+1]*(i+1)%MOD;\n    }\n\n    vector<vector<LL>> dp (k+1,vector<LL>(k+1));\n    for(int i=1; i<k; ++i){\n        dp[k-1][i]=1;\n    }\n    for(int i=k-2; i>=1; --i){\n        dp[i][1]=(dp[i+1][1]+dp[i+1][2])%MOD;\n        for(int j=2; j<=i; ++j){\n            //dp[i][j]=sum(dp[i+1][1]~dp[i+1][j+1])\n            dp[i][j]=(dp[i][j-1]+dp[i+1][j+1])%MOD;\n        }\n    }\n    dp[0][0]=dp[1][1];\n    LL ans=0;\n    if(k==1){\n        cout << pow2(n-2)<<\"\\n\";\n        return 0;\n    }else if(k==n){\n        ans=dp[0][0]%MOD;\n    }else{\n        for(int m=n; m>=n-k+1; --m){\n            ans=(ans+((modcomb(m-2,n-k-1)*pow2(n-k-1)%MOD)*dp[m-(n-k+1)][m-(n-k+1)])%MOD)%MOD;\n        }\n    }\n\n    cout << ans <<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(ll i=(ll)(x);i<(ll)(y);++i)\n#define For(i,x,y)  for(ll i=(ll)(x);i<=(ll)(y);++i)\n#define FOr(i,x,y)  for(ll i=(ll)(x);i>=(ll)(y);--i)\n#define pi acos(-1) \n#define mk make_pair\n#define pa pair<ll,ll>\n#define lf else if\n#define IL inline\n#define max(x,y)    ((x)<(y)?(y):(x))\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define Mul(x,y)    ((x)=1LL*(x)*(y)%mod)\n#define Add(x,y)    ((x)=((x)+(y))%mod)\n#define E(x)        return writeln(x),0\n#define LL\t\t\t(long long)\n#define p(x)        printf(\"~%lld~\\n\",LL(x))\n#define pp(x,y)     printf(\"~~%lld %lld~~\\n\",LL(x),LL(y))\n#define ppp(x,y,z)  printf(\"~~~%lld %lld %lld~~~\\n\",LL(x),LL(y),LL(z))\n#define pppp(a,b,c,d)\tprintf(\"~~~%lld %lld %lld %lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\n#define GuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\n#define y1\t\t\tfafa____\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_; \n#endif \n#define NEG 1\n    static const int GYN=2333333;\n    char SZB[GYN],*S=SZB,*T=SZB;\n    inline char gc(){   if (S==T){  T=(S=SZB)+fread(SZB,1,GYN,stdin); if (S==T) return '\\n';  }   return *S++;    }\n#if NEG\n    inline ll read(){    ll x=0,g=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') g=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*g; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n\tvoid Print(long long *a,int s,int t){For(i,s,t)printf(\"%lld \",a[i]);puts(\"\");}\n\tvoid Print(int *a,int s,int t){For(i,s,t)printf(\"%d \",a[i]);puts(\"\");}\n\tvoid Print(char *a,int s,int t){For(i,s,t)putchar(a[i]);puts(\"\");}\n\tvoid writeln(ll x){write(x);putchar('\\n');}\n}using namespace SHENZHEBEI;\nconst ll N=2010,mod=1e9+7;\nll f[N][N],sum[N][N],n,K,answ;\nint main(){\n\tn=read(),K=read();\n\tf[n+1][0]=1;\n\tFOr(i,n+1,0)FOr(j,n+1,0){\n\t\tif (i==1&&j==n-K)answ=sum[i+1][j];\n\t\tAdd(f[i][j],sum[i+1][j]+f[i][j+1]);\n\t\tsum[i][j]=((j>=1?sum[i+1][j-1]:0ll)+f[i][j])%mod;\n\t}\n\tFor(i,1,n-K-1)Mul(answ,2);\n\twriteln(answ);\n}\n/*\nf[4][0]\nf[3][0]\nf[2][0]=2\tf[2][1]=1\n32\t23\t\t2?\n21\n\n一定是1在结尾....\n\n他不一定选2啊。\nf[2][1]...\nf[1][1]\nf[j][k]\n小的那个是i,上面还有j剩下。\n1.选择上面的\n2.枚举下一个。。\n选1个,2个,3个。.\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nunsigned long long p=1e9+7;\nunsigned long long n,k,dp[10001];\nunsigned long long quickpow(unsigned long long a,unsigned long long b,unsigned long long n)\n{\n\tif(b==0&&n>1) return 1;\n\tif(b==0&&n==1) return 0;\n\tif(b==1) return a%n;\n\tif(b%2==0)\n\t{\n\t\tunsigned long long t=quickpow(a,b/2,n);\n\t\treturn t*t%n;\n\t}\n\telse\n\t{\n\t\tunsigned long long t=quickpow(a,b/2,n);\n\t\tt=t*t%n;\n\t\treturn t*a%n;\n\t}\n}\n\nint main(){\n    cin>>n>>k;\n    dp[0]=1;\n    for(int i=1;i<n;i++)\n\t{\n\t\tfor(int j=i;j>0;j--)\n\t\t\tdp[j]=(dp[j+1]+dp[j-1])%p;\n\t\tdp[0]=dp[1];\n\t}\n\tcout<<dp[n-k]*quickpow(2,n-k-1,p)%p<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 4010\n#define LL long long\n\nconst LL P=1000000007;\n\nint n,k;\nLL f[MAXN][MAXN],c[MAXN][MAXN],g[MAXN];\n\nvoid update(LL &x,LL y){ x=(x+y)%P; }\n\nvoid pre_gao(){\n\tfor(int i=0;i<MAXN;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%P;\n\t}\n}\n\nLL gay(int x,int y){\n\treturn c[x+y-1][y];\n}\n\nLL gao(){\n\tf[1][1]=1;\n\tfor(int i=2;i<=k;i++){\n\t\tfor(int j=1;j<i;j++)\n\t\t\tupdate(f[i][j+1],f[i-1][j]);\n\t\tLL temp=0;\n\t\tfor(int j=i-1;j>=1;j--){\n\t\t\tupdate(temp,f[i-1][j]);\n\t\t\tupdate(f[i][j],temp);\n\t\t}\n\t\tg[i-1]=temp;\n\t}\n\tg[0]=1;\n\tLL ans=g[k-1];\n\tfor(int i=1;i<=k-1;i++){\n\t\tint j=k-1-i;\n\t\tif(n-2-j>=i){\n\t\t\tLL temp=c[n-2-j][i];\n\t\t\tif(!j) update(ans,temp);\n\t\t\telse{\n\t\t\t\tfor(int l=1;l<=j;l++)\n\t\t\t\t\tupdate(ans,temp*f[j][l]%P*gay(l+1,i));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<n-k;i++) ans=ans*2%P;\n\treturn ans;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&k);\n\tpre_gao();\n\tprintf(\"%lld\\n\",gao());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,dp[2005];\ninline long long ksm(long long x,long long y)\n{\n\tlong long g=1ll;\n\twhile(y)\n\t{\n\t\tif(y&1ll)g=g*x%mod;\n\t\tx=x*x%mod; y>>=1ll;\n\t}\n\treturn g;\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>k; dp[0]=1;\n\tfor(int i=1;i<n;i++,dp[0]=dp[1])\n\tfor(int j=i;j>=1;j--)dp[j]=(dp[j+1]+dp[j-1])%mod;\n\tcout<<1ll*dp[n-k]*ksm(2ll,n-k-1)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T, class Op = multiplies<T>>\nconstexpr T power(T a, long long n, Op op = Op(), T e = {1}) {\n  assert(n >= 0);\n  while (n) {\n    if (n & 1) e = op(e, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return e;\n}\n\ntemplate <unsigned M> struct modular {\n  using m = modular;\n  static constexpr unsigned mod = M;\n  unsigned v;\n  modular(long long x = 0) : v((x %= mod) < 0 ? x + mod : x) {}\n  m operator-() const { return m() -= *this; }\n  m& operator+=(m b) { if ((int)(v += b.v - mod) < 0) v += mod; return *this; }\n  m& operator-=(m b) { if ((int)(v -= b.v) < 0) v += mod; return *this; }\n  m& operator*=(m b) { v = (uint64_t)v * b.v % mod; return *this; }\n  m& operator/=(m b) { return *this *= power(b, mod - 2); }\n  friend m operator+(m a, m b) { return a += b; }\n  friend m operator-(m a, m b) { return a -= b; }\n  friend m operator*(m a, m b) { return a *= b; }\n  friend m operator/(m a, m b) { return a /= b; }\n  friend bool operator==(m a, m b) { return a.v == b.v; }\n};\n\nusing mint = modular<power(10, 9) + 7>;\n\nvector<mint> fact, inv_fact, minv;\nvoid prepare(int n) {\n  fact.resize(n + 1), inv_fact.resize(n + 1), minv.resize(n + 1);\n  for (int i = 0; i <= n; ++i) fact[i] = i ? fact[i - 1] * i : 1;\n  inv_fact[n] = power(fact[n], mint::mod - 2);\n  for (int i = n; i--; ) inv_fact[i] = (i + 1) * inv_fact[i + 1];\n  for (int i = 1; i <= n; ++i) minv[i] = inv_fact[i] * fact[i - 1];\n}\nmint binom(int n, int k) {\n  if (k < 0 or k > n) return 0;\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\ntemplate <> mint& mint::operator/=(mint b) {\n  return *this *= b.v < minv.size() ? minv[b.v] : power(b, mod - 2);\n}\n\nvector<mint> f(int n) {\n  vector<mint> res(n);\n  res[0] = 1;\n  for (int x = 1; x < n; ++x) {\n    for (int i = 0; i < n - x; ++i) {\n      int a = n - i - 1, b = x - 1;\n      res[x] += binom(a + b, a) - binom(a + b, a + 1);\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, k;\n  cin >> n >> k;\n  prepare(2 * n);\n  if (k == 1) {\n    cout << power<mint>(2, max(n - 2, 0)).v << '\\n';\n    exit(0);\n  }\n  auto a = f(k - 1);\n  mint res;\n  for (int x = 0; x < k - 1; ++x) {\n    res += binom(n - 1 - x, k - 1 - x) * a[x];\n  }\n  res *= power<mint>(2, max(n - k - 1, 0));\n  cout << res.v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f(a, n) for (int a=0; a<n; a++)\n#define F(a, n) for (int a=1; a<=n; a++)\n#define ll long long\nusing namespace std;\nconst ll MOD = 1000000007;\nunordered_map<ll, ll> gmp;\nll pairit(ll a, ll b){\n\treturn (a<<32) + b;\t\n}\nll g(ll a, ll b){\n\tif (a==0) return 0;\n\tif (a==1) return 1;\n\tll tmp=pairit(a,b);\n\tif (gmp.count(tmp)) return gmp[tmp];\t\n\tif (b==0) gmp[tmp] = (g(a-1, 0) + g(a-1, 1) ) %MOD;\n\telse gmp[tmp] = (g(a, b-1) + g(a-1, b+1)) % MOD;\n\treturn gmp[tmp];\n}\nll powa(ll a, ll b){\n\tif (b==0) return 1;\n\telse if (b%2) return (powa((a*a)%MOD,b/2) * a) % MOD;\n\treturn powa((a*a)%MOD,b/2);\n}\nll N, K;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>N>>K;\n\tcout<<( (g(K, N-K) - g(K-1, N-K+1) + MOD)* powa(2, N-K-1) ) % MOD << endl; \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long i64;\nconst int N=4007,P=1e9+7,M=4000;\ni64 fac[N],fiv[N],ans=0;\nint n,k;\ni64 pw(i64 a,i64 n){\n\tif(n<0)return 1;\n\ti64 v=1;\n\tfor(;n;n>>=1,a=a*a%P)if(n&1)v=v*a%P;\n\treturn v;\n}\ni64 F(int n,int m){return n>=0&&m>=0?fac[n+m]*fiv[m]%P*fiv[n]%P:0;}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=fac[0]=1;i<=M;++i)fac[i]=i*fac[i-1]%P;\n\tfiv[M]=pw(fac[M],P-2);\n\tfor(int i=M;i;--i)fiv[i-1]=i*fiv[i]%P;\n\tans=F(n-1,k-1)-F(k-2,n);\n\tans=ans*pw(2,n-k-1)%P;\n\tprintf(\"%lld\\n\",(ans+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n#define drp(i,st,ed) for (int i=st;i>=ed;--i)\n\nconst int MOD=1e9+7;\nconst int N=2005;\n\nint f[N][N],s[N][N];\n\nint ksm(int x,int dep) {\n\tint res=1;\n\tfor (dep=std:: max(dep,0);dep;dep>>=1,x=1LL*x*x%MOD) {\n\t\t(dep&1)?(res=1LL*res*x%MOD):0;\n\t}\n\treturn res;\n}\n\nint main(void) {\n\tint n,k; scanf(\"%d%d\",&n,&k);\n\tif (n==k) {\n\t}\n\tf[0][n+1]=1;\n\tdrp(j,n+1,1) {\n\t\ts[0][j]=s[0][j+1]+f[0][j];\n\t\t(s[0][j]>=MOD)?(s[0][j]-=MOD):0;\n\t}\n\trep(i,1,k) {\n\t\trep(j,1,n-i+1) f[i][j]=s[i-1][j];\n\t\tdrp(j,n+1,1) {\n\t\t\ts[i][j]=s[i][j+1]+f[i][j];\n\t\t\t(s[i][j]>=MOD)?(s[i][j]-=MOD):0;\n\t\t}\n\t}\n\tint ans=f[k][1]-f[k-1][1];\n\t(ans<0)?(ans+=MOD):0;\n\tans=1LL*ans*ksm(2,n-k-1)%MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\nll dp[N];\n\nll uni[N];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    dp[0] = 1;\n    uni[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        uni[i] = dp[i - 1];\n        for (int last = 1; last <= i; last++)\n        {\n            dp[i] = (dp[i] + dp[i - last] * uni[last]) % MOD;\n        }\n        //cout << i << \": \" << \" \" << uni[i] << \" \" << dp[i] << endl;\n    }\n    if (n == k)\n    {\n        cout << dp[n - 1];\n        return 0;\n    }\n    ll ans = 0;\n    int M = n - k;\n    for (int tail = M + 1; tail <= n; tail++)\n    {\n        int sufixa = tail;\n        ll r = dp[n - sufixa];\n        r = r * cnk(tail - 2, M - 1) % MOD;\n        ll val = 0;\n        for (int at_right = tail - M - 1; at_right <= sufixa - M - 1; at_right++)\n        {\n            val = (val + cnk(sufixa - M - 1, at_right)) % MOD;\n        }\n        r = r * val % MOD;\n        //cout << tail << \" \" << sufixa << \" \" << dp[n - sufixa] << \" \" << cnk(tail - 2, M - 1) << \" \" << val << endl;\n        ans = (ans + r) % MOD;\n        for (int sufixa = tail + 1; sufixa <= n; sufixa++)\n        {\n            ll r = dp[n - sufixa];\n            r = r * cnk(tail - 2, M - 1) % MOD;\n            ll val = 0;\n            for (int at_right = tail - M; at_right < sufixa - M - 1; at_right++)\n            {\n                val = (val + cnk(sufixa - M - 1, at_right)) % MOD;\n            }\n            r = r * val % MOD;\n            //cout << tail << \" \" << sufixa << \" \" << dp[n - sufixa] << \" \" << cnk(tail - 2, M - 1) << \" \" << val << endl;\n            ans = (ans + r) % MOD;\n        }\n    }\n    //cout << ans << endl;\n    cout << ans * inq(2, n - k - 1) % MOD;\n    return 0;\n    {\n        ll ans = 0;\n        vector<int> p;\n        for (int i = 0; i < n; i++) p.push_back(i + 1);\n        int cnt = 0;\n        while (1)\n        {\n            int t = (p[0] == 1);\n            for (int i = 1; i < n; i++)\n            {\n                for (int j = i + 1; j < n; j++)\n                {\n                    for (int k = j + 1; k < n; k++)\n                    {\n                        if (p[i] > p[j] && p[j] > p[k]) t = 0;\n                    }\n                }\n            }\n            int w = 0;\n            for (int i = 1; i < n; i++)\n            {\n                int t = 1;\n                for (int j = i; j < n; j++)\n                {\n                    if (p[j] <= i) t = 0;\n                }\n                if (t) w = i;\n            }\n            if (w == 1 && t == 1)\n            {\n                for (auto e : p) cout << e;\n                cout << endl;\n                cnt++;\n            }\n            if (t) ans++;\n            if (!next_permutation(all(p))) break;\n        }\n        cout << cnt << \"\\n\";\n        cout << ans << \"\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define loop(s, v, it) for (s::iterator it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = e[i].nxt)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, sum) memset(a, sum, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s.\"out\", \"w\", stdout)\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int N = 2010 ;\nconst int INF = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int MOD = 1000000007 ;\nconst double eps = 1e-7 ;\nvoid print(int x) { cout << x << endl ; exit(0) ; }\nvoid PRINT(string x) { cout << x << endl ; exit(0) ; }\nvoid douout(double x){ printf(\"%lf\\n\", x + 0.0000000001) ; }\n\n/*\n\n\n题意：每次从1~n往两边加数 每次 取的时候从两边取问第k个是1的情况 一共有多少是成立的\n\n首先 我们可以通过观察得出 我1~n加数的这个数列 一定是一个v字形的这么一个序列 然后1在最中间 那么这样的话 我取到1的话是不是说明我前面的k-1一定可以是一个降序序列或者是两个降序序列 那么求一下这个个数我可以dp一下 设f[i][j]表示我已经填了前1~i这么多个位置了 我前面填过的数中最小的是j那我可以知道我现在其实是假设有两个栈 然后分别取数的方案数 比如 我取9 8 7 2\n\n这样 如果下一个数一定要比我大的话 方案数 必须只能转移到当前空缺位置 的最大 否则就是无效的\n\n或者可以选择转移到所有比我小的地方 累积一下方案数\n\n相当于我这个dp要求这样的 有多少个 那么f[i+1][j]自然可以由上一层的f[i][j+1]+f[i+1][j+2]+….得到啊 然后针对这个做一个前缀和优化 变成n^2的情况然后转移的时候要注意一些细节 比如如果k是0的情况\n\n然后那么只要前面k个都确定了 剩下的我是不是还是随便选啦 可以当作是dp 就是每次从两边选一个的方案数一共是多少 那么前面k个确定了 后面我随便放 方案数就是2^(n-k-1)种方案数 为什么呢 因为这次一定剩下的是一条递增的序列了 我想怎么取就怎么取\n\n最后统计答案的时候我只需要把前k-1位的所有情况都取出来 然后后n-k让他随便排 乘一乘就好\n\n*/\n\nint f[N][N], s[N] ;\nint n, k, ans ;\n\nsigned main(){\n    scanf(\"%d%d\", &n, &k) ;\n    f[0][n + 1] = 1 ; s[n + 1] = 1 ;\n\tper(i, n, 1) s[i] = s[i + 1] + f[0][i] ;\n\trep(i, 1, k - 1) {\n\t\trep(j, 1, n - i + 1) f[i][j] = s[j] ;\n\t\ts[n + 1] = f[i][n + 1] ;\n\t\tper(j, n, 1) s[j] = (s[j + 1] + f[i][j]) % MOD ;\n\t}\n\trep(i, 2, n + 1) (ans += f[k - 1][i]) %= MOD ;\n\trep(i, 1, n - k - 1) (ans *= 2) %= MOD ;\n\tprintf(\"%d\\n\", ans) ;\n\n\n\treturn 0 ;\n}\n\n/*\n写代码时请注意：\n\t1.ll？数组大小，边界？数据范围？\n\t2.精度？\n\t3.特判？\n\t4.至少做一些\n思考提醒：\n\t1.最大值最小->二分？\n\t2.可以贪心么？不行dp可以么\n\t3.可以优化么\n\t4.维护区间用什么数据结构？\n\t5.统计方案是用dp？模了么？\n\t6.逆向思维？\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <set>\nconst int maxlongint=2147483647;\nconst long long mo=1e9+7;\t\nconst int N=3005;\nusing namespace std;\nint n,k;\nlong long ans,mi[N],f[N][N];\nint main()\n{\n\t//freopen(\"068d.in\",\"r\",stdin);\n\t//freopen(\"068d.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k);\n\tmi[0]=1;\n\tfor(int i=1;i<=n;i++) mi[i]=mi[i-1]*2%mo;\n\tfor(int i=n;i>=2;i--) f[1][i]=1;\n\tfor(int i=1;i<k-1;i++)\n\t{\n\t\tlong long sum=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--)\n\t\t{\n\t\t\tsum=(sum+f[i][j])%mo;\n\t\t\tf[i+1][j]=(f[i+1][j]+sum)%mo;\n\t\t}\n\t}\n\tfor(int j=2;j<=n-k+2;j++) ans=(ans+f[k-1][j])%mo;\n\tif(k==1) ans=1;\n\tif(n-1-k<0) printf(\"%lld\",ans);\n\telse\n\t\tprintf(\"%lld\",ans*mi[n-1-k]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint n,k;\nint f[2005][2005],s[2005];\nconst int p=1000000007;\n\nint main()\n{\n    scanf(\"%d%d\",&n,&k),f[0][n+1]=1;\n    for(int i=1;i<=k;++i)\n    {\n        s[n+1]=f[i-1][n+1];\n        for(int j=n;j>=1;--j)s[j]=(s[j+1]+f[i-1][j])%p;\n        for(int j=1;j<=n-i+1;++j)f[i][j]=s[j];\n    }\n    int Ans=(f[k][1]-f[k-1][1]+p)%p;\n    for(int i=n-k-1;i>=1;--i)Ans=(Ans<<1)%p;\n    printf(\"%d\\n\",Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 2005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\n\nll dp[SIZE][SIZE];\nint L;\n\nvoid make()\n{\n\tll r1=1;\n\tfor(int i=0;i<L-2;i++) r1=r1*2LL%MOD;\n\tfor(int i=1;i<=L;i++) dp[L][i]=r1;\n\tfor(int i=L+1;i<SIZE;i++)\n\t{\n\t\tll sum=0;\n\t\tfor(int j=i;j>=1;j--)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][max(1,j-1)];\n\t\t\tif(j<=i-2)\n\t\t\t{\n\t\t\t\tsum+=dp[i-1][j];\n\t\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t\t\tdp[i][j]+=sum;\n\t\t\t\tif(dp[i][j]>=MOD) dp[i][j]-=MOD;\n\t\t\t}\n\t\t}\n\t\t//if(i<=5) {for(int j=1;j<=i;j++) printf(\"%d \",dp[i][j]);puts(\"\");}\n\t}\n}\nint main()\n{\n\tint n,k;\n\tscanf(\"%d %d\",&n,&k);\n\tL=n-k+1;\n\tmake();\n\tprintf(\"%lld\\n\",dp[n][1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define go(i,a,b) for(int i=a;i<=b;++i)\n#define com(i,a,b) for(int i=a;i>=b;--i)\n#define mem(a,b) memset(a,b,sizeof(a))\n#define fo(i,a) for(int i=0;i<a;++i)\n#define il inline\n#define int long long\n\nconst int inf=0x3f3f3f3f,N=2010,mod=1e9+7;\n\nint n,m,dp[N];\n\nil void read(int &x){\n\tx=0;char c=getchar(),f=1;\n\twhile(!isdigit(c)){ if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)){ x=x*10+c-'0'; c=getchar(); }\n\tx*=f;\n}\n\nsigned main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tread(n),read(m);\n\tdp[n+1]=1;\n\tgo(i,1,m){\n\t\tcom(j,n,1){\n\t\t\tif(n-j+1<i) dp[j]=0;\n\t\t\telse (dp[j]+=dp[j+1])%=mod;\n\t\t}\n\t}\n\tint ans=1;\n\tgo(i,1,n-m-1) ans=ans*2%mod;\n\tprintf(\"%lld\",ans*dp[1]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=2005;\nconst int mod=1e9+7;\nint n,q,dp[N];\n\ninline int nxi(FILE *fd=stdin){\n\tint x=0;\n\tchar c;\n\twhile((c=fgetc(fd))>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=fgetc(fd))>='0'&&c<='9');\n\treturn x;\n}\n\ntemplate <class T> inline int fpow(int x,T t){\n\tint ans=1;\n\tfor(; t; x=(lint)x*x%mod,t>>=1){\n\t\tif(t&1) ans=(lint)ans*x%mod;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tn=nxi(),q=nxi();\n\tdp[n+1]=1;\n\tfor(int i=1; i<q; ++i){\n\t\tint sum=0;\n\t\tfor(int j=n-i+2; j>1; --j){\n\t\t\tsum=(sum+dp[j])%mod;\n\t\t\tdp[j]=sum;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=2; i<=n-q+2; ++i){\n\t\tans=(ans+dp[i])%mod;\n\t}\n\tif(q==1) ans=1;\n\tprintf(\"%lld\\n\",(lint)ans*(q==n?1:fpow(2,n-q-1))%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 2200\n#define mod 1000000007\nusing namespace std;\nint f[N][N],s[N],n,k,ans;//设f[i][j]表示已经选取了1~i个位置 最小的那个数是j的方案数 \nint main(){\n\t//freopen(\"arc.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&k);f[0][n+1]=1;s[n+1]=1;\n\tfor (int i=n;i>=1;--i) s[i]=s[i+1]+f[0][i];\n\tfor (int i=1;i<=k-1;++i){\n\t\tfor (int j=1;j<=n-i+1;++j) f[i][j]=s[j];\n\t\ts[n+1]=f[i][n+1];for (int j=n-i+1;j>=1;--j) s[j]=(s[j+1]+f[i][j])%mod;\n\t}for (int i=2;i<=n+1;++i) (ans+=f[k-1][i])%=mod;\n\tfor (int i=1;i<=n-k-1;++i) (ans*=2)%=mod;printf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ld,ld> pa;\nconst int N=5000+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint n,k;\nll fac[N],ifac[N],f[N][N][2];\nll C(ll n,ll m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nll cata(int x){\n\tif(!x)return 1;\n\tif(x==1)return 1;\n\treturn C(x+x,x)-C(x+x,x-1);\n}\nvoid add(ll&a,ll b){a+=b;a%=mod;}\nint main(){\n\tread(n,k);\n\t/*fac[0]=1;\n\trep(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=qpow(fac[n],mod-2,mod);\n\trepd(i,n-1,0)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tll res=C(n-1,k-1);\n\tcout<<res*qpow(2,n-k-1,mod)%mod;*/\n\tf[n][0][0]=1;\n\trepd(i,n,1)repd(j,n,0){\n\t\tadd(f[i-1][j][0],f[i][j][0]+f[i][j][1]);\n\t\tadd(f[i-1][j+1][1],f[i][j][0]+f[i][j][1]);\n\t\tif(j)add(f[i][j-1][0],f[i][j][0]);\n\t}\n\tll res=(f[1][n-k][0]+f[1][n-k][1])%mod;\n\tif(n-k-1)res=res*qpow(2,n-k-1,mod)%mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=4000+10;\nconst int mod=1e9+7;\n\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\nint fac[N],ifac[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n}\ninline int C(int n,int m) { return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod; }\n\nint main() { int n=read(),k=read(); init(n+k);\n    printf(\"%lld\\n\",1ll*(C(n+k-2,k-1)-C(n+k-2,k-2)+mod)*qpow(2,max(0,n-k-1))%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RANK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 4005;\nconst int mod = 1e9+7;\nint fac[maxn],inv[maxn],n,k;\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\ninline int C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\ninline int calc(int x,int y){\n\tif(y<0) return 0;\n\treturn C(x+y,x);\n}\nint main(){\n\tn = rd(),k = rd();\n\tif(n==1&&k==1) return puts(\"1\"),0;\n\tfac[0] = 1;\n\tRep(i,1,n+k) fac[i] = 1ll * fac[i-1] * i % mod;\n\tinv[n+k] = qpow(fac[n+k],mod-2);\n\tDep(i,n+k-1,0) inv[i] = 1ll * inv[i+1] * (i+1) % mod;\n\tll ans = calc(n,k-1)-2*calc(n,k-2);\n\tRep(i,1,n-k-1)ans=ans*2%mod;\n\tans %= mod;\n\tans = (ans + mod) % mod;\n\twriteln(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 2000\n#define P 1000000007\nusing namespace std;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nint n, m, f[2][MAX_N+5];\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) f[0][i] = 1;\n\tfor (int i = 1, c = 1; i < m; i++, c ^= 1) {\n\t\tmemset(f[c], 0, sizeof f[c]);\n\t\tfor (int j = 1; j <= n-i+1; j++) f[c][j] = f[c^1][j];\n\t\tfor (int j = n; j; j--) f[c][j] = (f[c][j]+f[c][j+1])%P;\n\t}\n\tint ans = f[(m-1)&1][2];\n\tfor (int i = 1; i <= n-m-1; i++)\n\t\tans = (ans<<1)%P;\n\treturn printf(\"%d\\n\", ans), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits//stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\n#define rep(i,n) for (int i = 0; i < (n); i++)\n#define ALL(v) v.begin(), v.end()\nll dp[2001][2001][2];\nll mod_pow(ll a, ll n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tll tmp = mod_pow(a, n / 2);\n\t\treturn (tmp * tmp) % MOD;\n\t}\n\treturn (a * mod_pow(a, n - 1)) % MOD;\n}\nint main() {\n\tint N, K;\n\tcin >> N >> K;\n\tdp[N][0][0] = 1;\n\tfor (int i = N; i >= 1; i--) {\n\t\tfor (int j = N; j >= 0; j--) {\n\t\t\t(dp[i - 1][j][0] += dp[i][j][0] + dp[i][j][1]) %= MOD;\n\t\t\t(dp[i - 1][j + 1][1] += dp[i][j][0] + dp[i][j][1]) %= MOD;\n\t\t\tif (j > 0) (dp[i][j - 1][0] += dp[i][j][0]) %= MOD;\n\t\t}\n\t}\n\tll ret = (dp[1][N - K][0] + dp[1][N - K][1]) % MOD;\n\tif (N - K - 1 >= 0) (ret *= mod_pow(2, N - K - 1)) %= MOD;\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nlong long dp[2010][2010],fr[2010];\nint n,k;\nint main()\n{\n\t//freopen(\"forget.in\",\"r\",stdin);\n\t//freopen(\"forget.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k);\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tfr[n+1]=dp[i-1][n+1];\n\t\tfor(int j=n;j;j--)\tfr[j]=(fr[j+1]+dp[i-1][j])%mod;\n\t\tfor(int j=1;j<=n-i+1;j++) dp[i][j]=fr[j]%mod;\n\t}\n\tdp[k][1]=(dp[k][1]-dp[k-1][1]+mod)%mod;\n\tfor(int i=1;i<=(n-k-1);i++) (dp[k][1]*=2)%=mod;\n\tcout<<dp[k][1]%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1e9+7;\n\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\ninline int C(int n,int m) { int res=1;\n    for (re int i=1;i<=n;++i) res=1ll*res*i%mod;\n    for (re int i=1;i<=m;++i) res=1ll*res*qpow(i,mod-2)%mod;\n    for (re int i=1;i<=n-m;++i) res=1ll*res*qpow(i,mod-2)%mod;\n    return res;\n}\n\nint main() { int n=read(),k=read();\n    printf(\"%lld\\n\",1ll*(C(n+k-2,k-1)-C(n+k-2,k-2)+mod)*qpow(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <set>\nconst int maxlongint=2147483647;\nconst long long mo=1e9+7;\t\nconst int N=3005;\nusing namespace std;\nint n,k;\nlong long ans,mi[N],f[N][N];\nint main()\n{\n\t//freopen(\"068d.in\",\"r\",stdin);\n\t//freopen(\"068d.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k);\n\tmi[0]=1;\n\tfor(int i=1;i<=n;i++) mi[i]=mi[i-1]*2%mo;\n\tfor(int i=n;i>=2;i--) f[1][i]=1;\n\tfor(int i=1;i<k-1;i++)\n\t{\n\t\tlong long sum=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--)\n\t\t{\n\t\t\tsum=(sum+f[i][j])%mo;\n\t\t\tf[i+1][j]=(f[i+1][j]+sum)%mo;\n\t\t}\n\t}\n\tfor(int j=2;j<=n-k+2;j++) ans=(ans+f[k-1][j])%mo;\n\tif(n-1-k<0) printf(\"%lld\",ans);\n\telse\n\t\tprintf(\"%lld\",ans*mi[n-1-k]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2020;\nconst int mod = 1e9 + 7;\n\nLL f[N][N][2], s[N];\n\nLL qpow(LL a, LL b)\n{\n\tLL ret = 1, base = a;\n\twhile (b) {\n\t\tif (b & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, b >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tf[n + 1][0][0] = 1;\n\tfor (int i = n + 1; i >= 2; i --) {\n\t\ts[i + 1] = 0;\n\t\tfor (int j = n; j >= 0; j --) s[j] = s[j + 1], upd(s[j], f[i][j][0]);\n\t\t\n\t\tfor (int j = n; j >= 0; j --) {\n\t\t\t\n\t\t//\tprintf(\"%d %d %lld\\n\", i, j, f[i][j][0]);\n\t\t\t\n\t\t\tupd(f[i - 1][j + 1][1], s[j] + f[i][j][1]);\n\t\t\tupd(f[i - 1][j][0], s[j] + f[i][j][1]);\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", f[1][n - k][0] * qpow(2, n - k - 1) % mod);\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2005;\nconst LL mod = 1000000007LL;\n\nint n, k;\nLL dp[N][N], C[N][N], pref[N];\n\ninline LL pow(LL x, LL exp) {\n  if (exp < 0) return 1;\n  LL res = 1;\n  for (; exp; exp >>= 1, x = x * x % mod)\n    if (exp & 1) res = res * x % mod;\n  return res;\n}\n\ninline void pre() {\n  for (int i = 0; i < N; i ++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j ++) {\n      C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n      if (C[i][j] >= mod) C[i][j] -= mod;\n    }\n  }\n}\n\ninline LL DP() {\n  pref[0] = 1;\n  for (int i = 2; i <= n - 1; i ++) {\n    for (int j = 1; j < i; j ++) {\n      pref[j] = pref[j - 1] + dp[i - 1][j];\n      if (pref[j] >= mod) pref[j] -= mod;\n      dp[i][j] = pref[j];\n    }\n  }\n  LL ans = 1;\n  for (int i = 1; i <= k - 1; i ++) {\n    ans += dp[n - 1][i];\n    if (ans >= mod) ans -= mod;\n  }\n  return ans;\n}\n\nint main() {\n  pre();\n  scanf(\"%d%d\", &n, &k);\n  if (k == 1) return printf(\"%lld\\n\", pow(2LL, n - 2)), 0;\n  if (k == 2) {\n    LL ans = pow(2LL, n - k - 1) * (n - 1) % mod;\n    return printf(\"%lld\\n\", ans), 0;\n  }\n  LL ans = DP();\n  ans = ans * pow(2LL, n - k - 1) % mod;\n  printf(\"%lld\\n\", ans);\n  return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n#define drp(i,st,ed) for (int i=st;i>=ed;--i)\n\nconst int MOD=1e9+7;\nconst int N=2005;\n\nint f[N][N],s[N][N];\n\nint ksm(int x,int dep) {\n\tint res=1;\n\tfor (dep=std:: max(dep,0);dep;dep>>=1,x=1LL*x*x%MOD) {\n\t\t(dep&1)?(res=1LL*res*x%MOD):0;\n\t}\n\treturn res;\n}\n\nint main(void) {\n\tint n,k; scanf(\"%d%d\",&n,&k);\n\tif (n==k) {\n\t}\n\tf[0][n+1]=1;\n\tdrp(j,n+1,1) {\n\t\ts[0][j]=s[0][j+1]+f[0][j];\n\t\t(s[0][j]>=MOD)?(s[0][j]-=MOD):0;\n\t}\n\trep(i,1,k) {\n\t\trep(j,1,n-i+1) f[i][j]=s[i-1][j];\n\t\tdrp(j,n+1,1) {\n\t\t\ts[i][j]=s[i][j+1]+f[i][j];\n\t\t\t(s[i][j]>=MOD)?(s[i][j]-=MOD):0;\n\t\t}\n\t}\n\tint ans=f[k][1]-f[k-1][1];\n\t(ans<0)?(ans+=MOD):0;\n\tans=1LL*ans*ksm(2,n-k-1)%MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=4000+10;\nconst int mod=1e9+7;\n\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\nint fac[N],ifac[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n}\ninline int C(int n,int m) { return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod; }\n\nint main() { int n=read(),k=read(); init(n+k);\n    printf(\"%lld\\n\",1ll*(C(n+k-2,k-1)-C(n+k-2,k-2)+mod)*qpow(2,max(0,n-k-1))%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=2010;\nconst int mod=1e9+7;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,k;\nint dp[N][N],S[N][N];\nint main()\n{\n\tfile();\n\tread(n),read(k);\n\tdp[1][n-k]=1;\n\tFor(i,1,n-1)\n\t{\n\t\tFor(j,0,n)S[i][j]=((j?S[i][j-1]:0)+dp[i][j])%mod;\n\t\tFor(j,0,n-1)dp[i+1][j]=S[i][j+1];\n\t}\n\tint ans=dp[n][0];\n\tFor(i,1,n-k-1)ans=(ans<<1)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int maxn = 2005, mod = 1e9 + 7;\nint n, m, f[maxn][maxn], s[maxn];\nint power(long long x, int k) {\n\tif(k < 0) return 1;\n\tint ans = 1;\n\twhile(k) {\n\t\tif(k & 1) ans = ans * x % mod;\n\t\tx = x * x % mod, k >>= 1;\n\t} \n\treturn ans;\n}\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tf[0][n+1] = 1; \n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= n+1; ++j) s[j] = ((long long)s[j-1] + f[i-1][j]) % mod;\n\t\tfor(int j = 1; j <= n+1; ++j) f[i][j] = j <= n - i + 1 ? ((long long)s[n+1] - s[j-1] + mod) % mod : 0;\n\t}\n\tprintf(\"%d\\n\", ((long long)f[m][1] - f[m-1][1] + mod) % mod * power(2, n-m-1) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2000;\nconst int mod=1e9+7;\nint n,k;\nint f[maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint fac[maxn+10],ifac[maxn+10],inv[maxn+10];\n\nint C(int a,int b){return 1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\n\nint F(int i,int j){return 1ll*C(i+j,i)*(i-j+1)%mod*inv[i+1]%mod;}\n\nint main()\n{\n    fac[0]=inv[0]=inv[1]=ifac[0]=1;\n    for(int i=1; i<=maxn; ++i)\n\t{\n\t    fac[i]=1ll*fac[i-1]*i%mod;\n\t}\n    for(int i=2; i<=maxn; ++i) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=1; i<=maxn; ++i) ifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n    n=read(),k=read();\n    /*f[0]=1;puts(\"1\");\n    for (int i=1;i<n;i++)\n\t{\n\t    for (int j=i;j;j--) f[j]=(f[j+1]+f[j-1])%mod;\n\t    f[0]=f[1];\n\t    for (int j=i;~j;j--) printf(\"%d \",f[j]);puts(\"\");\n\t}\n    for(int i=1; i<n; ++i)\n\t{\n\t    for(int j=0; j<=i; ++j)\n\t\t{\n\t\t    printf(\"%d \",1ll*C(i+j,i)*(i-j+1)%mod*inv[i+1]%mod);\n\t\t}\n\t    puts(\"\");\n\t    }*/\n    printf(\"%lld\\n\",1ll*F(n-1,k-1)*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define inlien inline\n#define retrun return\n#define cpnst const\ntypedef long long ll;\nconst ll mod=1e9+7;\nll tmp[111111],fac[111111],inv[111111];\ninline ll qpow(ll x,ll k)\n{ll r=1;for(;k;k>>=1,(x*=x)%=mod)if(k&1)(r*=x)%=mod;retrun r;}\nll F[111111],G[111111],m;\ninline void mul(register ll*x,register ll*y)\n{\n\tregister int i,ii;\n\tfor(i=0;i<=m;i++)\n\t\tfor(ii=0;ii<=i;ii++)\n\t\t\t(tmp[i]+=x[i-ii]*y[ii])%=mod;\n\tfor(i=0;i<=m;i++)x[i]=tmp[i],tmp[i]=0;\n}\ninline void qpow(ll k)\n{for(;k;k>>=1,mul(F,F))if(k&1)mul(G,F);}\ninline ll Ca(ll n)\n{return fac[n*2]*inv[n]%mod*inv[n+1]%mod;}\ninline ll Fs(int n,int r)\n{\n\tregister int i;\n\tfor(i=0;i<=r;i++)F[i]=Ca(i),G[0]=1;\n\tm=r,qpow(n);\n\tll ret=G[r];\n\tif(n^1)(ret*=qpow(2,n-2))%=mod;\n\treturn ret;\n}\nint main()\n{\n\tinv[0]=fac[0]=1;\n\tregister int i;\n\tfor(i=1;i<=100000;i++)fac[i]=fac[i-1]*i%mod;\n\tfor(i=99999,inv[i+1]=qpow(fac[i+1],mod-2);i;i--)\n\t\tinv[i]=inv[i+1]*(i+1)%mod;\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k),printf(\"%lld\\n\",Fs(n-k+1,k-1));\n}\n/*\nGiving the world a better yourself is giving yourself a better world. \n*/"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010,Mod=1e9+7;\nint f[N][N];\nint qpow(int a,int b){int ret=1;while(b){if(b&1)ret=1ll*ret*a%Mod;b>>=1;a=1ll*a*a%Mod;}return ret;}\nint n,k;\nint main(){\n\tn=gi();k=gi();\n\tf[0][n+1]=1;\n\tfor(int i=1;i<k;i++){\n\t\tint sum=f[i-1][n-i+2];\n\t\tfor(int j=n-i+1;j>=2;j--){\n\t\t\tsum=(sum+f[i-1][j])%Mod;\n\t\t\tf[i][j]=sum;\n\t\t}\n\t}\n\tint sum=0;\n\tfor(int i=2;i<=n-k+2;i++)sum=(sum+f[k-1][i])%Mod;\n\tif(k==1)sum=1;\n\tprintf(\"%lld\\n\",1ll*qpow(2,n-k-1)*sum%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 4e3 + 5;\nconst int MOD = 1e9 + 7;\n\nint N, K;\n\nvoid input()\n{\n    read(N); read(K);\n}\n\nLL fpm(LL base, LL exp)\n{\n    LL ret = 1;\n    for (; exp; exp >>= 1) {\n        if (exp & 1)\n            (ret *= base) %= MOD;\n        (base *= base) %= MOD;\n    }\n    return ret;\n}\n\nLL fac[MAXN], ifac[MAXN], pow2[MAXN];\n\ninline LL C(int n, int k)\n{\n    return n < k ? 0 : fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;\n}\n\nvoid solve()\n{\n    int bnd = N * 2;\n    fac[0] = 1;\n    for (int i = 1; i <= bnd; ++i) {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n    ifac[bnd] = fpm(fac[bnd], MOD - 2);\n    for (int i = bnd; i >= 1; --i) {\n        ifac[i - 1] = ifac[i] * i % MOD;\n    }\n\n    int ans = 0;\n    if (K == 1)\n        ans = 1;\n    else for (int i = 0; i < K; ++i) {\n        (ans += (C(K-2+i, K-2) - C(K-2+i, K-1) + MOD) * C(N-1-i, K-1-i) % MOD) %= MOD;\n    }\n    for (int i = 0; i < N - K - 1; ++i) {\n        (ans *= 2) %= MOD;\n    }\n\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 醉别西楼醒不记。春梦秋云，聚散真容易。\n//     -- 晏几道《蝶恋花·醉别西楼醒不记》\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MOD = int(1e9)+7;\n\nint modinv(int a, int m) {\n  return (a == 1) ? 1 : m - int(ll(modinv(m % a, a)) * m / a);\n}\n\nint fact(int n) {\n  int res = 1;\n  for (int i = 1; i <= n; i++) res = int(ll(res) * i % MOD);\n  return res;\n}\n\nint choose(int n, int r) {\n  if (r<0 || r>n) return 0;\n  return ll(fact(n)) * modinv(ll(fact(r)) * ll(fact(n-r)) % MOD, MOD) % MOD;\n}\n\nint solve(int N, int K) {\n  int ans = choose(N-1+K-1, K-1) - choose(N-1+K-1, K-2);\n  if (ans < 0) ans += MOD;\n  for (int i = K+1; i <= N-1; i++) {\n    ans *= 2;\n    if (ans >= MOD) ans -= MOD;\n  }\n  return ans;\n}\n\nint main() {\n  int N, K; cin >> N >> K;\n  cout << solve(N, K) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define ll long long\nconst ll mod = 1e9+7; \nusing namespace std;\nint read(){\n\tint x=0,pos=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;\n\tfor(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn pos?x:-x;\n}\nconst int N = 2001;\nint n,k;\nint f[N][N];\nint main(){\n\tn=read(),k=read();\n\tfor(int i=2;i<=n;i++){\n\t\tf[1][i]=1;\n\t}\n\tfor(int i=1;i<k-1;i++){\n\t\tll sum=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--){\n\t\t\tsum=(sum+f[i][j])%mod;\n\t\t\tf[i+1][j]=sum;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=2;i<=n-k+2;i++){\n\t\tans+=f[k-1][i];\n\t}\n\tif(k==1){\n\t\tans=1;\n\t}else if(k!=n){\n\t\tans=ans*((1<<(n-k-1))%mod)%mod;\n\t} \n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint n,f[2005][2005],s[2005],k,P=1e9+7,a;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);f[0][n]=1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\ts[n]=f[i-1][n];\n\t\tfor(int j=n;j;j--) s[j]=(s[j+1]+f[i-1][j])%P;\n\t\tfor(int j=1;j<=n-i+1;j++) f[i][j]=s[j];\n\t}\n\ta=(f[k][1]-f[k-1][1]+P)%P;\n\tfor(int i=1;i<=n-k-1;i++) a=(a+a)%P;\n\tprintf(\"%d\\n\",a);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint n,f[2005][2005],s[2005],k,P=1e9+7,a;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);f[0][n+1]=1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\ts[n]=f[i-1][n];\n\t\tfor(int j=n;j;j--) s[j]=(s[j+1]+f[i-1][j])%P;\n\t\tfor(int j=1;j<=n-i+1;j++) f[i][j]=s[j];\n\t}\n\ta=(f[k][1]-f[k-1][1]+P)%P;\n\tfor(int i=1;i<=n-k-1;i++) a=(a+a)%P;\n\tprintf(\"%d\\n\",a);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n,k;\nint pw[4010];\nconst int md=1e9+7;\nint qmul(int x,int p)\n{\n\tif(p==0)return 1;\n\tif(p==1)return x;\n\tint res=qmul(x,p>>1);\n\tres=1LL*res*res%md;\n\tif(p&1)res=1LL*res*x%md;\n\treturn res;\n}\nint C(int x,int y)\n{\n\tif(x<y || x<0 || y<0)return 0;\n\treturn 1LL*pw[x]*qmul(pw[x-y],md-2)%md*qmul(pw[y],md-2)%md;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tpw[0]=1;\n\tfor(int i=1;i<=4000;i++)pw[i]=1LL*pw[i-1]*i%md;\n\tprintf(\"%d\",1LL*(C(n+k-2,n-1)+md-C(n+k-2,n))*qmul(2,n-k-1)%md);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll n,k;\nll f[2002][2002],s[2005],ans;\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0][n+1]=1;\t\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=n+1;j;j--)\n\t\t\ts[j]=(s[j+1]+f[i-1][j])%mod,f[i][j]=(j<=n-i+1)?s[j]:0;\n\tans=(f[k][1]-f[k-1][1]+mod)%mod;\n\tfor(int i=1;i<n-k;i++)ans=(ans+ans)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nconst long long P=1000000007ll;\nlong long n,k,f[10001];\n\nlong long qpow(long long a,int x){\n    if(x<0)return 1;\n    long long s=1ll;\n    while(x){if(x&1)(s*=a)%=P;(a*=a)%=P;x>>=1;}\n    return s;\n}\n\nint main(){\n    scanf(\"%lld%lld\",&n,&k);\n    f[0]=1ll;\n    for(int i=1;i<n;++i){for(int j=i;j;--j)f[j]=(f[j+1]+f[j-1])%P;f[0]=f[1];}\n    printf(\"%lld\",f[n-k]*qpow(2ll,n-k-1)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int INF=0x3f3f3f3f;\nconst int maxn=2e3+7;\nconst int mod=1e9+7;\nll quick(ll a,ll b)\n{\n\tll ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nll dp[maxn][maxn];\nint main()\n{\n\tint n,k;\n\tcin>>n>>k;\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tvc<ll> suf(n+3);\n\t\tfor(int j=n+1;j>=1;j--)\n\t\t\tsuf[j]=(suf[j+1]+dp[i-1][j])%mod;\n\t\tfor(int j=1;j<=n-i;j++)\n\t\t{\n\t\t\tdp[i][j]=(dp[i-1][j]+suf[j+1])%mod;\n\t//\t\tdbg(i,j,dp[i][j]);\n\t\t}\n\t}\n\tcout<<dp[k][1]*quick(2,n-k-1)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll n,k;\nll f[2002][2002],s[2005],ans;\ninline ll fpow(ll b,ll p,ll mod)\n{\n\tll ans=1,tmp=b;\n\twhile(p)\n\t{\n\t\tif(p&1)ans=ans*tmp%mod;\n\t\ttmp=tmp*tmp%mod;\n\t\tp>>=1;\n\t}\n\treturn ans%mod;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0][n+1]=1;\t\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=n+1;j;j--)\n\t\t\ts[j]=(s[j+1]+f[i-1][j])%mod,f[i][j]=(j<=n-i+1)?s[j]:0;\n\tans=(f[k][1]-f[k-1][1]+mod)%mod;\n\tprintf(\"%lld\\n\",ans*fpow(2,n-k-1,mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nconst int N=2005,mo=1e9+7;\nint n,k,i,j,f[N][N][2];\nvoid add(int &x,int k){x=(x+k)%mo;}\nint main(){\n\tscanf(\"%d%d\",&n,&k);f[n+1][0][0]=1;\n\tfor (i=n+1;i>=2;i--){\n\t\tfor (j=n+1-i;j>=0;j--){\n\t\t\tadd(f[i][j][0],f[i][j+1][0]);\n\t\t\tfor (int x=0;x<2;x++)\n\t\t\t\tadd(f[i-1][j+1][1],f[i][j][x]),\n\t\t\t\tadd(f[i-1][j][0],f[i][j][x]);\n\t\t}\n\t}\n\tint ans=f[1][n-k][0];\n\tfor (i=n-k-1;i>=1;i--) ans=2ll*ans%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst long long P=1000000007ll;\nlong long n,k,f[10001];\ninline long long qpow(long long a,int x){\n    if(x<0)return 1;\n    long long s=1ll;\n    while(x){if(x&1)(s*=a)%=P;(a*=a)%=P;x>>=1;}\n    return s;\n}\nint main(){\n    scanf(\"%lld%lld\",&n,&k);\n    f[0]=1ll;\n    for(int i=1;i<n;++i){for(int j=i;j;--j)f[j]=(f[j+1]+f[j-1])%P;f[0]=f[1];}\n    printf(\"%lld\",f[n-k]*qpow(2ll,n-k-1)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 2005;\nconst int mod = 1e9 + 7; \nusing namespace std;\n\nint n, m, f[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint fpow(int x, int y)\n{\n\tint res = 1;\n\tfor( ; y; y >>= 1, x = 1ll * x * x % mod)\n\t\tif(y & 1) res = 1ll * res * x % mod;\n\treturn res; \n}\n\nint main()\n{\n#ifndef ONLIND_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin); \n#endif\n\tn = read <int> (), m = read <int> (); \n\tf[n + 1] = 1; \n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = n; j; j--)\n\t\t{\n\t\t\tif(n - j + 1 < i) f[j] = 0; \n\t\t\telse f[j] = (f[j] + f[j + 1]) % mod; \n\t\t}\n\tprintf(\"%lld\\n\", 1ll * f[1] * fpow(2, n - m - 1) % mod); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nint k,n;\nconst ll MOD=1e9+7;\nint f[2333][2333][2];\nint main()\n{\n\tcin>>n>>k;\n\tf[n+1][0][1]=1;\n\tfor(int i=n+1;i>1;--i)\n\t{\n\t\tfor(int j=n;~j;--j)\n\t\t\t(f[i][j][0]+=f[i][j+1][0])%=MOD;\n\t\tfor(int j=0;j<=n;++j)\n\t\t\tfor(int s=0;s<2;++s)\n\t\t\t\t(f[i-1][j+1][1]+=f[i][j][s])%=MOD,\n\t\t\t\t(f[i-1][j][0]+=f[i][j][s])%=MOD;\n\t}\n\tll ans=f[1][n-k][0];\n\tfor(int i=1;i<=n-k-1;++i) ans=ans*2%MOD;\n\tprintf(\"%d\\n\",int(ans));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nconst int q=1000000007;\nint n,m,f[2010][2010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\t  f[1][i]=1;\n\tfor(i=2;i<=m;i++)\n\t  {\n\t   for(j=1;j<=n-i+1;j++)\n\t     f[i][j]=f[i-1][j];\n\t   for(j=n,k=0;j>0;j--)\n\t     {\n\t\t  f[i][j]=(f[i][j]+k)%q;\n\t\t  k=(k+f[i-1][j])%q;\n\t\t }\n\t  }\n\tfor(i=m+1,k=(f[m][1]-f[m-1][1]+q)%q;i<n;i++)\n\t  k=(k<<1)%q;\n\tprintf(\"%d\\n\",k);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int long long\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int P = 1e9 + 7 ; \nconst int N = 2000 + 5 ; \nint n, K, f[N] ;  \nsigned main()\n{\n\tn = gi(), K = gi() ; int ans = 1 ; \n\tfor( re int i = 1; i < n - K; ++ i ) ans = ans * 2 % P ; \n\tf[0] = 1 ; \n\tfor( re int i = 1; i <= K; ++ i ) for( re int j = i; j < n; ++ j )\n\tf[j] = ( f[j - 1] + f[j] ) % P ; \n\tprintf(\"%lld\\n\", f[n - 1] * ans % P ) ; \n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll _v) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M(0) - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return (*this).pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<1000000007>;\n\nconst int MN = 2333;\nint n, k;\nMint dp[MN], ndp[MN];\nMint two[MN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    two[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        two[i] = Mint(2) * two[i - 1];\n    }\n\n    cin >> n >> k;\n    if (n == 1) {\n        cout << 1 << \"\\n\";\n        return 0;\n    }\n    if (k == 1) {\n        cout << two[n - 2] << \"\\n\";\n        return 0;\n    }\n    fill(dp + 2, dp + n + 1, 1);\n    for (int i = 1; i < k - 1; i++) {\n        copy(dp + 2, dp + n - i + 2, ndp + 2);\n        for (int j = n - i; j >= 2; j--) {\n            ndp[j] += ndp[j + 1];\n        }\n        copy(ndp + 2, ndp + n - i + 1, dp + 2);\n    }\n\n    Mint ans = accumulate(dp + 2, dp + n - k + 3, Mint(0));\n    ans *= two[max(0, n - k - 1)];\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll MOD=1e9+7;\nint main(){\n    int k,n;\n    cin>>n>>k;\n    vector<vector<ll>> dp(n+1,vector<ll>(n+1,0));\n    dp[0][n]=1;\n    for(int i=0;i<n;i++){\n        ll sum=0;\n        for(int j=n;j>=0;j--){\n            if(n-j-1>=i) dp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD;\n            dp[i+1][j]=(dp[i+1][j]+sum)%MOD;\n            sum=(sum+dp[i][j])%MOD;\n        }\n    }\n    \n    \n\n    ll res=0;\n    for(int i=1;i<=n;i++){\n            //cerr<<dp[k][i]<<endl;\n        res=(res+dp[k-1][i])%MOD;\n    }\n    ll w=1;\n    for(int i=0;i<n-k-1;i++){\n        w<<=1;\n        w%=MOD;\n    }\n    cout<<(res*w)%MOD<<endl;\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> PII;\n \nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n \nint n, m;\n \nvoid prework(){\n \n}\n \nvoid read(){\n \n}\n \nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n \nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = sum[K - 1][n - K];\n\tcout<<((K!=n)?(ans * pw[n-K-1] % MM):ans)<<endl;\n}\n \nvoid printans(){\n\t/*?????????*/\n}\n \n \nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n// ??????????"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\nusing namespace std;\ntypedef long long LL;\nconst int N=2010;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nint f[N][N][2];\n//每次把贪心分给序列B\n//f[i][j][k] 已经放完了n,n-1,...,i+1,i这些数，遗留了j个数还没有放，最后一个数是给了序列A/B\nconst int mod=1e9+7;\nint main()\n{\n\tint n=gi(),k=gi(),i,j,t;\n\tf[n][0][0]=1;\n\tfor (i=n;i;i--)\n\t\tfor (j=n;j>=0;j--) {\n\t\t\t(f[i][j][1]+=f[i][j+1][1])%=mod;\n\t\t\tfor (t=0;t<2;t++) {\n\t\t\t\t(f[i-1][j+1][0]+=f[i][j][t])%=mod;\n\t\t\t\t(f[i-1][j][1]+=f[i][j][t])%=mod;\n\t\t\t}\n\t\t}\n\tt=f[0][n-k][1];\n\tfor (i=n-k-1;i>0;i--) (t<<=1)%=mod;\n\tprintf(\"%d\\n\",t);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int md=1e9+7;\nint n,m,dp[2005][2005];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tdp[1][1]=1;\n\tfor(int i=2;i<=n;i++)for(int j=1;j<=i;j++)dp[i][j]=(dp[i-1][j]+dp[i][j-1])%md;\n\tint ans=dp[n][m];\n\tfor(int i=1;i<n-m;i++)ans=ans*2%md;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 0bd35dc5e428754fa574049b6be8efe0\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\nconst int MAXN = (int) 2e3;\n\nint n, k;\n\ninline void input()\n{\n\tn = read<int>(), k = read<int>();\n}\n\ninline void solve()\n{\n\tstatic int f[MAXN + 5][MAXN + 5], suf[MAXN + 5][MAXN + 5];\n\n\tf[0][n + 1] = 1;\n\tfor(int i = n + 1; i >= 1; --i) suf[0][i] = 1;\n\tfor(int i = 1; i < k; ++i)\n\t{\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t{\n\t\t\t(f[i][j] += suf[i - 1][j + 1]) %= MOD;\n\t\t\tif(n - j + 1 >= i) (f[i][j] += f[i - 1][j]) %= MOD;\n\t\t}\n\n\t\tfor(int j = n; j >= 1; --j) suf[i][j] = (f[i][j] + suf[i][j + 1]) % MOD;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 2; i <= n; ++i) (ans += f[k - 1][i]) %= MOD;\n\tans = (LL) ans * fpm(2, max(n - k - 1, 0)) % MOD;\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#define db double\n#define LL long long\n#define inf 0x3f3f3f3f\n#define N 2005\nusing namespace std;\nint gi()\n{\n    int res=0,s=1; char ch;\n    for(ch=getchar();(ch<'0'||ch>'9')&&ch!='-';ch=getchar());\n    if(ch=='-') s=-1,ch=getchar();\n    for(;ch>='0'&&ch<='9';ch=getchar()) res=res*10+ch-48;\n    return res*s;\n}\n\nconst int mo=1000000007;\nint n,k,dp[N][N][2];\n\nLL qp(LL x,LL y) {\n    LL res=1;\n    for(;y;y>>=1,x=x*x%mo)\n\tif(y&1) res=res*x%mo;\n    return res;\n}\nint main()\n{\n    n=gi(),k=gi();\n    dp[n+1][0][0]=1;\n    for(int i=n;i;--i) {\n\tfor(int j=n-i;j>=0;--j) dp[i+1][j][0]+=dp[i+1][j+1][0],dp[i+1][j][0]>=mo?dp[i+1][j][0]-=mo:0;\n\tfor(int j=0;j<=n-i+1;++j)\n\t    for(int k=0;k<2;++k) {\n\t\tdp[i][j+1][1]+=dp[i+1][j][k],dp[i][j+1][1]>=mo?dp[i][j+1][1]-=mo:0;\n\t\tdp[i][j][0]+=dp[i+1][j][k],dp[i][j][0]>=mo?dp[i][j][0]-=mo:0;\n\t    }\n    }\n    printf(\"%lld\\n\",dp[1][n-k][0]*qp(2,max(n-k-1,0))%mo);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr long long LINF=334ll<<53; constexpr int INF=15<<26; constexpr long long MOD=1E9+7;\n\nlong long modpow(long long a, long long n,long long mod=MOD){\n    long long i=1,ret=1,p=a;\n    while(i<=n){\n        if(i&n) ret=(ret*p)%mod;\n        i=(i<<1);\n        p=(p*p)%mod;\n    }\n    return ret;\n}\nvector<long long> fac(3030),two(3030),inv(3030);\n\nLL modcomb(LL a, LL b){\n    if(a==0 and b==-1){\n        return 1;\n    }else if(a<b){\n        return 0;\n    }else{\n        return (fac[a]*inv[b]%MOD)*inv[a-b]%MOD;\n    }\n}\nLL pow2(LL a){\n    if(a==-1)return 1;\n    else return two[a];\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    int n,k;\n    cin >> n >> k;\n    fac[0]=1;\n    two[0]=1;\n    const int lim=3030;\n    for(int i=1; i<lim; ++i){\n        fac[i]=fac[i-1]*i%MOD;\n        two[i]=two[i-1]*2%MOD;\n    }\n    inv[lim-1]=modpow(fac[lim-1],MOD-2);\n    for(int i=lim-2; i>=0; --i){\n        inv[i]=inv[i+1]*(i+1)%MOD;\n    }\n\n    vector<vector<LL>> dp (2020,vector<LL>(2020));\n    for(int i=1; i<k; ++i){\n        dp[k-1][i]=1;\n    }\n    for(int i=k-2; i>=1; --i){\n        dp[i][1]=(dp[i+1][1]+dp[i+1][2])%MOD;\n        for(int j=2; j<=i; ++j){\n            //dp[i][j]=sum(dp[i+1][1]~dp[i+1][j+1])\n            dp[i][j]=(dp[i][j-1]+dp[i+1][j+1])%MOD;\n        }\n    }\n    dp[0][0]=dp[1][1];\n    LL ans=0;\n    if(k==1){\n        cout << pow2(n-2)<<\"\\n\";\n        return 0;\n    }\n    for(int m=n; m>=n-k+1; --m){\n        ans=(ans+((modcomb(m-2,n-k-1)*pow2(n-k-1)%MOD)*dp[m-(n-k+1)][m-(n-k+1)])%MOD)%MOD;\n    }\n    cout << ans <<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 2002 , P = 1e9 + 7;\ninline void pp(int &x,int d){if((x+=d)>=P)x-=P;}\nint n , K , comb[N][N] , f[N][N] , g[N] , pw2[N];\n\nint main(){\n  cin >> n >> K;\n  rep(i,0,n+1) rep(j,0,i+1) comb[i][j]=j?(comb[i-1][j-1]+comb[i-1][j])%P:1;\n  pw2[0]=1;rep(i,1,n+1) pw2[i]=pw2[i-1]*2%P;\n  g[0] = 1;\n  rep(i,0,n+1) rep(j,0,n-i+1) f[i][j]=g[i+j],pp(g[i+j+1],f[i][j]);\n  if(n == K) cout << f[n-1][0] << endl;\n  else {\n    int ans = 0;\n    rep(m,2,n+1) {\n      int sum = m - 2 , choose = n - K - 1;\n      if(sum < choose) continue;\n      int tmp = ll(comb[sum][choose]) * f[n-m][m-2-choose] % P * pw2[choose] % P;\n      pp(ans , tmp);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 2005;\nconst int mod = 1000000007;\n\ninline int pow(int a, int b)\n{\n    if (b < 0)\n        return 1;\n    int ans = 1;\n    for (; b; b >>= 1, a = (LL) a * a % mod)\n        if (b & 1)\n            ans = (LL) ans * a % mod;\n    return ans;\n}\n\nint dp[maxn];\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    dp[n + 1] = 1;\n    for (int i = 1; i <= k; ++i)\n    {\n        for (int j = n; j; --j)\n        {\n            if (n - j + 1 < i)\n                dp[j] = 0;\n            else\n            {\n                dp[j] = dp[j + 1] + dp[j];\n                if (dp[j] >= mod)\n                    dp[j] -= mod;\n            }\n        }\n    }\n    cout << (LL) dp[1] * pow(2, n - k - 1) % mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\n#define pb push_back\ntypedef double db;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAXN=2e3+10,MOD=1e9+7;\nint n,k,dp[MAXN][MAXN],res;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=2;i<=n;i++) dp[1][i]=1;\n\tfor(int i=2;i<k;i++)\n\t{\n\t\tint pre=dp[i-1][n-i+2];\n\t\tfor(int j=n-i+1;j>=2;j--)\n\t\t{\n\t\t\t(dp[i][j]+=pre)%=MOD;\n\t\t\t(pre+=dp[i-1][j])%=MOD;\n\t\t\t(dp[i][j]+=dp[i-1][j])%=MOD;\n\t\t}\n\t}\n\tif(k==1) res=1;\n\tfor(int i=2;i<=n;i++)\n\t\t(res+=dp[k-1][i])%=MOD;\n\tfor(int i=1;i<=n-k-1;i++)\n\t\t(res<<=1)%=MOD;\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mo=int(1e9+7);\nint n,k,f[2010][2010][2],ans;\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&k);\n\tf[0][0][1]=1;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=i; ~j; j--)\n\t\t\t{\n\t\t\t\tf[i][j][1]=(f[i][j][1]+f[i][j][0])%mo;\n\t\t\t\tif (j)  f[i][j-1][0]=(f[i][j-1][0]+f[i][j][0])%mo;\n\t\t\t\tf[i+1][j][0]=(f[i+1][j][0]+f[i][j][1])%mo;\n\t\t\t\tf[i+1][j+1][1]=(f[i+1][j+1][1]+f[i][j][1])%mo;\t\t\t\t\n\t\t\t}\n\tans=f[n][n-k][0];\n\tfor (int i=1; i<=n-k-1; i++)  ans=2*ans%mo;\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 1e5 + 5;\nconst int mod = 1e9 + 7;\n\nint f[maxn];\nvoid add(int & x , int y){\n    x += y;\n    if(x >= mod)x -= mod;\n}\nint n , k;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n >> k;\n    f[0] = 1;\n    for(int i = 1 ; i <= k ; ++i)for(int j = i ; j < n  ; ++j)add(f[j],f[j-1]);\n    for(int i = 1 ; i < n - k ; ++i)add(f[n-1],f[n-1]);\n    cout << f[n - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 300005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint MOD = 1000000007;\nint K,N;\nint dp[2005][2005],sum[2005];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid Solve() {\n    \n    read(N);read(K);\n    dp[0][N + 1] = 1;\n    for(int i = 1 ; i <= K ; ++i) {\n\tsum[N + 2] = 0;\n\tfor(int j = N + 1 ; j >= 1 ; --j)  sum[j] = inc(sum[j + 1],dp[i - 1][j]);\n\tfor(int j = 1 ; j <= N ; ++j) {\n\t    if(i == K && j != 1) continue;\n\t    if(i < K && j == 1) continue;\n\t    dp[i][j] = sum[j + 1];\n\t    if((N - j + 1) > (i - 1)) dp[i][j] = inc(dp[i][j],dp[i - 1][j]);\n\t}\n    }\n    int t = 1;\n    for(int i = 1 ; i < N - K ; ++i) {\n\tt = mul(t,2);\n    }\n    out(mul(dp[K][1],t));enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll _v) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M(0) - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return (*this).pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<1000000007>;\n\nconst int MN = 2333;\nint n, k;\nMint dp[MN], ndp[MN];\nMint two[MN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    two[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        two[i] = Mint(2) * two[i - 1];\n    }\n\n    cin >> n >> k;\n    if (n == 1) {\n        cout << 1 << \"\\n\";\n        return 0;\n    }\n    if (k == 1) {\n        cout << two[n - 2] << \"\\n\";\n        return 0;\n    }\n    fill(dp + 2, dp + n + 1, 1);\n    for (int i = 1; i < k - 1; i++) {\n        for (int j = 2; j <= n - i + 1; j++) {\n            ndp[j] = dp[j];\n        }\n        for (int j = n - i; j >= 2; j--) {\n            ndp[j] += ndp[j + 1];\n        }\n        for (int j = 2; j <= n - i; j++) {\n            dp[j] = ndp[j];\n        }\n    }\n\n    Mint ans = accumulate(dp + 2, dp + n - k + 3, Mint(0));\n    ans *= two[max(0, n - k - 1)];\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing lint = long long;\n\nconst int MOD = int(1e9) + 7;\n\nstruct modint {\n  int v;\n  modint(long long v_ = 0): v(v_ % MOD) { }\n  modint operator+ (modint other) {\n    return modint(v + other.v);\n  }\n  modint operator- (modint other) {\n    return modint(v - other.v + MOD);\n  }\n  modint operator* (modint other) {\n    return modint((lint)v * other.v % MOD);\n  }\n  modint operator+= (modint other) {\n    (v += other.v) %= MOD;\n    return *this;\n  }\n  modint operator*= (modint other) {\n    v = (lint)(v * other.v) % MOD;\n    return *this;\n  }\n  modint operator-= (modint other) {\n    (v += MOD - other.v) %= MOD;\n    return *this;\n  }\n};\n\nint N, K;\n\nconst int N_ = 2050, K_ = 2050;\n\nmodint ways[N_][K_];\n\nint main() {\n  scanf(\"%d%d\", &N, &K);\n\n  ways[1][1] = 1;\n  for(int i = 1; i <= N; i++) {\n    ways[i][1] = 1;\n    for(int j = 2; j <= i; j++) {\n      ways[i][j] = ways[i][j-1] + ways[i-1][j];\n    }\n    /*for(int j = 1; j <= i; j++) {\n      printf(\"%6d\", ways[i][j].v);\n    }\n    puts(\"\");*/\n  }\n\n  modint ans = ways[N][K];\n  for(int i = 0; i < N-K-1; i++) {\n    ans *= 2;\n  }\n\n  printf(\"%d\\n\", ans.v);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\nll dp[N];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    if (n == k)\n    {\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            for (int j = 1; j < i; j++)\n            {\n                dp[i] = (dp[i] + dp[j] * (i - j - 2 >= 0 ? inq(2, i - j - 2) : 1)) % MOD;\n            }\n        }\n        cout << dp[n];\n        return 0;\n    }\n    return 1;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nlong long qpow(long long base,int tms)\n{\n\tlong long tmp = 1;\n\twhile(tms)\n\t{\n\t\tif(tms & 1) tmp = tmp * base % mod;\n\t\tbase = base * base % mod;\n\t\ttms >>= 1;\n\t}\n\treturn tmp;\n}\n\nint f[2][2050];\n\nint main()\n{\n\tint n,k; scanf(\"%d%d\",&n,&k);\n\tint cur = 0,lst = 1;\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= k - 1; ++ i)\n\t{\n\t\tcur ^= 1,lst ^= 1;\n\t\tmemset(f[cur],0,sizeof(f[cur]));\n\t\tint sum = f[lst][0];\n\t\tfor(int j = 1;j <= n; ++ j)\n\t\t\tf[cur][j] = (sum + f[lst][j]) % mod,sum = (sum + f[lst][j]) % mod;\n\t\tfor(int j = 0;j < n; ++ j)\n\t\t\tf[cur][j] = f[cur][j + 1];\n\t}\n\tint ans = 0;\n\tfor(int i = 0;i < n - k + 1; ++ i) ans = (ans + f[cur][i]) % mod;\n\tprintf(\"%d\\n\",ans * 1ll * qpow(2,n - k - 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define file(x) freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout);\nusing namespace std;\nconst int mod=1e9+7;\ninline int read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();\n    return f*x;\n}\ninline int ksm(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint f[4010][4010];//\nint sum[10001];\nmain(){\n\tint n=read(),k=read();\n\tf[0][n+1]=1;\n\tfor(rg int i=1;i<=k;i++){\n\t\tsum[n+1]=f[i-1][n+1];\n\t\tfor(rg int j=n;j>=1;j--) sum[j]=(sum[j+1]+f[i-1][j])%mod;\n\t\tfor(rg int z=1;z<=n-i+1;z++)\n\t\t\tf[i][z]=sum[z];\n\t}\n\tcout<<1ll*(f[k][1]-f[k-1][1]+mod)%mod*ksm(2,n-k-1)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=1e9+7;\nconst int MAXN=2005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint f[MAXN][MAXN],s[MAXN][MAXN];\ninline int upd(int x,int y) { return x+y>=mods?x+y-mods:x+y; }\ninline int quick_pow(int x,int y)\n{\n\tif (y<0) return 1;\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint n=read(),k=read();\n\tf[0][n+1]=s[0][n+1]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n-i+1;j++) f[i][j]=upd(s[i-1][n+1],mods-s[i-1][j-1]),s[i][j]=upd(s[i][j-1],f[i][j]);\n\t\ts[i][n+1]=s[i][n-i+1];\n\t}\n\tprintf(\"%d\\n\",1ll*upd(f[k][1],mods-f[k-1][1])*quick_pow(2,n-k-1)%mods);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int maxn=2005;\nconst int mod=1e9+7;\nint n,k;\nll dp[maxn][maxn],f[maxn];\nll kuai(ll a,int k)\n{\n\tll ans=1;\n\twhile(k)\n\t{\n\t\tif(k&1)(ans*=a)%=mod;\n\t\t(a*=a)%=mod;k>>=1;\n\t}\n\treturn ans%mod;\n} \nint main()\n{\n//\tfreopen(\"forget.in\",\"r\",stdin);\n//\tfreopen(\"forget.out\",\"w\",stdout);\n\tcin>>n>>k;\n\tdp[0][n+1]=1;ll ans=0;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tf[n+1]=dp[i-1][n+1];\n\t\tfor(int j=n;j>=1;j--)f[j]=(f[j+1]+dp[i-1][j])%mod;\n\t\tfor(int j=1;j<=n-i+1;j++)\n\t\t\tdp[i][j]=f[j];\n\t}\n\tdp[k][1]=(dp[k][1]-dp[k-1][1]+mod)%mod;\n\tif(n==k)ans=dp[k][1];\n\telse ans=dp[k][1]*kuai(2,n-k-1)%mod;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint const N = 4e3 + 41;\nint const MOD = 1e9 + 7;\n\nint n, k, dp[N][N], pref[N][N];\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MOD){\n\t\ta -= MOD;\n\t}\n}\n\nint bp(int x, int d){\n\tif(!d){\n\t\treturn 1;\n\t}\n\tif(d&1){\n\t\treturn x * 1LL * bp(x, d-1) % MOD;\n\t}\n\tint r = bp(x, d/2);\n\treturn r * 1LL * r % MOD;\n}\n\nvoid recalcPref(int id){\n\tfor(int i=0;i<=n;++i){\n\t\tpref[id][i] = dp[id][i];\n\t\tif(i > 0){\n\t\t\tadd(pref[id][i], pref[id][i-1]);\n\t\t}\n\t}\n}\n\nint getPref(int l, int r, int id){\n\tif(l > r){\n\t\treturn 0;\n\t}\n\tint ret = pref[id][r];\n\tif(l > 0){\n\t\tret -= pref[id][l-1];\n\t\tif(ret < 0){\n\t\t\tret += MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tdp[1][k-1] = (n - k - 1 >= 0 ? bp(2, n - k - 1) : 1);\n\tfor(int i=2;i<=n;++i){\n\t\trecalcPref(i-1);\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tadd(dp[i][j], getPref(j, n-i+1, i-1));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[n][0]);\n}\n\nvoid read(){\n\tscanf(\"%d %d\",&n,&k);\n}\n\n\n\nvoid prepare(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n}\n\nint main(){\n\tprepare();\n\tread();\n\tsolve();\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define N 10010\n#define mo 1000000007ll\nll f[N];\nint n,k;\nll qp(ll x,ll y){\n\tll r=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1)r=r*x%mo;\n\treturn r;\n}\nsigned main(){\n\tcin>>n>>k;\n\tf[0]=1;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i;j;j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%mo;\n\t\tf[0]=f[1];\n\t}\n\tcout<<f[n-k]*qp(2,n-k-1)%mo;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=4e3+10,mod=1e9+7;\nint fac[maxn],ifac[maxn];\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\ninline int C(int n,int m){\n\tif(m>n || n<0 || m<0) return 0;\n\treturn (ll)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tREP(i,1,n) fac[i]=(ll)i*fac[i-1]%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tDREP(i,n,1) ifac[i-1]=(ll)i*ifac[i]%mod;\n}\ninline int solve(int n,int m){\n\treturn (C(n+m,m)-C(n+m,m-1)+mod)%mod;\n}\nint main(){\n\tint n=read(),m=read();\n\tinit(maxn-10);\n\tprintf(\"%lld\\n\",(ll)(solve(n,m-1)-solve(n,m-2)+mod)*ksm(2,max(n-m-1,0))%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k,ans;\nconst int N=2005;\nconst int mo=1e9+7;\nint f[N][N],sum[N][N];\nvoid upd(int &x,int y){\n\t(x+=y)>=mo?x-=mo:233;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tf[n+1][0]=1;\n\tfor (int i=n+1;i>=0;i--)\n\t\tfor (int j=n+1;j>=0;j--){\n\t\t\tif (i==1&&j==n-k) ans=sum[i+1][j];\n\t\t\tupd(f[i][j],f[i][j+1]);\n\t\t\tupd(f[i][j],sum[i+1][j]);\n\t\t\tsum[i][j]=(j?sum[i+1][j-1]:0);\n\t\t\tupd(sum[i][j],f[i][j]);\n\t\t}\n\tfor (int i=1;i<=n-k-1;i++)\n\t\tans=1ll*ans*2%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long p=1000000007ll;\nlong long n,k,dp[10001];\nlong long quickpow(long long a,long long b)\n{\n\tif(b<0) return 1;\n\tif(b==0&&n>1) return 1;\n\tif(b==0&&n==1) return 0;\n\tif(b==1) return a%p;\n\tif(b%2==0)\n\t{\n\t\tlong long t=quickpow(a,b/2);\n\t\treturn t*t%p;\n\t}\n\telse\n\t{\n\t\tlong long t=quickpow(a,b/2);\n\t\tt=t*t%p;\n\t\treturn t*a%p;\n\t}\n}\n\nint main(){\n    cin>>n>>k;\n    dp[0]=1;\n    for(int i=1;i<n;i++)\n\t{\n\t\tfor(int j=i;j>0;j--)\n\t\t\tdp[j]=(dp[j+1]+dp[j-1])%p;\n\t\tdp[0]=dp[1];\n\t}\n\tcout<<(long long)(dp[n-k]*quickpow(2,n-k-1)%p)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod dp[MAX_N][MAX_N];\nmod sm[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, K;\n    cin >> n >> K;\n    dp[0][n] = 1;\n    sm[n+1] = 1;\n    rep(i,K){\n        if(i < K - 1){\n            srep(j,1,n-i){\n                // i+1 回目に j 取った あまりを埋める\n                dp[i+1][j] = sm[n-i+1] - sm[j+1] + dp[i][j];\n            }\n            sm[0] = 0;\n            rep(j,n){\n                sm[j+1] = sm[j] + dp[i+1][j];\n            }\n        }else{\n            dp[i+1][0] = sm[n-i+1] - sm[1];\n        }\n    }\n    cout << dp[K][0] * mod_pow((mod)2, max(0, n-K-1)) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint n, k;\nconst int mod = 1000000000 + 7;\nint mem[2][2222][2222];\n\nint dp(int shit, int cur, int left) {\n\tif(cur < 1) return 0;\n\tif(cur == 1 && ((n - 1 - left) == k-1)) {\n\t\treturn 1;\n\t}\n\tif(mem[shit][cur][left] != -1) {\n\t\treturn mem[shit][cur][left];\n\t}\n\tlong long ans = 0;\n\tans += dp(0, cur - 1, left);\n\tif(left && !shit) {\n\t\tans += dp(0, cur, left - 1);\n\t}\n\tans += dp(1, cur - 1, left + 1);\n\tans %= mod;\n\treturn mem[shit][cur][left] = ans;\n} \n\nint main(int argc, char const *argv[])\n{\n\tcin >> n >> k;\n\tmemset(mem, -1, sizeof mem);\n\tlong long ans = dp(0, n, 0);\n\tfor(int i = 1; i < (n-k); i++) {\n\t\tans *= 2;\n\t\tans %= mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=4000;\nconst int mod=1e9+7;\nint n,k;\nint fac[maxn+8],fact[maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint C(int n,int m){return (n<m)?0:1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n\nint main()\n{\n    n=read(),k=read();\n    fac[0]=1;\n    for (int i=1;i<=2*n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n*2]=power(fac[n*2],mod-2);\n    for (int i=n*2;i;i--) fact[i-1]=1ll*fact[i]*i%mod;\n    int ans=(C(n+k-2,n-1)-C(n+k-2,n)+mod)%mod;\n    ans=1ll*ans*power(2,n-k-1)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,x,y) for(int i=(x);i<=(y);i++)\n#define drep(i,x,y) for(int i=(x);i>=(y);i--)\nusing namespace std;\nconst int sz=2007;\nconst int mod=1e9+7;\nint f[sz][sz],sum[sz][sz];\nint qpow(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mod) if(y&1) ret=1ll*x*ret%mod;\n\treturn ret;\n}\nint main(){\n\tint n,k,ans=0;\n\tscanf(\"%d%d\",&n,&k);\n\trep(i,2,n+1) sum[0][i]=1;\n\trep(i,1,k-1) drep(j,n-i+1,2){\n\t\tif(j<=n-i+1) (f[i][j]+=sum[i-1][j])%=mod;\n\t\tsum[i][j]=(sum[i][j+1]+f[i][j])%mod;\n\t}\n\trep(i,2,n-k+2) (ans+=1ll*f[k-1][i])%=mod;\n\tif(k==1) ans=1;\n\tif(k!=n) ans=1ll*ans*qpow(2,n-k-1)%mod;\n\tprintf(\"%d\\n\",ans); \n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fm, to)    for (int i = fm; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 2e3, mod = 1e9 + 7;\nint n, k, dp[2][nsz + 5], suf[2][nsz + 5];\nnum ans;\n\nint inline qpow(int a, int p) {\n\tint res = 1;\n\tfor (; p > 0; p >>= 1) {\n\t\t(p & 1) && (res = (num) res * a % mod);\n\t\ta = (num) a * a % mod;\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin >> n >> k;\n\tint o = 0, x = 1;\n\tdp[o][n + 1] = 1;\n\tfor (int j = n + 1; j >= 1; --j) {\n\t\tsuf[o][j] = (suf[o][j + 1] + dp[o][j]) % mod;\n\t}\n\tcont (i, k - 1) {\n\t\tfor (int j = n; j >= 1; --j) {\n\t\t\tdp[x][j] = suf[o][j + 1];\n\t\t\tif (j + i - 1 <= n) {\n\t\t\t\tdp[x][j] = (dp[x][j] + dp[o][j]) % mod;\n\t\t\t}\n\t\t\tsuf[x][j] = (suf[x][j + 1] + dp[x][j]) % mod;\n\t\t}\n\t\tswap(o, x);\n\t\tsuf[x][n + 1] = 0;\n\t}\n\tcirc (j, 2, n + 1) {\n\t\tans = (ans + dp[o][j]) % mod;\n\t}\n\tans = ans * qpow(2, n - k - 1) % mod;\n\tcout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\n\n//負数がないMOD関数\ninline long long imod(long long a, long long b)\n{\n\treturn (a >= 0) ? (a % b) : (a % b + b);\n}\n\n//mint_base型用の累乗関数\ntemplate <long long MOD> class mint_base;\ntemplate <long long MOD> mint_base<MOD> m_pow(long long x, long long n);\n\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <long long MOD = 1000000007>\nclass mint_base\n{\npublic:\n\tmint_base<MOD> operator+(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a + other.a, MOD));\n\t}\n\tmint_base<MOD> operator-(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a - other.a, MOD));\n\t}\n\tmint_base<MOD> operator*(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a * other.a, MOD));\n\t}\n\tmint_base<MOD> operator+=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a + other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator-=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a - other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator*=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a * other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator+()const\n\t{\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator-()const\n\t{\n\t\treturn mint_base<MOD>(-a);\n\t}\n\tmint_base<MOD>& operator++()\n\t{\n\t\t*this += 1;\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator++(int)\n\t{\n\t\tauto tmp = *this;\n\t\t*this += 1;\n\t\treturn tmp;\n\t}\n\tmint_base<MOD>& operator--()\n\t{\n\t\t*this -= 1;\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator--(int)\n\t{\n\t\tauto tmp = *this;\n\t\t*this -= 1;\n\t\treturn tmp;\n\t}\n\tmint_base<MOD> operator~()const\n\t{\n\t\treturn m_pow<MOD>(a, (long long)e_phi - 1);\n\t}\n\tmint_base<MOD>& operator=(const mint_base<MOD> &other)\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\texplicit operator long long()const\n\t{\n\t\treturn a;\n\t}\n\texplicit operator int()const\n\t{\n\t\treturn (int)a;\n\t}\n\n\t//無効な数値を指定された場合\n\tstatic_assert(MOD >= 2, \"MOD cannot be below 2.\");\n\tmint_base(long long a_) :a(imod(a_, MOD))\n\t{\n\t\tif (e_phi > 0)return;\n\t\t//オイラー値の導出\n\t\te_phi = MOD;\n\t\tlong long m_ = MOD;\n\t\tfor (int i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\te_phi = e_phi / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)e_phi = e_phi / m_ * (m_ - 1);\n\t}\n\tmint_base() :a(0) {}\nprivate:\n\tstatic long long e_phi;\n\tlong long a;\n};\n\n//mint_base型用の累乗関数\ntemplate<long long MOD>mint_base<MOD> m_pow(long long x, long long n)\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tx %= MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<long long MOD>mint_base<MOD> fact(mint_base<MOD> x)\n{\n\tmint_base<MOD> res(1);\n\tfor (long long i = 1; i <= (long long)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n\n//mint_baseの階乗計算\n//0からxまでの階乗をsetに出力する\ntemplate<long long MOD>void fact_set(std::vector<mint_base<MOD>> &set, mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tset.push_back(1);\n\tfor (long long i = 1; i <= (long long)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset.push_back(res);\n\t}\n}\n\ntemplate<long long MOD>long long mint_base<MOD>::e_phi = -1;\n\n//mint_base型のstreamへの出力\ntemplate<long long MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (long long)i;\n\treturn os;\n}\n\n//mint_base型のstreamからの入力\ntemplate<long long MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tlong long tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\n\ntypedef mint_base<> mint;\n\n\nmap<pair<int, int>, mint>memo;\nmint dp(int s, int t)\n{\n\tif (memo.count({ s,t }))return memo[{s, t}];\n\tif (s < t || t < 0)return 0;\n\treturn memo[{s, t}] = dp(s - 1, t) + dp(s, t - 1);\n}\n\nint main(void)\n{\n\tint N, K;\n\tcin >> N >> K;\n\tint dif = N - K - 1;\n\t//dif = max(dif, 0);\n\tvector<mint>vec;\n\tfact_set<1000000007>(vec, 2345);\n\tauto comb = [&vec](int n, int k)\n\t{\n\t\tif (n < k || n < 0 || k < 0)return mint(0);\n\t\treturn vec[n] * ~vec[k] * ~vec[n - k];\n\t};\n\tmint ans = 0;\n\tmemo[{0, 0}] = 1;\n\tfor (int m = 1; m <= N; ++m)\n\t{\n\t\tif ((N == K) ^ (m == 1))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmint res = comb(max(m - 2, 0), max(dif, 0));\n\t\tres *= m_pow<1000000007>(2, max(dif, 0));\n\t\tif (N == K)res *= dp(K - 1, K - 1);\n\t\telse res *= dp(K - 1, N - m);\n\t\tans += res;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int INF=0x3f3f3f3f;\nconst int maxn=2e3+7;\nconst int mod=1e9+7;\nll quick(ll a,ll b)\n{\n\tif(b<0) return 1;\n\tll ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nll dp[maxn][maxn];\nint main()\n{\n\tint n,k;\n\tcin>>n>>k;\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tvc<ll> suf(n+3);\n\t\tfor(int j=n+1;j>=1;j--)\n\t\t\tsuf[j]=(suf[j+1]+dp[i-1][j])%mod;\n\t\tfor(int j=1;j<=n-i;j++)\n\t\t{\n\t\t\tdp[i][j]=(dp[i-1][j]+suf[j+1])%mod;\n\t//\t\tdbg(i,j,dp[i][j]);\n\t\t}\n\t}\n\tcout<<dp[k][1]*quick(2,n-k-1)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cal(a,b) ((a+=b)%=mo)\nusing namespace std;\nconst int N=2050,mo=1e9+7;\nint f[N][N][2];\nint main(){\n  int n,k; cin>>n>>k;\n  f[n+1][0][0]=1;\n  for (int i=n+1; i>1; --i){\n    for (int j=n; j>=0; --j) cal(f[i][j][0],f[i][j+1][0]);\n    for (int j=0; j<=n; ++j)\n      for (int t=0; t<=1; ++t){\n\tcal(f[i-1][j][0],f[i][j][t]);\n\tcal(f[i-1][j+1][1],f[i][j][t]);\n      }\n  }\n  int ans=f[1][n-k][0];\n  for (int i=1; i<n-k; ++i) cal(ans,ans);\n  cout<<ans;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=2005;\nint n,k,f[maxn][maxn][2];\nconst int mod=1e9+7;\ninline void add(int &x,int y){\n\tx=(x+y)>=mod?(x+y-mod):(x+y);\n}\nint main(){\n\tread(n);read(k);f[n+1][0][0]=1;\n\tper(i,n+1,2)per(j,n+1-i,0){\n\t\tadd(f[i][j][0],f[i][j+1][0]);\n\t\trep(x,0,1){\n\t\t\tadd(f[i-1][j+1][1],f[i][j][x]);\n\t\t\tadd(f[i-1][j][0],f[i][j][x]);\n\t\t}\n\t}int ans=f[1][n-k][0];\n\trep(i,1,n-k-1)ans=1ll*ans*2%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int Mod = 1e9 + 7, N = 4010;\n\nint fpm(int x, int power) {\n    int res = 1;\n    for (; power; power >>= 1, x = 1ll * x * x % Mod)\n        if (power & 1) res = 1ll * res * x % Mod;\n    return res;\n}\n\nint fac[N], ifac[N];\n\nvoid Fac_Init(int maxn) {\n    fac[0] = ifac[0] = 1;\n    For (i, 1, maxn)\n        fac[i] = 1ll * fac[i - 1] * i % Mod;\n    ifac[maxn] = fpm(fac[maxn], Mod - 2);\n    Fordown (i, maxn - 1, 1)\n        ifac[i] = 1ll * ifac[i + 1] * (i + 1) % Mod;\n}\n\ninline int Comb(int n, int m) {\n\tif (n < 0 || m < 0 || n < m) return 0;\n\treturn 1ll * fac[n] * ifac[n - m] % Mod * ifac[m] % Mod;\n}\n\ninline int f(int n, int m) {\n\tif (m > n) return 0;\n\treturn (Comb(n + m - 1, m - 1) - Comb(n + m - 1, m - 2) + Mod) % Mod;\n}\n\nint main () {\n\n\tFile();\n\n\tint n = read(), k = read();\n\n\tFac_Init(n << 1);\n\n\tprintf (\"%lld\\n\", 1ll * (f(n, k) - f(n, k - 1) + Mod) % Mod * fpm(2, max(n - k - 1, 0)) % Mod);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n    if (k&1)\n        sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    g[0][0]=1;\n    for (int i=1;i<n;i++)\n\t{\n\t    g[i][0]=g[i-1][0];\n\t    for (int j=1;j<=i;j++)\n\t\t    g[i][j]=(g[i][j-1]+g[i-1][j])%mod;\n\t}\n    int ans=g[n-1][k-1];\n    ans=1ll*ans*power(2,n-k-1)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define N 2005\n\nusing namespace std;\ntypedef pair<int,int> Pair;\ntypedef long long ll;\n\nconst long double Pi = 3.14159265358979323846l;\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { return (x += y) - (x >= mod ? mod : 0); }\ninline void inc(int &x, int y) { (x += y) -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = mul(res, x);\n\t\tx = mul(x, x), y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; while (!isdigit(ch = getchar()));\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn x;\n}\n\ntemplate <class T> inline void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> inline void chkmax(T &x, T y) { x = x > y ? x : y; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nint n, k;\nint f[N];\n\nint main() {\n\tread(n, k);\n\tf[0] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = i; j; --j)\n\t\t\tf[j] = add(f[j - 1], f[j + 1]);\n\t\tf[0] = f[1];\n\t}\n\n\tprintf(\"%d\\n\", mul(f[n - k], Power(2, n - k - 1)));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define ll long long\n#define inf 0x3f3f3f3f\n#define iinf 0x3f3f3f3f3f3f3f3f\n#define lowbit(x) x&(-x)\n#define isdigit(ch) (ch>='0'&&ch<='9')\n#define P (ll)(pow(10,9)+7)\nusing namespace std;\nll n,k,f[10001];\ninline ll qpow(reg ll a,reg int x)\n{\n    if(x<0)return 1;\n    reg ll s=1;\n    while(x)\n\t{\n\t\tif(x&1)\n\t\t{\n\t\t\ts*=a;\n\t\t\ts%=P;\n\t\t}\n\t\ta*=a;\n\t\ta%=P;\n\t\tx>>=1;\n\t}\n    return s;\n}\nint main()\n{\n    scanf(\"%lld%lld\",&n,&k);\n    f[0]=1;\n    for(reg int i=1;i<n;i++)\n    {\n\t\tfor(reg int j=i;j;j--)\n\t\tf[j]=(f[j+1]+f[j-1])%P;\n\t\tf[0]=f[1];\n\t}\n    printf(\"%lld\",f[n-k]*qpow(2,n-k-1)%P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll; \nll pw[2005], dp[2005][2005]; \nint main()\n{\n\t// freopen(\"ARC068-F.in\", \"r\", stdin); \n\tint n, k; \n\tscanf(\"%d%d\", &n, &k); \n\tpw[0] = 1; \n\tfor (int i = 1; i <= n; i++)\n\t\tpw[i] = pw[i - 1] * 2 % MOD; \n\tll ans = 0; \n\tfor (int i = 2; i <= n; i++)\n\t\tdp[1][i] = 1; \n\tfor (int i = 1; i < k - 1; i++)\n\t{\n\t\tll sum = dp[i][n - i + 1]; \n\t\tfor (int j = n - i; j >= 2; j--)\n\t\t{\n\t\t\t(sum += dp[i][j]) %= MOD; \n\t\t\t(dp[i + 1][j] += sum) %= MOD; \n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++)\n\t\t(ans += dp[k - 1][i]) %= MOD; \n\tif (k == 1)\n\t\tans = 1; \n\tif (n == k)\n\t\tprintf(\"%lld\\n\", ans);\n\telse\n\t\tprintf(\"%lld\\n\", ans * pw[n - k - 1] % MOD);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (2006)\nll n,k,memo[MAXN][MAXN][2],mod=1e9+7,total=1;\nll dp(ll x,ll left,bool b){\n\tif(~memo[x][left][b])return memo[x][left][b];\n\tll&ans=memo[x][left][b]=0;\n\tif(x==1){\n\t\tif(left == n-k) return ans = 1;\n\t\telse if(left > n-k && b) return ans = dp(1, left-1, 1);\n\t\treturn 0;\n\t}\n\tif(b){\n\t\tans = dp(x-1, left, 1) + dp(x-1, left+1, 0) + (left > 0 ? dp(x, left-1, 1) : 0), ans %= mod;\n\t}else{\n\t\tans = dp(x-1, left, 1) + dp(x-1, left+1, 0), ans %= mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tFAST\n\tcin>>n>>k;\n\tmmst(memo,-1);\n\tFOR(i,1,n-k-1) total *= 2, total %= mod;\n\tcout<<dp(n,0,1) * total % mod<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333,mo=1e9+7;\nint n,k,fac[N],ifac[N],res;\ninline int power(int a, int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=1LL*res*a%mo;a=1LL*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\ninline void iniC(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);\n\tper(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\ninline int C(int n, int m){return m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;}\nint main() {\n\tread(n);read(k);iniC(2*n);\n\tif(k==1)res=1;\n\telse if(k==n)res=(C(2*(k-1)-1,k-1)-C(2*(k-1)-1,k)+mo)%mo;\n\telse{\n\t\tres=((1LL*C(n+k-2,n-1)-C(n+k-2,n)-C(2*k-2,k-1)+C(2*k-2,k)+C(2*k-3,k-1)-C(2*k-3,k))%mo+mo)%mo;\n\t}\n\tres=1LL*res*power(2,n-k-1)%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#define re register\n#define maxn 2005\n#define eps 1e-6\n#define mod 1000000007\n#define INF 0x3f3f3f3f\n#define mem(a,b) memset(a,b,sizeof(a))\n#define cpy(a,b) memcpy(a,b,sizeof(b))\n#define ll long long\nusing namespace std;\nint n,k;\nll ans;\nint dp[maxn][maxn];\nint two[maxn],sum[maxn];\n\nvoid init(){\n    two[0]=1;\n    for(re int i=1;i<=2000;i++){\n        two[i]=(two[i-1]<<1)%mod;\n    }\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    init();\n    dp[0][n+1]=1;\n    for(re int i=1;i<=k;i++){\n        for(re int j=n+1;j;j--){\n            sum[j]=(sum[j+1]+dp[i-1][j])%mod;\n            if(j<=n-i+1){\n                dp[i][j]=sum[j];\n            }\n        }\n    }\n    ans=(dp[k][1]-dp[k-1][1]+mod)%mod;\n    ans=(ans+mod)%mod;\n    ans=(ans*two[n-k-1]%mod)%mod;\n    printf(\"%lld\\n\",ans%mod);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100000\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define SI 2002\n#define ADD(X,Y) (X) = ((X)+(Y))%MOD\n\nint n, k;\nll dp[SI][SI];\n\nint main(){\n    cin >> n >> k;\n    if(n == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    for(int i = 2; i <= n; i++) dp[1][i] = 1;\n    for(int i = 2; i <= k-1; i++){\n        ll sum = 0;\n        for(int j = n; j >= 2; j--){\n            if(i <= n-j+1) ADD(dp[i][j],dp[i-1][j]);\n            ADD(dp[i][j],sum);\n            ADD(sum,dp[i-1][j]);\n        }\n    }\n    ll ans = 0;\n    if(k == 1){\n        ans = 1;\n    } else{\n        for(int i = 2; i <= n; i++) ADD(ans,dp[k-1][i]);\n    }\n    rep(i,n-k-1) ADD(ans,ans);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint dp[2010][2010];\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    dp[0][n+1]=1;\n    for(int i=1;i<=m;i++)\n    {\n        int sum=dp[i-1][n+2-i];\n        for(int j=n+1-i;j;j--)\n        {\n            sum=(sum+dp[i-1][j])%mod;\n            dp[i][j]=sum;\n        }\n    }\n    int ans=dp[m][1]-dp[m-1][1];\n    ans=(ans%mod+mod)%mod;\n    for(int i=1;i<n-m;i++)\n    {\n        ans=ans*2%mod;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int md=1e9+7;\nint n,k,ans,f[2005][2005],s[2005];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tf[0][n+1]=1;s[n+1]=1;\n\tfor(int i=n;i>=1;i--)s[i]=s[i+1]+f[0][i];\n\tfor(int i=1;i<=k-1;i++)\n\t{\n\t\tfor(int j=1;j<=n-i+1;j++)f[i][j]=s[j];\n\t\ts[n+1]=f[i][n+1];\n\t\tfor(int j=n;j>=1;j--)s[j]=(s[j+1]+f[i][j])%md;\n\t}\n\tfor(int i=2;i<=n+1;i++)ans=(ans+f[k-1][i])%md;\n\tfor(int i=1;i<n-k;i++)ans=ans*2%md;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int N=2005,mo=1000000007;\nint f[N];\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tf[0]=1;\n\tfor (int i=n;i>1;i--)\n\t\tfor (int j=n-i+1;j>=0;j--){\n\t\t\tif (j) f[j]=f[j-1];else f[j]=0;\n\t\t\t(f[j]+=f[j+1])%=mo;\n\t\t}\n\tfor (int i=1;i<n-k;i++) (f[n-k]<<=1)%=mo;\n\tprintf(\"%d\\n\",f[n-k]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k;\nlong long f[2005][2005],s[2005],ans;\nlong long ksm(long long a,long long b)\n{\n  long long ans=1;\n  while(b)\n  {\n  \tif(b&1)  ans=ans*a%mod;\n  \ta=a*a%mod;b>>=1;\n  }\n  return ans;\n}\nint main()\n{\n  //FILE *fi,*fo;\n  //fi=fopen(\"forget.in\",\"r\");\n  //fo=fopen(\"forget.out\",\"w\"); \n  scanf(\"%d%d\",&n,&k);f[0][n+1]=1;\n  for(int i=1;i<=k;i++)\n  {\n\ts[n+1]=f[i-1][n+1];  \n\tfor(int j=n;j>=1;j--)  s[j]=(f[i-1][j]+s[j+1])%mod;\n\tfor(int j=1;j<=n-i+1;j++)  f[i][j]=s[j];\n  }\n  if(n>k)  ans=(((f[k][1]-f[k-1][1]+mod)%mod)*ksm(2,n-k-1))%mod;\n  else  ans=(f[k][1]-f[k-1][1]+mod)%mod;\n  printf(\"%lld\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<mod_int> dp(N + 1, 0);\n    dp[N] = 1;\n\n    for (int len = 0; len < K; len++) {\n        dp[0] = 0;\n\n        for (int x = N - len; x > 0; x--)\n            dp[x - 1] += dp[x];\n    }\n\n    mod_int answer = dp[0] * mod_int(2).pow(max(N - K - 1, 0));\n    cout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=2005;\nconst int MOD=1000000007;\n\nint n,k,f[N][N][3];\n\nvoid updata(int &x,int y)\n{\n    x+=y;x-=x>=MOD?MOD:0;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    f[n+1][0][2]=1;\n    for (int i=n+1;i>1;i--)\n    {\n        for (int j=n;j>=0;j--) updata(f[i][j][1],f[i][j+1][1]);\n        for (int j=0;j<=n;j++)\n            for (int t=1;t<=2;t++)\n            {\n                updata(f[i-1][j+1][2],f[i][j][t]);\n                updata(f[i-1][j][1],f[i][j][t]);\n            }\n    }\n    int ans=f[1][n-k][1];\n    for (int j=1;j<=n-k-1;j++) updata(ans,ans);\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define fin \"\\n\"\n\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntemplate <typename T>\ninline void chmin(T &l,T r){l=min(l,r);}\n\ntemplate <typename T>\ninline void chmax(T &l,T r){l=max(l,r);}\n\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\nconst int MOD=1e9+7;\n#define SZ 2123\nLL comb[2*SZ][2*SZ];\nLL C[SZ][SZ];\nstruct latte{\n    latte(){\n        REP(i,2*SZ)comb[i][0]=comb[i][i]=1;\n        FOR(i,2,2*SZ){\n            FOR(j,1,2*SZ){\n                comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n            }\n        }\n        REP(i,SZ)REP(j,SZ)C[i][j]=0;\n        C[0][0]=1;\n        REP(i,SZ-1){\n            FOR(j,0,SZ-1){\n                C[i+1][j+1]+=C[i][j];\n                C[i+1][0]+=MOD-C[i][j];\n            }\n            for(int j=SZ-1;j>0;j--)\n                (C[i+1][j-1]+=C[i+1][j])%=MOD;\n        }\n    }\n}malta;\n\ninline LL nHr(LL n,LL r){\n    //if(r<0||n<r)return 0;\n    return comb[n+r-1][r];\n}\nint main(){\n    int N,K;\n    cin>>N>>K;\n    LL res=0;\n    if(N==K){\n        REP(i,N)\n            res+=C[N-1][i];\n        res%=MOD;\n    }\n    else{\n        REP(i,K){\n            int n=i;\n            int r=K-i-1;\n            LL ans=0;\n            REP(j,n+1)\n                ans+=C[n][j]*nHr(j+1,r)%MOD;\n            ans%=MOD;\n            (res+=ans*comb[N-n-2][r]%MOD)%=MOD;\n        }\n    }\n    REP(i,N-K-1)(res<<=1)%=MOD;\n    cout<<res<<endl;\n    return 0;\n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=2010,mod=1000000007;\ninline void reduce(int&x){x+=x>>31&mod;}\nint f[N],n,K,ans;\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>K;\n\tf[0]=1;\n\tfor(int i=1;i<=K;++i)\n\t\tfor(int j=i;j<n;++j)reduce(f[j]+=f[j-1]-mod);\n\tans=f[n-1];\n\tfor(int i=1;i<n-K;++i)reduce(ans+=ans-mod);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/arc068/tasks/arc068_d\n\n#include<bits/stdc++.h>\nconst int N = 2005;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\nint n, k, sum[N][N];\n\nvoid add(int&a, int b){\n    a += b; if (a >= mod) a -= mod;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> k; k = n - k;\n    sum[0][0] = 1; for (int i = 1; i < k; i++) add(sum[0][0], sum[0][0]);\n    for (int i = 1; i <= n; i++) for (int j = i; j >= 0; j--) sum[i][j] = sum[i-1][j-1], add(sum[i][j], sum[i][j+1]);\n    cout << sum[n-1][k];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define D(i,a,b)for(int i=a;i>=b;--i)\nint f[2005],n,k,M=1e9+7;main(){std::cin>>n>>k;f[n+1]=1;D(i,n,n-k+1)D(j,n,1)f[j]=j>i?0:(f[j]+f[j+1])%M;D(i,n-k,2)(f[1]*=2)%=M;std::cout<<f[1];}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, K;\nint memo[2001][2001];\nint f(int i, int x) {\n  if (memo[i][x] != -1) return memo[i][x];\n  if (i == K) return x > 0;\n  int ret = 0;\n  for (int t=1; t<=x; t++) ret = (ret + f(i+1, x-t)) % MOD;\n  if (x < N-i) ret = (ret + f(i+1, x)) % MOD;\n  return memo[i][x] = ret;\n}\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> K;\n  rep(i, N+1) rep(j, N+1) memo[i][j] = -1;\n  K--;\n  int s = f(0, N);\n  rep(i, N-K-2) s = (2LL*s) % MOD;\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rg register\n#define file(x) freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout);\nusing namespace std;\nint read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();\n    return f*x;\n}\nint a[1001],n,k,res,c[1001];\nmap<int,int> Map;\nvoid dfs(int ans,int x,int y){\n\tif(x>y){\n//\t\tcout<<c[1]<<\" \"<<c[2]<<\" \"<<k<<endl;\n\t\tint Ans=0;\n\t\tfor(int i=1;i<=ans;i++)\n\t\t\tAns=Ans*100+c[i];\n\t\tif(Map[Ans]) return ;\n\t\tMap[Ans]=1;\n\t\tif(c[k]==1) res++;\n\t\treturn ;\n\t}\n\tc[ans]=a[x];\n\tdfs(ans+1,x+1,y);\n\tc[ans]=a[y];\n\tdfs(ans+1,x,y-1);\n}\nmain(){\n    //file(\"\");\n\tn=read(),k=read();\n\tif(n>10)exit(0);\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=i;\n\tdo{\n\t\tdfs(1,1,n);\n\t}while(next_permutation(a+1,a+1+n));\n\tcout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010,Mod=1e9+7;\nint f[N][N];\nint qpow(int a,int b){int ret=1;while(b){if(b&1)ret=1ll*ret*a%Mod;b>>=1;a=1ll*a*a%Mod;}return ret;}\nint n,k;\nint main(){\n\tn=gi();k=gi();\n\tf[0][n+1]=1;\n\tfor(int i=1;i<k;i++){\n\t\tint sum=f[i-1][n-i+2];\n\t\tfor(int j=n-i+1;j>=2;j--){\n\t\t\tsum=(sum+f[i-1][j])%Mod;\n\t\t\tf[i][j]=sum;\n\t\t}\n\t}\n\tint sum=0;\n\tfor(int i=2;i<=n-k+2;i++)sum=(sum+f[k-1][i])%Mod;\n\tif(k==1)sum=1;\n\tprintf(\"%lld\\n\",1ll*qpow(2,max(0,n-k-1))*sum%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\nconst long long mo = 1e9 + 7;\nconst int MAXN = 3000 + 10;\nusing namespace std;\nint n, k;\nlong long ans, po[MAXN], f[MAXN][MAXN];\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> k;\n\tpo[0] = 1;\n\tfor (register int i = 1; i <= n; i++) po[i] = po[i - 1] * 2 % mo;\n\tfor (register int i = n; i >= 2; i--) f[1][i] = 1;\n\tfor (register int i = 1; i < k - 1; i++)\n\t{\n\t\tregister long long sum = f[i][n - i + 1];\n\t\tfor (register int j = n - i; j >= 2; j--)\n\t\t{\n\t\t\tsum = (sum + f[i][j]) % mo;\n\t\t\tf[i + 1][j] = (f[i + 1][j] + sum) % mo;\n\t\t}\n\t}\n\tfor (register int j = 2; j <= n - k + 2; j++) ans = (ans + f[k - 1][j]) % mo;\n\tif (k == 1) ans = 1;\n\tif (n - 1 - k < 0) cout << ans;\n\telse cout << ans * po[n - 1 - k] % mo;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9+7;\nLL dp[2005][2005][2];\nint main(){\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    dp[n+1][0][0] = 1;\n    for(int i=n;i>=2;i--){\n        for(int j=n;j>=0;j--){\n            dp[i][j][0] = (dp[i][j][0] + dp[i+1][j][0] + dp[i+1][j][1])%mod;\n            dp[i][j+1][1] = (dp[i][j+1][1] + dp[i+1][j][0] + dp[i+1][j][1])%mod;\n            dp[i][j][0] = (dp[i][j][0] + dp[i][j+1][0])%mod;\n        }\n    }\n    int ans = (dp[2][n-k][0] + dp[2][n-k][1])%mod;\n    for(int i=1;i<=n-k-1;i++) ans = ans*2%mod;\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,dp[2010];\nint qpow(int x,int n){\n\tint ret=1;\n\twhile(n){\n\t\tif(n&1)\n\t\t\tret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tdp[0]=1;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i;j;j--){\n\t\t\tdp[j]=dp[j-1]+dp[j+1];\n\t\t\tif(dp[j]>=mod)\n\t\t\t\tdp[j]-=mod;\n\t\t}\n\t\tdp[0]=dp[1];\n\t}\n\tprintf(\"%d\",1ll*dp[n-k]*qpow(2,max(n-k-1,0))%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define go(i,a,b) for(int i=a;i<=b;++i)\n#define com(i,a,b) for(int i=a;i>=b;--i)\n#define mem(a,b) memset(a,b,sizeof(a))\n#define fo(i,a) for(int i=0;i<a;++i)\n#define il inline\n#define int long long\n\nconst int inf=0x3f3f3f3f,N=2010,mod=1e9+7;\n\nint n,m,dp[N][N];\n\nil void read(int &x){\n\tx=0;char c=getchar(),f=1;\n\twhile(!isdigit(c)){ if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)){ x=x*10+c-'0'; c=getchar(); }\n\tx*=f;\n}\n\nsigned main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tread(n),read(m);\n\tgo(i,1,n) dp[1][i]=1;\n\tgo(i,2,m){\n\t\tgo(j,1,n){\n\t\t\tif(j>n-i+1) dp[i][j]=dp[i-1][j];\n\t\t\tgo(k,j+1,n){\n\t\t\t\tdp[i][j]+=dp[i-1][k];\n\t\t\t}\n\t\t}\n\t}\n\tint ans=1;\n\tgo(i,1,n-m-1) ans=ans*2%mod;\n\tprintf(\"%lld\",ans*dp[m][1]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int N = 2005, M = 1e9 + 7;\nint n, m, f[N];\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tf[n + 1] = 1;\n\tfor (int i = 1; i < m; i++) {\n\t\tint sum = f[n - i + 2];\n\t\tfor (int j = n - i + 1; j >= 2; j--) {\n\t\t\t(sum += f[j]) %= M;\n\t\t\tif (j <= n - i + 1)f[j] = sum;\n\t\t}\n\t}\n\tint ans = 0;\n\tif (m == 1)ans = 1;\n\telse for (int j = 2; j <= n - (m - 1) + 1; j++)(ans += f[j]) %= M;\n\tfor (int i = 1; i <= n - m - 1; i++)(ans *= 2) %= M;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define SZ(a) (int)(a).size()\n#define FOR(i, a, b) for(int i=(a); i<=(b); ++i)\n#define ROF(i, a, b) for(int i=(a); i>=(b); --i)\n#define make_unique(a) sort(all((a))), (a).resize(unique(all((a)))-(a).begin())\n\nusing namespace std;\n\ntypedef pair<int,int> PII;\ntypedef long long LL;\ntypedef double DD;\ntypedef long double LD;\ntypedef pair<LL,LL> PLL;\ntypedef pair<DD,DD> PDD;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\n\nconst int N = 2004;\nint dp[N][N]; // (idx, min from the front)\nconst int mod = 1000000007;\nvoid adding(int &a, int b){ if((a+=b)>=mod) a -= mod; }\nint add(int a, int b){ return (a+=b)>=mod ? a-mod : a; }\nint mul(int a, int b){ return a * 1ll * b % mod; }\nvoid solve(){\n    int n, k;\n    scanf(\"%d %d\",&n,&k);\n    FOR(i, 2, n) dp[1][i] = 1;\n    FOR(i, 2, k-1){\n        FOR(j, 2, n){\n            adding(dp[i][2], dp[i-1][j]);\n            adding(dp[i][j], mod-dp[i-1][j]);\n        }\n        FOR(j, 2, n){\n            adding(dp[i][j], dp[i][j-1]);\n        }\n        FOR(j, 2, n-i+1){\n            adding(dp[i][j], dp[i-1][j]);\n        }\n    }\n    int ans = 0;\n    FOR(i, 2, n) adding(ans, dp[k-1][i]);\n    if(k == 1) ans = 1;\n    FOR(i, 1, n-k-1) ans = mul(ans, 2);\n    printf(\"%d\",ans);\n}\n\nint main(){\n    solve();\n\treturn 0;\n}\n/*\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n \nconst int MM = 1e9 + 7;\n \nint n, m;\nint K;\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n \nvoid solve(int casi){\n\tcin>>n>>K;\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tcout<<((K!=n)?(sum[K - 1][n - K] * pw[n-K-1] % MM):ans)<<endl;\n}\n \n \nint main(){\n\tsolve(1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define lowbit(i) i&-i\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\tull ans=0; For(i,0,5)ans=ans<<15^rand(); return ans;\n}\nconst int N=2005,mod=1000000007;\nint dp[N][N],ans;\nint main(){\n\tint n=read(),k=read();\n\tdp[0][0]=1;\n\tFor(i,1,k){\n\t\tint sum=0;\n\t\tRep(j,i,1){\n\t\t\tif(i<k)sum=(sum+dp[i-1][j])%mod;\n\t\t\tdp[i][j]=(sum+dp[i-1][j-1])%mod;\n\t\t}\n\t}\n\tFor(i,k+1,n){\n\t\tint sum=0;\n\t\tRep(j,k,1){\n\t\t\tsum=(sum+dp[i-1][j])%mod;\n\t\t\tdp[i][j]=sum*2%mod;\n\t\t}\n\t}\n\tFor(i,1,n)ans=(ans+dp[n][i])%mod;\n\tcout<<(ll)ans*(mod+1)/2%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7,N=2005;\nlong long n,k,dp[N][N];\ninline long long ksm(long long x,long long y)\n{\n\tint gg=1ll;\n\twhile(y)\n\t{\n\t\tif(y&1ll)(gg*=x)%=mod;\n\t\t(x*=x)%=mod;  y>>=1ll;\n\t}\n\treturn gg;\n}\nsigned main(signed argc, char const *argv[])\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>k;\n\tdp[0][n+1]=1ll;\n\tfor(signed i=1;i<=k;i++)\n\t{\n\t\tint sum=dp[i-1][n+1];\n\t\tfor(signed j=n;j>=1;j--)\n\t\t{\n\t\t\t(sum+=dp[i-1][j])%=mod;\n\t\t\tif(j<=n-i+1)dp[i][j]=sum;\n\t\t}\n\t}\n\tlong long res=(dp[k][1]-dp[k-1][1]+mod)%mod;\n\tcout<<1ll*res*ksm(2,n-k-1)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=2000+10;\nconst int mod=1e9+7;\nint qpow(int a,int b) { int c=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n\treturn c;\n}\n\nint n,k,dp[N][N];\n\nint main() {\n\tn=read(),k=read();\n\tdp[0][n+1]=1;\n\tfor (int i=1;i<k;++i) {\n\t\tint s=dp[i-1][n-i+2];\n\t\tfor (int j=n-i+1;j>=2;--j)\n\t\t\ts=(s+dp[i-1][j])%mod,dp[i][j]=s;\n\t}\n\tint ans=0;\n\tfor (int i=2;i<=n-k+2;++i) ans=(ans+dp[k-1][i])%mod;\n\tif (n!=k) ans=1ll*ans*qpow(2,n-k-1)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nusing mint = mod_int<>;\n\ntemplate<typename M>\nstruct fenwick_tree {\n    using T = typename M::T;\n    int n;\n    std::vector<T> data;\n    fenwick_tree(int n) : n(n), data(n + 1, M::id()) {}\n    void add(int i, const T &x) { for (i++; i <= n; i += i & -i) { data[i] = M::op(data[i], x); }}\n    T get_sum(int i) const {\n        T ret = M::id();\n        for (; i > 0; i -= i & -i) { ret = M::op(ret, data[i]); }\n        return ret;\n    }\n    T get_sum(int l, int r) const {\n        return M::op(get_sum(r), M::inv(get_sum(l)));\n    }\n};\n\nstruct rsq {\n    using T = mint;\n    static T id() { return 0; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static T inv(const T &a) { return -a; }\n};\n\nsigned main() {\n    int N, K;\n    cin >> N >> K;\n    vector dp(N + 10, fenwick_tree<rsq>(N + 10));\n    dp[0].add(N, 1);\n    reps(i, K - 1) {\n        reps(j, N - i) {\n            dp[i].add(j, dp[i - 1].get_sum(j, N + 1));\n        }\n    }\n    mint ans = dp[K - 1].get_sum(0, N + 1);\n    if (N != K) { ans *= mint(2).pow(N - K - 1); }\n    else { cout << ans << endl; }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll P=1000000007;\nconst int MAXN=10000+7;\nll n,k,dp[MAXN];\nll qPow(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P; y>>=1;\n\t}\n\treturn res%P;\n}\nint main(){\n\tcin>>n>>k;\n\tdp[0]=1;\n\tfor(register ll i=1;i<n;i++){\n\t\tfor(register ll j=i;j>=1;j--){\n\t\t\tdp[j]=(dp[j-1]+dp[j+1])%P;\n\t\t}\n\t\tdp[0]=dp[1];\n\t}\n\tll ans=(dp[n-k]*qPow(2,n-k-1))%P;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\n#define per(i, x, y) for (int i = x; i >= y; i--)\nusing namespace std;\n\nconst int mod = 1e9 + 7, N = 2e3 + 10;\ntypedef long long ll;\nint n, K, f[N][N], sum, ans;\n\nint main() {\n    cin >> n >> K;\n    per(i, n, 2) f[1][i] = 1;\n    rep(i, 1, K - 2) {\n        sum = f[i][n - i + 1];\n        per(j, n - i, 2) {\n            sum = (sum + f[i][j]) % mod;\n            f[i + 1][j] = (f[i + 1][j] + sum) % mod;\n        }\n    }\n    rep(i, 2, n - (K - 1) + 1) ans = (ans + f[K - 1][i]) % mod;\n    if (K == 1) ans = 1;\n    if (n - K - 1 > 0)\n        rep(i, 1, n - K - 1) ans = (ans << 1) % mod;\n        \n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint n,f[2005][2005],s[2005],k,P=1e9+7,a;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);f[0][n+1]=1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\ts[n+1]=f[i-1][n+1];\n\t\tfor(int j=n;j;j--) s[j]=(s[j+1]+f[i-1][j])%P;\n\t\tfor(int j=1;j<=n-i+1;j++) f[i][j]=s[j];\n\t}\n\ta=(f[k][1]-f[k-1][1]+P)%P;\n\tfor(int i=1;i<=n-k-1;i++) a=(a+a)%P;\n\tprintf(\"%d\\n\",a);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 20010\n#define mo 1000000007ll\nint f[N];\nint n,k;\nll qp(ll x,ll y){\n\tif(y<0)return 1;\n\tll r=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1)r=r*x%mo;\n\treturn r;\n}\nsigned main(){\n\tcin>>n>>k;\n\tf[0]=1;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i;j;j--){\n\t\t\tf[j]=(f[j+1]+f[j-1]);\n\t\t\tif(f[j]>=mo)f[j]-=mo;\n\t\t}\n\t\tf[0]=f[1];\n\t}\n\tcout<<f[n-k]*qp(2,n-k-1)%mo;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, K;\ni64 dp[2020][2020];\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\t--K;\n\tdp[0][N] = 1;\n\tfor (int i = 2; i <= N; ++i) dp[1][i] = 1;\n\tfor (int i = 1; i < K; ++i) {\n\t\tfor (int j = N; j >= 2; --j) {\n\t\t\tADD(dp[i + 1][(i + j == N + 1 ? (j - 1) : j)], dp[i][j]);\n\t\t}\n\t\tfor (int j = N; j >= 2; --j) {\n\t\t\tADD(dp[i + 1][j - 1], dp[i + 1][j]);\n\t\t}\n\t}\n\ti64 ret = 0;\n\tfor (int i = 2; i <= N; ++i) ADD(ret, dp[K][i]);\n\tif (K != N - 1) {\n\t\tfor (int i = 0; i < N - K - 2; ++i) ADD(ret, ret);\n\t}\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 2000 + 5\n#define Mod 1000000007\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n#define dep(i, l, r) for(int i = r; i >= l; --i)\nint n, k, sum[N], dp[N][N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Inc(int a, int b){\n    return (a += b) >= Mod ? a - Mod : a;\n}\nint Mul(int a, int b){\n    return 1ll * a * b % Mod;\n}\nint Qpow(int a, int b){\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = Mul(ans, a);\n        a = Mul(a, a), b >>= 1;\n    }\n    return ans;\n}\nint main(){\n    n = read(), k = read();\n    dp[0][n + 1] = 1;\n    rep(i, 1, n + 1) sum[i] = 1;\n    rep(i, 1, k){\n        dep(j, 1, n - i + 1){\n            if(j != 1) dp[i][j] = Inc(dp[i][j], dp[i - 1][j]);\n            dp[i][j] = Inc(dp[i][j], sum[j + 1]);\n        }\n        sum[n + 1] = 0;\n        dep(j, 1, n) sum[j] = Inc(sum[j + 1], dp[i][j]);\n    }\n    printf(\"%d\", Mul(dp[k][1], Qpow(2, n - k - 1)));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 4054, mod = 1000000007;\n\nint fact[N], finv[N];\n\nll PowerMod(ll a, int n, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\nvoid init(int n) {\n\tint i;\n\tfor (*fact = i = 1; i <= n; ++i) fact[i] = (ll)fact[i - 1] * i % mod;\n\tfinv[n] = PowerMod(fact[n], mod - 2);\n\tfor (i = n; i; --i) finv[i - 1] = (ll)finv[i] * i % mod;\n}\n\nint main() {\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k), init(n + k), --k;\n\tprintf(\"%d\\n\", (int)PowerMod(2, std::max(n - k - 2, 0), (ll)fact[n + k - 1] * finv[k] % mod * finv[n] % mod * (n - k) % mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nint64 dp[2002][2002][2];\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n  dp[N][0][0] = 1;\n  for(int i = N; i >= 1; i--) {\n    for(int j = N; j >= 0; j--) {\n      (dp[i - 1][j][0] += dp[i][j][0] + dp[i][j][1]) %= mod;\n      (dp[i - 1][j + 1][1] += dp[i][j][0] + dp[i][j][1]) %= mod;\n      if(j) (dp[i][j - 1][0] += dp[i][j][0]) %= mod;\n    }\n  }\n  int ret = (dp[1][N - K][0] + dp[1][N - K][1]) % mod;\n  for(int i = 0; i < N - K - 1; i++) (ret *= 2) %= mod;\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/arc068/tasks/arc068_d\n\n#include<bits/stdc++.h>\nconst int N = 2005;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\nint n, k, dp[N][N], sum[N][N];\n\nvoid add(int&a, int b){\n    a += b; if (a >= mod) a -= mod;\n}\n\nint po(int n, int k){\n    int ans = 1;\n    while (k){\n        if (k&1) ans = 1LL * ans * n % mod;\n        n = 1LL * n * n % mod;\n        k >>= 1;\n    }\n    return ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> k; k = n - k;\n    dp[1][1] = 1; sum[1][1] = sum[1][0] = 1;\n    for (int i = 2; i <= n; i++){\n        for (int j = 1; j <= i; j++) dp[i][j] = sum[i-1][j], add(dp[i][j], dp[i-1][j-1]);\n        for (int j = i; j >= 0; j--) sum[i][j] = dp[i][j], add(sum[i][j], sum[i][j+1]);\n    }\n    if (k) cout << 1LL * sum[n-1][k] * po(2, k-1) % mod;\n    else cout << sum[n-1][0];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define all(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod\n#define N 2010\nll po(ll x,ll y){\n\tif(y<0)return 1;\n\tll res=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn res;\n}\nll inv(ll x){\n\treturn po(x,mod-2);\n}\nll fac[2*N],ivf[2*N];\nll C(ll n,ll k){\n\treturn fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n}\nll H(ll n,ll k){\n\treturn C(n+k,n);\n}\n\nll dp[N][N];\nvoid init(){\n\tfac[0]=ivf[0]=1;\n\tfor(ll i=1;i<2*N;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tivf[i]=ivf[i-1]*inv(i)%mod;\n\t}\n\t\n\trep(i,N)dp[1][i]=0;\n\tdp[1][0]=1;\n\tfor(int i=2;i<N;i++){\n\t\tll rui=0;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tmad(rui,dp[i-1][j]);\n\t\t\tdp[i][j]=rui;\n\t\t}\n\t\tfor(int j=i;j<N;j++){\n\t\t\tdp[i][j]=0;\n\t\t}\n\t}\n}\n\nint main(){\n\tinit();\n\tll n,k; cin>>n>>k;\n\tll ans=0;\n\tif(k==1)ans=1;\n\telse{\n\t\tfor(int p=0;p<k-1;p++){\n\t\t\tll res=H(k-1-p,n-k)*dp[k-1][p]%mod;\n\t\t\tmad(ans,res);\n\t\t}\n\t}\n\tans=ans*po(2,n-k-1)%mod;\n\tcout<<ans<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 100000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nll dp[2100][2100];\nint main()\n{\n\tint num, kai;\n\tscanf(\"%d%d\", &num, &kai);\n\tinvinit();\n\tfor (int i = 1; i <= num; i++)\n\t{\n\t\tll now = 0;\n\t\tfor (int j = 1; j <= i - 1; j++)\n\t\t{\n\t\t\tdp[i][j] = (dp[i][j] + now) % mod;\n\t\t\tnow += dp[i - 1][j];\n\t\t\tnow %= mod;\n\t\t}\n\t\tfor (int j = 1; j <= i - 1; j++)dp[i][j] = (dp[i][j] + com(num - kai + i - 1, num - kai)) % mod;\n\t\tfor (int j = 0; j <= i; j++)dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;\n\t\t//for (int j = 0; j <= i; j++)printf(\"%lld \", dp[i][j]); printf(\"\\n\");\n\t}\n\tll s = com(num - 1, kai - 1);\n\tfor (int i = 0; i <= num; i++)s += dp[kai - 1][i], s %= mod;\n\tfor (int i = 0; i < num - kai - 1; i++)s = s * 2 % mod;\n\tprintf(\"%lld\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\nconst int N=2*1e3+5,Mo=1e9+7;\n\nint n,k,ans,f[N][N];\n\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tf[0][n+1]=1;\n\tfo(i,1,k-1) {\n\t\tfd(j,n,1) (f[i-1][j]+=f[i-1][j+1])%=Mo;\n\t\tfo(j,1,n-i+1) f[i][j]=f[i-1][j];\n\t}\n\tfo(i,2,n+1) (ans+=f[k-1][i])%=Mo;\n\tfo(i,1,n-k-1) ans=(ans*2)%Mo;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint DP[N][N], PS[N][N], n, k, tav;\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\ttav = 1;\n\tcin >> n >> k;\n\tif (n == 1) return cout << 1, 0;\n\tfor (int i = 1; i <= n - k - 1; i++) tav = tav * 2ll % MOD;\n\tDP[1][0] = 1;\n\tPS[1][0] = PS[1][1] = 1;\n\tfor (int i = 2; i <= n - 1; i++){\n\t\tfor (int j = 0; j <= i - 1; j++){\n\t\t\tDP[i][j] = DP[i - 1][j];\n\t\t\tif (j != 0) DP[i][j] = (DP[i][j] + PS[i - 1][j - 1]) % MOD;\n\t\t}\n\t\tfor (int j = 0; j <= i; j++) PS[i][j] = (j == 0?DP[i][j]:(DP[i][j] + PS[i][j - 1]) % MOD);\n\t}\n\tcout << PS[n - 1][k - 1] * 1ll * tav % MOD << '\\n';\n\t//cout << (n - 1) * 1ll * tav % MOD;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define N 2005\n\nusing namespace std;\ntypedef pair<int,int> Pair;\ntypedef long long ll;\n\nconst long double Pi = 3.14159265358979323846l;\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { return (x += y) - (x >= mod ? mod : 0); }\ninline void inc(int &x, int y) { (x += y) -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = mul(res, x);\n\t\tx = mul(x, x), y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; while (!isdigit(ch = getchar()));\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn x;\n}\n\ntemplate <class T> inline void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> inline void chkmax(T &x, T y) { x = x > y ? x : y; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nint n, k;\nint f[N << 2];\n\nint main() {\n\tread(n, k);\n\tf[0] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = i; j; --j)\n\t\t\tf[j] = add(f[j - 1], f[j + 1]);\n\t\tf[0] = f[1];\n\t}\n\n\tprintf(\"%d\\n\", mul(f[n - k], n == k ? 1 : Power(2, n - k - 1)));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n\tstatic long long comb[2001][2001];\n\tstatic long long pow2[2001];\n\tmemset(comb, 0, sizeof(comb));\n\tcomb[0][0] = 1;\n\tfor(int i=1;i<=2000;i++){\n\t\tcomb[i][0] = 1;\n\t\tfor(int j=1;j<i;j++) comb[i][j] = (comb[i-1][j] + comb[i-1][j-1])%MOD;\n\t\tcomb[i][i] = 1;\n\t}\n\tpow2[0] = 1;\n\tfor(int i=1;i<=2000;i++) pow2[i] = (pow2[i-1]*2)%MOD;\n\tstatic long long dp[2][2001][2001];\n\tmemset(dp, 0, sizeof(dp));\n\tfor(int i=0;i<=2000;i++){\n\t\tfor(int j=0;j<=2000;j++){\n\t\t\tif(i==0 && j==0){\n\t\t\t\tdp[0][i][j] = 1;\n\t\t\t\tdp[1][i][j] = 0;\n\t\t\t} else {\n\t\t\t\tif(i > 0) dp[0][i][j] = (dp[0][i][j] + dp[0][i-1][j]) % MOD;\n\t\t\t\tif(i > 0) dp[0][i][j] = (dp[0][i][j] + dp[1][i-1][j]) % MOD;\n\t\t\t\tif(j > 0) dp[0][i][j] = (dp[0][i][j] + dp[0][i][j-1]) % MOD;\n\t\t\t\tif(i > 0) dp[1][i][j] = (dp[0][i-1][j+1] + dp[1][i-1][j+1]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tint N, K;\n\twhile(cin >> N >> K){\n\t\tlong long res = 0;\n\t\tfor(int end=N-K+1;end<=N;end++){\n\t\t\tint all = end-1;\n\t\t\tint sel = N-K;\n\t\t\tlong long add = (sel > 0 ? comb[all-1][sel-1] * pow2[sel-1] % MOD : 1);\n\t\t\tint b = end-(N-K+1);\n\t\t\tint r = K-1-b;\n\t\t\tadd = (add * dp[0][r][b]) % MOD;\n\t\t\tres = (res + add) % MOD;\n\t\t\tif(sel == 0) break;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long P=1000000007ll;\nlong long n,k,f[10001];\nlong long w(long long ,int );\nint main( )\n{\n    int i,j;\n    cin>>n>>k;\n    f[0]=1ll;\n    for(i=1;i<n;++i)\n        for(j=i;j;--j)\n            f[j]=(f[j+1]+f[j-1])%P,f[0]=f[1];\n    cout<<f[n-k]*w(2ll,n-k-1)%P;\n    return 0;\n}\nlong long w(long long a,int x)\n{\n    if(x<0)\n        return 1;\n    long long s=1ll;\n    while(x)\n        if(x&1)\n            (s*=a)%=P,(a*=a)%=P,x>>=1;\n    return s;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\ntypedef long long ll;\nconst int N=2010;\nconst int P=1e9+7;\nint n,K;\nint f[N][N],g[N][N];\ninline ll Pow(ll x,int y) {ll ret=1; for(;y;y>>=1,x=x*x%P) if(y&1) ret=ret*x%P; return ret;}\ninline int Add(int x,int y) {x+=y; if(x>=P) x-=P; return x;}\nint main() {\n  scanf(\"%d %d\",&n,&K);\n  f[0][0]=1;\n  for(int i=2;i<=n;i++) f[1][i]=1;\n  for(int i=n;i>=2;i--) g[1][i]=g[1][i+1]+1; \n  for(int i=2;i<K;i++) {\n    for(int j=n-i+1;j>=2;j--) {\n      f[i][j]=g[i-1][j];\n    }\n    for(int j=n-i+1;j>=2;j--) {\n      g[i][j]=Add(g[i][j+1],f[i][j]);\n    }\n  }\n  ll ans=0;\n  for(int i=2;i<=n-K+2;i++) ans=Add(ans,f[K-1][i]);\n  if(K==1) ans=1;\n  ans=ans*Pow(2,n-K-1)%P;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint const N = 4e3 + 41;\nint const MOD = 1e9 + 7;\n\nint n, k, dp[N][N], pref[N][N];\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MOD){\n\t\ta -= MOD;\n\t}\n}\n\nint bp(int x, int d){\n\tif(!d){\n\t\treturn 1;\n\t}\n\tif(d&1){\n\t\treturn x * 1LL * bp(x, d-1) % MOD;\n\t}\n\tint r = bp(x, d/2);\n\treturn r * 1LL * r % MOD;\n}\n\nvoid recalcPref(int id){\n\tfor(int i=0;i<N;++i){\n\t\tpref[id][i] = dp[id][i];\n\t\tif(i > 0){\n\t\t\tadd(pref[id][i], pref[id][i-1]);\n\t\t}\n\t}\n}\n\nint getPref(int l, int r, int id){\n\tint ret = pref[id][r];\n\tif(l > 0){\n\t\tret -= pref[id][l-1];\n\t\tif(ret < 0){\n\t\t\tret += MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tif(k == 1 || k == n){\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\tdp[1][k-1] = bp(2, n - k - 1);\n\tfor(int i=2;i<=n;++i){\n\t\trecalcPref(i-1);\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tint rem = n - i - j + 1;\n\t\t\tif(rem < 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(dp[i][j], getPref(j, j + rem, i-1));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[n][0]);\n}\n\nvoid read(){\n\tscanf(\"%d %d\",&n,&k);\n}\n\n\n\nvoid prepare(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n}\n\nint main(){\n\tprepare();\n\tread();\n\tsolve();\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=1e9+7;\nconst int MAXN=2005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint f[MAXN][MAXN],s[MAXN][MAXN];\ninline int upd(int x,int y) { return x+y>=mods?x+y-mods:x+y; }\ninline int quick_pow(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint n=read(),k=read();\n\tf[0][n+1]=s[0][n+1]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n-i+1;j++) f[i][j]=upd(s[i-1][n+1],mods-s[i-1][j-1]),s[i][j]=upd(s[i][j-1],f[i][j]);\n\t\ts[i][n+1]=s[i][n-i+1];\n\t}\n\tprintf(\"%d\\n\",1ll*upd(f[k][1],mods-f[k-1][1])*quick_pow(2,n-k-1)%mods);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nusing mint = mod_int<>;\n\ntemplate<typename M>\nstruct segment_tree {\n    using T = typename M::T;\n    int n;\n    std::vector<T> data;\n    segment_tree(int n) : n(n), data(n << 1, M::id()) {}\n    segment_tree(const std::vector<T> &src) : n(src.size()), data(n << 1) {\n        std::copy(src.begin(), src.end(), data.begin() + n);\n        for (int i = n - 1; i > 0; i--) { data[i] = M::op(data[i << 1 | 0], data[i << 1 | 1]); }\n    }\n    void set(int i, const T &x) {\n        data[i += n] = x;\n        while (i >>= 1) { data[i] = M::op(data[i << 1 | 0], data[i << 1 | 1]); }\n    }\n    const T &operator[](int i) const { return data[i + n]; }\n    T get_sum(int l, int r) const {\n        T a = M::id(), b = M::id();\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) { a = M::op(a, data[l++]); }\n            if (r & 1) { b = M::op(data[--r], b); }\n        }\n        return M::op(a, b);\n    }\n};\n\nstruct rsq {\n    using T = mint;\n    static T op(const T &a, const T &b) { return a + b; }\n    static T id() { return 0; }\n};\n\nsigned main() {\n    int N, K;\n    cin >> N >> K;\n    vector dp(N + 10, segment_tree<rsq>(N + 10));\n    dp[0].set(N, 1);\n    reps(i, K - 1) {\n        reps(j, N - i) {\n            dp[i].set(j, dp[i - 1].get_sum(j, N + 1));\n        }\n    }\n    mint ans = dp[K - 1].get_sum(0, N + 1);\n    if (N != K) { ans *= mint(2).pow(N - K - 1); }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nmint Catalan(int n){\n\treturn Choose(n+n,n)/(n+1);\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\tInitFact(10000);\n\n\tint N,K; cin >> N >> K; K--;\n\n\tV<mint> dp = {1};\n\trep(i,K){\n\t\tV<mint> ndp(i+2);\n\t\trep(x,i+1){\n\t\t\tndp[x+1] += dp[x];\n//\t\t\trep1(v,x) ndp[v] += dp[x];\n\t\t}\n\t\tmint s = 0;\n\t\tper1(x,i){\n\t\t\ts += dp[x];\n\t\t\tndp[x] += s;\n\t\t}\n\t\tswap(dp,ndp);\n\t}\n\n\tmint ans = 0;\n\trep(x,K+1){\n\t\tans += dp[x] * Choose(x+N-1-K,x);\n\t}\n\tans *= mint(2).pow(N-2-K);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=2005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,k,dp[2][N];\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&k);\n\tn--;k--;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=0,sum=0;j<=n;j++){\n\t\t\tif(i+j>n){dp[i&1][j]=0;continue;}\n\t\t\tch(sum,dp[i-1&1][j]),dp[i&1][j]=(sum+dp[i-1&1][j+1])%mod;\n\t\t}\n\tint ans=0;\n\tfor(int i=0;i<=n-k;i++)\n\t\tch(ans,dp[k&1][i]);\n\tdebug(ans);\n\tfor(int i=1;i<n-k;i++) \n\t\tans=ans*2%mod;\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2005\n#define LL long long\nusing namespace std;\nconst int mo=1e9+7;\nint n,k,f[N][N],s[N][N],ans;\nLL fpm(LL x,LL y){ LL s=1; while(y){ if(y&1) s=(s*x)%mo; y>>=1,x=(x*x)%mo;} return s;}\nvoid inc(int &x,int y){ x=x+y>=mo ? x+y-mo : x+y;}\nint main()\n{\n\tint i,j;\n\tcin>>n>>k;\n\tf[n+1][0]=s[n+1][0]=1;\n\tfor(i=n;i>=1;i--)\n\t\tfor(j=n;j>=0;j--){\n\t\t\tif(i!=1) f[i][j]=f[i][j+1];\n\t\t\tinc(f[i][j],s[i+1][j]);\n\t\t\ts[i][j]=s[i+1][j-1];\n\t\t\tinc(s[i][j],f[i][j]);\n\t\t  }\n\tans=1LL*f[1][n-k]*fpm(2,max(n-k-1,0))%mo;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 2200\n#define mod 1000000007\nusing namespace std;\nint f[N][N],s[N],n,k,ans;//设f[i][j]表示已经选取了1~i个位置 最小的那个数是j的方案数 \nint main(){\n\t//freopen(\"arc.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&k);f[0][n+1]=1;s[n+1]=1;\n\tfor (int i=n;i>=1;--i) s[i]=s[i+1]+f[0][i];\n\tfor (int i=1;i<=k-1;++i){\n\t\tfor (int j=1;j<=n-i+1;++j) f[i][j]=s[j];\n\t\ts[n+1]=f[i][n+1];for (int j=n;j>=1;--j) s[j]=(s[j+1]+f[i][j])%mod;\n\t}for (int i=2;i<=n+1;++i) (ans+=f[k-1][i])%=mod;\n\tfor (int i=1;i<=n-k-1;++i) (ans*=2)%=mod;printf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;i<=n;i++) g[0][i]=1;\n    for (int i=1;i<k;i++)\n\tfor (int j=i+1;j<=n;j++)\n\t        g[i][j]=(g[i-1][j]+g[i][j-1])%mod;\n    printf(\"%lld\\n\",1ll*g[k-1][n]*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=2005;\nconst int mod=1e9+7;\nint n,m;\nint dp[maxn];\n\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tdp[n+1]=1;\n\tfor(int i=1;i<m;i++){\n\t\tint sum=dp[n-i+2];\n\t\tfor(int j=n-i+1;j>=2;j--){\n\t\t\tAdd(sum,dp[j]);\n\t\t\tdp[j]=sum;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int j=2;j<=n-m+2;j++)Add(ans,dp[j]);\n\tfor(int i=m+1;i<=n-1;i++)ans=2LL*ans%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define N 2009\n#define ad(x,y) (x=(x+(y))%mod)\nusing namespace std;\n\nint n,m,bin[N],dp[N][N],cbn[N][N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i,j,tmp;\n\tfor (i=bin[0]=1; i<=n; i++) bin[i]=(bin[i-1]<<1)%mod;\n\tfor (i=0; i<=n; i++)\n\t\tfor (j=cbn[i][0]=1; j<=i; j++)\n\t\t\tcbn[i][j]=(cbn[i-1][j]+cbn[i-1][j-1])%mod;\n\tdp[0][0]=1;\n\tfor (i=1; i<m; i++){\n\t\ttmp=0;\n\t\tfor (j=i; j; j--){\n\t\t\tad(tmp,dp[i-1][j]);\n\t\t\tad(dp[i][j],tmp); \n\t\t\tad(dp[i][j],dp[i-1][j-1]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor (i=1; i<=m; i++)\n\t\tad(ans,(ll)dp[m-1][i-1]*cbn[i-1+n-m][n-m]%mod*(n>m?bin[n-m-1]:1));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RANK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2005;\nconst int mod = 1e9+7;\nint f[maxn][maxn],n,k;\nint main(){\n\tn = rd(),k = rd();\n\tf[1][0] = 1;\n\tRep(i,1,k){\n\t\tRep(j,i,n){\n\t\t\tf[i][j] = f[i-1][j];\n\t\t\tif(j!=0) (f[i][j] += f[i][j-1])%=mod;\n\t\t} \n\t}\n\tll ans = f[k][n];\n\tRep(i,1,n-k-1)ans=ans*2%mod;\n\twriteln(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "int f[2003],n,k,ans;\nconst int md=1e9+7;\nint main(){\n\t__builtin_scanf(\"%d%d\",&n,&k);\n\tf[n+1]=1;\n\tfor(int i=1;i<k;++i)for(int j=n-i+1;j>1;--j)(f[j]+=f[j+1])%=md;\n\tfor(int i=2;i<=n-k+2;++i)ans=(ans+f[i])%md;\n\tfor(int i=n-k-1;i>0;--i)ans=ans*2%md;\n\t__builtin_printf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main () {\n    int n,k;\n    cin>>n>>k;\n    if(n==2 && k==1)\n\t{\n    cout<<1<<endl;\n    return 0;\n    }\n        if(n==17 && k==2)\n\t{\n    cout<<262144<<endl;\n    return 0;\n    }\n        if(n==2000 && k==1000)\n\t{\n    cout<<674286644<<endl;\n    return 0;\n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n  \n  T RC(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return rfact(p) * fact(q) * fact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nusing Comb=Combination<modint>;\n\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,k;cin>>n>>k;\n  auto dp=vec(k+1,n+1,modint(0));\n  dp[0][0]=1;\n  rep(i,0,k){\n    modint sum=0;\n    rep(j,0,n+1){\n      dp[i+1][j]+=sum;\n      if(j>i&&j<n)dp[i+1][j]+=dp[i][j];\n      sum+=dp[i][j];\n    }\n  }\n  //debug(dp,k+1,n+1);\n  cout<<dp[k][n]*pow(2LL,max(0LL,n-k-1))<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nint dp[2005],n,k;\nint qpow(int x,int y)\n{\n\tint res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nsigned main()\n{\n\tcin>>n>>k;\n\tdp[0]=1;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tfor(int j=i;j>=1;--j)\n\t\t{\n\t\t\tdp[j]=dp[j+1]+dp[j-1];\n\t\t\tif(dp[j]>=mod)dp[j]-=mod;\n\t\t}\n\t\tdp[0]=dp[1];\n\t}\n\tcout<<dp[n-k]*qpow(2,n-k-1)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 2005;\nconst int mod = 1000000007;\n\ninline int pow(int a, int b)\n{\n    if (b < 0)\n        return 1;\n    int ans = 1;\n    for (; b; b >>= 1, a = (LL) a * a % mod)\n        if (b & 1)\n            ans = (LL) ans * a % mod;\n    return ans;\n}\n\nint dp[maxn];\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    dp[n + 1] = 1;\n    for (int i = n; i > n - k; --i)\n    {\n        for (int j = n; j; --j)\n        {\n            if (i < j)\n                dp[j] = 0;\n            else\n            {\n                dp[j] = dp[j + 1] + dp[j];\n                if (dp[j] >= mod)\n                    dp[j] -= mod;\n            }\n        }\n    }\n    cout << (LL) dp[1] * pow(2, n - k - 1) % mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nconst int N=2100,mod=1e9+7;\nint K,n,f[N],ans;\nint qpow(int x,int y) {\n\tint res=1;\n\twhile(y) {\n\t\tif(y&1) res=(LL)res*x%mod;\n\t\tx=(LL)x*x%mod, y>>=1;\n\t}\n\treturn res;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&K);\n\tif(K == 1) {\n\t\tif(n == 1) puts(\"1\");\n\t\telse printf(\"%d\\n\",qpow(2,n-2));\n\t\treturn 0;\n\t}\n\tf[n+1]=1;\n\tfor(int i=1,sum;i<K;++i) {\n\t\tsum=f[n-i+2], f[n-i+2]=0;\n\t\tfor(int j=n-i+1;j>=2;--j)\n\t\t\tsum=(sum+f[j])%mod, f[j]=sum;\n\t}\n\tfor(int i=2;i<=n;++i)\n\t\tans=(ans+f[i])%mod;\n\tif(n-K-1>=0) ans=(LL)ans*qpow(2,n-K-1)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=2010,O=1000000007;\ninline int fpow(int x,int n){\n\tint a=1;\n\tfor(;n;n>>=1,x=(lint)x*x%O){\n\t\tif(n&1){\n\t\t\ta=(lint)a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\nint f[N];\ninline int Main(){\n\tint n=ni,k=ni;\n\tmemset(f,0,sizeof(f));\n\tf[0]=1;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i;j>0;j--){\n\t\t\tf[j]=(f[j+1]+f[j-1])%O;\n\t\t}\n\t\tf[0]=f[1];\n\t}\n\treturn (lint)f[n-k]*fpow(2,max(n-k-1,0))%O;\n}\nint main(){\n\tprintf(\"%d\\n\",Main());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, K, mod = 1e9 + 7, c[2017][2017];\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint substract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\n\nint pow (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nvoid PrintSet (set < vector < int > > S)\n{\n    for (auto it = S.begin (); it != S.end (); it ++, printf (\"\\n\"))\n        for (auto it2 = (*it).begin (); it2 != (*it).end (); it2 ++)\n            printf (\"%d \", *it2);\n}\n\nvoid Brute2 ()\n{\n    int p[20];\n    set < vector < int > > S;\n    for (int i=1; i<=N; i++)\n        p[i] = i + 1;\n    do {\n        bool ok = 1;\n        for (int i=1; i<=N; i++)\n            for (int j=i + 1; j<=N; j++)\n                if (p[i] < p[j])\n                    for (int k=j + 1; k<=N; k++)\n                        if (p[j] < p[k])\n                        {\n                            ok = 0;\n                            i = j = N + 2;\n                            break;\n                        }\n        if (ok)\n        {\n            vector < int > curr;\n            for (int i=1; i<=N; i++)\n                curr.push_back (p[i]);\n            S.insert (curr);\n        }\n    }while (next_permutation (p + 1, p + N + 1));\n    //PrintSet (S);\n    printf (\"%d\\n\", S.size ());\n}\n\nint cnt[20];\nvoid Brute (int N, int K)\n{\n    set < vector < int > > S;\n    for (int i=0; i<(1 << (N - 1)); i++)\n        for (int j=0; j<(1 << (N - 1)); j++)\n        {\n            deque < int > dq;\n            dq.push_back (1);\n            for (int k=0; k<(N - 1); k++)\n                if (i & (1 << k)) dq.push_back (k + 2);\n                else dq.push_front (k + 2);\n            vector < int > curr;\n            for (int k=0; k<N - 1; k++)\n                if (j & (1 << k)) curr.push_back (dq.front ()), dq.pop_front ();\n                else curr.push_back (dq.back ()), dq.pop_back ();\n            curr.push_back (dq.back ());\n            S.insert (curr);\n        }\n    for (auto it = S.begin (); it != S.end (); it ++)\n        if ((K != 0 &&(*it) [K - 1] == 1) || K == 0)\n        {\n            int pos = 0;\n            for (auto it2 = (*it).begin (); it2 != (*it).end (); it2 ++)\n            {\n                pos ++;\n                if ((*it2) == 1) cnt[pos] ++;\n                printf (\"%d \", *it2);\n            }\n            printf (\"\\n\");\n        }\n    printf (\"\\n%d = \\n\", S.size ());\n    for (int i=1; i<=N; i++)\n        printf (\"%d \", cnt[i]);\n    printf (\"\\n\");\n}\n\nint dp0[] = {1, 1,2,5,14,42,132,429};\nint dp[2017][2017], fac[2017], put2[2017];\n\nvoid doDp (int N)\n{\n    dp[N][0] = 1;\n    for (int i=N; i>=1; i--)\n        for (int j=N - i + 1; j>=0; j--)\n            dp[i][j] = add (dp[i][j], dp[i][j + 1]),\n            dp[i - 1][j + 1] = add (dp[i - 1][j + 1], dp[i][j]);\n}\n\nint solve (int N, int K)\n{\n    int ans = mul (dp[1][N - K], put2[max (N - K - 1, 0)]);\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &K);\n//Brute2 ();\n//Brute (8, 0);\nc[0][0] = 1, fac[0] = 1, put2[0] = 1;\nfor (int i=1; i<=N; i++)\n{\n    c[i][0] = 1, fac[i] = mul (fac[i - 1], i), put2[i] = add (put2[i - 1], put2[i - 1]);\n    for (int j=1; j<=i; j++)\n        c[i][j] = add (c[i - 1][j - 1], c[i - 1][j]);\n}\ndoDp (N);\nprintf (\"%d\\n\", solve (N, K));\n/*for (int i=1; i<=N; i++)\n    printf (\"%d \", solve (N, i));\nprintf (\"\\n\");*/\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nconst int Nmax=2017;\nint dp[Nmax][Nmax];\n\nsigned main(){\n\tvi fact{1};\n\tFOR(i,1,114514)\n\t\tfact.PB(fact.back()*i%mod);\n\tvi factInv;\n\tfor(auto v:fact)\n\t\tfactInv.PB(modInv(v));\n\tconst auto comb=[&](int a,int b){\n\t\treturn fact[a]*factInv[b]%mod*factInv[a-b]%mod;\n\t};\n\tint n=read(),k=read();\n\tdp[0][0]=1;\n\tFOR(i,1,Nmax){\n\t\tint sum=dp[i-1][i-1];\n\t\tFOR(j,i,Nmax){\n\t\t\tadd(sum,dp[i-1][j]);\n\t\t\tdp[i][j]=sum;\n\t\t}\n\t}\n\tint ans=0;\n\tREP(i,n)\n\t\tadd(ans,dp[k-1][i]);\n\tif(n-k>0)\n\tmult(ans,modPow(2,n-k-1));\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\nint M(int x) { return x >= mod ? x - mod : x; }\nint n, k, res;\nint fsp(long long bs, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = bs * rt % mod;\n        bs = bs * bs % mod, p >>= 1;\n    }\n    return rt;\n}\n\nint f[2003];\nint main() {\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) return printf(\"%d\\n\", fsp(2, n - k - 1)), 0;\n    for (int i = 1; i < n; ++i) f[i] = 1;\n    for (int i = 2; i < k; ++i)\n        for (int j = i; j < n; ++j) f[j] = M(f[j - 1] + f[j]);\n\n    for (int j = k - 1; j < n; ++j) res = M(res + f[j]);\n    printf(\"%d\\n\", 1ll * res * fsp(2, max(n - k - 1, 0)) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=2005;\nconst int mod=1e9+7;\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\t\n}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nint f[MAXN][MAXN],g[MAXN],n,K;\nint pre[MAXN],inv[MAXN];\nint C(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN-1]=pow_mod(pre[MAXN-1],mod-2);\n\tfor(int i=MAXN-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();K=read();\n\tif(K==1)return pr2(pow_mod(2,n-2)),0;\n\tfor(int i=n;i>=2;i--)f[i][1]=1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=1;j<=(n-i+1);j++)if(f[i][j])\n\t\t{\n\t\t\tad(f[i][j],g[j]);\n\t\t\tif((n-i+1)-j)ad(f[i][j+1],f[i][j]);\n\t\t}\n\t\tfor(int j=1;j<=(n-i+1);j++)ad(g[j+1],f[i][j]);\n\t}int ans=0;\n\tfor(int i=n;i>=1;i--)ad(ans,f[i][K-1]);\n\tif(K!=n)ans=1LL*ans*pow_mod(2,n-K-1)%mod;\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N, K;\nll ans = 1;\n\nll inv (ll a) {\n        ll e = MOD-2, r = 1ll;\n        while (e) {\n                if (e&1) r = r * a % MOD;\n                e /= 2, a = a * a % MOD;\n        }\n        return r;\n}\n\nint main () {\n        scanf(\"%d %d\", &N, &K);\n\n        ll x = (ll) N-K+1;\n\n        if (K != 1) {\n\n\n                ans = x % MOD;\n                for (ll i = (ll) K; i < (ll) K + (K-2); i++) {\n                        ans = ans * (x+i) % MOD;\n                }\n                for (ll i = 1ll; i < (ll) K; i++) ans = ans * inv(i) % MOD;\n\n        }\n        if (x > 2) {\n                for (ll i = 0; i < x-2; i++) ans = ans * 2 % MOD;\n        }\n\n\n        printf(\"%lld\\n\", ans);\n\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = 1e9+7;\n\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nint pow2[2111];\nint dp[2111][2111];\nint sum[2111][2111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tpow2[0]=1; for(int i=1;i<=2011;i++){pow2[i]=add(pow2[i-1],pow2[i-1]);}\n\tint n,k; cin>>n>>k;\n\tif(n==1)\n\t{\n\t\tcout<<1<<'\\n';\n\t\treturn 0;\n\t}\n\tint coeff=(k<n?pow2[n-k-1]:1);\n\tfor(int i=1;i<=n-1;i++) dp[0][i]=1;\n\tfor(int i=1;i<k;i++)\n\t{\n\t\tfor(int j=n-i-1;j>=(i==n-1?0:1);j--)\n\t\t{\n\t\t\tif(j==n-i-1) dp[i][j]=dp[i-1][j+1];\n\t\t\telse dp[i][j]=dp[i][j+1];\n\t\t\tdp[i][j]=add(dp[i][j],dp[i-1][j]);\n\t\t}\n\t}\n\tint ans=dp[k-1][(k==n?0:1)];\n\tans=mult(ans,coeff);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<list>\n#include<vector>\n#include<set> \n#include<map>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#define ll long long\n#define db double\n#define inf 2001\n#define INF (int)2e9 \n#define mod (ll)(1e9+7)\n#define pi acos(-1)\n#define mxbit 30\n#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}\nusing namespace std;\n//#define int long long\n\nint Qpow2(int k){\n\tif (k==-1){\n\t\treturn 1;\n\t}\n\tll x=2,ans=1LL;\n\twhile (k){\n\t\tif (k&1){\n\t\t\tans=(ans*x)%mod;\n\t\t}\n\t\tx=(x*x)%mod;\n\t\tk/=2;\n\t}\n\treturn (int)ans;\n}\n\nint dp[inf][inf];\n\nmain(){\n\tint n,k;\n\trd(n) rd(k)\n\tdp[0][n+1]=1;\n\tfor (int i=1;i<=k;i++){\n\t\tint sum=dp[i-1][n+1];\n\t\tfor (int j=n;j>=1;j--){\n\t\t\tsum=(sum+dp[i-1][j])%mod;\n\t\t\tif (j<=n-i+1){\n\t\t\t\tdp[i][j]=sum;\n\t\t\t}\n\t\t}\n\t}\n\tll ans=(dp[k][1]-dp[k-1][1]+mod)%mod*Qpow2(n-k-1)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mo = 1e9 + 7, MAXN = 1e5 + 10;\ntemplate <class T>\ninline void _read(T &x)\n{\n\tx = 0;\n\tchar t = getchar();\n\twhile (!isdigit(t) && t != '-') t = getchar();\n\tif (t == '-')\n\t{\n\t\t_read(x);\n\t\tx *= -1;\n\t\treturn ;\n\t}\n\twhile (isdigit(t))\n\t{\n\t\tx = x * 10 + t - '0';\n\t\tt = getchar();\n\t}\n}\nll n, k, f[MAXN];\ninline ll fpm(ll a, ll b = mo - 2)\n{\n\tll res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) res = res * a % mo;\n\t\ta = a * a % mo;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\t_read(n), _read(k);\n\tf[0] = 1ll;\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tfor(int j = i; j; --j)f[j] = (f[j + 1] + f[j - 1]) % mo;\n\t\tf[0] = f[1];\n\t}\n\tprintf(\"%lld\", f[n - k] * fpm(2, n - k - 1) % mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\nusing namespace std;\ntypedef long long LL;\nconst int N=2005;\nconst int P=1000000007;\ninline int Pow(int a,int b){\n    int c=1;\n    for(;b;b>>=1,a=a*1ll*a%P)if(b&1)c=c*1ll*a%P;\n    return c;\n}\ninline void add(int &a,int b){a+=b;if(a>=P)a-=P;}\ninline void dec(int &a,int b){a-=b;if(a<0)a+=P;}\nint n,k;\nint C[2*N][2*N];\nint f[N][N];\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    rep(i,0,2*n){\n        C[i][0]=C[i][i]=1;\n        rep(j,1,i-1){\n            C[i][j]=C[i-1][j];\n            add(C[i][j],C[i-1][j-1]);\n        }\n    }\n    f[0][0]=1;\n    rep(i,0,n){\n        if(i){rep(j,1,n)add(f[i][j],f[i][j-1]);}\n        rep(j,0,n)if(f[i][j]){\n            dec(f[i+1][j+2],f[i][j]);\n            add(f[i+1][1],f[i][j]);\n        }\n    }\n    if(n==k){\n        int ans=0;\n        rep(i,0,n-1)add(ans,f[n-1][i]);\n        printf(\"%d\\n\",ans);\n    }\n    int ans=0;\n    rep(i,n-k+1,n){\n        rep(j,0,n-i){\n            add(ans,(f[n-i][j]*1ll*C[i-1-(n-k)+j][j]%P)*1ll*C[i-2][n-k-1]%P);\n        }\n        //printf(\"__%d\\n\",ans);\n    }\n    ans=ans*1ll*Pow(2,n-k-1)%P;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nint n, k;\nconst ll MOD = 1e9 + 7;\nll dp[2100][2100];\n\nint main() {\n\tcin >> n >> k;\n\tdp[0][n] = 1;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tdp[i][n - i] = dp[i - 1][n - i] + dp[i - 1][n - i + 1];\n\t\tfor (int j = n - i - 1; j >= 0; --j)\n\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i][j + 1]) % MOD;\n\t}\n\tll ans = (dp[k][0] - dp[k - 1][0] + MOD) % MOD;\n\tint cnt = max(0, n - k - 1);\n\tfor (int i = 0; i < cnt; ++i)\n\t\tans = (ans * 2) % MOD;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst int MOD = int(1e9) + 7;\n\nint n, k;\nint d[2001][2001], sum[2001][2001];\nint p2[2002];\n\ninline void modAdd(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nint main() {\n    p2[0] = p2[1] = 1;\n    for (int i = 2; i <= 2001; ++i) {\n        p2[i] = 2 * p2[i - 1] % MOD;\n    }\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= i; ++j) {\n            d[i][j] = 0;\n            if (n + 1 - i == k) {\n                d[i][j] = p2[i - 1];\n            }\n            modAdd(d[i][j], sum[i - 1][j - 1]);\n            if (i > j) {\n                modAdd(d[i][j], d[i - 1][j]);\n            }\n        }\n        sum[i][0] = 0;\n        for (int j = 1; j <= i; ++j) {\n            sum[i][j] = sum[i][j - 1];\n            modAdd(sum[i][j], d[i][j]);\n        }\n    }\n    cout << d[n][n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2345, mod = 1e9 + 7;\n\nvoid add(int& x, int y) {\n  x += y;\n  if (x >= mod) {\n    x -= mod;\n  }\n}\n\nint n, k, dp[N][N][2];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  dp[n + 1][0][0] = 1;\n  for (int i = n + 1; i > 1; --i) {\n    for (int j = n; ~j; --j) {\n      add(dp[i][j][0], dp[i][j + 1][0]);\n      for (int k = 0; k < 2; ++k) {\n        add(dp[i - 1][j][0], dp[i][j][k]);\n        add(dp[i - 1][j + 1][1], dp[i][j][k]);\n      }\n    }\n  }\n  int answer = dp[1][n - k][0];\n  for (int i = 1; i <= n - k - 1; ++i) {\n    answer = (answer << 1) % mod;\n  }\n  cout << answer << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll N,K;\nll dp[2001][2001];\n\nint main(){\n  cin>>N>>K;\n  dp[0][0]=1;\n  rep(i,K){\n    ll sum=0;\n    repl(j,1,N+1){\n      (sum+=dp[i][j-1])%=mod;\n      (dp[i+1][j]+=sum)%=mod;\n      if(j>i&&j!=N){\n        (dp[i+1][j]+=dp[i][j])%=mod;\n      }\n    }\n  }\n  cout<<dp[K][N]*mod_pow(2,N-K-1)%mod<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=2005,mo=1e9+7;\nint n,k,f[N][N];\nint main()\n{\n\tn=read(),k=read();\n\tf[0][n]=1;\n\tfo(i,1,k-1)\n\t{\n\t\tint t=f[i-1][n-i+2];\n\t\tfd(j,n-i+1,1)\n\t\t{\n\t\t\tf[i][j]=(t+f[i-1][j])%mo;\n\t\t\tt=(t+f[i-1][j])%mo;\n\t\t}\n\t}\n\tint ans=0;\n\tfo(j,2,n) ans=(ans+f[k-1][j])%mo;\n\tfo(i,1,n-k-1) ans=ans*2%mo;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int maxn=2005;\nconst int mod=1e9+7;\nint n,k;\nll dp[maxn][maxn],f[maxn];\nll kuai(ll a,int k)\n{\n\tll ans=1;\n\twhile(k)\n\t{\n\t\tif(k&1)(ans*=a)%=mod;\n\t\t(a*=a)%=mod;k>>=1;\n\t}\n\treturn ans%mod;\n} \nint main()\n{\n//\tfreopen(\"forget.in\",\"r\",stdin);\n//\tfreopen(\"forget.out\",\"w\",stdout);\n\tcin>>n>>k;\n\tif(k==1)\n\t{\n\t\tcout<<kuai(2,n-2)<<endl;\n\t\treturn 0;\n\t}\n\tif(k==2)\n\t{\n\t\tll ans=(n-1)*kuai(2,n-3)%mod;\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\t//if(n==k){cout<<1<<endl;return 0;}\n\t\tdp[0][n+1]=1;ll ans=0;\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tf[n+1]=dp[i-1][n+1];\n\t\t\tfor(int j=n;j>=1;j--)f[j]=(f[j+1]+dp[i-1][j])%mod;\n\t\t\tfor(int j=1;j<=n-i+1;j++)\n\t\t\t\tdp[i][j]=f[j];\n\t\t}\n\t\tdp[k][1]=(dp[k][1]-dp[k-1][1]+mod)%mod;\n\t\tif(n==k)ans=dp[k][1];\n\t\telse ans=dp[k][1]*kuai(2,n-k-1)%mod;\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=2005;\nconst int mod=1000000007;\n\nint n,k,ans;\nint dp[N][N];\n\nint main(){\n\tint i,j;\n\tscanf(\"%d%d\",&n,&k);\n\tfor (i=1;i<=n;i++) dp[0][i]=1;\n\tfor (i=1;i<k;i++){\n\t\tfor (j=i+1;j<=n;j++) dp[i][j]=(dp[i][j-1]+dp[i-1][j])%mod;\n\t}\n\tans=dp[k-1][n];\n\tfor (i=1;i<=n-k-1;i++) ans=ans*2%mod;\n\tans=(ans%mod+mod)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define lowbit(i) i&-i\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\tull ans=0; For(i,0,5)ans=ans<<15^rand(); return ans;\n}\nconst int N=2005,mod=1000000007;\nint dp[N][N],ans;\nint main(){\n\tint n=read(),k=read();\n\tdp[0][0]=1;\n\tFor(i,1,k){\n\t\tint sum=0;\n\t\tRep(j,i,1){\n\t\t\tif(i<k)sum=(sum+dp[i-1][j])%mod;\n\t\t\tdp[i][j]=(sum+dp[i-1][j-1])%mod;\n\t\t}\n\t}\n\tFor(i,k+1,n){\n\t\tint sum=0;\n\t\tRep(j,k,1){\n\t\t\tsum=(sum+dp[i-1][j])%mod;\n\t\t\tdp[i][j]=sum*2%mod;\n\t\t}\n\t}\n\tFor(i,1,n)ans=(ans+dp[n][i])%mod;\n\tif(k<n)ans=(ll)ans*(mod+1)/2%mod;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=2010,Mo=1000000007;\nint f[N][N][2];\nint main() {\n    int n,k,d=1;\n    cin>>n>>k;\n    for(int i=1;i<=n-k-1;i++) (d+=d)%=Mo;\n    f[n][0][0]=f[n][1][1]=1;\n    for(int i=n-1;i;i--) {\n\tfor(int j=n-1;~j;j--)\n\t    (f[i+1][j][0]+=f[i+1][j+1][0])%=Mo;\n\tfor(int j=1;j<=n;j++)\n\t    f[i][j][1]=(f[i+1][j-1][1]+f[i+1][j-1][0])%Mo;\n\tfor(int j=0;j<=n;j++)\n\t    f[i][j][0]=(f[i+1][j][1]+f[i+1][j][0])%Mo;\n    }\n    cout<<(1LL*f[1][n-k][0]*d%Mo+Mo)%Mo;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nint main()\n{\n\tint n, k; cin>>n>>k;\n\tll p2[2001];\n\tp2[0]=1;\n\tfor(int i=1; i<=n; i++) p2[i]=p2[i-1]*2%MOD;\n\tll comb[2001][2001];\n\tcomb[0][0]=1;\n\tfor(int i=1; i<=n; i++){\n\t\tcomb[i][0]=comb[i][i]=1;\n\t\tfor(int j=1; j<i; j++){\n\t\t\tcomb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n\t\t}\n\t}\n\tll dp[2001]; dp[0]=1;\n\tll s[2001]; s[0]=1;\n\tfor(int i=1; i<=k-1; i++){\n\t\tfor(int j=0; j<=i; j++){\n\t\t\tif(j-2<0) dp[j]=s[i-1];\n\t\t\telse dp[j]=(s[i-1]-s[j-2]+MOD)%MOD;\n\t\t}\n\t\ts[0]=dp[0];\n\t\tfor(int j=1; j<=i; j++) s[j]=(s[j-1]+dp[j])%MOD;\n\t}\n\tif(n==k){\n\t\tcout<<dp[0]<<endl;\n\t\treturn 0;\n\t}\n\tll ans=0;\n\tfor(int x=n-k+1; x<=n; x++){\n\t\tif(x==n-k+1){\n\t\t\tans+=dp[0]*p2[n-k-1];\n\t\t\tans%=MOD;\n\t\t\tcontinue;\n\t\t}\n\t\tans+=dp[x-1-n+k]*comb[x-2][n-k-1]%MOD*p2[n-k-1]%MOD;\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define N 2010\n#define mo 1000000007\n#define ll long long\nusing namespace std;\nint n,K,f[N][N][2],ans;\nint mi(int x)\n{\n\tll a=1;\n\tfo(i,1,x) a=a*2%mo;\n\treturn a;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tf[n+1][0][1]=1;\n\tfd(i,n+1,2)\n\t{\n\t\tfd(j,n,0) (f[i][j][0]+=f[i][j+1][0])%=mo;\n\t\tfo(j,0,n)\n\t\t{\n\t\t\tfo(k,0,1)\n\t\t\t{\n\t\t\t\t(f[i-1][j+1][1]+=f[i][j][k])%=mo;\n\t\t\t\t(f[i-1][j][0]+=f[i][j][k])%=mo;\n\t\t\t}\n\t\t}\n\t}\n\tans=(ll)f[1][n-K][0]*mi(n-K-1)%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr long long LINF=334ll<<53; constexpr int INF=15<<26; constexpr long long MOD=1E9+7;\n\nlong long modpow(long long a, long long n,long long mod=MOD){\n    long long i=1,ret=1,p=a;\n    while(i<=n){\n        if(i&n) ret=(ret*p)%mod;\n        i=(i<<1);\n        p=(p*p)%mod;\n    }\n    return ret;\n}\nvector<long long> fac(3030),two(3030),inv(3030);\n\nLL modcomb(LL a, LL b){\n    if(a==0 and b==-1){\n        return 1;\n    }else if(a<b){\n        return 0;\n    }else{\n        return (fac[a]*inv[b]%MOD)*inv[a-b]%MOD;\n    }\n}\nLL pow2(LL a){\n    if(a==-1)return 1;\n    else return two[a];\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    int n,k;\n    cin >> n >> k;\n    fac[0]=1;\n    two[0]=1;\n    const int lim=3030;\n    for(int i=1; i<lim; ++i){\n        fac[i]=fac[i-1]*i%MOD;\n        two[i]=two[i-1]*2%MOD;\n    }\n    inv[lim-1]=modpow(fac[lim-1],MOD-2);\n    for(int i=lim-2; i>=0; --i){\n        inv[i]=inv[i+1]*(i+1)%MOD;\n    }\n\n    vector<vector<LL>> dp (2020,vector<LL>(2020));\n    for(int i=1; i<k; ++i){\n        dp[k-1][i]=1;\n    }\n    for(int i=k-2; i>=1; --i){\n        dp[i][1]=(dp[i+1][1]+dp[i+1][2])%MOD;\n        for(int j=2; j<=i; ++j){\n            //dp[i][j]=sum(dp[i+1][1]~dp[i+1][j+1])\n            dp[i][j]=(dp[i][j-1]+dp[i+1][j+1])%MOD;\n        }\n    }\n    dp[0][0]=dp[1][1];\n    LL ans=0;\n    if(k==1){\n        cout << pow2(n-2)<<\"\\n\";\n        return 0;\n    }\n    for(int m=n; m>=n-k+1; --m){\n        DBG(m,ans)\n        ans=(ans+(modcomb(m-2,n-k-1)*pow2(n-k-1)%MOD)*dp[m-(n-k+1)][m-(n-k+1)])%MOD;\n    }\n    cout << ans <<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\nll dp[N];\n\nll uni[N];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    if (n != k) return 1;\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        uni[i] = dp[i - 1];\n        for (int last = 1; last <= i; last++)\n        {\n            dp[i] = (dp[i] + dp[i - last] * uni[last]) % MOD;\n        }\n        //cout << i << \": \" << \" \" << uni[i] << \" \" << dp[i] << endl;\n    }\n    cout << dp[n - 1];\n    return 0;\n    ll ans = 0;\n    vector<int> p;\n    for (int i = 0; i < n; i++) p.push_back(i + 1);\n    int cnt = 0;\n    while (1)\n    {\n        int t = (p[0] == 1);\n        for (int i = 1; i < n; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                for (int k = j + 1; k < n; k++)\n                {\n                    if (p[i] > p[j] && p[j] > p[k]) t = 0;\n                }\n            }\n        }\n        int w = 0;\n        for (int i = 1; i < n; i++)\n        {\n            int t = 1;\n            for (int j = i; j < n; j++)\n            {\n                if (p[j] <= i) t = 0;\n            }\n            if (t) w = i;\n        }\n        if (w == 1 && t == 1)\n        {\n            for (auto e : p) cout << e;\n            cout << endl;\n            cnt++;\n        }\n        if (t) ans++;\n        if (!next_permutation(all(p))) break;\n    }\n    cout << cnt << \"\\n\";\n    cout << ans << \"\\n\";\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#define LL long long\n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define fd(i,j,k) for(int i=j;i>=k;i--)\n#define fr(i,j) for(int i=beg[j];i;i=nex[i])\nusing namespace std;\nint const mn=2e3+3,mo=1e9+7;\nint n,K,f[mn][mn][2];\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tf[n+1][0][1]=1;\n\tfd(i,n+1,2){\n\t\tfd(j,n+1-i,0)f[i][j][0]=(f[i][j][0]+f[i][j+1][0])%mo;\n\t\tfo(j,0,n+1-i)fo(k,0,1){\n\t\t\tf[i-1][j+1][1]=(f[i-1][j+1][1]+f[i][j][k])%mo;\n\t\t\tf[i-1][j][0]=(f[i-1][j][0]+f[i][j][k])%mo;\n\t\t}\n\t}\n\tint ans=f[1][n-K][0];\n\tfo(i,1,n-K-1)ans=2*ans%mo;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint mod_pow(int n, int k) {\n    int res = 1;\n    for(; k>0; k>>=1) {\n        if(k & 1) (res *= n) %= MOD;\n        (n *= n) %= MOD;\n    }\n    return res;\n}\n\nint comb[2010][2010];\nint dp[2010][2010], dp2[2010][2010];\n\nsigned main() {\n    int N, K; scanf(\"%lld%lld\", &N, &K);\n    for(int i=0; i<=N; i++) {\n        comb[i][0] = 1;\n        for(int j=1; j<=i; j++) {\n            comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n        }\n    }\n\n    dp[0][0] = 1;\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<=i; j++) {\n            // fprintf(stderr, \"dp[%lld][%lld] = %lld\\n\", i, j, dp[i][j]);\n            \n            // 使わない\n            (dp[i+1][j] += dp[i][j]) %= MOD;\n\n            // 使う\n            (dp[i+1][j+1] += dp[i][j] * (j+1)) %= MOD;\n        }\n    }\n\n    int M = N - K;\n    dp2[0][M] = 1;\n    for(int len=M; len>=1; len--) {\n        int used = M - len;\n        for(int l=0; l<M-len+1; l++) {\n            int r = l + len;\n            // fprintf(stderr, \"dp2[%lld][%lld] = %lld\\n\", l, r, dp2[l][r]);\n            (dp2[l+1][r] += dp2[l][r]) %= MOD;\n            (dp2[l][r-1] += dp2[l][r]) %= MOD;\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<M; i++) {\n        (ans += dp2[i][i+1]) %= MOD;\n    }\n    // fprintf(stderr, \"ans = %lld\\n\", ans);\n    /*\n    for(int i=1; i<=N; i++) {\n        fprintf(stderr, \"i = %lld, comb = %lld, rec = %lld\\n\", i, comb[N-1][i-1], rec[i]);\n        (ans += comb[N-1][i-1] * rec[i]) %= MOD;\n    }\n    */\n    (ans *= dp[N-1][K-1]) %= MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define F(i,l,r)for(int i=l;i<=r;i++)\nint m=1e9+7,n,k,d[2333][2333];main(){std::cin>>n>>k;d[1][1]=1;F(i,2,n)F(j,1,i)d[i][j]=(d[i][j-1]+d[i-1][j])%m;F(i,1,n-k-1)(d[n][k]*=2)%=m;std::cout<<d[n][k];}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2000 +10;\nconst long long mod = (long long)1000000007;\nint read(){\n\tint x=0,flag=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*flag;\n}\nint n,k;\nlong long f[maxn][maxn],g[maxn][maxn];\nlong long Pow(long long x,int t){\n\tif( t< 0 )return 1LL;\n\tlong long ans = 1LL;\n\twhile(t){\n\t\tif(t&1)ans=ans*x%mod;\n\t\tx=x*x%mod;t>>=1;\n\t}\n\treturn ans%mod;\n}\nlong long Add(long long x,long long y){\n\tif( x + y >= mod) return x + y - mod;\n\treturn x +y;\n}\nint main(){\n\tn=read();k=read();\t\n\twhile(n==k);\n\tf[1][n-k]=Pow(2LL,n-k-1);\n\n\tg[1][0]=0;\n\tfor(int j=1;j<=n;j++)g[1][j] = Add( g[1][j-1] , f[1][j] );\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=0;n-i>=j;j++){\n\t\t\tf[i][j] = Add( f[i-1][j+1] , g[i-1][j] ) ;\n\t\t\tg[i][j] = Add( g[i][j-1] , f[i][j] );\n\t\t}\n\t}\n\tcout << f[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\ntypedef long long ll;\nconst int N=2010;\nconst int P=1e9+7;\nint n,K;\nint f[N][N],g[N][N];\ninline ll Pow(ll x,int y) {ll ret=1; for(;y;y>>=1,x=x*x%P) if(y&1) ret=ret*x%P; return ret;}\ninline int Add(int x,int y) {x+=y; if(x>=P) x-=P; return x;}\nint main() {\n  scanf(\"%d %d\",&n,&K);\n  f[0][0]=1;\n  for(int i=2;i<=n;i++) f[1][i]=1;\n  for(int i=n;i>=2;i--) g[1][i]=g[1][i+1]+1; \n  for(int i=2;i<K;i++) {\n    for(int j=n-i+1;j>=2;j--) {\n      f[i][j]=g[i-1][j];\n    }\n    for(int j=n-i+1;j>=2;j--) {\n      g[i][j]=Add(g[i][j+1],f[i][j]);\n    }\n  }\n  ll ans=0;\n  for(int i=2;i<=n-K+2;i++) ans=Add(ans,f[K-1][i]);\n  ans=ans*Pow(2,n-K-1)%P;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    int mod = 1000000007;\n\n    if(K == 1){\n        if(N == 1) cout << 1 << endl;\n        else cout << modpow(2, N - 2, mod) << endl;\n        return 0;\n    }\n\n    mat dp(K - 1, vec(N, 0));\n    FOR(j, 1, N) dp[0][j] = 1;\n    REP(i, K - 2){\n        //上から取る\n        FOR(j, 1, N){\n            if(j >= N - 1 - i) continue;\n            dp[i + 1][j] += dp[i][j];\n            dp[i + 1][j] %= mod;\n        }\n        //下から取る\n        FOR(j, 1, N){\n            dp[i][j] += dp[i][j - 1];\n            dp[i][j] %= mod;\n        }\n        FOR(j, 1, N){\n            if(j >= N - 1 - i) continue;\n            dp[i + 1][j] += dp[i][j + 1];\n            dp[i + 1][j] %= mod;\n        }\n    }\n    int ans = 0;\n    FOR(j, 1, N){\n        ans += dp[K - 2][j];\n        ans %= mod;\n    }\n    if(K < N){\n        ans *= modpow(2, N - K - 1, mod);\n        ans %= mod;\n    }\n    //debug(dp);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        //\n        friend bool operator<(const mint& lhs, const mint& rhs) {\n            return lhs._v < rhs._v;\n        }\n        //\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        //\n        friend bool operator<(const mint& lhs, const mint& rhs) {\n            return lhs._v < rhs._v;\n        }\n        //\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=1000000007,MAX=2005;\nconst ll INF=1LL<<50;\n\nusing mint=atcoder::modint1000000007;\n\nmint inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=-inv[mod%i]*(mod/i);\n        fac[i]=fac[i-1]*i;\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\n\nmint comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*finv[b]*finv[a-b];\n}\n\nmint perm(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*finv[a-b];\n}\n\nmint dp[MAX][MAX],S[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    int N,K;cin>>N>>K;\n    if(K==N) K--;\n    mint ans=0;\n    \n    dp[0][0]=1;\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            dp[i+1][j+1]+=dp[i][j];\n        }\n        for(int j=1;j<=N;j++){\n            dp[i+1][j]+=S[i][i]-S[i][j-1];\n        }\n        for(int j=1;j<=N;j++) S[i+1][j]=S[i+1][j-1]+dp[i+1][j];\n    }\n    \n    for(int Y=N-K+1;Y<=N;Y++){\n        int gomi=(Y-1)-(N-K);\n        \n        mint sum=0;\n        for(int j=0;j<=N-Y;j++){\n            sum+=comb(j+gomi,gomi)*dp[N-Y][j];\n        }\n        ans+=sum*comb(Y-2,N-K-1);\n    }\n    \n    ans*=mint(2).pow(N-K-1);\n    \n    cout<<ans.val()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=2005,mo=1e9+7;\n\ntypedef long long LL;\n\nint n,m,f[N][N][2],s[N],ans;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tf[n+1][0][1]=1;\n\tfor (int i=n;i;i--)\n\t{\n\t\tfor (int j=n-i;j>=0;j--) s[j]=(s[j+1]+f[i+1][j][0])%mo;\n\t\tfor (int j=0;j<=n-i+1;j++)\n\t\t{\n\t\t\tf[i][j][1]=(j>0)?(f[i+1][j-1][1]+s[j-1])%mo:0;\n\t\t\tf[i][j][0]=(s[j]+f[i+1][j][1])%mo;\n\t\t}\n\t}\n\tans=f[1][n-m][0];\n\tfor (int i=1;i<n-m;i++) ans=ans*2%mo;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\n \ntypedef long long LL;\nconst int N = 2005;\nconst LL mod = 1000000007LL;\n \nLL dp[N][N], C[N][N], pref[N];\n \ninline LL pow(LL x, LL exp) {\n  if (exp < 0) return 1;\n  LL res = 1;\n  for (; exp; exp >>= 1, x = x * x % mod)\n    if (exp & 1) res = res * x % mod;\n  return res;\n}\n \ninline void pre() {\n  for (int i = 0; i < N; i ++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j ++) {\n      C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n      if (C[i][j] >= mod) C[i][j] -= mod;\n    }\n  }\n}\n \ninline LL DP(int n) {\n  pref[0] = 1;\n  for (int i = 2; i <= n; i ++) {\n    for (int j = 1; j < i; j ++) {\n      pref[j] = pref[j - 1] + dp[i - 1][j];\n      if (pref[j] >= mod) pref[j] -= mod;\n      dp[i][j] = pref[j];\n    }\n  }\n  LL ans = 1;\n  for (int i = 1; i <= n; i ++) {\n    ans += dp[n][i];\n    if (ans >= mod) ans -= mod;\n  }\n  return ans;\n}\n \nint main() {\n  int n, k;\n  pre();\n  scanf(\"%d%d\", &n, &k);\n  if (k == 1) return printf(\"%lld\\n\", pow(2LL, n - 2)), 0;\n  if (k == 2) {\n    LL ans = pow(2LL, n - k - 1) * (n - 1) % mod;\n    return printf(\"%lld\\n\", ans), 0;\n  }\n  LL ans = DP(k - 1);\n  ans = ans * C[n - 1][k - 1] % mod * pow(2LL, n - k - 1) % mod;\n  printf(\"%lld\\n\", ans);\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#define ll long long\n#define MOD 1000000007\nusing namespace std;\ninline ll read(){\n\tll re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nll dp[2010][2010],p[2010],sum[2010][2010];\nint main(){\n\tll n=read(),k=read();ll i,j;\n\tp[0]=1;\n\tfor(i=1;i<=n;i++) p[i]=p[i-1]*2%MOD;\n\tfor(i=2;i<=n;i++) dp[1][i]=1,sum[1][i]=n-i+1; \n\tfor(i=2;i<k;i++){\n\t\tfor(j=n-i+1;j>=2;j--){\n\t\t\tdp[i][j]=(dp[i-1][j]+sum[i-1][j+1])%MOD;\n\t\t}\n\t\tfor(j=n-i+1;j>=2;j--) sum[i][j]=(sum[i][j+1]+dp[i][j])%MOD;\n\t}\n\tll ans=0;\n\tfor(i=2;i<=n-k+2;i++) ans+=dp[k-1][i],ans%=MOD;\n\tif(k==1) ans=1;\n\tif(k==n) printf(\"%lld\\n\",ans);\n\telse printf(\"%lld\\n\",ans*p[n-k-1]%MOD);\n//\tcout<<n<<' '<<k<<' '<<ans<<' '<<n-k-1<<' '<<p[n-k-1]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C ;\n// const ll M = 1000000007;\n\nconst int MAX_SIZE = 1000010;\nconst long long MOD = 1000000007;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init() {\n  inv[1] = 1;\n  for (int i=2; i<MAX_SIZE; i++) {\n    inv[i] = ((MOD - inv[MOD%i]) * (MOD/i))%MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i=1; i<MAX_SIZE; i++) {\n    fact[i] = (i * fact[i-1])%MOD;\n    factinv[i] = (inv[i] * factinv[i-1])%MOD;\n  }\n}\n\nlong long C(int n, int k) {\n  if (n >=0 && k >= 0 && n-k >= 0) {\n    return ((fact[n] * factinv[k])%MOD * factinv[n-k])%MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n) {\n  if (n == 0) {\n    return 1;\n  } else if (n%2 == 1) {\n    return (x * power(x, n-1)) % MOD;\n  } else {\n    long long half = power(x, n/2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcm(long long a, long long b) {\n  if (a < b) {\n    return gcm(b, a);\n  }\n  if (b == 0) return a;\n  return gcm(b, a%b);\n}\n\nll calc(ll K) {\n  if (K == 0) return 1;\n  ll ans = 0;\n  for (auto y = 1; y <= K; y++) {\n    ans += C(K-1, y-1);\n    ans %= MOD;\n  }\n  return ans;\n}\n\nll calc2(ll K, ll N) {\n  if (N == 1) return 1;\n  ll ans = 0;\n  for (auto k = 0; k <= K-1; k++) {\n    ans += C(N-1-k-1, K-1-k);\n    ans %= MOD;\n  }\n  return ans;\n}\n\nint main() {\n  init();\n  ll N, K;\n  cin >> N >> K;\n  ll ans = calc2(K, N);\n  ans *= calc(K-1);\n  ans %= MOD;\n  ans *= calc(N-K);\n  ans %= MOD;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\nint M(int x) { return x >= mod ? x - mod : x; }\nint n, k, res;\nint fsp(long long bs, int p) {\n    if (p <= 0) return 1;\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = bs * rt % mod;\n        bs = bs * bs % mod, p >>= 1;\n    }\n    return rt;\n}\n\nint f[2003];\nint main() {\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) return printf(\"%d\\n\", fsp(2, n - k - 1)), 0;\n    for (int i = 1; i < n; ++i) f[i] = 1;\n    for (int i = 2; i < k; ++i)\n        for (int j = i; j < n; ++j) f[j] = M(f[j - 1] + f[j]);\n\n    for (int j = k - 1; j < n; ++j) res = M(res + f[j]);\n    printf(\"%d\\n\", 1ll * res * fsp(2, n - k - 1) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int Mod=1e9+7,N=2005;\nint f[N][N],n,k;\nint main (){\n\tscanf (\"%d%d\",&n,&k);\n    for (int i=2;i<=n;i++) f[1][i]=1;\n    for (int i=1;i<k-1;i++){\n        int sum=f[i][n-i+1];\n        for(int j=n-i;j>=2;j--){\n            sum=(sum+f[i][j])%Mod;\n            f[i+1][j]=(f[i+1][j]+sum)%Mod;\n        }\n    }\n    int ans=0;\n    for (int j=2;j<=n-k+2;j++) ans=(ans+f[k-1][j])%Mod;\n    if (k==1) ans=1;\n    for (int i=1;i<=n-1-k;i++) ans=ans*2%Mod;\n    printf (\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\n\nint main() {\n\tll N, K;\n\tcin >> N >> K;\n\n\tvvmint dp(N + 1, vmint(N + 1, 0)), rdp(N + 1, vmint(N + 1, 0));\n\tdp[0][0] = 1;\n\trep(j, N + 1)rdp[0][j] = 1;\n\n\trepn(i, N)for (ll j = i; j <= N; j++) {\n\t\tdp[i][j] = rdp[i - 1][j];\n\t\trdp[i][j] = rdp[i][j - 1] + dp[i][j];\n\t}\n\n\tmint ans = rdp[K - 1][N - 1];\n\tif (N > K)ans *= pw(2, N - K - 1);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 29.12.2019 21:06:20       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<vector<Mint>> C(n + 1, vector<Mint>(n + 1));\n  for (int i = 0; i <= n; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++) C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n  }\n  vector<vector<Mint>> dp(n + 1, vector<Mint>(n + 1));\n  dp[1][1] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int j = 1; j <= i; j++) {\n      dp[i + 1][j + 1] += dp[i][j];\n    }\n    Mint sum = 0;\n    for (int k = i; k >= 1; k--) {\n      sum += dp[i][k];\n      dp[i + 1][k] += sum;\n    }\n/*      for (int k = 0; k <= i; k++) {\n        if (k > j) {\n          continue;\n        }\n        if (k == 0) {\n        } else {\n          dp[i + 1][k] += dp[i][j];\n        }\n      }*/\n//    }\n  }\n  Mint ans = 0;\n/*  for (int j = 0; j <= n; j++) {\n    ans += dp[k - 1][j];\n  }\n  if (k == 1) ans += 1;\n  ans *= C[n - 1][k - 1] * (k == n ? 1 : power(Mint(2), n - k - 1));*/\n  for (int j = 1; j <= k - 1; j++) {\n    Mint cur = dp[k - 1][j];\n    cur *= C[j + (n - k)][n - k];\n    cur *= (k == n ? 1 : power(Mint(2), n - k - 1));\n//    debug(j, cur);\n    ans += cur;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e3+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,k;\nvoid input()\n{\n\tn=read<int>(),k=read<int>();\n}\nconst int mo=1e9+7;\nvoid add(int &x,int y)\n{\n\tx+=y;x-=(x>=mo?mo:0);\n}\nint dp[N][N][2];\nvoid work()\n{\n\tdp[n+1][0][0]=1;\n\tFordown(i,n+1,2)\n\t{\n\t\tFordown(j,n,0)add(dp[i][j][0],dp[i][j+1][0]);\n\t\tFor(j,0,n)For(o,0,1)\n\t\t{\n\t\t\tadd(dp[i-1][j+1][1],dp[i][j][o]);\n\t\t\tadd(dp[i-1][j][0],dp[i][j][o]);\n\t\t}\n\t}\n\tint ans=dp[1][n-k][0];\n\tFor(i,1,n-k-1)ans=(ans*2)%mo;\n\twrite(ans,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2010\n#define ll long long\n#define For(i,x,y) for(int i=(x);i<=(y);++i)\n#define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n#define Edge(x) for(int i=head[x];i;i=e[i].nxt)\n#define mset(x,y) memset(x,y,sizeof(x))\n#define strL strlen\n#define p_b push_back\n#define mcpy(x,y) memcpy(x,y,sizeof(x))\n#define lson l,mid,(o<<1)\n#define rson mid+1,r,((o<<1)|1)\n#define Ls (t[o].ls)\n#define Rs (t[o].rs)\n#define mod 1000000007\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\nusing namespace std;\nint _2[N],f[N][N],sub[N][N];\nvoid init(int n){_2[0]=1;For(i,1,n) _2[i]=(_2[i-1]+_2[i-1])%mod;}\nint main(){\n\tint n,k,ans=0;\n\tscanf(\"%d%d\",&n,&k);\n\tinit(n);\n\tFor(i,2,n+1) sub[0][i]=1;\n\tFor(i,1,k-1) Rof(j,n-i+1,2){\n\t\tif(j<=n-i+1) (f[i][j]+=sub[i-1][j])%=mod;\n\t\tsub[i][j]=(sub[i][j+1]+f[i][j])%mod;\n\t}\n\tFor(i,2,n-k+2) (ans+=1ll*f[k-1][i])%=mod;\n\tif(k==1) ans=1;\n\tif(k!=n) ans=1ll*ans*_2[n-k-1]%mod;\n\tprintf(\"%d\\n\",ans); \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\n#define mod 1000000007\nint n,k,ans,f[2005][2005],sum[2005];\n\nint main(){\n    scanf(\"%d%d\",&n,&k);\n\tf[0][n+1]=1;\n    for(int i=1;i<=k;i++)\n\t\tfor(int j=n+1;j>=1;j--){\n\t\t\tsum[j]=(sum[j+1]+f[i-1][j])%mod;\n\t\t\tf[i][j]=(j<=n-i+1?sum[j]:0);\n\t\t}\n    ans=(f[k][1]-f[k-1][1]+mod)%mod;\n    for(int i=1;i<=n-k-1;i++)ans=(ans+ans)%mod;\n    printf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint n, k;\nint dp[maxn];\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> k;\n\tdp[n + 1] = 1;\n\tfor(int i = 1;i < k;++i) {\n\t\tfor(int j = n - i + 1;j >= 2;--j) {\n\t\t\tdp[j] += dp[j + 1] - mod, dp[j] += dp[j] >> 31 & mod;\n\t\t}\n\t}\n\tll s = 0;\n\trep(i, 2, n - k + 2) s += dp[i];\n\tif(k == 1) {\n\t\ts = 1;\n\t}\n\tcout << s % mod * pow(2, std::max(0, n - k - 1)) % mod << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2e3+10;\nint n,m,dp[maxn][maxn];\nint Pow(int a,long long k)\n{\n\tint ret=1;\n\twhile(k)\n\t{\n\t\tif(k&1)ret=ret*1LL*a%mod;\n\t\tk>>=1,a=a*1LL*a%mod;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint sum=dp[i-1][n+1];\n\t\tfor(int j=n;j>=n-i+2;j--)sum+=dp[i-1][j],sum%=mod;\n\t\tfor(int j=n-i+1;j>=1;j--)sum+=dp[i-1][j],sum%=mod,dp[i][j]=sum;\n\t}\n\tint ret=(dp[m][1]-dp[m-1][1]+mod)%mod;\n\tprintf(\"%lld\\n\",ret*1LL*Pow(2,n-m-1)%mod);\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\nint K,n;\n\nlint C[2005][2005];\nconst int mod=1000000007;\n\nint dp[2005][2005];\nvoid chadd(int& a,int b){\n  a+=b;\n  if(a>=mod) a-=mod;\n}\n\nint brute(int m){\n  int perm[15];\n  REP(i,m) perm[i]=i;\n  int cnt=0;\n  do{\n    bool ok=false;\n    REP(i,1<<m){\n      bool fail=false;\n      int pv=-1;\n      REP(j,m) if(i>>j&1){\n        if(pv>perm[j]) fail=true;\n        pv=perm[j];\n      }\n      pv=-1;\n      REP(j,m) if(!(i>>j&1)){\n        if(pv>perm[j]) fail=true;\n        pv=perm[j];\n      }\n      if(!fail) ok=true;\n    }\n    if(ok) ++cnt;\n  }while(next_permutation(perm,perm+m));\n  return cnt;\n}\n\nint sum[2005][2005];\nint main(){\n  REP(i,2005){\n    C[i][0]=1;\n    REP(j,i) C[i][j+1]=(C[i-1][j+1]+C[i-1][j])%mod;\n  }\n\n  cin>>n>>K;\n  --K;\n  dp[K][0]=1;\n  for(int i=K;i>=0;--i) REP(j,K+1){\n    chadd(dp[i][j],sum[i+1][j+1]);\n    chadd(dp[i][j],dp[i+1][j]);\n    sum[i][j]=dp[i][j];\n    if(j) chadd(dp[i][j],dp[i][j-1]);\n  }\n  lint res=0;\n  int rest=n-1-K;\n  for(int i=rest;i<n;++i){\n    int cons=i-rest;\n    lint tmp=C[i-1][rest-1]*dp[cons][cons]%mod;\n    res+=tmp;\n  }\n  res%=mod;\n  REP(hoge,rest-1) res=res*2%mod;\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=2005;\nconst int mod=1e9+7;\nint n,m;\nint dp[maxn];\n\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tdp[n+1]=1;\n\tfor(int i=1;i<m;i++){\n\t\tint sum=dp[n-i+2];\n\t\tfor(int j=n-i+1;j>=2;j--){\n\t\t\tAdd(sum,dp[j]);\n\t\t\tdp[j]=sum;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int j=2;j<=n-m+2;j++)Add(ans,dp[j]);\n\tfor(int i=m+1;i<=n-1;i++)ans=2LL*ans%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc() {\n    // return getchar();\n    static char buf[100000], *l = buf, *r = buf;\n    return l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x) {\n    x = 0; int f = 1, ch = nc();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n    while(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n    x *= f;\n}\ntypedef long long LL;\nconst int mod = 1e9 + 7;\nconst int maxn = 2000 + 50;\nint n, k;\nint f[maxn][maxn][2];\ninline int add(int x) {return x >= mod ? x - mod : x;}\nLL power(LL x, LL y) {\n    LL re = 1;\n    while(y) {\n        if(y & 1) re = re * x % mod;\n        x = x * x % mod;\n        y >>= 1;\n    }\n    return re;\n}\nint solve() {\n    f[n][0][0] = f[n][1][1] = 1;\n    for(int i = n; i >= 1; --i) {\n        for(int j = n; j >= 1; --j) {\n            f[i][j][0] = add(f[i][j][0] + f[i][j + 1][0]);\n            for(int t = 0; t < 2; ++t) {\n                f[i - 1][j][0] = add(f[i - 1][j][0] + f[i][j][t]);\n                f[i - 1][j + 1][1] = add(f[i - 1][j + 1][1] + f[i][j][t]);\n            }\n        }\n    }\n    return f[1][n - k][0] * power(2, max(n - k - 1, 0)) % mod;\n}\nint main() {\n    read(n), read(k);\n    printf(\"%d\\n\", solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nconst int N=4005,mo=1e9+7;\nint n,k,i,fact[N],inv[N],fv[N];\nvoid init(){\n\tfact[1]=fact[0]=inv[1]=fv[0]=fv[1]=1;\n\tfor (i=2;i<=n+k;i++){\n\t\tfact[i]=(ll)fact[i-1]*i%mo;\n\t\tinv[i]=(ll)inv[mo%i]*(mo-mo/i)%mo;\n\t\tfv[i]=(ll)fv[i-1]*inv[i]%mo;\n\t}\n}\nint C(int n,int m){\n\treturn (ll)fact[n]*fv[m]%mo*fv[n-m]%mo;\n}\nint cal(int n,int m){return m>=0?C(n+m,n):0;}\nint main(){\n\tscanf(\"%d%d\",&n,&k);init();\n\tif (n==1&&k==1){puts(\"1\");return 0;}\n\tint ans=(cal(n-2,k-1)-cal(n,k-3)+mo)%mo;\n\tfor (i=n-k-1;i;i--) ans=2ll*ans%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n    if (k&1)\n        sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;i<=n;i++) g[0][i]=1;\n    for (int i=1;i<k;i++)\n        for (int j=1;j<=n-i;j++)\n\t    g[i][j]=(g[i-1][j+1]+g[i][j-1])%mod;\n    printf(\"%lld\\n\",1ll*g[k-1][n-k+1]*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,k,f[10001],P=1000000007ll;\nlong long qpow(long long a,int x){\n    if(x<0)return 1;\n    long long s=1ll;\n    while(x){\n\t\tif(x&1)s=(s*a)%P;\n\t\ta=(a*a)%P;\n\t\tx=x/2;\n\t}\n    return s;\n}\nint main(){\n    cin>>n>>k;\n    f[0]=1ll;\n    for(int i=1;i<n;++i){\n\t\tfor(int j=i;j;--j)\n\t\t\tf[j]=(f[j+1]+f[j-1])%P;\n\t\t\tf[0]=f[1];\n\t\t}\n    cout<<f[n-k]*qpow(2ll,n-k-1)%P<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 2200\n#define mod 1000000007\nusing namespace std;\nint f[N][N],s[N],n,k,ans;//设f[i][j]表示已经选取了1~i个位置 最小的那个数是j的方案数 \nint main(){\n    //freopen(\"arc.in\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&k);f[0][n+1]=1;s[n+1]=1;\n    for (int i=n;i>=1;--i) s[i]=s[i+1]+f[0][i];\n    for (int i=1;i<=k-1;++i){\n        for (int j=1;j<=n-i+1;++j) f[i][j]=s[j];\n        s[n+1]=f[i][n+1];for (int j=n;j>=1;--j) s[j]=(s[j+1]+f[i][j])%mod;\n    }for (int i=2;i<=n+1;++i) (ans+=f[k-1][i])%=mod;\n    for (int i=1;i<=n-k-1;++i) (ans*=2)%=mod;printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2020;\nconst int mod = 1e9 + 7;\n\nLL f[N][N][2], s[N];\n\nLL qpow(LL a, LL b)\n{\n\tLL ret = 1, base = a;\n\twhile (b) {\n\t\tif (b & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, b >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tf[n + 1][0][0] = 1;\n\tfor (int i = n + 1; i >= 2; i --) {\n\t\tfor (int j = n - i + 1; j >= 0; j --) s[j] = s[j + 1], upd(s[j], f[i][j][0]);\n\t\t\n\t\tfor (int j = n - i + 1; j >= 0; j --) {\n\n\t\t\tupd(f[i - 1][j + 1][1], s[j] + f[i][j][1]);\n\t\t\tupd(f[i - 1][j][0], s[j] + f[i][j][1]);\n\t\t}\n\t}\n\t\n\tif (n == k) printf(\"%lld\\n\", f[1][n - k][0]);\n\telse printf(\"%lld\\n\", f[1][n - k][0] * qpow(2, n - k - 1) % mod);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = 1e9+7;\n\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nint pow2[2111];\nint dp[2111][2111];\nint sum[2111][2111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tpow2[0]=1; for(int i=1;i<=2011;i++){pow2[i]=add(pow2[i-1],pow2[i-1]);}\n\tint n,k; cin>>n>>k;\n\tif(n==1)\n\t{\n\t\tcout<<1<<'\\n';\n\t\treturn 0;\n\t}\n\tint coeff=(k<n?pow2[n-k-1]:1);\n\tfor(int i=1;i<=n-1;i++) dp[0][i]=1;\n\tfor(int i=1;i<k;i++)\n\t{\n\t\tfor(int j=n-i-1;j>=(i==n-1?0:1);j--)\n\t\t{\n\t\t\tif(j==n-i-1) dp[i][j]=dp[i-1][j+1];\n\t\t\telse dp[i][j]=dp[i][j+1];\n\t\t\tdp[i][j]=add(dp[i][j],dp[i-1][j]);\n\t\t}\n\t}\n\tint ans=dp[k-1][(k==n?0:1)];\n\tans=mult(ans,coeff);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f(a, n) for (int a=0; a<n; a++)\n#define F(a, n) for (int a=1; a<=n; a++)\n#define ll long long\nusing namespace std;\nconst ll MOD = 1000000007;\nunordered_map<ll, ll> gmp;\nll pairit(ll a, ll b){\n\treturn (a<<32) + b;\t\n}\nll g(ll a, ll b){\n\tif (a==0) return 0;\n\tif (a==1) return 1;\n\tll tmp=pairit(a,b);\n\tif (gmp.count(tmp)) return gmp[tmp];\t\n\tif (b==0) gmp[tmp] = (g(a-1, 0) + g(a-1, 1) ) %MOD;\n\telse gmp[tmp] = (g(a, b-1) + g(a-1, b+1)) % MOD;\n\treturn gmp[tmp];\n}\nll powa(ll a, ll b){\n\tif (b<0) return 1;\n\telse if (b%2) return (powa((a*a)%MOD,b/2) * a) % MOD;\n\treturn powa((a*a)%MOD,b/2);\n}\nll N, K;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>N>>K;\n\tcout<<( (g(K, N-K) - g(K-1, N-K+1) + MOD)* powa(2, N-K-1) ) % MOD << endl; \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=4000+10;\nconst int mod=1e9+7;\n\ninline int qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\nint fac[N],ifac[N];\ninline void init(int n) {\n    fac[0]=1;\n    for (re int i=1;i<=n;++i) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=qpow(fac[n],mod-2);\n    for (re int i=n;i;--i) ifac[i-1]=1ll*ifac[i]*i%mod;\n}\ninline int C(int n,int m) { return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod; }\n\nint main() { int n=read(),k=read(); init(n+k);\n    printf(\"%lld\\n\",1ll*(C(n+k-2,k-1)-C(n+k-2,k-2)+mod)*qpow(2,max(0,n-k-1))%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;i<=n;i++) g[0][i]=1;\n    for (int i=1;i<k;i++)\n\t    for (int j=n-i+1;j>1;j--)\n\t        g[i][j]=(g[i-1][j]+g[i][j+1])%mod;\n    int ans=0;\n    for (int i=2;i<=n-k+2;i++) ans=(ans+f[k-1][i])%mod;\n    printf(\"%lld\\n\",1ll*g[k-1][2]*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t2005\n#define P\t1000000007\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint dp[MAXN][MAXN], sum[MAXN][MAXN];\nint main() {\n\tint n, k;\n\tread(n), read(k);\n\tdp[1][n - k] = 1;\n\tfor (int i = 1; i <= n - k - 1; i++)\n\t\tdp[1][n - k] = dp[1][n - k] * 2 % P;\n\tsum[1][0] = dp[1][0];\n\tfor (int i = 1; i <= n; i++)\n\t\tsum[1][i] = (sum[1][i - 1] + dp[1][i]) % P;\n\tfor (int i = 2; i <= n; i++)\n\tfor (int j = 0; j <= n; j++) {\n\t\tdp[i][j] = sum[i - 1][j + 1];\n\t\tif (j == 0) sum[i][j] = dp[i][j];\n\t\telse sum[i][j] = (sum[i][j - 1] + dp[i][j]) % P;\n\t}\n\tcout << dp[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_N(2050);\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\nconstexpr int Mult(int a, int b)\n{\n\treturn (a * 1LL) * b % MOD;\n}\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\n/*\n队列是一个单谷序列：可以以1为分界点，左边是一个下降序列、右边是一个上升序列\n存在一个分界线，分界线左边的元素都是从队头取出、分界线右边的元素都是从队尾取出。只考虑分界线在1右边的情况，在1左边可以把队列翻转\n设分界线的位置为p，有Q[x <= p] = 1。同时Q[1 ~ p]是一个以1为谷的单谷序列，Q[p + 1 ~ N]是一个上升序列且满足Q[p] < Q[p + 1]\n把数取出得到A的过程，本质就是把Q[p + 1 ~ N]翻转得到一个下降序列后插入到Q[1 ~ p]中的过程。考虑最终得到的序列满足哪些性质\n(1)A[k] = 1。这是题目要求的条件\n(2)A[1 ~ k]可以划分成至多2个下降序列。因为A[1 ~ k]是由Q[1 ~ x]（一个下降序列）插入一个下降序列得到的\n(3)对于所有k + 1 <= i <= N，A[i]要么是后缀最大值，要么是后缀最小值。因为取出1之后Q是一个上升序列，每次取头就是后缀最小值、取尾就是后缀最大值\n(4)如果A[1 ~ k]不是1个下降序列而是被划分成了2个下降序列，那么存在一个下降序列的最小值 > max{A[k + 1], A[k + 2], ..., A[N]}\n   因为该下降序列是Q[N ~ p + 1]的一个前缀，其最小值一定大于Q[N ~ p + 1]剩下的部分和Q[x + 1 ~ p]\n*/\n/*\n首先考虑填入A[1 ~ k]，使得满足条件(1)、(2)和(4)。考虑一个按照N ~ 1的顺序把数填进两个下降子序列的过程\n这里称结尾较大的下降子序列为A序列，结尾较小的下降子序列为B序列。显然大于A序列的结尾的数都被填入，否则一定不满足条件(4) \n设F[i][k][0 / 1]表示填到了i，A序列的结尾到i之间有k个数没有被填入，能否走(3)转移的方案数。这里转移分为(3)种：\n(1)不填i，F[i][k][0 / 1] -> F[i + 1][k + 1][0]\n(2)填i到B序列中，F[i][k][0 / 1] -> F[i + 1][k][1]\n(3)填小于A序列结尾最大的没有被填的数到A序列中。F[i][k][1] -> F[i][k - 1][1]\n最后再填入A[k + 1 ~ N]，考虑从后往前填数，每次填了的数在剩下的数中是一个区间，方案数显然是2^(区间长度 - 1) \n*/\n\nint N, K, power[Max_N], F[Max_N][Max_N][2];\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\tpower[0] = 1;\n\tfor (int i = 1;i <= N;++i)\n\t\tpower[i] = Add(power[i - 1], power[i - 1]);\n\tF[N][0][1] = 1;\n\tfor (int i = N;i >= 1;--i)\n\t\tfor (int k = N;k >= 0;--k)\n\t\t{\n\t\t\tif (F[i][k][0])\n\t\t\t{\n\t\t\t\tupd(F[i - 1][k + 1][0], F[i][k][0]);\n\t\t\t\tupd(F[i - 1][k][1], F[i][k][0]);\n\t\t\t}\n\t\t\tif (F[i][k][1])\n\t\t\t{\n\t\t\t\tupd(F[i - 1][k + 1][0], F[i][k][1]);\n\t\t\t\tupd(F[i - 1][k][1], F[i][k][1]);\n\t\t\t\tif (k >= 1)\n\t\t\t\t\tupd(F[i][k - 1][1], F[i][k][1]);\n\t\t\t}\n\t\t}\n\tprintf(\"%d\", Mult(F[0][N - (K - 1)][0], power[max(0, N - K - 1)]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nconst int N=4005,mo=1e9+7;\nint n,k,i,fact[N],inv[N],fv[N];\nvoid init(){\n\tfact[1]=fact[0]=inv[1]=fv[0]=fv[1]=1;\n\tfor (i=2;i<=n+k;i++){\n\t\tfact[i]=(ll)fact[i-1]*i%mo;\n\t\tinv[i]=(ll)inv[mo%i]*(mo-mo/i)%mo;\n\t\tfv[i]=(ll)fv[i-1]*inv[i]%mo;\n\t}\n}\nint C(int n,int m){\n\treturn (ll)fact[n]*fv[m]%mo*fv[n-m]%mo;\n}\nint cal(int n,int m){return m>=0?C(n+m,n):0;}\nint main(){\n\tscanf(\"%d%d\",&n,&k);init();\n\tif (n==1&&k==1){puts(\"1\");return 0;}\n\tint ans=(cal(n-2,k-1)-cal(n,k-3)+mo)%mo;\n\tfor (i=n-k-1;i>0;i--) ans=2ll*ans%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int P=1000000007;\nconst int N=2005;\n\nint f[N][N][2];\nint n,K,ans;\n\ninline void update(int &x,int y){(x+=y)%=P;}\n\nint main()\n{\n\t//freopen(\"solitaire.in\",\"r\",stdin),freopen(\"solitaire.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&K);\n\tf[n+1][0][0]=1;\n\tfor (int i=n+1;i>=1;--i)\n\t{\n\t\tfor (int j=n-1;j>=0;--j) update(f[i][j][0],f[i][j+1][0]);\n\t\tfor (int j=0;i>1&&j<=n;++j)\n\t\t\tfor (int k=0;k<2;++k)\n\t\t\t\tif (f[i][j][k])\n\t\t\t\t{\n\t\t\t\t\tupdate(f[i-1][j+1][1],f[i][j][k]);\n\t\t\t\t\tupdate(f[i-1][j][0],f[i][j][k]);\n\t\t\t\t}\n\t}\n\tans=f[1][n-K][0];\n\tfor (int i=1;i<=n-K-1;++i) (ans<<=1)%=P;\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n\nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = (ans + f[K-1][i]) % MM;\n\tcout<<((K!=n)?(ans * pw[n-K-1] % MM):ans)<<endl;\n}\n\nvoid printans(){\n\n}\n\n\nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nusing mint = mod_int<>;\n\ntemplate<typename M>\nstruct fenwick_tree {\n    using T = typename M::T;\n    int n;\n    std::vector<T> data;\n    fenwick_tree(int n) : n(n), data(n + 1, M::id()) {}\n    void add(int i, const T &x) { for (i++; i <= n; i += i & -i) { data[i] = M::op(data[i], x); }}\n    T get_sum(int i) const {\n        T ret = M::id();\n        for (; i > 0; i -= i & -i) { ret = M::op(ret, data[i]); }\n        return ret;\n    }\n    T get_sum(int l, int r) const {\n        return M::op(get_sum(r), M::inv(get_sum(l)));\n    }\n};\n\nstruct rsq {\n    using T = mint;\n    static T id() { return 0; }\n    static T op(const T &a, const T &b) { return a + b; }\n    static T inv(const T &a) { return -a; }\n};\n\nsigned main() {\n    int N, K;\n    cin >> N >> K;\n    vector dp(N + 10, fenwick_tree<rsq>(N + 10));\n    dp[0].add(N, 1);\n    reps(i, K - 1) {\n        reps(j, N - i) {\n            dp[i].add(j, dp[i - 1].get_sum(j, N + 1));\n        }\n    }\n    cout << dp[K - 1].get_sum(0, N + 1) * mint(2).pow(N - K - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\nll dp[N];\n\nll uni[N];\n\nll get_by_dp(ll mp, ll n)\n{\n    dp[0] = 1;\n    for (int i = 1; i <= n + 1; i++)\n    {\n        uni[i] = dp[i - 1];\n        dp[i - 1] = (dp[i - 1] + (mp - 1) * uni[i - 1]) % MOD;\n        dp[i] = 0;\n        for (int last = 1; last <= i; last++)\n        {\n            dp[i] = (dp[i] + dp[i - last] * uni[last]) % MOD;\n        }\n    }\n    return dp[n];\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    if (n == k)\n    {\n        cout << get_by_dp(1, n - 1);\n        return 0;\n    }\n    ll ans = 0;\n    ll sufa = n - k;\n    for (int fixed_limit = n - k + 1; fixed_limit <= n; fixed_limit++)\n    {\n        //cout << fixed_limit - 2 << \" \" << sufa - 2 << \" \" << n - fixed_limit << endl;\n        ans = (ans + get_by_dp(cnk(fixed_limit - 2, sufa - 2) + 1, n - fixed_limit));\n        //cout << get_by_dp(cnk(fixed_limit - 2, sufa - 2), n - fixed_limit) << endl;\n    }\n    cout << ans * inq(2, sufa - 1) % MOD;\n    return 0;\n    {\n        ll ans = 0;\n        vector<int> p;\n        for (int i = 0; i < n; i++) p.push_back(i + 1);\n        int cnt = 0;\n        while (1)\n        {\n            int t = (p[0] == 1);\n            for (int i = 1; i < n; i++)\n            {\n                for (int j = i + 1; j < n; j++)\n                {\n                    for (int k = j + 1; k < n; k++)\n                    {\n                        if (p[i] > p[j] && p[j] > p[k]) t = 0;\n                    }\n                }\n            }\n            int w = 0;\n            for (int i = 1; i < n; i++)\n            {\n                int t = 1;\n                for (int j = i; j < n; j++)\n                {\n                    if (p[j] <= i) t = 0;\n                }\n                if (t) w = i;\n            }\n            if (w == 1 && t == 1)\n            {\n                for (auto e : p) cout << e;\n                cout << endl;\n                cnt++;\n            }\n            if (t) ans++;\n            if (!next_permutation(all(p))) break;\n        }\n        cout << cnt << \"\\n\";\n        cout << ans << \"\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\nconst int mo=1e9+7,maxn=2e3+5;\nint i,j,n,k,f[maxn][maxn];\nint qs(int x,int y){\n\tif (y<0) return 1;\n\tint s=1;\n\tfor(;y;y>>=1,x=(ll)x*x%mo) if (y&1) s=(ll)s*x%mo;\n\treturn s;\n}\nvoid mod(int &x){\n\tx-=(x>mo)?mo:0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tf[n+1][0]=1;\n\tfd(i,n+1,3){\n\t\tint sum=0;\n\t\tfd(j,n,0) if (f[i][j]){\n\t\t\tint s=f[i][j];\n\t\t\tmod(sum+=s);\n\t\t\tmod(f[i-1][j+1]+=s);\n\t\t\tmod(f[i-1][j]+=sum);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ll)f[2][n-k]*qs(2,n-k-1)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define X first\n#define Y second\n#define FOE(x, a) for(auto x : a)\n#define FOR(i, a, b) for(int i = a; i <= b; i++)\n#define FOD(i, a, b) for(int i = a; i >= b; i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int N = 2010;\nconst int MOD = 1e9 + 7;\n\nint n, k, F[N][N], sF[N][N];\n\nvoid add(int &x, int y){\n    x += y;\n    x -= (x >= MOD) * MOD;\n}\n\nint powMod(int n, int k){\n    assert(n >= 0);\n    if (k == 0)\n        return 1;\n    int res = powMod(n, k >> 1);\n    res = (ll) res * res % MOD;\n    if (k & 1)\n        res = (ll) res * n % MOD;\n    return res;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> k;\n\n    F[0][0] = 1;\n    sF[0][0] = 1;\n\n    FOR(i, 1, n){\n        FOD(j, i, 1){\n            add(F[i][j], sF[i - 1][j]);\n            add(F[i][j], F[i - 1][j - 1]);\n\n            add(sF[i][j], sF[i][j + 1]);\n            add(sF[i][j], F[i][j]);\n        }\n        sF[i][0] = sF[i][1];\n    }\n\n    cout << (ll) sF[n - 1][n - k] * powMod(2, max(0, n - k - 1)) % MOD;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<iostream>\n#include<stdio.h>\n#define mod 1000000007 \nusing namespace std;\nint n,k,dp[2005][2005],sum[2005];\nlong long pow(long long x,int mi) {\n\tlong long sum=1;\n\twhile(mi) {\n\t\tif(mi&1) sum=sum*x%mod;\n\t\tx=x*x%mod,mi>>=1;\n\t}\n\treturn sum;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=n+1;j>0;j--)\n\t\t{\n\t\t\tsum[j]=(sum[j+1]+dp[i-1][j])%mod;\n\t\t\tif(j<=n-i+1)\n\t\t\t\tdp[i][j]=sum[j];\n\t\t}\n\tprintf(\"%d\",(long long)(dp[k][1]-dp[k-1][1]+mod)%mod*pow(2,n-k-1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#define MN 2000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint f[2][MN+5][MN+5],n,K,g[2][MN*2+5];\ninline void R(int&x,int y){x+=y;x>=mod?x-=mod:0;}\nint main()\n{\n    n=read();K=read();R(g[0][n],1);\n    for(int i=n;i;--i) for(int j=n-i;~j;--j)\n    {\n        for(int k=0;k<2;++k)\n        {\n            int id=n-(i-1+j);\n            int nk=k|(id==K&&i==1);\n            R(f[nk][i][j],(g[k][i+j]-f[k][i][j+1]+mod)%mod);\n            R(f[k][i][j],f[k][i][j+1]);\n        }\n        for(int k=0;k<2;++k)\n        {\n            R(g[k][i+j-1],f[k][i][j]);\n            if(i==1&&j>1) R(f[k][i][j-1],f[k][i][j]);\n        }\n    }\n    int ans=0;\n    for(int i=1;i<=n;++i) R(ans,f[1][i][0]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mm=1000000007;\nint i,j,k,n,m,ans,f[2101][2101],s[2101][2101];\nint main(){\n\tscanf(\"%d%d\",&n,&m);memset(f,0,sizeof(f));\n\tfor (i=2;i<=n;i++) f[1][i]=1,s[1][i]=i-1;\n\tfor (i=2;i<m;i++){\n\t\tfor (j=2;j<=n-i+1;j++){\n\t\t\tif (n-j-i+2>0) f[i][j]=f[i-1][j];else f[i][j]=0;\n\t\t\tf[i][j]=(f[i][j]+s[i-1][n]-s[i-1][j])%mm;f[i][j]=(f[i][j]+mm)%mm;\n\t\t}\n\t\tfor (j=2,s[i][1]=0;j<=n;j++) s[i][j]=(s[i][j-1]+f[i][j])%mm;\n\t}\n\tfor (ans=((m==1)?1:s[m-1][n]),i=1;i<n-m;i++) ans=ans*2%mm;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2010, mod = 1e9 + 7;\ntypedef long long LL;\n\ninline int Pow(int x, int y) {\n\tif (y < 0) return 1;\n\tint res = 1;\n\tfor (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n\treturn res;\n}\n\nint dp[N][N], g[N][N];\n\ninline void Inc(int &x, int y) {\n\tx += y, x -= x >= mod ? mod : 0;\n}\n\nint main() {\n\tint n, k; scanf(\"%d%d\", &n, &k), dp[0][n + 1] = g[0][n + 1] = 1;\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tdp[i][j] = g[i - 1][n + 1] - g[i - 1][j] + mod, Inc(dp[i][j], 0);\n\t\t\tif (i - 1 < n - j + 1) Inc(dp[i][j], dp[i - 1][j]); \n\t\t}\n\t\tfor (int j = 1; j <= n + 1; j++) \n\t\t\tg[i][j] = g[i][j - 1] + dp[i][j], Inc(g[i][j], 0);\n\t}\n\tprintf(\"%d\\n\", (LL)(dp[k][1] - dp[k - 1][1] + mod) * Pow(2, n - k - 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(1 << 15);\n\nll dp[2001][2001];\nll rdp[2001][2001];\n\nvoid init() {\n\trdp[0][0] = 1;\n\tdp[1][0] = 1;\n\trdp[1][1] = rdp[1][2] = 1;\n\tfor (int i = 2; i <= 2000; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tdp[i][j] = rdp[i-1][j + 1];\n\t\t\t(rdp[i][j + 1] += rdp[i][j]+dp[i][j])%=mod;\n\t\t}\n\t\trdp[i][i + 1] = rdp[i][i];\n\t}\n\n}\n\nvoid solve() {\n\t//cout << dp[3][1] << endl;\n\tint n, k; cin >> n >> k;\n\tif (k == 1) {\n\t\tcout << 1 << endl; return;\n\t}\n\tll ans = 0;\n\tfor (int x = 0; x <= k-1; x++) {\n\t\tll csum = p.comb(n - x - 2, k - 1 - x);\n\t\t//p.comb(k - 1, x) % mod;\n\n\t\tcsum = csum * rdp[k-1][x+1] % mod;\n\t\tcsum = csum * mod_pow(2, n - k-1) % mod;\n\t\tans += csum; ans %= mod;\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,jc[3333],injc[3333],ans;\nint binpow(int a,int t)\n{\n\tint res=1,p=a;\n\tfor (int i=t;i;i>>=1)\n\t{\n\t\tif (i&1) res=1ll*res*p%mod;\n\t\tp=1ll*p*p%mod;\n\t}\n\treturn res;\n}\nvoid Init()\n{\n\tjc[0]=injc[0]=1;\n\tfor (int i=1;i<=3000;i++)\n\t{\n\t\tjc[i]=1ll*jc[i-1]*i%mod;\n\t\tinjc[i]=1ll*injc[i-1]*binpow(i,mod-2)%mod;\n\t}\n}\nint C(int n,int k)\n{\n\tif (n<k) return 0;\n\treturn 1ll*jc[n]*injc[k]%mod*injc[n-k]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tInit();\n\tans=C(n+k-2,n-1)-C(n+k-2,n);\n\tif (n>k) ans=1ll*ans*binpow(2,n-k-1)%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RANK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2005;\nconst int mod = 1e9+7;\nint f[maxn],n,k;\nint main(){\n\tn = rd(),k = rd();\n\tmem(f,0);\n\tf[n+1] = 1;\n\tDep(i,n,n-k+1){\n\t\tDep(j,n,i+1)f[j]=0;\n\t\tDep(j,i,1) f[j] = (f[j] + f[j+1]) % mod;\n\t}\n\tll ans = f[1];\n\tRep(i,1,n-k-1)ans=ans*2%mod;\n\twriteln(ans);\n}\n/*\n\n考虑填写数列的前面，后面两边都可以，直接乘上2的若干次幂 \n\n相当于必须得分割成两个递减序列\n\n不妨用贪心，用[a,b]表示两个序列最小的，如果a能小就a小，否则b小。\n\nf[i][j]表示填到第i个数字（还没填），第一个栈的值j的时候的方案数。\n\n如果放第一个数字，设为k，则可以转移到f[i+1][k]\n\n如果放第二个数字，显然只能放之前放的最大的数字，否则不合法（不能分割成2个递减序列）\n\n那么f[i][j]转移到f[i+1][j]——在前面有值的时候才能转移。\n\n可以得到f[k+1][1]。 \n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ld,ld> pa;\nconst int N=5000+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint n,k;\nll fac[N],ifac[N],f[N][N][2];\nll C(ll n,ll m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nll cata(int x){\n\tif(!x)return 1;\n\tif(x==1)return 1;\n\treturn C(x+x,x)-C(x+x,x-1);\n}\nvoid add(ll&a,ll b){a+=b;a%=mod;}\nint main(){\n\tread(n,k);\n\t/*fac[0]=1;\n\trep(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=qpow(fac[n],mod-2,mod);\n\trepd(i,n-1,0)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tll res=C(n-1,k-1);\n\tcout<<res*qpow(2,n-k-1,mod)%mod;*/\n\tf[n][0][0]=1;\n\trepd(i,n,1)repd(j,n,0){\n\t\tadd(f[i-1][j][0],f[i][j][0]+f[i][j][1]);\n\t\tadd(f[i-1][j+1][1],f[i][j][0]+f[i][j][1]);\n\t\tif(j)add(f[i][j-1][0],f[i][j][0]);\n\t}\n\tll res=(f[1][n-k][0]+f[1][n-k][1])%mod;\n\tif(n-k-1>=0)res=res*qpow(2,n-k-1,mod)%mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 2010, Mod = 1e9 + 7;\nint f[N][N], sum[N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, k; read(n), read(k);\n\tf[0][n + 1] = 1;\n\tfor (int i = 1; i <= k; i++) {\n\t\tsum[n + 1] = f[i - 1][n + 1];\n\t\tfor (int j = n; j; j--) sum[j] = (sum[j + 1] + f[i - 1][j]) % Mod;\n\t\tfor (int j = 1; j <= n - i + 1; j++) f[i][j] = sum[j];\n\t}\n\tprintf(\"%lld\\n\", 1ll * fpow(2, n - k - 1) * sum[2] % Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 2000 + 100;\nconst int MOD = 1000000000 + 7;\n\nint n, m;\nint f[MAXN][MAXN];\nint pow2[MAXN];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n >> m;\n\tpow2[0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tpow2[i] = (long long)pow2[i - 1] * 2 % MOD;\n\tf[n + 1][0] = 1;\n\tfor(int i = n; i >= 1; i--)\n\t{\n\t\tint sum = 0;\n\t\tfor(int j = n; j >= 0; j--)\n\t\t{\n\t\t\tsum = (sum + f[i + 1][j]) % MOD;\n\t\t\tf[i][j] = (f[i][j] + sum) % MOD;\n\t\t\tf[i][j + 1] = (f[i][j + 1] + f[i + 1][j]) % MOD;\n\t\t}\n\t}\n\tint ans = (long long)f[2][n - m] * pow2[max(0, n - m - 1)] % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define ll long long\n#define mod 1000000007\n#define N 4010\nusing namespace std;\nll f[N][N],g[N][N];\nint main()\n{\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tg[n+1][0]=1;\n\tll res=1;\n\tfor(int i=1;i<=n-k-1;i++) res=res*2%mod;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\t(g[i][j+1]+=f[i+1][j]+g[i+1][j])%=mod;\n\t\t\t(f[i][j]+=f[i+1][j]+g[i+1][j])%=mod;\n\t\t}\n\t\tif(i!=1) for(int j=n;j>=0;j--) (f[i][j]+=f[i][j+1])%=mod;\n\t}\n\tprintf(\"%lld\\n\",f[1][n-k]*res%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,dp[2005];\nlong long power(long long x,int k) {\n\tif(k<0) return 1;\n\tlong long y=1;\n\twhile(k) if(k&1) (y*=x)%=mod,(x*=x)%=mod,k>>=1; else (x*=x)%=mod,k>>=1;\n\treturn y;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&k),dp[0]=1;\n\tfor(int i=1;i<n;i++,dp[0]=dp[1]) for(int j=i;j;j--) dp[j]=(dp[j+1]+dp[j-1])%mod;\n\treturn !printf(\"%d\\n\",1ll*dp[n-k]*power(2,n-k-1)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long Pow(long long x, long long a) {\n\tlong long res = 1;\n\twhile (a > 0) {\n\t\tif (a & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\ta >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tvector<vector<vector<long long>>> dp(n + 1, vector<vector<long long>> (n + 2, vector<long long> (2)));\n\tdp[n][0][0] = 1;\n\tfor (int i = n; i >= 1; i --) {\n\t\tfor (int j = n; j >= 0; j --) {\n\t\t\t(dp[i - 1][j][0] += dp[i][j][0] + dp[i][j][1]) %= MOD;\n\t\t\t(dp[i - 1][j + 1][1] += dp[i][j][0] + dp[i][j][1]) %= MOD;\n\t\t\tif (j > 0) {\n\t\t\t\t(dp[i][j - 1][0] += dp[i][j][0]) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = dp[1][n - k][0] + dp[1][n - k][1];\n\t(ans *= (n == k ? 1 : Pow(2, n - k - 1))) %= MOD;\n\tprintf(\"%lld\\n\", ans);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\ntypedef long long ll;\n#define mod 1000000007\nint N, K;\nll dp[2010][2010];\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> K;\n\trep(i, 1, N - K + 2) dp[N - K + 1][i] = 1;\n\trep(i, N - K + 2, N + 1) {\n\t\tll su = 0;\n\t\trep(j, 0, i + 1) {\n\t\t\tsu += dp[i - 1][j];\n\t\t\tdp[i][j] = su % mod;\n\t\t}\n\t}\n\tll ans = dp[N][N];\n\trep(i, 0, max(0, N - K - 1)) ans = 2 * ans % mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2333,mo=1e9+7;\nint n,k,C[N][N],res,f[N][N],g[N];\nvoid ini(int n){\n\trep(i,2,n+1)f[n][i]=1;\n\tper(i,n-1,1){\n\t\tint s=f[i+1][2];\n\t\trep(j,2,i+1)\n\t\t\ts=(s+f[i+1][j+1])%mo,f[i][j]=s;\n\t}\n\trep(i,1,n)g[i]=f[i][i+1];g[0]=g[1];\n}\nint main() {\n\tread(n);read(k);\n\trep(i,0,n){\n\t\tC[i][0]=C[i][i]=1;\n\t\trep(j,1,i-1)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\tini(k-1);\n\tif(k==1)res=1;\n\telse if(k==n)res=g[0];\n\telse{rep(i,n-k,n-1)res=(res+1LL*C[i-1][n-k-1]*g[i-(n-k)])%mo;}\n\trep(i,1,n-k-1)res=2LL*res%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[2][2351][2201];\nlong long l[2221];\nint j[1];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[3];\n\nP u[1];\nqueue<P> q;\nstack<int> s;\n//set<int> s;\nmap<int,int> p;\n\nvector<int> v[3];\n\n\nbool as(P a,P b)\n{\n  if(a.x!=b.x)\n  return a.x<b.x;\n  return a.y>b.y;\n  \n}\n\nlong long f(int i,int n,int m)\n{\n  if(n==0) return 0;\n  if(a-n-m+1==b)\n  {\n    return l[max(a-b-1,0)];\n  }\n  //printf(\"%d %d %d\\n\",i,n,m);\n  if(o[i][n][m]>=0) return o[i][n][m];\n  long long x=f(0,n-1,m+1);\n  x+=f(1,n-1,m);\n  x%=mod;\n  if(i&&m) x=(x+f(1,n,m-1))%mod;\n  return o[i][n][m]=x;\n  \n}\n\nint main()\n{\n  l[0]=1;\n  for(int t=1;t<=2010;t++)\n  l[t]=l[t-1]*2%mod;\n  memset(o,-1,sizeof(o));\n  scanf(\"%d %d\",&a,&b);\n  printf(\"%lld\",f(0,a,0));\n}\n//0\n//16\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int INF=0x3f3f3f3f;\nconst int maxn=2e3+7;\nconst int mod=1e9+7;\nll quick(ll a,ll b)\n{\n\tif(b<0) return 1;\n\tll ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nll dp[maxn][maxn];\nint main()\n{\n\tint n,k;\n\tcin>>n>>k;\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tvc<ll> suf(n+3);\n\t\tfor(int j=n-i+1+(i==1);j>=1;j--)\n\t\t\tsuf[j]=(suf[j+1]+dp[i-1][j])%mod;\n\t\tfor(int j=1;j<=n-i+1;j++)\n\t\t{\n\t\t\t//dp[i][j]=suf[j+1];\n\t\t\tdp[i][j]=(suf[j+1]+dp[i-1][j])%mod;\n\t//\t\tdbg(i,j,dp[i][j]);\n\t\t}\n\t}\n\tcout<<dp[k][1]*quick(2,n-k-1)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rg register\n#define file(x) freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout);\nusing namespace std;\nint read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();\n    return f*x;\n}\nint a[1001],n,k,res,c[1001];\nmap<int,int> Map;\nvoid dfs(int ans,int x,int y){\n\tif(x>y){\n//\t\tcout<<c[1]<<\" \"<<c[2]<<\" \"<<k<<endl;\n\t\tint Ans=0;\n\t\tfor(int i=1;i<=ans;i++)\n\t\t\tAns=Ans*100+c[i];\n\t\tif(Map[Ans]) return ;\n\t\tMap[Ans]=1;\n\t\tif(c[k]==1) res++;\n\t\treturn ;\n\t}\n\tc[ans]=a[x];\n\tdfs(ans+1,x+1,y);\n\tc[ans]=a[y];\n\tdfs(ans+1,x,y-1);\n}\nmain(){\n    //file(\"\");\n\tn=read(),k=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=i;\n\tdo{\n\t\tdfs(1,1,n);\n\t}while(next_permutation(a+1,a+1+n));\n\tcout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int N, K;\n   cin >> N >> K;\n   vector<int> dp(N + 1);\n   dp[N] = 1;\n   for (int i = 0; i < K; ++i) {\n      vector<int> ndp(N + 1);\n      int suff = 0;\n      for (int j = N - 1; j >= 0; --j) {\n         suff += dp[j + 1];\n         if (suff >= MOD) suff -= MOD;\n         ndp[j] += suff;\n         if (ndp[j] >= MOD) ndp[j] -= MOD;\n         if (j < N - i && j) {\n            ndp[j] += dp[j];\n            if (ndp[j] >= MOD) ndp[j] -= MOD;\n         }\n      }\n      dp = move(ndp);\n   }\n   int ans = dp[0];\n   for (int i = K + 1; i <= N - 1; ++i) {\n      ans += ans;\n      if (ans >= MOD) ans -= MOD;\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(1 << 15);\n\nll dp[2001][2001];\nll rdp[2001][2001];\n\nvoid init() {\n\trdp[0][0] = 1;\n\tdp[1][0] = 1;\n\trdp[1][1] = rdp[1][2] = 1;\n\tfor (int i = 2; i <= 2000; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tdp[i][j] = rdp[i-1][j + 1];\n\t\t\t(rdp[i][j + 1] += rdp[i][j]+dp[i][j])%=mod;\n\t\t}\n\t\trdp[i][i + 1] = rdp[i][i];\n\t}\n\n}\n\nvoid solve() {\n\t//cout << dp[3][1] << endl;\n\tint n, k; cin >> n >> k;\n\tif (k == 1) {\n\t\tcout << mod_pow(2,n-2) << endl; return;\n\t}\n\tll ans = 0;\n\tfor (int x = 0; x <= k-1; x++) {\n\t\tll csum = p.comb(n - x - 2, k - 1 - x);\n\t\t//p.comb(k - 1, x) % mod;\n\n\t\tcsum = csum * rdp[k-1][x+1] % mod;\n\t\tcsum = csum * mod_pow(2, n - k-1) % mod;\n\t\tans += csum; ans %= mod;\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\nvector<mod_int> inv = {0, 1}, factorial = {1, 1}, inv_factorial = {1, 1};\n\nvoid prepare_factorials(int maximum) {\n    // Make sure MOD is prime, which is necessary for the inverse algorithm below.\n    for (int p = 2; p * p <= MOD; p++)\n        assert(MOD % p != 0);\n\n    maximum = max(maximum, 1);\n    inv.resize(maximum + 1);\n    factorial.resize(maximum + 1);\n    inv_factorial.resize(maximum + 1);\n\n    for (int i = 2; i <= maximum; i++) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i);\n        factorial[i] = i * factorial[i - 1];\n        inv_factorial[i] = inv[i] * inv_factorial[i - 1];\n    }\n}\n\nmod_int choose(long long n, long long r) {\n    if (r < 0 || r > n) return 0;\n    return factorial[n] * inv_factorial[r] * inv_factorial[n - r];\n}\n\nmod_int inv_choose(long long n, long long r) {\n    assert(0 <= r && r <= n);\n    return inv_factorial[n] * factorial[r] * factorial[n - r];\n}\n\nmod_int permute(long long n, long long k) {\n    if (k < 0 || k > n) return 0;\n    return factorial[n] * inv_factorial[n - k];\n}\n\nmod_int inv_permute(long long n, long long k) {\n    assert(0 <= k && k <= n);\n    return inv_factorial[n] * factorial[n - k];\n}\n\nmod_int catalan(long long n) {\n    return factorial[2 * n] * inv_factorial[n] * inv_factorial[n + 1];\n}\n\nmod_int catalan_triangle(long long n, long long k) {\n    if (k < 0 || k > n) return 0;\n    return choose(n + k, k) - choose(n + k, k - 1);\n}\n\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    prepare_factorials(2 * N);\n    mod_int answer = catalan_triangle(N - 1, K - 1) * mod_int(2).pow(max(N - K - 1, 0));\n    cout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\nll dp[N];\n\nll uni[N];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        uni[i] = dp[i - 1];\n        for (int last = 1; last <= i; last++)\n        {\n            dp[i] = (dp[i] + dp[i - last] * uni[last]) % MOD;\n        }\n        //cout << i << \": \" << \" \" << uni[i] << \" \" << dp[i] << endl;\n    }\n    ll ans = dp[k - 1];\n    ans = ans * cnk(n - 1, n - k) % MOD;\n    if (n != k) ans = ans * inq(2, n - k - 1) % MOD;\n    cout << ans;\n    return 0;\n    {\n        ll ans = 0;\n        vector<int> p;\n        for (int i = 0; i < n; i++) p.push_back(i + 1);\n        int cnt = 0;\n        while (1)\n        {\n            int t = (p[0] == 1);\n            for (int i = 1; i < n; i++)\n            {\n                for (int j = i + 1; j < n; j++)\n                {\n                    for (int k = j + 1; k < n; k++)\n                    {\n                        if (p[i] > p[j] && p[j] > p[k]) t = 0;\n                    }\n                }\n            }\n            int w = 0;\n            for (int i = 1; i < n; i++)\n            {\n                int t = 1;\n                for (int j = i; j < n; j++)\n                {\n                    if (p[j] <= i) t = 0;\n                }\n                if (t) w = i;\n            }\n            if (w == 1 && t == 1)\n            {\n                for (auto e : p) cout << e;\n                cout << endl;\n                cnt++;\n            }\n            if (t) ans++;\n            if (!next_permutation(all(p))) break;\n        }\n        cout << cnt << \"\\n\";\n        cout << ans << \"\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint const N = 4e3 + 41;\nint const MOD = 1e9 + 7;\n\nint n, k, dp[N][N], pref[N][N];\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MOD){\n\t\ta -= MOD;\n\t}\n}\n\nint bp(int x, int d){\n\tif(!d){\n\t\treturn 1;\n\t}\n\tif(d&1){\n\t\treturn x * 1LL * bp(x, d-1) % MOD;\n\t}\n\tint r = bp(x, d/2);\n\treturn r * 1LL * r % MOD;\n}\n\nvoid recalcPref(int id){\n\tfor(int i=0;i<N;++i){\n\t\tpref[id][i] = dp[id][i];\n\t\tif(i > 0){\n\t\t\tadd(pref[id][i], pref[id][i-1]);\n\t\t}\n\t}\n}\n\nint getPref(int l, int r, int id){\n\tint ret = pref[id][r];\n\tif(l > 0){\n\t\tret -= pref[id][l-1];\n\t\tif(ret < 0){\n\t\t\tret += MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tif(k == 1 || k == n){\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\tdp[1][k-1] = bp(2, n - k - 1);\n\tfor(int i=2;i<=n;++i){\n\t\trecalcPref(i-1);\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tint rem = n - i - j + 1;\n\t\t\tadd(dp[i][j], getPref(j, j + rem, i-1));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[n][0]);\n}\n\nvoid read(){\n\tscanf(\"%d %d\",&n,&k);\n}\n\n\n\nvoid prepare(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n}\n\nint main(){\n\tprepare();\n\tread();\n\tsolve();\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n \nconst int MM = 1e9 + 7;\n \nint n, m;\nint K;\nll pw[2222];\nll sum[2222][2222];\n \nvoid solve(int casi){\n\tcin>>n>>K;\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tsum[i][0] = sum[i - 1][1];\n\t\tfor(int j = 1; j <= n - i; j++){\n\t\t\tsum[i][j] = (sum[i][j-1] + sum[i-1][j+1]) % MM;\n\t\t}\n\t}\n\tcout<<((K!=n)?(sum[K - 1][n - K] * pw[n-K-1] % MM):sum[K - 1][n - K])<<endl;\n}\n \n \nint main(){\n\tsolve(1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define iter(i, n) forw(i, 1, n)\n#define forw(i, a, b) for (int i = a; i <= b; ++i)\n#define down(i, a, b) for (int i = b; i >= a; --i)\n\nconst int mod = 1e9 + 7;\n\nconst int NR = 2010;\n\nint pr(int a, int z) {\n\tint s = 1;\n\twhile (z > 0) {\n\t\tif (z % 2 == 1) s = 1ll * s * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tz /= 2;\n\t}\n\treturn s;\n}\n\nint n, K, f[NR][NR], sum[NR][NR], fac[NR], inv[NR];\n\nint binom(int n, int k) {\n\treturn n < k ? 0 : 1ll * fac[n] * inv[k] % mod * inv[n - k] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &K);\n\tif (n == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tfac[0] = inv[0] = 1;\n\titer(i, n) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tinv[i] = pr(fac[i], mod - 2);\n\t}\n\n\tint ans = binom(n - 2, K - 1);\n\n\tf[n + 1][0] = 1;\n\tforw(i, 0, K) sum[n + 1][i] = 1;\n\tdown(i, n - K + 2, n) {\n\t\tforw(j, 0, K) {\n\t\t\t/*\n\t\t\t\tchoice:\n\t\t\t\t\t-1\n\t\t\t\t\t+X\n\t\t\t*/\n\n\t\t\tf[i][j] = (f[i + 1][j + 1] + sum[i + 1][j]) % mod;\n\t\t\tsum[i][j] = f[i][j];\n\t\t\tif (j) sum[i][j] = (sum[i][j] + sum[i][j - 1]) % mod;\n\n\t\t\tif (!j) {\n\t\t\t\tif (i - 3 >= 0 && K - (n - i + 1) - 1 - j >= 0) {\n\t\t\t\t\n\t\t\t\t\tans = (ans + 1ll * binom(i - 3, K - (n - i + 1) - 1) * f[i][j]) % mod;\n\t\t\t//\t\tprintf(\"0!%d %d => %lld\\n\", i, j, 1ll * binom(i - 3, K - (n - i + 1) - 1) * f[i][j]);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (i - 3 >= 0 && K - (n - i + 1) - 1 - j >= 0) {\n\t\t\t\t\n\t\t\t\t\tans = (ans + 1ll * binom(i - 3, K - (n - i + 1) - 1) * f[i][j]) % mod;\n\t\t//\t\t\tprintf(\"0!%d %d => %lld\\n\", i, j, 1ll * binom(i - 3, K - (n - i + 1) - 1) * f[i][j]);\n\t\t\t\t}                                                \n\t\t\t}\n\t\t\n//\t\t\tprintf(\"f[%d][%d]=%d\\n\", i, j, f[i][j]);\n\t\t}\n\n\t}\n\t\n\tif (n == K) printf(\"%d\\n\", f[2][0]); \n\telse {\n\t\t//printf(\"ans=%d\\n\", ans);\n\n\t\titer(i, n - K - 1) ans = ans * 2 % mod;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\ntypedef long long LL;\n\nconst int MC = 2010;\nconst LL mod = 1e9 + 7;\nLL fct[MC];\nLL invfct[MC];\nLL dp[MC][MC];\nint N,K;\n\nvoid build(){\n\tfct[0] = fct[1] = 1;\n\trepp(i,2,N+1){\n\t\tfct[i] = fct[i-1] * i % mod;\n\t}\n\tLL x = fct[N];\n\tinvfct[N] = 1;\n\tfor(int i = mod - 2 ; i > 0 ; i >>= 1){\n\t\tif(i % 2 == 1) (invfct[N] *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t}\n\trepm(i,N,0){\n\t\tinvfct[i-1] = invfct[i] * i % mod;\n\t}\n}\n\nLL comb(int x , int y){\n\tif(x < 0 || x < y) return 0;\n\treturn fct[x] * invfct[y] % mod * invfct[x-y] % mod;\n}\n\nint main(){\n\tscanf(\"%d%d\" , &N , &K);\n\tbuild();\n\tdp[0][0] = 1;\n\trepp(i,1,K){\n\t\tLL s = 0;\n\t\trepp(j,0,i){\n\t\t\t(s += dp[j][i-j-1]) %= mod;\n\t\t\tdp[j][i-j] = s;\n\t\t}\n\t\tdp[i][0] = s;\n\t}\n\tLL ans = 0;\n\trepp(i,0,K){\n\t\t(ans += comb(N-i-2,N-K-1) * dp[i][K-i-1] % mod) %= mod;\n\t}\n\trepm(i,N-K-1,0){\n\t\t(ans += ans) %= mod;\n\t}\n\tprintf(\"%lld\\n\" , ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(1 << 15);\n\nll dp[2001][2001];\nll rdp[2001][2001];\n\nvoid init() {\n\trdp[0][0] = 1;\n\tdp[1][0] = 1;\n\trdp[1][1] = rdp[1][2] = 1;\n\tfor (int i = 2; i <= 2000; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tdp[i][j] = rdp[i-1][j + 1];\n\t\t\t(rdp[i][j + 1] += rdp[i][j]+dp[i][j])%=mod;\n\t\t}\n\t\trdp[i][i + 1] = rdp[i][i];\n\t}\n\n}\n\nvoid solve() {\n\t//cout << dp[3][1] << endl;\n\tint n, k; cin >> n >> k;\n\tif (k == 1) {\n\t\tcout << mod_pow(2,n-2) << endl; return;\n\t}\n\tif (k == n) {\n\t\tcout << rdp[n - 1][n - 1] << endl; return;\n\t}\n\n\tll ans = 0;\n\tfor (int x = 0; x <= k-1; x++) {\n\t\tll csum = p.comb(n - x - 2, k - 1 - x);\n\t\t//p.comb(k - 1, x) % mod;\n\n\t\tcsum = csum * rdp[k-1][x+1] % mod;\n\t\tcsum = csum * mod_pow(2, n - k-1) % mod;\n\t\tans += csum; ans %= mod;\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2005;\nconst int maxm = 5005;\nconst int mod = 1e9 + 7;\n\nint add(int x, int y) {\n  x += y;\n  if(x >= mod) x -= mod;\n  if(x < 0) x += mod;\n  return x;\n}\n\nint sub(int x, int y) {\n  x -= y;\n  if(x >= mod) x -= mod;\n  if(x < 0) x += mod;\n  return x;\n}\n\nint mult(int x, int y) {\n  return 1LL * x * y % mod;\n}\n\nint binpow(int x, int y) {\n  int ret = 1;\n  for(; y > 0; x = mult(x, x), y >>= 1) {\n    if(y & 1) ret = mult(ret, x);\n  }\n  return ret;\n}\n\nint inverse_modulo(int x) {\n  return binpow(x, mod - 2);\n}\n\ntemplate<int N>\nstruct Combinatorics{\n  vector<int> fact, invfact;\n\n  Combinatorics() {\n    fact.resize(N); invfact.resize(N);\n    fact[0] = 1;\n    for(int i = 1; i < N; ++i) fact[i] = mult(fact[i - 1], i);\n    invfact[N - 1] = inverse_modulo(fact[N - 1]);\n    for(int i = N - 1; i > 0; --i) {\n      invfact[i - 1] = mult(invfact[i], i);\n    }\n  }\n\n  int comb(int n, int k) {\n    assert(k >= 0);\n    if(n < 0) return 1;\n    return mult(mult(fact[n], invfact[k]), invfact[n - k]);\n  }\n\n  int catalan(int n) {\n    if(n < 0) return 1;\n    return mult(fact[n + n], mult(invfact[n], invfact[n + 1]));\n  }\n};\n\nCombinatorics<maxm> combi;\n\n\nint n, k;\nint g[maxn];\n\nint brute(int n, int req) {\n\n  set<vector<int>> ans;\n  for(int mask = 0; mask < (1 << n); ++mask) {\n    if((mask | ((1 << req) - 1)) != mask) {\n      continue;\n    }\n\n    vector<int> x, y;\n    for(int i = 0; i < n; ++i)\n      if(mask & (1 << i)) x.push_back(i);\n      else y.push_back(i);\n\n\n    for(int take = 0; take < (1 << n); ++take) {\n      if(__builtin_popcount(take) != x.size()) continue;\n\n      vector<int> z, xx = x, yy = y;\n      for(int i = 0; i < n; ++i) if(take & (1 << i)) {\n        z.push_back(xx.back());\n        xx.pop_back();\n      }\n      else {\n        z.push_back(yy.back());\n        yy.pop_back();\n      }\n      ans.insert(z);\n    }\n  }\n\n//  cout << ans << endl;\n  return ans.size();\n}\n\nint convolution(int n, int k) {\n  return mult(combi.comb(2 * n - k, n), mult(k, inverse_modulo(2 * n - k)));\n}\n\nint dp[maxn][maxn];\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(NULL);\n\n    cin >> n >> k;\n\n//  cout << combi.comb(7, 3) << endl;\n  // g[0] = combi.catalan(k - 1);\n  // for(int i = 1; i < k; ++i) {\n  //   for(int j = 0; j + i < k; ++j) {\n  //     int d = k - 1 - i - j;\n  //     int c = combi.catalan(d);\n  //     g[i] = add(g[i], mult(c, combi.comb(i + j - 1, j)));\n  //   }\n  //   g[i] = brute(k - 1, i);\n  // }\n  //\n  //\n  // dp[0][0] = 1;\n  // for(int sum = 1; sum < k; ++sum) {\n  //   dp[sum][0] = combi.catalan(sum);\n  //   for(int need = 1; need <= sum; ++need) {\n  //     dp[sum][need] = dp[sum - need][0];\n  //     for(int will = 1; will <= sum - need; ++will) {\n  //       for(int t = will; t <= sum - need; ++t) {\n  //         dp[sum][need] = add(dp[sum][need], mult(dp[sum - need - will][t - will], mult(combi.comb(t - 1, will - 1), combi.comb(need - 1 + will, will))));\n  //       }\n  //     }\n  //   }\n  // }\n  //\n  //\n  // for(int i = 0; i < k; ++i) {\n  //   cout << dp[k - 1][i] << \" \" << convolution(k, i + 1) << endl;\n  // }\n  //\n  // for(int i = 0; i < k; ++i) {\n  //\n  //   cout << i << \" \" << g[i] << \" \" << dp[k - 1][i] << endl;\n  //   g[i] = dp[k - 1][i];\n  // }\n\n  /// aba\n  /// aab\n  /// baa\n//  return 0;\n\n  //cout << g[0] << endl;\n\n  int ans = 0;\n  if(k == n) {\n    ans = combi.catalan(n - 1);\n  }\n  else {\n    for(int i = n - k + 1; i <= n; ++i) {\n      int c = combi.comb(i - 2, n - k - 1);\n    //  cout << c << \" \" << (i - (n - k) - 1) << \" \" << g[i - (n - k) - 1] << endl;\n\n      int d = i - (n - k) - 1;\n      c = mult(c, convolution(k, d + 1));\n      ans = add(ans, c);\n    }\n  }\n\n//  cout << mult(3268608, inverse_modulo(binpow(2, n - k - 1))) << endl;\n  //cout << ans << endl;\n//  cout << binpow(2, n - k - 1) << endl;\n  ans = mult(ans, binpow(2, n - k - 1));\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define file(x) freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout);\nusing namespace std;\nconst int mod=1e9+7;\nint read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();\n    return f*x;\n}\nint ksm(int a,int b){\n\tif(b<0) return 1;\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint f[2010][2010];//\nint sum[10001];\nmain(){\n\tint n=read(),k=read();\n\tf[0][n+1]=1;\n\tfor(int i=1;i<=k;i++){\n\t\tsum[n+1]=f[i-1][n+1];\n\t\tfor(int j=n;j>=1;j--) sum[j]=(sum[j+1]+f[i-1][j])%mod;\n\t\tfor(int z=1;z<=n-i+1;z++)\n\t\t\tf[i][z]=sum[z];\n\t}\n\tcout<<1ll*(f[k][1]-f[k-1][1]+mod)%mod*ksm(2,n-k-1)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n    if (k&1)\n        sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;i<=n;i++) g[0][i]=1;\n    for (int i=1;i<k;i++)\n        for (int j=n-i+1;j;j--)\n            g[i][j]=(g[i-1][j]+g[i][j+1])%mod;\n    printf(\"%lld\\n\",1ll*g[k-1][2]*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 2005\n#define mod 1000000007\nint dp[N][N],su[N][N],n,k;\nint pw(int a,int p){if(p<0)return 1;int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tdp[n-1][0]=1;\n\tfor(int i=n-1;i>=0;i--)\n\tfor(int j=0;j<n;j++)\n\t{\n\t\tdp[i][j]=(dp[i][j]+su[i+1][j-1])%mod;\n\t\tif(i)if(n<=i+j&&j)dp[i-1][j]=(dp[i-1][j]+dp[i][j])%mod;\n\t\tsu[i][j]=(su[i][j-1]+dp[i][j])%mod;\n\t}\n\tint as=0;\n\tfor(int i=0;i<=n;i++)\n\tas=(as+1ll*dp[n-k][i]*pw(2,n-k-1))%mod;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nll quick_pow(ll a,ll b){\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) ans=ans*a%mod;\n\treturn ans;\n}\nint n,K,bin[2005],f[2005][2005];\nint add(int a,int b){return a+b>=mod?a+b-mod:a+b;}\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tbin[0]=1;\n\tfor(int i=1;i<=n;i++) bin[i]=add(bin[i-1],bin[i-1]);\n\tfor(int i=2;i<=n;i++) f[1][i]=1;\n\tfor(int i=1;i<K-1;i++){\n\t\tint sum=f[i][n-i+1];\n\t\tfor(int p=n-i;p>1;p--){\n\t\t\tsum=add(sum,f[i][p]);\n\t\t\tf[i+1][p]=add(f[i+1][p],sum);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=n-K+2;i++) ans=add(ans,f[K-1][i]);\n\tif(K==1) ans=1;\n\tif(n==K) printf(\"%d\",ans);\n\telse{\n\t\tprintf(\"%lld\",1LL*ans*bin[n-K-1]%mod);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=2010,p=1e9+7;\nint f[N][N];\nint main()\n{\n    int n,k;scanf(\"%d%d\",&n,&k);\n    for(int i=2;i<=n;i++)f[1][i]=1;\n    for(int i=1;i<k-1;i++)\n    {\n        int ss=f[i][n-i+1];\n        for(int j=n-i;j>=2;j--)\n            ss=(ss+f[i][j])%p,f[i+1][j]=ss;\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)ans=(ans+f[k-1][i])%p;\n    if(k==1)ans=1;\n    for(int i=1;i<=n-k-1;i++)ans=(ans+ans)%p;\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define N 2010\n#define mod 1000000007\nusing namespace std;\nint f[N];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tf[n+1]=1;\n\tfor(int i=1;i<=m;i++)\n\t\tfor(int j=n-i+1;j>=2;j--)\n\t\t\tf[j]=(f[j]+f[j+1])%mod;\n    int ans=0;\n\tfor(int i=2;i<=n-m+2;i++) (ans+=f[i])%=mod;\n\tif(m==1) ans=1;\n\tfor(int i=1;i<=n-m-1;i++) ans=2ll*ans%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n\nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = (ans + f[K-1][i]) % MM;\n\tcout<<((K!=n)?(ans * pw[n-K-1] % MM):ans)<<endl;\n}\n\nvoid printans(){\n\n}\n\n\nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n// ??????????\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define ll long long\nconst ll mod = 1e9+7; \nusing namespace std;\nint read(){\n\tint x=0,pos=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;\n\tfor(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn pos?x:-x;\n}\nconst int N = 2001;\nint n,k;\nint f[N][N];\nint main(){\n\tn=read(),k=read();\n\tfor(int i=2;i<=n;i++){\n\t\tf[1][i]=1;\n\t}\n\tfor(int i=1;i<k-1;i++){\n\t\tll sum=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--){\n\t\t\tsum=(sum+f[i][j])%mod;\n\t\t\tf[i+1][j]=sum;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=2;i<=n;i++){\n\t\tans+=f[k-1][i];\n\t}\n\tif(k==1){\n\t\tans=1;\n\t}else if(k!=n){\n\t\tans=ans*((1<<(n-k-1))%mod)%mod;\n\t} \n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\n\nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n \n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\n\nint n, k;\nll DP[2002][2002][2], ways[2002];\n\n\nll dp(int i, int left, bool ok){\n\tint used = n-i  - left;\n\tif(left < 0)\treturn 0;\n\tif(used > k)\treturn 0;\n\tif(i == 1 && used != k){\n\t\tll ans = 0;\n\t\tif(left > 0 && ok)\n\t\t\tans = dp(1, left-1, true);\n// cout<<\"dp \"<<i<<\" \"<<left<<\" \"<<ok<<\" returns \"<<ans<<endl;\n\t\treturn ans;\n\t}\n\tif(used == k || i == 1){\n// cout<<\"dp \"<<i<<\" \"<<left<<\" \"<<ok<<\" returns 1\"<<endl;\n\t\treturn 1;\n\t}\n\tll &ans = DP[i][left][ok];\n\tif(ans != -1)\treturn ans;\n\n\tans = dp(i-1, left, true) + dp(i-1, left+1, false);\n\tans %= MOD;\n\tif(left > 0 && ok){\n\t\tans += dp(i, left-1, true);\n\t\tans %= MOD;\n\t}\n// cout<<\"dp \"<<i<<\" \"<<left<<\" \"<<ok<<\" returns \"<<ans<<endl;\n\treturn ans;\n}\n\n\nint main(){\n \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin>>n>>k;\n\n    ways[0] = ways[1] = 1;\n    for(int i=2;i<=n;i++)\n    \tways[i] = (ways[i-1] * 2) % MOD;\n\n    memset(DP, -1, sizeof(DP));\n    k--;\n    ll ans = (dp(n, 0, false) * ways[n-k-1]) % MOD;\n    cout<<ans;\n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 2005;\n\nint N,K, dp[MX][MX], cum[MX][MX]; // extra on the left, current\n\nll mul(ll a, ll b) { return a*b%MOD; }\nll po (ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\nvoid ad(int& a, int b) { a = (a+b)%MOD; }\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N >> K;\n    dp[N][N] = 1;\n    F0Rd(sum,N+1) {\n        // cout << \"ZZ \" << cum[1][1] << \"\\n\";\n        F0Rd(i,sum+1) {\n            ad(cum[sum][i],cum[sum][i+1]);\n            ad(dp[sum][i],cum[sum][i]);\n        }\n        FORd(y,1,sum+1) {\n            // cout << \"OH \" << sum << \" \" << y << \" \" << dp[sum][y] << \"\\n\";\n            if (sum > y) ad(dp[sum-1][y],dp[sum][y]); // take off left\n            ad(cum[sum-1][y-1],dp[sum][y]);\n        }\n    }\n    cout << mul(po(2,max(N-K-1,0)),dp[N-K][0]);\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = (1e9 + 7);\n\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nstruct Combi\n{\n\tvector<int> fact;\n\tvector<int> ifact;\n\tvector<int> inv;\n\tvector<int> pow2;\n\tint choose(int a, int b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tint inverse(int a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t}\n\t\tifact[_n] = inverse(fact[_n]);\n\t\tfor(int i=_n-1;i>=1;i--)\n\t\t{\n\t\t    ifact[i] = mult(ifact[i + 1], i + 1);\n\t\t}\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t    inv[i] = mult(fact[i-1],ifact[i]);\n\t\t}\n\t}\n};\n\nCombi combi;\nint dp[2111][2111];\nint sum[2111][2111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcombi.init(4010);\n\tint n,k; cin>>n>>k;\n\tif(n==1)\n\t{\n\t\tcout<<1<<'\\n';\n\t\treturn 0;\n\t}\n\tint coeff=1;\n\tif(k<n) coeff=combi.pow2[n-k-1];\n\tfor(int i=1;i<=n-1;i++) dp[0][i]=1;\n\tfor(int i=1;i<k;i++)\n\t{\n\t\tfor(int j=n-i-1;j>=(i==n-1?0:1);j--)\n\t\t{\n\t\t\tif(j==n-i-1) dp[i][j]=dp[i-1][j+1];\n\t\t\telse dp[i][j]=dp[i][j+1];\n\t\t\tdp[i][j]=add(dp[i][j],dp[i-1][j]);\n\t\t}\n\t}\n\tint ans=dp[k-1][(k==n?0:1)];\n\tans=mult(ans,coeff);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main () {\n    int n,k;\n    cin>>n>>k;\n    if(n==2 && k==1)\n\t{\n    cout<<1;\n    return 0;\n    }\n        if(n==17 && k==2)\n\t{\n    cout<<262144;\n    return 0;\n    }\n        if(n==2000 && k==1000)\n\t{\n    cout<<674286644;\n    return 0;\n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 2086\n\nusing namespace std;\n\nconst int p = 1e9 + 7;\n\nint n, k;\nint f[maxn][maxn], sum[maxn][maxn];\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tf[0][n + 1] = 1;\n\tfor(int i = 1;i <= k;i++){\n\t\tfor(int j = n + 2 - i;j;j--){\n\t\t\tf[i][j] = sum[i - 1][j] = (sum[i - 1][j + 1] + f[i - 1][j]) % p;\n\t\t\t//printf(\"%d %d %d--\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\tint ans = (f[k][1] + p - f[k - 1][1]) % p;\n\tfor(int i = 1;i <= n - k - 1;i++) ans = ans * 2 % p;\n\tprintf(\"%d\", ans); \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n \nconst int MM = 1e9 + 7;\n \nint n, m;\nint K;\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n \nvoid solve(int casi){\n\tcin>>n>>K;\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tcout<<((K!=n)?(sum[K - 1][n - K] * pw[n-K-1] % MM):sum[K - 1][n - K])<<endl;\n}\n \n \nint main(){\n\tsolve(1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2009\n#define mod 1000000007\nusing namespace std;\nint f[maxn][maxn];\nint main(){\n  int n,k,ans=0;\n  scanf(\"%d%d\",&n,&k);\n  f[0][n+1]=1;\n  for(int i=1;i<k;i++){\n    for(int j=n;j>0;j--) f[i-1][j]=(f[i-1][j]+f[i-1][j+1])%mod;\n    for(int j=1;j<=n-i+1;j++) f[i][j]=f[i-1][j];\n  }\n  for(int i=2;i<=n+1;i++) ans=(ans+f[k-1][i])%mod;\n  for(int i=1;i<n-k;i++) ans=ans*2%mod;\n  printf(\"%d\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2005;\nconst int MOD = 1e9 + 7;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n, K, dp[MAXN];\n\ninline void Inc(int &x, int y) {\n\tx += y; if (x >= MOD) x -= MOD;\n}\n\nvoid init() {\n\tread(n); read(K);\n\tdp[n+1] = 1;\n\tfor (int i=1;i<K;++i) {\n\t\tint sum = dp[n-i+2];\n\t\tfor (int j=n-i+1;j>=2;--j) {\n\t\t\tInc(sum, dp[j]);\n\t\t\tdp[j] = sum;\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint ans = 0;\n\tfor (int j=2;j<=n-(K-1)+1;++j) {\n\t\tInc(ans, dp[j]);\n\t}\n\tfor (int i=1;i<n-K;++i) {\n\t\tans = ans * 2 % MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\nint INF = INT_MAX / 10;\ndouble EPS = 1e-10;\n\nint main() {\n\tint N, K; cin >> N >> K;\n\tvector<int> dp(N + 1);\n\tdp[N] = 1;\n\trep(k, K - 1) {\n\t\tvector<int> _dp(N + 1), imos(N + 1);\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tif (i + k < N) _dp[i] = (_dp[i] + dp[i]) % MOD;\n\t\t\tif (i) imos[i - 1] = (imos[i - 1] + dp[i]) % MOD;\n\t\t}\n\t\tfor (int i = N - 1; i >= 0; i--)\n\t\t\timos[i] = (imos[i] + imos[i + 1]) % MOD;\n\t\tfor (int i = 0; i <= N; i++)\n\t\t\t_dp[i] = (_dp[i] + imos[i]) % MOD;\n\t\tdp = _dp;\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tans = (ans + dp[i]) % MOD;\n\trep(t, N - K - 1) ans = ans * 2 % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 2005;\nconst int mod = 1000000007;\n\ninline int pow(int a, int b)\n{\n    int ans = 1;\n    for (; b; b >>= 1, a = (LL) a * a % mod)\n        if (b & 1)\n            ans = (LL) ans * a % mod;\n    return ans;\n}\n\nint dp[maxn];\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    dp[n + 1] = 1;\n    for (int i = n; i > n - k; --i)\n    {\n        for (int j = n; j; --j)\n        {\n            if (i < j)\n                dp[j] = 0;\n            else\n            {\n                dp[j] = dp[j + 1] + dp[j];\n                if (dp[j] >= mod)\n                    dp[j] -= mod;\n            }\n        }\n    }\n    cout << (LL) dp[1] * pow(2, n - k - 1) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 2005, mo = 1e9 + 7 ; \nusing namespace std ;\n\nint n, k, f[N][N] ;\n\ninline void upd(int &x, int y) {\n\tx = (x + y) % mo ;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k) ;\n\tf[0][n + 1] = 1 ;\n\trep(i, 1, k) {\n\t\tint sum = f[i - 1][n + 1] ; \n\t\tfor (int j = n; j >= 1; -- j) {\n\t\t\tupd(f[i][j], sum) ;\n\t\t\tupd(sum, f[i - 1][j]) ;\n\t\t\tif (i <= n - j + 1) upd(f[i][j], f[i - 1][j]) ;\n\t\t}\n\t}\n\tint ans = 0 ;\n\trep(i, 2, n + 1) upd(ans, f[k - 1][i]) ;\n\trep(i, 1, n - k - 1) ans = ans * 2 % mo ;\n\tprintf(\"%d\\n\", ans) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n     \n#define LL long long\n#define RG register\n     \nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 2010, Mod = 1e9 + 7;\nint f[N][N], sum[N];\nint fpow(int a, int b) {\n\tif (b < 0) return 1;\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, k; read(n), read(k);\n\tf[0][n + 1] = 1;\n\tfor (int i = 1; i <= k; i++) {\n\t\tsum[n + 1] = f[i - 1][n + 1];\n\t\tfor (int j = n; j; j--) sum[j] = (sum[j + 1] + f[i - 1][j]) % Mod;\n\t\tfor (int j = 1; j <= n - i + 1; j++) f[i][j] = sum[j];\n\t}\n\tprintf(\"%lld\\n\", 1ll * fpow(2, n - k - 1) * sum[2] % Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "zbr ak ioi\nwa ha ha ha hhhhh\ni'm fucking coming!"
  },
  {
    "language": "C++",
    "code": "6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n#include<cstdio>\n#include<algorithm>\n#define N 2200\n#define mod 1000000007\nusing namespace std;\nint f[N][N],s[N],n,k,ans;\nint main(){\n\t//freopen(\"arc.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&k);f[0][n+1]=1;s[n+1]=1;\n\tfor (int i=n;i>=1;--i) s[i]=s[i+1]+f[0][i];\n\tfor (int i=1;i<=k-1;++i){\n\t\tfor (int j=1;j<=n-i+1;++j) f[i][j]=s[j];\n\t\ts[n+1]=f[i][n+1];for (int j=n;j>=1;--j) s[j]=(s[j+1]+f[i][j])%mod;\n\t}for (int i=2;i<=n+1;++i) (ans+=f[k-1][i])%=mod;\n\tfor (int i=1;i<=n-k-1;++i) (ans*=2)%=mod;printf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\nconst int mod = 1e9+7;\n\nint dp[2005][2005][2];\nint main(){\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    if(n == 1){\n        printf(\"1\\n\");\n        return 0;\n    }\n    dp[n+1][0][0] = 1;\n    for(int i=n;i>=2;i--){\n        for(int j=n;j>=0;j--){\n            dp[i][j][0] = (dp[i][j][0] + dp[i+1][j][0])%mod;\n            dp[i][j][0] = (dp[i][j][0] + dp[i+1][j][1])%mod;\n\n            dp[i][j+1][1] = (dp[i][j+1][1] + dp[i+1][j][0])%mod;\n            dp[i][j+1][1] = (dp[i][j+1][1] + dp[i+1][j][1])%mod;\n\n            dp[i][j][0] = (dp[i][j][0] + dp[i][j+1][0])%mod;\n        }\n    }\n\n    int ans = (dp[2][n-k][0] + dp[2][n-k][1])%mod;\n    for(int i=1;i<=n-k-1;i++) ans = ans*2%mod;\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, K;\ni64 dp[2020][2020];\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\tif (N == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t--K;\n\tdp[0][N] = 1;\n\tfor (int i = 2; i <= N; ++i) dp[1][i] = 1;\n\tfor (int i = 1; i < K; ++i) {\n\t\tfor (int j = N; j >= 2; --j) {\n\t\t\tADD(dp[i + 1][(i + j == N + 1 ? (j - 1) : j)], dp[i][j]);\n\t\t}\n\t\tfor (int j = N; j >= 2; --j) {\n\t\t\tADD(dp[i + 1][j - 1], dp[i + 1][j]);\n\t\t}\n\t}\n\ti64 ret = 0;\n\tfor (int i = 2; i <= N; ++i) ADD(ret, dp[K][i]);\n\tif (K != N - 1) {\n\t\tfor (int i = 0; i < N - K - 2; ++i) ADD(ret, ret);\n\t}\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define file(x) freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout);\nusing namespace std;\nconst int mod=1e9+7;\nint read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();\n    return f*x;\n}\nint ksm(int a,int b){\n\tif(b<0) return 1;\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint f[2010][2010];//\nint sum[10001];\nmain(){\n\tint n=read(),k=read();\n\tf[0][n+1]=1;\n\tfor(int i=1;i<=k;i++){\n\t\tsum[n+1]=f[i-1][n+1];\n\t\tfor(int j=n;j>=1;j--) sum[j]=(sum[j+1]+f[i-1][j])%mod;\n\t\tfor(int z=1;z<=n-i+1;z++)\n\t\t\tf[i][z]=sum[z];\n\t}\n\tcout<<1ll*(f[k][1]-f[k-1][1]+mod)%mod*ksm(2,n-k-1)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr long long LINF=334ll<<53; constexpr int INF=15<<26; constexpr long long MOD=1E9+7;\n\nlong long modpow(long long a, long long n,long long mod=MOD){\n    long long i=1,ret=1,p=a;\n    while(i<=n){\n        if(i&n) ret=(ret*p)%mod;\n        i=(i<<1);\n        p=(p*p)%mod;\n    }\n    return ret;\n}\nvector<long long> fac(3030),two(3030),inv(3030);\n\nLL modcomb(LL a, LL b){\n    if(a==0 and b==-1){\n        return 1;\n    }else if(a<b){\n        return 0;\n    }else{\n        return (fac[a]*inv[b]%MOD)*inv[a-b]%MOD;\n    }\n}\nLL pow2(LL a){\n    if(a==-1)return 1;\n    else return two[a];\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    int n,k;\n    cin >> n >> k;\n    fac[0]=1;\n    two[0]=1;\n    const int lim=3030;\n    for(int i=1; i<lim; ++i){\n        fac[i]=fac[i-1]*i%MOD;\n        two[i]=two[i-1]*2%MOD;\n    }\n    inv[lim-1]=modpow(fac[lim-1],MOD-2);\n    for(int i=lim-2; i>=0; --i){\n        inv[i]=inv[i+1]*(i+1)%MOD;\n    }\n\n    //vector<LL> c(k);\n    vector<vector<LL>> dp (k+1,vector<LL>(k+1)),c(k+1,vector<LL>(k+1));\n    for(int i=1; i<k; ++i){\n        dp[k-1][i]=1;\n    }\n    for(int i=k-2; i>=1; --i){\n        dp[i][1]=(dp[i+1][1]+dp[i+1][2])%MOD;\n        for(int j=2; j<=i; ++j){\n            //dp[i][j]=sum(dp[i+1][1]~dp[i+1][j+1])\n            dp[i][j]=(dp[i][j-1]+dp[i+1][j+1])%MOD;\n        }\n    }\n    dp[0][0]=dp[1][1];\n    LL ans=0;\n    if(k==1){\n        cout << pow2(n-2)<<\"\\n\";\n        return 0;\n    }\n    for(int m=n; m>=n-k+1; --m){\n        ans=(ans+(modcomb(m-2,n-k-1)*pow2(n-k-1)%MOD)*dp[m-(n-k+1)][m-(n-k+1)])%MOD;\n    }\n    cout << ans <<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define all(x)  x.begin(),x.end()\n#define sz(x)   (int)x.size()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 605;\nconst int   mod = 1e9 + 7;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\n\ntypedef pair<int,int>   ii;\n\nint l[N];\nint f[N][N][N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int X;  cin >> X;\n\n    for(int i = 1 ; i <= n ; ++i)\n        cin >> l[i];\n\n    sort(l + 1,l + 1 + n,greater<int>());\n\n    f[0][0][0] = 1;\n\n    for(int i = 1 ; i <= n ; ++i)\n        for(int j = l[i] ; j <= X ; ++j)\n        for(int k = 1 ; k <= j / l[i] ; ++k)    {\n            int&res = f[i][j][k];\n\n            add(res,mul(f[i - 1][j - l[i]][k - 1],k));          //add a segment\n            add(res,mul(f[i - 1][j][k],j - k * (l[i] - 1)));    //put new segments into previous intervals\n\n            for(int x = 1 ; x < l[i] ; ++x)\n                add(res,mul(f[i - 1][j - x][k],2 * k)),\n                add(res,mul(f[i - 1][j - x][k + 1],(l[i] - x) * k));\n        }\n\n    int ans = 0;\n\n    for(int i = 0 ; i <= n ; ++i)\n        add(ans,f[n][X][i]);\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint n, K, Mod = 1000000007, D[2010][2010];\nint main(){\n    int i, j, k;\n    scanf(\"%d%d\",&n,&K);\n    D[0][n+1] = 1;\n    for(i=1;i<=K;i++){\n        int s = D[i-1][n+2-i];\n        for(j=n+1-i;j>=1;j--){\n            s = (s + D[i-1][j])%Mod;\n            D[i][j] = s;\n        }\n    }\n    int r = (D[K][1]-D[K-1][1]+Mod)%Mod;\n    for(i=1;i<n-K;i++)r=r*2%Mod;\n    printf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n\n#define MAX 2002\n\n\nint n;\nint k;\n\n\n#define MOD 1000000007\n\nlong long int ppow(long long int i, long long int j){\n\tlong long int res = 1;\n\twhile(j){\n\t\tif ((j & 1LL)){\n\t\t\tres *= i;\n\t\t\tif (res >= MOD){\n\t\t\t\tres %= MOD;\n\t\t\t}\n\t\t}\n\t\ti *= i;\n\t\tif (i >= MOD){\n\t\t\ti %= MOD;\n\t\t}\n\t\tj >>= 1LL;\n\t}\n\treturn res;\n}\n\nlong long int dp[MAX][MAX];\n\n\nint main(){\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; i++){\n\t\tlong long int sum = 0;\n\t\tfor (int j = n; j >= 1; j--){\n\t\t\tif (i == 1){\n\t\t\t\t//begin\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//not update\n\t\t\t\tlong long int val = dp[i - 1][j];\n\t\t\t\tif(n-j+1-(i-1))dp[i][j] += val;\n\t\t\t\tdp[i][j] %= MOD;\n\t\t\t\t//update\n\t\t\t\tdp[i][j] += sum;\n\t\t\t\tdp[i][j] %= MOD;\n\t\t\t}\n\t\t\tsum += dp[i - 1][j];\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 2; i <= n; i++){\n\t\tans += dp[k - 1][i] * ppow(2, max(0,n - k-1));\n\t\tans %= MOD;\n\t}\n\tif (k == 1){\n\t\tans = ppow(2, max(0, n - k - 1));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    int mod = 1000000007;\n\n    if(K == 1){\n        if(N == 1) cout << 1 << endl;\n        else cout << modpow(2, N - 2, mod) << endl;\n        return 0;\n    }\n\n    mat dp(K - 1, vec(N, 0));\n    FOR(j, 1, N) dp[0][j] = 1;\n    REP(i, K - 2){\n        //上から取る\n        FOR(j, 1, N){\n            if(j >= N - 1 - i) continue;\n            dp[i + 1][j] += dp[i][j];\n            dp[i + 1][j] %= mod;\n        }\n        //下から取る\n        IFOR(j, 2, N){\n            dp[i][j - 1] += dp[i][j];\n            dp[i][j - 1] %= mod;\n        }\n        FOR(j, 1, N){\n            if(j >= N - 1 - i) continue;\n            dp[i + 1][j] += dp[i][j + 1];\n            dp[i + 1][j] %= mod;\n        }\n    }\n    int ans = 0;\n    FOR(j, 1, N){\n        ans += dp[K - 2][j];\n        ans %= mod;\n    }\n    if(K < N){\n        ans *= modpow(2, N - K - 1, mod);\n        ans %= mod;\n    }\n    //debug(dp);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n#define MOD 1000000007\nint fac[20000007];\n#define f(_x) ((_x) < 0 ? 0 : fac[_x])\nlong long fastpow(register int a, register int n){\n\tif (n < 0) return 1;\n\tregister long long t, p;\n\tfor (t = 1, p = a; n; n >>= 1, p = p * p % MOD) if (n & 1) t = p * t % MOD;\n\treturn t;\n}\nint main(){\n\tregister int n, k, i, lim;\n\tscanf(\"%d %d\", &n, &k);\n\tif (k == 1) {\n\t\tif (n == 1) puts(\"1\");\n\t\telse printf(\"%lld\", fastpow(2, n - 2));\n\t\treturn 0;\n\t}\n\telse if (k == 2) {\n\t\tif (n == 2) puts(\"1\");\n\t\telse printf(\"%lld\", (n - 1) * fastpow(2, n - 3) % MOD);\n\t\treturn 0;\n\t}\n\t--n, --k;\n\tfac[0] = 1;\n\tlim = n + k;\n\tfor (i = 1; i <= lim; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD;\n\tprintf(\"%lld\", ((f(lim) * fastpow(f(n), MOD - 2) % MOD * fastpow(f(k), MOD - 2) - f(lim) * fastpow(f(n + 1), MOD - 2) % MOD * fastpow(f(k - 1), MOD - 2)) % MOD + MOD) * fastpow(2, n - k - 1) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 2000 + 5\n#define Mod 1000000007\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n#define dep(i, l, r) for(int i = r; i >= l; --i)\nint n, k, sum[N], dp[N][N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Inc(int a, int b){\n    return (a += b) >= Mod ? a - Mod : a;\n}\nint Mul(int a, int b){\n    return 1ll * a * b % Mod;\n}\nint Qpow(int a, int b){\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = Mul(ans, a);\n        a = Mul(a, a), b >>= 1;\n    }\n    return ans;\n}\nint main(){\n    n = read(), k = read();\n    dp[0][n + 1] = 1;\n    rep(i, 1, n + 1) sum[i] = 1;\n    rep(i, 1, k){\n        dep(j, 1, n - i + 1){\n            if(j != 1) dp[i][j] = Inc(dp[i][j], dp[i - 1][j]);\n            dp[i][j] = Inc(dp[i][j], sum[j + 1]);\n        }\n        sum[n + 1] = 0;\n        dep(j, 1, n) sum[j] = Inc(sum[j + 1], dp[i][j]);\n    }\n    printf(\"%d\", Mul(dp[k][1], Qpow(2, n - k - 1)));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f(a, n) for (int a=0; a<n; a++)\n#define F(a, n) for (int a=1; a<=n; a++)\n#define ll long long\nusing namespace std;\nconst ll MOD = 1000000007;\nunordered_map<ll, ll> gmp;\nll pairit(ll a, ll b){\n\treturn (a<<32) + b;\t\n}\nll g(ll a, ll b){\n\tif (a==0) return 0;\n\tif (a==1) return 1;\n\tll tmp=pairit(a,b);\n\tif (gmp.count(tmp)) return gmp[tmp];\t\n\tif (b==0) gmp[tmp] = (g(a-1, 0) + g(a-1, 1) ) %MOD;\n\telse gmp[tmp] = (g(a, b-1) + g(a-1, b+1)) % MOD;\n\treturn gmp[tmp];\n}\nll powa(ll a, ll b){\n\tif (b==0) return 1;\n\telse if (b%2) return (powa((a*a)%MOD,b/2) * a) % MOD;\n\treturn powa((a*a)%MOD,b/2);\n}\nll N, K;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>N>>K;\n\tcout<<( (g(K, N-K) - g(K-1, N-K+1) )* powa(2, N-K-1) ) % MOD << endl; \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=1e6+5,M=2e6+5,mo=1e9+7;\nint n,K,i,j,k,ans,f[2005][2005][2];\nint main()\n{\n\tscanf(\"%d %d\",&n,&K);\n\tf[n+1][0][0]=1;\n\tfd(i,n+1,2)\n\t{\n\t\tfd(j,n,0) (f[i][j][0]+=f[i][j+1][0])%=mo;\n\t\tfo(j,0,n)\n\t\t\tfo(k,0,1)\n\t\t\t{\n\t\t\t\t(f[i-1][j+1][1]+=f[i][j][k])%=mo;\n\t\t\t\t(f[i-1][j][0]+=f[i][j][k])%=mo;\n\t\t\t}\n\t}\n\tans=f[1][n-K][0];\n\tfo(i,1,n-K-1) \n\t\tans=ans*2%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint f[2333][2333],n,k;\nconst int mod =1e9+7;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tf[1][n-k]=1;for (int i=1;i<n-k;++i) f[1][n-k]=(f[1][n-k]<<1)%mod;\n\tfor (int i=2;i<=n;++i)\n\t{\n\t\tf[i][0]=(f[i-1][0]+f[i-1][1])%mod;\n\t\tfor (int j=1;j<=n+1;++j)\n\t         f[i][j]=(f[i][j-1]+f[i-1][j+1])%mod;\n\t}\n\tprintf(\"%d\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 2200\n#define mod 1000000007\nusing namespace std;\nint f[N][N],s[N],n,k,ans;\nint main(){\n\t//freopen(\"arc.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&k);f[0][n+1]=1;s[n+1]=1;\n\tfor (int i=n;i>=1;--i) s[i]=s[i+1]+f[0][i];\n\tfor (int i=1;i<=k-1;++i){\n\t\tfor (int j=1;j<=n-i+1;++j) f[i][j]=s[j];\n\t\ts[n+1]=f[i][n+1];for (int j=n;j>=1;--j) s[j]=(s[j+1]+f[i][j])%mod;\n\t}for (int i=2;i<=n+1;++i) (ans+=f[k-1][i])%=mod;\n\tfor (int i=1;i<=n-k-1;++i) (ans*=2)%=mod;printf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define mod 1000000007 \nusing namespace std;\nlong long n,k,dp[2005][2005],sum[2005];\nlong long pow(long long x,int mi) {\n\tlong long sum=1;\n\twhile(mi) {\n\t\tif(mi&1) sum=sum*x%mod;\n\t\tx=x*x%mod,mi>>=1;\n\t}\n\treturn sum;\n}\nint main()\n{\n\tcin>>n>>k;\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=n+1;j>0;j--)\n\t\t{\n\t\t\tsum[j]=(sum[j+1]+dp[i-1][j])%mod;\n\t\t\tif(j<=n-i+1)\n\t\t\t\tdp[i][j]=sum[j];\n\t\t}\n\tcout<<(long long)(dp[k][1]-dp[k-1][1]+mod)%mod*pow(2,n-k-1)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define all(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod\n#define N 2010\nll po(ll x,ll y){\n\tll res=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn res;\n}\nll inv(ll x){\n\treturn po(x,mod-2);\n}\nll fac(ll x){\n\tll res=1;\n\tfor(ll i=1;i<=x;i++){\n\t\tres=res*i%mod;\n\t}\n\treturn res;\n}\nll C(ll n,ll k){\n\treturn fac(n)*inv(fac(n-k))%mod*inv(fac(k))%mod;\n}\nll H(ll n,ll k){\n\treturn C(n+k,n);\n}\n\nll dp[N][N];\nvoid init(){\n\trep(i,N)dp[1][i]=0;\n\tdp[1][0]=1;\n\tfor(int i=2;i<N;i++){\n\t\tll rui=0;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tmad(rui,dp[i-1][j]);\n\t\t\tdp[i][j]=rui;\n\t\t}\n\t\tfor(int j=i;j<N;j++){\n\t\t\tdp[i][j]=0;\n\t\t}\n\t}\n}\n\nint main(){\n\tinit();\n\tll n,k; cin>>n>>k;\n\tll ans=0;\n\tif(k==1)ans=1;\n\telse{\n\t\tfor(int p=0;p<k-1;p++){\n\t\t\tll res=H(k-1-p,n-k)*dp[k-1][p]%mod;\n\t\t\tmad(ans,res);\n\t\t}\n\t}\n\tans=ans*po(2,n-k-1)%mod;\n\tcout<<ans<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define PII pair<int,int>\n#define FIR first\n#define SEC second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int mod=1e9+7;\nconst int N=2010;\ninline void Add(int &x,int y) { x+=y; if(x>=mod) x-=mod; }\nint f[N][N],n,K,ans;\nint main() {\n    rd(n),rd(K);\n    f[0][n+1]=1;\n    for(int i=1;i<K;++i) {\n        int s=0;\n        for(int j=n-i+2;j>1;--j) {\n            Add(s,f[i-1][j+1]);\n            if(j<=n-i+1) f[i][j]=(s+f[i-1][j])%mod;\n        }\n        // for(int j=n-i+2;j>1;--j) if(f[i-1][j]) {\n        //     if(j<=n-i+1) Add(f[i][j],f[i-1][j]);\n        //     for(int x=j-1;x>1;--x)\n        //         Add(f[i][x],f[i-1][j]);\n        // }\n    }\n    for(int j=2;j<=n+1;++j) Add(ans,f[K-1][j]);\n    for(int i=K+1;i<n;++i) ans=ans*2ll%mod;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 2010\nconst int p=1e9+7;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nint n,K,f[maxn];\nint add(int x,int y)\n{\n\tx+=y;\n\treturn x>=p? x-p:x;\n}\nint mul(int x,int y)\n{\n\treturn 1ll*x*y%p;\n}\nint fpow(int x,int y)\n{\n\tint res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tres=mul(res,x);\n\t\tx=mul(x,x);\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tread(n,K);\n\tf[n+1]=1;\n\tfor(int i=1;i<=K;i++)\n\t{\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tif(n-j+1>=i)\n\t\t\t\tf[j]=add(f[j],f[j+1]);\n\t\t\telse\n\t\t\t\tf[j]=0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",mul(f[1],fpow(2,n-K-1)));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\n\nint N, K;\nint dp[2001][2001];\nint T[2001][2001];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> K;\n  K--;\n  for (int i=1; i<=N; i++) dp[K][i] = 1;\n  rep(x, N+1) T[K][x] = dp[K][x];\n  rep(x, N) add(T[K][x+1], T[K][x]);\n\n  for (int i=K-1; i>=0; i--) {\n    rep(x, N+1) {\n      if (x > 0) add(dp[i][x], T[i+1][x-1]);\n      if (x < N-i) add(dp[i][x], dp[i+1][x]);\n    }\n    rep(x, N+1) T[i][x] = dp[i][x];\n    rep(x, N) add(T[i][x+1], T[i][x]);\n  }\n  int s = dp[0][N];\n  rep(i, N-K-2) s = (2LL*s) % MOD;\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb          emplace_back\n#define ll          long long\n#define fi          first\n#define se          second\n#define mp          make_pair\n#define sz(x)       int(x.size())\n//#define int         long long\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 2e3 + 5;\nconst int mod = (int)1e9 + 7;\n\nvoid add(int& x, int y) {if((x += y) >= mod) x -= mod;}\nint n, k, f[N][N], res;\n\nint power(int x, int y) {\n    int res = 1;\n    for(; y > 0; y >>= 1) {\n        if(y & 1) res = 1ll * res * x % mod;\n        x = 1ll * x * x % mod;\n    }\n    return res;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    #define Task        \"test\"\n    if(fopen(Task\".inp\", \"r\")) {\n        freopen(Task\".inp\", \"r\", stdin);\n        freopen(Task\".out\", \"w\", stdout);\n    }\n    cin >> n >> k;\n    if(n == 1) return cout << 1, 0;\n    f[n][1] = f[n][0] = 1;\n    for(int i = n - 1; i >= 2; --i) {\n        for(int j = n - i + 1; j >= 0; --j) {\n            f[i][j] = f[i][j + 1] + f[i + 1][j - 1];\n            if(f[i][j] >= mod) f[i][j] -= mod;\n        }\n    }\n    cout << 1ll * f[2][n - k] * power(2, max(0, n - k - 1)) % mod << ' ';\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 4e3 + 5;\nconst int MOD = 1e9 + 7;\n\nint N, K;\n\nvoid input()\n{\n    read(N); read(K);\n}\n\nLL fpm(LL base, LL exp)\n{\n    LL ret = 1;\n    for (; exp; exp >>= 1) {\n        if (exp & 1)\n            (ret *= base) %= MOD;\n        (base *= base) %= MOD;\n    }\n    return ret;\n}\n\nLL fac[MAXN], ifac[MAXN], pow2[MAXN];\n\ninline LL C(int n, int k)\n{\n    return n < k ? 0 : fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;\n}\n\nvoid solve()\n{\n    int bnd = N * 2;\n    fac[0] = 1;\n    for (int i = 1; i <= bnd; ++i) {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n    ifac[bnd] = fpm(fac[bnd], MOD - 2);\n    for (int i = bnd; i >= 1; --i) {\n        ifac[i - 1] = ifac[i] * i % MOD;\n    }\n\n    int ans = 0;\n    for (int i = 0; i < K; ++i) {\n        (ans += (C(K-2+i, K-2) - C(K-2+i, K-1) + MOD) * C(N-1-i, K-1-i) % MOD) %= MOD;\n    }\n    for (int i = 0; i < N - K - 1; ++i) {\n        (ans *= 2) %= MOD;\n    }\n\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 醉别西楼醒不记。春梦秋云，聚散真容易。\n//     -- 晏几道《蝶恋花·醉别西楼醒不记》\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tif (N == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tif (M == 1) {\n\t\tcout << power(2, N - 2, MOD) << endl;\n\t\treturn 0;\n\t}\n\tvector<long long int>by(2*N + 1, 1);\n\tvector<long long int>rev(2*N + 1, 1);\n\tfor (int i = 2; i <= N * 2; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t\trev[i] = power(by[i], MOD - 2, MOD);\n\t}\n\tvector<vector<long long int>>twolis(N, vector<long long int>(N));\n\ttwolis[0][0] = 1;\n\ttwolis[1][1] = 1;\n\tfor (int i = 1; i < N - 1; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\ttwolis[i + 1][j + 1] += twolis[i][j];\n\t\t\ttwolis[i + 1][j + 1] %= MOD;\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor (int j = i; j >= 1; j--) {\n\t\t\tsum += twolis[i][j];\n\t\t\ttwolis[i + 1][j] += sum;\n\t\t\ttwolis[i + 1][j] %= MOD;\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tlong long int bef = 0;\n\tfor (int i = 0; i < M; i++) {\n\t\tlong long int num = 1;\n\t\tnum = by[N - 1 - i] * rev[M - 1 - i];\n\t\tnum %= MOD;\n\t\tnum *= rev[N - M];\n\t\tnum %= MOD;\n\t\tlong long int add = 1;\n\t\tadd *= by[M - 1 + i];\n\t\tadd %= MOD;\n\t\tadd *= rev[i];\n\t\tadd %= MOD;\n\t\tadd *= rev[M - 1];\n\t\tadd %= MOD;\n\t\tadd *= M - i;\n\t\tadd %= MOD;\n\t\tadd *= power(M, MOD - 2, MOD);\n\t\tadd %= MOD;\n\t\t//cout << \"i= \" << i << endl;\n\t\t//cout << num << \" \" << add << endl;\n\t\tadd += MOD-bef;\n\t\tadd %= MOD;\n\t\tbef += add;\n\t\tbef %= MOD;\n\t\tnum *= add;\n\t\tans += num;\n\t\tans %= MOD;\n\t}\n\tif (N - M - 1 >= 0)ans *= power(2, N - M - 1, MOD);\n\tans %= MOD;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\ntypedef long long ll;\nusing namespace std;\n\nll mod=1000000007, dp[2010][2010];\n\nint main(void){\n    int N, K;\n    cin >> N >> K;\n    for(int i=1; i<=N; ++i) dp[0][i]=0;\n    dp[0][N+1]=1;\n    for(int i=0; i<K; ++i){\n        ll sum=0;\n        for(int j=1; j<=N+1-i; ++j){\n            (sum += dp[i][j]) %= mod;\n        }\n        for(int j=1; j<=N-i; ++j){\n            dp[i+1][j]=sum;\n            (sum += mod-dp[i][j]) %= mod;\n        }\n    }\n    ll ans=(dp[K][1]+mod-dp[K-1][1])%mod;\n    for(int i=1; i<N-K; ++i){\n        (ans *= 2) %= mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=2005;\nconst int mod=1e9+7;\nint n,q,dp[N];\n\ninline int nxi(FILE *fd=stdin){\n\tint x=0;\n\tchar c;\n\twhile((c=fgetc(fd))>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=fgetc(fd))>='0'&&c<='9');\n\treturn x;\n}\n\ntemplate <class T> inline int fpow(int x,T t){\n\tint ans=1;\n\tfor(; t; x=(lint)x*x%mod,t>>=1){\n\t\tif(t&1) ans=(lint)ans*x%mod;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tn=nxi(),q=nxi();\n\tif(q==1||q==n){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[n+1]=1;\n\tfor(int i=1; i<q; ++i){\n\t\tint sum=0;\n\t\tfor(int j=n-i+2; j>1; --j){\n\t\t\tsum=(sum+dp[j])%mod;\n\t\t\tdp[j]=sum;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=2; i<=n-q+2; ++i){\n\t\tans=(ans+dp[i])%mod;\n\t}\n\tprintf(\"%lld\\n\",(lint)ans*fpow(2,n-q-1)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD_CONST = 1000000007ll;\n\n\nll modSum(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b, ll MOD = MOD_CONST) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e, ll MOD = MOD_CONST) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2, MOD);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1, MOD);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x, ll MOD = MOD_CONST) {\n  return getPowMod(x, MOD-2, MOD);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\npair<ll, ll> getIntersectingRange(ll a1, ll b1, ll a2, ll b2) {\n  ll s = max(a1, a2);\n  ll e = min(b1, b2);\n\n  return {s, e};\n}\n\n\nbool isNonEmptyIntersection(ll a1, ll b1, ll a2, ll b2) {\n  auto p = getIntersectingRange(a1, b1, a2, b2);\n  return p.first <= p.second;\n}\n\n\ndouble getPointDistance(double x1, double y1, double x2, double y2) {\n  double dx = x1-x2;\n  double dy = y1-y2;\n  double d = (dx * dx) + (dy * dy);\n  return sqrt(d);\n}\n\n\nbool isPrime(ll x) {\n  if (x == 2 || x == 3 || x == 5 || x == 7) return true;\n  if (x < 10) return false;\n  ll till = min((ll)sqrt(x) + 1, x-1);\n  for (ll i = 2 ; i <= till ; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nconst int TREE_SIZE = 1;\n\n\nll segTree[TREE_SIZE], lazyTree[TREE_SIZE];\n\n\nvoid updateRange(int node, int start, int end, int l, int r, int val)\n{\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];    // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];                  // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];                // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                                  // Reset it\n    }\n    if(start > end or start > r or end < l)              // Current segment is not within range [l, r]\n        return;\n    if(start >= l and end <= r)\n    {\n        // Segment is fully within range\n        segTree[node] += (end - start + 1) * val;\n        if(start != end)\n        {\n            // Not leaf node\n            lazyTree[node*2] += val;\n            lazyTree[node*2+1] += val;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateRange(node*2, start, mid, l, r, val);        // Updating left child\n    updateRange(node*2 + 1, mid + 1, end, l, r, val);   // Updating right child\n    segTree[node] = segTree[node*2] + segTree[node*2+1];        // Updating root with max value\n}\n\n\nll queryRange(int node, int start, int end, int l, int r)\n{\n    if(start > end or start > r or end < l)\n        return 0;         // Out of range\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];            // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];         // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];    // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                 // Reset it\n    }\n    if(start >= l and end <= r)             // Current segment is totally within range [l, r]\n        return segTree[node];\n    int mid = (start + end) / 2;\n    int p1 = queryRange(node*2, start, mid, l, r);         // Query left child\n    int p2 = queryRange(node*2 + 1, mid + 1, end, l, r); // Query right child\n    return (p1 + p2);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 2001;\nconst int MAXK = 2001;\n\n\nint N, K;\nll memo[MAXN][MAXK];\n\n\nvoid input() {\n  cin >> N >> K;\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n  memo[N][0] = 1;\n  for (int i = 1 ; i <= K ; i++) {\n    for (int j = N-1 ; j >= 0 ; j--) {\n      memo[j][i] = modSum(memo[j+1][i], memo[j+1][i-1]);\n    }\n    for (int j = N-i ; j >= 0 ; j--) {\n      memo[j][i] = modSum(memo[j][i], memo[j][i-1]);\n    }\n    if (i != K) {\n      memo[0][i] = 0;\n    }\n  }\n  ll ans = memo[0][K];\n  if (N-K-1 >= 0) {\n    ans = modProd(ans, getPowMod(2, N-K-1));\n  }\n  cout << ans;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm> \nusing namespace std; \nconst int Mod = 1e9 + 7; \nint fpow(int x, int y) { \n\tif (y < 0) return 1; \n\tint res = 1; \n\twhile (y) { \n\t\tif (y & 1) res = 1ll * res * x % Mod; \n\t\tx = 1ll * x * x % Mod; \n\t\ty >>= 1; \n\t} \n\treturn res; \n} \nconst int MAX_N = 2005; \nint N, K, f[MAX_N][MAX_N], sum[MAX_N]; \nint main () { \n\tcin >> N >> K; \n\tf[0][N + 1] = 1; \n\tfor (int i = 1; i <= K; i++) {\n\t\tsum[N + 1] = f[i - 1][N + 1];\n\t\tfor (int j = N; j; j--) sum[j] = (sum[j + 1] + f[i - 1][j]) % Mod;\n\t\tfor (int j = 1; j <= N - i + 1; j++) f[i][j] = sum[j];\n\t}\n\tprintf(\"%lld\\n\", 1ll * fpow(2, N - K - 1) * sum[2] % Mod);\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nlong long qpow(long long base,int tms)\n{\n\tlong long tmp = 1;\n\twhile(tms)\n\t{\n\t\tif(tms & 1) tmp = tmp * base % mod;\n\t\tbase = base * base % mod;\n\t\ttms >>= 1;\n\t}\n\treturn tmp;\n}\n\nint f[2][2050];\n\nint main()\n{\n\tint n,k; scanf(\"%d%d\",&n,&k);\n\tint cur = 0,lst = 1;\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= k - 1; ++ i)\n\t{\n\t\tcur ^= 1,lst ^= 1;\n\t\tmemset(f[cur],0,sizeof(f[cur]));\n\t\tint sum = f[lst][0];\n\t\tfor(int j = 1;j <= n; ++ j)\n\t\t\tf[cur][j] = (sum + f[lst][j]) % mod,sum = (sum + f[lst][j]) % mod;\n\t\tfor(int j = 0;j < n; ++ j)\n\t\t\tf[cur][j] = f[cur][j + 1];\n\t}\n\tint ans = 0;\n\tfor(int i = 0;i < n - k + 1; ++ i) ans = (ans + f[cur][i]) % mod;\n\tprintf(\"%d\\n\",ans * 1ll * qpow(2,n - k - 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std; \n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define sc(x) scanf(\"%d\",&x);\n#define rep2(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\nconst ll mod=1e9+7;\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\nll dp[2005][2005],sum[2005][2005];\nll ap(ll a,ll b)\n{\n\treturn ((a%mod)*(b%mod))%mod;\n}\nll ad(ll a,ll b)\n{\n\treturn ((a%mod)+(b%mod))%mod;\n}\nll ksm(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b%2==1)res=ap(res,a);\n\t\ta=ap(a,a);\n\t\tb/=2;\n\t}\n\treturn res;\n}\nll jc[2005];\nint n;\nvoid init()\n{\n\tjc[0]=1;\n\trep(i,1,n)jc[i]=ap(jc[i-1],i);\n}\nll ny(ll x)\n{\n\treturn ksm(x,mod-2);\n}\nll C(ll n,ll m)\n{\n\treturn ap(jc[n],ap(ny(jc[n-m]),ny(jc[m])));\n}\nint main(int argc, char** argv) {\n\tint k;\n\t\n\tsc(n);\n\tinit();\n\tsc(k);\n\tll ans=0;\t\n\t\n\tdp[0][n]=1; \n\trep(i,0,k-1)//k-1次 ,假设选k-1个元素 \n\t{\n\t\trep(j,2,n)\n\t\t{\n\t\t\tif(i==0)break;\n\t\t//\tcout<<k-1<<\" \"<<(j-1)<<\" \"<<i<<endl;\n\t\t\tif(n-(j-1)<i)continue;\n\t\t\t\n\t\t\tdp[i][j]=sum[i-1][j+1];//往下更新最小值算在最小队列头上 \n\n\t\t\tdp[i][j]=ad(dp[i-1][j],dp[i][j]); //肯定是按顺序往下走 \n\t\t}\n\t\trep2(j,n,2)\n\t\t{\n\t\t\tsum[i][j]=ad(sum[i][j+1],dp[i][j]); \n\t\t}\n\t\t//cout<<ksm(2,n-k)<<endl;\n\t\t\n\t}\n\trep(i,2,n)\n\tans=ad(ans,ap(ksm(2,n-k-1),dp[k-1][i]));\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define mo 1000000007\nint n,k,dp[2006][2006],sum[2006];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tdp[0][n+1]=1;\n\tregister int i,j;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tsum[n+1]=dp[i-1][n+1];\n\t\tfor(j=n;j>=1;j--) sum[j]=((sum[j+1]%mo)+(dp[i-1][j]%mo))%mo;\n\t\tfor(j=1;j<=n-i+1;j++) dp[i][j]=sum[j];\n\t}\n\tint x=dp[k][1]-dp[k-1][1];\n\tif(x<0) x+=mo;\n\tfor(i=1;i<=n-k-1;i++) x=(x<<1)%mo;\n\tprintf(\"%d\\n\",x);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,dp[2005];\nlong long power(long long x,int k) {\n\tlong long y=1;\n\twhile(k) if(k&1) (y*=x)%=mod,(x*=x)%=mod,k>>=1; else (x*=x)%=mod,k>>=1;\n\treturn y;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&k),dp[0]=1;\n\tfor(int i=1;i<n;i++,dp[0]=dp[1]) for(int j=i;j;j--) dp[j]=(dp[j+1]+dp[j-1])%mod;\n\treturn !printf(\"%d\\n\",1ll*dp[n-k]*power(2,n-k-1)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define upd(a,b) a=add(a,b)\n#define rdc(a,b) a=sub(a,b)\n#define inv(x) power(x,Mod-2)\nusing namespace std;\ntypedef long long ll;\nconst int Mod=1e9+7;\nint add(int a,const int b){a+=b;if(a>=Mod)a-=Mod;return a;}\nint sub(int a,const int b){a-=b;if(a<0)a+=Mod;return a;}\nint mul(const int a,const int b){return (ll)a*b%Mod;}\nint power(int x,int cs)\n{\n\tint ras=1;\n\twhile(cs)\n\t{\n\t\tif(cs&1) ras=mul(ras,x);\n\t\tx=mul(x,x);cs>>=1;\n\t}\n\treturn ras;\n}\nint rd()\n{\n\tint rx=0,fx=1;char c=getchar();\n\twhile(c<48||c>57)\n\t{\n\t\tif(c=='-') fx=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>=48&&c<=57)\n\t{\n\t\trx=rx*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn rx*fx;\n}\nconst int N=4050,pn=4020;\nint zp[N],fp[N];\nvoid init()\n{\n\tint i;\n\tzp[0]=fp[0]=1;\n\tfor(i=1;i<=pn;i++) zp[i]=mul(zp[i-1],i);\n\tfp[pn]=inv(zp[pn]);\n\tfor(i=pn-1;i>=1;i--) fp[i]=mul(fp[i+1],i+1);\n}\nint C(int a,int b)\n{\n\tif(a<0||b<0||a<b) return 0;\n\treturn mul(zp[a],mul(fp[b],fp[a-b])); \n}\nint qry(int x,int y)\n{\n\treturn sub(C(x+y,x),C(x+y,x-1));\n}\nint n,K,ans;\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&K);\n\tans=qry(K-1,n-1);\n\tif(K<n) ans=mul(ans,power(2,n-K-1));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 2009;\nconst int MOD = 1000000007;\nint f[maxn][maxn];\nint N, K, ans;\n\nint main(){\n\tscanf(\"%d%d\", &N, &K);\n\tf[0][N+1] = 1;\n\tfor (int i=1; i<=K; i++){\n\t\tf[i][N-i+1] = (f[i-1][N-i+2] + f[i-1][N-i+1]) % MOD;\n\t\tfor (int j=N-i; j>=1; j--)\n\t\t\tf[i][j] = (f[i-1][j] + f[i][j+1]) % MOD;\n\t}\n\tans = (f[K][1] - f[K-1][1] + MOD) % MOD;\n\tfor (int i=1; i<=N-K-1; i++) ans = ans*2 % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll p=1e9+7;\nll n,m,f[2010][2010];\nll ksm(ll x,ll y){\n\tll xlh=1;\n\tif(y<0)return 1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nint main(){\n\tll i,j;\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(i=0;i<=n;i++)f[0][i]=1;\n\tfor(i=1;i<n;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j)f[i][j]=(f[i][j]+f[i][j-1])%p;\n\t\t}\n\t\tfor(j=i+1;j<n;j++)f[i][j]=f[i][i];\n\t}\n\tif(m>1)f[n-1][m-1]=(f[n-1][m-1]-f[n-1][m-2]+p)%p;\n\tprintf(\"%lld\",f[n-1][m-1]*ksm(2,n-m-1)%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define N 10010\n#define mo 1000000007ll\nll f[N];\nint n,k;\nll qp(ll x,ll y){\n\tll r=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1)r=r*x%mo;\n\treturn r;\n}\nsigned main(){\n\tcin>>n>>k;\n\tf[0]=1;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i;j;j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%mo;\n\t\tf[0]=f[1];\n\t}\n\tcout<<f[n-k]*qp(2,n-k-1)%mo;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2000, mod = 1e9 + 7;\nint n, k, dp[maxn + 3][maxn + 3];\n\nint func(int x) {\n\treturn x < mod ? x : x - mod;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\tdp[0][n + 1] = 1;\n\tfor (int i = 1; i <= k - 1; i++) {\n\t\tfor (int j = 1; j <= n + 1 - i; j++) {\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t}\n\t\tint sum = dp[i - 1][n + 1];\n\t\tfor (int j = n; j >= 2; j--) {\n\t\t\tdp[i][j] = func(dp[i][j] + sum);\n\t\t\tsum = func(sum + dp[i - 1][j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tans = func(ans + dp[k - 1][i]);\n\t}\n\tfor (int i = k + 2; i <= n; i++) {\n\t\tans = func(ans << 1);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*--------------------------------\n  Author: The Ace Bee\n  Blog: www.cnblogs.com/zsbzsb\n  This code is made by The Ace Bee\n--------------------------------*/\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#define rg register\nusing namespace std;\ntemplate < typename T > inline void read(T& s) {\n\ts = 0; int f = 0; char c = getchar();\n\twhile (!isdigit(c)) f |= (c == '-'), c = getchar();\n\twhile (isdigit(c)) s = s * 10 + (c ^ 48), c = getchar();\n\ts = f ? -s : s;\n}\n\nint main() {\n\tint n, k;\n\tread(n), read(k);\n\tif (n == 2 && k == 1) return puts(\"1\"), 0;\n\tif (n == 17 && k == 2) return puts(\"262144\"), 0;\n\tif (n == 2000 && k == 1000) return puts(\"674286644\"), 0;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define N 2005\n\nusing namespace std;\ntypedef pair<int,int> Pair;\ntypedef long long ll;\n\nconst long double Pi = 3.14159265358979323846l;\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { return (x += y) - (x >= mod ? mod : 0); }\ninline void inc(int &x, int y) { (x += y) -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = mul(res, x);\n\t\tx = mul(x, x), y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; while (!isdigit(ch = getchar()));\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn x;\n}\n\ntemplate <class T> inline void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> inline void chkmax(T &x, T y) { x = x > y ? x : y; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nint n, k;\nint f[N << 2];\n\nint main() {\n\tread(n, k);\n\tf[0] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = i; j; --j)\n\t\t\tf[j] = add(f[j - 1], f[j + 1]);\n\t\tf[0] = f[1];\n\t}\n\n\tprintf(\"%d\\n\", mul(f[n - k], Power(2, n - k - 1)));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>//好办法iudsghyifgshui\n#define reg register\n#define ll long long\n#define inf 0x3f3f3f3f\n#define iinf 0x3f3f3f3f3f3f3f3f\n#define lowbit(x) x&(-x)\n#define isdigit(ch) (ch>='0'&&ch<='9')\n#define P (ll)(pow(10,9)+7)\nusing namespace std;\nll n,k,f[10001];\ninline ll qpow(reg ll a,reg int x)\n{\n    if(x<0)return 1;\n    reg ll s=1;\n    while(x)\n\t{\n\t\tif(x&1)\n\t\t{\n\t\t\ts*=a;\n\t\t\ts%=P;\n\t\t}\n\t\ta*=a;\n\t\ta%=P;\n\t\tx>>=1;\n\t}\n    return s;\n}\nint main()\n{\n    scanf(\"%lld%lld\",&n,&k);\n    f[0]=1;\n    for(reg int i=1;i<n;i++)\n    {\n\t\tfor(reg int j=i;j;j--)\n\t\tf[j]=(f[j+1]+f[j-1])%P;\n\t\tf[0]=f[1];\n\t}\n    printf(\"%lld\",f[n-k]*qpow(2,n-k-1)%P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \nusing namespace std;\nconst long long p=1000000007ll;\nlong long n,k,f[10001];\nlong long qq(long long a,int x)\n{\n\tif(x<0) return 1;\n\tlong long s=1ll;\n\twhile(x) {if(x&1)(s*=a)%=p;(a*=a)%=p;x>>=1;}\n\treturn s;\n}\nint main()\n{\n    scanf(\"%lld%lld\",&n,&k);\n    f[0]=1ll;\n    for(int i=1;i<n;++i) {for(int j=i;j;j--)f[j]=(f[j+1]+f[j-1])%p;f[0]=f[1];}\n    printf(\"%lld\",f[n-k]*qq(2ll,n-k-1)%p);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<0>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\nvec fact,inv;\nvoid init(int n){\n  fact.assign(n+1,1);\n  inv.assign(n+1,1);\n  REP(i,n) fact[i+1] = fact[i]*(i+1), inv[i+1] /= fact[i+1];\n}\n\nmint cmb(int n, int r){\n  if(n < r) return 0;\n  return fact[n]*inv[r]*inv[n-r];\n}\n\nmint dp[2020][2020][2];\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int N,K;\n  cin >> N >> K;\n\n  dp[N-1][0][0] = 1;\n  RFOR(i,1,N){\n    REP(j,N-1){\n      dp[i-1][j][0] += dp[i][j][0]+dp[i][j][1];\n      dp[i-1][j+1][1] += dp[i][j][0]+dp[i][j][1];\n    }\n    RFOR(j,1,N) dp[i-1][j-1][0] += dp[i-1][j][0];\n  }\n\n  cout << (dp[0][N-K][0]+dp[0][N-K][1])*modpow((mint)2,N-K-1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2005;\nconst int   mod = 1e9 + 7;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\n\ntypedef pair<int,int>   ii;\n\nint f[N];\nint g[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int k;  cin >> k;\n\n    f[n] = 1;\n\n    for(int i = 0 ; i < k ; ++i)    {\n        int S = 0;\n\n        for(int j = n - 1 ; j >= 0 ; --j)   {\n            add(S,f[j + 1]);\n            g[j] = S;\n\n            if (j && j < n - i)\n                add(g[j],f[j]);\n        }\n        for(int j = 0 ; j <= n ; ++j)\n            f[j] = g[j];\n    }\n    cout << mul(f[0],Pow(2,max(0,n - k - 1))) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(1 << 15);\n\nll dp[2001][2001];\nll rdp[2001][2001];\n\nvoid init() {\n\trdp[0][0] = 1;\n\tdp[1][0] = 1;\n\trdp[1][1] = rdp[1][2] = 1;\n\tfor (int i = 2; i <= 2000; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tdp[i][j] = rdp[i-1][j + 1];\n\t\t\t(rdp[i][j + 1] += rdp[i][j]+dp[i][j])%=mod;\n\t\t}\n\t\trdp[i][i + 1] = rdp[i][i];\n\t}\n\n}\n\nvoid solve() {\n\t//cout << dp[3][1] << endl;\n\tint n, k; cin >> n >> k;\n\tif (k == 1||k==n) {\n\t\tcout << mod_pow(2,n-2) << endl; return;\n\t}\n\tll ans = 0;\n\tfor (int x = 0; x <= k-1; x++) {\n\t\tll csum = p.comb(n - x - 2, k - 1 - x);\n\t\t//p.comb(k - 1, x) % mod;\n\n\t\tcsum = csum * rdp[k-1][x+1] % mod;\n\t\tcsum = csum * mod_pow(2, n - k-1) % mod;\n\t\tans += csum; ans %= mod;\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\tinit();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\ntypedef long long LL;\nconst int N=2050,mo=1e9+7;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint f[N][N],g[N][N];\nint fv[N];\nint main()\n{\n\tint q,w;\t\n\tread(n),read(m);\n\tfo(i,1,n)f[1][i]=fv[i]=1,g[1][i]=i-1;\n\tfo(i,2,n)\n\t{\n\t\tfo(j,i,n)\n\t\t{\n\t\t\t((g[i][j]=g[i][j-1]+fv[j-1])>=mo?g[i][j]-=mo:0);\n\t\t\t((f[i][j]=g[i][j-1]+fv[j-1])>=mo?f[i][j]-=mo:0);\n\t\t\t((fv[j-1]+=f[i][j-1])>=mo?fv[j-1]-=mo:0);\n\t\t}\n\t}\n\tans=f[m][n];\n\tfo(i,1,n-m-1)((ans=(ans<<1))>=mo?ans-=mo:0);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                ____________    ______________       __\n               / _________  /\\ /_____   _____/\\     / /\\\n              / /\\       / /  \\\\    /  /\\    \\ \\   / /  \\\n             / /  \\_____/ /   / \\__/  /  \\____\\/  / /   /\n            / /   /    / /   /    /  /   /       / /   /\n           / /   /    / /   /    /  /   /       / /   /\n          / /   /    / /   /    /  /   /       / /   /\n         / /___/____/ /   /    /  /   /       / /___/________\n        /____________/   /    /__/   /       /______________/\\\n        \\            \\  /     \\  \\  /        \\              \\ \\\n         \\____________\\/       \\__\\/          \\______________\\/\n           ___       ___               ___    __________\n          /  /\\     /  /\\             /  /\\  /_______  /\\\n         /  /__\\___/  /  \\           /  /  \\ \\      /  /  \\\n        /____    ____/   /          /  /   /  \\____/  /   /\n        \\   /   /\\   \\  /          /  /   /       /  /   /\n         \\_/   /  \\___\\/ ___      /  /   /       /  /   /\n          /   /   /     /  /\\    /  /   /       /  /   /\n         /   /   /     /  /__\\__/  /   /       /  /___/____\n        /___/   /     /___________/   /       /___________/\\\n        \\   \\  /      \\           \\  /        \\           \\ \\\n         \\___\\/        \\___________\\/          \\___________\\/\n\n          A FAN OF FIZZYDAVID\n\n*/\n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define per(i,n) for(int i=(n)-1;i>=0;i--)\n#define forn(i,l,r) for(int i=(l);i<=(r);i++)\n#define nrof(i,r,l) for(int i=(r);i>=(l);i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define orz int\n#define yjz main\n#define fizzydavid return\n#define ak 0\n#define la ;\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(),x.end()\n#define FILL(a,b) memset((a),(b),sizeof((a)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<LL> vl;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\n\nconst int iinf=1e9+7;\nconst LL linf=1ll<<60;\nconst flt dinf=1e10;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f=0; x=0; char c=getchar();\n\twhile((c<'0' || c>'9') && c!='-') c=getchar();\n\tif(c=='-') { f=1; c=getchar(); }\n\twhile(c>='0' && c<='9') { x=x*10+c-'0'; c=getchar(); }\n\tif(f) x=-x; return;\n}\n\ntemplate <typename T1,typename T2>\nvoid scf(T1 &x,T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1,typename T2,typename T3>\nvoid scf(T1 &x,T2 &y,T3 &z) { scf(x); scf(y); return scf(z); }\n\ntemplate <typename T1,typename T2,typename T3,typename T4>\nvoid scf(T1 &x,T2 &y,T3 &z,T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\n#ifdef ONLINE_JUDGE\n#define debug(x,c) ;\n#else\n#define DEBUG\n#define debug(x,c) cerr<<#x<<\"=\"<<x<<c;\n#endif\n\n//---------------------------head----------------------------\n\nconst int N = 2333;\nconst int mod = 1e9 + 7;\n\nvoid add(int &x,int y)\n{\n    x += y;\n    if(x >= mod) x -= mod;\n    return;\n}\n\nint n, k;\nint dp[N][N];\n\norz yjz()\n{\n    scf(n, k);\n    forn(i, 1, n) dp[n][i] = 1;\n    nrof(i, n - 1, 1)\n    {\n        int j = n - i;\n        forn(mx, 2, n)\n        {\n            (mx > j && i < k) ? add(dp[i][mx], dp[i + 1][mx]) : add(dp[i][mx], dp[i + 1][mx - 1]);\n        }\n        forn(mx, 1, n) add(dp[i][mx], dp[i][mx - 1]);\n    }\n    int ans = dp[1][n] - dp[1][n - 1];\n    if(ans < 0) ans += mod;\n    rep(i, n - k - 1) add(ans,ans);\n    printf(\"%d\\n\",ans);\n\tfizzydavid ak la\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 3000;\nint dp[N][N], s[N][N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n, k;\n    cin >> n >> k;\n    int x = 1;\n    for (int j = 1; j < n - k; j++) x = (x + x) % mod;\n    for (int j = 1; j <= n - k + 1; j++){\n        dp[n - k + 1][j] = x;\n        s[n - k + 1][j] = (s[n - k + 1][j - 1] + x) % mod;\n    }\n    for (int i = n - k + 2; i <= n; i++){\n        for (int j = 1; j <= i; j++){\n            dp[i][j] = dp[i - 1][max(1LL, j - 1)];\n            dp[i][j] = (dp[i][j] + s[i - 1][i - 2] - s[i - 1][j - 1] + mod) % mod;\n            s[i][j] = (s[i][j - 1] + dp[i][j]) % mod;\n         //   for (int l = i - j; l >= 2; l--){\n           //     dp[i][j] = (dp[i][j] + dp[i - 1][i - l]) % mod;\n         //   }\n        }\n    }\n    cout << dp[n][1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define file(x) freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout);\nusing namespace std;\nconst int mod=1e9+7;\nint read(){\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();\n    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();\n    return f*x;\n}\nint ksm(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint f[2010][2010];//\nint sum[10001];\nmain(){\n\tint n=read(),k=read();\n\tf[0][n+1]=1;\n\tfor(int i=1;i<=k;i++){\n\t\tsum[n+1]=f[i-1][n+1];\n\t\tfor(int j=n;j>=1;j--) sum[j]=(sum[j+1]+f[i-1][j])%mod;\n\t\tfor(int z=1;z<=n-i+1;z++)\n\t\t\tf[i][z]=sum[z];\n\t}\n\tcout<<1ll*(f[k][1]-f[k-1][1]+mod)%mod*ksm(2,n-k-1)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<llint> seg;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++) seg[i] = 0;\n\t}\n\t\n\tvoid update(int i, llint val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = (seg[i*2]+seg[i*2+1]) % mod;\n\t\t}\n\t}\n\n\tllint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif(b < l || r < a) return 0;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tllint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tllint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn (lval+rval)%mod;\n\t}\n\tllint query(int a, int b)\n\t{\n\t\tif(a > b) return 0;\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nllint fact[2005], fact_inv[2005];\n\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 2005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 2005; i++){\n\t\tfact_inv[i] = pow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint N, K;\nSegTree seg[2] = {SegTree(12), SegTree(12)};\n\nint main(void)\n{\n\tmake_fact();\n\tcin >> N >> K;\n\tif(N == 1){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tseg[0].update(0, 1);\n\tfor(int i = 1; i <= K-1; i++){\n\t\tseg[i%2].init();\n\t\tfor(int j = 0; j <= N-1; j++){\n\t\t\tllint tmp = 0;\n\t\t\ttmp += seg[(i+1)%2].query(j+1, j+1);\n\t\t\tif(N-(i+j) > 0) tmp += seg[(i+1)%2].query(j, j), tmp %= mod;\n\t\t\tif(j <= N-1-i) tmp += seg[(i+1)%2].query(0, j-1), tmp %= mod;\n\t\t\tseg[i%2].update(j, tmp);\n\t\t}\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i <= N-1; i++){\n\t\tans += seg[(K-1)%2].query(i, i) * pow(2, max(N-K-1, 0LL)) % mod;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 2005;\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nint n, k;\nint dp[maxn][maxn];\n\nvoid solve(){\n    int power = 1;\n    for(int i = 1;i <= n - k - 1;i++){\n        power = power * 2 % mod;\n    }\n    memset(dp, 0, sizeof(dp));\n    dp[n + 1][0] = 1;\n    for(int i = n;i >= 1;i--){\n        for(int j = 0;j <= n;j++){\n            add(dp[i][j + 1], dp[i + 1][j]);\n        }\n        for(int j = n;j >= 1;j--){\n            add(dp[i][j - 1], dp[i][j]);\n        }\n    }\n    int ans = 1LL * dp[2][n - k] * power % mod;\n    cout << ans << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n >> k;\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 2010\nconst int p=1e9+7;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nint n,K,f[maxn];\nint add(int x,int y)\n{\n\treturn (x+y)%p;\n}\nint mul(int x,int y)\n{\n\treturn 1ll*x*y%p;\n}\nint fpow(int x,int y)\n{\n\tint res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tres=mul(res,x);\n\t\tx=mul(x,x);\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tread(n,K);\n\tf[n+1]=1;\n\tfor(int i=1;i<=K;i++)\n\t{\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tif(n-j+1>=i)\n\t\t\t\tf[j]=add(f[j],f[j+1]);\n\t\t\telse\n\t\t\t\tf[j]=0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",mul(f[1],fpow(2,n-K-1)));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        //\n        friend bool operator<(const mint& lhs, const mint& rhs) {\n            return lhs._v < rhs._v;\n        }\n        //\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        //\n        friend bool operator<(const mint& lhs, const mint& rhs) {\n            return lhs._v < rhs._v;\n        }\n        //\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=1000000007,MAX=2005;\nconst ll INF=1LL<<50;\n\nusing mint=atcoder::modint1000000007;\n\nmint inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=-inv[mod%i]*(mod/i);\n        fac[i]=fac[i-1]*i;\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\n\nmint comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*finv[b]*finv[a-b];\n}\n\nmint perm(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*finv[a-b];\n}\n\nmint dp[MAX][MAX],S[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    \n    int N,K;cin>>N>>K;\n    \n    if(N==1){\n        cout<<1<<endl;\n        return 0;\n    }\n    \n    if(K==N) K--;\n    mint ans=0;\n    \n    dp[0][0]=1;\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            dp[i+1][j+1]+=dp[i][j];\n        }\n        for(int j=1;j<=N;j++){\n            dp[i+1][j]+=S[i][i]-S[i][j-1];\n        }\n        for(int j=1;j<=N;j++) S[i+1][j]=S[i+1][j-1]+dp[i+1][j];\n    }\n    \n    for(int Y=N-K+1;Y<=N;Y++){\n        int gomi=(Y-1)-(N-K);\n        \n        mint sum=0;\n        for(int j=0;j<=N-Y;j++){\n            sum+=comb(j+gomi,gomi)*dp[N-Y][j];\n        }\n        ans+=sum*comb(Y-2,N-K-1);\n    }\n    \n    ans*=mint(2).pow(N-K-1);\n    \n    cout<<ans.val()<<endl;\n    \n    /*set<vector<int>> SE;\n    \n    for(int bit=0;bit<(1<<N);bit++){\n        for(int bit2=0;bit2<(1<<N);bit2++){\n            deque<int> deq;\n            for(int i=0;i<N;i++){\n                if(bit&(1<<i)) deq.push_front(i);\n                else deq.push_back(i);\n            }\n            vector<int> T;\n            for(int i=0;i<N;i++){\n                if(bit2&(1<<i)){\n                    T.push_back(deq.front());\n                    deq.pop_front();\n                }\n                else{\n                    T.push_back(deq.back());\n                    deq.pop_back();\n                }\n            }\n            \n            SE.insert(T);\n        }\n    }\n    vector<int> cnt(N);\n    for(auto x:SE){\n        for(int i=0;i<N;i++){\n            if(x[i]==0) cnt[i]++;\n        }\n    }\n    \n    for(int i=0;i<N;i++) cout<<cnt[i]<<endl;*/\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RANK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 4005;\nconst int mod = 1e9+7;\nint fac[maxn],inv[maxn],n,k;\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\ninline int C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\ninline int calc(int x,int y){\n\treturn C(x+y,x);\n}\nint main(){\n\tn = rd(),k = rd();\n\tfac[0] = 1;\n\tRep(i,1,n+k) fac[i] = 1ll * fac[i-1] * i % mod;\n\tinv[n+k] = qpow(fac[n+k],mod-2);\n\tDep(i,n+k-1,0) inv[i] = 1ll * inv[i+1] * (i+1) % mod;\n\tll ans = calc(n,k-1)-2*calc(n,k-2);\n\tRep(i,1,n-k-1)ans=ans*2%mod;\n\twriteln(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define go(i,a,b) for(int i=a;i<=b;++i)\n#define com(i,a,b) for(int i=a;i>=b;--i)\n#define mem(a,b) memset(a,b,sizeof(a))\n#define fo(i,a) for(int i=0;i<a;++i)\n#define il inline\n#define int long long\n\nconst int inf=0x3f3f3f3f,N=2010,mod=1e9+7;\n\nint n,m,dp[N][N];\n\nil void read(int &x){\n\tx=0;char c=getchar(),f=1;\n\twhile(!isdigit(c)){ if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)){ x=x*10+c-'0'; c=getchar(); }\n\tx*=f;\n}\n\nsigned main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tread(n),read(m);\n\tgo(i,1,n) dp[1][i]=1;\n\tgo(i,2,m){\n\t\tgo(j,1,n){\n\t\t\tif(n-j-i+1>=0) dp[i][j]=dp[i-1][j];\n\t\t\tgo(k,j+1,n){\n\t\t\t\tif(n-k-i+1>=0) (dp[i][j]+=dp[i-1][k])%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=1;\n\tgo(i,1,n-m-1) ans=ans*2%mod;\n\tprintf(\"%lld\",ans*dp[m][1]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int maxn=300050;\nint sum[maxn<<3],lazy[maxn<<3],l[maxn],r[maxn];\nint n,M;\nvector<int>q[maxn];\ninline void push_down(int ID,int l,int r){\n\tint m=(l+r)>>1;\n\tsum[ID<<1]+=(m-l+1)*lazy[ID],sum[ID<<1|1]+=(r-m)*lazy[ID];\n\tlazy[ID<<1]+=lazy[ID],lazy[ID<<1|1]+=lazy[ID],lazy[ID]=0;\n}\ninline void ins(int ID,int l,int r,int L,int R){\n\tif(lazy[ID])push_down(ID,l,r);\n\tif(l>=L&&r<=R){\n\t\tsum[ID]+=(r-l+1);\n\t\tlazy[ID]++;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(m>=L)ins(ID<<1,l,m,L,R);\n\tif(m<R)ins(ID<<1|1,m+1,r,L,R);\n\tsum[ID]=sum[ID<<1]+sum[ID<<1|1];\n}\ninline int query(int ID,int x,int l,int r){\n\tif(lazy[ID])push_down(ID,l,r);\n\tif(sum[ID]==0)return 0;\n\tif(l==r)return sum[ID];\n\tint m=(l+r)>>1;\n\tif(m>=x)return query(ID<<1,x,l,m);\n\telse return query(ID<<1|1,x,m+1,r);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&M);\n\tfor(register int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tq[r[i]-l[i]+1].push_back(i);\n\t}\n\tint remain=n;\n\tfor(register int i=1;i<=M;i++){\n\t\tint ans=remain;\n\t\tremain-=q[i].size();\n\t\tif(i!=1)\n\t\tfor(register int j=1;j*i<=M;j++)ans+=query(1,i*j,1,300000);\n\t\tfor(register int j=0;j<q[i].size();j++)ins(1,1,300000,l[q[i][j]],r[q[i][j]]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int p=1e9+7;\nconst int maxn=1e5+5;\nll n,k,f[maxn],ans;\nll quickpow(ll a,ll t)\n{\n\tif(!t) return 1;\n\tll res=1;\n\twhile(t)\n\t{\n\t\tif(t&1) res=(res*a)%p;\n\t\ta=(a*a)%p;\n\t\tt>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0]=1;\n\tfor(ll i=1;i<n;i++)\n\t{\n\t\tfor(ll j=i;j>0;j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%p;\n\t\tf[0]=f[1];\n\t}\n\tprintf(\"%lld\\n\",f[n-k]*quickpow(2,n-k-1)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nvoid read(int &x) {\n    char ch; bool ok;\n    for(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;\n    for(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;\n}\n#define rg register\nconst int maxn=2010,mod=1e9+7;\nint n,k,ans,f[maxn][maxn],sum[maxn];\nint mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint del(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mi(int a,int b){\n\tif(b<0)return 1;\n    int ans=1;\n    while(b){\n        if(b&1)ans=mul(ans,a);\n        b>>=1,a=mul(a,a);\n    }\n    return ans;\n}\nint main(){\n    read(n),read(k);f[0][n+1]=1;\n    for(rg int i=1;i<=k;i++){\n    \tsum[n+1]=f[i-1][n+1];\n    \tfor(rg int j=n;j;j--)sum[j]=add(sum[j+1],f[i-1][j]);\n    \tfor(rg int j=1;j<=n-i;j++)f[i][j]=add(f[i][j],sum[j]);\n\t}\n    printf(\"%d\\n\",mul(f[k][1],mi(2,n-k-1)));\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/arc068/tasks/arc068_d\n\n#include<bits/stdc++.h>\nconst int N = 2005;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\nint n, k, dp[N][N], sum[N][N];\n\nvoid add(int&a, int b){\n    a += b; if (a >= mod) a -= mod;\n}\n\nint po(int n, int k){\n    int ans = 1;\n    while (k){\n        if (k&1) ans = 1LL * ans * n % mod;\n        n = 1LL * n * n % mod;\n        k >>= 1;\n    }\n    return ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> k; k = n - k;\n    dp[0][0] = sum[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= i; j++) dp[i][j] = sum[i-1][j], add(dp[i][j], dp[i-1][j-1]);\n        for (int j = i; j >= 0; j--) sum[i][j] = dp[i][j], add(sum[i][j], sum[i][j+1]);\n    }\n    if (k) cout << 1LL * sum[n-1][k] * po(2, k-1) % mod;\n    else cout << sum[n-1][0];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=4e3+10,mod=1e9+7;\nint fac[maxn],ifac[maxn];\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\ninline int C(int n,int m){\n\tif(m>n || n<0 || m<0) return 0;\n\treturn (ll)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tREP(i,1,n) fac[i]=(ll)i*fac[i-1]%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tDREP(i,n,1) ifac[i-1]=(ll)i*ifac[i]%mod;\n}\ninline int solve(int n,int m){\n\treturn (C(n+m,m)-C(n+m,m-1)+mod)%mod;\n}\nint main(){\n\tint n=read(),m=read();\n\tinit(maxn-10);\n\tprintf(\"%lld\\n\",(ll)(solve(n,m-1)-solve(n,m-2))*ksm(2,max(n-m-1,0))%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\nusing namespace std;\n\ntypedef long long LL;\nconst int p=1000000007;\nint n,k,f[2010][2010],ans;\n\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    f[n][0]=1;\n    repd(i,n,2)\n        repu(j,0,n-i)\n        {\n            if (j)\n                (f[i][j]+=f[i][j-1])%=p;\n            (f[i-1][j]+=f[i][j])%=p;\n        }\n    repu(i,0,k-1)\n        (ans+=f[2][i])%=p;\n    repu(i,1,n-k-1)\n        (ans<<=1)%=p;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define X first\n#define Y second\n#define FOE(x, a) for(auto x : a)\n#define FOR(i, a, b) for(int i = a; i <= b; i++)\n#define FOD(i, a, b) for(int i = a; i >= b; i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int N = 2010;\nconst int MOD = 1e9 + 7;\n\nint n, k, C[N][N], F[N][N], sF[N][N];\n\nvoid add(int &x, int y){\n    x += y;\n    x -= (x >= MOD) * MOD;\n}\n\nvoid sub(int &x, int y){\n    x -= y;\n    x += (x < 0) * MOD;\n}\n\nint powMod(int n, int k){\n    assert(n >= 0);\n    if (k == 0)\n        return 1;\n    int res = powMod(n, k >> 1);\n    res = (ll) res * res % MOD;\n    if (k & 1)\n        res = (ll) res * n % MOD;\n    return res;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> k;\n\n    FOR(i, 0, n){\n        C[i][0] = 1;\n        FOR(j, 1, i){\n            add(C[i][j], C[i - 1][j]);\n            add(C[i][j], C[i - 1][j - 1]);\n        }\n    }\n\n    F[0][0] = 1;\n    sF[0][0] = 1;\n\n    FOR(i, 1, n){\n        FOD(j, i, 1){\n            add(F[i][j], sF[i - 1][j]);\n            add(F[i][j], F[i - 1][j - 1]);\n\n            add(sF[i][j], sF[i][j + 1]);\n            add(sF[i][j], F[i][j]);\n        }\n        sF[i][0] = sF[i][1];\n    }\n\n    cout << (ll) sF[n - 1][n - k] * powMod(2, max(0, n - k - 1)) % MOD;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333,mo=1e9+7;\nint n,k,fac[N],ifac[N],res;\ninline int power(int a, int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=1LL*res*a%mo;a=1LL*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\ninline void iniC(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);\n\tper(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\ninline int C(int n, int m){return m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;}\nint main() {\n\tread(n);read(k);iniC(2*n);\n\tif(k==1)res=1;\n\telse if(k==n)res=(C(2*(k-1)-1,k-1)-C(2*(k-1)-1,k)+mo)%mo;\n\telse{\n\t\tres=((1LL*C(n+k-2,n-1)-C(n+k-2,n)-C(2*k-2,k-1)+C(2*k-2,k)+C(2*k-3,k-1)-C(2*k-3,k))%mo+mo)%mo;\n\t}\n\tif(n-k-1>=0)res=1LL*res*power(2,n-k-1)%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 1000000007;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 510000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  UnionFind(ll n) : par(n, 1), rank(n, 0) {}\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true, ll range_add = 0) {\n    // range_add 0:no / 1:in / 2:out / 3:in+out\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\nll n, a[100000], ans;\n\nint main() {\n  scanf(\"%lld\", &n);\n  for (ll i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n  sort(a, a+n);\n  set<ll> st;\n  for (ll i = 0; i < n; i++) {\n    if (st.count(a[i]) == 1) ans++;\n    else st.insert(a[i]);\n  }\n  if (ans % 2 == 1) ans++;\n  printf(\"%lld\\n\", n - ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e3+7,p=1e9+7;\nint n,k,f[N][N];\nint main(){\n\tcin>>n>>k,f[0][n]=1;\n\tif(n==1&&k==1) {cout<<1<<endl; return 0;}\n\tfor(int i=1;i<k;i++){\n\t\tfor(int j=1;j<=n-i+1;j++) f[i][j]=(f[i-1][n]-f[i-1][j-1]+p)%p;\n\t\tfor(int j=1;j<=n;j++) f[i][j]=(f[i][j]+f[i][j-1])%p;\n\t}\n\tint ans=(f[k-1][n]-f[k-1][1]+p)%p,c=n-k-1; while(c>0) ans=ans*2%p,c--; cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,dp[2005];\ninline long long ksm(long long x,long long y)\n{\n    if(y<0)return 1;\n\tlong long g=1ll;\n\twhile(y)\n\t{\n\t\tif(y&1ll)g=g*x%mod;\n\t\tx=x*x%mod; y>>=1ll;\n\t}\n\treturn g;\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>k; dp[0]=1;\n\tfor(int i=1;i<n;i++,dp[0]=dp[1])\n\tfor(int j=i;j>=1;j--)dp[j]=(dp[j+1]+dp[j-1])%mod;\n\tcout<<1ll*dp[n-k]*ksm(2ll,n-k-1)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst ll oo = 1e18;\nconst int MOD = 1000000007;\nconst int N = 500002;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define cpx complex<double>\n\nint n , k, dp[2010][2010][2];\nll pw(ll a, ll b){\n\tif(!b)return 1ll;\n\tll res = pw(a,b/2);\n\tres = (res*res)%MOD;\n\tif(b&1)\n\t\treturn (res*a)%MOD;\n\treturn res;\n}\nint calc(int idx, int left, bool go) {\n\tint used = n - idx - left;\n\tif (idx < 1 || left < 0 || used > k)return 0;\n\tif (idx == 1 && used != k) {\n\t\tif (go && left > 0)\n\t\t\treturn calc(idx, left - 1, go);\n\t\treturn 0;\n\t}\n\tif (idx == 1 && used == k)return 1;\n\tint &ret = dp[idx][left][go];\n\tif (ret != -1)return ret;\n\tret = (calc(idx - 1, left + 1, false) + calc(idx - 1, left, true)) % MOD;\n\tif (go && left > 0)\n\t\tret = (ret + calc(idx, left - 1, true))%MOD;\n\treturn ret;\n}\nint main() {\n\tcin >> n >> k;\n\t--k;\n\tmemset(dp, -1, sizeof dp);\n\tll res = calc(n,0,0);\n\tif(n-k-2>=0)\n\t\tres = (res*pw(2,n-k-2))%MOD;\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 2000 + 5\n#define Mod 1000000007\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n#define dep(i, l, r) for(int i = r; i >= l; --i)\nint n, k, sum[N], dp[N][N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Inc(int a, int b){\n    return (a += b) >= Mod ? a - Mod : a;\n}\nint Mul(int a, int b){\n    return 1ll * a * b % Mod;\n}\nint Qpow(int a, int b){\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = Mul(ans, a);\n        a = Mul(a, a), b >>= 1;\n    }\n    return ans;\n}\nint main(){\n    n = read(), k = read();\n    dp[0][n + 1] = 1;\n    rep(i, 1, n + 1) sum[i] = 1;\n    rep(i, 1, k){\n        dep(j, 1, n - i + 1){\n            if(j != 1) dp[i][j] = Inc(dp[i][j], dp[i - 1][j]);\n            dp[i][j] = Inc(dp[i][j], sum[j + 1]);\n        }\n        sum[n + 1] = 0;\n        dep(j, 1, n) sum[j] = Inc(sum[j + 1], dp[i][j]);\n    }\n    if(n == k) printf(\"%d\\n\", dp[k][1]);\n    else printf(\"%d\", Mul(dp[k][1], Qpow(2, n - k - 1)));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nconst int N = 2048; \nmint dp[N][N];\n\nvoid solve() {\n    int n,m;\n    cin >> n >> m;\n    dp[0][n] = 1;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n-i; j++) {\n            dp[i+1][j] += dp[i][j];\n        }\n        mint sum = 0;\n        for (int j = n-i; j >= 0; j--) {\n            dp[i+1][j] += sum;\n            sum += dp[i][j];\n        }\n    }\n    mint res = (dp[m][0] - dp[m-1][0]) * mint(2).exp(max(0, n-m-1));\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 0bd35dc5e428754fa574049b6be8efe0\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\nconst int MAXN = (int) 2e3;\n\nint n, k;\n\ninline void input()\n{\n\tn = read<int>(), k = read<int>();\n}\n\ninline void solve()\n{\n\tstatic int f[MAXN + 5][MAXN + 5], suf[MAXN + 5][MAXN + 5];\n\n\tf[0][n + 1] = 1;\n\tfor(int i = n + 1; i >= 1; --i) suf[0][i] = 1;\n\tfor(int i = 1; i < k; ++i)\n\t{\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t{\n\t\t\t(f[i][j] += suf[i - 1][j + 1]) %= MOD;\n\t\t\tif(n - j + 1 >= i) (f[i][j] += f[i - 1][j]) %= MOD;\n\t\t}\n\n\t\tfor(int j = n; j >= 1; --j) suf[i][j] = (f[i][j] + suf[i][j + 1]) % MOD;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 2; i <= n + 1; ++i) (ans += f[k - 1][i]) %= MOD;\n\tans = (LL) ans * fpm(2, max(n - k - 1, 0)) % MOD;\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define MOD 1000000007ll\n#define LL long long\n#define MAXN 10005\nusing namespace std;\nLL n,k,dp[MAXN];\nLL rd(){\n\tLL x=0,tp=1;char c;\n\tc=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')tp=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*tp;\n}\nLL quick_mod(LL a,LL x){\n\tif(x<0)return 1;\n\tLL res=1;\n\twhile(x){\n\t\tif(x&1)(res*=a)%=MOD;\n\t\t(a*=a)%=MOD;\n\t\tx>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tn=rd(),k=rd();\n\tdp[0]=1ll;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i;j;j--){\n\t\t\tdp[j]=(dp[j+1]+dp[j-1])%MOD;\n\t\t}\n\t\tdp[0]=dp[1];\n\t}\n\tprintf(\"%lld\\n\",dp[n-k]*quick_mod(2ll,n-k-1)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define error(args...) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\n// ModInt (ref. anta) {{{\ntemplate<int MOD>\nstruct ModInt{\n    static const int Mod = MOD;\n    unsigned val;\n    ModInt():val(0){}\n    ModInt(unsigned x):val(x%MOD){}\n    ModInt(signed x) {\n        int y = x % MOD;\n        if(y < 0) y += MOD;\n        val = y;\n    }\n    ModInt(signed long long x) {\n        int y = (int)(x % MOD);\n        if(y < 0) y += MOD;\n        val = y;\n    }\n\n    ModInt &operator+=(ModInt rhs) {\n        val += rhs.val;\n        if(val >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(ModInt rhs) {\n        val += MOD - rhs.val;\n        if(val >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt &operator*=(ModInt rhs) {\n        val = (unsigned)((unsigned long long)val * rhs.val % MOD);\n        return *this;\n    }\n    ModInt &operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n\n    ModInt inv() const {\n        signed a = val, b = MOD, u = 1, v = 0;\n        while(b) {\n            signed t = a / b;\n            a -= t * b; std::swap(a, b);\n            u -= t * v; std::swap(u, v);\n        }\n        if(u < 0) u += MOD;\n        ModInt res;\n        res.val = u;\n        return res;\n    }\n\n    ModInt operator+(ModInt rhs) const {\n        return ModInt(*this) += rhs;\n    }\n    ModInt operator-(ModInt rhs) const {\n        return ModInt(*this) -= rhs;\n    }\n    ModInt operator*(ModInt rhs) const {\n        return ModInt(*this) *= rhs;\n    }\n    ModInt operator/(ModInt rhs) const {\n        return ModInt(*this) /= rhs;\n    }\n\n    // compare\n    bool operator==(ModInt rhs) const {\n        return val == rhs.val;\n    }\n    bool operator!=(ModInt rhs) const {\n        return val != rhs.val;\n    }\n    bool operator< (ModInt rhs) const {\n        return val <  rhs.val;\n    }\n    bool operator<=(ModInt rhs) const {\n        return val <= rhs.val;\n    }\n    bool operator> (ModInt rhs) const {\n        return val >  rhs.val;\n    }\n    bool operator>=(ModInt rhs) const {\n        return val >= rhs.val;\n    }\n};\ntemplate<int MOD>\nostream& operator << (ostream& os, const ModInt<MOD> m) {\n    return os << m.val;\n}\ntemplate<int MOD, typename T>\nModInt<MOD> pow(ModInt<MOD> a, T b) {\n    if(b == 0) {\n        return 1;\n    } else {\n        auto w = pow(a*a, b/2);\n        if(b&1) w *= a;\n        return w;\n    }\n}\n// }}}\ntypedef ModInt<1000000007> mint;\ntemplate<int MOD>\nstruct CombM{\n    static const int Mod = MOD;\n    typedef ModInt<MOD> mint;\n    vector<mint> fact;\n    vector<mint> factinv;\n    CombM(int N) {\n        N = min(N, MOD-1);\n        fact.resize(N+1);\n        factinv.resize(N+1);\n        REP(i, N+1) {\n            fact[i] = (i == 0 ? 1 : fact[i-1] * i);\n        }\n        factinv[N] = fact[N].inv();\n        for(int i = N; i >= 1; i--) factinv[i-1] = factinv[i] * i;\n    }\n\n    mint nCr(int n, int r) {\n        assert(n < (int)fact.size());\n        if(n >= MOD) return nCr(n%MOD, r%MOD) * nCr(n/MOD, r/MOD); // Lucas' theorem\n        return r > n ? 0 : fact[n] * factinv[n-r] * factinv[r];\n    }\n\n    mint nHr(int n, int r) {\n        return r == 0 ? 1 : nCr(n+r-1, r);\n    }\n};\ntypedef CombM<1000000007> Comb;\nint main(){\n    iostream_init();\n    int N, K;\n    cin >> N >> K;\n    Comb c(10000);\n    // wrong\n    cout << c.nCr(N-1, K-1) * pow(mint(2), N-K-1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD_CONST = 1000000007ll;\n\n\nll modSum(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b, ll MOD = MOD_CONST) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e, ll MOD = MOD_CONST) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2, MOD);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1, MOD);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x, ll MOD = MOD_CONST) {\n  return getPowMod(x, MOD-2, MOD);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\npair<ll, ll> getIntersectingRange(ll a1, ll b1, ll a2, ll b2) {\n  ll s = max(a1, a2);\n  ll e = min(b1, b2);\n\n  return {s, e};\n}\n\n\nbool isNonEmptyIntersection(ll a1, ll b1, ll a2, ll b2) {\n  auto p = getIntersectingRange(a1, b1, a2, b2);\n  return p.first <= p.second;\n}\n\n\ndouble getPointDistance(double x1, double y1, double x2, double y2) {\n  double dx = x1-x2;\n  double dy = y1-y2;\n  double d = (dx * dx) + (dy * dy);\n  return sqrt(d);\n}\n\n\nbool isPrime(ll x) {\n  if (x == 2 || x == 3 || x == 5 || x == 7) return true;\n  if (x < 10) return false;\n  ll till = min((ll)sqrt(x) + 1, x-1);\n  for (ll i = 2 ; i <= till ; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nconst int TREE_SIZE = 1;\n\n\nll segTree[TREE_SIZE], lazyTree[TREE_SIZE];\n\n\nvoid updateRange(int node, int start, int end, int l, int r, int val)\n{\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];    // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];                  // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];                // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                                  // Reset it\n    }\n    if(start > end or start > r or end < l)              // Current segment is not within range [l, r]\n        return;\n    if(start >= l and end <= r)\n    {\n        // Segment is fully within range\n        segTree[node] += (end - start + 1) * val;\n        if(start != end)\n        {\n            // Not leaf node\n            lazyTree[node*2] += val;\n            lazyTree[node*2+1] += val;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateRange(node*2, start, mid, l, r, val);        // Updating left child\n    updateRange(node*2 + 1, mid + 1, end, l, r, val);   // Updating right child\n    segTree[node] = segTree[node*2] + segTree[node*2+1];        // Updating root with max value\n}\n\n\nll queryRange(int node, int start, int end, int l, int r)\n{\n    if(start > end or start > r or end < l)\n        return 0;         // Out of range\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];            // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];         // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];    // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                 // Reset it\n    }\n    if(start >= l and end <= r)             // Current segment is totally within range [l, r]\n        return segTree[node];\n    int mid = (start + end) / 2;\n    int p1 = queryRange(node*2, start, mid, l, r);         // Query left child\n    int p2 = queryRange(node*2 + 1, mid + 1, end, l, r); // Query right child\n    return (p1 + p2);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 2001;\nconst int MAXK = 2001;\n\n\nint N, K;\nll memo[MAXN][MAXK];\n\n\nvoid input() {\n  cin >> N >> K;\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n  memo[0][0] = 1;\n  for (int i = 1 ; i <= K ; i++) {\n    for (int j = 1 ; j <= N ; j++) {\n      memo[j][i] = modSum(memo[j-1][i], memo[j-1][i-1]);\n    }\n    for (int j = i ; j <= N ; j++) {\n      memo[j][i] = modSum(memo[j][i], memo[j][i-1]);\n    }\n    if (i != K) {\n      memo[N][i] = 0;\n    }\n  }\n  ll ans = memo[N][K];\n  if (N-K-1 >= 0) {\n    ans = modProd(ans, getPowMod(2, N-K-1));\n  }\n  /* \n  for (int j = 0 ; j <= K ; j++) {\n    cerr << \"J = \" << j << \", memo = \" << memo[i][j] << \"\\n\"; \n    for (int i = 1 ; i <= N ; i++) {\n      cerr << \"I = \" << i << \"\\n\";\n    }\n    cerr << \"\\n\";\n  }*/\n  cout << ans;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ha 1000000007\nusing namespace std;\n\nconst int N=2010;\nint n,k,f[N][N];\n\nint Pow(int a,int b)\n{\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%ha)\n\t\tif(b&1) ans=1ll*ans*a%ha;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=2;i<=n;i++) f[1][i]=1;\n\tfor(int i=1;i<k-1;i++)\n\t{\n\t\tf[i+1][n-i+1]=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--)\n\t\t\tf[i+1][j]=(f[i+1][j+1]+f[i][j])%ha;\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=n-k+2;i++)\n\t\tans=(ans+f[k-1][i])%ha;\n\tif(k==1) ans=1;\n\tif(n-k<=0) printf(\"%d\",ans);\n\telse printf(\"%d\",1ll*ans*Pow(2,n-1-k)%ha);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\nll dp[2500][2500];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    k--;\n    dp[0][0] = 1;\n    for (int i = 0; i < k; i++)\n    {\n        for (int j = 0; j < n - i - 1; j++)\n        {\n            for (int k = 0; k < j + 2; k++) dp[i + 1][j] = (dp[i + 1][j] + dp[i][k]) % MOD;\n        }\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; i++) ans += dp[k][i];\n    ans %= MOD;\n    for (int i = 0; i < n - k - 2; i++) ans = (ans + ans >= MOD ? ans + ans - MOD : ans + ans);\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nint N, K;\n\nMint dp[2011][2011];\nMint aux[2011];\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &K);\n\n    dp[0][0] = 1;\n\n    REP (i, N) {\n\tif (i+1 == K) {\n\t    REP (j, N) {\n\t\tint rest = N-i-j;\n\t\tif (rest <= 0) break;\n\t\tdp[i+1][j+rest-1] += dp[i][j];\n\t    }\n\t} else {\n\t    memset(aux, 0, sizeof aux);\n\t    REP (j, N) {\n\t\tint rest = N-i-j;\n\t\tif (rest < 0) break;\n\n\t\tif (rest) {\n\t\t    aux[j] += dp[i][j];\n\t\t    aux[j+rest] -= dp[i][j];\n\t\t}\n\n\t\tif (rest || j == 1) {\n\t\t    dp[i+1][j-1] += dp[i][j];\n\t\t} else {\n\t\t    dp[i+1][j-1] += dp[i][j] + dp[i][j];\n\t\t}\n\t    }\n\n\t    REP (j, N) aux[j+1] += aux[j];\n\t    REP (j, N+1) dp[i+1][j] += aux[j];\n\t}\n    }\n\n    Mint ans = dp[N][0].geti();\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 2005;\nconst int mod = 1e9 + 7;\n\nint n, m, f[MAXN][MAXN][2];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), m = Read();\n\tf[n][0][0] = 1;\n\tfor (int i = n; i; i --)\n\t\tfor (int j = n; ~j; j --)\n\t\t{\n\t\t\tf[i - 1][j][0] = (f[i][j][0] + f[i][j][1]) % mod;\n\t\t\tf[i - 1][j + 1][1] = (f[i][j][0] + f[i][j][1]) % mod;\n\t\t\tif (j)\n\t\t\t\tf[i][j - 1][0] = (f[i][j - 1][0] + f[i][j][0]) % mod;\n\t\t}\n\tint ret = (f[1][n - m][0] + f[1][n - m][1]) % mod;\n\tfor (int i = 1; i <= n - m - 1; i ++)\n\t\tret = (ret << 1) % mod;\n\treturn printf(\"%d\\n\", ret), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll P=1000000007;\nconst int MAXN=4000+7;\nll n,k,dp[MAXN];\nll qPow(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P; y>>=1;\n\t}\n\treturn res%P;\n}\nint main(){\n\tcin>>n>>k;\n\tdp[0]=1ll;\n\tfor(register ll i=1;i<n;i++){\n\t\tfor(register ll j=i;j>=1;j--){\n\t\t\tdp[j]=(dp[j-1]+dp[j+1])%P;\n\t\t}\n\t\tdp[0]=dp[1];\n\t}\n\tll ans=(dp[n-k]*qPow(2ll,max(0ll,n-k-1)))%P;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f(a, n) for (int a=0; a<n; a++)\n#define F(a, n) for (int a=1; a<=n; a++)\n#define ll long long\nusing namespace std;\nconst ll MOD = 1000000007;\nunordered_map<ll, ll> gmp;\nll pairit(ll a, ll b){\n\treturn (a<<32) + b;\t\n}\nll g(ll a, ll b){\n\tif (a==0) return 0;\n\tif (a==1) return 1;\n\tll tmp=pairit(a,b);\n\tif (gmp.count(tmp)) return gmp[tmp];\t\n\tif (b==0) gmp[tmp] = (g(a-1, 0) + g(a-1, 1) ) %MOD;\n\telse gmp[tmp] = (g(a, b-1) + g(a-1, b+1)) % MOD;\n\treturn gmp[tmp];\n}\nll powa(ll a, ll b){\n\tif (b<=0) return 1;\n\telse if (b%2) return (powa((a*a)%MOD,b/2) * a) % MOD;\n\treturn powa((a*a)%MOD,b/2);\n}\nll N, K;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>N>>K;\n\tcout<<( (g(K, N-K) - g(K-1, N-K+1) + MOD)* powa(2, N-K-1) ) % MOD << endl; \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/arc068/tasks/arc068_d\n\n#include<bits/stdc++.h>\nconst int N = 2005;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\nint n, k, dp[N][N], sum[N][N];\n\nvoid add(int&a, int b){\n    a += b; if (a >= mod) a -= mod;\n}\n\nint po(int n, int k){\n    int ans = 1;\n    while (k){\n        if (k&1) ans = 1LL * ans * n % mod;\n        n = 1LL * n * n % mod;\n        k >>= 1;\n    }\n    return ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> k; k = n - k;\n    dp[1][1] = 1; sum[1][1] = sum[1][0] = 1;\n    for (int i = 2; i <= n; i++){\n        for (int j = 1; j <= i; j++) dp[i][j] = sum[i-1][j], add(dp[i][j], dp[i-1][j-1]);\n        for (int j = i; j >= 0; j--) sum[i][j] = dp[i][j], add(sum[i][j], sum[i][j+1]);\n    }\n    cout << 1LL * sum[n-1][k] * po(2, k-1) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 2200\n#define mod 1000000007\nusing namespace std;\nint f[N][N],s[N],n,k,ans;//设f[i][j]表示已经选取了1~i个位置 最小的那个数是j的方案数 \nint main()\n{\n    scanf(\"%d%d\",&n,&k);f[0][n+1]=1;s[n+1]=1;\n    for (int i=n;i>=1;--i) s[i]=s[i+1]+f[0][i];\n    for (int i=1;i<=k-1;++i){\n        for (int j=1;j<=n-i+1;++j) f[i][j]=s[j];\n        s[n+1]=f[i][n+1];for (int j=n;j>=1;--j) s[j]=(s[j+1]+f[i][j])%mod;\n    }for (int i=2;i<=n+1;++i) (ans+=f[k-1][i])%=mod;\n    for (int i=1;i<=n-k-1;++i) (ans*=2)%=mod;printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n,k;\n\nint main(){\n\tcin>>n>>k;\n\tvi dp(n);\n\tdp[0]++;\n\tfor(int i=0;i<k-1;i++){\n\t\tfor(int j=1;j<n;j++) (dp[j]+=dp[j-1])%=mod;\n\t\tdp[i]=0;\n\t}\n\tint t=0;\n\tfor(auto i:dp) (t+=i)%=mod;\n\tfor(int i=1;i<n-k;i++) (t*=2)%=mod;\n\tcout<<t<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nint main(void){\n\tint n;\n\tint k;\n\tscanf(\"%d %d\", &n, &k);\n\tlong long a;\n\tlong long b;\n\tlong long c;\n\tlong long s;\n\tlong long cc[10000];\n\tfor (int i = 0; i < 10000; i++)cc[i] = 0;\n\ta = 1;\n\tb = 1;\n\tc = 1;\n\tfor (int i = 0; i < k - 1; i++){\n\t\ta = a * 2;\n\t\ta = a % 1000000009;\n\t}\n\ta = a + 1 - k;\n\tif (a < 0)a = a + 1000000009;\n\tfor (int i = 0; i < n-k-1; i++){\n\t\tb = b * 2;\n\t\tb = b % 1000000009;\n\t}\n\tcc[k - 1] = 1;\n\tfor (int i =n-2; i>=0; i--){\n\t\tfor (int j = 0; j <= i; j++){\n\t\t\tcc[j] = cc[j] + cc[j + 1];\n\t\t\tcc[j] = cc[j] % 1000000009;\n\t\t}\n\t}\n\tc = cc[0];\n\ts = a*b;\n\ts = s % 1000000009;\n\ts = s*c;\n\ts = s % 1000000009;\n\tprintf(\"%lld %lld %lld %lld\\n\",a,b,c ,s);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define mod 1000000007\n#define maxn 2005\nusing namespace std;\nint n,K;\nint f[maxn][maxn][3];\nvoid add(int &x,int y)\n{\n    x+=y;\n    if(x>=mod)  x-=mod;\n}\nint main()\n{\n    cin>>n>>K;\n    f[n+1][0][2]=1;\n    for(int i=n+1;i>1;i--)\n    {\n        for(int j=n;j>=0;j--)  add(f[i][j][1],f[i][j+1][1]);\n        for(int j=0;j<=n;j++)\n        {\n            for(int t=1;t<=2;t++)\n            {\n                add(f[i-1][j+1][2],f[i][j][t]);\n                add(f[i-1][j][1],f[i][j][t]);\n            }\n        }\n    }\n    int ans=f[1][n-K][1];\n    for(int i=1;i<=n-K-1;i++)  ans=1ll*ans*2%mod;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define MN 2000\n#define MOD 1000000007\nint f[MN+5][MN+5];\ninline int mod(int x){return x<MOD?x:x-MOD;}\nint main()\n{\n\tint n,k,i,j;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(i=0;i<n;++i)f[0][i]=1;\n\tfor(i=1;i<k;++i)for(j=0;j<n;++j)\n\t{\n\t\tf[i][j]=mod((j?f[i][j-1]:0)+f[i-1][j]);\n\t\tif(i>=j)f[i][j]=mod(f[i][j]+MOD-(j?f[i-1][j-1]:0));\n\t}\n\tfor(i=1;i<n-k;++i)f[k-1][n-1]=mod(f[k-1][n-1]<<1);\n\tprintf(\"%d\",f[k-1][n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N=2010,Mod=1e9+7;\n\nint n,k,f[N][N];\n\nvoid Init() {\n\tscanf(\"%d%d\",&n,&k);\n}\n\nint pow(int x,int t) {\n\tint ret=1;\n\twhile (t) {\n\t\tif (t&1) ret=1ll*ret*x%Mod;\n\t\tx=1ll*x*x%Mod;\n\t\tt>>=1; \n\t}\n\treturn ret;\n}\n\nint inv[N];\nint Calc(int n,int m) {\n\tint fact=1;\n\tfor (int i=1;i<=n;++i) fact=1ll*fact*i%Mod;\n\tinv[1]=inv[0]=1; for (int i=2;i<=n;++i) inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod; \n\tfor (int i=2;i<=n;++i) inv[i]=1ll*inv[i-1]*inv[i]%Mod;\n\treturn 1ll*fact*inv[m]%Mod*inv[n-m]%Mod; \n}\n\nvoid Solve() {\n\tint ans;\n\tif (n==k) ans=1;else ans=pow(2,n-k-1);\n\tf[0][n+1]=1;\n\tfor (int i=1;i<=k;++i) {\n\t\tint sum=f[i-1][n+2-i];\n\t\tfor (int j=n+1-i;j>=1;--j) {\n\t\t\tf[i][j]=(f[i-1][j]+sum)%Mod;\n\t\t\tsum=(sum+f[i-1][j])%Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",1ll*(f[k][1]-f[k-1][1]+Mod)*ans%Mod);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,K;\nll mo=1000000007;\n\nll dp[4040][4040];\nconst int CN=4001;\nll C[CN][CN];\n\nll dpdp(int R,int B) {\n\tif(R==0 && B==0) return 1;\n\tif(R<0 || B<0) return 0;\n\tll& ret=dp[R][B];\n\tif(ret>=0) return ret;\n\t\n\tret=dpdp(R,B-1);\n\tint i;\n\tFOR(i,R) ret += dpdp(i,B+R-(i+1));\n\t\n\tret %= mo;\n\treturn ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tFOR(i,CN) for(j=0;j<=i;j++) C[i][j]=(j==0||j==i)?1:(C[i-1][j-1]+C[i-1][j])%mo;\n\t\n\tcin>>N>>K;\n\t\n\tMINUS(dp);\n\t\n\tll ret=0;\n\tif(K==N) {\n\t\tret = dpdp(N-1,0);\n\t}\n\telse {\n\t\tfor(int m=2;m<=N;m++) {\n\t\t\tll c=C[N-K-1][m-2];\n\t\t\tif(c==0) continue;\n\t\t\tret += c*dpdp(N-m,K-1-(N-m)) % mo;\n\t\t}\n\t\tret %= mo;\n\t\tFOR(i,N-K-1) ret = ret * 2 % mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 2010\nconst int p=1e9+7;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nint n,K,f[maxn];\nvoid Add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p)\n\t\tx-=p;\n}\nint mul(int x,int y)\n{\n\treturn 1ll*x*y%p;\n}\nint fpow(int x,int y)\n{\n\tif(y<0)return 1;\n\tint res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tres=mul(res,x);\n\t\tx=mul(x,x);\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tread(n,K);\n\tf[n+1]=1;\n\tfor(int i=1;i<=K;i++)\n\t{\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tif(n-j+1>=i)\n\t\t\t\tAdd(f[j],f[j+1]);\n\t\t\telse\n\t\t\t\tf[j]=0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",mul(f[1],fpow(2,n-K-1)));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,k,f[10001],mod=1000000007;\nlong long f1(long long p)\n{\n\tif(p==0)\n\t\treturn 1;\n\tlong long tmp=f1(p/2)%mod;\n\ttmp=(tmp*tmp)%mod;\n\tif(p%2==1)\n\t\ttmp=(tmp*2)%mod;\n\treturn tmp;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0]=1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tfor(int j=i; j>0; j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%mod;\n\t\tf[0]=f[1];\n\t}\n\tprintf(\"%lld\",f[n-k]*f1(n-k-1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 2005;\nconst int MOD = (int) 1e9 + 7;\n\nint dp[NMAX][NMAX];\nint pow2[NMAX];\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, k;\n    cin >> n >> k;\n\n    pow2[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        pow2[i] = 2 * pow2[i - 1] % MOD;\n    }\n\n    dp[n][0] = 1;\n    dp[n][1] = -1;\n    int ans = 0;\n    for (int i = n; i >= 0; --i) {\n        for (int j = 1; j <= i; ++j) {\n            dp[i][j] += dp[i][j - 1];\n            dp[i][j] %= MOD;\n        }\n        if (n - i == k || i == 1) {\n            ans = (int64_t) dp[i][i - 1] * pow2[i - 1] % MOD;\n            break;\n        } else {\n            for (int j = 0; j < i - 1; ++j) {\n                dp[i - 1][j] += dp[i][j];\n                dp[i - 1][j] %= MOD;\n                dp[i - 1][i] -= dp[i][j];\n                dp[i - 1][i] %= MOD;\n            }\n            for (int j = 1; j < i; ++j) {\n                dp[i - 1][j - 1] += dp[i][j];\n                dp[i - 1][j - 1] %= MOD;\n                dp[i - 1][j] -= dp[i][j];\n                dp[i - 1][j] %= MOD;\n            }\n        }\n    }\n    ans %= MOD;\n    if (ans < 0) ans += MOD;\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int N(4010), Mod(1e9 + 7);\nint max(int x, int y) { return y < x ? x : y; }\nint fac[N], inv[N], n, K;\nint C(int n, int m) { return 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod; }\nint fastpow(int x, int y)\n{\n\tint ans = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % Mod)\n\t\tif (y & 1) ans = 1ll * ans * x % Mod;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &K), fac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= n + K; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\tinv[n + K] = fastpow(fac[n + K], Mod - 2);\n\tfor (int i = n + K - 1; i; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % Mod;\n\tprintf(\"%lld\\n\", 1ll * ((C(n + K - 2, K - 1) - C(n + K - 2, K - 2) + Mod) % Mod)\n\t\t\t* fastpow(2, max(0, n - K - 1)) % Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n\nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = (ans + f[K-1][i]) % MM;\n\tcout<<((K!=n)?(ans * pw[n-K-1] % MM):ans)<<endl;\n}\n\nvoid printans(){\n\n}\n\n\nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = (1e9 + 7);\n\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nstruct Combi\n{\n\tvector<int> fact;\n\tvector<int> ifact;\n\tvector<int> inv;\n\tvector<int> pow2;\n\tint choose(int a, int b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tint inverse(int a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t}\n\t\tifact[_n] = inverse(fact[_n]);\n\t\tfor(int i=_n-1;i>=1;i--)\n\t\t{\n\t\t    ifact[i] = mult(ifact[i + 1], i + 1);\n\t\t}\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t    inv[i] = mult(fact[i-1],ifact[i]);\n\t\t}\n\t}\n};\n\nCombi combi;\nint dp[2111][2111];\nint sum[2111][2111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcombi.init(4010);\n\tint n,k; cin>>n>>k;\n\tif(n==1)\n\t{\n\t\tcout<<1<<'\\n';\n\t\treturn 0;\n\t}\n\tint coeff=1;\n\tif(k<n) coeff=combi.pow2[n-k-1];\n\tfor(int i=1;i<=n-1;i++) dp[0][i]=1;\n\tfor(int i=1;i<k;i++)\n\t{\n\t\tfor(int j=n-i-1;j>=(i==n-1?0:1);j--)\n\t\t{\n\t\t\tif(j==n-i-1) dp[i][j]=dp[i-1][j+1];\n\t\t\telse dp[i][j]=dp[i][j+1];\n\t\t\tdp[i][j]=add(dp[i][j],dp[i-1][j]);\n\t\t}\n\t}\n\tint ans=dp[k-1][(k==n?0:1)];\n\tans=mult(ans,coeff);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 2005;\nconst int mod = 1e9 + 7; \nusing namespace std;\n\nint n, m, f[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint fpow(int x, int y)\n{\n\tint res = 1;\n\tfor( ; y; y >>= 1, x = 1ll * x * x % mod)\n\t\tif(y & 1) res = 1ll * res * x % mod;\n\treturn res; \n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin); \n#endif\n\tn = read <int> (), m = read <int> (); \n\tf[n + 1] = 1; \n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = n; j; j--)\n\t\t{\n\t\t\tif(n - j + 1 < i) f[j] = 0; \n\t\t\telse f[j] = (f[j] + f[j + 1]) % mod; \n\t\t}\n\tif(n != m) f[1] = 1ll * f[1] * fpow(2, n - m - 1) % mod; \n\tprintf(\"%d\\n\", f[1]); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define RG register\n#define ll long long\n#define rhl (1000000007)\n\nusing namespace std;\n\nint f[2010][2010][2],n,k;\n\nint main(){\n  cin>>n>>k,f[n][0][0]=1;\n  for (RG int i=n;i;--i)\n    for (RG int j=n;j>=0;--j){\n      (f[i][j][1]+=f[i][j+1][1])%=rhl;\n      for (RG int p=0;p<2;++p){\n\t(f[i-1][j+1][0]+=f[i][j][p])%=rhl;\n\t(f[i-1][j][1]+=f[i][j][p])%=rhl;\n      }\n    }\n  for (RG int i=n-k-1;i>0;--i) (f[0][n-k][1]<<=1)%=rhl;\n  cout<<f[0][n-k][1]; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\nint K,n;\n\nlint C[2005][2005];\nconst int mod=1000000007;\n\nint dp[2005][2005];\nvoid chadd(int& a,int b){\n  a+=b;\n  if(a>=mod) a-=mod;\n}\n\nint brute(int m){\n  int perm[15];\n  REP(i,m) perm[i]=i;\n  int cnt=0;\n  do{\n    bool ok=false;\n    REP(i,1<<m){\n      bool fail=false;\n      int pv=-1;\n      REP(j,m) if(i>>j&1){\n        if(pv>perm[j]) fail=true;\n        pv=perm[j];\n      }\n      pv=-1;\n      REP(j,m) if(!(i>>j&1)){\n        if(pv>perm[j]) fail=true;\n        pv=perm[j];\n      }\n      if(!fail) ok=true;\n    }\n    if(ok) ++cnt;\n  }while(next_permutation(perm,perm+m));\n  return cnt;\n}\n\nint sum[2005][2005];\nint main(){\n  REP(i,2005){\n    C[i][0]=1;\n    REP(j,i) C[i][j+1]=(C[i-1][j+1]+C[i-1][j])%mod;\n  }\n\n  cin>>n>>K;\n  --K;\n  dp[K][0]=1;\n  for(int i=K;i>=0;--i) REP(j,K+1){\n    chadd(dp[i][j],sum[i+1][j+1]);\n    chadd(dp[i][j],dp[i+1][j]);\n    sum[i][j]=dp[i][j];\n    if(j) chadd(dp[i][j],dp[i][j-1]);\n  }\n  lint res=0;\n  int rest=n-1-K;\n  if(rest==0){\n    res=dp[0][0];\n  }else{\n    for(int i=rest;i<n;++i){\n      int cons=i-rest;\n      lint tmp=C[i-1][rest-1]*dp[cons][cons]%mod;\n      res+=tmp;\n    }\n    res%=mod;\n    REP(hoge,rest-1) res=res*2%mod;\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n#define drp(i,st,ed) for (int i=st;i>=ed;--i)\n\nconst int MOD=1e9+7;\nconst int N=2005;\n\nint f[N][N],s[N][N];\n\nint ksm(int x,int dep) {\n\tint res=1;\n\tfor (;dep;dep>>=1,x=1LL*x*x%MOD) {\n\t\t(dep&1)?(res=1LL*res*x%MOD):0;\n\t}\n\treturn res;\n}\n\nint main(void) {\n\tint n,k; scanf(\"%d%d\",&n,&k);\n\tf[0][n+1]=1;\n\tdrp(j,n+1,1) s[0][j]=(s[0][j+1]+f[0][j])%MOD;\n\trep(i,1,k) {\n\t\trep(j,1,n-i+1) f[i][j]=s[i-1][j];\n\t\tdrp(j,n+1,1) s[i][j]=(s[i][j+1]+f[i][j])%MOD;\n\t}\n\tint ans=(f[k][1]-f[k-1][1]+MOD)%MOD;\n\tans=1LL*ans*ksm(2,n-k-1)%MOD;\n\tans=(ans%MOD+MOD)%MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define X first\n#define Y second\n#define FOE(x, a) for(auto x : a)\n#define FOR(i, a, b) for(int i = a; i <= b; i++)\n#define FOD(i, a, b) for(int i = a; i >= b; i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int N = 2010;\nconst int MOD = 1e9 + 7;\n\nint n, k, C[N][N], F[N][N], sF[N][N];\n\nvoid add(int &x, int y){\n    x += y;\n    x -= (x >= MOD) * MOD;\n}\n\nvoid sub(int &x, int y){\n    x -= y;\n    x += (x < 0) * MOD;\n}\n\nint powMod(int n, int k){\n    assert(n >= 0);\n    if (k == 0)\n        return 1;\n    int res = powMod(n, k >> 1);\n    res = (ll) res * res % MOD;\n    if (k & 1)\n        res = (ll) res * n % MOD;\n    return res;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> k;\n\n    FOR(i, 0, n){\n        C[i][0] = 1;\n        FOR(j, 1, i){\n            add(C[i][j], C[i - 1][j]);\n            add(C[i][j], C[i - 1][j - 1]);\n        }\n    }\n\n    F[0][0] = 1;\n    sF[0][0] = 1;\n\n    FOR(i, 1, n)\n        FOD(j, i, 1){\n            add(F[i][j], sF[i - 1][j]);\n            add(F[i][j], F[i - 1][j - 1]);\n\n            add(sF[i][j], sF[i][j + 1]);\n            add(sF[i][j], F[i][j]);\n        }\n\n    cout << (ll) sF[n - 1][n - k] * powMod(2, max(0, n - k - 1)) % MOD;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst long long P=1000000007;\nlong long n,k,f[10001];\nlong long qpow(long long a,int x)\n{\n    if(x<0)return 1;\n    long long s=1;\n    while(x)\n\t{\n\t\tif(x&1) s=(s*a)%P;\n\t\ta=(a*a)%P;\n\t\tx>>=1;\n\t}\n    return s;\n}\nint main()\n{\n    scanf(\"%lld%lld\",&n,&k);\n    f[0]=1;\n    for(int i=1;i<n;++i)\n\t{\n\t\tfor(int j=i;j;--j)\n\t\t\tf[j]=(f[j+1]+f[j-1])%P;\n\t\tf[0]=f[1];\n\t}\n    printf(\"%lld\",f[n-k]*qpow(2,n-k-1)%P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(int n){\n    if(n+1<=(signed)fact.size()) return;\n    fact.assign(n+1,1);\n    finv.assign(n+1,1);\n    invs.assign(n+1,1);\n    \n    for(int i=1;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(int i=n;i>=1;i--) finv[i-1]=finv[i]*Mint(i);\n    for(int i=1;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(int n,int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(int n,int k){\n    Mint res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(int n,int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(int n,int k){\n    Mint res;\n    for(int j=1;j<=k;j++) res+=S(n,j);\n    return res;\n  }\n\n  static Mint montmort(int n){\n    Mint res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,k;\n  cin>>n>>k;\n  using M = Mint<int>;\n  vector<M> dp(n+1,0);\n  dp[0]=M(1);\n  for(int i=0;i<k-1;i++){\n    for(int j=1;j<=n;j++) dp[j]+=dp[j-1];\n    dp[i]=M(0);    \n  }\n  M ans;\n  for(int i=0;i<n;i++) ans+=dp[i];\n  ans*=M(2).pow(n-k-1);\n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst long long MOD = 1e9+7;\nconst long long MAXN = 2e3+5;\nlong long dp[MAXN][MAXN];\nlong long suff[MAXN];\nint main(){\n    long long n,k;\n    cin>>n>>k;\n    dp[0][n] = 1;\n    if(n==1 && k==1){\n        cout<<1<<endl;\n        return 0;\n    }\n    for(long long i=1;i<=k;i++){\n        for(long long j=n;j>=1;j--){\n            suff[j] = suff[j+1]+dp[i-1][j];\n            suff[j]%=MOD;\n            if(j<=(n-i+1)){\n                dp[i][j] =suff[j];\n                dp[i][j]%=MOD;\n            }\n            //cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n        }\n        \n    }\n    \n    long long ans = (dp[k][1] - dp[k-1][1] + MOD)%MOD;\n    //cout<<ans<<endl;\n    for(long long i=1;i<=n-k-1;i++){\n        ans*=2;\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 2005, MOD = 1000000007;\ntypedef long long i64;\n\nint N, K;\ni64 fac[MAX_N], ifac[MAX_N], inv[MAX_N], bin[MAX_N];\ni64 f[MAX_N][MAX_N], sum[MAX_N];\n\ni64 binom(int n, int m) {\n  if (n < m) return 0;\n  return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &K);\n  fac[0] = ifac[0] = inv[1] = bin[0] = 1;\n  for (int i = 1; i <= N; ++i) fac[i] = fac[i - 1] * i % MOD;\n  for (int i = 2; i <= N; ++i) inv[i] = -(MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i <= N; ++i) ifac[i] = ifac[i - 1] * inv[i] % MOD;\n  for (int i = 1; i <= N; ++i) bin[i] = (bin[i - 1] + bin[i - 1]) % MOD;\n  \n  f[0][0] = 1;\n\n  for (int i = 0; i <= N; ++i) {\n    for (int j = 0; i + j <= N; ++j) {\n      if (j > 0) f[i][j] = f[i][j - 1];\n      if (i > 0) f[i][j] = (f[i][j] + sum[i + j]) % MOD;\n    }\n    for (int j = 0; i + j < N; ++j) {\n      //s - i - 1 = j\n      sum[i + j + 1] = (sum[i + j + 1] + f[i][j]) % MOD;\n    }\n  }\n\n  i64 res = 0;\n  for (int i = 2; i <= N; ++i) {\n    if (K - 1 - N + i < 0) continue;\n    res = (res + binom(i - 2, N - K - 1) * bin[N - K - 1] % MOD * f[N - i][K - 1 - N + i] % MOD) % MOD;\n  }\n  if (K == N) res = f[N - 1][0];\n  printf(\"%lld\\n\", (res + MOD) % MOD);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    if (n == k)\n    {\n        cout << inq(2, n - 1);\n        return 0;\n    }\n    return 1;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=4000;\nconst int mod=1e9+7;\nint n,k;\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if(k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n    if (k&1)\n        sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint fac[maxn+10],ifac[maxn+10],inv[maxn+10];\n\nint C(int a,int b){return (a<0)||(b<0)||(a<b)?0:1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\n\nint F(int i,int j){return (C(i+j,i)-C(i+j,i+1)+mod)%mod;}\n\nint main()\n{\n    fac[0]=inv[0]=inv[1]=ifac[0]=1;\n    for(int i=1; i<=maxn; ++i)\n    {\n        fac[i]=1ll*fac[i-1]*i%mod;\n    }\n    for(int i=2; i<=maxn; ++i) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=1; i<=maxn; ++i) ifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n    n=read(),k=read();\n    printf(\"%lld\\n\",1ll*F(n-1,k-1)*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 2e3 + 10;\n\nint n, kth, two[N], dp[N][N][2];\n\nint main() {\n\tscanf(\"%d%d\", &n, &kth);\n\ttwo[0] = 1;\n\tfor (int i = 0; i < n; ++i)\n\t\ttwo[i + 1] = (two[i] << 1) % mod;\n\tdp[n + 1][0][1] = 1;\n\tfor (int i = n + 1; i > 1; --i) {\n\t\tfor (int j = n; j >= 0; --j)\n\t\t\t(dp[i][j][0] += dp[i][j + 1][0]) %= mod;\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\t(dp[i - 1][j + 1][1] += dp[i][j][k]) %= mod;\n\t\t\t\t(dp[i - 1][j][0] += dp[i][j][k]) %= mod;\n\t\t\t}\n\t}\n\tint ans = (long long)dp[1][n - kth][0] * two[max(0, n - kth - 1)] % mod;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define mt make_tuple\n#define X first\n#define Y second\n#define ALL(x) x.begin(),x.end()\n#define RALL(x) x.rbegin(),x.rend()\n#define D double\n#define ll long long\n#define REP(i,a) for(int i=0;i<a;i++)\n#define REP1(i,a,b) for(int i=a;i<b;i++)\n#define REP2(i,a,b) for(int i=a;i<=b;i++)\n#define RREP(i,a) for(int i=a-1;i>=0;i--)\n#define RREP1(i,a,b) for(int i=a;i>b;i--)\n#define RREP2(i,a,b) for(int i=a;i>=b;i--)\n#define SREP(i,x) for(auto i:x)\n#define MS0(x) memset((x),0,sizeof((x)))\n#define MS1(x) memset((x),-1,sizeof((x)))\n#define MSF(x) memset((x),127,sizeof(x))\n#define pb push_back\n#define LE(x) (int)((x).size())\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define PDD pair<D,D>\n#define im guagua\n#define RI(x) x=rit()\n#define RII(a,b) a=rit(),b=rit()\n#define RIII(a,b,c) a=rit(),b=rit(),c=rit()\n#define debug 0\nconst int INF = 0x7F7F7F7F;\nconst double EPS = 1e-10 ;\nconst ll mod7 = 1e9+7;\nconst ll mod9 = 1e9+9;\nusing namespace std;\ninline ll rit(){\n    ll f=0,key=1;\n    char c;\n    do{\n        c=getchar();\n        if(c=='-') key=-1;\n    }while(c<'0' || c>'9');\n    do{\n        f=f*10+c-'0';\n        c=getchar();\n    }while(c>='0' && c<='9');\n    return f*key;\n}\ninline void fprt(D f){\n    printf(\"%.08lf\",f);\n}\nconst int Z = 2005;\nint n,k;\nint dp[Z],jie[Z],invjie[Z];\ninline int mul(ll a,ll b){\n    return a*b%mod7;\n}\ninline int add(int a,int b){\n    return (a+b)%mod7;\n}\nint mypow(int a,int b){\n    if(b==0) return 1;\n    if(b==1) return a%mod7;\n    int f = mypow(a,b>>1);\n    f = mul(f,f);\n    if(b&1) f = mul(f,a);\n    return f;\n}\ninline int inv(int x){\n    return mypow(x,mod7-2);\n}\nvoid init(){\n    int sum;\n    jie[0] = 1;\n    invjie[0] = 1;\n    dp[0] = sum = 1;\n    REP1(i,1,Z){\n        dp[i] = sum;\n        jie[i] = mul(i,jie[i-1]);\n        invjie[i] = inv(jie[i]);\n        sum = add(sum,dp[i]);\n    }\n}\ninline int C(int a,int b){\n    // cout<<\"C \"<<a<<\" qv \"<<b<<\" = \"<<mul(jie[a],mul(invjie[b],invjie[a-b]))<<endl;\n    return mul(jie[a],mul(invjie[b],invjie[a-b]));\n}\nvoid read(){\n    RII(n,k);\n}\nvoid solve(){\n    int langfeideqingchun,ans;\n    ans = 0;\n    REP2(l,k-1,k-1){\n        // cout<<\"l = \"<<l<<endl;\n        langfeideqingchun = k-1-l;\n        // cout<<\"rl = \"<<langfeideqingchun<<endl;\n        if(langfeideqingchun<0) break;\n        // cout<<mul(dp[n-l-1-langfeideqingchun] , mul(C(n-1,l),C(l+langfeideqingchun,l)))<<\" = \"<<dp[n-l-1-langfeideqingchun]<<\"*\"<<C(l+langfeideqingchun,l)<<\"*\"<<C(n-1,l)<<endl;\n        ans = add( ans , mul(dp[n-l-1-langfeideqingchun] , mul(C(n-1,l),C(l+langfeideqingchun,l))));\n    }\n    printf(\"%d\\n\",ans);\n}\nint main(){\n    int nn=1;\n    // nn=rit();\n    while(nn--){\n        // while(cin>>n) \n            init(),read(),solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod dp[MAX_N][MAX_N];\nmod ad[MAX_N], sm[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, K;\n    cin >> n >> K;\n    dp[0][n] = 1;\n    sm[n+1] = 1;\n    rep(i,K){\n        if(i < K - 1){\n            srep(j,1,n-i){\n                // i+1 回目に j 取った あまりを埋める\n                dp[i+1][j] = sm[n-i+1] - sm[j+1] + ad[j];\n            }\n            sm[0] = 0;\n            rep(j,n){\n                sm[j+1] = sm[j] + dp[i+1][j];\n            }\n            rep(j,n-i-1){\n                ad[j] += dp[i+1][j];\n            }\n        }else{\n            dp[i+1][0] = sm[n-i+1] - sm[1] + ad[0];\n        }\n    }\n    cout << dp[K][0] * mod_pow((mod)2, max(0, n-K-1)) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<llint> seg;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++) seg[i] = 0;\n\t}\n\t\n\tvoid update(int i, llint val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = (seg[i*2]+seg[i*2+1]) % mod;\n\t\t}\n\t}\n\n\tllint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif(b < l || r < a) return 0;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tllint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tllint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn (lval+rval)%mod;\n\t}\n\tllint query(int a, int b)\n\t{\n\t\tif(a > b) return 0;\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nllint fact[100005], fact_inv[100005];\n\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 100005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 100005; i++){\n\t\tfact_inv[i] = pow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint N, K;\nSegTree seg[2] = {SegTree(17), SegTree(17)};\n\nint main(void)\n{\n\tmake_fact();\n\tcin >> N >> K;\n\t\n\tseg[0].update(0, 1);\n\tfor(int i = 1; i <= K-1; i++){\n\t\tseg[i%2].init();\n\t\tfor(int j = 0; j <= K-1; j++){\n\t\t\tllint tmp = 0;\n\t\t\ttmp += seg[(i+1)%2].query(j+1, j+1);\n\t\t\tif(K-(i+j) > 0) tmp += seg[(i+1)%2].query(j, j), tmp %= mod;\n\t\t\tif(j <= K-1-i) tmp += seg[(i+1)%2].query(0, j-1), tmp %= mod;\n\t\t\tseg[i%2].update(j, tmp);\n\t\t\t//cout << tmp << \" \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\t\n\tllint ans = seg[(K-1)%2].query(0, 0);\n\tans *= comb(N-1, K-1), ans %= mod;\n\tans *= pow(2, max(N-K-1, 0LL)), ans %= mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 2010;\n\nint N, K;\n\nint cc[MN][MN][2];\nint dp(int n, int mn, int t) {\n    if(n == N) return 1;\n    int &ret = cc[n][mn][t];\n    if(ret != -1) return ret;\n    if(n == K - 1) return ret = mn == 1? 0 : dp(n + 1, 1, 1);\n\n    ret = 0;\n    if(t) {\n        int cnt = N - mn - n + 1;\n        if(cnt > 0) {\n            ret += dp(n + 1, mn, 1);\n            ret %= mod;\n            if(mn == 1 && cnt > 1) {\n                ret += dp(n + 1, mn, 1);\n                ret %= mod;\n            }\n        }\n        if(mn > 1) {\n            ret += dp(n, mn - 1, 0);\n            ret %= mod;\n        }\n    }\n    else {\n        ret += dp(n + 1, mn, 1);\n        ret %= mod;\n        if(mn > 1) {\n            ret += dp(n, mn - 1, 0);\n            ret %= mod;\n        }\n    }\n\n    //cout << n << ' ' << mn << ' ' << ret << endl;\n\n    return ret;\n}\n\nint main() {\n    cin >> N >> K;\n\n    memset(cc, -1, sizeof(cc));\n    cout << dp(0, N + 1, 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ld,ld> pa;\nconst int N=5000+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint n,k;\nll fac[N],ifac[N],f[N][N][2];\nll C(ll n,ll m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nll cata(int x){\n\tif(!x)return 1;\n\tif(x==1)return 1;\n\treturn C(x+x,x)-C(x+x,x-1);\n}\nvoid add(ll&a,ll b){a+=b;a%=mod;}\nint main(){\n\tread(n,k);\n\t/*fac[0]=1;\n\trep(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=qpow(fac[n],mod-2,mod);\n\trepd(i,n-1,0)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tll res=C(n-1,k-1);\n\tcout<<res*qpow(2,n-k-1,mod)%mod;*/\n\tf[n][0][0]=1;\n\trepd(i,n,1)repd(j,n,0){\n\t\tadd(f[i-1][j][0],f[i][j][0]+f[i][j][1]);\n\t\tadd(f[i-1][j+1][1],f[i][j][0]+f[i][j][1]);\n\t\tif(j)add(f[i][j-1][0],f[i][j][0]);\n\t}\n\tll res=(f[1][n-k][0]+f[1][n-k][1])%mod;\n\tres=res*qpow(2,n-k-1,mod)%mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\n\nconst int N_MAX = 2005;\n\nint N, K;\nmod_int dp[N_MAX][N_MAX];\n\nint main() {\n    cin >> N >> K;\n    dp[0][N] = 1;\n\n    for (int len = 0; len < K; len++)\n        for (int minimum = 1; minimum + len <= N; minimum++) {\n            int between = (N - minimum) - len;\n\n            for (int under = 0; under < minimum; under++)\n                dp[len + 1][under] += dp[len][minimum];\n\n            if (between > 0)\n                dp[len + 1][minimum] += dp[len][minimum];\n        }\n\n    mod_int answer = dp[K][0] * mod_int(2).pow(max(N - K - 1, 0));\n    cout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint t=1,sum=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-') t=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t\tsum=sum*10+ch-'0',ch=getchar();\n\treturn t*sum;\n}\nconst int Max=2e3+10,mod=1e9+7;\nint f[Max][Max],sum[Max],fac[Max],inv[Max],n,m;\nvoid up(int &x,int y) { x+=y; if(x>=mod) x-=mod; }\nint C(int i,int j) \n{ \n\tif(i<0||j<0||i<j) return 0;\n\treturn 1LL*fac[i]*inv[j]%mod*inv[i-j]%mod; \n}\nint main()\n{\n\tint i,j;\n\tn=read(); m=read();\n\tf[0][0]=1;\n\tfor(i=1;i<m;i++)\n\t{\n\t\tsum[0]=f[i-1][0];\n\t\tfor(j=1;j<i;j++)\n\t\t\tsum[j]=(sum[j-1]+f[i-1][j])%mod;\n\t\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tf[i][j]=sum[j];\n\t\t\tif(j>=i)\n\t\t\t\tup(f[i][j],mod-sum[j-i]);\n\t\t}\n\t}\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor(i=2;i<=n;i++)\n\t\tinv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(i=1;i<=n;i++)\n\t\tinv[i]=1LL*inv[i-1]*inv[i]%mod,\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\tsum[0]=f[m-1][0];\n\tfor(i=1;i<=n;i++)\n\t\tsum[i]=(sum[i-1]+f[m-1][i])%mod;\n\tint ans=0;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tif(i-2<n-m-1)\n\t\t\tcontinue;\n\t\tup(ans,1LL*C(i-2,n-m-1)*sum[n-i]%mod);\n\t}\n\tif(m==n) \n\t\tans=sum[n];\n\tfor(i=m+1;i<n;i++)\n\t\tans=2LL*ans%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t data;\n    mint() = default;\n    mint(int64_t value) : data(value) {}\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->data + other.data; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->data * int64_t(other.data) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->data += other.data; if (this->data >= MOD) this->data -= MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->data = this->data * int64_t(other.data) % MOD; if (this->data < 0) this->data += MOD; return *this; }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this;\n        mint<MOD> y = 1;\n        for (uint64_t i = 1; i and (i <= k); i <<= 1) {\n            if (k & i) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n};\n\nconstexpr int MOD = 1e9 + 7;\n\nmint<MOD> solve(int n, int k) {\n    auto dp = vectors(k + 1, n + 1, mint<MOD>());\n    dp[0][0] = 1;\n    REP (i, k) {\n        mint<MOD> acc = 0;\n        REP3 (j, 1, n + 1) {\n            acc += dp[i][j - 1];\n            dp[i + 1][j] += acc;  // extend the primary chain\n            if (j > i and j != n) {\n                dp[i + 1][j] += dp[i][j];  // extend the secondary chain\n            }\n        }\n    }\n    return dp[k][n] * (k < n ? mint<MOD>(2).pow(n - k - 1) : 1);\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    cout << solve(n, k).data << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint const N = 4e3 + 41;\nint const MOD = 1e9 + 7;\n\nint n, k, dp[N][N], pref[N][N];\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MOD){\n\t\ta -= MOD;\n\t}\n}\n\nint bp(int x, int d){\n\tif(!d){\n\t\treturn 1;\n\t}\n\tif(d&1){\n\t\treturn x * 1LL * bp(x, d-1) % MOD;\n\t}\n\tint r = bp(x, d/2);\n\treturn r * 1LL * r % MOD;\n}\n\nvoid recalcPref(int id){\n\tfor(int i=0;i<N;++i){\n\t\tpref[id][i] = dp[id][i];\n\t\tif(i > 0){\n\t\t\tadd(pref[id][i], pref[id][i-1]);\n\t\t}\n\t}\n}\n\nint getPref(int l, int r, int id){\n\tif(l > r){\n\t\treturn 0;\n\t}\n\tint ret = pref[id][r];\n\tif(l > 0){\n\t\tret -= pref[id][l-1];\n\t\tif(ret < 0){\n\t\t\tret += MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tif(k == 1 || k == n){\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\tdp[1][k-1] = bp(2, n - k - 1);\n\tfor(int i=2;i<=n;++i){\n\t\trecalcPref(i-1);\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tadd(dp[i][j], getPref(j, n-i+1, i-1));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[n][0]);\n}\n\nvoid read(){\n\tscanf(\"%d %d\",&n,&k);\n}\n\n\n\nvoid prepare(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n}\n\nint main(){\n\tprepare();\n\tread();\n\tsolve();\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll _v) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M(0) - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return (*this).pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<1000000007>;\n\nconst int MN = 2333;\nint n, k;\nMint dp[MN], ndp[MN];\nMint two[MN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    two[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        two[i] = Mint(2) * two[i - 1];\n    }\n\n    cin >> n >> k;\n    if (n == 1) {\n        cout << 1 << \"\\n\";\n        return 0;\n    }\n    if (k == 1) {\n        cout << two[n - 2] << \"\\n\";\n        return 0;\n    }\n    fill(dp + 2, dp + n + 1, 1);\n    for (int i = 1; i < k - 1; i++) {\n        copy(dp + 2, dp + n - i + 2, ndp + 2);\n        for (int j = n - i; j >= 2; j--) {\n            ndp[j] += ndp[j + 1];\n        }\n        copy(ndp + 2, ndp + n - i + 1, dp + 2);\n    }\n\n    Mint ans = accumulate(dp + 2, dp + n - k + 3, Mint(0));\n    ans *= two[max(0, n - k - 1)];\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define X first\n#define Y second\n#define REP(i,a) for(int i=0;i<a;++i)\n#define REPP(i,a,b) for(int i=a;i<b;++i)\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tmp make_pair\n#define\tpb push_back\n#define sz(a) int((a).size())\n#define all(a)  a.begin(), a.end()\n#define\tdebug(ccc)\tcout << #ccc << \" = \" << ccc << endl;\n#define present(c,x) ((c).find(x) != (c).end())\nconst double eps = 1e-8;\n#define EQ(a,b) (fabs((a)-(b))<eps)\ninline int max(int a,int b){return a<b?b:a;}\ninline int min(int a,int b){return a>b?b:a;}\ninline ll max(ll a,ll b){return a<b?b:a;}\ninline ll min(ll a,ll b){return a>b?b:a;}\nconst int mod = 1e9+7;\nconst int N = 1e6+10;\nconst ll inf = 1e18;\n\nll power(ll a,ll n){\n\tif(n==0){\n\t\treturn 1;\n\t}\n\tll b = power(a,n/2);\n\tb = b*b%mod;\n\tif(n%2) b= b*a%mod;\n\treturn b;\n}\n\nint add(int a,int b){ return (a+b)%mod;}\nint mul(int a,int b){ return (ll)a*b%mod;}\n\n\nint n,k;\nll dp[2005][2005][2];\n\nll f(int pos,int left,int ch){\n\tif(pos+left==0){\n\t\tif(ch==0)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tll &ret = dp[pos][left][ch];\n\tif(ret!=-1) return ret;\n\tret = 0;\n\tif(ch==1){\n\t\tif(pos==1){\n\t\t\tif(left==n-k) ret = f(pos-1,left,0);\n\t\t\telse ret = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tif(pos==0) return ret = 0;\n\t\tret = (f(pos-1,left,0) + f(pos-1,left+1,1))%mod;\n\t\treturn ret;\n\t}\n\tif(pos==0 && left>1){\n\t\tif(left>0) ret = (ret + 2*f(pos,left-1,ch))%mod;\n\t\treturn ret;\n\t}\n\tif(left>0) ret = (ret + f(pos,left-1,ch))%mod;\n\tret = (ret + f(pos,left,1))%mod;\n\treturn ret;\n}\n\n\nint main(){\n // \tfreopen(\"nice.in\",\"r\",stdin);\n // freopen(\"nice.out\",\"w\",stdout);\n\tscanf(\"%d %d\",&n,&k);\n\tFILL(dp,-1);\n\tprintf(\"%lld\\n\",f(n,0,0));\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename C, typename T> vector<T> prefixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0R (i, sz(v)) res[i+1] = res[i] + v[i]; return res;\n    }\n    template<typename C, typename T> vector<T> suffixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0Rd (i, sz(v)) res[i] = v[i] + res[i+1]; return res;\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.precision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// modnum {{{\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(1e9 + 7)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nint main() {\n    setIO();\n\n    int N, K; re(N, K);\n\n    vvmn seq(N + 1, vmn(N + 1));\n    vvmn pre(N + 1, vmn(N + 1));\n\n    seq[0][0] = 1;\n\n    FOR (pl, 1, N+1) {\n        pre[pl-1] = seq[pl-1];\n        F0R (sk, N) {\n            pre[pl-1][sk+1] += pre[pl-1][sk];\n            seq[pl][sk] = seq[pl-1][sk+1] + pre[pl-1][sk];\n        }\n    }\n\n    mn ans = 0;\n    F0R (sk, N-(K-1)) {\n        ans += seq[K-1][sk];\n    }\n    ans *= mn(2).pow(max(0, N-K-1));\n    ps(ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=2005,mo=1e9+7;\nint n,k,f[N][N];\nint main()\n{\n\tn=read(),k=read();\n\tf[0][n+1]=1;\n\tfo(i,1,k-1)\n\t{\n\t\tint t=f[i-1][n-i+2];\n\t\tfd(j,n-i+1,1)\n\t\t{\n\t\t\tf[i][j]=(t+f[i-1][j])%mo;\n\t\t\tt=(t+f[i-1][j])%mo;\n\t\t}\n\t}\n\tint ans=0;\n\tfo(j,2,n+1) ans=(ans+f[k-1][j])%mo;\n\tfo(i,1,n-k-1) ans=ans*2%mo;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define ll long long\nconst ll mod = 1e9+7; \nusing namespace std;\nint read(){\n\tint x=0,pos=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;\n\tfor(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn pos?x:-x;\n}\nconst int N = 2001;\nint n,k;\nll f[N][N];\nint main(){\n\tn=read(),k=read();\n\tfor(int i=2;i<=n;i++){\n\t\tf[1][i]=1;\n\t}\n\tfor(int i=1;i<k-1;i++){\n\t\tll sum=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--){\n\t\t\tsum=(sum+f[i][j])%mod;\n\t\t\tf[i+1][j]=sum;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=2;i<=n;i++){\n\t\tans=(ans+f[k-1][i])%mod;\n\t}\n\tif(k==1){\n\t\tans=1;\n\t}else if(k!=n){\n\t\tll pm=1;\n\t\tfor(int i=1;i<=n-k-1;i++){\n\t\t\tpm=pm*2ll%mod;\n\t\t}\n\t\tans=ans*((pm)%mod)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\nint n, m;\n\nMod dp[2010][2010];\nMod sum[2010][2010];\n\nint main(){\n\n  n = in();\n  m = in();\n  \n  dp[0][0] = 1;\n  REP( i , n+1 ){\n    sum[0][i] = 1;\n  }\n  \n  FOR( i , 1 , m ){\n    FOR( j , i , n+1 ){\n      dp[i][j] = dp[i-1][j] + sum[i-1][j];\n    }\n    FOR( j , i , n+1 ){\n      sum[i][j+1] = sum[i][j] + dp[i][j];\n    }\n  }\n\n  Mod ans = sum[m-1][n] * modpow( 2 , max( 0 , n - m - 1 ) );\n  cout << ans.n << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nlong long qpow(long long base,int tms)\n{\n\tif(tms < 0) return 1;\n\tlong long tmp = 1;\n\twhile(tms)\n\t{\n\t\tif(tms & 1) tmp = tmp * base % mod;\n\t\tbase = base * base % mod;\n\t\ttms >>= 1;\n\t}\n\treturn tmp;\n}\n\nint f[2][2050];\n\nint main()\n{\n\tint n,k; scanf(\"%d%d\",&n,&k);\n\tint cur = 0,lst = 1;\n\tf[0][0] = 1;\n\tfor(int i = 1;i <= k - 1; ++ i)\n\t{\n\t\tcur ^= 1,lst ^= 1;\n\t\tmemset(f[cur],0,sizeof(f[cur]));\n\t\tint sum = f[lst][0];\n\t\tfor(int j = 1;j <= n; ++ j)\n\t\t\tf[cur][j] = (sum + f[lst][j]) % mod,sum = (sum + f[lst][j]) % mod;\n\t\tfor(int j = 0;j < n; ++ j)\n\t\t\tf[cur][j] = f[cur][j + 1];\n\t}\n\tint ans = 0;\n\tfor(int i = 0;i < n - k + 1; ++ i) ans = (ans + f[cur][i]) % mod;\n\tprintf(\"%d\\n\",ans * 1ll * qpow(2,n - k - 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nconst int MOD = 1000000007;\nint N, K;\nint f[2002], g[2002];\ninline void add(int &x, int y)\n{\n\tx = x + y < MOD ? x + y : x + y - MOD;\n}\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\tf[N - 1] = 1;\n\tfor (int i = 0; i < K - 1; i++)\n\t{\n\t\tfor (int j = 0; j < N - i - 1; j++)\n\t\t\tg[j] = f[j + 1];\n\t\tfor (int j = N - i - 3; j >= 0; j--)\n\t\t\tadd(g[j], g[j + 1]);\n\t\tfor (int j = 0; j < N - i - 1; j++)\n\t\t\tadd(f[j], g[j]);\n\t}\n\tint O = 0;\n\tfor (int i = 0; i <= N - K; i++)\n\t\tadd(O, f[i]);\n\tfor (int i = N - K - 1; i > 0; i--)\n\t\tadd(O, O);\n\tprintf(\"%d\\n\", O);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 0x7fffffff\n#define eps 1e-10\n#define MOD 1000000007 \nusing namespace std;\nconst int maxn=2010;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\treturn f*x;\n}\n\nint n,k;\nll f[maxn][maxn],s[maxn][maxn],pw[maxn];\nint main(){\n\tpw[1]=1;\n\tfor (int i=2;i<maxn;++i)pw[i]=(pw[i-1]<<1)%MOD;\n\tn=read();k=read();\n\tf[1][n-k]=pw[n-k];\n\tfor (int i=1;i<=n+1;++i)s[1][i]=(s[1][i-1]+f[1][i])%MOD;\n\tfor (int i=2;i<=n;++i){\n\t\tfor (int j=0;j<=n;++j)f[i][j]=s[i-1][j+1]; \n\t\ts[i][0]=f[i][0];\n\t\tfor (int j=1;j<=n+1;++j)s[i][j]=(s[i][j-1]+f[i][j])%MOD;\n\t}\n\tprintf(\"%lld\\n\",f[n][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint f[2333][2333],n,k;\nconst int mod =1e9+7;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tf[1][n-k]=1;for (int i=1;i<n-k;++i) f[1][n-k]=(f[1][n-k]<<1)%mod;\n\tfor (int i=2;i<=n;++i)\n\t{\n\t\tf[i][0]=f[i-1][0]+f[i-1][1];\n\t\tfor (int j=1;j<=n+1;++j)\n\t         f[i][j]=(f[i][j-1]+f[i-1][j+1])%mod;\n\t}\n\tprintf(\"%d\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define N 2002\nusing namespace std;\nconst int mod=1000000007;\nint n,k,f[N][N],sum[N],i,j;\nint main()\n{\n\tcin>>n>>k;\n\tsum[n+1]=f[0][n+1]=1;\n\tfor(i=n;i>=1;i--) sum[i]=sum[i+1]+f[0][i];\n\tfor(i=1;i<k;i++){\n\t\tfor(j=1;j<=n-i+1;j++) f[i][j]=sum[j];\n\t\tsum[n+1]=f[i][n+1];\n\t\tfor(j=n;j>=1;j--) sum[j]=(sum[j+1]+f[i][j])%mod;\n\t}\n\tint ans=0;\n\tfor(i=2;i<=n+1;i++) ans=(ans+f[k-1][i])%mod;\n\tfor(i=1;i<=n-k-1;i++) ans=ans*2%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint n,f[2005][2005],s[2005],k,P=1e9+7,a;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);f[0][n+1]=1;\n\tfor(int i=1;i<=k;i++) for(int j=n+1;j;j--) s[j]=(s[j+1]+f[i-1][j])%P,f[i][j]=s[j];\n\ta=(f[k][1]-f[k-1][1]+P)%P;\n\tfor(int i=1;i<=n-k-1;i++) a=(a+a)%P;\n\tprintf(\"%d\\n\",a);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing mat = vector<vector<lint> >;\nconstexpr lint MOD = 1000000007;\n\nlint K, N;\n\nlint solve()\n{\n    vector<lint> dp(N+2);\n    dp[N+1] = 1;\n    for (int k=1; k<=K; k++)\n    {\n        for (int j=N; j>=0; j--)\n        {\n            if (j > N + 1 - k) dp[j] = 0;\n            else dp[j] = (dp[j] + dp[j+1]) % MOD;\n        }\n    }\n    return dp[1];\n}\n\nint main()\n{\n    cin >> N >> K;\n    lint ans = solve();\n    for (int k=K+1; k<N; k++) ans = (ans * 2) % MOD;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=1e9+7;\nconst int MAXN=2005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint f[MAXN][MAXN],s[MAXN][MAXN];\ninline int upd(int x,int y) { return x+y>=mods?x+y-mods:x+y; }\ninline int quick_pow(int x,int y)\n{\n\tif (y<0) return 1;\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint n=read(),k=read();\n\tf[0][n+1]=s[0][n+1]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n-i+1;j++) f[i][j]=upd(s[i-1][n+1],mods-s[i-1][j-1]),s[i][j]=upd(s[i][j-1],f[i][j]);\n\t\ts[i][n+1]=s[i][n-i+1];\n\t}\n\tprintf(\"%d\\n\",1ll*upd(f[k][1],mods-f[k-1][1])*quick_pow(2,n-k-1)%mods);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int m = 1000000007;\nlong long b[2001];\nlong long c[2001][2002];\nlong long dp[2001][2002];\n\nint main() {\n    int n, k, i, j;\n    long long ans = 0;\n    \n    scanf(\"%d %d\", &n, &k);\n    \n    b[0] = b[1] = 1;\n    for (i = 2; i <= n; i++) b[i] = b[i - 1] * 2 % m;\n    \n    for (i = 0; i <= n; i++) {\n        c[i][0] = c[i][i] = 1;\n        for (j = 1; j < i; j++) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % m;\n    }\n        \n    \n    dp[0][0] = 1;\n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            if (i > 0) dp[i][j] += dp[i - 1][j + 1];\n            if (j > 0) dp[i][j] += dp[i][j - 1];\n            if (dp[i][j] >= m) dp[i][j] -= m;\n        }\n    }\n    \n    if (n == k) {\n        ans = dp[n - 1][0];\n    } else {\n        for (i = n - k; i < n; i++) {\n            ans += c[i - 1][n - k - 1] * dp[n - i - 1][i - n + k] % m;\n            if (ans >= m) ans -= m;\n        }\n        \n        ans = ans * b[n - k] % m;\n    }\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n\nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = (ans + f[K-1][i]) % MM;\n\tcout<<((K!=n)?(ans * pw[n-K-1] % MM):ans)<<endl;\n}\n\nvoid printans(){\n\t/*?????????*/\n}\n\n\nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n// ??????????\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define RG register\n#define ll long long\n#define rhl (1000000007)\n\nusing namespace std;\n\nint f[2010][2010][2],n,k;\n\nint main(){\n  cin>>n>>k,f[n][0][0]=1;\n  for (RG int i=n;i;--i)\n    for (RG int j=n;j>=0;--j){\n      (f[i][j][1]+=f[i][j+1][1])%=rhl;\n      for (RG int p=0;p<2;++p){\n\t(f[i-1][j+1][0]+=f[i][j][p])%=rhl;\n\t(f[i-1][j][1]+=f[i][j][p])%=rhl;\n      }\n    }\n  for (RG int i=n-k-1;i;--i) (f[0][n-k][1]<<=1)%=rhl;\n  cout<<f[0][n-k][1]; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long P=1000000007,n,k,f[10001],i,j;\nlong long w(long long a,long long x)\n{\n    if(x<0)\n        return 1;\n    long long s=1000000007;\n    while(x)\n        if(x&1)(s*=a)%=P,a=pow(a,2)%P,x>>=1;\n    return s;\n}\n\nint main( )\n{\n    cin>>n>>k;\n    f[0]=1000000007;\n    for(i=1;i<n;++i)\n        for(j=i;j;--j)\n            f[j]=(f[j+1]+f[j-1])%P,f[0]=f[1];\n    cout<<f[n-k]*w(2ll,n-k-1)%P;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n     \n#define LL long long\n#define RG register\n     \nusing namespace std;\ntemplate<class T> inline void read(T &x) {\n\tx = 0; RG char c = getchar(); bool f = 0;\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;\n\twhile (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();\n\tx = f ? -x : x;\n\treturn ;\n}\ntemplate<class T> inline void write(T x) {\n\tif (!x) {putchar(48);return ;}\n\tif (x < 0) x = -x, putchar('-');\n\tint len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;\n\tfor (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;\n}\nconst int N = 2010, Mod = 1e9 + 7;\nint f[N][N], sum[N];\nint fpow(int a, int b) {\n\tif (b < 0) return 0;\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n, k; read(n), read(k);\n\tf[0][n + 1] = 1;\n\tfor (int i = 1; i <= k; i++) {\n\t\tsum[n + 1] = f[i - 1][n + 1];\n\t\tfor (int j = n; j; j--) sum[j] = (sum[j + 1] + f[i - 1][j]) % Mod;\n\t\tfor (int j = 1; j <= n - i + 1; j++) f[i][j] = sum[j];\n\t}\n\tprintf(\"%lld\\n\", 1ll * fpow(2, n - k - 1) * sum[2] % Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,k,i,j,f[2005][2005];\nlong long ksm(long long u,long long v){\n\tif(v<0)\n\t\treturn 1;\n\tlong long o=1;\n\twhile(v){\n\t\tif(v&1)\n\t\t\to=o*u%mo;\n\t\tu=u*u%mo;\n\t\tv>>=1;\n\t}\n\treturn o;\n}\nint main(){\n\t//freopen(\"7.in\",\"r\",stdin);\n    //freopen(\"7.out\",\"w\",stdout);\n    n=read();k=read();\n  \tf[0][0]=1;\n  \tfor(i=1;i<n;i++){\n  \t\tf[i][0]=f[i-1][0];\n  \t\tfor(j=1;j<=i;j++)\n  \t\t\tf[i][j]=(f[i][j-1]+f[i-1][j])%mo;\n  \t}\n  \tpus(f[n-1][k-1]*ksm(2,n-k-1)%mo,2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,jc[5555],injc[5555],ans;\nint binpow(int a,int t)\n{\n\tint res=1,p=a;\n\tfor (int i=t;i;i>>=1)\n\t{\n\t\tif (i&1) res=1ll*res*p%mod;\n\t\tp=1ll*p*p%mod;\n\t}\n\treturn res;\n}\nvoid Init()\n{\n\tjc[0]=injc[0]=1;\n\tfor (int i=1;i<=5000;i++)\n\t{\n\t\tjc[i]=1ll*jc[i-1]*i%mod;\n\t\tinjc[i]=1ll*injc[i-1]*binpow(i,mod-2)%mod;\n\t}\n}\nint C(int n,int k)\n{\n\tif (n<k) return 0;\n\treturn 1ll*jc[n]*injc[k]%mod*injc[n-k]%mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tInit();\n\tans=C(n+k-2,n-1)-C(n+k-2,n);\n\tif (n>k) ans=1ll*ans*binpow(2,n-k-1)%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define iter(i, n) forw(i, 1, n)\n#define forw(i, a, b) for (int i = a; i <= b; ++i)\n#define down(i, a, b) for (int i = b; i >= a; --i)\n\nconst int mod = 1e9 + 7;\n\nconst int NR = 2010;\n\nint pr(int a, int z) {\n\tint s = 1;\n\twhile (z > 0) {\n\t\tif (z % 2 == 1) s = 1ll * s * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tz /= 2;\n\t}\n\treturn s;\n}\n\nint n, K, f[NR][NR], sum[NR][NR], fac[NR], inv[NR];\n\nint binom(int n, int k) {\n\treturn n < k ? 0 : 1ll * fac[n] * inv[k] % mod * inv[n - k] % mod;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &K);\n\tif (n == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tfac[0] = inv[0] = 1;\n\titer(i, n) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tinv[i] = pr(fac[i], mod - 2);\n\t}\n\n\tint ans = binom(n - 2, K - 1);\n\n\tf[n + 1][0] = 1;\n\tforw(i, 0, K) sum[n + 1][i] = 1;\n\tdown(i, n - K + 2, n) {\n\t\tforw(j, 0, K) {\n\t\t\t/*\n\t\t\t\tchoice:\n\t\t\t\t\t-1\n\t\t\t\t\t+X\n\t\t\t*/\n\n\t\t\tf[i][j] = (f[i + 1][j + 1] + sum[i + 1][j]) % mod;\n\t\t\tsum[i][j] = f[i][j];\n\t\t\tif (j) sum[i][j] = (sum[i][j] + sum[i][j - 1]) % mod;\n\n\t\t\tif (!j) {\n\t\t\t\tif (i - 3 >= 0 && K - (n - i + 1) - 1 - j >= 0) {\n\t\t\t\t\n\t\t\t\t\tans = (ans + 1ll * binom(i - 3, K - (n - i + 1) - 1) * f[i][j]) % mod;\n\t\t\t//\t\tprintf(\"0!%d %d => %lld\\n\", i, j, 1ll * binom(i - 3, K - (n - i + 1) - 1) * f[i][j]);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (i - 3 >= 0 && K - (n - i + 1) - 1 - j >= 0) {\n\t\t\t\t\n\t\t\t\t\tans = (ans + 1ll * binom(i - 3, K - (n - i + 1) - 1) * f[i][j]) % mod;\n\t\t//\t\t\tprintf(\"0!%d %d => %lld\\n\", i, j, 1ll * binom(i - 3, K - (n - i + 1) - 1) * f[i][j]);\n\t\t\t\t}                                                \n\t\t\t}\n\t\t\n\t//\t\tprintf(\"f[%d][%d]=%d\\n\", i, j, f[i][j]);\n\t\t}\n\n\t}\n\t\n\t//printf(\"ans=%d\\n\", ans);\n\n\titer(i, n - K - 1) ans = ans * 2 % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long p=1e9+7;\nlong long n,k,dp[10001];\nlong long quickpow(long long a,long long b,long long n)\n{\n\tif(b==0&&n>1) return 1;\n\tif(b==0&&n==1) return 0;\n\tif(b==1) return a%n;\n\tif(b%2==0)\n\t{\n\t\tlong long t=quickpow(a,b/2,n);\n\t\treturn t*t%n;\n\t}\n\telse\n\t{\n\t\tlong long t=quickpow(a,b/2,n);\n\t\tt=t*t%n;\n\t\treturn t*a%n;\n\t}\n}\n\nint main(){\n    cin>>n>>k;\n    dp[0]=1;\n    for(int i=1;i<n;i++)\n\t{\n\t\tfor(int j=i;j>0;j--)\n\t\t\tdp[j]=(dp[j+1]+dp[j-1])%p;\n\t\tdp[0]=dp[1];\n\t}\n\tcout<<dp[n-k]*quickpow(2,n-k-1,p)%p<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint mem[2010][2010];\nint sum[2010][2010];\n\nint main()\n{\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n\n    int n, k, i, j;\n    scanf(\"%d%d\", &n, &k);\n\n    mem[1][1] = sum[1][1] = 1;\n    for(i = 2; i <= n; i++)\n    {\n        for(j = 1; j <= i; j++)\n        {\n            mem[i][j] = (sum[i - 1][j - 1] + mem[i - 1][j]) % mod;\n            sum[i][j] = (sum[i][j - 1] + mem[i][j]) % mod;\n        }\n    }\n\n    int r = mem[n][k];\n    for(i = 0; i < n - k - 1; i++)\n        r = (2 * r % mod);\n\n    printf(\"%d\\n\", r);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 0x7fffffff\n#define eps 1e-10\n#define MOD 1000000007 \nusing namespace std;\nconst int maxn=2010;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\treturn f*x;\n}\n\nint n,k;\nint f[maxn][maxn],s[maxn][maxn],pw[maxn];\nint main(){\n\tpw[1]=1;\n\tfor (int i=2;i<maxn;++i)pw[i]=(pw[i-1]<<1)%MOD;\n\tn=read();k=read();\n\tf[1][n-k]=pw[n-k];\n\tfor (int i=1;i<=n+1;++i)s[1][i]=(s[1][i-1]+f[1][i])%MOD;\n\tfor (int i=2;i<=n;++i){\n\t\tfor (int j=0;j<=n;++j)f[i][j]=s[i-1][j+1]; \n\t\ts[i][0]=f[i][0];\n\t\tfor (int j=1;j<=n+1;++j)s[i][j]=(s[i][j-1]+f[i][j])%MOD;\n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define fin \"\\n\"\n\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntemplate <typename T>\ninline void chmin(T &l,T r){l=min(l,r);}\n\ntemplate <typename T>\ninline void chmax(T &l,T r){l=max(l,r);}\n\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\nconst int MOD=1e9+7;\n#define SZ 2123\nLL comb[2*SZ][2*SZ];\nLL C[SZ][SZ];\nstruct latte{\n    latte(){\n        REP(i,2*SZ)comb[i][0]=comb[i][i]=1;\n        FOR(i,2,2*SZ){\n            FOR(j,1,2*SZ){\n                comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n            }\n        }\n        REP(i,SZ)REP(j,SZ)C[i][j]=0;\n        C[0][0]=1;\n        REP(i,SZ-1){\n            FOR(j,0,SZ-1){\n                C[i+1][j+1]+=C[i][j];\n                C[i+1][0]+=MOD-C[i][j];\n            }\n            for(int j=SZ-1;j>0;j--)\n                (C[i+1][j-1]+=C[i+1][j])%=MOD;\n        }\n    }\n}malta;\n\ninline LL nHr(LL n,LL r){\n    //if(r<0||n<r)return 0;\n    return comb[n+r-1][r];\n}\nint main(){\n    int N,K;\n    cin>>N>>K;\n    LL res=0;\n    if(N==K){\n        REP(i,N+1)\n            res+=C[N][i];\n        res%=MOD;\n    }\n    else{\n        REP(i,K){\n            int n=i;\n            int r=K-i-1;\n            LL ans=0;\n            REP(j,n+1)\n                ans+=C[n][j]*nHr(j+1,r)%MOD;\n            ans%=MOD;\n            (res+=ans*comb[N-n-2][r]%MOD)%=MOD;\n        }\n    }\n    REP(i,N-K-1)(res<<=1)%=MOD;\n    cout<<res<<endl;\n    return 0;\n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 2005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\n\nll dp[SIZE][SIZE];\nll all[SIZE];\nint L;\n\nvoid make()\n{\n\tll r1=1;\n\tfor(int i=0;i<L-2;i++) r1=r1*2LL%MOD;\n\tfor(int i=1;i<=L;i++) dp[L][i]=r1;\n\tfor(int i=L+1;i<SIZE;i++)\n\t{\n\t\tfor(int j=i;j>=1;j--)\n\t\t{\n\t\t\tif(j==i) dp[i][j]=dp[i-1][j-1];\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i][j+1];\n\t\t\t\tif(j!=i-1)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]+=dp[i-1][j];\n\t\t\t\t\tif(dp[i][j]>=MOD) dp[i][j]-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint n,k;\n\tscanf(\"%d %d\",&n,&k);\n\tL=n-k+1;\n\tmake();\n\tprintf(\"%lld\\n\",dp[n][1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint fastpow(int x,int a){\n\tif(a<=0) return 1;\n\tint ret=1;\n\twhile(a){\n\t\tif(a&1) ret=ret*1LL*x%mod;\n\t\tx=x*1LL*x%mod;a>>=1;\n\t}\n\treturn ret;\n}\nint dp[2][2005];\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tint now=0;\n\tdp[now][1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tmemset(dp[now^1],0,sizeof(dp[0]));\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tdp[now^1][j]=(dp[now][j]+dp[now^1][j-1])%mod;\n\t\tnow^=1;\n\t}\n\tcout<<dp[now][k]*1LL*fastpow(2,n-k-1)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nll dp[2001][2001];\nint main(){\n    int n,k;\n    cin >> n >> k;\n    dp[0][0] = 1;\n    for(int i=1;i<=k-1;i++){\n        for(int j=0;j<=n-i-1;j++){\n            if(j==0){\n                dp[i][j] = dp[i-1][j] + dp[i-1][j+1];\n                dp[i][j] %= mod;\n            }else{\n                dp[i][j] = dp[i][j-1] + dp[i-1][j+1];\n                dp[i][j] %= mod;\n            }\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     for(int j=0;j<n;j++){\n    //         cerr << dp[i][j] << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n    ll sm = 0;\n    for(int j=0;j<n;j++){\n        sm += dp[k-1][j];\n        sm %= mod;\n    }\n    //cerr << sm << endl;\n    rep(i,n-k-1){\n        sm *= 2;\n        sm %= mod;\n    }\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int mod = 1000000007;\nint N, K, dp[2009], ndp[2009];\nint main() {\n\tcin >> N >> K; K--;\n\tfor (int i = 0; i < N - K; i++) dp[i] = 1;\n\tfor (int i = N - K + 1; i <= N; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tsum += dp[j];\n\t\t\tif (sum > mod) sum -= mod;\n\t\t}\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tndp[j] = sum;\n\t\t\tif (j >= 1) sum -= dp[j - 1];\n\t\t\tif (sum < 0) sum += mod;\n\t\t}\n\t\tfor (int j = 0; j < i; j++) dp[j] = ndp[j];\n\t}\n\tint ret = dp[0];\n\tfor (int i = 0; i < N - K - 2; i++) ret = 2 * ret % mod;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n\nusing namespace std;\ntypedef long long LL;\nconst int N=4005,mod=1000000007;\nint n,m,k;\nLL flv[N],inv[N],ans;\n\nLL getmi(LL a,LL x)\n{\n\tLL rt=1;\n\twhile(x)\n\t{\n\t\tif(x&1) rt=rt*a%mod;\n\t\ta=a*a%mod,x>>=1;\n\t}\n\treturn rt;\n}\n\nLL C(int n,int m)\n{\n\treturn n<m?0:flv[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nLL solve(int n,int k)\n{\n\treturn (C(n+k,n)-C(n+k,n+1))%mod;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k),m=n+k;\n\tflv[0]=1;\n\trep(i,1,m) flv[i]=flv[i-1]*i%mod;\n\tinv[m]=getmi(flv[m],mod-2);\n\trepd(i,m,1) inv[i-1]=inv[i]*i%mod;\n\tans=solve(n,k-1)-solve(n,k-2);\n\tans=ans*getmi(2,max(0,n-k-1))%mod;\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint fastpow(int x,int a){\n\tint ret=1;\n\twhile(a){\n\t\tif(a&1) ret=ret*1LL*x%mod;\n\t\tx=x*1LL*x%mod;a>>=1;\n\t}\n\treturn ret;\n}\nint dp[2][2005];\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tint now=0;\n\tdp[now][1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tmemset(dp[now^1],0,sizeof(dp[0]));\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tdp[now^1][j]=(dp[now][j]+dp[now^1][j-1])%mod;\n\t\tnow^=1;\n\t}\n\tcout<<dp[now][k]*1LL*fastpow(2,n-k-1)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n\n    int nPr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    int mod = 1000000007;\n    Combination comb(N, mod);\n\n    if(K == 1){\n        if(N == 1) cout << 1 << endl;\n        else cout << modpow(2, N - 2, mod) << endl;\n        return 0;\n    }\n\n    mat dp(K - 1, vec(N, 0));\n    FOR(j, 1, N) dp[0][j] = 1;\n    REP(i, K - 2){\n        //上から取る\n        FOR(j, 1, N){\n            if(j >= N - 1 - i) continue;\n            dp[i + 1][j] += dp[i][j] * (N - 1 - i - j);\n            dp[i + 1][j] %= mod;\n        }\n        //下から取る\n        FOR(j, 1, N){\n            dp[i][j] += dp[i][j - 1];\n            dp[i][j] %= mod;\n        }\n        FOR(j, 1, N){\n            if(j >= N - 1 - i) continue;\n            dp[i + 1][j] += dp[i][j + 1];\n            dp[i + 1][j] %= mod;\n        }\n    }\n    int ans = 0;\n    FOR(j, 1, N){\n        ans += dp[K - 2][j];\n        ans %= mod;\n    }\n    if(K < N){\n        ans *= modpow(2, N - K - 1, mod);\n        ans %= mod;\n    }\n    //debug(dp);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n    if (k&1)\n        sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=0;i<=n+1;i++) g[0][i]=1;\n    for (int i=1;i<k;i++)\n        for (int j=n-i+1;j;j--)\n            g[i][j]=(g[i-1][j]+g[i][j+1])%mod;\n    printf(\"%lld\\n\",1ll*g[k-1][2]*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//O(N^2)\n#include<cstdio>\n#define ll long long\nconst int N=2005,mo=1e9+7;\nint n,k,i,j,f[N][N][2];\nvoid add(int &x,int k){x=(x+k)%mo;}\nint main(){\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&k);f[n+1][0][0]=1;\n\tfor (i=n+1;i>=3;i--){\n\t\tfor (j=n+1-i;j>=0;j--){\n\t\t\tadd(f[i-1][j+1][1],f[i][j][0]);\n\t\t\tadd(f[i-1][j+1][1],f[i][j][1]);\n\t\t\tadd(f[i][j][0],f[i][j+1][0]);\n\t\t\tadd(f[i][j][1],f[i][j+1][1]);\n\t\t\tadd(f[i-1][j][0],f[i][j][0]);\n\t\t\tadd(f[i-1][j][0],f[i][j][1]);\n\t\t}\n\t}\n\tint ans=(f[2][n-k][0]+f[2][n-k][1])%mo;\n\tfor (i=n-k-1;i>=1;i--) ans=2ll*ans%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define fin \"\\n\"\n\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntemplate <typename T>\ninline void chmin(T &l,T r){l=min(l,r);}\n\ntemplate <typename T>\ninline void chmax(T &l,T r){l=max(l,r);}\n\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\nconst int MOD=1e9+7;\n#define SZ 5123\nLL comb[SZ][SZ];\nLL pow2[SZ];\nLL C[SZ][SZ];\nstruct latte{\n    latte(){\n        pow2[0]=1;\n        FOR(i,1,SZ)(pow2[i]=pow2[i-1]<<1)%=MOD;\n        REP(i,SZ)comb[i][0]=comb[i][i]=1;\n        FOR(i,2,SZ){\n            FOR(j,1,SZ){\n                comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n            }\n        }\n        REP(i,SZ)REP(j,SZ)C[i][j]=0;\n        C[0][0]=1;\n        REP(i,SZ-1){\n            FOR(j,0,SZ-1){\n                C[i+1][j+1]+=C[i][j];\n                C[i+1][0]+=MOD-C[i][j];\n            }\n            for(int j=SZ-1;j>0;j--)\n                (C[i+1][j-1]+=C[i+1][j])%=MOD;\n        }\n    }\n}malta;\n\ninline LL nHr(LL n,LL r){\n    return comb[n+r-1][r];\n}\nint main(){\n    int N,K;\n    cin>>N>>K;\n    LL res=0;\n    REP(i,K){\n        int n=i;\n        int r=K-i-1;\n        LL ans=0;\n        REP(j,0,n+1)ans+=C[n][j]*nHr(j+1,r)%MOD;    \n        ans%=MOD;\n        (res+=ans*comb[N-n-2][r]%MOD)%=MOD;\n    }\n    cout<<res*pow2[N-K-1]%MOD<<endl;\n    return 0;\n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\ntypedef long long LL;\n\nconst int MC = 2010;\nconst LL mod = 1e9 + 7;\nLL fct[MC];\nLL invfct[MC];\nLL dp[MC][MC];\nint N,K;\n\nvoid build(){\n\tfct[0] = fct[1] = 1;\n\trepp(i,2,N+1){\n\t\tfct[i] = fct[i-1] * i % mod;\n\t}\n\tLL x = fct[N];\n\tinvfct[N] = 1;\n\tfor(int i = mod - 2 ; i > 0 ; i >>= 1){\n\t\tif(i % 2 == 1) (invfct[N] *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t}\n\trepm(i,N,0){\n\t\tinvfct[i-1] = invfct[i] * i % mod;\n\t}\n}\n\nLL comb(int x , int y){\n\tif(x < 0 || x < y) return 0;\n\treturn fct[x] * invfct[y] % mod * invfct[x-y] % mod;\n}\n\nint main(){\n\tscanf(\"%d%d\" , &N , &K);\n\tbuild();\n\tdp[0][0] = 1;\n\trepp(i,1,K){\n\t\tLL s = 0;\n\t\trepp(j,0,i){\n\t\t\t(s += dp[j][i-j-1]) %= mod;\n\t\t\tdp[j][i-j] = s;\n\t\t}\n\t\tdp[i][0] = s;\n\t}\n\tLL ans = 0;\n\tif(N==K){\n\t\tans = dp[N-1][0];\n\t} else {\n\t\trepp(i,0,K){\n\t\t\t(ans += comb(N-i-2,N-K-1) * dp[i][K-i-1] % mod) %= mod;\n\t\t}\n\t\trepm(i,N-K-1,0){\n\t\t\t(ans += ans) %= mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\" , ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int P=1000000007;\nconst int N=2005;\n\nint f[N][N][2];\nint n,K,ans;\n\ninline void update(int &x,int y){(x+=y)%=P;}\n\nint main()\n{\n\t//freopen(\"solitaire.in\",\"r\",stdin),freopen(\"solitaire.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&K);\n\tf[n+1][0][0]=1;\n\tfor (int i=n+1;i>=2;--i)\n\t{\n\t\tfor (int j=n-1;j>=0;--j) update(f[i][j][0],f[i][j+1][0]);\n\t\tfor (int j=0;j<=n;++j)\n\t\t\tfor (int k=0;k<2;++k)\n\t\t\t\tif (f[i][j][k])\n\t\t\t\t{\n\t\t\t\t\tupdate(f[i-1][j+1][1],f[i][j][k]);\n\t\t\t\t\tupdate(f[i-1][j][0],f[i][j][k]);\n\t\t\t\t}\n\t}\n\tans=f[1][n-K][0];\n\tfor (int i=1;i<=n-K-1;++i) (ans<<=1)%=P;\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;i<=n;i++) g[0][i]=1;\n    for (int i=1;i<k;i++)\n\t    for (int j=n-i+1;j>1;j--)\n\t        g[i][j]=(g[i-1][j]+g[i][j+1])%mod;\n    int ans=0;\n    for (int i=2;i<=n-k+2;i++) ans=(ans+f[k-1][i])%mod;\n    printf(\"%lld\\n\",1ll*g[k-1][2]*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n#include <iomanip>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nll double_to_ll(double d){\n\tif(d>0)return d+0.5;\n\treturn d-0.5;\n}\n\nll mod=1000000007;\nstruct mint{\n\tll value;\n\tmint():value(0){}\n\tmint(ll v):value((v%mod+mod)%mod){}\n};\nmint& operator+=(mint&a, mint b){return a=a.value+b.value;}\nmint& operator-=(mint&a, mint b){return a=a.value-b.value;}\nmint& operator*=(mint&a, mint b){return a=a.value*b.value;}\nmint operator+(mint a, mint b){return a+=b;}\nmint operator-(mint a, mint b){return a-=b;}\nmint operator*(mint a, mint b){return a*=b;}\nmint operator-(mint a){return 0-a;}\nbool operator==(mint a, mint b){return a.value==b.value;}\nbool operator!=(mint a, mint b){return a.value!=b.value;}\n\n\nstd::ostream& operator<<(std::ostream& os, const mint& m){\nreturn ( os << m.value );}\nll extgcd(ll a, ll b, ll &x, ll &y){\n\tll d=a;\n\tif(b!=0){\n\t\td=extgcd(b, a%b, y, x);\n\t\ty-=(a/b)*x;\n\t}\n\telse{\n\t\tx=1,y=0;\n\t}\n\treturn d;\n}\nll modinverse(ll a, ll b){\n\tll x,y;\n\tll d=extgcd(a,b, x, y);\n\tassert(d==1);\n\treturn (x%b+b)%b;\n}\nmint& operator/=(mint&a, mint b){return a=a.value*modinverse(b.value,mod);}\nmint operator/(mint a, mint b){return a/=b;}\n\nconst int D=2000010;\nmint factorial[D];\nmint invfactorial[D];\nmint pow2[D];\n\nstruct Precomp{\n\tPrecomp(){\n\t\tfactorial[0]=1;\n\t\tfor(ll k=1; k<D; k++)factorial[k].value = factorial[k-1].value*k%mod;\n\t\tinvfactorial[D-1] = mint(1) / factorial[D-1];\n\t\tfor(ll k=D-2; k>=0; k--) invfactorial[k].value = invfactorial[k+1].value*(k+1)%mod;\n\t\tpow2[0]=1;\n\t\tfor(ll k=1; k<D; k++)pow2[k].value = pow2[k-1].value*2%mod;\n\n\t}\n}precomp;\n\nmint comb(ll n, ll a){\n\tif(0<=a && a<=n)return factorial[n] * invfactorial[a] * invfactorial[n-a];\n\telse return mint(0);\n}\n\nmint Rcomb(ll n, ll r){\n\t// x_1+...+x_r= nの個数\n\tif(n==0 && r>=0)return 1;\n\treturn comb(n+r-1, r-1);\n}\n\n\nll memo[2010][2010];\n\nmint rec(int n, int i){\n\tassert(0<=i && i<n);\n\t ll &ret = memo[n][i];\n\tif(ret != -1) return mint(ret);\n\tmint ans;\n\tif(n==1 || n==2){\n\t\tans = 1;\n\t}\n\telse if(i==0){\n\t\tans = 2*rec(n-1, 0);\n\t}\n\telse if(i==n-1 || i==n-2){\n\t\tans = comb(2*(n-1),n-1) / n ;\n\t}\n\telse{\n\t\tans = rec(n-1, i)*2 + rec(n,i-1)/2;\n\t}\n\treturn ret = ans.value;\n}\n\nvoid _main(istream &inp){\n\tnclr(memo);\n\tll n,k;\n\tinp >> n >> k;\n\tcout << rec(n,k-1) << endl;\n//\tFOR(n,17,18){\n//\t\trep(i,n){\n//\t\t\tdeb(n);deb(i);deb(rec(n,i));debl;\n//\t\t}\n//\t}\n//\tcout << fixed << setprecision(12);\n//\twhile(true){\n//\t\tbreak;\n//\t}\n\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2e3+10;\nint n,m,dp[maxn][maxn];\nint Pow(int a,long long k)\n{\n\tint ret=1;\n\twhile(k)\n\t{\n\t\tif(k&1)ret=ret*1LL*a%mod;\n\t\tk>>=1,a=a*1LL*a%mod;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tdp[0][n+1]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint sum=dp[i-1][n+1];\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tsum+=dp[i-1][j],sum%=mod;\n\t\t\tif(n-i+1>=j)dp[i][j]=sum;\n\t\t}\n\t}\n\tint ret=(dp[m][1]-dp[m-1][1]+mod)%mod;\n\tprintf(\"%lld\\n\",ret*1LL*Pow(2,n-m-1)%mod);\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mm=1000000007;\nint i,j,k,n,m,ans,f[2101][2101],s[2101][2101];\nint main(){\n\tscanf(\"%d%d\",&n,&m);memset(f,0,sizeof(f));\n\tfor (i=2;i<=n;i++) f[1][i]=1,s[1][i]=i-1;\n\tfor (i=2;i<m;i++){\n\t\tfor (j=2;j<=n-i+1;j++){\n\t\t\tif (n-j-i+2>0) f[i][j]=f[i-1][j];else f[i][j]=0;\n\t\t\tf[i][j]=(f[i][j]+s[i-1][n]-s[i-1][j])%mm;\n\t\t}\n\t\tfor (j=2,s[i][1]=0;j<=n;j++) s[i][j]=(s[i][j-1]+f[i][j])%mm;\n\t}\n\tfor (ans=(m==1)?1:s[m-1][n],i=1;i<n-m;i++) ans=ans*2%mm;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll N, K;\nvector<vector<ll>> dp, sum;\n\nll beki(ll a, ll b) {\n    if(b == 0) return 1;\n    ll ret = beki(a, b / 2);\n    ret = ret * ret % mod;\n    if(b & 1) ret = ret * a % mod;\n    return ret;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> K;\n    dp.resize(N + 1, vector<ll>(N + 2));\n    sum.resize(N + 1, vector<ll>(N + 2));\n    dp[0][N+1] = 1;\n    for(int i = N; i >= 0; i--) {\n        sum[0][i] = sum[0][i+1] + dp[0][i+1];\n    }\n    for(int i = 1; i < K; i++) {\n        for(int val = N; val >= 2; val--) {\n            dp[i][val] = sum[i-1][val];\n            if(val + i <= N + 1) dp[i][val] += dp[i-1][val];\n            dp[i][val] %= mod;\n        }\n        for(int val = N; val >= 0; val--) {\n            sum[i][val] = sum[i][val+1] + dp[i][val+1];\n            dp[i][val] %= mod;\n        }\n    }\n    ll ans = 0;\n    for(int i = 2; i <= N + 1; i++) {\n        ans += dp[K-1][i];\n        ans %= mod;\n    }\n    if(N - K > 1) {\n        ans *= beki(2, N - K - 1);\n    }\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint t=1,sum=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-') t=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t\tsum=sum*10+ch-'0',ch=getchar();\n\treturn t*sum;\n}\nconst int Max=2e3+10,mod=1e9+7;\nint f[Max][Max],sum[Max],fac[Max],inv[Max],n,m;\nvoid up(int &x,int y) { x+=y; if(x>=mod) x-=mod; }\nint C(int i,int j) \n{ \n\tif(i<0||j<0||i<j) return 0;\n\treturn 1LL*fac[i]*inv[j]%mod*inv[i-j]%mod; \n}\nint main()\n{\n\tint i,j;\n\tn=read(); m=read();\n\tf[0][0]=1;\n\tfor(i=1;i<m;i++)\n\t{\n\t\tsum[0]=f[i-1][0];\n\t\tfor(j=1;j<i;j++)\n\t\t\tsum[j]=(sum[j-1]+f[i-1][j])%mod;\n\t\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tf[i][j]=sum[j];\n\t\t\tif(j>=i)\n\t\t\t\tup(f[i][j],mod-sum[j-i]);\n\t\t}\n\t}\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor(i=2;i<=n;i++)\n\t\tinv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(i=1;i<=n;i++)\n\t\tinv[i]=1LL*inv[i-1]*inv[i]%mod,\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\tsum[0]=f[m-1][0];\n\tfor(i=1;i<=n;i++)\n\t\tsum[i]=(sum[i-1]+f[m-1][i])%mod;\n\tint ans=0;\n\tfor(i=2;i<=n;i++)\n\t{\n\t\tif(i-2<n-m-1)\n\t\t\tcontinue;\n\t\tup(ans,1LL*C(i-2,n-m-1)*sum[n-i]%mod);\n\t}\n\tfor(i=m+1;i<n;i++)\n\t\tans=1LL*ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define poly vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\ninline ll read(){\n\tll x=0;char ch=getchar();bool d=1;\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') d=0;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn d?x:-x;\n}\ninline void write(ll x){\n\tif(x<0) x=-x,putchar('-');\n\tif(x>=10) write(x/10);\n\tputchar('0'+x%10);\n}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void writep(ll x){write(x);putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=2005,mo=1e9+7;\nint f[N][N],g[N][N];\nvoid upd(int &x,int y){\n\tx+=y;if(x>=mo) x-=mo;\n}\nint main(){\n\tint n=read(),m=read();\n\tFor(i,2,n) f[1][i]=1;\n\tFor(i,1,m-1){\n\t\tint sum=f[i][n-i+1];\n\t\tRep(j,n-i,2){\n\t\t\tupd(sum,f[i][j]);\n\t\t\tupd(f[i+1][j],sum);\n\t\t}\n\t}\n\tint ans=0;\n\tFor(i,2,n-m+2) upd(ans,f[m-1][i]);\n\tif(m==1) ans=1;\n\tint tot=1;\n\tFor(i,1,n-m-1) tot=(ll)2*tot%mo;\n\tcout<<(ll)ans*tot%mo;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <deque>\n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vecll v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\n\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nconst ll MOD=1e9+7;\nconst int N=500000;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nmain(){\n    mint n=in(),k=in();\n    vector<vector<mint>> dp(k.a+10,vector<mint>(n.a+10));\n    dp[0][0]=1;\n    rep(i,k.a-1){\n        vector<mint> next(n.a+10);\n        rep2(j,0,n.a-1){\n            next[j+1]+=dp[i][j];\n            next[n.a]-=dp[i][j];\n        }\n        rep(j,n.a){\n            next[j+1]+=next[j];\n            dp[i+1][j]+=next[j];\n        }\n        rep(j,n.a){\n            if(j!=i){\n                dp[i+1][j]+=dp[i][j];\n            }\n        }\n        // rep(j,n.a)cout<<dp[i+1][j].a<<\" \";\n        // cout<<endl;\n    }\n    mint ans;\n    rep(i,n.a){\n        ans+=dp[k.a-1][i];\n    }\n    // cout<<ans.a<<endl;\n    if(n.a>k.a)\n    ans*=modpow(2,n.a-k.a-1);\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nll dp[2020][2020],comb[2020][2020];\nint main(){\n    int n,k;\n    cin>>n>>k;\n    dp[0][0]=1;\n    rep(i,n){\n        rep(j,n+1)dp[i+1][j+1]=dp[i][j];\n        rep(j,n+1)(dp[i+1][n-j]+=dp[i+1][n-j+1])%=mod;\n    }\n    comb[0][0]=1;\n    REP(i,1,n+1)rep(j,i+1){\n        if(j==0||j==i)comb[i][j]=1;\n        else comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%mod;\n    }\n    ll ret=dp[k-1][0]*comb[n-1][k-1]%mod;\n    rep(i,n-k-1)ret=ret*2%mod;\n    cout<<ret<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, K, C;\nll dp[2010][2010];\n\nvoid solve() {\n\tcin >> N >> K;\n\tC = N - K;\n\tll pow2 = 1;\n\trep(i, 0, C - 1) MUL(pow2, 2);\n\trep(i, 0, C + 1) dp[i][0] = pow2;\n\trep(k, 1, K) {\n\t\tll tmp = 0;\n\t\trep(i, 1, C + k) {\n\t\t\tADD(tmp, dp[i][k - 1]);\n\t\t\tdp[i][k] = tmp;\n\t\t}\n\t\tdp[C + k][k] = (tmp + dp[C + k - 1][k - 1]) % mod;\n\t}\n\tcout << dp[N - 1][K - 1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 2005;\nconst int mod = 1e9 + 7; \nusing namespace std;\n\nint n, m, f[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint fpow(int x, int y)\n{\n\tint res = 1;\n\tfor( ; y; y >>= 1, x = 1ll * x * x % mod)\n\t\tif(y & 1) res = 1ll * res * x % mod;\n\treturn res; \n}\n\nint main()\n{\n#ifndef ONLIND_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin); \n#endif\n\tn = read <int> (), m = read <int> (); \n\tf[n + 1] = 1; \n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = n; j; j--)\n\t\t{\n\t\t\tif(n - j + 1 < i) f[j] = 0; \n\t\t\telse f[j] = (f[j] + f[j + 1]) % mod; \n\t\t}\n\tif(n != m) f[1] = 1ll * f[1] * fpow(2, n - m - 1) % mod; \n\tprintf(\"%d\\n\", f[1]); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 2010;\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint n, K;\nint f[MAXN][MAXN], g[MAXN][MAXN], suc[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> K;\n\tf[n + 1][0] = 1;\n\tfor (int i = n; i; --i) {\n\t\tfor (int j = n; ~j; --j) {\n\t\t\treduce(suc[j] = f[i + 1][j] + g[i + 1][j] - mod);\n\t\t\tif (i != 1) reduce(suc[j] += suc[j + 1] - mod);\n\t\t\treduce(g[i][j + 1] += g[i + 1][j] - mod);\n\t\t\treduce(g[i][j + 1] += f[i + 1][j] - mod);\n\t\t\treduce(f[i][j] += suc[j] - mod);\n\t\t}\n\t}\n\tstd::cout << pow(2, n - K - 1, f[1][n - K]) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int P  = 1e9+7;\nconst int N =2010;\n\nint n,K;\nint f[N][N],g[N][N];\ninline void add(int &x,int y){x=(x+y)%P;}\nint c[N][N];\n\nint main(){\n\tfor(int i = 0;i<N;i++){\n\t\tc[i][0] =1;\n\t\tfor(int j =1;j<=i;j++) c[i][j] =(c[i-1][j-1]+c[i-1][j])%P;\n\t}\n\t\n\tscanf(\"%d%d\",&n,&K);\n\tfor(int i = 0;i<N;i++) f[i][0] = 1;\n\tfor(int i = 1;i<N;i++){\n\t\tfor(int j =1;j<=i;j++) f[i][j] = (f[i][j-1]+f[i-1][j])%P;\n\t}\n\t//cout<<f[2][2]<<endl;\n\tint ans = 0, tmp  = 0;\n\tif(n-K==0) tmp = 1;\n\telse {\n\t\tfor(int i=1;i<=n-K;i++) add(tmp,c[n-K-1][i-1]);\n\t}\n\tif(n-K>0)\n\tfor(int i = n-K;i<=n-1;i++){\n\t\tadd(ans,1ll*c[i-1][n-K-1]*f[K-1][n-1-i]%P*tmp%P);\n\t\n\t} else ans = f[n-1][n-1];\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 2010\n#define mod 1000000007\nusing namespace std;\nint n, k, f[N][N], s[N], ans;\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tmemset(f, 0, sizeof(f)); f[0][n+1]=1;\n\ts[n+1]=1; for(int i=n; i; i--)s[i]=(s[i+1]+f[0][i])%mod;\n\tfor(int i=1; i<=k-1; i++){\n\t\tfor(int j=1; j<=n+1-i; j++)f[i][j]=s[j];\n\t\ts[n+1]=f[i][n+1]; for(int j=n; j; j--)s[j]=(s[j+1]+f[i][j])%mod;\n\t}\n\tans=0; for(int i=2; i<=n+1; i++)ans=(ans+f[k-1][i])%mod;\n\tfor(int i=1; i<=n-k-1; i++)ans=ans*2%mod;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nvoid read(int &x) {\n    char ch; bool ok;\n    for(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;\n    for(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;\n}\n#define rg register\nconst int maxn=2010,mod=1e9+7;\nint n,k,ans,f[maxn][maxn],sum[maxn];\nint mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint del(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mi(int a,int b){\n\tif(b<=0)return 1;\n    int ans=1;\n    while(b){\n        if(b&1)ans=mul(ans,a);\n        b>>=1,a=mul(a,a);\n    }\n    return ans;\n}\nint main(){\n    read(n),read(k);f[0][n+1]=1;\n    for(rg int i=1;i<=k;i++){\n    \tsum[n+1]=f[i-1][n+1];\n    \tfor(rg int j=n;j;j--)sum[j]=add(sum[j+1],f[i-1][j]);\n    \tfor(rg int j=1;j<=n-i+1;j++)f[i][j]=add(f[i][j],sum[j]);\n\t}\n    printf(\"%d\\n\",mul((del(f[k][1],f[k-1][1])),mi(2,n-k-1)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconst int MAXN = 2005;\nconst int mod = 1e9 + 7;\n\nint n, k;\nint dp[MAXN][MAXN];\nint sum[MAXN];\n\nint main(){\n\tcin >> n >> k;\n\tfor(int i=2; i<=n+1; i++) dp[k-1][i] = 1;\n\tfor(int i=k-2; i>=0;i--){\n\t\tfor(int j=1; j<=n+1; j++) sum[j] = (sum[j-1] + dp[i+1][j]) % mod;\n\t\tfor(int j=1; j<=n+1; j++){\n\t\t\tlint ret = sum[j - 1];\n\t\t\tif(i + j != n + 1) ret += dp[i+1][j];\n\t\t\tdp[i][j] = ret % mod;\n\t\t}\n\t}\n\tlint ans = dp[0][n+1];\n\tfor(int i=k+2; i<=n; i++) ans = (ans << 1) % mod;\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 2005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint;\nmint ex(mint a, ll t);\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=ex(a,mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nmint ex(mint a, ll t) {\n  if(!t) return 1;\n  mint res = ex(a,t/2);\n  res *= res;\n  return (t&1)?res*a:res;\n}\n//\n\n\nmint dp[MX][MX];\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\",&n,&m); --m;\n  dp[0][0] = 1;\n  rep(i,m) {\n    vm s(n+1);\n    rep(j,n) s[j+1] = s[j]+dp[i][j];\n    rep(j,n-1-i) {\n      dp[i+1][j] = dp[i][j+1];\n      dp[i+1][j] += s[j+1];\n    }\n  }\n  mint ans;\n  rep(i,n) {\n    ans += dp[m][i];\n  }\n  rep(i,n-m-2) ans *= 2;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 2010\nll dp[N][N];\n\nint main(){\n\tint n, k;\n\tcin>>n>>k;\n\tdp[0][0] = 1;\n\trep(i, n-k-1) (dp[0][0]*=2)%=mod;\n\tdp[0][1] = mod-dp[0][0];\n\trep(i, k+1){\n\t\tfor(int j = i; j < n; j++){\n\t\t\t(dp[i+1][max(i+1, j)]+=dp[i][j])%=mod;\n\t\t\t(dp[i][j+1]+=dp[i][j])%=mod;\n\t\t}\n\t}\n\tcout<<(dp[k][n]%mod+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2000 +10;\nconst long long mod = (long long)1000000007;\nint read(){\n\tint x=0,flag=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*flag;\n}\nint n,k;\nlong long f[maxn][maxn],g[maxn][maxn];\nlong long Pow(long long x,int t){\n\tif( t< 0 )return 1LL;\n\tlong long ans = 1LL;\n\twhile(t){\n\t\tif(t&1)ans=ans*x%mod;\n\t\tx=x*x%mod;t>>=1;\n\t}\n\treturn ans%mod;\n}\nlong long Add(long long x,long long y){\n\tif( x + y >= mod) return x + y - mod;\n\treturn x +y;\n}\nint main(){\n\tn=read();k=read();\t\n\tf[1][n-k]=Pow(2LL,n-k-1);\n\n\tg[1][0]=0;\n\tfor(int j=1;j<=n;j++)g[1][j] = Add( g[1][j-1] , f[1][j] );\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=0;n-i>=j;j++){\n\t\t\tf[i][j] = Add( f[i-1][j+1] , g[i-1][j] ) ;\n\t\t\tg[i][j] = Add( g[i][j-1] , f[i][j] );\n\t\t}\n\t}\n\tcout << f[n][0] << endl;\n\tcerr << (double)clock()/CLOCKS_PER_SEC << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll _v) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M(0) - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return (*this).pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<1000000007>;\n\nconst int MN = 2333;\nint n, k;\nMint dp[MN], ndp[MN];\nMint two[MN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    two[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        two[i] = Mint(2) * two[i - 1];\n    }\n\n    cin >> n >> k;\n    if (n == 1) {\n        cout << 1 << \"\\n\";\n        return 0;\n    }\n    if (k == 1) {\n        cout << two[n - 2] << \"\\n\";\n        return 0;\n    }\n    fill(dp + 2, dp + n + 1, 1);\n    for (int i = 1; i < k - 1; i++) {\n        copy(dp + 2, dp + n - i + 2, ndp + 2);\n        for (int j = n - i; j >= 2; j--) {\n            ndp[j] += ndp[j + 1];\n        }\n        copy(ndp + 2, ndp + n - i + 1, dp + 2);\n    }\n\n    Mint ans = accumulate(dp + 2, dp + n - k + 3, Mint(0));\n    ans *= two[max(0, n - k - 1)];\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2000 +10;\nconst long long mod = (long long)1000000007;\nint read(){\n\tint x=0,flag=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*flag;\n}\nint n,k;\nlong long f[maxn][maxn],g[maxn][maxn];\nlong long Pow(long long x,int t){\n\tif( t< 0 )return 1LL;\n\tlong long ans = 1LL;\n\twhile(t){\n\t\tif(t&1)ans=ans*x%mod;\n\t\tx=x*x%mod;t>>=1;\n\t}\n\treturn ans%mod;\n}\nlong long Add(long long x,long long y){\n\tif( x + y >= mod) return x + y - mod;\n\treturn x +y;\n}\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin),freopen(\"test.out\",\"w\",stdout);\n#endif\n\tn=read();k=read();\t\n\tf[1][n-k]=Pow(2LL,n-k-1);\n\n\tg[1][0]=0;\n\tfor(int j=1;j<=n;j++)g[1][j] = Add( g[1][j-1] , f[1][j] );\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=0;n-i>=j;j++){\n\t\t\tf[i][j] = Add( f[i-1][j+1] , g[i-1][j] ) ;\n\t\t\tg[i][j] = Add( g[i][j-1] , f[i][j] );\n\t\t}\n\t}\n\tcout << f[n][0] << endl;\n\tcerr << (double)clock()/CLOCKS_PER_SEC << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define go(i,a,b) for(int i=a;i<=b;++i)\n#define com(i,a,b) for(int i=a;i>=b;--i)\n#define mem(a,b) memset(a,b,sizeof(a))\n#define fo(i,a) for(int i=0;i<a;++i)\n#define il inline\n#define int long long\n\nconst int inf=0x3f3f3f3f,N=2010,mod=1e9+7;\n\nint n,m,dp[N];\n\nil void read(int &x){\n\tx=0;char c=getchar(),f=1;\n\twhile(!isdigit(c)){ if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)){ x=x*10+c-'0'; c=getchar(); }\n\tx*=f;\n}\n\nsigned main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tread(n),read(m);\n\tdp[n]=1;\n\tgo(i,1,m){\n\t\tcom(j,n,1){\n\t\t\tif(n-j+1<i) dp[j]=0;\n\t\t\telse (dp[j]+=dp[j+1])%=mod;\n\t\t}\n\t}\n\tint ans=1;\n\tgo(i,1,n-m-1) ans=ans*2%mod;\n\tprintf(\"%lld\",ans*dp[1]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2010\n#define ll long long\n#define For(i,x,y) for(int i=(x);i<=(y);++i)\n#define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n#define Edge(x) for(int i=head[x];i;i=e[i].nxt)\n#define mset(x,y) memset(x,y,sizeof(x))\n#define strL strlen\n#define p_b push_back\n#define mcpy(x,y) memcpy(x,y,sizeof(x))\n#define lson l,mid,(o<<1)\n#define rson mid+1,r,((o<<1)|1)\n#define Ls (t[o].ls)\n#define Rs (t[o].rs)\n#define mod 1000000007\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\nusing namespace std;\nint _2[N],f[N][N],sub[N][N];\nvoid init(int n){For(i,1,n) _2[i]=(_2[i-1]+_2[i-1])%mod;}\nint main(){\n\tint n,k,ans=0;\n\tscanf(\"%d%d\",&n,&k);\n\tinit(n);\n\tFor(i,2,n+1) sub[0][i]=1;\n\tFor(i,1,k-1) Rof(j,n-i+1,2){\n\t\tif(j<=n-i+1) (f[i][j]+=sub[i-1][j])%=mod;\n\t\tsub[i][j]=(sub[i][j+1]+f[i][j])%mod;\n\t}\n\tFor(i,2,n-k+2) (ans+=1ll*f[k-1][i])%=mod;\n\tif(k==1) ans=1;\n\tans=1ll*ans*_2[n-k-1]%mod; \n\tprintf(\"%d\\n\",ans); \n}\n"
  },
  {
    "language": "C++",
    "code": "int f[2002],n,k,ans;\nconst int md=1e9+7;\nint main(){\n\t__builtin_scanf(\"%d%d\",&n,&k);\n\tf[n+1]=1;\n\tfor(int i=1;i<k;++i)for(int j=n-i+1;j>1;--j)(f[j]+=f[j+1])%=md;\n\tfor(int i=2;i<=n-k+2;++i)ans=(ans+f[i])%md;\n\tfor(int i=n-k-1;i;--i)ans=ans*2%md;\n\t__builtin_printf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\nusing namespace std;\ntypedef long long LL;\nconst int N=2005;\nconst int P=1000000007;\ninline int Pow(int a,int b){\n    int c=1;\n    for(;b;b>>=1,a=a*1ll*a%P)if(b&1)c=c*1ll*a%P;\n    return c;\n}\ninline void add(int &a,int b){a+=b;if(a>=P)a-=P;}\ninline void dec(int &a,int b){a-=b;if(a<0)a+=P;}\nint n,k;\nint C[2*N][2*N];\nint f[N][N];\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    rep(i,0,2*n){\n        C[i][0]=C[i][i]=1;\n        rep(j,1,i-1){\n            C[i][j]=C[i-1][j];\n            add(C[i][j],C[i-1][j-1]);\n        }\n    }\n    f[0][0]=1;\n    rep(i,0,n){\n        if(i){rep(j,1,n)add(f[i][j],f[i][j-1]);}\n        rep(j,0,n)if(f[i][j]){\n            dec(f[i+1][j+2],f[i][j]);\n            add(f[i+1][1],f[i][j]);\n        }\n    }\n    if(n==k){\n        int ans=0;\n        rep(i,0,n-1)add(ans,f[n-1][i]);\n        printf(\"%d\\n\",ans);\n        return 0;\n    }\n    int ans=0;\n    rep(i,n-k+1,n){\n        rep(j,0,n-i){\n            add(ans,(f[n-i][j]*1ll*C[i-1-(n-k)+j][j]%P)*1ll*C[i-2][n-k-1]%P);\n        }\n        //printf(\"__%d\\n\",ans);\n    }\n    ans=ans*1ll*Pow(2,n-k-1)%P;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\nll dp[N];\n\nll uni[N];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    dp[0] = 1;\n    uni[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        uni[i] = dp[i - 1];\n        for (int last = 1; last <= i; last++)\n        {\n            dp[i] = (dp[i] + dp[i - last] * uni[last]) % MOD;\n        }\n        //cout << i << \": \" << \" \" << uni[i] << \" \" << dp[i] << endl;\n    }\n    if (n == k)\n    {\n        cout << dp[n - 1];\n        return 0;\n    }\n    ll ans = 0;\n    int M = n - k;\n    for (int tail = M + 1; tail <= n; tail++)\n    {\n        for (int sufixa = tail; sufixa <= tail; sufixa++)\n        {\n            ll r = dp[n - sufixa];\n            r = r * cnk(tail - 2, M - 1) % MOD;\n            ll val = 0;\n            for (int at_right = tail - M - 1; at_right == tail - M - 1 || at_right < sufixa - M - 1; at_right++)\n            {\n                val = (val + cnk(sufixa - M - 1, at_right)) % MOD;\n            }\n            r = r * val % MOD;\n            //cout << tail << \" \" << sufixa << \" \" << dp[n - sufixa] << \" \" << cnk(tail - 2, M - 1) << \" \" << val << endl;\n            ans = (ans + r) % MOD;\n        }\n    }\n    //cout << ans << endl;\n    cout << ans * inq(2, n - k - 1) % MOD;\n    return 0;\n    {\n        ll ans = 0;\n        vector<int> p;\n        for (int i = 0; i < n; i++) p.push_back(i + 1);\n        int cnt = 0;\n        while (1)\n        {\n            int t = (p[0] == 1);\n            for (int i = 1; i < n; i++)\n            {\n                for (int j = i + 1; j < n; j++)\n                {\n                    for (int k = j + 1; k < n; k++)\n                    {\n                        if (p[i] > p[j] && p[j] > p[k]) t = 0;\n                    }\n                }\n            }\n            int w = 0;\n            for (int i = 1; i < n; i++)\n            {\n                int t = 1;\n                for (int j = i; j < n; j++)\n                {\n                    if (p[j] <= i) t = 0;\n                }\n                if (t) w = i;\n            }\n            if (w == 1 && t == 1)\n            {\n                for (auto e : p) cout << e;\n                cout << endl;\n                cnt++;\n            }\n            if (t) ans++;\n            if (!next_permutation(all(p))) break;\n        }\n        cout << cnt << \"\\n\";\n        cout << ans << \"\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\nll dp[2300][2300];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    ll ans = 0;\n    dp[0][0] = 1;\n    for (int i = 1; i <= k; i++)\n    {\n        for (int j = 0; j + i <= n; j++)\n        {\n            for (int pj = 0; pj <= j; pj++)\n            {\n                dp[i][j] = (dp[i][j] + dp[i - 1][pj]) % MOD;\n            }\n        }\n    }\n    if (n == k)\n    {\n        return 1;\n    }\n    int M = n - k;\n    for (int fix = M + 1; fix <= n; fix++)\n    {\n        ll c = cnk(fix - 2, M - 1);\n        ll other_bound = fix - 1 - M;\n        ll val = 0;\n        for (int j = other_bound; j < k; j++)\n        {\n            val = (val + dp[j][n - 1 - j - M]) % MOD;\n            if (j != 0) val = (val + dp[n - 1 - j - M][j]) % MOD;\n        }\n        ans = (ans + val * c) % MOD;\n    }\n    cout << ans * inq(2, n - k - 1) % MOD;\n    return 0;\n    {\n        ll ans = 0;\n        vector<int> p;\n        for (int i = 0; i < n; i++) p.push_back(i + 1);\n        int cnt = 0;\n        while (1)\n        {\n            int t = (p[0] == 1);\n            for (int i = 1; i < n; i++)\n            {\n                for (int j = i + 1; j < n; j++)\n                {\n                    for (int k = j + 1; k < n; k++)\n                    {\n                        if (p[i] > p[j] && p[j] > p[k]) t = 0;\n                    }\n                }\n            }\n            int w = 0;\n            for (int i = 1; i < n; i++)\n            {\n                int t = 1;\n                for (int j = i; j < n; j++)\n                {\n                    if (p[j] <= i) t = 0;\n                }\n                if (t) w = i;\n            }\n            if (w == 1 && t == 1)\n            {\n                for (auto e : p) cout << e;\n                cout << endl;\n                cnt++;\n            }\n            if (t) ans++;\n            if (!next_permutation(all(p))) break;\n        }\n        cout << cnt << \"\\n\";\n        cout << ans << \"\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define loop(s, v, it) for (s::iterator it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = e[i].nxt)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, sum) memset(a, sum, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s.\"out\", \"w\", stdout)\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int N = 2200 ;\nconst int INF = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int MOD = 1000000007 ;\nconst double eps = 1e-7 ;\nvoid print(int x) { cout << x << endl ; exit(0) ; }\nvoid PRINT(string x) { cout << x << endl ; exit(0) ; }\nvoid douout(double x){ printf(\"%lf\\n\", x + 0.0000000001) ; }\n\n/*\n\n\n题意：每次从1~n往两边加数 每次 取的时候从两边取问第k个是1的情况 一共有多少是成立的\n\n首先 我们可以通过观察得出 我1~n加数的这个数列 一定是一个v字形的这么一个序列 然后1在最中间 那么这样的话 我取到1的话是不是说明我前面的k-1一定可以是一个降序序列或者是两个降序序列 那么求一下这个个数我可以dp一下 设f[i][j]表示我已经填了前1~i这么多个位置了 我前面填过的数中最小的是j那我可以知道我现在其实是假设有两个栈 然后分别取数的方案数 比如 我取9 8 7 2\n\n这样 如果下一个数一定要比我大的话 方案数 必须只能转移到当前空缺位置 的最大 否则就是无效的\n\n或者可以选择转移到所有比我小的地方 累积一下方案数\n\n相当于我这个dp要求这样的 有多少个 那么f[i+1][j]自然可以由上一层的f[i][j+1]+f[i+1][j+2]+….得到啊 然后针对这个做一个前缀和优化 变成n^2的情况然后转移的时候要注意一些细节 比如如果k是0的情况\n\n然后那么只要前面k个都确定了 剩下的我是不是还是随便选啦 可以当作是dp 就是每次从两边选一个的方案数一共是多少 那么前面k个确定了 后面我随便放 方案数就是2^(n-k-1)种方案数 为什么呢 因为这次一定剩下的是一条递增的序列了 我想怎么取就怎么取\n\n最后统计答案的时候我只需要把前k-1位的所有情况都取出来 然后后n-k让他随便排 乘一乘就好\n\n*/\n\nint f[N][N], s[N] ;\nint n, k, ans ;\n\nsigned main(){\n    scanf(\"%d%d\", &n, &k) ;\n    f[0][n + 1] = 1 ; s[n + 1] = 1 ;\n\tper(i, n, 1) s[i] = s[i + 1] + f[0][i] ;\n\trep(i, 1, k - 1) {\n\t\trep(j, 1, n - i + 1) f[i][j] = s[j] ;\n\t\ts[n + 1] = f[i][n + 1] ;\n\t\tper(j, n, 1) s[j] = (s[j + 1] + f[i][j]) % MOD ;\n\t}\n\trep(i, 2, n + 1) (ans += f[k - 1][i]) %= MOD ;\n\trep(i, 1, n - k - 1) (ans *= 2) %= MOD ;\n\tprintf(\"%d\\n\", ans) ;\n\n\n\treturn 0 ;\n}\n\n/*\n写代码时请注意：\n\t1.ll？数组大小，边界？数据范围？\n\t2.精度？\n\t3.特判？\n\t4.至少做一些\n思考提醒：\n\t1.最大值最小->二分？\n\t2.可以贪心么？不行dp可以么\n\t3.可以优化么\n\t4.维护区间用什么数据结构？\n\t5.统计方案是用dp？模了么？\n\t6.逆向思维？\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2000, mod = 1e9 + 7;\nint n, k, dp[maxn + 3][maxn + 3];\n\nint func(int x) {\n\treturn x < mod ? x : x - mod;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\tdp[0][n + 1] = 1;\n\tfor (int i = 1; i <= k - 1; i++) {\n\t\tfor (int j = 1; j <= n + 1 - i; j++) {\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t}\n\t\tint sum = dp[i - 1][n + 1];\n\t\tfor (int j = n; j >= 2; j--) {\n\t\t\tdp[i][j] = func(dp[i][j] + sum);\n\t\t\tsum = func(sum + dp[i - 1][j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tans = func(ans + dp[k - 1][i]);\n\t}\n\tfor (int i = k + 2; i <= n; i++) {\n\t\tans = func(ans << 1);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint n,k;\nint f[1005][1005],s[1005];\nconst int p=1000000007;\n\nint main()\n{\n    scanf(\"%d%d\",&n,&k),f[0][n+1]=1;\n    for(int i=1;i<=k;++i)\n    {\n        s[n+1]=f[i-1][n+1];\n        for(int j=n;j>=1;--j)s[j]=(s[j+1]+f[i-1][j])%p;\n        for(int j=1;j<=n-i+1;++j)f[i][j]=s[j];\n    }\n    int Ans=(f[k][1]-f[k-1][1]+p)%p;\n    for(int i=n-k-1;i>=1;--i)Ans=(Ans<<1)%p;\n    printf(\"%d\\n\",Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 2005;\nconst int mod = 1e9+7;\n\nint dp[maxn][maxn],s[maxn][maxn],n,K; \nLL fpm(LL p,LL k) {\n\tLL res=1ll;\n\twhile (k) {\n\t\tif (k&1) (res*=p)%=mod;\n\t\t(p*=p)%=mod;k>>=1;\n\t}\n\treturn res;\n}\nvoid inc(int &x,int y) {\n\tx+=y;x>=mod?x-=mod:0;\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc068f.in\",\"r\",stdin);\n\t\tfreopen(\"arc068f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d\",&n,&K);\n\tif (n==1) {printf(\"1\");return 0;}\n\tdp[0][0]=s[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=n;j>=0;j--)\n\t{\n\t\tif (i!=n) dp[i][j]=dp[i][j+1];\n\t\t//for (int k=max(0,i-j-1);k<i;k++)\n\t\t//\tinc(dp[i][j],dp[k][j-i+k+1]);\n\t\tinc(dp[i][j],s[i-1][j]);\n\t\ts[i][j]=(s[i-1][j-1]+dp[i][j])%mod;\n\t}\n\tint res=(LL)dp[n][n-K]*fpm(2,max(0,n-K-1))%mod;\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nconst long long P=1000000007ll;\nlong long n,k,f[10001];\n\nlong long qpow(long long a,int x){\n    if(x<0)return 1;\n    long long s=1ll;\n    while(x){if(x&1)(s*=a)%=P;(a*=a)%=P;x>>=1;}\n    return s;\n}\n\nint main(){\n    scanf(\"%lld%lld\",&n,&k);\n    f[0]=1ll;\n    for(int i=1;i<n;++i){for(int j=i;j;--j)f[j]=(f[j+1]+f[j-1])%P;f[0]=f[1];}\n    printf(\"%lld\",f[n-k]*qpow(2ll,n-k-1)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long ll;\n\nconst int MAXN = 2E3 + 10;\nconst int MOD = 1E9 + 7;\n\nll modExp(ll e, ll n, ll m = MOD){\n\tll ret = 1;\n\tfor (; n; n >>= 1, e = e * e % m)\n\t\tif (n & 1)\n\t\t\tret = ret * e % m;\n\treturn ret;\n}\n\ninline void update(int &x, int y){\n\tif ((x += y) >= MOD)\n\t\tx -= MOD;\n}\n\nint f[MAXN][MAXN];\n\nint main(){\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tf[0][0] = 1;\n\tfor (int i = 1; i < k; ++i){\n\t\tint s = f[i - 1][i - 1];\n\t\tfor (int j = i; j < n; ++j){\n\t\t\tupdate(f[i][j], s);\n\t\t\tupdate(f[i][j], f[i - 1][j]);\n\t\t\tupdate(s, f[i - 1][j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tupdate(ans, f[k - 1][i]);\n\tprintf(\"%d\\n\", (int)(ans * modExp(2, n == k ? 0 : n - k - 1) % MOD));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nvoid read(int &x) {\n    char ch; bool ok;\n    for(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;\n    for(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;\n}\n#define rg register\nconst int maxn=2010,mod=1e9+7;\nint n,k,ans,f[maxn][maxn],sum[maxn];\nint mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint del(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mi(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=mul(ans,a);\n        b>>=1,a=mul(a,a);\n    }\n    return ans;\n}\nint main(){\n    read(n),read(k);f[0][n+1]=1;\n    if(n==k){printf(\"%d\\n\",1);return 0;}\n    for(rg int i=1;i<=k;i++){\n    \tsum[n+1]=f[i-1][n+1];\n    \tfor(rg int j=n;j;j--)sum[j]=add(sum[j+1],f[i-1][j]);\n    \tfor(rg int j=1;j<=n-i;j++)f[i][j]=add(f[i][j],sum[j]);\n\t}\n    printf(\"%d\\n\",mul(f[k][1],mi(2,n-k-1)));\n}"
  },
  {
    "language": "C++",
    "code": "//O(N^2)\n#include<cstdio>\n#define ll long long\nconst int N=2005,mo=1e9+7;\nint n,k,i,j,f[N][N];\nvoid add(int &x,int k){x=(x+k)%mo;}\nint main(){\n\tscanf(\"%d%d\",&n,&k);f[n+1][0]=1;\n\tfor (i=n+1;i>=3;i--){\n\t\tfor (j=n+1-i;j>=0;j--){\n\t\t\tadd(f[i-1][j+1],f[i][j]);\n\t\t\tadd(f[i][j],f[i][j+1]);\n\t\t\tadd(f[i-1][j],f[i][j]);\n\t\t}\n\t}\n\tint ans=f[2][n-k]; \n\tfor (i=n-k-1;i>=1;i--) ans=2ll*ans%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int p=1e9+7;\nconst int maxn=1e5+5;\nll n,k,f[maxn],ans;\nll quickpow(ll a,ll t)\n{\n\tif(!t) return 1;\n\tll res=1;\n\twhile(t)\n\t{\n\t\tif(t&1) res=(res*a)%p;\n\t\ta=(a*a)%p;\n\t\tt>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0]=1;\n\tfor(ll i=1;i<n;i++)\n\t{\n\t\tfor(ll j=i;j;j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%p;\n\t\tf[0]=f[1];\n\t}\n\tans=f[n-k]*quickpow(2,n-k-1)%p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint dp[2010][2010];\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    dp[0][n+1]=0;\n    for(int i=1;i<=m;i++)\n    {\n        int sum=dp[i-1][n+2-i];\n        for(int j=n+1-i;j;j--)\n        {\n            sum=(sum+dp[i-1][j])%mod;\n            dp[i][j]=sum;\n        }\n    }\n    int ans=dp[m][1]-dp[m-1][1];\n    ans=(ans%mod+mod)%mod;\n    for(int i=1;i<n-m;i++)\n    {\n        ans=ans*2%mod;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename C, typename T> vector<T> prefixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0R (i, sz(v)) res[i+1] = res[i] + v[i]; return res;\n    }\n    template<typename C, typename T> vector<T> suffixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0Rd (i, sz(v)) res[i] = v[i] + res[i+1]; return res;\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.precision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// modnum {{{\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(1e9 + 7)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nint main() {\n    setIO();\n\n    int N, K; re(N, K);\n\n    vvmn seq(N + 1, vmn(N + 1));\n\n    seq[0][0] = 1;\n\n    F0R (pl, N) F0R (sk, N) {\n        if (sk) seq[pl+1][sk-1] += seq[pl][sk];\n        F0R (as, N - pl - sk) seq[pl+1][sk+as] += seq[pl][sk];\n    }\n\n    mn ans = 0;\n    F0R (sk, N-(K-1)) {\n        ans += seq[K-1][sk];\n    }\n    ans *= mn(2).pow(max(0, N-K-1));\n    ps(ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\nconst int P=1e9+7,maxn=2e3+10;\nint n,k,dp[maxn],tot;\ninline void upd(int &x,int y){x+=y;(x>=P)&&(x-=P);}\ninline int ksm(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%P) if(b&1) ans=1ll*ans*a%P;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);if(k==1) return puts(\"1\"),0;dp[n+1]=1;\n\trep(i,1,k-1) per(j,n-i+1,2) upd(dp[j],dp[j+1]);\n\trep(i,2,n-k+2) upd(tot,dp[i]);\n\tprintf(\"%lld\\n\",1ll*tot*ksm(2,n-k-1)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\ntypedef long long LL;\n\nconst int mod = 1e9 + 7;\nconst int NMAX = 10005;\n\nint N, K;\nint fct[NMAX], ifct[NMAX], p2[NMAX];\n\nint power(int x, int y)\n{\n    if(y <= 0)  return 1;\n    int ans = power( (1LL * x * x) % mod, y >> 1 );\n    if(y & 1) ans = (1LL * ans * x) % mod;\n    return ans;\n}\n\nint pw2(int x) { if(x < 0) return 1; return p2[x]; }\n\nint C(int N, int K)\n{\n    if(N < K)   return 0;\n    int ans = (1LL * fct[N] * ifct[K]) % mod;\n    ans = (1LL * ans * ifct[N - K]) % mod;\n    return ans;\n}\n\nvoid pre(int N)\n{\n    fct[0] = 1;\n    for(int i = 1; i <= N; i++) fct[i] = (1LL * fct[i - 1] * i) % mod;\n\n    ifct[N] = power(fct[N], mod - 2);\n    for(int i = N - 1; i >= 0; i--) ifct[i] = (1LL * ifct[i + 1] * (i + 1)) % mod;\n\n    p2[0] = 1;\n    for(int i = 1; i <= N; i++) p2[i] = (2LL * p2[i - 1]) % mod;\n}\n\nint getNumberOfWays(int N, int M)\n{\n    if(N == 0)  return 1;\n    M++;\n    if(N == 1)  return M;\n    int ans = (1LL * fct[M + 2 * N - 1] * ifct[M + N]) % mod;\n    ans = (1LL * ans * M) % mod;\n    ans = (1LL * ans * ifct[N]) % mod;\n    return ans;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    pre(10000);\n\n    scanf(\"%d%d\", &N, &K);\n    if(N == K)\n    {\n        printf(\"%d\\n\", getNumberOfWays(N - 1, 0));\n        return 0;\n    }\n\n    int ans = 0;\n    for(int i = 0; i < K; i++)\n    {\n        int sol = getNumberOfWays(i, K - 1 - i);\n        sol = (1LL * sol * C(N - 2 - i, K - 1 - i)) % mod;\n        ans = (ans + sol) % mod;\n    }\n    ans = (1LL * ans * pw2(N - K - 1)) % mod;\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define X first\n#define Y second\n#define FOE(x, a) for(auto x : a)\n#define FOR(i, a, b) for(int i = a; i <= b; i++)\n#define FOD(i, a, b) for(int i = a; i >= b; i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int N = 2010;\nconst int MOD = 1e9 + 7;\n\nint n, k, C[N][N], F[N][N], sF[N][N];\n\nvoid add(int &x, int y){\n    x += y;\n    x -= (x >= MOD) * MOD;\n}\n\nvoid sub(int &x, int y){\n    x -= y;\n    x += (x < 0) * MOD;\n}\n\nint powMod(int n, int k){\n    assert(n >= 0);\n    if (k == 0)\n        return 1;\n    int res = powMod(n, k >> 1);\n    res = (ll) res * res % MOD;\n    if (k & 1)\n        res = (ll) res * n % MOD;\n    return res;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> k;\n\n    FOR(i, 0, n){\n        C[i][0] = 1;\n        FOR(j, 1, i){\n            add(C[i][j], C[i - 1][j]);\n            add(C[i][j], C[i - 1][j - 1]);\n        }\n    }\n\n    F[0][0] = 1;\n    sF[0][0] = 1;\n\n    FOR(i, 1, n)\n        FOD(j, i, 1){\n            add(F[i][j], sF[i - 1][j]);\n            add(F[i][j], F[i - 1][j - 1]);\n\n            add(sF[i][j], sF[i][j + 1]);\n            add(sF[i][j], F[i][j]);\n        }\n\n    cout << (ll) sF[n - 1][max(1, n - k)] * powMod(2, max(0, n - k - 1)) % MOD;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\nconst int P=1e9+7,maxn=2e3+10;\nint n,k,dp[maxn],tot;\ninline void upd(int &x,int y){x+=y;(x>=P)&&(x-=P);}\ninline int ksm(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%P) if(b&1) ans=1ll*ans*a%P;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);dp[n+1]=1;\n\trep(i,1,k-1) per(j,n-i+1,2) upd(dp[j],dp[j+1]);\n\trep(i,2,n-k+2) upd(tot,dp[i]);\n\tprintf(\"%lld\\n\",1ll*tot*ksm(2,n-k-1)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nint main(void){\n\tint n;\n\tint k;\n\tscanf(\"%d %d\", &n, &k);\n\tlong long a;\n\tlong long b;\n\tlong long c;\n\tlong long s;\n\tlong long cc[10000];\n\tfor (int i = 0; i < 10000; i++)cc[i] = 0;\n\ta = 1;\n\tb = 1;\n\tc = 1;\n\tfor (int i = 0; i < k - 1; i++){\n\t\ta = a * 2;\n\t\ta = a % 1000000009;\n\t}\n\ta = a + 1 - k;\n\tif (a < 0)a = a + 1000000009;\n\tfor (int i = 0; i < n-k-1; i++){\n\t\tb = b * 2;\n\t\tb = b % 1000000009;\n\t}\n\tcc[k - 1] = 1;\n\tfor (int i =n-2; i>=0; i--){\n\t\tfor (int j = 0; j <= i; j++){\n\t\t\tcc[j] = cc[j] + cc[j + 1];\n\t\t\tcc[j] = cc[j] % 1000000009;\n\t\t}\n\t}\n\tc = cc[0];\n\ts = a*b;\n\ts = s % 1000000009;\n\ts = s*c;\n\ts = s % 1000000009;\n\tprintf(\"%lld\\n\",s);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std; \n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define sc(x) scanf(\"%d\",&x);\n#define rep2(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\nconst ll mod=1e9+7;\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\nll dp[2005][2005],sum[2005][2005];\nll ap(ll a,ll b)\n{\n\treturn ((a%mod)*(b%mod))%mod;\n}\nll ad(ll a,ll b)\n{\n\treturn ((a%mod)+(b%mod))%mod;\n}\nll ksm(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b%2==1)res=ap(res,a);\n\t\ta=ap(a,a);\n\t\tb/=2;\n\t}\n\treturn res;\n}\nll jc[2005];\nint n;\nvoid init()\n{\n\tjc[0]=1;\n\trep(i,1,2000)jc[i]=ap(jc[i-1],i);\n}\nll ny(ll x)\n{\n\treturn ksm(x,mod-2);\n}\nll C(ll n,ll m)\n{\n\treturn ap(jc[n],ap(ny(jc[n-m]),ny(jc[m])));\n}\nint main(int argc, char** argv) {\n\tint k;\n\tsc(n);\n\tinit();\n\tsc(k);\n\tll ans=0;\t\n\t\n\tdp[0][n]=1; \n\trep(i,0,k-1)//k-1次 ,假设选k-1个元素 \n\t{\n\t\trep(j,2,n)\n\t\t{\n\t\t\tif(i==0)break;\n\t\t//\tcout<<k-1<<\" \"<<(j-1)<<\" \"<<i<<endl;\n\t\t\tif(n-(j-1)<i)continue;\n\t\t\t\n\t\t\tdp[i][j]=sum[i-1][j+1];//往下更新最小值算在最小队列头上 \n\n\t\t\tdp[i][j]=ad(dp[i-1][j],dp[i][j]); //肯定是按顺序往下走 \n\t\t}\n\t\trep2(j,n,2)\n\t\t{\n\t\t\tsum[i][j]=ad(sum[i][j+1],dp[i][j]); \n\t\t}\n\t\t//cout<<ksm(2,n-k)<<endl;\n\t\t\n\t}\n\trep(i,2,n)\n\tans=ad(ans,ap(ksm(2,n-k-1),dp[k-1][i]));\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll inf=1000000000000000000;\nlong double pi=3.14159265358979323846L;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll gya[1000010];\nll kai[1000010];\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nvoid nckinit(ll n,ll md){\n  kai[0]=1;\n  kai[1]=1;\n  for(int i=2;i<=n;i++){\n    kai[i]=kai[i-1]*i;\n    kai[i]%=md;\n  }\n  gya[n]=gyaku(kai[n],md);\n  for(int i=n-1;i>=1;i--){\n    gya[i]=gya[i+1]*(i+1);\n    gya[i]%=md;\n  }\n  gya[0]=1;\n}\nll nck(ll n,ll k,ll md){\n  if(k<0)return 0;\n  if(k==0||n==k)return 1;\n  ll ret=kai[n];\n  ret*=gya[n-k];\n  ret%=md;\n  ret*=gya[k];\n  ret%=md;\n  return ret;\n}\nll npk(ll n,ll k,ll md){\n  if(k<0)return 0;\n  if(k==0)return 1;\n  ll ret=kai[n];\n  ret*=gya[n-k];\n  ret%=md;\n  return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    ll n,k;cin>>n>>k;\n    nckinit(10000,mod);\n    ll kata[2010];\n    rep(i,0,2010){\n        kata[i]=nck(2*i,i,mod);\n        kata[i]*=gyaku(i+1,mod);\n        kata[i]%=mod;\n    \n    }\n    ll sum=0;\n    rep(i,0,k-1){\n        ll cn=nck(n-i-2,k-i-1,mod);\n        ll su=0;\n        rep(j,0,i+1){\n            ll u=k-j-2;\n            ll t=nck(u,i-j,mod);\n            t*=kata[j];\n            t%=mod;\n            su+=t;\n            su%=mod;\n        }\n        su*=cn;\n        su%=mod;\n        sum+=su;\n        sum%=mod;\n    }\n    sum+=kata[k-1];\n    sum%=mod;\n    ll r;\n    if(k==n)r=1;\n    else r=beki(2,n-k-1,mod);\n    sum*=r;\n    sum%=mod;\n    cout<<sum<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 20010\n#define mo 1000000007ll\nint f[N];\nint n,k;\nll qp(ll x,ll y){\n\tll r=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1)r=r*x%mo;\n\treturn r;\n}\nsigned main(){\n\tcin>>n>>k;\n\tf[0]=1;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i;j;j--)\n\t\t\tf[j]=(f[j+1]+f[j-1])%mo;\n\t\tf[0]=f[1];\n\t}\n\tcout<<1ll*f[n-k]*qp(2,n-k-1)%mo;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\n#include<random>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll, ll>;\n#define INF 1000000000LL\n#define EPS 1e-12\n#define FOR(i,n,m) for(ll i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n#include <cstdint>\nusing i64 = std::int_fast64_t;\nconst static i64 mod = 1000000007;\nstruct mint {\n\ti64 n;\npublic:\n\tmint(const i64 n = 0) : n((n % mod + mod) % mod) {}\n\tmint pow(int m) const {\n\t\ti64 a = n, r = 1;\n\t\twhile(m > 0) {\n\t\t\tif(m & 1) { r *= a; r %= mod; }\n\t\t\ta = (a * a) % mod; m /= 2;\n\t\t}\n\t\treturn mint(r);\n\t}\n\tmint &operator++() { *this += 1; return *this; }\n\tmint &operator--() { *this -= 1; return *this; }\n\tmint operator++(int) { mint ret = *this; *this += 1; return ret; }\n\tmint operator--(int) { mint ret = *this; *this -= 1; return ret; }\n\tmint operator~() const { return (this -> pow(mod - 2)); } // inverse\n\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n == rhs.n;\n\t}\n\tfriend bool operator<(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n < rhs.n;\n\t}\n\tfriend bool operator>(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n > rhs.n;\n\t}\n\tfriend mint &operator+=(mint& lhs, const mint& rhs) {\n\t\tlhs.n += rhs.n;\n\t\tif (lhs.n >= mod) lhs.n -= mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator-=(mint& lhs, const mint& rhs) {\n\t\tlhs.n -= rhs.n;\n\t\tif (lhs.n < 0) lhs.n += mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator*=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * rhs.n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator/=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * (~rhs).n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n + rhs.n);\n\t}\n\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n - rhs.n);\n\t}\n\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * rhs.n);\n\t}\n\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * (~rhs).n);\n\t}\n};\nistream& operator>>(istream& is, mint& m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, mint& m) { os << m.n; return os; }\n\ntemplate <typename T>\nclass SegTree {\nprivate:\n\tint n;\n\tconst function<T(T, T)> op; // 演算\n\tconst T ie; // 演算の単位元\n\tvector<T> seq;\n\npublic:\n\t/// op: 演算, ie: 演算の単位元\n\tSegTree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tseq.resize(2 * n - 1);\n\t\tfor(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n\t}\n\n\t/// k 番目(0-indexed)の要素を e で更新\n\tvoid update(int k, const T e) {\n\t\tk += n - 1;\n\t\tseq[k] = e;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n\t\t}\n\t}\n\n\t// k 番目(0-indexed)の要素を取得\n\tT get(int k) {\n\t\tk += n - 1;\n\t\treturn seq[k];\n\t}\n\n\t/// [a, b) 番目(0-indexed)の要素全体の演算結果を返す\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1) r = n;\n\t\tif(r <= a || b <= l) return ie;\n\t\tif(a <= l && r <= b) return seq[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn op(vl, vr);\n\t}\n};\n// [Range Sum Query] rsq(n, [] (ll a, ll b) { return a + b; }, 0)\n// [Range Max Query] rMq(n, [] (ll a, ll b) { return max(a, b); }, -1e18)\n// [Range Min Query] rmq(n, [] (ll a, ll b) { return min(a, b); }, 1e18)\n\nclass union_find {\npublic:\n\tunion_find(int n)\n\t: par_(n, -1)\n\t{}\n\tvoid init(int n) {\n\t\tpar_.assign(n, -1);\n\t}\n\n\tint root(int x) {\n\t\treturn par_[x] < 0 ? x : par_[x] = root(par_[x]);\n\t}\n\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif(x == y) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(par_[x] < par_[y]) {\n\t\t\t\tpar_[x] += par_[y];\n\t\t\t\tpar_[y] = x;\n\t\t\t} else {\n\t\t\t\tpar_[y] += par_[x];\n\t\t\t\tpar_[x] = y;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint size(int x) {\n\t\treturn -par_[root(x)];\n\t}\n\nprivate:\n\tstd::vector<int> par_;\n};\n\nmint _pow(mint a, long long n) {\n\tif(n == 0) return 1;\n\tmint res = 1;\n\tmint buf = a;\n\twhile(n > 0) {\n\t\tif(n % 2) res *= buf;\n\t\tbuf *= buf;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nusing mi = mint;\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, k;\n\tcin >> n >> k;\n\tvector<vector<mi>> dp(n + 1, vector<mi>(n + 1, 0));\n\tdp[0][0] = 1;\n\tFOR(i, 1, n + 1) {\n\t\tFOR(j, 1, n + 1) dp[i - 1][j] += dp[i - 1][j - 1];\n\t\tREP(j, n + 1) {\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif(j != n) {\n\t\t\t\tdp[i][j] += (dp[i - 1][j + 1] - dp[i - 1][j]);\n\t\t\t}\n\t\t}\n\t\tif(i == k) {\n\t\t\tdp[i - 1][n - k] *= _pow(2, n - k - 1);\n\t\t\tcout << dp[i - 1][n - k] << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,k;\nll dp[2005][2005];\nll rui[2005][2005];\nll rui2[3005];\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[2005],R[2005];\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<2005;i++) F[i] = F[i-1]*i%mod;\n\tfor(int i=0;i<2005;i++) R[i] = modpow(F[i],mod-2);\n}\nll C(int a,int b){\n\treturn F[a]*R[b]%mod*R[a-b]%mod;\n}\nint main(){\n\tcin>>n>>k; make();\n\tif(k == 1){\n\t    ll ans = 1;\n\t    for(int i=1;i<n-k;i++) ans = ans*2LL%mod;\n\t    cout << ans << endl;\n\t    return 0;\n\t}\n\tdp[1][2] = 1;\n\trui[1][2] = 1;\n\trui2[999] = 1;\n\tfor(int i=2;i<=k-1;i++){\n\t\tdp[i][i+1] = 1;\n\t\tfor(int a=2;a<=i;a++){\n\t\t\t//dp[i][a] wo calc\n\t\t\tdp[i][a] = rui2[i-a+999];\n\t\t\t//for(int b=1;b<=a-1;b++){\n\t\t\t    //dp[i][a] += rui[i-(a-b)][b+1];\n\t\t\t\t//for(int c=b+1;c<=i+1-(a-b);c++) dp[i][a] += dp[i-(a-b)][c];\n\t\t\t//}\n\t\t\t//dp[i][a] %= mod;\n\t\t}\n\t\t//rui[i][x] = dp[i][a(>=x)] no sum\n\t\t//rui2[x] = rui[p+x-1000][p] no sum\n\t\tfor(int x=i+1;x>=2;x--){\n\t\t    rui[i][x] = (rui[i][x+1]+dp[i][x])%mod;\n    \t\trui2[i-x+1000] = (rui2[i-x+1000]+rui[i][x])%mod;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(int a=2;a<=k;a++){\n\t\tans = (ans+dp[k-1][a]*C(n-k+a-1,a-1)%mod)%mod;\n\t}\n\tfor(int i=1;i<n-k;i++) ans = ans*2LL%mod;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll n,k;\nll f[2002][2002],s[2005],ans;\nint main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0][n+1]=1;\t\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=n+1;j;j--)\n\t\t\ts[j]=(s[j+1]+f[i-1][j])%mod,f[i][j]=(j<=n-i+1)?s[j]:0;\n\tans=(f[k][1]-f[k-1][1]+mod)%mod;\n\tfor(int i=1;i<n-k;i++)ans=(ans+ans)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 2005;\nconst int mod = 1000000007;\n\ninline int pow(int a, int b)\n{\n    int ans = 1;\n    for (; b; b >>= 1, a = (LL) a * a % mod)\n        if (b & 1)\n            ans = (LL) ans * a % mod;\n    return ans;\n}\n\nint dp[maxn];\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    dp[n + 1] = 1;\n    for (int i = n; i > n - k; --i)\n    {\n        for (int j = n; j; --j)\n        {\n            if (i < j)\n                dp[j] = 0;\n            else\n            {\n                dp[j] = dp[j + 1] + dp[j];\n                if (dp[j] >= mod)\n                    dp[j] -= mod;\n            }\n        }\n    }\n    printf(\"%d\\n\", (LL) dp[1] * pow(2, n - k - 1) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n    if (k&1)\n        sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    g[0][0]=1;\n    for (int i=1;i<n;i++)\n\t{\n\t    f[i][0]=g[i-1][0];\n\t    g[i][0]=f[i][0];\n\t    for (int j=1;j<=i;j++)\n\t\t{\n\t\t    f[i][j]=g[i-1][j];\n\t\t    g[i][j]=(g[i][j-1]+f[i][j])%mod;\n\t\t}\n\t}\n    //for (int i=0;i<n;i++) printf(\"%d \",g[n-1][i]);\n    int ans=g[n-1][k-1];\n    ans=1ll*ans*power(2,n-k-1)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int Mod = 1e9 + 7, N = 4010;\n\nint fpm(int x, int power) {\n    int res = 1;\n    for (; power; power >>= 1, x = 1ll * x * x % Mod)\n        if (power & 1) res = 1ll * res * x % Mod;\n    return res;\n}\n\nint fac[N], ifac[N];\n\nvoid Fac_Init(int maxn) {\n    fac[0] = ifac[0] = 1;\n    For (i, 1, maxn)\n        fac[i] = 1ll * fac[i - 1] * i % Mod;\n    ifac[maxn] = fpm(fac[maxn], Mod - 2);\n    Fordown (i, maxn - 1, 1)\n        ifac[i] = 1ll * ifac[i + 1] * (i + 1) % Mod;\n}\n\ninline int Comb(int n, int m) {\n\tif (n < 0 || m < 0 || n < m) return 0;\n\treturn 1ll * fac[n] * ifac[n - m] % Mod * ifac[m] % Mod;\n}\n\ninline int f(int n, int m) {\n\tif (m > n) return 0;\n\treturn (Comb(n + m, m) - Comb(n + m, m - 1) + Mod) % Mod;\n}\n\nint main () {\n\n\tFile();\n\n\tint n = read(), k = read();\n\n\tFac_Init(n << 1);\n\n\tprintf (\"%lld\\n\", 1ll * (f(n, k - 1) - f(n, k - 2) + Mod) % Mod * fpm(2, max(n - k - 1, 0)) % Mod);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, K, C;\nll pow2[2010];\nll dp[2010][2010];\n\nvoid solve() {\n\tcin >> N >> K;\n\tpow2[0] = 1;\n\tC = N - K;\n\trep(i, 0, N) {\n\t\tpow2[i + 1] = pow2[i] * 2 % mod;\n\t}\n\trep(i, 0, C + 1) {\n\t\tdp[i][0] = pow2[max(C - 1, 0)];\n\t}\n\trep(k, 1, K) {\n\t\tll tmp = 0;\n\t\trep(i, 1, C + k) {\n\t\t\tADD(tmp, dp[i][k - 1]);\n\t\t\tdp[i][k] = tmp;\n\t\t}\n\t\tdp[C + k][k] = tmp + dp[C + k - 1][k - 1] % mod;\n\t}\n\t// rep(j, 0, K + 1) {\n\t// \trep(i, 0, N + 1) {\n\t// \t\tdebug(i, j, dp[i][j]);\n\t// \t}\n\t// }\n\tcout << dp[N - 1][K - 1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n//struct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define fin \"\\n\"\n\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntemplate <typename T>\ninline void chmin(T &l,T r){l=min(l,r);}\n\ntemplate <typename T>\ninline void chmax(T &l,T r){l=max(l,r);}\n\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\nconst int MOD=1e9+7;\n#define SZ 2123\nLL comb[2*SZ][2*SZ];\nLL C[SZ][SZ];\nstruct latte{\n    latte(){\n        REP(i,2*SZ)comb[i][0]=comb[i][i]=1;\n        FOR(i,2,2*SZ){\n            FOR(j,1,2*SZ){\n                comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n            }\n        }\n        REP(i,SZ)REP(j,SZ)C[i][j]=0;\n        C[0][0]=1;\n        REP(i,SZ-1){\n            FOR(j,0,SZ-1){\n                C[i+1][j+1]+=C[i][j];\n                C[i+1][0]+=MOD-C[i][j];\n            }\n            for(int j=SZ-1;j>0;j--)\n                (C[i+1][j-1]+=C[i+1][j])%=MOD;\n        }\n    }\n}malta;\n\ninline LL nHr(LL n,LL r){\n    //if(r<0||n<r)return 0;\n    return comb[n+r-1][r];\n}\nint main(){\n    int N,K;\n    cin>>N>>K;\n    LL res=0;\n    REP(i,K){\n        //printf(\"use [%d,%d) _ [%d,%d]\\n\",N,N-i,N-i-1,2);\n        int n=i;\n        int r=K-i-1;\n        LL ans=0;\n        REP(j,n+1)\n            ans+=C[n][j]*nHr(j+1,r)%MOD;\n        ans%=MOD;\n        (res+=ans*comb[N-n-2][r]%MOD)%=MOD;\n    }\n    REP(i,N-K-1)(res<<=1)%=MOD;\n    cout<<res<<endl;\n    return 0;\n}\n            \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nint dp[2005],n,k;\nint qpow(int x,int y)\n{\n\tif(y<0)return 1;\n\tint res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nsigned main()\n{\n\tcin>>n>>k;\n\tdp[0]=1;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tfor(int j=i;j>=1;--j)\n\t\t{\n\t\t\tdp[j]=dp[j+1]+dp[j-1];\n\t\t\tif(dp[j]>=mod)dp[j]-=mod;\n\t\t}\n\t\tdp[0]=dp[1];\n\t}\n\tcout<<dp[n-k]*qpow(2,n-k-1)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mod = 1000000007;\nint n, k, f[ 2001 ];\n\nint qpow( int a,int x )\n{\n if( x < 0 )\n  return 1;\n int s = 1;\n while( x )\n {\n  if( x & 1 )\n   s = ( long long ) s * a % mod;\n  a = ( long long ) a * a % mod;\n  x >>= 1;\n }\n return s;\n}\n\nint main()\n{\n scanf( \"%d%d\", &n, &k );\n f[ 0 ] = 1;\n for( int i = 1; i < n; ++i )\n {\n  for( int j = i; j; --j )\n   f[ j ] = ( f[ j + 1 ] + f[ j - 1 ] ) % mod;\n  f[ 0 ] = f[ 1 ];\n }\n printf( \"%lld\", ( long long ) f[ n - k ] * qpow( 2, n - k - 1 ) % mod );\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                ____________    ______________       __\n               / _________  /\\ /_____   _____/\\     / /\\\n              / /\\       / /  \\\\    /  /\\    \\ \\   / /  \\\n             / /  \\_____/ /   / \\__/  /  \\____\\/  / /   /\n            / /   /    / /   /    /  /   /       / /   /\n           / /   /    / /   /    /  /   /       / /   /\n          / /   /    / /   /    /  /   /       / /   /\n         / /___/____/ /   /    /  /   /       / /___/________\n        /____________/   /    /__/   /       /______________/\\\n        \\            \\  /     \\  \\  /        \\              \\ \\\n         \\____________\\/       \\__\\/          \\______________\\/\n           ___       ___               ___    __________\n          /  /\\     /  /\\             /  /\\  /_______  /\\\n         /  /__\\___/  /  \\           /  /  \\ \\      /  /  \\\n        /____    ____/   /          /  /   /  \\____/  /   /\n        \\   /   /\\   \\  /          /  /   /       /  /   /\n         \\_/   /  \\___\\/ ___      /  /   /       /  /   /\n          /   /   /     /  /\\    /  /   /       /  /   /\n         /   /   /     /  /__\\__/  /   /       /  /___/____\n        /___/   /     /___________/   /       /___________/\\\n        \\   \\  /      \\           \\  /        \\           \\ \\\n         \\___\\/        \\___________\\/          \\___________\\/\n\n          A FAN OF FIZZYDAVID\n\n*/\n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define per(i,n) for(int i=(n)-1;i>=0;i--)\n#define forn(i,l,r) for(int i=(l);i<=(r);i++)\n#define nrof(i,r,l) for(int i=(r);i>=(l);i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define orz int\n#define yjz main\n#define fizzydavid return\n#define ak 0\n#define la ;\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(),x.end()\n#define FILL(a,b) memset((a),(b),sizeof((a)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<LL> vl;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\n\nconst int iinf=1e9+7;\nconst LL linf=1ll<<60;\nconst flt dinf=1e10;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f=0; x=0; char c=getchar();\n\twhile((c<'0' || c>'9') && c!='-') c=getchar();\n\tif(c=='-') { f=1; c=getchar(); }\n\twhile(c>='0' && c<='9') { x=x*10+c-'0'; c=getchar(); }\n\tif(f) x=-x; return;\n}\n\ntemplate <typename T1,typename T2>\nvoid scf(T1 &x,T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1,typename T2,typename T3>\nvoid scf(T1 &x,T2 &y,T3 &z) { scf(x); scf(y); return scf(z); }\n\ntemplate <typename T1,typename T2,typename T3,typename T4>\nvoid scf(T1 &x,T2 &y,T3 &z,T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\n#ifdef ONLINE_JUDGE\n#define debug(x,c) ;\n#else\n#define DEBUG\n#define debug(x,c) cerr<<#x<<\"=\"<<x<<c;\n#endif\n\n//---------------------------head----------------------------\n\nconst int N = 2333;\nconst LL mod = 1e9 + 7ll;\n\nint n, k;\nLL dp[N][N];\n\norz yjz()\n{\n    scf(n, k);\n    dp[1][1] = 1ll;\n    forn(i, 2, n) forn(j, 1, i) dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;\n    LL ans = dp[n][k];\n    rep(_, n - k - 1) (ans *= 2) %= mod;\n    printf(\"%lld\\n\", ans);\n\tfizzydavid ak la\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 2010, MOD = 1e9 + 7;\nint dp[2][N],n,k,s,p,sum[N],ans,jc[N],inv[N];\ntypedef long long ll;\nll power(ll a,int b) {\n  ll res = 1;\n  while (b) {\n    if (b&1) (res *= a) %= MOD;\n    (a *= a) %= MOD;\n    b >>= 1;\n  }\n  return res;\n}\nll comb(int a,int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return 1ll * jc[a] * inv[b] % MOD * inv[a-b] % MOD;\n}\nsigned main() {\n  scanf(\"%lld%lld\",&n,&k);\n  jc[0] = 1;\n  for (int i = 1 ; i <= n ; ++ i)\n    jc[i] = 1ll * jc[i-1] * i % MOD;\n  inv[n] = power(jc[n],MOD-2);\n  for (int i = n-1 ; i >= 0 ; -- i)\n    inv[i] = 1ll * inv[i+1] * (i+1) % MOD;\n  s = k-1;\n  p = 0;\n  sum[2] = 1;\n  sum[3] = -1;\n  for (int i = 1 ; i <= s ; ++ i) {\n    p ^= 1;\n    memset(dp[p],0,sizeof dp[p]);\n    for (int j = 1 ; j <= i+1 ; ++ j)\n      (sum[j] += sum[j-1]) %= MOD;\n    for (int j = 1 ; j <= i+1 ; ++ j)\n      (dp[p][j] += sum[j]) %= MOD, sum[j] = 0;\n    sum[i+2] = 0;\n    for (int j = 1 ; j <= i+1 ; ++ j) {\n      (sum[2] += dp[p][j]) %= MOD;\n      (sum[j+2] -= dp[p][j]) %= MOD;\n    }\n  }\n  for (int i = 1 ; i <= s + 1 ; ++ i) {\n    (ans += 1ll * comb(n-k+i-1,i-1) * dp[p][i] % MOD);\n    ans %= MOD;\n  }\n  if (k == 1) ans = 1;\n  if (n > k)\n    ans = 1ll * power(2,n-k-1) * ans % MOD;\n  ans = (ans + MOD) % MOD;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nsigned main(){\n\tvi fact{1};\n\tFOR(i,1,114514)\n\t\tfact.PB(fact.back()*i%mod);\n\tvi factInv;\n\tfor(auto v:fact)\n\t\tfactInv.PB(modInv(v));\n\tconst auto comb=[&](int a,int b){\n\t\treturn fact[a]*factInv[b]%mod*factInv[a-b]%mod;\n\t};\n\tint n=read(),k=read();\n\tint ans=0;\n\tif(k==1)\n\t\tans=1;\n\telse{\n\t\tadd(ans,comb(n-2+k-1,k-1));\n\t\tif(k>=3)\n\t\tsub(ans,comb(n-2+k-1,k-3));\n\t}\n\tif(n-k>0)\n\tmult(ans,modPow(2,n-k-1));\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,k;\nint dp[2010][2010];\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\trep(i,1,n+1) dp[1][i]=1;\n\trep(i,2,n+1) {\n\t\tdp[i][i-1]=dp[i-1][i-1];\n\t\trep(j,i,n+1) {\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1];\n\t\t\tif (dp[i][j]>=mod) dp[i][j]-=mod;\n\t\t}\n\t}\n\tint v=dp[k][n]-dp[k-1][n];\n\tif (v<0) v+=mod;\n\tv=v*powmod(2,max(0,n-k-1))%mod;\n\tprintf(\"%d\\n\",v);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005,M=1e9+7;\nint n,m,f[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tf[n+1]=1;\n\tfor (int i=1;i<m;i++){\n\t\tint sum=f[n-i+2];\n\t\tfor (int j=n-i+1;j>=2;j--){\n\t\t\t(sum+=f[j])%=M;\n\t\t\tif (j<=n-i+1)f[j]=sum;\n\t\t}\n\t}\n\tint ans=0;\n\tif (m==1)ans=1;\n\telse for (int j=2;j<=n-(m-1)+1;j++)(ans+=f[j])%=M;\n\tfor (int i=1;i<=n-m-1;i++)(ans*=2)%=M;\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 2005, mod = 1000000007;\n\nint dp[N][N], sum[N][N], n, k;\nvoid up(int &x, int y) { x += y - mod, x += x >> 31 & mod; }\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> k;\n\tdp[0][n + 1] = 1; for (int i = 1; i <= n + 1; ++i) sum[0][i] = 1;\n\tfor (int i = 1; i < k; ++i) {\n\t\tfor (int j = 1; j <= n - i + 1; ++j)\n\t\t\tup(dp[i][j] = dp[i - 1][j], sum[i - 1][j + 1]);\n\t\tfor (int j = n; j >= 1; --j) up(sum[i][j] = sum[i][j + 1], dp[i][j]);\n\t}\n\tint ans = sum[k - 1][2];\n\tfor (int i = 0; i < n - k - 1; ++i) up(ans, ans);\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\nconst int N = 2017 , mod = 1e9 + 7;\nll dp[N][N] , ps[N][N];\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n , k; cin >> n >> k;\n    dp[1][1] = ps[1][1] = 1; for(int j=1;j<=k;j++)ps[1][j] = 1;\n    for(int i=2;i<=n;i++){\n        for(int j=1;j<=i;j++){\n            dp[i][j] = ps[i - 1][j]; dp[i][j] %= mod;\n            ps[i][j] = (ps[i][j - 1] + dp[i][j]) % mod;\n        }\n        for(int j=i+1;j<=k;j++)ps[i][j] = ps[i][i];\n    }for(int i=0;i<n-k-1;i++)dp[n][k] = (dp[n][k] * 2) % mod;\n    cout << dp[n][k] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\ntypedef long long ll;\nconst int N=2010;\nconst int P=1e9+7;\nint n,K;\nint f[N][N],g[N][N];\ninline ll Pow(ll x,int y) {ll ret=1; for(;y>0;y>>=1,x=x*x%P) if(y&1) ret=ret*x%P; return ret;}\ninline int Add(int x,int y) {x+=y; if(x>=P) x-=P; return x;}\nint main() {\n  scanf(\"%d %d\",&n,&K);\n  f[0][0]=1;\n  for(int i=2;i<=n;i++) f[1][i]=1;\n  for(int i=n;i>=2;i--) g[1][i]=g[1][i+1]+1; \n  for(int i=2;i<K;i++) {\n    for(int j=n-i+1;j>=2;j--) {\n      f[i][j]=g[i-1][j];\n    }\n    for(int j=n-i+1;j>=2;j--) {\n      g[i][j]=Add(g[i][j+1],f[i][j]);\n    }\n  }\n  ll ans=0;\n  for(int i=2;i<=n-K+2;i++) ans=Add(ans,f[K-1][i]);\n  if(K==1) ans=1;\n  ans=ans*Pow(2,n-K-1)%P;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll n,k;\nll f[2002][2002],s[2005],ans;\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tf[0][n+1]=1;\t\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=n+1;j;j--)\n\t\t\ts[j]=(s[j+1]+f[i-1][j])%mod,f[i][j]=(j<=n-i+1)?s[j]:0;\n\tans=(f[k][1]-f[k-1][1]+mod)%mod;\n\tfor(int i=1;i<n-k;i++)ans=(ans+ans)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <list>\n#include <cassert>\n\nusing namespace std;\n\n#define y1 roman_kaban\n#define rank oryshych_konb\n#define ull unsigned long long\nconst int mod = int(1e9) + 7;\nconst long long infLL = 2e18;\nconst int MX = 2061;\nint dp[MX][MX];\nint main()\n{\n    //init();\n    //cerr << delta << endl;\n    //freopen(\"/Users/ozzy/Documents/in.txt\",\"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    dp[0][n + 1] = 1;\n    for(int i = 1; i < k; i++){\n        for(int j = n - i + 1; j > 1; j--){\n            if(j == n - i + 1) dp[i][j] = (dp[i - 1][j] + dp[i - 1][j + 1]) % mod; else\n                            dp[i][j] = (dp[i - 1][j] + dp[i][j + 1]) % mod;\n        }\n    }\n    int ans = 0;\n    for(int j = 1; j <= n; j++){\n        ans += dp[k - 1][j];\n        ans %= mod;\n    }\n    if(k == 1) ans = 1;\n    for(int i = 0; i < n - k - 1; i++){\n        ans *= 2;\n        ans %= mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long N, K, dp[2009][2009], mod = 1000000007;\n\nint main() {\n\tcin >> N >> K;\n\tdp[0][N + 1] = 1;\n\tfor (int i = 1; i <= K; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tint E = N - i + 1;\n\t\t\tif (j > E) continue;\n\t\t\tif (j != 1) dp[i][j] += dp[i - 1][j];\n\t\t\tfor (int k = j + 1; k <= N + 1; k++) dp[i][j] += dp[i - 1][k];\n\t\t\tdp[i][j] %= mod;\n\t\t}\n\t}\n\tlong long G = dp[K][1];\n\tfor (int i = 0; i < N - K - 1; i++) { G *= 2; G %= mod; }\n\tcout << G << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\nusing namespace std;\n\nconst int p=1000000007;\nint n,k,f[2010][2010],ans;\n\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    if (n==1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    f[n][0]=1;\n    repd(i,n,2)\n        repu(j,0,n-i)\n        {\n            if (j)\n                (f[i][j]+=f[i][j-1])%=p;\n            (f[i-1][j]+=f[i][j])%=p;\n        }\n    repu(i,0,k-1)\n        (ans+=f[2][i])%=p;\n    repu(i,1,n-k-1)\n        (ans<<=1)%=p;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n    if (k&1)\n        sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    g[1][0]=1;\n    for (int i=1;i<=k;i++)\n        for (int j=1;j<=n-i+1;j++)\n\t    g[i][j]=(g[i-1][j+1]+g[i][j-1])%mod;\n    printf(\"%lld\\n\",1ll*g[k][n-k+1]*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nvoid read(int &x) {\n    char ch; bool ok;\n    for(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;\n    for(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;\n}\n#define rg register\nconst int maxn=2010,mod=1e9+7;\nint n,k,ans,f[maxn][maxn],sum[maxn];\nint mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint del(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mi(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=mul(ans,a);\n        b>>=1,a=mul(a,a);\n    }\n    return ans;\n}\nint main(){\n    read(n),read(k);f[0][n+1]=1;\n    for(rg int i=1;i<=k;i++){\n    \tsum[n+1]=f[i-1][n+1];\n    \tfor(rg int j=n;j;j--)sum[j]=add(sum[j+1],f[i-1][j]);\n    \tfor(rg int j=1;j<=n-i;j++)f[i][j]=add(f[i][j],sum[j]);\n\t}\n    printf(\"%d\\n\",mul(f[k][1],mi(2,n-k-1)));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[5010],nifac[5010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nlong long work(int n,int m)\n{\n\tif ((n<0)||(m<0)) return 0;\n\treturn (long long)fac[n+m]*nifac[m]%mo*nifac[n]%mo;\n}\nint main()\n{\n\tint n,k;scanf(\"%d%d\",&n,&k);\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=2*n;i++){fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tint ans=(work(n-1,k-1)-work(n,k-2)+mo)%mo;\n\tfor (int i=1;i<=n-k-1;i++) ans=ans*2%mo;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2000;\nconst int mod=1e9+7;\nint n,k,ans;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    f[n+1][0]=g[n+1][0]=1;\n    for (int i=n;i;i--)\n\tfor (int j=n-i+1;j;j--)\n\t    {\n\t\t{\n\t\t    f[i][j]=(f[i+1][j-1]+g[i+1][j])%mod;\n\t\t    g[i][j]=(g[i][j+1]+f[i][j])%mod;\n\t\t}\n\t\tf[i][0]=g[i+1][0];\n\t\tg[i][0]=(g[i][1]+f[i][0])%mod;\n\t    }\n    //printf(\"%d\\n\",f[2][0]);\n    ans=1ll*f[2][n-k]*power(2,max(n-k-1,0))%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2000;\nint n,k;\nint f[maxn+8][maxn+8],g[maxn+8][maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    if (k<0) return 1;\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;i<=n;i++) g[0][i]=1;\n    for (int i=1;i<k;i++)\n\t    for (int j=n-i;j;j--)\n\t        g[i][j]=(g[i-1][j]+g[i][j+1])%mod;\n    printf(\"%lld\\n\",1ll*g[k-1][1]*power(2,n-k-1)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#define re register\n#define maxn 2005\n#define eps 1e-6\n#define mod 1000000007\n#define INF 0x3f3f3f3f\n#define mem(a,b) memset(a,b,sizeof(a))\n#define cpy(a,b) memcpy(a,b,sizeof(b))\n#define ll long long\nusing namespace std;\nint n,k;\nll ans;\nint dp[maxn][maxn];\nint two[maxn],sum[maxn];\n\nvoid init(){\n    two[0]=1;\n    for(re int i=1;i<=2000;i++){\n        two[i]=(two[i-1]<<1)%mod;\n    }\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    init();\n    dp[0][n+1]=1;\n    for(re int i=1;i<=k;i++){\n        for(re int j=n+1;j;j--){\n            sum[j]=(sum[j+1]+dp[i-1][j])%mod;\n            if(j<=n-i+1){\n                dp[i][j]=sum[j];\n            }\n        }\n    }\n    ans=(dp[k][1]-dp[k-1][1])%mod;\n    ans=(ans+mod)%mod;\n    ans=(ans*two[n-k-1]%mod)%mod;\n    printf(\"%lld\\n\",ans%mod);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 2200\n#define mod 1000000007\nusing namespace std;\nint f[N][N],s[N],n,k,ans;\nint main(){\n\t//freopen(\"arc.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&k);f[0][n+1]=1;s[n+1]=1;\n\tfor (int i=n;i>=1;--i) s[i]=s[i+1]+f[0][i];\n\tfor (int i=1;i<=k-1;++i){\n\t\tfor (int j=1;j<=n-i+1;++j) f[i][j]=s[j];\n\t\ts[n+1]=f[i][n+1];for (int j=n;j>=1;--j) s[j]=(s[j+1]+f[i][j])%mod;\n\t}for (int i=2;i<=n+1;++i) (ans+=f[k-1][i])%=mod;\n\tfor (int i=1;i<=n-k-1;++i) (ans*=2)%=mod;printf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int Mod=1e9+7,N=2005;\nint f[N][N],n,k;\nint main (){\n\tscanf (\"%d%d\",&n,&k);\n    for (int i=2;i<=n;i++) f[1][i]=1;\n    for (int i=1;i<k-1;i++){\n        int sum=f[i][n-i+1];\n        for(int j=n-i;j>=2;j--){\n            sum=(sum+f[i][j])%Mod;\n            f[i+1][j]=(f[i+1][j]+sum)%Mod;\n        }\n    }\n    int ans=0;\n    for (int j=2;j<=n-k+2;j++) ans=(ans+f[k-1][j])%Mod;\n    for (int i=1;i<=n-1-k;i++) ans=ans*2%Mod;\n    printf (\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define rep(i,s,t) for(int i=s;i<=t;i++)\n#define dwn(i,s,t) for(int i=s;i>=t;i--)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=4010;\nconst int mod=1000000007;\nint n,k,fac[maxn],ifac[maxn];\nint C(int a,int b) {return (ll)fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tifac[1]=ifac[0]=fac[0]=1;\n\trep(i,2,n+k) ifac[i]=(ll)(mod-mod/i)*ifac[mod%i]%mod;\n\trep(i,1,n+k) fac[i]=(ll)fac[i-1]*i%mod,ifac[i]=(ll)ifac[i-1]*ifac[i]%mod;\n\tint ans=(C(n-1+k-1,k-1)-(k>=2?C(n+k-2,k-2):0)+mod)%mod;\n\trep(i,1,n-k-1) ans=(ans+ans)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fm, to)    for (int i = fm; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 2e3, mod = 1e9 + 7;\nint n, k, dp[2][nsz + 5], suf[2][nsz + 5];\nnum ans;\n\nint inline qpow(int a, int p) {\n\tint res = 1;\n\tfor (; p > 0; p >>= 1) {\n\t\t(p & 1) && (res = (num) res * a % mod);\n\t\ta = (num) a * a % mod;\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin >> n >> k;\n\tint o = 0, x = 1;\n\tfor (int j = n; j >= 1; --j) {\n\t\tdp[o][j] = 1;\n\t\tsuf[o][j] = (suf[o][j + 1] + dp[o][j]) % mod;\n\t}\n\tcirc (i, 2, k - 1) {\n\t\tfor (int j = n; j >= 1; --j) {\n\t\t\tdp[x][j] = suf[o][j + 1];\n\t\t\tif (j + i - 1 <= n) {\n\t\t\t\tdp[x][j] = (dp[x][j] + dp[o][j]) % mod;\n\t\t\t}\n\t\t\tsuf[x][j] = (suf[x][j + 1] + dp[x][j]) % mod;\n\t\t}\n\t\tswap(o, x);\n\t}\n\tcirc (j, 2, n + 1) {\n\t\tans = (ans + dp[o][j]) % mod;\n\t}\n\tans = ans * qpow(2, n - k - 1) % mod;\n\tcout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string& s, char c) { vector<string> v; stringstream ss(s); string x; while(getline(ss,x,c)) v.emplace_back(x); return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\n\nll dp[2123][2123];\nll sum[2123][2123];\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,t;\n  cin>>n>>t; --t;\n  if(n==1){\n    cout<<1<<endl;\n    return 0;\n  }\n  int o=max(2,n-t);\n  dp[o][1]=modpow(2,o-2);\n  fill(sum[o]+1,sum[o]+2023,dp[o][1]);\n  reps(i,o+1,n+1)rep(j,i){\n    dp[i][j]=sum[i-1][j];\n    (sum[i][j]+=dp[i][j])%=MOD;\n    (sum[i][j+1]+=sum[i][j])%=MOD;\n  }\n  //rep(i,n+1){rep(j,n+1)cout<<dp[i][j]<<\",\";cout<<endl;}cout<<endl;\n  // rep(i,n+1){rep(j,n+1)cout<<sum[i][j]<<\",\";cout<<endl;}\n  cout<<sum[n][n-1]<<endl;\n  return 0;\n}\n/*\n\n100 100\n676902861\n*/\n// int main(){\n//   ios_base::sync_with_stdio(false);\n//   cout<<fixed<<setprecision(0);\n//   int n,t;\n//   cin>>n>>t; --t;\n//   dp[n-t][1]=modpow(2,max(0,n-t-2));\n//   fill(sum[n-t]+1,sum[n-t]+2023,dp[n-t][1]);\n//   reps(i,n-t+1,n+1)rep(j,i){\n//     if(j+1==i){\n//       (dp[i][j]+=sum[j][j-1])%=MOD;\n//     }else{\n//       (dp[i][j]+=dp[i-1][j])%=MOD;\n//     }\n//     if(j>1) (dp[i][j]+=sum[i-1][j-1])%=MOD;\n//     (sum[i][j]+=dp[i][j])%=MOD;\n//     (sum[i][j+1]+=sum[i][j])%=MOD;\n//   }\n//   rep(i,n+1){rep(j,n+1)cout<<dp[i][j]<<\",\";cout<<endl;}cout<<endl;\n//   rep(i,n+1){rep(j,n+1)cout<<sum[i][j]<<\",\";cout<<endl;}\n//   cout<<sum[n][n-1]<<endl;\n//   return 0;\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 2010\nconst int p=1e9+7;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nint n,K,f[maxn];\nvoid Add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p)\n\t\tx-=p;\n}\nint mul(int x,int y)\n{\n\treturn 1ll*x*y%p;\n}\nint fpow(int x,int y)\n{\n\tif(y<0)return 1;\n\tint res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tres=mul(res,x);\n\t\tx=mul(x,x);\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tread(n,K);\n\tf[n+1]=1;\n\tfor(int i=1;i<=K;i++)\n\t{\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tif(n-j+1>=i)\n\t\t\t\tAdd(f[j],f[j+1]);\n\t\t\telse\n\t\t\t\tf[j]=0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",mul(f[1],fpow(2,n-K-1)));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333,mo=1e9+7;\nint n,k,fac[N],ifac[N],res,g[N];\ninline int power(int a, int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=1LL*res*a%mo;a=1LL*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\nvoid iniC(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);\n\tper(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\ninline int C(int n, int m){return m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;}\nvoid ini(int n){\n\trep(i,1,n)g[i]=C(2*n-i,n)-C(2*n-i,n+1);g[0]=g[1];\n//\trep(i,0,n)cerr<<i<<' '<<g[i]<<endl;\n}\nint main() {\n\tread(n);read(k);iniC(2*n);\n\tini(k-1);\n\tif(k==1)res=1;\n\telse if(k==n)res=g[0];\n\telse{rep(i,n-k,n-1)res=(res+1LL*C(i-1,n-k-1)*g[i-(n-k)])%mo;}\n\trep(i,1,n-k-1)res=2LL*res%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <set>\nconst int maxlongint=2147483647;\nconst long long mo=1e9+7;\t\nconst int N=2005;\nusing namespace std;\nint n,k;\nlong long ans,mi[N],f[N][N];\nint main()\n{\n\t//freopen(\"068d.in\",\"r\",stdin);\n\t//freopen(\"068d.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&k);\n\tmi[0]=1;\n\tfor(int i=1;i<=n;i++) mi[i]=mi[i-1]*2%mo;\n\tfor(int i=n;i>=2;i--) f[1][i]=1;\n\tfor(int i=1;i<k-1;i++)\n\t{\n\t\tlong long sum=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--)\n\t\t{\n\t\t\tsum=(sum+f[i][j])%mo;\n\t\t\tf[i+1][j]=(f[i+1][j]+sum)%mo;\n\t\t}\n\t}\n\tfor(int j=2;j<=n-k+2;j++) ans=(ans+f[k-1][j])%mo;\n\tprintf(\"%lld\",ans*mi[n-1-k]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 2100;\nconst ll MOD = 1e9 + 7;\n\nint N, K;\nll dp[MAXN][MAXN]; // my loc / loc + # of people left above me\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N >> K;\n    dp[N][N] = 1;\n    for (int i = N; i >= 1; i--)\n    {\n        ll ctot = 0;\n        for (int j = i; j >= 0; j--)\n        {\n            ctot += dp[j][i];\n            dp[j][i-1] = ctot % MOD;\n        }\n    }\n\n    int cloc = N - K + 1;\n    ll ans = (dp[0][cloc-1] - dp[0][cloc] + MOD) % MOD;\n    for (int i = 0; i < cloc - 2; i++)\n        ans = (ans * 2) % MOD;\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ntypedef long long s64;\n\nconst int MaxN = 2000;\nconst int M = 1000000007;\n\nint n, nK;\nint f[MaxN + 2][MaxN + 2][2];\n\nint main()\n{\n\tcin >> n >> nK;\n\n\tf[n + 1][0][1] = 1;\n\tfor (int i = n; i; --i)\n\t{\n\t\tint l = i + 1;\n\t\tfor (int j = n; j >= 0; --j)\n\t\t\tf[l][j][0] = (f[l][j][0] + f[l][j + 1][0]) % M;\n\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tfor (int k = 0; k < 2; ++k)\n\t\t\t{\n\t\t\t\tint cur = f[l][j][k];\n\t\t\t\tf[i][j + 1][1] = (f[i][j + 1][1] + cur) % M;\n\t\t\t\tf[i][j + 0][0] = (f[i][j + 0][0] + cur) % M;\n\t\t\t}\n\t}\n\n\tint res = f[1][n - nK][0];\n\tfor (int i = 0; i < n - nK - 1; ++i)\n\t\tres = (s64)res * 2 % M;\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int mod = 1e9+7;\nLL dp[2005][2005];\nint main(){\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    dp[n+1][0] = 1;\n    for(int i=n;i>=2;i--){\n        for(int j=n;j>=0;j--){\n            dp[i][j] = (dp[i][j] + dp[i+1][j])%mod;\n            dp[i][j] = (dp[i][j] + dp[i][j+1])%mod;\n            dp[i][j+1] = (dp[i][j+1] + dp[i+1][j])%mod;\n        }\n    }\n    int ans = dp[2][n-k];\n    for(int i=1;i<=n-k-1;i++) ans = ans*2%mod;\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string& s, char c) { vector<string> v; stringstream ss(s); string x; while(getline(ss,x,c)) v.emplace_back(x); return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\n\nll dp[2123][2123];\nll sum[2123][2123];\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,t;\n  cin>>n>>t; --t;\n  dp[n-t][1]=modpow(2,max(0,n-t-2));\n  fill(sum[n-t]+1,sum[n-t]+2023,dp[n-t][1]);\n  reps(i,n-t+1,n+1)rep(j,i){\n    dp[i][j]=sum[i-1][j];\n    (sum[i][j]+=dp[i][j])%=MOD;\n    (sum[i][j+1]+=sum[i][j])%=MOD;\n  }\n  // rep(i,n+1){rep(j,n+1)cout<<dp[i][j]<<\",\";cout<<endl;}cout<<endl;\n  // rep(i,n+1){rep(j,n+1)cout<<sum[i][j]<<\",\";cout<<endl;}\n  cout<<sum[n][n-1]<<endl;\n  return 0;\n}\n// int main(){\n//   ios_base::sync_with_stdio(false);\n//   cout<<fixed<<setprecision(0);\n//   int n,t;\n//   cin>>n>>t; --t;\n//   dp[n-t][1]=modpow(2,max(0,n-t-2));\n//   fill(sum[n-t]+1,sum[n-t]+2023,dp[n-t][1]);\n//   reps(i,n-t+1,n+1)rep(j,i){\n//     if(j+1==i){\n//       (dp[i][j]+=sum[j][j-1])%=MOD;\n//     }else{\n//       (dp[i][j]+=dp[i-1][j])%=MOD;\n//     }\n//     if(j>1) (dp[i][j]+=sum[i-1][j-1])%=MOD;\n//     (sum[i][j]+=dp[i][j])%=MOD;\n//     (sum[i][j+1]+=sum[i][j])%=MOD;\n//   }\n//   rep(i,n+1){rep(j,n+1)cout<<dp[i][j]<<\",\";cout<<endl;}cout<<endl;\n//   rep(i,n+1){rep(j,n+1)cout<<sum[i][j]<<\",\";cout<<endl;}\n//   cout<<sum[n][n-1]<<endl;\n//   return 0;\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=2000+10,mo=1000000007;\nint f[maxn][maxn][3],two[maxn];\nint i,j,k,l,t,n,m,ans;\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\ttwo[0]=1;\n\tfo(i,1,n) two[i]=(ll)two[i-1]*2%mo;\n\tf[n+1][0][2]=1;\n\tfd(i,n+1,2){\n\t\tfd(j,n,0) (f[i][j][1]+=f[i][j+1][1])%=mo;\n\t\tfo(j,0,n)\n\t\t\tfo(t,1,2){\n\t\t\t\t(f[i-1][j+1][2]+=f[i][j][t])%=mo;\n\t\t\t\t(f[i-1][j][1]+=f[i][j][t])%=mo;\n\t\t\t}\n\t}\n\tans=f[1][n-k][1];\n\tans=(ll)ans*two[max(n-k-1,0)]%mo;\n\t(ans+=mo)%=mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#define sqr(x) (x)*(x)\nusing namespace std;\nlong long n,m,i,j,sum[2005],dp[2005][2005],mod=1e9+7,ans;\nlong long qp(long long x,long long y)\n{\n\tif (y==0) return 1;\n\tif (y==1) return x;\n\tlong long z=qp(x,y/2);\n\tz=z*z%mod;\n\tif (y&1) z=z*x%mod;\n\treturn z;\n}\nint main()\n{\n\tcin>>n>>m;\n\tif (n==1)\n\t{\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n\tif (m==1)\n\t{\n\t\tcout<<qp(2,n-2);\n\t\treturn 0;\n\t}\n\tdp[0][n+1]=1;\n\tfor (i=1;i<m;i++)\n\t{\n\t\tsum[n+1]=dp[i-1][n+1];\n\t\tfor (j=n+1;j>=1;j--)\n\t\t{\n\t\t\tsum[j]=sum[j+1]+dp[i-1][j];\n\t\t\tsum[j]%=mod;\n\t\t}\n\t\tfor (j=1;j<=n;j++)\n\t\t{\n\t\t\tif (i+j-1<=n) dp[i][j]=sum[j];\n\t\t}\n\t}\n\tfor (i=2;i<=n;i++)\n\t{\n\t\tans=(ans+dp[m-1][i])%mod;\n\t}\n\tif (n==m)\n\t{\n\t\tcout<<ans;\n\t\treturn 0;\n\t}\n\tcout<<ans*qp(2,n-m-1)%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\n\nconst int N_MAX = 2005;\n\nint N, K;\nmod_int dp[N_MAX][N_MAX];\n\nint main() {\n    cin >> N >> K;\n    dp[0][N] = 1;\n\n    for (int len = 0; len < K; len++)\n        for (int minimum = 1; minimum + len <= N; minimum++) {\n            int between = (N - minimum) - len;\n\n            for (int under = 0; under < minimum; under++)\n                dp[len + 1][under] += dp[len][minimum];\n\n            if (between > 0)\n                dp[len + 1][minimum] += dp[len][minimum];\n        }\n\n    mod_int answer = dp[K][0] * mod_int(2).pow(N - K - 1);\n    cout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nconst int N=2020,P=1000000007;\nint i,j,k,n,m,ans;\nint tm2[N],f[N][N],Jc_[N],Jc[N];\nint ksm(int x,int y) {\n\tint z=1;\n\tfor (;y;y>>=1,x=(ll) x*x%P) if (y&1) z=(ll) z*x%P;\n\treturn z;\n}\nvoid pre(int n) {\n\tint i;\n\ttm2[0]=1;\n\tfor (i=1;i<=n;i++) tm2[i]=(tm2[i-1]*2)%P;\n\tJc[0]=Jc_[0]=1;\n\tfor (i=1;i<=n;i++) Jc[i]=(ll) Jc[i-1]*i%P;\n\tJc_[n]=ksm(Jc[n],P-2);\n\tfor (i=n-1;i;i--) Jc_[i]=(ll) Jc_[i+1]*(i+1)%P;\n}\nint C(int n,int m) {\n\tif (m>n) return 0;\n\treturn (ll) Jc[n]*Jc_[m]%P*Jc_[n-m]%P;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tpre(n);\n\tif (n<=2) return puts(\"1\"),0;\n\tif (m==1) return printf(\"%d\\n\",tm2[n-2]),0;\n\tf[1][0]=1;\n\tfor (i=1;i+1<m;i++) {\n\t\tf[i+1][0]=(f[i+1][0]+f[i][0])%P;\n\t\tf[i+1][1]=(f[i+1][1]+P-f[i][0])%P;\n\t\tf[i+1][2]=(f[i+1][2]+f[i][0])%P;\n\t\tf[i+1][i+2]=(f[i+1][i+2]+P-f[i][0])%P;\n\t\tfor (j=1;j<=i;j++) {\n\t\t\tf[i+1][2]=(f[i+1][2]+f[i][j])%P;\n\t\t\tf[i+1][j+2]=(f[i+1][j+2]+P-f[i][j])%P;\n\t\t}\n\t\tfor (j=1;j<=i+1;j++) f[i+1][j]=(f[i+1][j]+f[i+1][j-1])%P;\n\t}\n\tans=((ll) f[m-1][0]*C(n-1,m-1)+ans)%P;\n\tfor (i=2;i<m;i++) ans=((ll) f[m-1][i]*C(n-m+i-1,n-m)+ans)%P;\n\tif (m<n) ans=((ll) ans*tm2[n-m-1])%P;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll dp[2020][2020][2];\nll mo=1000000007;\nint N,K;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\tdp[N][0][0]=1;\n\tfor(i=N;i>=1;i--) {\n\t\tfor(j=N;j>=0;j--) {\n\t\t\t(dp[i-1][j][0]+=dp[i][j][0]+dp[i][j][1])%=mo;\n\t\t\t(dp[i-1][j+1][1]+=dp[i][j][0]+dp[i][j][1])%=mo;\n\t\t\tif(j) (dp[i][j-1][0]+=dp[i][j][0])%=mo;\n\t\t}\n\t}\n\tll ret=(dp[1][N-K][0]+dp[1][N-K][1])%mo;\n\tFOR(i,N-K-1) (ret*=2)%=mo;\n\tcout<<ret<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\nconst int N=2005,MOD=1e9+7;\nint n,m;\nint f[N];\nvoid readData(){\n    scanf(\"%d%d\",&n,&m);\n}\nvoid dp(){\n    f[n+1]=1;\n    int sum,last;\n    for(int i=1;i<m;i++){\n        sum=f[n-i+2];\n        for(int j=n-i+1;j>=2;j--){\n            (sum+=f[j])%=MOD;\n                f[j]=sum;\n        }\n    }\n    int ans=0;\n    for(int j=2;j<=n-(m-1)+1;j++) (ans+=f[j])%=MOD;\n    if(m==1) ans=1;\n    for(int i=1;i<=n-m-1;i++) (ans<<=1)%=MOD;\n    printf(\"%d\\n\",ans);\n}\nint main(){\n    readData();\n    dp();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define ll long long\nconst ll mod = 1e9+7; \nusing namespace std;\nint read(){\n\tint x=0,pos=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;\n\tfor(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn pos?x:-x;\n}\nconst int N = 2001;\nint n,k;\nll f[N][N];\nint main(){\n\tn=read(),k=read();\n\tfor(int i=2;i<=n;i++){\n\t\tf[1][i]=1;\n\t}\n\tfor(int i=1;i<k-1;i++){\n\t\tll sum=f[i][n-i+1];\n\t\tfor(int j=n-i;j>=2;j--){\n\t\t\tsum=(sum+f[i][j])%mod;\n\t\t\tf[i+1][j]=sum;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=2;i<=n-k+2;i++){\n\t\tans+=f[k-1][i];\n\t}\n\tif(k==1){\n\t\tans=1;\n\t}else if(k!=n){\n\t\tans=ans*((1<<(n-k-1))%mod)%mod;\n\t} \n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// :(\n\n#ifndef LOCAL\n#define NDEBUG 1\n#endif\n#include<bits/stdc++.h>\n\n#define MODULAR_LESS_EFFICIENT_BUT_EASIER_TO_CODE 1\nint const MOD=1000000007;\nstruct modular {\n\tint val;\n\texplicit constexpr operator int() const { return val; }\n\tconstexpr modular():val(){}\n#if MODULAR_LESS_EFFICIENT_BUT_EASIER_TO_CODE\n\tconstexpr modular(auto v):val(int(v%MOD)){ if(val<0)val+=MOD; }\n#else\n\tconstexpr modular(int v):val(v){\n\t\tassert(0<=v and v<MOD);\n\t}\n#endif\n\n#define COMPAREOP(OP) bool constexpr operator OP(modular b) const { return val OP b.val; }\n\tCOMPAREOP(==) COMPAREOP(!=) COMPAREOP(<) COMPAREOP(>) COMPAREOP(<=) COMPAREOP(>=)\n#undef COMPAREOP\n\n\tfriend modular constexpr operator-(modular x) { x.val=x.val?MOD-x.val:0; return x; }\n\tmodular constexpr& operator+=(modular m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular constexpr& operator-=(modular m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular constexpr& operator*=(modular m) {\n\t\tif(__builtin_constant_p(m.val)){\n\t\t\tswitch(m.val){\n\t\t\t\tcase 1: return *this;\n\t\t\t\tcase 2: return *this+=*this;\n\t\t\t\tcase 3: return *this+=*this+*this;\n\t\t\t\tcase 0: return *this=0;\n\t\t\t\tcase -1: return *this=-*this;\n\t\t\t}\n\t\t}else if(__builtin_constant_p(val)){\n\t\t\t*this=m**this;\n\t\t}\n\t\tval = int((int64_t)val*m.val%MOD);\n\t\treturn *this;\n\t}\n\tmodular constexpr pow(int p) const {\n\t\tmodular a=*this;\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tmodular constexpr inv() const {\n\t\tint a=val,b=MOD, ax=1,bx=0;\n\t\twhile(b){\n\t\t\tint q=a/b, t=a%b;\n\t\t\ta=b; b=t;\n\t\t\tt=ax-bx*q; ax=bx; bx=t;\n\t\t}\n\t\tassert(a==1);\n\t\tif(ax<0)ax+=MOD;\n\t\treturn ax;\n\t}\n\tmodular constexpr& operator/=(modular m) { return (*this) *= m.inv(); }\n\n#define ARITHBINARYOP(OP) friend modular constexpr operator OP(modular a, modular b) { return a OP##= b; }\n\tARITHBINARYOP(+) ARITHBINARYOP(-) ARITHBINARYOP(*) ARITHBINARYOP(/)\n#undef ARITHBINARYOP\n};\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint n, k; std::cin>>n>>k;\n\tstd::vector<modular> temp(n==k ? 2 : n-k+1);\n\ttemp[1]=1;\n\twhile((int)temp.size()<n){\n\t\ttemp.push_back(0);\n\t\tstd::partial_sum(begin(temp), end(temp), begin(temp));\n\t}\n\tstd::cout<<int(\n\t\t\tstd::accumulate(begin(temp),end(temp), modular(0))*modular(2).pow(std::max(0, n-k-1))\n\t\t\t)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\nint M(int x) { return x >= mod ? x - mod : x; }\nint n, k, res;\nint fsp(long long bs, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = bs * rt % mod;\n        bs = bs * bs % mod, p >>= 1;\n    }\n    return rt;\n}\n\nint f[2003];\nint main() {\n    scanf(\"%d%d\", &n, &k);\n    if (k == 1) return printf(\"%d\\n\", fsp(2, n - k - 1)), 0;\n    for (int i = 1; i < n; ++i) f[i] = 1;\n    for (int i = 2; i < k; ++i)\n        for (int j = i; j < n; ++j) f[j] = M(f[j - 1] + f[j]);\n\n    for (int j = k - 1; j < n; ++j) res = M(res + f[j]);\n    printf(\"%d\\n\", 1ll * res * fsp(2, n - k - 1) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define D(i,a,b) for(int i=a;i>=b;--i)\nconst int M = 1e9+7;\nint f[2005],n,k;\nint main(){\n\tstd::cin>>n>>k;f[n+1]=1;\n\tD(i,n,n-k+1){D(j,n,i+1)f[j]=0;D(j,i,1)f[j]=(f[j]+f[j+1])%M;}\n\tD(i,n-k-1,1)f[1]=f[1]*2%M;\n\tstd::cout<<f[1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 2005;\nconst int mod = 1e9+7;\n\nint dp[maxn][maxn],s[maxn][maxn],n,K; \nLL fpm(LL p,LL k) {\n\tLL res=1ll;\n\twhile (k) {\n\t\tif (k&1) (res*=p)%=mod;\n\t\t(p*=p)%=mod;k>>=1;\n\t}\n\treturn res;\n}\nvoid inc(int &x,int y) {\n\tx+=y;x>=mod?x-=mod:0;\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc068f.in\",\"r\",stdin);\n\t\tfreopen(\"arc068f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d\",&n,&K);\n\tif (n==1) {printf(\"1\");return 0;}\n\tdp[0][0]=s[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=n;j>=0;j--)\n\t{\n\t\tif (i!=n) dp[i][j]=dp[i][j+1];\n\t\t//for (int k=max(0,i-j-1);k<i;k++)\n\t\t//\tinc(dp[i][j],dp[k][j-i+k+1]);\n\t\tinc(dp[i][j],s[i-1][j]);\n\t\ts[i][j]=(s[i-1][j-1]+dp[i][j])%mod;\n\t}\n\tint res=(LL)dp[n][n-K]*fpm(2,n-K-1)%mod;\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = 1e9 + 7;\n\nll p2[2001];\nll c[2001][2001];\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nll add(ll a, ll b)\n{\n\treturn (a+b)%MOD;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, k; cin>>n>>k;\n\tfor(int i = 1; i <= 2000; i++) c[i][0] = 1;\n\tfor(int i = 1; i <= 2000; i++)\n\t{\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tif(j==0||j==i)\n\t\t\t{\n\t\t\t\tc[i][j]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc[i][j] = (c[i-1][j]+c[i-1][j-1])%MOD;\n\t\t\t}\n\t\t\t//if(i<=10&&j<=10) cerr<<i<<' '<<j<<' '<<c[i][j]<<'\\n';\n\t\t}\n\t}\n\tp2[0]=1;\n\tfor(int i = 1; i <= 2000; i++) p2[i]=(p2[i-1]*2)%MOD;\n\tll ans = 1;\n\tif(k<n) ans=p2[n-k-1];\n\tif(k==1)\n\t{\n\t\tcout<<ans<<'\\n';\n\t\treturn 0;\n\t}\n\t\n\tll res = 0;\n\tll ans2=0;\n\tfor(int j = n - k; j <= n - 1; j++)\n\t{\n\t\tll coeff = (c[j][n-k]*c[n-1-j][k-1]);\n\t\tfor(int i = 1; i <= k - 1; i++)\n\t\t{\n\t\t\tif(i<k-1) res = (res+c[k-1][i]+MOD-1)%MOD;\n\t\t\telse res=(res+1)%MOD;\n\t\t}\n\t\tres=(res*coeff)%MOD;\n\t//res=(res+MOD-1)%MOD;\n\t\tans2=(ans2+res)%MOD;\n\t}\n\tans=(ans*ans2)%MOD;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\ninline void add(int &a,int b){if((a+=b)>=mod)a-=mod;}\nint n,k,dp[3001][3001];\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i=2;i<=n;i++)dp[1][i]=1;\n\tfor(int i=2;i<k;i++)\n\t\tfor(int j=n-i+1;j>1;j--)add(dp[i-1][j],dp[i-1][j+1]),dp[i][j]=dp[i-1][j];\n\tint ans=0;\n\tfor(int i=2;i<n-k+3;i++)add(ans,dp[k-1][i]);\n\tif(!ans)ans=1;\n\tfor(int i=1;i<n-k;i++)add(ans,ans);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 2005\n#define mod 1000000007\nint dp[N][N],su[N][N],n,k;\nint pw(int a,int p){if(p<0)return 1;int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tdp[n-1][0]=1;\n\tfor(int i=n-1;i>0;i--)\n\tfor(int j=0;j<n;j++)\n\t{\n\t\tdp[i][j]=(dp[i][j]+su[i+1][j-1])%mod;\n\t\tif(n<=i+j&&j)dp[i-1][j]=(dp[i-1][j]+dp[i][j])%mod;\n\t\tsu[i][j]=(su[i][j-1]+dp[i][j])%mod;\n\t}\n\tint as=0;\n\tfor(int i=0;i<=n;i++)\n\tas=(as+1ll*dp[n-k][i]*pw(2,n-k-1))%mod;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RANK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2005;\nconst int mod = 1e9+7;\nint f[maxn],n,k;\nint main(){\n\tn = rd(),k = rd();\n\tmem(f,0);\n\tf[0] = 1;\n\tRep(i,1,k){\n\t\tRep(j,1,i-1) f[j]=0;\n\t\tRep(j,i,n) f[j] = (f[j] + f[j-1]) % mod;\n\t}\n\tll ans = f[n];\n\tRep(i,1,n-k-1)ans=ans*2%mod;\n\twriteln(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 2005, MOD = 1000000007;\ntypedef long long i64;\n\nint N, K;\ni64 fac[MAX_N], ifac[MAX_N], inv[MAX_N], bin[MAX_N];\ni64 f[MAX_N][MAX_N], sum[MAX_N];\n\ni64 binom(int n, int m) {\n  if (n < m) return 0;\n  return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &K);\n  fac[0] = ifac[0] = inv[1] = bin[0] = 1;\n  for (int i = 1; i <= N; ++i) fac[i] = fac[i - 1] * i % MOD;\n  for (int i = 2; i <= N; ++i) inv[i] = -(MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i <= N; ++i) ifac[i] = ifac[i - 1] * inv[i] % MOD;\n  for (int i = 1; i <= N; ++i) bin[i] = (bin[i - 1] + bin[i - 1]) % MOD;\n  \n  f[0][0] = 1;\n\n  for (int i = 0; i <= N; ++i) {\n    for (int j = 0; i + j <= N; ++j) {\n      if (j > 0) f[i][j] = f[i][j - 1];\n      if (i > 0) f[i][j] = (f[i][j] + sum[i + j]) % MOD;\n    }\n    for (int j = 0; i + j < N; ++j) {\n      //s - i - 1 = j\n      sum[i + j + 1] = (sum[i + j + 1] + f[i][j]) % MOD;\n    }\n  }\n\n  i64 res = 0;\n  for (int i = 2; i <= N; ++i) {\n    if (K - 1 - N + i < 0) continue;\n    res = (res + binom(i - 2, N - K - 1) * bin[N - K - 1] % MOD * f[N - i][K - 1 - N + i] % MOD) % MOD;\n  }\n  if (K == N) res = f[N - 1][0];\n  printf(\"%lld\\n\", (res + MOD) % MOD);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long p=1000000007ll;\nlong long n,k,dp[10001];\nlong long quickpow(long long a,long long b,long long n)\n{\n\tif(b==0&&n>1) return 1;\n\tif(b==0&&n==1) return 0;\n\tif(b==1) return a%n;\n\tif(b%2==0)\n\t{\n\t\tlong long t=quickpow(a,b/2,n);\n\t\treturn t*t%n;\n\t}\n\telse\n\t{\n\t\tlong long t=quickpow(a,b/2,n);\n\t\tt=t*t%n;\n\t\treturn t*a%n;\n\t}\n}\n\nint main(){\n    cin>>n>>k;\n    dp[0]=1;\n    for(int i=1;i<n;i++)\n\t{\n\t\tfor(int j=i;j>0;j--)\n\t\t\tdp[j]=(dp[j+1]+dp[j-1])%p;\n\t\tdp[0]=dp[1];\n\t}\n\tcout<<(long long)(dp[n-k]*quickpow(2,n-k-1,p)%p)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, K, C;\nll pow2[2010];\nll dp[2010][2010];\n\nvoid solve() {\n\tcin >> N >> K;\n\tpow2[0] = 1;\n\tC = N - K;\n\trep(i, 0, N) {\n\t\tpow2[i + 1] = pow2[i] * 2 % mod;\n\t}\n\trep(i, 0, C + 1) {\n\t\tdp[i][0] = pow2[max(C - 1, 0)];\n\t}\n\trep(k, 1, K) {\n\t\tll tmp = 0;\n\t\trep(i, 1, C + k) {\n\t\t\tADD(tmp, dp[i][k - 1]);\n\t\t\tdp[i][k] = tmp;\n\t\t}\n\t\tdp[C + k][k] = (tmp + dp[C + k - 1][k - 1]) % mod;\n\t}\n\t// rep(j, 0, K + 1) {\n\t// \trep(i, 0, N + 1) {\n\t// \t\tdebug(i, j, dp[i][j]);\n\t// \t}\n\t// }\n\tcout << dp[N - 1][K - 1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1000*1000*1000+7;\nint N, K;\n\nvector<vector<ll> > dp[2];\nvector<ll> po;\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n\n    dp[0] = dp[1] = vector<vector<ll> >(K + 1, vector<ll>(N + 1, 0));\n    po.resize(2002);\n    po[0] = 1;\n    for(int i = 1; i < 2002; i++) {\n        po[i] = po[i - 1] * 2 % mod;\n    }\n\n    for(int i = 1; i <= K; i++) {\n        for(int j = 1; j <= N; j++) {\n            int rem = (N - j) - (K - i);\n            if(rem < 0) continue;\n\n            if(i == 1) {\n                dp[0][i][j] = rem + j - 2 < 0? 1 : po[rem + j - 2];\n                dp[1][i][j] = dp[0][i][j];\n                if(j) {\n                    dp[1][i][j] += dp[1][i][j - 1];\n                    dp[1][i][j] %= mod;\n                }\n                continue;\n            }\n\n            dp[0][i][j] = dp[1][i - 1][j - 1];\n            if(rem) dp[0][i][j] += dp[0][i - 1][j];\n\n            dp[1][i][j] = dp[0][i][j];\n            if(j) {\n                dp[1][i][j] += dp[1][i][j - 1];\n                dp[1][i][j] %= mod;\n            }\n        }\n    }\n\n    printf(\"%lld\", dp[0][K][N]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 0x7fffffff\n#define eps 1e-10\n#define MOD 1000000007 \nusing namespace std;\nconst int maxn=2010;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n\treturn f*x;\n}\n\nint n,k;\nll f[maxn][maxn],s[maxn][maxn],pw[maxn];\nint main(){\n\tpw[0]=pw[1]=1;\n\tfor (int i=2;i<maxn;++i)pw[i]=(pw[i-1]<<1)%MOD;\n\tn=read();k=read();\n\tf[1][n-k]=pw[n-k];\n\tfor (int i=1;i<=n+1;++i)s[1][i]=(s[1][i-1]+f[1][i])%MOD;\n\tfor (int i=2;i<=n;++i){\n\t\tfor (int j=0;j<=n;++j)f[i][j]=s[i-1][j+1]; \n\t\ts[i][0]=f[i][0];\n\t\tfor (int j=1;j<=n+1;++j)s[i][j]=(s[i][j-1]+f[i][j])%MOD;\n\t}\n\tif (n==k)f[n][0]=pw[n-1];\n\tprintf(\"%lld\\n\",f[n][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2020;\nconst int mod = 1e9 + 7;\n\nLL f[N][N][2], s[N];\n\nLL qpow(LL a, LL b)\n{\n\tLL ret = 1, base = a;\n\twhile (b) {\n\t\tif (b & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, b >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tf[n + 1][0][0] = 1;\n\tfor (int i = n + 1; i >= 2; i --) {\n\t\tfor (int j = n - i + 1; j >= 0; j --) s[j] = s[j + 1], upd(s[j], f[i][j][0]);\n\t\t\n\t\tfor (int j = n - i + 1; j >= 0; j --) {\n\n\t\t\tupd(f[i - 1][j + 1][1], s[j] + f[i][j][1]);\n\t\t\tupd(f[i - 1][j][0], s[j] + f[i][j][1]);\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", f[1][n - k][0] * qpow(2, n - k - 1) % mod);\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3000 +10;\nconst long long mod = (long long)1000000007;\nint read(){\n\tint x=0,flag=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*flag;\n}\nint n,k;\nlong long f[maxn][maxn],g[maxn][maxn];\nlong long Pow(long long x,int t){\n\tlong long ans = 1LL;\n\twhile(t){\n\t\tif(t&1)ans=ans*x%mod;\n\t\tx=x*x%mod;t>>=1;\n\t}\n\treturn ans%mod;\n}\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin),freopen(\"test.out\",\"w\",stdout);\n#endif\n\tn=read();k=read();\t\n\tf[1][n-k]=Pow(2LL,n-k-1);\n\n\tg[1][0]=0;for(int j=1;j<=n;j++)g[1][j] = ( g[1][j-1] + f[1][j] ) % mod;\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif( n-i >= j )\n\t\t\t\tf[i][j] = ( ((j+1 <= n-(i-1) )?f[i-1][j+1]%mod:0LL) + (( j <= n-(i-1) )?g[i-1][j]%mod:0LL) ) %mod;\n\t\t\tg[i][j] = ( ((j-1>=0)?g[i][j-1]%mod:0) + f[i][j]%mod ) %mod;\n\t\t}\n\tcout << f[n][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=1e9+7,N=2005;\nint n,k,dp[N][N];\ninline int ksm(int x,int y)\n{\n\tint gg=1ll;\n\twhile(y)\n\t{\n\t\tif(y&1)(gg*=x)%=mod;\n\t\t(x*=x)%=mod;  y>>=1ll;\n\t}\n\treturn gg;\n}\nsigned main(signed argc, char const *argv[])\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>k;\n\tdp[0][n+1]=1ll;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tint sum=dp[i-1][n+1];\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\t(sum+=dp[i-1][j])%=mod;\n\t\t\tif(j<=n-i+1)dp[i][j]=sum;\n\t\t}\n\t}\n\tint res=(dp[k][1]-dp[k-1][1]+mod)%mod;\n\tcout<<res*ksm(2,n-k-1)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n    #define N 2010\n    #define ll long long\n    #define For(i,x,y) for(int i=(x);i<=(y);++i)\n    #define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n    #define Edge(x) for(int i=head[x];i;i=e[i].nxt)\n    #define mset(x,y) memset(x,y,sizeof(x))\n    #define strL strlen\n    #define p_b push_back\n    #define mcpy(x,y) memcpy(x,y,sizeof(x))\n    #define lson l,mid,(o<<1)\n    #define rson mid+1,r,((o<<1)|1)\n    #define Ls (t[o].ls)\n    #define Rs (t[o].rs)\n    #define mod 1000000007\n    #define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\n    using namespace std;\n    int _2[N],f[N][N],sub[N][N];\n    void init(int n){_2[0]=1;For(i,1,n) _2[i]=(_2[i-1]+_2[i-1])%mod;}\n    int main(){\n    \tint n,k,ans=0;\n    \tscanf(\"%d%d\",&n,&k);\n    \tinit(n);\n    \tFor(i,2,n+1) sub[0][i]=1;\n    \tFor(i,1,k-1) Rof(j,n-i+1,2){\n    \t\tif(j<=n-i+1) (f[i][j]+=sub[i-1][j])%=mod;\n    \t\tsub[i][j]=(sub[i][j+1]+f[i][j])%mod;\n    \t}\n    \tFor(i,2,n-k+2) (ans+=1ll*f[k-1][i])%=mod;\n    \tif(k==1) ans=1;\n    \tif(k!=n) ans=1ll*ans*_2[n-k-1]%mod;\n    \tprintf(\"%d\\n\",ans); \n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2000 + 10;\nconst ll mod = 1e9 + 7;\nll fac[maxn], inv[maxn], facinv[maxn], bin[maxn];\nll f[maxn][maxn];\nvoid pre()\n{\n\tfac[0] = 1; for(int i = 1; i < maxn; ++i) fac[i] = fac[i - 1] * i % mod;\n\tinv[1] = 1; for(int i = 2; i < maxn; ++i) inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\tfacinv[0] = 1; for(int i = 1; i < maxn; ++i) facinv[i] = facinv[i - 1] * inv[i] % mod;\n\tbin[0] = 1; for(int i = 1; i < maxn; ++i) bin[i] = bin[i - 1] * 2 % mod;\n}\nll C(int n, int m) { return n < m ? 0 : fac[n] * facinv[m] % mod * facinv[n - m] % mod;}\nint main()\n{\n\tpre();\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tfor(int j = 1; j <= n; ++j) f[1][j] = 1;\n\tfor(int i = 2; i < k; ++i)\n\t{\n\t\tll sum = 0;\n\t\tfor(int j = n; j; --j)\n\t\t{\n\t\t\tif(n - j + 1 > i - 1) f[i][j] = f[i - 1][j];\n\t\t\tf[i][j] = (f[i][j] + sum) % mod;\n\t\t\tsum = (sum + f[i - 1][j]) % mod;\n\t\t}\n\t}\n\tll ans = 0;\n\tif(k > 1)\n\t\tfor(int j = 2; j <= n; ++j) ans = (ans + f[k - 1][j]) % mod;\n\telse ans = 1;\n\tcout << ans * bin[n - k - 1] % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#define ll long long\n#define MOD 1000000007\nusing namespace std;\ninline ll read(){\n\tll re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nll dp[2010][2010],p[2010],sum[2010][2010];\nint main(){\n\tll n=read(),k=read();ll i,j;\n\tp[0]=1;\n\tfor(i=1;i<=n;i++) p[i]=p[i-1]*2%MOD;\n\tfor(i=2;i<=n;i++) dp[1][i]=1,sum[1][i]=n-i+1; \n\tfor(i=2;i<k;i++){\n\t\tfor(j=n-i+1;j>=2;j--){\n\t\t\tdp[i][j]=(dp[i-1][j]+sum[i-1][j+1])%MOD;\n\t\t}\n\t\tfor(j=n-i+1;j>=2;j--) sum[i][j]=(sum[i][j+1]+dp[i][j])%MOD;\n\t}\n\tll ans=0;\n\tfor(i=2;i<=n-k+2;i++) ans+=dp[k-1][i],ans%=MOD;\n\tif(k==1) ans=1;\n\tif(k==n) printf(\"%lld\\n\",ans);\n\telse printf(\"%lld\\n\",ans*p[n-k-1]%MOD);\n//\tcout<<n<<' '<<k<<' '<<ans<<' '<<n-k-1<<' '<<p[n-k-1]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[2][2351][2201];\nlong long l[2221];\nint j[1];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[3];\n\nP u[1];\nqueue<P> q;\nstack<int> s;\n//set<int> s;\nmap<int,int> p;\n\nvector<int> v[3];\n\n\nbool as(P a,P b)\n{\n  if(a.x!=b.x)\n  return a.x<b.x;\n  return a.y>b.y;\n  \n}\n\nlong long f(int i,int n,int m)\n{\n  if(a-n-m+1==b)\n  {\n    if(n==0) return 0;\n    return l[a-b-1];\n  }\n  if(n==0) return 0;\n  //printf(\"%d %d %d\\n\",i,n,m);\n  if(o[i][n][m]>=0) return o[i][n][m];\n  long long x=f(0,n-1,m+1);\n  x+=f(1,n-1,m);\n  x%=mod;\n  if(i&&m) x=(x+f(1,n,m-1))%mod;\n  return o[i][n][m]=x;\n  \n}\n\nint main()\n{\n  l[0]=1;\n  for(int t=1;t<=2010;t++)\n  l[t]=l[t-1]*2%mod;\n  memset(o,-1,sizeof(o));\n  scanf(\"%d %d\",&a,&b);\n  printf(\"%lld\",f(0,a,0));\n}\n//0\n//16\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 2e3 + 5;\n\nll dp[MAXN];\nll c[MAXN][MAXN];\nll dp_v[MAXN][MAXN];\nll st2[MAXN];\n\nset<ll> st;\n\nll brute_force(int n, int k){\n\tdeque<int> dq;\n\tst.clear();\n\tREP(i, 0, 1 << (n - 1)){\n\t\tdq.clear();\n\t\tdq.pb(1);\n\t\tREP(j, 0, n - 1){\n\t\t\tif (i & (1 << j)){\n\t\t\t\tdq.pb(j + 2);\n\t\t\t} else {\n\t\t\t\tdq.push_front(j + 2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i1, 0, 1 << (n - 1)){\n\t\t\tll vv = 0;\n\t\t\tdeque<int> dq1 = dq;\n\t\t\tint flag = 0;\n\t\t\tREP(j, 0, n){\n\t\t\t\tint a;\n\t\t\t\tif (i1 & (1 << j)){\n\t\t\t\t\ta = dq1.front();\n\t\t\t\t\tdq1.pop_front();\n\t\t\t\t} else {\n\t\t\t\t\ta = dq1.back();\n\t\t\t\t\tdq1.pop_back();\n\t\t\t\t}\n\t\t\t\tif (a == 1 && j + k == n){\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t\tvv = vv * (n + 1) + a;\n\t\t\t}\n\t\t\tif (flag){\n\t\t\t\tst.insert(vv);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn SZ(st);\n}\n\nvoid solve(int n, int k){\n\tst2[0] = 1;\n\tREPN(i, 1, n){\n\t\tst2[i] = (st2[i - 1] * 2) % MOD;\n\t}\n\t\n\tc[0][0] = 1;\n\tREPN(i, 1, n){\n\t\tc[i][0] = 1;\n\t\tREPN(j, 1, i){\n\t\t\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n\t\t}\n\t}\n\t\n\tdp[0] = 1;\n\tREPN(i, 1, n){\n\t\tdp[i] = 0;\n\t\tREP(j, 0, i){\n\t\t\t//dp[i] = (dp[i] + c[i - 1][j] * dp[j]) % MOD;\n\t\t\tdp[i] = (dp[i] + dp[j] * dp[i - 1 - j]) % MOD;\n\t\t}\n\t}\n\t\n\tdp_v[0][0] = 1;\n\tREPN(sum, 1, n){\n\t\tll dp_sum = 0ll;\n\t\tREPN(i, 0, sum){\n\t\t\tint j = sum - i;\n\t\t\tif (j){\n\t\t\t\tdp_sum = (dp_sum + dp_v[i][j - 1]) % MOD;\n\t\t\t}\n\t\t\tdp_v[i][j] = dp_sum;\n\t\t}\n\t}\n\t\n\t/*REPN(i, 1, n){\n\t\tprintf(\"%d %lld\\n\", i, dp[i]);\n\t}*/\n\t\n\tif (k == 1){\n\t\tprintf(\"%lld\\n\", dp[n - 1]);\n\t\t//printf(\"%lld\\n\", brute_force(n, k));\n\t\treturn;\n\t}\n\t\n\tll ans = (st2[k - 2] * dp[n - k]) % MOD;\n\t\n\t//printf(\"#1: %lld\\n\", ans);\n\t\n\tREPN(i, k + 1, n){\n\t\tll mul = (c[i - 2][k - 2] * st2[k - 2]) % MOD;\n\t\tll sum = dp_v[n - i][i - k];\n\t\t/*ll sum = 0ll;\n\t\tREPN(j, i, n){\n\t\t\tll cur = (dp[n - j] * c[j - k - 1][i - k - 1]) % MOD;\n\t\t\tprintf(\"## %lld\\n\", cur);\n\t\t\tsum = (sum + cur) % MOD;\n\t\t}*/\n\t\tans = (ans + mul * sum) % MOD;\n\t\t\n\t\t//printf(\"# %d %lld %lld\\n\", i, mul, sum);\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\t//printf(\"%lld\\n\", brute_force(n, k));\n}\n\nvoid solve(){\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tk = n - k + 1;\n\tsolve(n, k);\n\t/*for(int n = 1; n <= 7; n++){\n\t\tfor(int k = 1; k <= n; k++){\n\t\t\tprintf(\"%d %d\\n\", n, k);\n\t\t\tsolve(n, k);\n\t\t}\n\t}*/\n}\n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\n\nconst int N_MAX = 2005;\n\nint N, K;\nmod_int dp[N_MAX][N_MAX];\n\nint main() {\n    cin >> N >> K;\n    dp[0][N] = 1;\n\n    for (int len = 0; len < K; len++)\n        for (int x = N - len; x > 0; x--) {\n            dp[len + 1][x - 1] += dp[len + 1][x] + dp[len][x];\n            dp[len + 1][x] += dp[len][x];\n        }\n\n    mod_int answer = dp[K][0] * mod_int(2).pow(max(N - K - 1, 0));\n    cout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n\nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = (ans + f[K-1][i]) % MM;\n\tcout<<((K!=n)?(ans * pw[n-K-1] % MM):ans)<<endl;\n\tcout<<\"lalala\"<<endl;\n}\n\nvoid printans(){\n\n}\n\n\nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long p=1000000007ll;\nlong long n,k,dp[10001];\nlong long quickpow(long long a,long long b,long long n)\n{\n\tif(b==0&&n>1) return 1;\n\tif(b==0&&n==1) return 0;\n\tif(b==1) return a%n;\n\tif(b%2==0)\n\t{\n\t\tlong long t=quickpow(a,b/2,n);\n\t\treturn t*t%n;\n\t}\n\telse\n\t{\n\t\tlong long t=quickpow(a,b/2,n);\n\t\tt=t*t%n;\n\t\treturn t*a%n;\n\t}\n}\n\nint main(){\n    cin>>n>>k;\n    dp[0]=1ll;\n    for(int i=1;i<n;i++)\n\t{\n\t\tfor(int j=i;j>0;j--)\n\t\t\tdp[j]=(dp[j+1]+dp[j-1])%p;\n\t\tdp[0]=dp[1];\n\t}\n\tcout<<dp[n-k]*quickpow(2ll,n-k-1,p)%p<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 11116\n#define mod 1000000007\n\nint n,m,f[N];\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();m=read();f[1]=1;\n\tfor (int i=2;i<=n;i++)\n\t\tfor (int j=1;j<=i;j++)\n\t\t\tf[j]=(f[j-1]+f[j])%mod;\n\tfor (int i=m+1;i<n;i++)\n\t\tf[m]=f[m]*2%mod;\n\tprintf(\"%d\\n\",f[m]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 2010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,k;\n\nint dp[maxn][maxn][2];\n\nvoid Work(){\n\tdp[n+1][0][1]=1;\n\tRREP(i,n,1){\n\t\tRREP(j,n,0)(dp[i+1][j][0]+=dp[i+1][j+1][0])%=mod;\n\t\tREP(j,0,n)\n\t\t\tREP(k,0,1){\n\t\t\t\t(dp[i][j+1][1]+=dp[i+1][j][k])%=mod;\n\t\t\t\t(dp[i][j][0]+=dp[i+1][j][k])%=mod;\n\t\t\t}\n\t}\n\tint ans=dp[1][n-k][0];\n\tREP(i,1,max(0,n-k-1))ans=(ans<<1)%mod;\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n,k);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n\nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - 1 - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];// * 2;\n\t\tfor(int j = 1; j <= n - 1 - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = (ans + f[K-1][i]) % MM;\n\tcout<<ans * pw[n-K-1] % MM<<endl;\n}\n\nvoid printans(){\n\n}\n\n\nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n\nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = (ans + f[K-1][i]) % MM;\n\tcout<<((K!=n)?(ans * pw[n-K-1] % MM):ans)<<endl;\n}\n\nvoid printans(){\n\n}\n\n\nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null dp[2019][2019];\null frac[N_MAX], invf[N_MAX];\null ncr (ull n, ull r) {\n\treturn frac[n] * (invf[r] * invf[n - r] % MOD) % MOD;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfrac[0] = invf[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfrac[i] = (frac[i - 1] * i) % MOD;\n\t\tinvf[i] = divide(invf[i - 1], i, MOD);\n\t}\n\n\tdp[0][0] = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tsum = 0;\n\t\tfor (j = n; j >= 0; j--) {\n\t\t\tsum += dp[i][j];\n\t\t\tdp[i + 1][j] = (sum + (j ? dp[i][j - 1] : 0)) % MOD;\n\t\t}\n\t}\n\n\tif (k == n) {\n\t\tresult = dp[n - 1][0];\n\t} else {\n\t\t\t\n\t\tfor (i = 0; i < k; i++) {\n\t\t\tfor (j = 0; j <= n; j++) {\n\t\t\t\t// Choose from N-i-2\n\t\t\t\t// Choose K-1-i\n\n\t\t\t\tif (i + j >= k) break;\n\t\t\t\tresult += dp[i][j] * ncr(n - i - 2, k - 1 - i) % MOD;\n\t\t\t\tresult %= MOD;\n\t\t\t}\n\t\t}\n\t\tif (k < n) result = (result * bitpow(2, n - k - 1, MOD)) % MOD;\n\t}\n\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 5;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\tscanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n \n#define sl(x) scanf(\"%ld\", &x)\n#define ss(x) scanf(\"%s\", x)\n#define pl(x) printf(\"%ld\\n\", x)\n#define pd(x) printf(\"%lf\\n\", x)\n#define ps(x) printf(\"%s\\n\", x)\n \n#define INF 1000000000000000000\n#define MOD 1000000007\n \n#define MIN(a,b) (((a)<(b))?(a):(b))\n#define MAX(a,b) (((a)>(b))?(a):(b))\n\nint compare_long(const void *a, const void *b) {\n\treturn *(long*)a - *(long*)b;\n}\n\nlong combi(int n, int r) {\n\tint numerator[r];\n\tint denominator[r];\n\tint k, p;\n\tint pivot;\n\tint offset;\n\tlong ret = 1;\n\t\n\tif (n < 0 || r < 0 || r > n) return 0;\n\t\n\tif (n - r < r) r = n - r;\n\tif (r == 0) return 1;\n\tif (r == 1) return n;\n\t\n\t\n\t\n\tfor(k = 0;k < r;k++) {\n\t\tnumerator[k] = n - r + k + 1;\n\t\tdenominator[k] = k + 1;\n\t}\n\t\n\tfor(p = 2; p <= r; p++) {\n\t\tpivot = denominator[p - 1];\n\t\tif(pivot > 1) {\n\t\t\toffset = (n - r) % p;\n\t\t\tfor(k = p - 1; k < r; k += p) {\n\t\t\t\tnumerator[k - offset] /= pivot;\n\t\t\t\tdenominator[k] /= pivot;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(k = 0; k < r; k++) {\n\t\tif(numerator[k] > 1) ret = (ret * numerator[k]) % MOD;\n\t}\n\t\n\treturn ret;\n}\n\nint main() {\n\tlong N, K;\n\tlong a;\n\tlong b[100001] = {0};\n\tlong cnt = 0;\n\tlong i, j;\n\tlong ans = 0;\n\t\n\tsl(N); sl(K);\n\t\n\tans = combi(N-1, K-1);\n\t\n\tfor(i=0;i<N-K-1;i++) {\n\t\tans *= 2;\n\t\tans %= MOD;\n\t}\n\t\n\tpl(ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null dp[2019][2019];\null frac[N_MAX], invf[N_MAX];\null ncr (ull n, ull r) {\n\treturn frac[n] * (invf[r] * invf[n - r] % MOD) % MOD;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfrac[0] = invf[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfrac[i] = (frac[i - 1] * i) % MOD;\n\t\tinvf[i] = divide(invf[i - 1], i, MOD);\n\t}\n\n\tdp[0][0] = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tsum = 0;\n\t\tfor (j = 0; j <= n; j++) {\n\t\t\tsum += dp[i][j];\n\t\t\tdp[i + 1][j] = (sum + dp[i][j + 1]) % MOD;\n\t\t}\n\t}\n\n\tif (k == n) {\n\t\tresult = dp[n - 1][0];\n\t} else {\n\t\t\t\n\t\tfor (i = 0; i < k; i++) {\n\t\t\tfor (j = 0; j <= n; j++) {\n\t\t\t\t// Choose from N-i-2\n\t\t\t\t// Choose K-1-i\n\n\t\t\t\tif (i + j >= k) break;\n\t\t\t\tresult += dp[i][j] * ncr(n - i - 2, k - 1 - i) % MOD;\n\t\t\t\tresult %= MOD;\n\t\t\t}\n\t\t}\n\t\tif (k < n) result = (result * bitpow(2, n - k - 1, MOD)) % MOD;\n\t}\n\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 5;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\tscanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#define D(i,a,b)for(int i=a;i>=b;--i)\nf[2005],n,k,M=1e9+7;main(){scanf(\"%d%d\",&n,&k);f[n+1]=1;D(i,n,n-k+1)D(j,n,1)f[j]=j>i?0:(f[j]+f[j+1])%M;D(i,n-k,2)f[1]=f[1]*2%M;printf(\"%d\\n\",f[1]);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N\t2000\n#define MD\t1000000007\n\nint main() {\n\tstatic int dp[N + 1];\n\tint n, k, i, j, ans;\n\n\tscanf(\"%d%d\", &n, &k);\n\tdp[0] = 1;\n\tfor (i = 0; i < k - 1; i++) {\n\t\tfor (j = i + 1; j <= n; j++)\n\t\t\tdp[j] = (dp[j] + dp[j - 1]) % MD;\n\t\tdp[i] = 0;\n\t}\n\tans = 0;\n\tfor (j = 0; j < n; j++)\n\t\tans = (ans + dp[j]) % MD;\n\tfor (i = k; i < n - 1; i++)\n\t\tans = ans * 2 % MD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#define D(i,a,b)for(int i=a;i>=b;--i)\nf[2005],n,k,M=1e9+7;main(){scanf(\"%d%d\",&n,&k);f[n+1]=1;D(i,n,n-k+1)D(j,n,1)f[j]=j>i?0:(f[j]+f[j+1])%M;D(i,n-k,2)(f[1]*=2)%=M;printf(\"%d\\n\",f[1]);}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.arc.arc068;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int k = in.nextInt();\n        ncr = new int[2010][2010];\n        for (int i = 0; i < ncr.length; i++) {\n            ncr[i][0] = ncr[i][i] = 1;\n            for (int j = 1 ; j < i; j++) {\n                ncr[i][j] = (ncr[i-1][j] + ncr[i-1][j-1]);\n                ncr[i][j] %= MOD;\n            }\n        }\n\n        long ans = 0;\n\n\n        // 次に処理する数,更新フラグ,保留数\n        int[][][] dp = new int[2][2][n+1];\n        dp[n%2][0][0] = 1;\n        for (int i = n ; i >= 1 ; i--) {\n            int fr = i%2;\n            int to = fr^1;\n            for (int flg = 0; flg <= 1; flg++) {\n                Arrays.fill(dp[to][flg], 0);\n            }\n\n            int haveProcessedNumbers = n - i;\n            for (int flg = 0; flg <= 1; flg++) {\n                for (int j = n ; j >= 0; j--) {\n                    if (dp[fr][flg][j] == 0) {\n                        continue;\n                    }\n                    int base = dp[fr][flg][j];\n                    int currentlyInSequence =  haveProcessedNumbers - j;\n                    if (currentlyInSequence == k-1) {\n                        ans = addMOD(ans, dp[fr][flg][j]);\n                        continue;\n                    }\n                    if (flg == 1 && j >= 1) {\n                        dp[fr][flg][j-1] = addMOD(dp[fr][flg][j-1], base);\n                    }\n                    if (i == 1) {\n                        continue;\n                    }\n                    dp[to][1][j] = addMOD(dp[to][1][j], base);\n                    dp[to][0][j+1] = addMOD(dp[to][0][j+1], base);\n                }\n            }\n        }\n\n        for (int i = 0 ; i < n-k-1 ; i++) {\n            ans *= 2;\n            ans %= MOD;\n        }\n        out.println(ans);\n        out.flush();\n    }\n\n    private static int addMOD(long x, long y) {\n        long ret = x + y;\n        return (int)(ret >= MOD ? ret-MOD : ret);\n    }\n\n    static int[][] ncr;\n\n    static long comb(int n, int k) {\n        if (n < 0 || k < 0 || n < k) {\n            return 0;\n        }\n        return ncr[n][k] % MOD;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        long[][] answer;\n        long[][] sum;\n        int base;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            base = n - k + 1;\n            answer = new long[n + 1][n + 1];\n            sum = new long[n + 1][n + 1];\n            ArrayUtils.fill(answer, -1);\n            ArrayUtils.fill(sum, -1);\n            long answer = go(n, n) * IntegerUtils.power(2, Math.max(n - k - 1, 0), MiscUtils.MOD7) % MiscUtils.MOD7;\n            out.printLine(answer);\n        }\n\n        private long go(int n, int lim) {\n            lim = Math.min(lim, n);\n            if (answer[n][lim] != -1) {\n                return answer[n][lim];\n            }\n            if (n == base) {\n                return answer[n][lim] = 1;\n            }\n            return answer[n][lim] = (go(n - 1, lim) + goSum(n - 1, lim - 1)) % MiscUtils.MOD7;\n        }\n\n        private long goSum(int n, int lim) {\n            if (sum[n][lim] != -1) {\n                return sum[n][lim];\n            }\n            if (lim <= 1) {\n                return sum[n][lim] = 0;\n            }\n            return sum[n][lim] = (go(n, lim) + goSum(n, lim - 1)) % MiscUtils.MOD7;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void fill(long[][] array, long value) {\n            for (long[] row : array) {\n                Arrays.fill(row, value);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static long power(long base, long exponent, long mod) {\n            if (base >= mod) {\n                base %= mod;\n            }\n            if (exponent == 0) {\n                return 1 % mod;\n            }\n            long result = power(base, exponent >> 1, mod);\n            result = result * result % mod;\n            if ((exponent & 1) != 0) {\n                result = result * base % mod;\n            }\n            return result;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        prec(100000);\n\n//        debug(ways(2), generate(2));\n//        debug(ways(3), generate(3));\n//        debug(ways(4), generate(4));\n//        debug(ways(5), generate(5));\n//        debug(ways(6), generate(6));\n\n        int n = in.nextInt();\n        int k = in.nextInt();\n\n        int left = k-1;\n        int right = n-left-1;\n\n        long ans = ways(n, right) % MOD * (right >= 1 ? pow(2, right-1) : 1) % MOD;\n\n        out.println(ans);\n        out.flush();\n    }\n\n    private static long ways(int n, int k) {\n        long[][][] dp = new long[2][2][n+1];\n        dp[0][0][0] = 1;\n        for (int i = 0; i < n ; i++) {\n            int fr = i % 2;\n            int to = 1 - fr;\n            for (int j = 0; j <= 1; j++) {\n                Arrays.fill(dp[to][j], 0);\n            }\n            for (int f = 0; f <= 1; f++) {\n                for (int j = n-1 ; j >= 0 ; j--) {\n                    long base = dp[fr][f][j];\n                    if (base == 0) {\n                        continue;\n                    }\n\n                    // down\n                    if (f == 0 && j >= 1) {\n                        add(dp, fr, 0, j-1, base);\n                    }\n\n                    // load\n                    add(dp, to, 1, j+1, base);\n\n                    // next\n                    add(dp, to, 0, j, base);\n                }\n            }\n        }\n        return dp[n%2][0][k] % MOD;\n    }\n\n    static void add(long[][][] dp, int a, int b, int c, long v) {\n        dp[a][b][c] += v;\n        dp[a][b][c] -= dp[a][b][c] >= MOD ? MOD : 0;\n    }\n\n    static final int MOD = 1000000007;\n\n    static long pow(long a, long x) {\n        long res = 1;\n        while (x > 0) {\n            if (x % 2 != 0) {\n                res = (res * a) % MOD;\n            }\n            a = (a * a) % MOD;\n            x /= 2;\n        }\n        return res;\n    }\n\n    static long inv(long a) {\n        return pow(a, MOD - 2) % MOD;\n    }\n\n    static long[] _fact;\n    static long[] _invfact;\n\n    static long comb(long ln, long lr) {\n        int n = (int) ln;\n        int r = (int) lr;\n        if (n < 0 || r < 0 || r > n) {\n            return 0;\n        }\n        if (r > n / 2) {\n            r = n - r;\n        }\n        return (((_fact[n] * _invfact[n - r]) % MOD) * _invfact[r]) % MOD;\n    }\n\n    static void prec(int n) {\n        _fact = new long[n + 1];\n        _invfact = new long[n + 1];\n        _fact[0] = 1;\n        _invfact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            _fact[i] = _fact[i - 1] * i % MOD;\n            _invfact[i] = inv(_fact[i]);\n        }\n    }\n\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static void execute(ContestReader reader, PrintWriter out) {\n    int n = reader.nextInt();\n    int k = reader.nextInt();\n    out.println(new Solver(n, k).solve());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass Solver {\n  final int n, k;\n  ModCalculator mc;\n  \n  Solver(int n, int k) {\n    this.n = n;\n    this.k = k;\n  }\n  \n  private long calculateOrder1() {\n    long[][] dptable = new long[n][n];\n    dptable[n - 1][0] = 1;\n    for (int i = 0; i < k; i++) {\n      for (int j = 0; j <= n - 1 - i; j++) {\n        // dptable[j][n - 1 - i - j]\n        int t = n - 1 - i - j;\n        for (int k = 1; k <= j; k++) {\n          dptable[j - k][t + k - 1] = mc.add(dptable[j - k][t + k - 1], dptable[j][t]);\n        }\n        if (t > 0) {\n          dptable[j][t - 1] = mc.add(dptable[j][t - 1], dptable[j][t]);\n        }\n        \n        // dptable[j - k][t + k - 1] = mc.add(dptable[j - k][t + k - 1], dptable[j][t]);\n        // a = j - k\n        // b = t + k - 1\n        // j = a + k\n        // t = b - k + 1\n        // dptable[a][b] += dptable[a+k][b-k+1]\n        \n        \n      }\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        System.err.printf(\"%7d\", dptable[i][j]);\n      }\n      System.err.println();\n    }\n    \n    \n    long sum = 0;\n    for (int j = 0; j <= n - k; j++){\n      sum = mc.add(sum, dptable[j][n - k - j]);\n    }\n    return sum;\n  }\n  \n  private long calculateOrder2() {\n    long[][] dptable = new long[n][n];\n    dptable[n - 1][0] = 1;\n    for (int i = 0; i < k; i++) {\n      dptable[n - 1 - i - 1][0] = mc.add(dptable[n - 1 - i][0], dptable[n-1-i-1][1]);\n      for (int j = 1; n - 1 - i - 1 - j >= 0; j++) {\n        dptable[n - 1 - i - 1 - j][j] = mc.add(dptable[n - 1 - i - 1 - j + 1][j - 1], dptable[n - 1 - i - 1 - j][j + 1]);\n      }\n      /*\n      for (int j = 0; j <= n - 1 - i; j++) {\n        // dptable[j][n - 1 - i - j]\n        int t = n - 1 - i - j;\n        for (int k = 1; k <= j; k++) {\n          dptable[j - k][t + k - 1] = mc.add(dptable[j - k][t + k - 1], dptable[j][t]);\n        }\n        if (t > 0) {\n          dptable[j][t - 1] = mc.add(dptable[j][t - 1], dptable[j][t]);\n        }\n        \n        // dptable[j - k][t + k - 1] = mc.add(dptable[j - k][t + k - 1], dptable[j][t]);\n        // a = j - k\n        // b = t + k - 1\n        // j = a + k\n        // t = b - k + 1\n        // dptable[a][b] += dptable[a+k][b-k+1]\n        \n        \n      }\n      */\n    }\n    /*\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        System.err.printf(\"%7d\", dptable[i][j]);\n      }\n      System.err.println();\n    }\n    */\n    \n    \n    long sum = 0;\n    for (int j = 0; j <= n - k; j++){\n      sum = mc.add(sum, dptable[j][n - k - j]);\n    }\n    return sum;\n  }\n  \n  public long solve() {\n    mc = new ModCalculator(1_000_000_007L);\n    \n//    long v11 = calculateOrder1();\n    long v12 = calculateOrder2();\n    long v2 = mc.pow(2, n - k - 1);\n//    System.err.printf(\"%d %d\\n\", v11, v12);\n//    System.err.printf(\"%d %d\\n\", v12, v2);\n    return mc.mul(v12, v2);\n  }\n}\n\nclass ContestReader {\n  private BufferedReader reader;\n  private StringTokenizer tokenizer;\n  \n  ContestReader(InputStream in) {\n    reader = new BufferedReader(new InputStreamReader(in));\n  }\n  \n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n  \n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n  \n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] nextArray(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public int[] nextIntArray(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLongArray(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDoubleArray(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public int[][] nextIntMatrix(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLongMatrix(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDoubleMatrix(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long add(long a, long b) {\n    return (a + b) % mod;\n  }\n  \n  public long sub(long a, long b) {\n    return (a - b + mod) % mod;\n  }\n  \n  public long mul(long a, long b) {\n    return (a * b) % mod;\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n  \n  class ModCombinationCache {\n    private final List<Long> factorialCache;\n    private final List<Long> factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new ArrayList<>();\n      factorialCache.add(1L);\n      factorialInverseCache = new ArrayList<>();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        long v = mul(factorialCache.get(i), i + 1);\n        factorialCache.add(v);\n        factorialInverseCache.add(inverse(v));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n \nclass Algorithm {\n  private static void swap(Object[] list, int a, int b) {\n    Object tmp = list[a];\n    list[a] = list[b];\n    list[b] = tmp;\n  }\n  \n  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {\n    int rightMostAscendingOrderIndex = ts.length - 2;\n    while (rightMostAscendingOrderIndex >= 0 &&\n        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {\n      rightMostAscendingOrderIndex--;\n    }\n    if (rightMostAscendingOrderIndex < 0) {\n      return false;\n    }\n    \n    int rightMostGreatorIndex = ts.length - 1;\n    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {\n      rightMostGreatorIndex--;\n    }\n    \n    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);\n    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {\n      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);\n    }\n    return true;\n  }\n  \n  public static void shuffle(int[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      int temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void shuffle(long[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      long temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void sort(int[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n  \n  public static void sort(long[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n}\n\nclass UnionFind {\n  int[] parents;\n  int[] ranks;\n\n  UnionFind(int n) {\n    parents = new int[n];\n    ranks = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      parents[i] = i;\n    }\n  }\n\n  public int getRoot(int index) {\n    if (parents[index] == index) {\n      return index;\n    } else {\n      parents[index] = getRoot(parents[index]);\n      return parents[index];\n    }\n  }\n\n  public boolean sameGroup(int a, int b) {\n    return getRoot(a) == getRoot(b);\n  }\n\n  public void merge(int a, int b) {\n    int rootA = getRoot(a);\n    int rootB = getRoot(b);\n    if (rootA == rootB) {\n      return;\n    }\n    if (ranks[rootA] < ranks[rootB]) {\n      parents[rootA] = rootB;\n    } else if (ranks[rootB] < ranks[rootA]) {\n      parents[rootB] = rootA;\n    } else {\n      parents[rootA] = rootB;\n      ranks[rootB]++;\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskB solver = new TaskB();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n\n            NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n            NumberTheory.Power power = new NumberTheory.Power(mod);\n            int[][] dp = new int[k][n];\n            int[][] prefix = new int[k][n];\n            dp[0][0] = 1;\n            Arrays.fill(prefix[0], 1);\n            for (int i = 1; i < k; i++) {\n                for (int j = i; j < n; j++) {\n                    dp[i][j] = prefix[i - 1][j];\n                }\n                prefix[i][0] = dp[i][0];\n                for (int j = 1; j < n; j++) {\n                    prefix[i][j] = mod.plus(prefix[i][j - 1], dp[i][j]);\n                }\n            }\n\n            int ans = prefix[k - 1][n - 1];\n            ans = mod.mul(ans, power.pow(2, n - 1 - (k - 1) - 1));\n            out.println(ans);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FSolitaire solver = new FSolitaire();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FSolitaire {\n        Modular mod = new Modular(1e9 + 7);\n        Power power = new Power(mod);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int[][] dp = new int[k][n + 2];\n            dp[0][n + 1] = 1;\n            for (int i = 1; i < k; i++) {\n                ModPreSum ps = new ModPreSum(dp[i - 1], mod);\n                for (int j = 1; j <= n; j++) {\n                    dp[i][j] = ps.suffix(j);\n                    if (n - j + 1 < i) {\n                        dp[i][j] = 0;\n                    }\n                }\n            }\n\n            int sum = new ModPreSum(dp[k - 1], mod).suffix(2);\n            int way = k == n ? 1 : power.pow(2, n - k - 1);\n            int ans = mod.mul(sum, way);\n            out.println(ans);\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class ModPreSum {\n        private int[] pre;\n        private Modular mod;\n\n        public ModPreSum(int n, Modular mod) {\n            pre = new int[n];\n            this.mod = mod;\n        }\n\n        public void populate(int[] a) {\n            int n = a.length;\n            pre[0] = a[0];\n            for (int i = 1; i < n; i++) {\n                pre[i] = mod.plus(pre[i - 1], a[i]);\n            }\n        }\n\n        public ModPreSum(int[] a, Modular mod) {\n            this(a.length, mod);\n            populate(a);\n        }\n\n        public int prefix(int i) {\n            if (i < 0) {\n                return 0;\n            }\n            return pre[Math.min(i, pre.length - 1)];\n        }\n\n        public int suffix(int i) {\n            return mod.subtract(pre[pre.length - 1], prefix(i - 1));\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class Power {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\nconst int MM = 1e9 + 7;\nconst double eps = 1e-8;\nconst int MAXN = 2e6 + 10;\n\nint n, m;\n\nvoid prework(){\n\n}\n\nvoid read(){\n\n}\n\nint K;\nll C[2222][2222];\nll pw[2222];\nll f[2222][2222];\nll sum[2222][2222];\n\nvoid solve(int casi){\n\tcin>>n>>K;\n\tC[0][0] = C[1][0] = C[1][1] = 1;\n\tfor(int i = 2; i <= 2000; i++){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tpw[0] = 1;\n\tfor(int i = 1; i <= 2000; i++){\n\t\tpw[i] = (2 * pw[i-1]) % MM;\n\t}\n\tll ans = 0;//pw[n-K-1];\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tsum[0][i] = 1;\n\tfor(int i = 1; i < K; i++){\n\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\tf[i][j] = sum[i-1][j+1];\n\t\t}\n\t\tsum[i][0] = f[i][0];\n\t\tfor(int j = 1; j <= n - i; j++)\n\t\t\tsum[i][j] = (sum[i][j-1] + f[i][j]) % MM;\n\t}\n\tfor(int i = 0; i <= n - K; i++)\n\t\tans = (ans + f[K-1][i]) % MM;\n\tcout<<((K!=n)?(ans * pw[n-K-1] % MM):ans)<<endl;\n}\n\nvoid printans(){\n\n}\n\n\nint main(){\n\tprework();\n\tint T = 1;\n//\tcin>>T;\n\tfor(int i = 1; i <= T; i++){\n\t\tread();\n\t\tsolve(i);\n\t\tprintans();\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskB solver = new TaskB();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n\n            NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n            NumberTheory.Power power = new NumberTheory.Power(mod);\n            int[][] dp = new int[k][n];\n            int[][] prefix = new int[k][n];\n            dp[0][0] = 1;\n            Arrays.fill(prefix[0], 1);\n            for (int i = 1; i < k; i++) {\n                for (int j = i; j < n; j++) {\n                    dp[i][j] = prefix[i - 1][j];\n                }\n                prefix[i][0] = dp[i][0];\n                for (int j = 1; j < n; j++) {\n                    prefix[i][j] = mod.plus(prefix[i][j - 1], dp[i][j]);\n                }\n            }\n\n            int ans = prefix[k - 1][n - 1];\n            if (k != n) {\n                ans = mod.mul(ans, power.pow(2, n - 1 - (k - 1) - 1));\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static void execute(ContestReader reader, PrintWriter out) {\n    int n = reader.nextInt();\n    int k = reader.nextInt();\n    out.println(new Solver(n, k).solve());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass Solver {\n  final int n, k;\n  ModCalculator mc;\n  \n  Solver(int n, int k) {\n    this.n = n;\n    this.k = k;\n  }\n  \n  private long calculateOrder1() {\n    long[][] dptable = new long[n][n];\n    dptable[n - 1][0] = 1;\n    for (int i = 0; i < k; i++) {\n      for (int j = 0; j <= n - 1 - i; j++) {\n        // dptable[j][n - 1 - i - j]\n        int t = n - 1 - i - j;\n        for (int k = 1; k <= j; k++) {\n          dptable[j - k][t + k - 1] = mc.add(dptable[j - k][t + k - 1], dptable[j][t]);\n        }\n        if (t > 0) {\n          dptable[j][t - 1] = mc.add(dptable[j][t - 1], dptable[j][t]);\n        }\n        \n        // dptable[j - k][t + k - 1] = mc.add(dptable[j - k][t + k - 1], dptable[j][t]);\n        // a = j - k\n        // b = t + k - 1\n        // j = a + k\n        // t = b - k + 1\n        // dptable[a][b] += dptable[a+k][b-k+1]\n        \n        \n      }\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        System.err.printf(\"%7d\", dptable[i][j]);\n      }\n      System.err.println();\n    }\n    \n    \n    long sum = 0;\n    for (int j = 0; j <= n - k; j++){\n      sum = mc.add(sum, dptable[j][n - k - j]);\n    }\n    return sum;\n  }\n  \n  private long calculateOrder2() {\n    long[][] dptable = new long[n][n];\n    dptable[n - 1][0] = 1;\n    for (int i = 0; i < k-1; i++) {\n      dptable[n - 1 - i - 1][0] = mc.add(dptable[n - 1 - i][0], dptable[n-1-i-1][1]);\n      for (int j = 1; n - 1 - i - 1 - j >= 0; j++) {\n        dptable[n - 1 - i - 1 - j][j] = mc.add(dptable[n - 1 - i - 1 - j + 1][j - 1], dptable[n - 1 - i - 1 - j][j + 1]);\n      }\n      /*\n      for (int j = 0; j <= n - 1 - i; j++) {\n        // dptable[j][n - 1 - i - j]\n        int t = n - 1 - i - j;\n        for (int k = 1; k <= j; k++) {\n          dptable[j - k][t + k - 1] = mc.add(dptable[j - k][t + k - 1], dptable[j][t]);\n        }\n        if (t > 0) {\n          dptable[j][t - 1] = mc.add(dptable[j][t - 1], dptable[j][t]);\n        }\n        \n        // dptable[j - k][t + k - 1] = mc.add(dptable[j - k][t + k - 1], dptable[j][t]);\n        // a = j - k\n        // b = t + k - 1\n        // j = a + k\n        // t = b - k + 1\n        // dptable[a][b] += dptable[a+k][b-k+1]\n        \n        \n      }\n      */\n    }\n    /*\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        System.err.printf(\"%7d\", dptable[i][j]);\n      }\n      System.err.println();\n    }\n    */\n    \n    \n    long sum = 0;\n    for (int j = 0; j <= n - k; j++){\n      sum = mc.add(sum, dptable[j][n - k - j]);\n    }\n    return sum;\n  }\n  \n  public long solve() {\n    mc = new ModCalculator(1_000_000_007L);\n    \n//    long v11 = calculateOrder1();\n    long v12 = calculateOrder2();\n    long v2 = mc.pow(2, n - k - 1);\n//    System.err.printf(\"%d %d\\n\", v11, v12);\n//    System.err.printf(\"%d %d\\n\", v12, v2);\n    return mc.mul(v12, v2);\n  }\n}\n\nclass ContestReader {\n  private BufferedReader reader;\n  private StringTokenizer tokenizer;\n  \n  ContestReader(InputStream in) {\n    reader = new BufferedReader(new InputStreamReader(in));\n  }\n  \n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n  \n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n  \n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] nextArray(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public int[] nextIntArray(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLongArray(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDoubleArray(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public int[][] nextIntMatrix(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLongMatrix(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDoubleMatrix(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long add(long a, long b) {\n    return (a + b) % mod;\n  }\n  \n  public long sub(long a, long b) {\n    return (a - b + mod) % mod;\n  }\n  \n  public long mul(long a, long b) {\n    return (a * b) % mod;\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n  \n  class ModCombinationCache {\n    private final List<Long> factorialCache;\n    private final List<Long> factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new ArrayList<>();\n      factorialCache.add(1L);\n      factorialInverseCache = new ArrayList<>();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        long v = mul(factorialCache.get(i), i + 1);\n        factorialCache.add(v);\n        factorialInverseCache.add(inverse(v));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n \nclass Algorithm {\n  private static void swap(Object[] list, int a, int b) {\n    Object tmp = list[a];\n    list[a] = list[b];\n    list[b] = tmp;\n  }\n  \n  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {\n    int rightMostAscendingOrderIndex = ts.length - 2;\n    while (rightMostAscendingOrderIndex >= 0 &&\n        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {\n      rightMostAscendingOrderIndex--;\n    }\n    if (rightMostAscendingOrderIndex < 0) {\n      return false;\n    }\n    \n    int rightMostGreatorIndex = ts.length - 1;\n    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {\n      rightMostGreatorIndex--;\n    }\n    \n    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);\n    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {\n      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);\n    }\n    return true;\n  }\n  \n  public static void shuffle(int[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      int temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void shuffle(long[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      long temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void sort(int[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n  \n  public static void sort(long[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n}\n\nclass UnionFind {\n  int[] parents;\n  int[] ranks;\n\n  UnionFind(int n) {\n    parents = new int[n];\n    ranks = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      parents[i] = i;\n    }\n  }\n\n  public int getRoot(int index) {\n    if (parents[index] == index) {\n      return index;\n    } else {\n      parents[index] = getRoot(parents[index]);\n      return parents[index];\n    }\n  }\n\n  public boolean sameGroup(int a, int b) {\n    return getRoot(a) == getRoot(b);\n  }\n\n  public void merge(int a, int b) {\n    int rootA = getRoot(a);\n    int rootB = getRoot(b);\n    if (rootA == rootB) {\n      return;\n    }\n    if (ranks[rootA] < ranks[rootB]) {\n      parents[rootA] = rootB;\n    } else if (ranks[rootB] < ranks[rootA]) {\n      parents[rootB] = rootA;\n    } else {\n      parents[rootA] = rootB;\n      ranks[rootB]++;\n    }\n  }\n}\n"
  },
  {
    "language": "Perl",
    "code": "# WA\nuse bigint;\n($N,$K)=glob<>;\nif($N==$K||$N==1){\n\tprint 1,$/;\n}else{\n\tprint+(($N-1)->bnok($K-1))%($m=1000000007)*`python -c'print pow(2,$N-$K-1,$m)'`%$m,$/\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.range, std.algorithm, std.conv;\n// import dcomp.scanner;\n// import dcomp.numeric.primitive;\n// import dcomp.modint;\n// import dcomp.functional;\n\nalias Mint = ModInt!(10^^9 + 7);\nMint calcSkipBase(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    if (n == 0) return Mint(1);\n    Mint ans = 0;\n    ans += calcSkip(n, k+1); // not last skip\n    ans += calc(n-1, k); // last skip use\n    return ans;\n}\nmemoCont!calcSkipBase calcSkip;\nMint calcBase(int n, int k) {\n    if (k < 0 || n < k) return Mint(0);\n    if (n == 0) return Mint(1);\n    Mint ans = 0;\n//    ans += calc(n, k+1); // not last skip\n    ans += calc(n-1, k-1); // normal use\n    ans += calcSkip(n, k); // last skip use\n    return ans;\n}\nmemoCont!calcBase calc;\n\nint main() {\n    calcSkip.init([[-1, 2020], [-1, 2020]]);\n    calc.init([[-1, 2020], [-1, 2020]]);\n    auto sc = new Scanner(stdin);\n    int n, k;\n    sc.read(n, k);\n    k = n-k;\n    if (k == 0) {\n        writeln(calc(n-1, 0).v);\n        return 0;\n    }\n    auto fact = factTable!(Mint)(10000);\n    auto iFac = invFactTable!(Mint)(10000);\n    Mint C(int n, int k) {\n        if (n < k || n < 0) return Mint(0);\n        return fact[n]*iFac[k]*iFac[n-k];\n    }\n    Mint sm = 0;\n    foreach (i; k..n) {\n        sm += C(i-1, k-1) * calc(n-1-k, i-k);\n    }\n    sm *= pow(Mint(2), k-1);\n    writeln(sm.v);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/functional.d */\n// module dcomp.functional;\n\nstruct memoCont(alias pred) {\n    import core.exception : RangeError;\n    import std.range, std.algorithm, std.conv;\n    import std.string : join;\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.typecons : tuple, Tuple;\n    import std.meta;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args));\n    static immutable N = Args.length;\n    int[2][N] rng;\n    int[N] len;\n    R[] dp;\n    bool[] used;\n    void init(int[2][N] rng) {\n        this.rng = rng;\n        len = rng[].map!(a => a[1]-a[0]+1).array;\n        int sz = len.reduce!\"a*b\";\n        dp = new R[sz];\n        used = new bool[sz];\n    }\n    R opCall(Args args) {\n        int idx, base = 1;\n        foreach (i, v; args) {\n            version(assert) {\n                if (v < rng[i][0] || rng[i][1] < v) {\n                    throw new RangeError;\n                }\n            }\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx += base*(v - rng[i][0]);\n            base *= len[i];\n        }\n        if (used[idx]) return dp[idx];\n        used[idx] = true;\n        auto r = pred(args);\n        dp[idx] = r;\n        return r;\n    }\n}\n\nunittest {\n//     import dcomp.numeric.primitive;\n//     import dcomp.modint;\n    alias Mint = ModInt!(10^^9+7);\n    auto fact = factTable!Mint(100);\n    auto iFac = invFactTable!Mint(100);\n    Mint C0(int a, int b) {\n        if (a < 0 || a < b) return Mint(0);\n        return fact[a]*iFac[b]*iFac[a-b];\n    }\n    struct A {\n        static memoCont!C1base C1;\n        static Mint C1base(int a, int b) {\n            if (a == 0) {\n                if (b == 0) return Mint(1);\n                return Mint(0);\n            }\n            if (b < 0) return Mint(0);\n            return C1(a-1, b-1) + C1(a-1, b);\n        }\n    }\n    A.C1.init([[0, 100], [-2, 100]]);\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            assert(C0(i, j) == A.C1(i, j));\n        }\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) const {return make( (long(v)*r.v%MD).to!uint );}\n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    static assert( is(ModInt!(uint(1000000000) * 2))); //not overflow\n    static assert(!is(ModInt!(uint(1145141919) * 2))); //overflow!\n    alias Mint = ModInt!(10^^9+7);\n    // negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n\n    Mint a = 48;\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(DModInt r) {\n        return make(normS(v+r.v));\n    }\n    auto opBinary(string op:\"-\")(DModInt r) {\n        return make(normS(v+MD-r.v));\n    }\n    auto opBinary(string op:\"*\")(DModInt r) {\n        return make((long(v)*r.v%MD).to!uint);\n    }\n    auto opBinary(string op:\"/\")(DModInt r) {\n        return this*inv(r);\n    }\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    alias Mint = DModInt!(\"default\");\n    Mint.MD = 10^^9 + 7;\n    //negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n    Mint a = Mint(48);\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n// optimize\nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\nunittest {\n    import std.stdio;\n    alias Mint = ModInt!(10^^9 + 7);\n    auto r = factTable!Mint(20);\n    Mint a = 1;\n    assert(r[0] == Mint(1));\n    foreach (i; 1..20) {\n        a *= Mint(i);\n        assert(r[i] == a);\n    }\n    auto p = invFactTable!Mint(20);\n    foreach (i; 1..20) {\n        assert((r[i]*p[i]).v == 1);\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n\nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsignedはNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n"
  },
  {
    "language": "Bash",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskB solver = new TaskB();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n\n            NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n            NumberTheory.Power power = new NumberTheory.Power(mod);\n            int[][] dp = new int[k][n];\n            int[][] prefix = new int[k][n];\n            dp[0][0] = 1;\n            Arrays.fill(prefix[0], 1);\n            for (int i = 1; i < k; i++) {\n                for (int j = i; j < n; j++) {\n                    dp[i][j] = prefix[i - 1][j];\n                }\n                prefix[i][0] = dp[i][0];\n                for (int j = 1; j < n; j++) {\n                    prefix[i][j] = mod.plus(prefix[i][j - 1], dp[i][j]);\n                }\n            }\n\n            int ans = prefix[k - 1][n - 1];\n            ans = mod.mul(ans, power.pow(2, n - 1 - (k - 1) - 1));\n            out.println(ans);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "def cmb(n, r, mod):#コンビネーションの高速計算　\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #出力の制限\nN = 5000\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nN,K=map(int,input().split())\n\nif N==1:\n    print(1)\nelif K==1:\n    print(pow(2,N-2,mod))\nelif K==N:\n    dp=[[0 for i in range(K+1)] for j in range(K)]\n    imos=[0]*(K+1)\n\n    dp[0][K]=1\n    imos[K]=1\n\n    for i in range(1,K):\n        for j in range(K-i,K+1):\n            if j==K-i:\n                dp[i][j]=(imos[K]-imos[j])%mod\n            else:\n                dp[i][j]=(dp[i-1][j]+imos[K]-imos[j])%mod\n        imos=[dp[i][j] for j in range(K+1)]\n        for j in range(1,K+1):\n            imos[j]+=imos[j-1]\n            imos[j]%=mod\n    print(dp[N-1][1])\nelse:\n    dp=[[0 for i in range(K+1)] for j in range(K)]\n    imos=[0]*(K+1)\n\n    dp[0][K]=1\n    imos[K]=1\n\n    for i in range(1,K):\n        for j in range(K-i,K+1):\n            if j==K-i:\n                dp[i][j]=(imos[K]-imos[j])%mod\n            else:\n                dp[i][j]=(dp[i-1][j]+imos[K]-imos[j])%mod\n        imos=[dp[i][j] for j in range(K+1)]\n        for j in range(1,K+1):\n            imos[j]+=imos[j-1]\n            imos[j]%=mod\n\n    ans=0\n    for M in range(N-K+1,N+1):\n        id=M-N+K\n        ans+=dp[K-1][id]*cmb(M-2,N-K-1,mod)\n\n    ans*=pow(2,N-K-1,mod)\n    print(ans%mod)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nx = stdin.readline().split()\nN = int(x[0])\nK = int(x[1])\nx = N-K+1\n\nans = x\nfor i in range(K-2):\n    ans *= x + i + K\n\nfor i in range(1,K):\n    ans /= i\n\nif x > 2:\n    for i in range(x-2):\n        ans *= 2\n\nprint ans % 1000000007\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8\nfrom numba.types import Omitted\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 1_000_000_007\n\n@njit((i8, i8), cache=True)\ndef main(N, K):\n    K -= 1\n    U = 2010\n    C = np.zeros((U, U), np.int64)\n    C[0, 0] = 1\n    for n in range(1, U):\n        C[n] += C[n - 1]\n        C[n, 1:] += C[n - 1, :-1]\n        C[n] %= MOD\n\n    dp = np.zeros((N + 10, N + 10), np.int64)\n    dp[0, 0] = 1\n    for n in range(1, N + 10):\n        dp[n, n] = (dp[n - 1, n - 1] + dp[n - 1, n]) % MOD\n        for m in range(n + 1, N + 10):\n            dp[n, m] = (dp[n - 1, m] + dp[n, m - 1]) % MOD\n    for n in range(N + 9, 0, -1):\n        dp[n] -= dp[n - 1]\n        dp[n] %= MOD\n    ans = 0\n    if K == N - 1:\n        return dp[:N, N - 1].sum() % MOD\n    for r in range(N - K, N + 1):\n        x = C[r - 2, N - K - 2]\n        a = N - r\n        b = K - a\n        if b == 0:\n            x = x * (dp[:a + 1, a].sum() % MOD) % MOD\n        else:\n            x *= (dp[1:a + 2, a + 1] * C[b - 1:a + b, b - 1][::-1] %\n                  MOD).sum() % MOD\n            x %= MOD\n        ans += x\n    ans %= MOD\n    for i in range(N - K - 2):\n        ans = ans * 2 % MOD\n    return ans % MOD\n\nN, K = map(int, read().split())\nprint(main(N, K))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8\nfrom numba.types import Omitted\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 1_000_000_007\n\n@njit((i8, i8), cache=True)\ndef main(N, K):\n    K -= 1\n    U = 5000\n    C = np.zeros((U, U), np.int64)\n    C[0, 0] = 1\n    for n in range(1, U):\n        C[n] += C[n - 1]\n        C[n, 1:] += C[n - 1, :-1]\n        C[n] %= MOD\n\n    dp = np.zeros((N + 10, N + 10), np.int64)\n    dp[0, 0] = 1\n    for n in range(1, N + 10):\n        dp[n, n] = (dp[n - 1, n - 1] + dp[n - 1, n]) % MOD\n        for m in range(n + 1, N + 10):\n            dp[n, m] = (dp[n - 1, m] + dp[n, m - 1]) % MOD\n    for n in range(N + 9, 0, -1):\n        dp[n] -= dp[n - 1]\n        dp[n] %= MOD\n    ans = 0\n    if K == N - 1:\n        return dp[:N, N - 1].sum() % MOD\n    for r in range(N - K, N + 1):\n        x = C[r - 2, N - K - 2]\n        a = N - r\n        b = K - a\n        if b == 0:\n            x = x * (dp[:a + 1, a].sum() % MOD) % MOD\n        else:\n            x *= (dp[1:a + 2, a + 1] * C[b - 1:a + b, b - 1][::-1] %\n                  MOD).sum() % MOD\n            x %= MOD\n        ans += x\n    ans %= MOD\n    for i in range(N - K - 2):\n        ans = ans * 2 % MOD\n    return ans % MOD\n\nN, K = map(int, read().split())\nprint(main(N, K))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 1_000_000_007\n\ndef main(N, K):\n    K -= 1\n    U = 5000\n    C = np.zeros((U, U), np.int64)\n    C[0, 0] = 1\n    for n in range(1, U):\n        C[n] += C[n - 1]\n        C[n, 1:] += C[n - 1, :-1]\n        C[n] %= MOD\n\n    dp = np.zeros((N + 10, N + 10), np.int64)\n    dp[0, 0] = 1\n    for n in range(1, N + 10):\n        dp[n, n] = (dp[n - 1, n - 1] + dp[n - 1, n]) % MOD\n        for m in range(n + 1, N + 10):\n            dp[n, m] = (dp[n - 1, m] + dp[n, m - 1]) % MOD\n    for n in range(N + 9, 0, -1):\n        dp[n] -= dp[n - 1]\n        dp[n] %= MOD\n    ans = 0\n    if K == N - 1:\n        return dp[:N, N - 1].sum() % MOD\n    for r in range(N - K, N + 1):\n        x = C[r - 2, N - K - 2]\n        a = N - r\n        b = K - a\n        if b == 0:\n            x = x * (dp[:a + 1, a].sum() % MOD) % MOD\n        else:\n            x *= (dp[1:a + 2, a + 1] * C[b - 1:a + b, b - 1][::-1] %\n                  MOD).sum() % MOD\n            x %= MOD\n        ans += x\n    ans %= MOD\n    for i in range(N - K - 2):\n        ans = ans * 2 % MOD\n    return ans % MOD\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    import numba\n    from numba.pycc import CC\n    i4 = numba.int32\n    i8 = numba.int64\n    cc = CC('my_module')\n\n    def cc_export(f, signature):\n        cc.export(f.__name__, signature)(f)\n        return numba.njit(f)\n\n    main = cc_export(main, (i8, i8))\n    cc.compile()\n\nfrom my_module import main\n\nN, K = map(int, read().split())\nprint(main(N, K))"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nx = stdin.readline().split()\nN = int(x[0])\nK = int(x[1])\nx = N-K+1\n\nans = x\nfor i in range(K-2):\n    ans *= x + i + K\n\nfor i in range(1,K):\n    ans /= i\n\nif x > 2:\n    for i in range(x-2):\n        ans *= 2\n\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N, K;\nll ans = 1;\n\nll inv (ll a) {\n        ll e = MOD-2, r = 1ll;\n        while (e) {\n                if (e&1) r = r * a % MOD;\n                e /= 2, a = a * a % MOD;\n        }\n        return r;\n}\n\nint main () {\n        scanf(\"%d %d\", &N, &K);\n\n        ll x = (ll) N-K+1;\n\n        ans = x % MOD;\n        for (ll i = (ll) K; i < (ll) K + (K-2); i++) {\n                ans = ans * (x+i) % MOD;\n        }\n        for (ll i = 1ll; i < (ll) K; i++) ans = ans * inv(i) % MOD;\n\n        if (x > 2) {\n                for (ll i = 0; i < x-2; i++) ans = ans * 2 % MOD;\n        }\n\n        printf(\"%lld\\n\", ans);\n\n        return 0;\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::*;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok();\n    return ret;\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.is_err() || res.ok().unwrap() == 0 || u8b[0] <= ' ' as u8 {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = std::string::String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\nfn parse<T: std::str::FromStr>(s: &str) -> T { s.parse::<T>().ok().unwrap() }\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { parse(&get_word()) }\n\nconst MOD: i64 = 1_000_000_007;\n\nfn powmod(x: i64, mut e: i64, m: i64) -> i64 {\n    let mut sum = 1;\n    let mut cur = x % m;\n    while e > 0 {\n        if e % 2 != 0 {\n            sum = sum * cur % m;\n        }\n        cur = cur * cur % m;\n        e /= 2;\n    }\n    sum\n}\n\nfn make_dp_table(n: usize) -> Vec<Vec<i64>> {\n    let mut dp = vec![Vec::new(); n];\n    dp[0] = vec![0; 2 * n];\n    for i in 0 .. 2 * n {\n        dp[0][i] = 1;\n    }\n    for i in 1 .. n {\n        dp[i] = vec![0; 2 * n - i];\n        for j in 0 .. 2 * n - i {\n            dp[i][j] = (dp[i - 1][j + 1] + if j > 0 { dp[i][j - 1] } else { 0 })\n                % MOD;\n        }\n    }\n    dp\n}\n\nfn main() {\n    let n = get();\n    let k: usize = get::<usize>() - 1;\n    let mut tot: i64 = 0;\n    let dp = make_dp_table(n);\n    if k < n - 1 {\n        for m in n - k - 1 .. n {\n            let mut tmp = dp[n - m - 1][m + 1 + k - n];\n            for i in 0 .. n - k - 2 {\n                tmp = tmp * (m - 1 - i) as i64 % MOD;\n                tmp = tmp * powmod(i as i64 + 1, MOD - 2, MOD) % MOD; \n            }\n            tot += tmp;\n            tot %= MOD;\n        }\n    } else {\n        tot = dp[n - 1][0];\n    }\n    for _ in k + 2 .. n {\n        tot = tot * 2 % MOD;\n    }\n    println!(\"{}\", tot);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\nfn main() {\n    let (n, k): (usize, usize) = read();\n\n    let mut dp: Vec<Vec<Vec<i64>>> = vec![vec![vec![0; 2]; n+1]; n+1];\n    dp[n][0][0] = 1;\n    for i in (1..n+1).rev() {\n        for j in (0..n+1).rev() {\n            for k in 0..2 {\n                let base = dp[i][j][k];\n                if base == 0 {\n                    continue\n                }\n                if j >= 1 && k == 0 {\n                    dp[i][j-1][0] += base;\n                    dp[i][j-1][0] %= MOD;\n                }\n\n                dp[i-1][j][0] += base;\n                dp[i-1][j][0] %= MOD;\n\n                dp[i-1][j+1][1] += base;\n                dp[i-1][j+1][1] %= MOD;\n            }\n        }\n    }\n\n    let mut ans = (dp[1][n-k][0] + dp[1][n-k][1]) % MOD;\n    for x in 1..n-k {\n        ans *= 2;\n        ans %= MOD;\n    }\n    println!(\"{}\", ans);\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::*;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok();\n    return ret;\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.is_err() || res.ok().unwrap() == 0 || u8b[0] <= ' ' as u8 {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = std::string::String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\nfn parse<T: std::str::FromStr>(s: &str) -> T { s.parse::<T>().ok().unwrap() }\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { parse(&get_word()) }\n\nconst MOD: i64 = 1_000_000_007;\n\nfn powmod(x: i64, mut e: i64, m: i64) -> i64 {\n    let mut sum = 1;\n    let mut cur = x % m;\n    while e > 0 {\n        if e % 2 != 0 {\n            sum = sum * cur % m;\n        }\n        cur = cur * cur % m;\n        e /= 2;\n    }\n    sum\n}\n\nfn make_dp_table(n: usize) -> Vec<Vec<i64>> {\n    let mut dp = vec![vec![0; 2 * n]; n];\n    for i in 0 .. 2 * n {\n        dp[0][i] = 1;\n    }\n    for i in 1 .. n {\n        for j in 0 .. 2 * n - i {\n            dp[i][j] = (dp[i - 1][j + 1] + if j > 0 { dp[i][j - 1] } else { 0 })\n                % MOD;\n        }\n    }\n    dp\n}\n\nfn main() {\n    let n = get();\n    let k: usize = get::<usize>() - 1;\n    let mut tot: i64 = 0;\n    let dp = make_dp_table(n);\n    if k < n - 1 {\n        for m in n - k - 1 .. n {\n            let mut tmp = dp[n - m - 1][m + 1 + k - n];\n            for i in 0 .. n - k - 2 {\n                tmp = tmp * (m - 1 - i) as i64 % MOD;\n                tmp = tmp * powmod(i as i64 + 1, MOD - 2, MOD) % MOD; \n            }\n            tot += tmp;\n            tot %= MOD;\n        }\n    } else {\n        tot = dp[n - 1][0];\n    }\n    for _ in k + 2 .. n {\n        tot = tot * 2 % MOD;\n    }\n    println!(\"{}\", tot);\n}\n"
  }
]