[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  import scala.io.StdIn._\n  import scala.math\n  val Array(n, m, k) = readLine.trim.split(' ').map(_.toInt)\n  val oranges = List.tabulate(n){_ ⇒ readLine.trim.toInt}\n  implicit val memo: Array[Option[Long]] = Array.tabulate(n + 1){_ ⇒ None}\n  println(\n    dp(oranges, n, m, k)\n  )\n  def dp(oranges: List[Int], length:Int, m: Int, k: Int)(implicit memo: Array[Option[Long]]): Long = {\n    oranges match{\n      case Nil ⇒ 0\n      case h::t ⇒\n        memo(length) match{\n          case Some(v) ⇒ v\n          case None ⇒ dp(t, 1, h, h, m, k, length - 1).also(it ⇒ memo(length) = Some(it))\n        }\n    }\n\n  }\n  def dp(oranges: List[Int], count: Long, max: Int, min: Int, m: Int, k: Int, length: Int): Long = {\n    if (count == m) dp(oranges, length, m, k) + k + count * (max - min)\n    else {\n      oranges match {\n        case Nil ⇒ k + count * (max - min)\n        case h :: t if max < h ⇒ math.min(dp(oranges, length, m, k) + k + count * (max - min), dp(t, count + 1, h, min, m, k, length - 1))\n        case h :: t if min > h ⇒ math.min(dp(oranges, length, m, k) + k + count * (max - min), dp(t, count + 1, max, h, m, k, length - 1))\n        case _ :: t ⇒ math.min(dp(oranges, length, m, k) + k + count * (max - min), dp(t, count + 1, max, min, m, k, length - 1))\n      }\n    }\n  }\n  implicit class ScopeFunc[T](private val value: T) {\n    def let[A](func:T ⇒ A): A = func(value)\n    def also(func:T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 99999999999999\n\nint N,M;\nll K;\n\nll* table,*memo;\n\nll recursive(int index){\n\n\tif(index >= N)return 0;\n\n\tif(memo[index] != -1)return memo[index];\n\n\tll ret = NUM;\n\tll max_orange = -1,min_orange = NUM;\n\n\tfor(int i = 1; i <= M; i++){\n\t\tif(index + i > N)continue;\n\t\tmax_orange = max(max_orange,table[index+i-1]);\n\t\tmin_orange = min(min_orange,table[index+i-1]);\n\t\tret = min(ret,recursive(index+i)+i*(max_orange-min_orange)+K);\n\t}\n\n\treturn memo[index] = ret;\n\n}\n\n\nint main(){\n\tscanf(\"%d %d %lld\",&N,&M,&K);\n\ttable = new ll[N];\n\tmemo = new ll[N];\n\tfor(int i = 0; i < N; i++)memo[i] = -1;\n\n\tfor(int i = 0; i < N; i++)scanf(\"%lld\",&table[i]);\n\n\tprintf(\"%lld\\n\",recursive(0));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 20001\nconst int inf = 1e9;\n\nint mn[2][MAX], mx[2][MAX];\nint a[MAX], dp[2][MAX];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\tfill((int*)(mn+1), (int*)(mn+2), inf);\n\t\tfill((int*)(mx+1), (int*)(mx+2), 0);\n\t\tfill((int*)(dp+1), (int*)(dp+2), inf);\n\t\t/*for(int j = 0;j < 2;j++){\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tif(dp[j][k] == inf)printf(\"* \");\n\t\t\t\telse printf(\"%d \", dp[j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tif(dp[1][0] > sum){\n\t\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t\t\tdp[1][0] = sum;\n\t\t\t}\n\t\t}\n\t\tswap(mn[0], mn[1]);\n\t\tswap(mx[0], mx[1]);\n\t\tswap(dp[0], dp[1]);\n\t}\n\t\n\t/*printf(\"%d %d\\n\", mn[8][3], mx[8][3]);\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(dp[i][j] == inf)printf(\"%3c \", '*');\n\t\t\telse printf(\"%3d \", dp[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < n;i++){\n\t\tif(dp[1][i] == inf)continue;\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : AOJ.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\nusing namespace std;\n\nconst long long INF=10000000000000;\nint main() {\n\tlong long N,M;\n\tlong long K;\n\tlong long A[20001];\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\n\n\tlong long oldDP[1000]={};\n\tlong long DP[1000]={};\n\tlong long oldDmax[1000]={};\n\tlong long oldDmin[1000]={};\n\tlong long Dmax[1000]={};\n\tlong long Dmin[1000]={};\n\n\tDmax[1]=A[1];\n\tDmin[1]=A[1];\n\tDP[1]=0;\n\tfor(long long j=2;j<N+1;j++){\n\t\tfor(long long i=1;i<M+1;i++){\n\t\t\toldDP[i]=DP[i];\n\t\t\toldDmax[i]=Dmax[i];\n\t\t\toldDmin[i]=Dmin[i];\n\t\t}\n\t\tDP[1]=INF;\n\t\tDmax[1]=A[j];\n\t\tDmin[1]=A[j];\n\n\t\tfor(long long i=2;i<M+1;i++){\n\t\t\tDmax[i]=max(oldDmax[i-1],A[j]);\n\t\t\tDmin[i]=min(oldDmin[i-1],A[j]);\n\t\t\tDP[i]=oldDP[i-1];\n\t\t}\n\t\tfor(long long i=1;i<M+1;i++){\n\t\t\tDP[1]=min(DP[1],oldDP[i]+K+i*(oldDmax[i]-oldDmin[i]));\n\t\t}\n\t}\n\tlong long R=INF;\n\tfor(int i=1;i<M+1;i++){\n\t\tR=min(R,DP[i]+K+i*(Dmax[i]-Dmin[i]));\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n\nint dp[20020];\nint a[200020];\nsigned main(){\n\t\n\t\n   cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tfor(int i=0;i<=n;i++){\n\t\tcin>>a[i+1];\n\t\tdp[i]=inf*1000000ll;\n\t}\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint ma=-inf,mi=inf;\n\t\t\n\t\tfor(int j=i;j>i-m;j--){\n\t\t\tif(j==0) break;\n\t\t\tma=max(ma,a[j]);\n\t\t\tmi=min(mi,a[j]);\n\t\t\tdp[i]=min(dp[i],dp[j-1]+(ma-mi)*(i-j+1)+k);\n\t\t}\n\t}\n\tcout<<dp[n]<<endl;\n\treturn 0;\n\t\n\n \n }\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : AOJ.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\nusing namespace std;\n\nconst long long INF=100000000000000;\nint main() {\n\tlong long N,M;\n\tlong long K;\n\tlong long A[20001];\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\n\n\tlong long oldDP[1000]={};\n\tlong long DP[1000]={};\n\tlong long oldDmax[1000]={};\n\tlong long oldDmin[1000]={};\n\tlong long Dmax[1000]={};\n\tlong long Dmin[1000]={};\n\n\tDmax[1]=A[1];\n\tDmin[1]=A[1];\n\tDP[1]=0;\n\tfor(long long j=2;j<N+1;j++){\n\t\tfor(long long i=1;i<M+1;i++){\n\t\t\toldDP[i]=DP[i];\n\t\t\toldDmax[i]=Dmax[i];\n\t\t\toldDmin[i]=Dmin[i];\n\t\t}\n\t\tDP[1]=INF;\n\t\tDmax[1]=A[j];\n\t\tDmin[1]=A[j];\n\n\t\tfor(long long i=2;i<M+1;i++){\n\t\t\tDmax[i]=max(oldDmax[i-1],A[j]);\n\t\t\tDmin[i]=min(oldDmin[i-1],A[j]);\n\t\t\tDP[i]=oldDP[i-1];\n\t\t}\n\t\tfor(long long i=1;i<M+1;i++){\n\t\t\tDP[1]=min(DP[1],oldDP[i]+K+i*(oldDmax[i]-oldDmin[i]));\n\t\t}\n\t}\n\tlong long R=INF;\n\tfor(int i=1;i<M+1;i++){\n\t\tR=min(R,DP[i]+K+i*(Dmax[i]-Dmin[i]));\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<cassert>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int IINF = INT_MAX;\nconst char EMPTY = 'X';\n \nstruct Node{\n  int value;\n  /*\n    lazy : \n    A : ??????????????¶ ( ADD )\n    S : ?????????????´?????????????????????????????????¶ ( SET )\n\n    lazy_coef : \n    ????????????????????????????????????or???????????????????????????????¨????\n  */\n  char lazy;\n  int lazy_coef; \n  Node(int value=0,char lazy=EMPTY,int lazy_coef=0):value(value),lazy(lazy),lazy_coef(lazy_coef){}\n};\n \nclass SegmentTree{\npublic:\n  vector<Node> RMQ;\n  vector<int> minimum_dat,maximum_dat;\n  int limit,N; // N ???????´???°\n \n  void init(int tmp){\n    N = tmp;\n    int N_N = 1;\n    while(N_N < N)N_N *= 2;\n    limit = N_N;\n    RMQ.resize(3*limit);\n    minimum_dat.resize(3*limit);\n    maximum_dat.resize(3*limit);\n    rep(i,3*limit-1) {\n      RMQ[i] = Node();\n      minimum_dat[i] =  IINF;\n      maximum_dat[i] = -IINF;\n    }\n  }\n\n  /* \n     O(n)??§RMQ????????????\n     [L,R)\n     tuple<int,int,int>(?????????????°????????????§???)\n  */\n  tuple<int,int,int> _build(int cur,int L,int R,const vector<int> &buf){\n\n    if( !( 0 <= cur && cur < 2*limit-1 ) ) return tuple<int,int,int>(0,IINF,-IINF);\n    if( L == R-1 ){\n      if( L >= N ) return tuple<int,int,int>(0,IINF,-IINF);\n      //???????´??????????????????§????????´??? ( ??????????????????????????????????????§?????????????????´??? )\n      //buf[] ?????¨??????????????\\??? RMQ[cur].value = buf[L]; ??¨??????\n      // RMQ???L?????????????´????buf[L]??§??´??°\n      RMQ[cur].value = buf[L];\n      minimum_dat[cur] = buf[L];\n      maximum_dat[cur] = buf[L];\n      //???????´??????¨??????????????´???\n      //RMQ[cur] = 0; // RMQ ??????????´?????????§???????????? 1 ?????? RMQ[cur] = 1????????????...\n      //minimum_dat[cur] = 0;\n      //maximum_dat[cur] = 0;\n    } else {\n      tuple<int,int,int> vl = _build(cur*2+1,L,(L+R)/2,buf);\n      tuple<int,int,int> vr = _build(cur*2+2,(L+R)/2,R,buf);\n      RMQ[cur].value = get<0>(vl) + get<0>(vr);\n      minimum_dat[cur] = min(get<1>(vl),get<1>(vr));\n      maximum_dat[cur] = max(get<2>(vl),get<2>(vr));\n    }\n    return tuple<int,int,int>(RMQ[cur].value,minimum_dat[cur],maximum_dat[cur]);\n  }\n\n  //init?????????????????¨???????????¨!!! ??§????????¨limit?????£??????????????\\??£???????????????\n  void build(const vector<int> &buf) { _build(0,0,limit,buf); }\n\n  inline void value_evaluate(int index,int L,int R){\n    if( RMQ[index].lazy == 'A' ){\n      RMQ[index].value += ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] += RMQ[index].lazy_coef;\n      maximum_dat[index] += RMQ[index].lazy_coef;\n    } else if( RMQ[index].lazy == 'S' ){\n      RMQ[index].value = ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] = RMQ[index].lazy_coef;\n      maximum_dat[index] = RMQ[index].lazy_coef;\n    }\n  }\n   \n  inline void lazy_evaluate(int index,int L,int R){\n    value_evaluate(index,L,R);\n    if( index < limit && RMQ[index].lazy != EMPTY ) {\n      if( RMQ[index].lazy == 'A' ) {\n        if( RMQ[index*2+1].lazy == EMPTY ) RMQ[index*2+1].lazy = 'A'; \n        if( RMQ[index*2+2].lazy == EMPTY ) RMQ[index*2+2].lazy = 'A';\n        RMQ[index*2+1].lazy_coef += RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef += RMQ[index].lazy_coef;\n      } else if( RMQ[index].lazy == 'S') {\n        RMQ[index*2+1].lazy = RMQ[index*2+2].lazy = 'S';\n        RMQ[index*2+1].lazy_coef = RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef = RMQ[index].lazy_coef;\n      }\n    }\n    RMQ[index].lazy = EMPTY;\n    RMQ[index].lazy_coef = 0;\n  }\n \n  inline void value_update(int index){\n    RMQ[index].value = RMQ[index*2+1].value + RMQ[index*2+2].value;\n    minimum_dat[index] = min(minimum_dat[index*2+1],minimum_dat[index*2+2]);\n    maximum_dat[index] = max(maximum_dat[index*2+1],maximum_dat[index*2+2]);\n  }\n \n  /*\n  //[a,b)???????????????opr?????????\n  ??????????????¬??????[L,R)\n  [a,b)??????????´????????????????\n  opr ??? 'A'??????v????????? ( ADD )\n  opr ??? 'S'??????v????????? ( SET )\n  */\n  void _update(int a,int b,char opr,int v,int index,int L,int R){\n    /*\n      RMQ[index].lazy ???EMPTY??\\?????????????????????????????????????????§????????°\n      ???????????¶???????????????????????????\n    */\n    lazy_evaluate(index,L,R);\n \n    if( b <= L || R <= a )return;\n    if( a <= L && R <= b ){\n      /*\n        [L,R)???????????????????????\\??£????????§???????????§?????????????????? ( ???????????????????????´??°?????????????????´??°?????????, ????????£???????????¶?????????????????? )\n        [??????????????????]            [??????????????????]\n        [??????]  [??????]     => [??????,?????¶] [??????,?????¶]\n        ??????????????????????????????\n        ??????????????????????¨??????????????????¶????????????????????????\n      */\n      RMQ[index].lazy = opr; // ??????????????????????????¶????¨??????????????????????????????????\n      if( opr == 'A' )      RMQ[index].lazy_coef += v; \n      else if( opr == 'S' ) RMQ[index].lazy_coef = v; \n      lazy_evaluate(index,L,R);\n      return;\n    }\n \n    _update(a,b,opr,v,index*2+1,L,(L+R)/2);\n    _update(a,b,opr,v,index*2+2,(L+R)/2,R);\n    value_update(index);\n \n  }\n\n  // [a,b) ???????????? opr ?????????\n  void update(int a,int b,char opr,int v){ _update(a,b,opr,v,0,0,limit); } \n\n  tuple<int,int,int> _query(int a,int b,int index,int L,int R){\n    lazy_evaluate(index,L,R); //???????????????????????£??????????????\\??£????????????(?????¶????????????)????????§??????????????§??????????????£??????????????\\??????\n \n    if( b <= L || R <= a ) return make_tuple(0,IINF,-IINF);\n    if( a <= L && R <= b ) return make_tuple(RMQ[index].value,minimum_dat[index],maximum_dat[index]);\n\n\n    auto tmp1 = _query(a,b,index*2+1,L,(L+R)/2);\n    auto tmp2 = _query(a,b,index*2+2,(L+R)/2,R);\n    tuple<int,int,int> ret = make_tuple(get<0>(tmp1)+get<0>(tmp2),min(get<1>(tmp1),get<1>(tmp2)),max(get<2>(tmp1),get<2>(tmp2)));\n    value_update(index); //???????????§????????¨??????????????£???????????£??????????????§??????????????¨??£?????????????????????????????£?????????????????????\n    return ret;\n  }\n\n  // [a,b) ????????????????°????????????§????????????\n  tuple<int,int,int> query(int a,int b) { return _query(a,b,0,0,limit); }\n\n};\n\n\n\n#define MAX 20010\n\nll dp[MAX];\nint N,M;\nll K,A[MAX];\n\nvoid computer() {\n  SegmentTree rmq;\n  {\n    rmq.init(N);\n    vector<int> vec(N);\n    rep(i,N) vec[i] = A[i];\n    rmq.build(vec);\n  }\n  rep(i,N+1) dp[i] = LLONG_MAX;\n  rep(i,N) {\n    dp[i] = ((i-1>=0)?dp[i-1]:0) + K;\n    rep(j,i) {\n      if( i - j + 1 > M ) continue;\n      auto v = rmq.query(j,i+1);\n      ll maxi = get<2>(v);\n      ll mini = get<1>(v);\n      assert( maxi >= mini );\n      dp[i] = min(dp[i],((j-1>=0)?dp[j-1]:0)+K+(ll)(i-j+1) * ( maxi - mini ));\n    }\n  }\n  cout << dp[N-1] << endl;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  rep(i,N) cin >> A[i];\n  computer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m;\nlong long k,dp[20010],a[20010],x,y;\nint main(){\n\tcin>>n>>m>>k;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\tdp[i+1]=114514114514114514;\n\t}dp[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tx=a[i],y=a[i];\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tdp[i+j]=min(dp[i+j],dp[i]+k+j*(x-y));\n\t\t\tx=max(x,a[i+j]),y=min(y,a[i+j]);\n\t\t\tif(i+j==n)break;\n\t\t}\n\t}\n\tcout<<dp[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdint>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, s, t) for (int i = s; i < t; i++)\n#define ALL(obj) obj.begin(), obj.end()\n\nconst int iINF = 1e9;\nconst long long llINF = 1e18;\nconst int MOD = 1e9 + 7;\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate <int MOD>\nstruct ModInt {\n    long long val;\n    constexpr ModInt(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr ModInt operator-() const noexcept { return val ? MOD - val : 0; }\n    constexpr ModInt operator+(const ModInt& r) const noexcept { return ModInt(*this) += r; }\n    constexpr ModInt operator-(const ModInt& r) const noexcept { return ModInt(*this) -= r; }\n    constexpr ModInt operator*(const ModInt& r) const noexcept { return ModInt(*this) *= r; }\n    constexpr ModInt operator/(const ModInt& r) const noexcept { return ModInt(*this) /= r; }\n    constexpr ModInt& operator+=(const ModInt& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr ModInt& operator-=(const ModInt& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr ModInt& operator*=(const ModInt& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr ModInt& operator/=(const ModInt& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const ModInt& r) const noexcept { return this->val == r.val; }\n    constexpr bool operator!=(const ModInt& r) const noexcept { return this->val != r.val; }\n    friend constexpr ostream& operator<<(ostream& os, const ModInt<MOD>& x) noexcept { return os << x.val; }\n\n    friend constexpr istream& operator>>(istream& is, ModInt<MOD>& x) noexcept { return is >> x.val; }\n    friend constexpr ModInt<MOD> modpow(const ModInt<MOD>& a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\nusing mint = ModInt<MOD>;\n\nlong long modPow(long long x, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long extGCD(long long a, long long b, long long& x, long long& y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\nlong long gcd(long long a, long long b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\nlong long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\n\ntemplate <typename T>\nmap<T, int> compress(vector<T> x) {\n    map<T, int> res;\n    sort(x.begin(), x.end());\n    x.erase(unique(x.begin(), x.end()), x.end());\n    for (int i = 0; i < x.size(); i++) {\n        res[x[i]] = i;\n    }\n\n    return res;\n}\n\ntemplate <typename T>\nint former(const vector<T>& v, T x) {\n    return upper_bound(v.begin(), v.end(), x) - v.begin() - 1;\n}\n\ntemplate <typename T>\nint latter(const vector<T>& v, T x) {\n    return lower_bound(v.begin(), v.end(), x) - v.begin();\n}\n\ntemplate <typename T>\nusing Vec = vector<T>;\ntemplate <typename T>\nusing VVec = vector<vector<T>>;\nusing LL = long long;\n\nLL dp[20010];\nLL sum[20010][1010];\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    Vec<LL> A(N);\n    REP(i, N) { cin >> A[i]; }\n    REP(i, N + 1) dp[i] = llINF;\n    REP(i, N) {\n        LL mn = llINF, mx = -llINF;\n        FOR(j, 1, M + 1) {\n            chmin(mn, A[i + j - 1]);\n            chmax(mx, A[i + j - 1]);\n            sum[i][j] = K + j * (mx - mn);\n        }\n    }\n\n    dp[0] = 0;\n    REP(i, N) {\n        FOR(j, 1, M + 1) {\n            if (dp[i] == llINF) continue;\n            if (i + j <= N) chmin(dp[i + j], dp[i] + sum[i][j]);\n        }\n    }\n    cout << dp[N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 10000000000000000;\n\nll n, m, k, a[20001], dp[20001];\n\nint main() {\n  scanf(\"%lld%lld%lld\", &n, &m, &k);\n  for (ll i = 1; i <= n; i++) scanf(\"%lld\", &a[i]), dp[i] = INF;\n  dp[0] = 0;\n  for (ll i = 1; i <= n; i++) {\n    ll minN = a[i], maxN = a[i], counter = 1;\n    for (int j = i - 1; counter <= m; j--) {\n      dp[i] = min(dp[i], dp[j] + k + counter * (maxN - minN));\n      if (j == 0) break;\n      minN = min(minN, a[j]);\n      maxN = max(maxN, a[j]);\n      counter++;\n    }\n  }\n  printf(\"%lld\\n\", dp[n]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 10000000000000000\ntypedef long long LL;\nusing namespace std;\nLL N,M,K;\nLL ary[20010],dp[20010];\nint main(){\n\tcin>>N>>M>>K;\n\tfor(LL i=1;i<=N;i++){\n\t\tcin>>ary[i];\n\t}\n\tfill(dp,dp+N+1,INF);\n\tLL a,b;\n\tdp[0]=0;\n\tfor(LL i=0;i<N;i++){\n\t\ta=b=ary[i+1];\n\t\tfor(LL j=1;j<=M;j++){\n\t\t\ta=max(a,ary[i+j]);\n\t\t\tb=min(b,ary[i+j]);\n\t\t\tdp[i+j]=min(dp[i+j],dp[i]+K+j*(a-b));\n\t\t}\n\t}\n\tcout<<dp[N]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int IINF = INT_MAX;\nconst char EMPTY = 'X';\n \nstruct Node{\n  int value;\n  /*\n    lazy : \n    A : ??????????????¶ ( ADD )\n    S : ?????????????´?????????????????????????????????¶ ( SET )\n\n    lazy_coef : \n    ????????????????????????????????????or???????????????????????????????¨????\n  */\n  char lazy;\n  int lazy_coef; \n  Node(int value=0,char lazy=EMPTY,int lazy_coef=0):value(value),lazy(lazy),lazy_coef(lazy_coef){}\n};\n \nclass SegmentTree{\npublic:\n  vector<Node> RMQ;\n  vector<int> minimum_dat,maximum_dat;\n  int limit,N; // N ???????´???°\n \n  void init(int tmp){\n    N = tmp;\n    int N_N = 1;\n    while(N_N < N)N_N *= 2;\n    limit = N_N;\n    RMQ.resize(3*limit);\n    minimum_dat.resize(3*limit);\n    maximum_dat.resize(3*limit);\n    rep(i,3*limit-1) {\n      RMQ[i] = Node();\n      minimum_dat[i] =  IINF;\n      maximum_dat[i] = -IINF;\n    }\n  }\n\n  /* \n     O(n)??§RMQ????????????\n     [L,R)\n     tuple<int,int,int>(?????????????°????????????§???)\n  */\n  tuple<int,int,int> _build(int cur,int L,int R,const vector<int> &buf){\n\n    if( !( 0 <= cur && cur < 2*limit-1 ) ) return tuple<int,int,int>(0,IINF,-IINF);\n    if( L == R-1 ){\n      if( L >= N ) return tuple<int,int,int>(0,IINF,-IINF);\n      //???????´??????????????????§????????´??? ( ??????????????????????????????????????§?????????????????´??? )\n      //buf[] ?????¨??????????????\\??? RMQ[cur].value = buf[L]; ??¨??????\n      // RMQ???L?????????????´????buf[L]??§??´??°\n      RMQ[cur].value = buf[L];\n      minimum_dat[cur] = buf[L];\n      maximum_dat[cur] = buf[L];\n      //???????´??????¨??????????????´???\n      //RMQ[cur] = 0; // RMQ ??????????´?????????§???????????? 1 ?????? RMQ[cur] = 1????????????...\n      //minimum_dat[cur] = 0;\n      //maximum_dat[cur] = 0;\n    } else {\n      tuple<int,int,int> vl = _build(cur*2+1,L,(L+R)/2,buf);\n      tuple<int,int,int> vr = _build(cur*2+2,(L+R)/2,R,buf);\n      RMQ[cur].value = get<0>(vl) + get<0>(vr);\n      minimum_dat[cur] = min(get<1>(vl),get<1>(vr));\n      maximum_dat[cur] = max(get<2>(vl),get<2>(vr));\n    }\n    return tuple<int,int,int>(RMQ[cur].value,minimum_dat[cur],maximum_dat[cur]);\n  }\n\n  //init?????????????????¨???????????¨!!! ??§????????¨limit?????£??????????????\\??£???????????????\n  void build(const vector<int> &buf) { _build(0,0,limit,buf); }\n\n  inline void value_evaluate(int index,int L,int R){\n    if( RMQ[index].lazy == 'A' ){\n      RMQ[index].value += ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] += RMQ[index].lazy_coef;\n      maximum_dat[index] += RMQ[index].lazy_coef;\n    } else if( RMQ[index].lazy == 'S' ){\n      RMQ[index].value = ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] = RMQ[index].lazy_coef;\n      maximum_dat[index] = RMQ[index].lazy_coef;\n    }\n  }\n   \n  inline void lazy_evaluate(int index,int L,int R){\n    value_evaluate(index,L,R);\n    if( index < limit && RMQ[index].lazy != EMPTY ) {\n      if( RMQ[index].lazy == 'A' ) {\n        if( RMQ[index*2+1].lazy == EMPTY ) RMQ[index*2+1].lazy = 'A'; \n        if( RMQ[index*2+2].lazy == EMPTY ) RMQ[index*2+2].lazy = 'A';\n        RMQ[index*2+1].lazy_coef += RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef += RMQ[index].lazy_coef;\n      } else if( RMQ[index].lazy == 'S') {\n        RMQ[index*2+1].lazy = RMQ[index*2+2].lazy = 'S';\n        RMQ[index*2+1].lazy_coef = RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef = RMQ[index].lazy_coef;\n      }\n    }\n    RMQ[index].lazy = EMPTY;\n    RMQ[index].lazy_coef = 0;\n  }\n \n  inline void value_update(int index){\n    RMQ[index].value = RMQ[index*2+1].value + RMQ[index*2+2].value;\n    minimum_dat[index] = min(minimum_dat[index*2+1],minimum_dat[index*2+2]);\n    maximum_dat[index] = max(maximum_dat[index*2+1],maximum_dat[index*2+2]);\n  }\n \n  /*\n  //[a,b)???????????????opr?????????\n  ??????????????¬??????[L,R)\n  [a,b)??????????´????????????????\n  opr ??? 'A'??????v????????? ( ADD )\n  opr ??? 'S'??????v????????? ( SET )\n  */\n  void _update(int a,int b,char opr,int v,int index,int L,int R){\n    /*\n      RMQ[index].lazy ???EMPTY??\\?????????????????????????????????????????§????????°\n      ???????????¶???????????????????????????\n    */\n    lazy_evaluate(index,L,R);\n \n    if( b <= L || R <= a )return;\n    if( a <= L && R <= b ){\n      /*\n        [L,R)???????????????????????\\??£????????§???????????§?????????????????? ( ???????????????????????´??°?????????????????´??°?????????, ????????£???????????¶?????????????????? )\n        [??????????????????]            [??????????????????]\n        [??????]  [??????]     => [??????,?????¶] [??????,?????¶]\n        ??????????????????????????????\n        ??????????????????????¨??????????????????¶????????????????????????\n      */\n      RMQ[index].lazy = opr; // ??????????????????????????¶????¨??????????????????????????????????\n      if( opr == 'A' )      RMQ[index].lazy_coef += v; \n      else if( opr == 'S' ) RMQ[index].lazy_coef = v; \n      lazy_evaluate(index,L,R);\n      return;\n    }\n \n    _update(a,b,opr,v,index*2+1,L,(L+R)/2);\n    _update(a,b,opr,v,index*2+2,(L+R)/2,R);\n    value_update(index);\n \n  }\n\n  // [a,b) ???????????? opr ?????????\n  void update(int a,int b,char opr,int v){ _update(a,b,opr,v,0,0,limit); } \n\n  tuple<int,int,int> _query(int a,int b,int index,int L,int R){\n    lazy_evaluate(index,L,R); //???????????????????????£??????????????\\??£????????????(?????¶????????????)????????§??????????????§??????????????£??????????????\\??????\n \n    if( b <= L || R <= a ) return make_tuple(0,IINF,-IINF);\n    if( a <= L && R <= b ) return make_tuple(RMQ[index].value,minimum_dat[index],maximum_dat[index]);\n\n\n    auto tmp1 = _query(a,b,index*2+1,L,(L+R)/2);\n    auto tmp2 = _query(a,b,index*2+2,(L+R)/2,R);\n    tuple<int,int,int> ret = make_tuple(get<0>(tmp1)+get<0>(tmp2),min(get<1>(tmp1),get<1>(tmp2)),max(get<2>(tmp1),get<2>(tmp2)));\n    value_update(index); //???????????§????????¨??????????????£???????????£??????????????§??????????????¨??£?????????????????????????????£?????????????????????\n    return ret;\n  }\n\n  // [a,b) ????????????????°????????????§????????????\n  tuple<int,int,int> query(int a,int b) { return _query(a,b,0,0,limit); }\n\n};\n\n\n\n#define MAX 20010\n\nll dp[MAX];\nint N,M;\nll K,A[MAX];\n\nvoid computer() {\n  SegmentTree rmq;\n  {\n    rmq.init(N);\n    vector<int> vec(N);\n    rep(i,N) vec[i] = A[i];\n    rmq.build(vec);\n  }\n  rep(i,N+1) dp[i] = LLONG_MAX;\n  rep(i,N) {\n    dp[i] = ((i-1>=0)?dp[i-1]:0) + K;\n    rep(j,i) {\n      if( i - j + 1 > M ) continue;\n      auto v = rmq.query(j,i+1);\n      ll maxi = get<2>(v);\n      ll mini = get<1>(v);\n      assert( maxi >= mini );\n      dp[i] = min(dp[i],((j-1>=0)?dp[j-1]:0)+K+(ll)(i-j+1) * ( maxi - mini ));\n    }\n  }\n  cout << dp[N-1] << endl;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  rep(i,N) cin >> A[i];\n  computer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\ntemplate<typename T>\nvoid chmin(T &a, T b) {\n    a = min(a, b);\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int N, M;\n    ll K;\n    cin >> N >> M >> K;\n    vector<ll> A(N);\n    REP(i, 0, N) {\n        cin >> A[i];\n    }\n    auto dp = make_v(2, M + 1, 1LL << 50);\n    vector<ll> Min(M + 1, 1LL << 50), Max(M + 1, 0);\n    dp[0][0] = 0;\n    REP(i, 0, N + 1) {\n        dp[(i + 1) % 2] = vector<ll>(M + 1, 1LL << 50);\n        REP(j, 0, M + 1) {\n            if (i - j < 0) continue;\n            ll cost = (Max[j] - Min[j]);\n            chmin(dp[i % 2][0], dp[i % 2][j] + K + j * cost);\n        }\n        if (i != N) {\n            for (int j = M - 1; j >= 0; j--) {\n                Min[j + 1] = min(Min[j], A[i]);\n                Max[j + 1] = max(Max[j], A[i]);\n            }\n        }\n        REP(j, 0, M + 1) {\n            if (i != N && j - 1 >= 0) {\n                chmin(dp[(i + 1) % 2][j], dp[i % 2][j - 1]);\n            }\n        }\n    }\n    /*\n    REP (i, 0, N + 1) {\n        REP (j, 0, M + 1) {\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    //*/\n    cout << dp[N % 2][0] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing  ll =          long long int;\nusing ull = unsigned long long int;\nconst char en ='\\n';\nconst int  mod=1000000007;\n\nint n,m,k;\nvector<int> orangees,memo;\n\n\nint dfs(int index){\n\tif(index<0) return 0;\n\tif(memo[index]!=INT_MIN) return memo[index];\n\n\tint MIN=INT_MAX,MAX=INT_MIN;\n\tint start=max(index-m,0);\n\tfor(int i=index;i>=start;--i){\n\t\tMIN=min(MIN,orangees[i]);\n\t\tMAX=max(MAX,orangees[i]);\n\t\tmemo[index]=min(memo[index],dfs(i-1)+k+(index-i+1)*(MAX-MIN));\n\t}\n\treturn 0;\n}\nint main(){\n\tcin.tie();\n\tios::sync_with_stdio(false);\n\n\tcin>>n>>m>>k;\n\torangees=vector<int>(n);\n\tmemo    =vector<int>(n);\n\tfor(auto& i:orangees) cin>>i;\n\tfill_n(memo.begin(),n,INT_MIN);\n\n\tcout<<dfs(n-1)<<en;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\ntypedef long long ll;\n\nconst ll inf = (ll)1e+17 + 7;\n\nint n, m;\nll k;\nll a[20001];\nll dp[20001];\n\nint main(){\n\tstd::cin >> n >> m >> k;\n\tfor(int i = 0; i < n; ++i)std::cin >> a[i];\n\t\n\tfor(int i = 0; i < 20001; ++i){\n\t\tdp[i] = inf;\n\t}\n\t\n\tdp[0] = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tll small = inf, large = -inf;\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tif(i + j + 1 > n)continue;\n\t\t\t\n\t\t\tsmall = std::min(small, a[i + j]);\n\t\t\tlarge = std::max(large, a[i + j]);\n\t\t\t\n\t\t\tdp[i + j + 1] = std::min(dp[i + j + 1], dp[i] + k + (j + 1) * (large - small));\n\t\t}\n\t}\n\t\n\tstd::cout << dp[n] << std::endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nstruct P {\n\tlong long ma, mi;\n};\nll dp[20001], n, m, k, a[20000],s,f;\nP c[20000];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 9000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=90000000000;\n\t\tfor (ll y = i; y < i + x; ) {\n\t\t\tif (y % s == 0 && y + s < i + x&&y/s<f) {\n\t\t\t\tma = max(c[(y / s)].ma, ma);\n\t\t\t\tmi = min(c[y / s].mi, mi);\n\t\t\t\ty += s;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tma = max(ma, a[y]);\n\t\t\t\tmi = min(mi, a[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\ts = floor(sqrt(n));\n\t\tf = 0;\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tfor (ll i = 0; i < floor(i / s); i++) {\n\t\t\tll ma = -1, mi = 900000000000000;\n\t\t\tfor (ll j = i * s; j < (i + 1) * s; j++) {\n\t\t\t\tma = max(ma, a[j]);\n\t\t\t\tmi = min(mi, a[j]);\n\t\t\t}\n\t\t\tf++;\n\t\t\tc[i].ma = ma;\n\t\t\tc[i].mi = mi;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nconstexpr ll INF = 1LL<<60;\n\nvoid chmin(ll &a, ll b){\n    a = min(a,b);\n}\nvoid chmax(ll &a, ll b){\n    a = max(a,b);\n}\n\nbool solve(){\n    ll n, m, k;\n    cin >> n >> m >> k;\n    vector<ll> a(n), dp(n+1,INF);\n    for(int i=0;i<n;i++){\n        cin >> a[i];\n    }\n    dp[0] = 0;\n    for(int i=0;i<n;i++){\n        ll mi = INF, ma = 0;\n        for(int j=i+1;j<=min(n,i+m);j++){\n            chmin(mi, a[j-1]);\n            chmax(ma, a[j-1]);\n            chmin(dp[j], dp[i]+k+(ma-mi)*(j-i));\n        }\n    }\n    cout << dp[n] << endl;\n    return true;\n}\n\nint main(){\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll > P;\n\nll N, M, K;\nll ookisa[20000];\nll dp[20000][1001];\n\nP get(int a,int b) {\n\tP res;\n\tres.first = *max_element(ookisa + a, ookisa + b + 1);\n\tres.second = *min_element(ookisa + a, ookisa + b + 1);\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < N; i++)cin >> ookisa[i];\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < M; j++)dp[i][j] = 1145141919810893;\n\n\tdp[0][M - 1] = K;\n\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tP minmax = get(i - (M - j - 1),i + 1);\n\t\t\tif(j != 0)dp[i + 1][j - 1] = min(dp[i + 1][j - 1],\n\t\t\t\tdp[i - (M - j - 1)][M - 1] + (M - j + 1) * (minmax.first - minmax.second));\n\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t}\n\t}\n\n\tll ans = 1145141919810893;\n\n\tfor (int i = 0; i < M; i++)ans = min(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll > P;\n\nll N, M, K;\nll ookisa[20000];\nll dp[20000][1001];\n\nP get(int a,int b) {\n\tP res;\n\tres.first = *max_element(ookisa + a, ookisa + b + 1);\n\tres.second = *min_element(ookisa + a, ookisa + b + 1);\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < N; i++)cin >> ookisa[i];\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < M; j++)dp[i][j] = 1145141919810893;\n\n\tdp[0][M - 1] = K;\n\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP minmax = get(i - (M - j - 1), i + 1);\n\t\t\t\tdp[i + 1][j - 1] = min(dp[i + 1][j - 1],\n\t\t\t\t\tdp[i - (M - j - 1)][M - 1] + (M - j + 1) * (minmax.first - minmax.second));\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 1145141919810893;\n\n\tfor (int i = 0; i < M; i++)ans = min(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nstruct P {\n\tlong long ma, mi;\n};\nll dp[20001], n, m, k, a[20000],f;\nP c[200], d[20000];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 9000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=90000000000;\n\t\tfor (ll y = i; y < i + x; ) {\n\t\t\tif (y % 100 == 0&&y+100<i+x) {\n\t\t\t\tma = max(c[(y / 100)].ma, ma);\n\t\t\t\tmi = min(c[y / 100].mi, mi);\n\t\t\t\ty += 100;\n\t\t\t}\n\t\t\telse if (y % 50 == 0 && y + 50 < i + x&&y/50<f) {\n\t\t\t\tma = max(d[(y / 50)].ma, ma);\n\t\t\t\tmi = min(d[y / 50].mi, mi);\n\t\t\t\ty += 50;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tma = max(ma, a[y]);\n\t\t\t\tmi = min(mi, a[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tf = 0;\n\t\tfor (ll i = 0; i < floor(i / 100); i++) {\n\t\t\tll ma = -1, mi = 900000000000000,ma2=ma,mi2=mi;\n\t\t\tfor (ll j = i * 100; j < (i + 1) * 100; j++) {\n\t\t\t\tma = max(ma, a[j]);\n\t\t\t\tmi = min(mi, a[j]);\n\t\t\t\tif (j == i+50) {\n\t\t\t\t\td[i * 2].ma = ma;\n\t\t\t\t\td[i * 2].mi - mi;\n\t\t\t\t\tma2 = -1;\n\t\t\t\t\tmi2 = 900000000000000;\n\t\t\t\t}\n\t\t\t\tma2 = max(ma2, a[j]);\n\t\t\t\tmi2 = min(mi2, a[j]);\n\t\t\t\tf++;\n\t\t\t}\n\t\t\tc[i].ma = ma;\n\t\t\tc[i].mi = mi;\n\t\t\td[i * 2 + 1].ma = ma2;\n\t\t\td[i * 2 + 1].mi = mi2;\n\t\t\tf++;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst ll INF=123456789012345LL;\n\nint main()\n{\n    int n,m;\n    ll k;\n    cin >>n >>m >>k;\n    vector<ll> a(n);\n    rep(i,n) cin >>a[i];\n\n    ll dp[20001];\n    fill(dp,dp+n+1,INF);\n    dp[0]=0;\n\n    //?§????i\n    rep(i,n)\n    {\n        ll x=0, y=1234567890LL;\n        //??????j\n        for(int j=i; j<min(n,i+m); ++j)\n        {\n            x=max(x,a[j]);\n            y=min(y,a[j]);\n            int s=j-i+1;\n\n            dp[j+1]=min(dp[j+1],dp[i]+k+s*(x-y));\n        }\n    }\n\n    cout << dp[n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nstruct P {\n\tlong long ma, mi;\n};\nll dp[20001], n, m, k, a[20000];\nP c[200], d[20000];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 9000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=90000000000;\n\t\tfor (ll y = i; y < i + x; ) {\n\t\t\tif (y % 100 == 0&&y+100<i+x) {\n\t\t\t\tma = max(c[(y / 100)].ma, ma);\n\t\t\t\tmi = min(c[y / 100].mi, mi);\n\t\t\t\ty += 100;\n\t\t\t}\n\t\t\telse if (y % 50 == 0 && y + 50 < i + x) {\n\t\t\t\tma = max(d[(y / 50)].ma, ma);\n\t\t\t\tmi = min(d[y / 50].mi, mi);\n\t\t\t\ty += 50;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tma = max(ma, a[y]);\n\t\t\t\tmi = min(mi, a[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tfor (ll i = 0; i < floor(i / 100); i++) {\n\t\t\tll ma = -1, mi = 900000000000000,ma2=ma,mi2=mi;\n\t\t\tfor (ll j = i * 100; j < (i + 1) * 100; j++) {\n\t\t\t\tma = max(ma, a[j]);\n\t\t\t\tmi = min(mi, a[j]);\n\t\t\t\tif (j % 50 == 0) {\n\t\t\t\t\td[i * 2].ma = ma;\n\t\t\t\t\td[i * 2].mi - mi;\n\t\t\t\t\tma2 = -1;\n\t\t\t\t\tmi2 = 900000000000000;\n\t\t\t\t}\n\t\t\t\tma2 = max(ma2, a[j]);\n\t\t\t\tmi2 = min(mi2, a[j]);\n\t\t\t}\n\t\t\tc[i].ma = ma;\n\t\t\tc[i].mi = mi;\n\t\t\td[i * 2 + 1].ma = ma2;\n\t\t\td[i * 2 + 1].mi = mi2;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\ntemplate<C T>void pr(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  ll n,m,k;\n  cin >> n >> m >> k;\n  ll a[n];\n  rep(i,n) R a[i];\n  ll dp[n+1];\n  fill(dp,dp+n+1,MAXL);\n  dp[0]=0;\n  rep(i,n) {\n    ll mx=0,mi=MAXL;\n    rep(j,m) {\n      if(i+j>=n) break;\n      mx=max(mx,a[i+j]);\n      mi=min(mi,a[i+j]);\n      dp[i+j+1]=min(dp[i+j+1],dp[i]+k+(mx-mi)*(j+1));\n    }\n  }\n  pr(dp[n]);\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 10000000000000000;\nint main(){\n\tint n,m,k;\n\tll a[20000],dp[20001];\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i=0;i<n;i++) scanf(\"%lld\",a+i);\n\tfor(int i=0;i<=n;i++){\n\t\tif(i==0){\n\t\t\tdp[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tdp[i] = INF;\n\t\tll mi = a[i-1], ma = a[i-1];\n\t\tfor(int j=i-1;i-j<=m&&j>=0;j--){\n\t\t\tmi = min(mi,a[j]);\n\t\t\tma = max(ma,a[j]);\n\t\t\tdp[i] = min(dp[i],dp[j]+k+(ma-mi)*(i-j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconstexpr int MAX_N=20001,MAX_M=1001;\nconstexpr long long int INF=(long long int)1e18;\n\nint n,m,k;\nlong long int dp[MAX_N];\nlong long int a[MAX_N];\n\nint main(){\n\tstd::cin>>n>>m>>k;\n\tfor(int i=1;i<=n;++i)\n\t\tstd::cin>>a[i];\n\tstd::fill(dp+1,dp+n+1,INF);\n\tlong long int max,min;\n\tfor(int i=1;i<=n;++i){\n\t\tmax=0;\n\t\tmin=INF;\n\t\tfor(int j=1;j<=m&&j<=i;++j){\n\t\t\tmax=std::max(max,a[i-j+1]);\n\t\t\tmin=std::min(min,a[i-j+1]);\n\t\t\tdp[i]=std::min(dp[i],dp[i-j]+(max-min)*j+k);\n\t\t}\n\t}\n\tstd::cout<<dp[n]<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nstruct P {\n\tlong long ma, mi;\n};\nll dp[20001], n, m, k, a[20000],s;\nP c[20000];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 9000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=90000000000;\n\t\tfor (ll y = i; y < i + x; ) {\n\t\t\tif (y % s == 0&&y+s<i+x) {\n\t\t\t\tma = max(c[(y / s)].ma, ma);\n\t\t\t\tmi = min(c[y / s].mi, mi);\n\t\t\t\ty += s;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tma = max(ma, a[y]);\n\t\t\t\tmi = min(mi, a[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\ts = floor(sqrt(n));\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tfor (ll i = 0; i < floor(i / s); i++) {\n\t\t\tll ma = -1, mi = 900000000000000;\n\t\t\tfor (ll j = i * s; j < (i + 1) * s; j++) {\n\t\t\t\tma = max(ma, a[j]);\n\t\t\t\tmi = min(mi, a[j]);\n\t\t\t}\n\t\t\tc[i].ma = ma;\n\t\t\tc[i].mi = mi;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint main() {\n\tlong long n, m, k;\n\tcin >> n >> m >> k;\n\tvector<long long> mi(m + 1, 1000*1000*1000+1);\n\tvector<long long> ma(m + 1, 0);\n\tvector<long long> dp(n + 1, k*n);\n\tdp[0] = 0;\n\tfor (long long i = 1; i <= n; i++) {\n\t\tlong long a; cin >> a;\n\t\tfor (long long j = min(m, i); j > 0; j--) {\n\t\t\tmi[j] = min(mi[j - 1], a);\n\t\t\tma[j] = max(ma[j - 1], a);\n\t\t\tdp[i] = min(dp[i], dp[i - j] + k+j * (ma[j] - mi[j]));\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2016-ho-t1.cpp\n *\n *  Created on: 2017/02/09\n *      Author: joi\n */\n\n#include<cstdio>\nint main(void){\n\tlong long dp[1001];\n\tlong long dpb[1001];\n\tlong long dpmin[1001];\n\tlong long dpmax[1000];\nlong long n;\nlong long m;\nlong long min;\n\tlong long a[20000];\n\tlong long k=0;\n\tlong long x=0;\n\tlong long y=0;\n\tscanf(\"%lld %lld %lld\",&n,&m,&k);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t}\nfor(int i=0;i<m;i++){\n\tdp[i]=0;\n\tdpb[i]=0;\n\tdpmax[i]=0;\n\tdpmin[i]=0;\n}\nfor(int i=0;i<n;i++){\n\tx=a[i];\nif(i<m-1)y=i;\nelse y=m-1;\n\tfor(int j=y;j>0;j--){\n\t\tdpb[j]=dp[j];\n\tif(dpmax[j-1]<x){\n\t\tdp[j]=((x-dpmin[j-1])*(j+1))-((dpmax[j-1]-dpmin[j-1])*(j))+dp[j-1];\n\t\tdpmax[j]=x;\n\t\tdpmin[j]=dpmin[j-1];\n\t}\n\telse if(dpmin[j-1]>x){\n\t\tdp[j]=((dpmax[j-1]-x)*(j+1))-((dpmax[j-1]-dpmin[j-1])*(j))+dp[j-1];\n\t\tdpmax[j]=dpmax[j-1];\n\t\tdpmin[j]=x;\n\t}\n\telse{\n\t\tdp[j]=dpmax[j-1]-dpmin[j-1]+dp[j-1];\n\t\tdpmax[j]=dpmax[j-1];\n\t\tdpmin[j]=dpmin[j-1];\n}\n\t}\n\tif(i==0){\n\t\tdp[i]=k;\n\t\tdpmax[i]=x;\n\t\tdpmin[i]=x;\n\t}\n\telse{\n\tdpb[0]=dp[0];\n\tmin=100000000000000000;\n\tfor(int j=0;j<m&&j<i;j++){\n\t\tif(min>dpb[j]){\nmin=dpb[j];\n\t\t}\n\t}\n\t\tdp[0]=min+k;\n\t\tdpmax[0]=x;\n\t\tdpmin[0]=x;\n\t}\n}\nmin=100000000000000000;\nfor(int i=0;i<m&&i<n;i++){\n\tif(min>dp[i])min=dp[i];\n}\nprintf(\"%lld\\n\",min);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nint main()\n{\n  int N, M, K, A[20000];\n  int64 dp[20001];\n  \n  scanf(\"%d %d %d\", &N, &M, &K);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &A[i]);\n  }\n\n  fill_n(dp, 20001, INF);\n  dp[0] = 0;\n  for(int i = 0; i < N; i++) {\n    int small = A[i], large = A[i];\n    for(int j = 0; j < min(M, N - i); j++) {\n      small = min(small, A[i + j]);\n      large = max(large, A[i + j]);\n      dp[i + j + 1] = min(dp[i + j + 1], dp[i] + K + (j + 1) * (large - small));\n    }\n  }\n  cout << dp[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define int long long\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint n, m, k;\nint a[20000 + 5];\nint dp[20000 + 5];\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m >> k;\n    rep(i, n) cin >> a[i];\n    fill(dp, dp + n + 1, LLONG_MAX);\n    dp[0] = 0;\n    rep(i, n){\n        int mx = 0;\n        int mn = 1e9+5;\n        rep(s, m) {\n            if (i - s < 0) break;\n            mx = max(mx, a[i - s]);\n            mn = min(mn, a[i - s]);\n            dp[i+1] = min(dp[i + 1], dp[i - s] + k + (s + 1) * (mx - mn));\n        }\n    }\n    cout << dp[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll a[20000], shou[80000], dai[80000], dp[20000], n, m, k2;\nconst ll inf = 99999999999999999;\nint start, ruend;\nvoid update(int i, ll x) {\n\tshou[i] = x;\n\tdai[i] = x;\n\twhile (i > 0) {\n\t\ti = floor((i - 1) / 2.0);\n\t\tshou[i] = min(shou[i * 2 + 1], shou[i * 2 + 2]);\n\t\tdai[i] = max(dai[i * 2 + 1], dai[i * 2 + 2]);\n\t}\n}\nll shouquery(int a, int b, int k, int l, int r) {\n\t//a??????b???????°????//k???l??\\???r??\\????????????\n\tif (b<l || a>r) return inf;\n\tif (l >= a&&r <= b) return shou[k];\n\telse {\n\t\tll vl = shouquery(a, b, k * 2 + 1, l, floor((l + r) / 2.0));\n\t\tll vr = shouquery(a, b, k * 2 + 2, ceil((l + r) / 2.0), r);\n\t\treturn min(vl, vr);\n\t}\n}\nll daiquery(int a, int b, int k, int l, int r) {\n\t//a??????b???????°????//k???l??\\???r??\\????????????\n\tif (b<l || a>r) return -1;\n\tif (l >= a&&r <= b) return dai[k];\n\telse {\n\t\tll vl = daiquery(a, b, k * 2 + 1, l, floor((l + r) / 2.0));\n\t\tll vr = daiquery(a, b, k * 2 + 2, ceil((l + r) / 2.0), r);\n\t\treturn max(vl, vr);\n\t}\n}\nll solve(int i) {\n\tif (i == n) return 0;\n\tll sum = inf;\n\tfor (int j = 1; j <= m&&i + j <= n; j++) {\n\t\tll res = k2 + j*(daiquery(start + i, start + i + j - 1, 0, start, ruend) - shouquery(start + i, start + i + j - 1, 0, start, ruend));\n\t\tif (dp[i + j] != -1) sum = min(sum, res + dp[i + j]);\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i+j]=solve(i + j)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tcin >> n >> m >> k2;\n\tfor (ll i = 0; i < n * 4; i++) {\n\t\tshou[i] = inf;\n\t\tdai[i] = -1;\n\t}\n\tll io = 0, iop = 1;\n\twhile (iop < n) {\n\t\tio += iop;\n\t\tiop *= 2;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tdp[i] = -1;\n\t\tupdate(io + i, a[i]);\n\t}\n\tstart = io;\n\truend = io + iop - 1;\n\tcout << solve(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int IINF = INT_MAX;\nconst char EMPTY = 'X';\n \nstruct Node{\n  int value;\n  /*\n    lazy : \n    A : ??????????????¶ ( ADD )\n    S : ?????????????´?????????????????????????????????¶ ( SET )\n\n    lazy_coef : \n    ????????????????????????????????????or???????????????????????????????¨????\n  */\n  char lazy;\n  int lazy_coef; \n  Node(int value=0,char lazy=EMPTY,int lazy_coef=0):value(value),lazy(lazy),lazy_coef(lazy_coef){}\n};\n \nclass SegmentTree{\npublic:\n  vector<Node> RMQ;\n  vector<int> minimum_dat,maximum_dat;\n  int limit,N; // N ???????´???°\n \n  void init(int tmp){\n    N = tmp;\n    int N_N = 1;\n    while(N_N < N)N_N *= 2;\n    limit = N_N;\n    RMQ.resize(3*limit);\n    minimum_dat.resize(3*limit);\n    maximum_dat.resize(3*limit);\n    rep(i,3*limit-1) {\n      RMQ[i] = Node();\n      minimum_dat[i] =  IINF;\n      maximum_dat[i] = -IINF;\n    }\n  }\n\n  /* \n     O(n)??§RMQ????????????\n     [L,R)\n     tuple<int,int,int>(?????????????°????????????§???)\n  */\n  tuple<int,int,int> _build(int cur,int L,int R,const vector<int> &buf){\n\n    if( !( 0 <= cur && cur < 2*limit-1 ) ) return tuple<int,int,int>(0,IINF,-IINF);\n    if( L == R-1 ){\n      if( L >= N ) return tuple<int,int,int>(0,IINF,-IINF);\n      //???????´??????????????????§????????´??? ( ??????????????????????????????????????§?????????????????´??? )\n      //buf[] ?????¨??????????????\\??? RMQ[cur].value = buf[L]; ??¨??????\n      // RMQ???L?????????????´????buf[L]??§??´??°\n      RMQ[cur].value = buf[L];\n      minimum_dat[cur] = buf[L];\n      maximum_dat[cur] = buf[L];\n      //???????´??????¨??????????????´???\n      //RMQ[cur] = 0; // RMQ ??????????´?????????§???????????? 1 ?????? RMQ[cur] = 1????????????...\n      //minimum_dat[cur] = 0;\n      //maximum_dat[cur] = 0;\n    } else {\n      tuple<int,int,int> vl = _build(cur*2+1,L,(L+R)/2,buf);\n      tuple<int,int,int> vr = _build(cur*2+2,(L+R)/2,R,buf);\n      RMQ[cur].value = get<0>(vl) + get<0>(vr);\n      minimum_dat[cur] = min(get<1>(vl),get<1>(vr));\n      maximum_dat[cur] = max(get<2>(vl),get<2>(vr));\n    }\n    return tuple<int,int,int>(RMQ[cur].value,minimum_dat[cur],maximum_dat[cur]);\n  }\n\n  //init?????????????????¨???????????¨!!! ??§????????¨limit?????£??????????????\\??£???????????????\n  void build(const vector<int> &buf) { _build(0,0,limit,buf); }\n\n  inline void value_evaluate(int index,int L,int R){\n    if( RMQ[index].lazy == 'A' ){\n      RMQ[index].value += ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] += RMQ[index].lazy_coef;\n      maximum_dat[index] += RMQ[index].lazy_coef;\n    } else if( RMQ[index].lazy == 'S' ){\n      RMQ[index].value = ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] = RMQ[index].lazy_coef;\n      maximum_dat[index] = RMQ[index].lazy_coef;\n    }\n  }\n   \n  inline void lazy_evaluate(int index,int L,int R){\n    value_evaluate(index,L,R);\n    if( index < limit && RMQ[index].lazy != EMPTY ) {\n      if( RMQ[index].lazy == 'A' ) {\n        if( RMQ[index*2+1].lazy == EMPTY ) RMQ[index*2+1].lazy = 'A'; \n        if( RMQ[index*2+2].lazy == EMPTY ) RMQ[index*2+2].lazy = 'A';\n        RMQ[index*2+1].lazy_coef += RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef += RMQ[index].lazy_coef;\n      } else if( RMQ[index].lazy == 'S') {\n        RMQ[index*2+1].lazy = RMQ[index*2+2].lazy = 'S';\n        RMQ[index*2+1].lazy_coef = RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef = RMQ[index].lazy_coef;\n      }\n    }\n    RMQ[index].lazy = EMPTY;\n    RMQ[index].lazy_coef = 0;\n  }\n \n  inline void value_update(int index){\n    RMQ[index].value = RMQ[index*2+1].value + RMQ[index*2+2].value;\n    minimum_dat[index] = min(minimum_dat[index*2+1],minimum_dat[index*2+2]);\n    maximum_dat[index] = max(maximum_dat[index*2+1],maximum_dat[index*2+2]);\n  }\n \n  /*\n  //[a,b)???????????????opr?????????\n  ??????????????¬??????[L,R)\n  [a,b)??????????´????????????????\n  opr ??? 'A'??????v????????? ( ADD )\n  opr ??? 'S'??????v????????? ( SET )\n  */\n  void _update(int a,int b,char opr,int v,int index,int L,int R){\n    /*\n      RMQ[index].lazy ???EMPTY??\\?????????????????????????????????????????§????????°\n      ???????????¶???????????????????????????\n    */\n    lazy_evaluate(index,L,R);\n \n    if( b <= L || R <= a )return;\n    if( a <= L && R <= b ){\n      /*\n        [L,R)???????????????????????\\??£????????§???????????§?????????????????? ( ???????????????????????´??°?????????????????´??°?????????, ????????£???????????¶?????????????????? )\n        [??????????????????]            [??????????????????]\n        [??????]  [??????]     => [??????,?????¶] [??????,?????¶]\n        ??????????????????????????????\n        ??????????????????????¨??????????????????¶????????????????????????\n      */\n      RMQ[index].lazy = opr; // ??????????????????????????¶????¨??????????????????????????????????\n      if( opr == 'A' )      RMQ[index].lazy_coef += v; \n      else if( opr == 'S' ) RMQ[index].lazy_coef = v; \n      lazy_evaluate(index,L,R);\n      return;\n    }\n \n    _update(a,b,opr,v,index*2+1,L,(L+R)/2);\n    _update(a,b,opr,v,index*2+2,(L+R)/2,R);\n    value_update(index);\n \n  }\n\n  // [a,b) ???????????? opr ?????????\n  void update(int a,int b,char opr,int v){ _update(a,b,opr,v,0,0,limit); } \n\n  tuple<int,int,int> _query(int a,int b,int index,int L,int R){\n    lazy_evaluate(index,L,R); //???????????????????????£??????????????\\??£????????????(?????¶????????????)????????§??????????????§??????????????£??????????????\\??????\n \n    if( b <= L || R <= a ) return make_tuple(0,IINF,-IINF);\n    if( a <= L && R <= b ) return make_tuple(RMQ[index].value,minimum_dat[index],maximum_dat[index]);\n\n\n    auto tmp1 = _query(a,b,index*2+1,L,(L+R)/2);\n    auto tmp2 = _query(a,b,index*2+2,(L+R)/2,R);\n    tuple<int,int,int> ret = make_tuple(get<0>(tmp1)+get<0>(tmp2),min(get<1>(tmp1),get<1>(tmp2)),max(get<2>(tmp1),get<2>(tmp2)));\n    value_update(index); //???????????§????????¨??????????????£???????????£??????????????§??????????????¨??£?????????????????????????????£?????????????????????\n    return ret;\n  }\n\n  // [a,b) ????????????????°????????????§????????????\n  tuple<int,int,int> query(int a,int b) { return _query(a,b,0,0,limit); }\n\n};\n\n\n\n#define MAX 20010\n\nll dp[MAX];\nint N,M;\nll K,A[MAX];\n\nvoid computer() {\n  SegmentTree rmq;\n  {\n    rmq.init(N);\n    vector<int> vec(N);\n    rep(i,N) vec[i] = A[i];\n    rmq.build(vec);\n  }\n  rep(i,N+1) dp[i] = LLONG_MAX;\n  rep(i,N) {\n    dp[i] = ((i-1>=0)?dp[i-1]:0) + K;\n    rep(j,i) {\n      if( i - j + 1 > M ) break;\n      auto v = rmq.query(j,i+1);\n      ll maxi = get<2>(v);\n      ll mini = get<1>(v);\n      assert( maxi >= mini );\n      dp[i] = min(dp[i],((j-1>=0)?dp[j-1]:0)+K+(ll)(i-j+1) * ( maxi - mini ));\n    }\n  }\n  cout << dp[N-1] << endl;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  rep(i,N) cin >> A[i];\n  computer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll N,M,K;\nll A[100005];\n\nll dp[20005];\n\nconst ll INF = 1000000000000000000LL;\n\nll solve(){\n  fill(dp,dp+N+1,INF);\n  dp[0] = 0;\n  for(ll i=1;i<=N;i++){\n    ll a = -INF, b= INF;      \n    for(ll j=i-1;j>=max(0LL,i-M);j--){\n      b = min( A[j], b );\n      a = max( A[j], a );\n      ll c = K + (i-j)*(a-b);\n      assert( c >= 0 );\n      dp[i] = min( dp[i], dp[j] + c );\n    }\n  }\n  return dp[N];\n}\n\nint main(){\n  cin >>N >> M >> K;\n  assert( N < 20000 );\n  for(int i=0;i<N;i++)\n    cin >> A[i];\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll > P;\n\nll N, M, K;\nll ookisa[20000];\nll dp[20000][1001];\n\nP get(int a,int b) {\n\tP res;\n\tres.first = *max_element(ookisa + a, ookisa + b + 1);\n\tres.second = *min_element(ookisa + a, ookisa + b + 1);\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < N; i++)cin >> ookisa[i];\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < M; j++)dp[i][j] = 1145141919810893;\n\n\tdp[0][M - 1] = K;\n\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP minmax = get(i - (M - j - 1), i + 1);\n\t\t\t\t/*dp[i + 1][j - 1] = min(dp[i + 1][j - 1],\n\t\t\t\t\tdp[i - (M - j - 1)][M - 1] + (M - j + 1) * (minmax.first - minmax.second));\n\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 1145141919810893;\n\n\tfor (int i = 0; i < M; i++)ans = min(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n\tcout << 0 - M + 0 + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long int\nusing namespace std;\nconst int INF = 3e18;\nint n, m, k;\nint a[20001];\nint dp[20001];\nsigned main()\n{\n  scanf(\"%lld%lld%lld\", &n, &m, &k);\n  for(int i = 1; i <= n; i++){\n    scanf(\"%lld\", &a[i]);\n  }\n\n  fill(dp + 1, dp + n + 1, INF);\n\n  for(int i = 0; i < n; i++){\n    int mx = 0, mn = INF;\n    for(int j = i + 1; j <= min(i + m, n); j++){\n      mx = max(mx, a[j]);\n      mn = min(mn, a[j]);\n\n      dp[j] = min(dp[j], dp[i] + k + ((j - i) * (mx - mn)));\n    }\n  }\n  printf(\"%lld\\n\", dp[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = (1LL << 55);\n\nstruct SegmentTree{\n  vector<ll> mini, maxi;\n  int sz;\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz *= 2;\n    mini.resize(2*sz-1, INF);\n    maxi.resize(2*sz-1, -INF);\n  }\n  void update(int k, ll x)\n  {\n    k += sz - 1;\n    mini[k] = x;\n    maxi[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      mini[k] = min(mini[2*k+1], mini[2*k+2]);\n      maxi[k] = max(maxi[2*k+1], maxi[2*k+2]);\n    }\n  }\n  ll minimum(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return mini[k];\n    ll vl = minimum(a, b, 2*k+1, l, (l+r)/2);\n    ll vr = minimum(a, b, 2*k+2, (l+r)/2, r);\n    return min(vl, vr);\n  }\n  ll maximum(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -INF;\n    if(a <= l && r <= b) return maxi[k];\n    ll vl = maximum(a, b, 2*k+1, l, (l+r)/2);\n    ll vr = maximum(a, b, 2*k+2, (l+r)/2, r);\n    return max(vl, vr);\n  }\n  ll minimum(int a, int b)\n  {\n    return minimum(a, b, 0, 0, sz);\n  }\n  ll maximum(int a, int b)\n  {\n    return maximum(a, b, 0, 0, sz);\n  }\n};\n\nint main()\n{\n  ll N, M, K;\n  cin >> N >> M >> K;\n  SegmentTree seg(N);\n  for(int i = 0; i < N; i++){\n    int A; cin >> A;\n    seg.update(i, A);\n  }\n  ll dp[20010];\n  fill(dp, dp + 20010, INF);\n  dp[0] = 0;\n  for(int i = 0; i < N; i++){\n    for(int j = min(M, N-i); j > 0; j--){\n      ll dif = seg.maximum(i, i + j) - seg.minimum(i, i + j);\n      dp[i + j] = min(dp[i + j], dp[i] + K + j*dif);\n    }\n  }\n  cout << dp[N] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 200001\nconst int inf = 1e18;\n\nint mn[2][1001], mx[2][1001];\nint a[MAX], dp[2][1001];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tmn[0][j] = mn[1][j];mn[1][j] = inf;\n\t\t\tmx[0][j] = mx[1][j];mx[1][j] = 0;\n\t\t\tdp[0][j] = dp[1][j];dp[1][j] = inf;\n\t\t}\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < n;i++){\n\t\tif(dp[0][i] == inf)continue;\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll dp[2][1010];\nll a[2][1010],b[2][1010];\nint main(){\n\tll n,m,k;\tcin>>n>>m>>k;\n\tvector<ll> v(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>v[i];\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[i][j]=LLONG_MAX;\n\t\t\ta[i][j]=INT_MIN;\tb[i][j]=INT_MAX;\n\t\t}\n\t}\n\tdp[0][0]=k;\ta[0][0]=b[0][0]=v[0];\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(dp[0][j]==LLONG_MAX)\tcontinue;\n\t\t\t//その箱に追加する場合\n\t\t\tif(j+1<m){\n\t\t\t\tdp[1][j+1]=dp[0][j];\n\t\t\t\ta[1][j+1]=max((ll)a[0][j],v[i]);\n\t\t\t\tb[1][j+1]=min((ll)b[0][j],v[i]);\n\t\t\t}\n\t\t\t//新しく箱を作る場合\n\t\t\tll num=k+dp[0][j];\n\t\t\tnum+=(a[0][j]-b[0][j])*(j+1);\n\t\t\tdp[1][0]=min(dp[1][0],num);\n\t\t\ta[1][0]=b[1][0]=v[i];\n\t\t}\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[0][j]=dp[1][j];\tdp[1][j]=LLONG_MAX;\n\t\t\ta[0][j]=a[1][j];\ta[1][j]=INT_MIN;\n\t\t\tb[0][j]=b[1][j];\tb[1][j]=INT_MAX;\n\t\t}\n\t}\n\tll ans=LLONG_MAX;\n\tfor(int i=0;i<m;i++){\n\t\tll num=dp[0][i];\n\t\tnum+=(a[0][i]-b[0][i])*(i+1);\n\t\tans=min(ans,num);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll a[20000],dp[20001];\nll n, m, k;\nconst ll inf = 9898989898989;\nint main() {\n\tcin >> n >> m >> k;\n\tfor (ll i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tdp[i] = inf;\n\t}\n\tdp[n] = inf;\n\tdp[0] = 0;\n\tll mi, ma;\n\tfor (ll i = 0; i < n; i++) {\n\t\tma = a[i];\n\t\tmi = a[i];\n\t\tfor (ll j = 1; j <= m&&i + j <= n; j++) {\n\t\t\tma = max(ma, a[i + j - 1]);\n\t\t\tmi = min(mi, a[i + j - 1]);\n\t\t\tdp[i + j] = min(dp[i + j], (dp[i] + k + j*(ma - mi)));\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing  ll =          long long int;\nusing ull = unsigned long long int;\nconst char en ='\\n';\nconst int  mod=1000000007;\n\nint n,m,k;\nvector<int> orangees,memo;\n\n\nint dfs(int index){\n\tif(index<0) return 0;\n\tif(index==0){\n\t\tmemo[0]=k;\n\t\treturn k;\n\t}\n\tif(memo[index]!=INT_MAX) return memo[index];\n\n\tint MIN=INT_MAX,MAX=INT_MIN;\n\tint start=max(index-m,0);\n\tfor(int i=index;i>=start;--i){\n\t\tMIN=min(MIN,orangees[i]);\n\t\tMAX=max(MAX,orangees[i]);\n\t\tmemo[index]=min(memo[index],dfs(i-1)+k+(index-i+1)*(MAX-MIN));\n\t}\n\treturn memo[index];\n}\nint main(){\n\tcin.tie();\n\tios::sync_with_stdio(false);\n\n\n\tcin>>n>>m>>k;\n\torangees=vector<int>(n);\n\tmemo    =vector<int>(n);\n\tfor(auto& i:orangees) cin>>i;\n\tfill_n(memo.begin(),n,INT_MAX);\n\n\tcout<<dfs(n-1)<<en;\n\n\tfor(int i=0;i<n;i++) cout<<memo[i]<<' ';\n\tcout<<en;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconstexpr int MAX_N=20001,MAX_M=1001;\nconstexpr long long int INF=(long long int)1e15;\n\nint n,m,k;\nlong long int dp[MAX_N];\nint a[MAX_N];\nint max[MAX_N][MAX_M],min[MAX_N][MAX_M];\n\nint main(){\n\tstd::cin>>n>>m>>k;\n\tfor(int i=1;i<=n;++i)\n\t\tstd::cin>>a[i];\n\tstd::fill(dp+1,dp+n+1,INF);\n\n\tfor(int i=1;i<=n;++i){\n\t\tint _max=0,_min=(int)1e9;\n\t\tfor(int j=1;j<=m&&j<=i;++j){\n\t\t\t_max=std::max(_max,a[i-j+1]);\n\t\t\tmax[i][j]=_max;\n\t\t\t_min=std::min(_min,a[i-j+1]);\n\t\t\tmin[i][j]=_min;\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=m&&j<=i;++j)\n\t\t\tdp[i]=std::min(dp[i],dp[i-j]+(max[i][j]-min[i][j])*j+k);\n\t}\n\tstd::cout<<dp[n]<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M,K;\nint A[20000];\n\nint dp[20001];\n\nsigned main(){\n    cin>>N>>M>>K;\n    rep(i,N)cin>>A[i];\n\n    for(int i=1;i<=N;i++){\n        int mi=1001001001,ma=0;\n        dp[i]=1001001001001001001ll;\n        for(int j=1;j<=M&&i-j>=0;j++){\n            chmax(ma,A[i-j]);\n            chmin(mi,A[i-j]);\n            chmin(dp[i],dp[i-j]+K+j*(ma-mi));\n        }\n    }\n\n    cout<<dp[N]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 20001\nconst int inf = 1e18;\n\nint mn[2][1001], mx[2][1001];\nint a[MAX], dp[2][1001];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\tfill((int*)(mn+1), (int*)(mn+2), inf);\n\t\tfill((int*)(mx+1), (int*)(mx+2), 0);\n\t\tfill((int*)(dp+1), (int*)(dp+2), inf);\n\t\t/*for(int j = 0;j < 2;j++){\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tif(dp[j][k] == inf)printf(\"* \");\n\t\t\t\telse printf(\"%lld \", dp[j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}\n\t\tswap(mn[0], mn[1]);\n\t\tswap(mx[0], mx[1]);\n\t\tswap(dp[0], dp[1]);\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < n;i++){\n\t\tif(dp[0][i] == inf)continue;\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconstexpr int MAX_N=20001,MAX_M=1001;\nconstexpr long long int INF=(long long int)1e15;\n\nint n,m,k;\nlong long int dp[MAX_N];\nint a[MAX_N];\nint max[MAX_N][MAX_M],min[MAX_N][MAX_M];\n\nint main(){\n\tstd::cin>>n>>m>>k;\n\tfor(int i=1;i<=n;++i)\n\t\tstd::cin>>a[i];\n\tstd::fill(dp+1,dp+n+1,INF);\n\n\tfor(int i=1;i<=n;++i){\n\t\tint _max=0,_min=(int)1e9;\n\t\tfor(int j=1;j<=m&&j<=i;++j){\n\t\t\t_max=std::max(_max,a[i-j+1]);\n\t\t\tmax[i][j]=_max;\n\t\t\t_min=std::min(_min,a[i-j+1]);\n\t\t\tmin[i][j]=_min;\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=m&&j<=i;++j)\n\t\t\tdp[i]=std::min(dp[i],dp[i-j]+(max[i][j]-min[i][j])*j+k);\n\t}\n\tstd::cout<<dp[n]<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "16 4 12\n3\n10\n13\n10\n19\n9\n12\n16\n11\n2\n19\n9\n13\n2\n13\n19"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 3e18;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, K;\nint A[20005];\nint memo[20005];\n\nint rec(int now)\n{\n    if (~memo[now]) return memo[now];\n\n    int res = inf;\n    int mi = inf, ma = -inf;\n    \n    for (int i = 0, to = min(N - now, M); i < to; ++i) {\n        mi = min(mi, A[now + i]);\n        ma = max(ma, A[now + i]);\n\n        res = min(res, K + (ma - mi) * (i + 1) + rec(now + i + 1));\n    }\n\n    if (res == inf) res = 0;\n\n    return memo[now] = res;\n}\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    omajinai;\n    cin >> N >> M >> K;\n\n    rep(i, N) {\n        cin >> A[i];\n    }\n\n    memset(memo, -1, sizeof (memo));\n\n    cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint n, m, k;\nint a[20000];\nint dp[20000];\n\nint dfs(int id) {\n\tif (id >= n) return 0;\n\tif (dp[id] != 0) return dp[id];\n\n\tint maxi = -1145141919;\n\tint mini = 1145141919;\n\tfor (int s = 1; s <= m; s++) {\n\t\tif (id + s > n) { continue; }\n\t\tmaxi = max(maxi, a[id + s - 1]);\n\t\tmini = min(mini, a[id + s - 1]);\n\t\tret = min(ret, dfs(id + s) + k + s * (maxi - mini));\n\t}\n\treturn (dp[id] = ret);\n}\n\nsigned main() {\n\tcin >> n >> m >> k;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tcout << dfs(0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  vector<ll> a(n + 1);\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n\n  vector<ll> dp(n + 1, 1e18);\n  dp[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    ll maxa = a[i], mina = a[i];\n    for (int j = 1; j <= min(m, i); j++) {\n      maxa = max(maxa, a[i - j + 1]);\n      mina = min(mina, a[i - j + 1]);\n      dp[i] = min(dp[i], dp[i - j] + k + j * (maxa - mina));\n    }\n  }\n\n  cout << dp[n] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nlong long N,M,K;\nlong long A[20001]={};\nlong long dp[20001][1001];\nlong long maxD[20001][1001];\nlong long minD[20001][1001];\nconst long long INF=100000000000000000;\n\nlong long calc(long long n1,long long m1){\n\tlong long ans=INF;\n\tif(dp[n1][m1]>-1)return dp[n1][m1];\n\tif(m1>0){\n\t\tans=calc(n1,0)+K+m1*(maxD[n1][m1]-minD[n1][m1]);\n\t}else{\n\t\tfor(long long i=1;i<M+1&&i<n1+1;++i){\n\t\t\tans=min(ans,calc(n1-i,i));\n\t\t}\n\t}\n\tdp[n1][m1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(long long i=1;i<N+1;i++)cin>>A[i];\n\n\tfill(dp[0],dp[20001],-1);\n\tfor(int i=0;i<N+1;i++){\n\t\tmaxD[i][0]=0;\n\t\tminD[i][0]=INF;\n\t\tfor(int j=1;j<M+1;j++){\n\t\t\tmaxD[i][j]=max(maxD[i][j-1],A[i+j]);\n\t\t\tminD[i][j]=min(minD[i][j-1],A[i+j]);\n\t\t}\n\t}\n\tdp[0][0]=0;\n//\tlong long R;\n//\tfor(int i=1;i<N+1;i++)R=calc(i,0);\n//\tcout<<R<<endl;\n\tcout<<calc(N,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define min(a,b) a<b?a:b\nusing namespace std;\nint dp[20005];\nint size[20005];\nconst int MAX=1000000007;\nint main(){\n\tint n,m,x;\n\tint i,j,k;\n\tint ma,mb;\n\tint a,b;\n\tfor(i=1;i<20005;i++){dp[i]=MAX;}\n\tcin>>n>>m>>x;\n\tfor(i=0;i<n;i++){\n\t\tcin>>size[i];\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tma=MAX,mb=0;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tif(i-j<0)break;\n\t\t\tif(size[i-j]<ma)ma=size[i-j];\n\t\t\tif(mb<size[i-j])mb=size[i-j];\n\t\t\tdp[i]=min(dp[i],dp[i-j]+x+(mb-ma)*j);\n\t\t}\n\t}\n\tcout<<dp[n]<<endl;\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e18;\nll v[20001], dp[2][1010];\nll a[2][1010],b[2][1010];\nint main(){\n\tll n,m,k;\tcin>>n>>m>>k;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>v[i];\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[i][j]=INF;\n\t\t\ta[i][j]=-INF;\tb[i][j]=INF;\n\t\t}\n\t}\n\tdp[0][0]=k;\ta[0][0]=b[0][0]=v[0];\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(dp[0][j]==INF)\tcontinue;\n\t\t\t//その箱に追加する場合\n\t\t\tif(j+1<m){\n\t\t\t\tdp[1][j+1]=dp[0][j];\n\t\t\t\ta[1][j+1]=max((ll)a[0][j],v[i]);\n\t\t\t\tb[1][j+1]=min((ll)b[0][j],v[i]);\n\t\t\t}\n\t\t\t//新しく箱を作る場合\n\t\t\tll num=k+dp[0][j];\n\t\t\tnum+=(a[0][j]-b[0][j])*(j+1);\n\t\t\tdp[1][0]=min(dp[1][0],num);\n\t\t\ta[1][0]=b[1][0]=v[i];\n\t\t}\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[0][j]=dp[1][j];\tdp[1][j]=INF;\n\t\t\ta[0][j]=a[1][j];\ta[1][j]=-INF;\n\t\t\tb[0][j]=b[1][j];\tb[1][j]=INF;\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(int i=0;i<m;i++){\n\t\tll num=dp[0][i];\n\t\tnum+=(a[0][i]-b[0][i])*(i+1);\n\t\tans=min(ans,num);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll > P;\n\nll N, M, K;\nll ookisa[20000];\nll dp[20000][1001];\n\nP get(int a,int b) {\n\tP res;\n\tres.first = *max_element(ookisa + a, ookisa + b + 1);\n\tres.second = *min_element(ookisa + a, ookisa + b + 1);\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < N; i++)cin >> ookisa[i];\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < M; j++)dp[i][j] = 1145141919810893;\n\n\tdp[0][M - 1] = K;\n\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*P minmax = get(i - (M - j - 1), i + 1);\n\t\t\t\tdp[i + 1][j - 1] = min(dp[i + 1][j - 1],\n\t\t\t\t\tdp[i - (M - j - 1)][M - 1] + (M - j + 1) * (minmax.first - minmax.second));\n\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 1145141919810893;\n\n\tfor (int i = 0; i < M; i++)ans = min(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n\tcout << 0 - M + 0 + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n\n#define MAX_N 20001\n\nusing namespace std;\n\nuint64_t N,M,K,A[MAX_N],T[MAX_N];\n\nuint64_t min(uint64_t a,uint64_t b)\n{\n\tif(a < b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nuint64_t max(uint64_t a,uint64_t b)\n{\n\tif(a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nuint64_t getmin(int begin,int end)\n{\n\tuint64_t res = UINT64_MAX;\n\tfor(int i = begin;i <= end;i++)\n\t\tres = min(res,A[i]);\n\treturn res;\n}\n\nuint64_t getmax(int begin,int end)\n{\n\tuint64_t res = 0;\n\tfor(int i = begin;i <= end;i++)\n\t\tres = max(res,A[i]);\n\treturn res;\n}\n\nuint64_t getsum(int begin,int end)\n{\n\tuint64_t res = 0;\n\tfor(int i = begin;i <= end;i++)\n\t\tres = res + A[i];\n\treturn res;\n}\n\nint main(void)\n{\n\tcin >> N >> M >> K;\n\tfor(int i = 0;i < MAX_N;i++)\n\t{\n\t\tT[i] = UINT64_MAX;\n\t}\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\tT[N] = 0;\n\tfor(int i = N-1;i >= 0;i--)\n\t{\n\t\tfor(int k = 1;k <= M && (i + k) <= N ;k++)\n\t\t{\n\t\t\tint cost = K + (k * (getmax(N-(i+k),(N-i)-1) - getmin(N-(i+k),(N-i)-1)));\n\t\t\tT[i] = min(T[i],T[i+k]+cost);\n\t\t}\n\t}\n\tcout << T[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\nlong long int cost[30000];\nlong long int min_size[30000];\nlong long int max_size[30000];\n\n\nlong long int const LL_MAX = 10000000000000000; // 10^16\n\nint main(){\n\t\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\t\n\tfor(int i = 0; i < 30000; i++){\n\t\tmax_size[i] = 0;\n\t\tmin_size[i] = LL_MAX;\n\t\tcost[i] = LL_MAX;\n\t}\n\t\n\tmin_size[0] = 0;\n\tcost[0] = 0;\n\tcost[1] = 0;\n\t\n\tfor(int i = 1; i <= N + 1; i++){\n\t\tfor(int j = max(1, i - M); j < i; j++){\n\t\t\tcost[i] = min(cost[i], cost[j] + K + (i - j) * (max_size[j] - min_size[j]));\n\t\t}\n\t\tif(i == N + 1){\n\t\t\tbreak;\n\t\t}\n\t\tlong long int num;\n\t\tcin >> num;\n\t\tfor(int j = max(0, i - M) + 1; j <= i; j++){\n\t\t\tmax_size[j] = max(max_size[j], num);\n\t\t\tmin_size[j] = min(min_size[j], num);\n\t\t}\n\t}\n\t\n\tcout << cost[N + 1] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconstexpr int MAX_N=20001,MAX_M=1001;\nconstexpr long long int INF=(long long int)1e15;\n\nint n,m,k;\nlong long int dp[MAX_N];\nlong long int a[MAX_N];\nlong long int max[MAX_N][MAX_M],min[MAX_N][MAX_M];\n\nint main(){\n\tstd::cin>>n>>m>>k;\n\tfor(int i=1;i<=n;++i)\n\t\tstd::cin>>a[i];\n\tstd::fill(dp+1,dp+n+1,INF);\n\n\tfor(int i=1;i<=n;++i){\n\t\tlong long int _max=0,_min=INF;\n\t\tfor(int j=1;j<=m&&j<=i;++j){\n\t\t\t_max=std::max(_max,a[i-j+1]);\n\t\t\tmax[i][j]=_max;\n\t\t\t_min=std::min(_min,a[i-j+1]);\n\t\t\tmin[i][j]=_min;\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=m&&j<=i;++j)\n\t\t\tdp[i]=std::min(dp[i],dp[i-j]+(max[i][j]-min[i][j])*j+k);\n\t}\n\tstd::cout<<dp[n]<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\n\nconst int MAX_N=2e4;\n\nint N,M,K;\nint A[MAX_N];\n\nll dp[MAX_N+1];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin>>N>>M>>K;\n\tREP(i,N){\n\t\tcin>>A[i];\n\t}\n\tdp[0]=0;\n\tFOR(i,1,N+1){\n\t\tdp[i]=K+dp[i-1];\n\t\tint ma=A[i-1],mi=A[i-1];\n\t\tFOR(j,2,min(M,i)+1){\n\t\t\tma=max(ma,A[i-j]);\n\t\t\tmi=min(mi,A[i-j]);\n\t\t\tdp[i]=min(dp[i],K+j*(ma-mi)+dp[i-j]);\n\t\t}\n\t}\n\tcout<<dp[N]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 25252\n#define INF (1LL<<55)\ntypedef long long ll;\n\nll N, M, K;\nll memo[MAX];\nvector<ll> A;\n\nll solve(int n)\n{\n    if (n == N) return 0;\n    ll &res = memo[n];\n\n    if (res != -1) return res;\n    res = INF;\n    \n    ll maxi = 0, mini = INF;\n    for (int i = n; i < min(n + M, N); i++) {\n        maxi = max(maxi, A[i]);\n        mini = min(mini, A[i]);\n        ll cost = K + (i+1 - n) * (maxi - mini);\n        res = min(res, solve(i+1) + cost);\n    }\n    return res;\n}\n\nint main()\n{\n    cin >> N >> M >> K;\n    A.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << solve(0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<array>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<unordered_map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nconst int MOD = 1e9 + 7;\nconst bool DEBUG = false;\n\n#define MAX 20010\n\nint N, M, K;\nint A[MAX] = {};\nint dp[MAX] = {};//a????????\\????????°????????¨??????????°??????????\n\nint dfs(int a) {\n\tif (dp[a] != -1)return dp[a];\n\tint e = min(N, a + M);\n\tpair<int*, int*> k = minmax_element(A + a, A + e);\n\tint ret = (e - a)*(*k.second - *k.first) + K + dfs(e);\n\trep(b, a + 1, e) {\n\t\tpair<int*, int*> k = minmax_element(A + a, A + b);\n\t\tret = min(ret, (b - a)*(*k.second - *k.first) + K + dfs(b));\n\t}\n\tk = minmax_element(A + a, A + e);\n\tif (DEBUG)cerr << a << \" \" << e << \" \" << ret << \" \" << *k.second - *k.first << endl;\n\treturn dp[a] = ret;\n}\n\nsigned main() {\n\tcin >> N >> M >> K;\n\trep(i, 0, N)cin >> A[i];\n\tmemset(dp, -1, sizeof(dp));\n\tdp[N] = 0;\n\tint ans = dfs(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = (1LL << 55);\n\nstruct SegmentTree{\n  vector<ll> mini, maxi;\n  int sz;\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz *= 2;\n    mini.resize(2*sz-1, INF);\n    maxi.resize(2*sz-1, -INF);\n  }\n  void update(int k, ll x)\n  {\n    k += sz - 1;\n    mini[k] = x;\n    maxi[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      mini[k] = min(mini[2*k+1], mini[2*k+2]);\n      maxi[k] = max(maxi[2*k+1], maxi[2*k+2]);\n    }\n  }\n  ll minimum(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return mini[k];\n    ll vl = minimum(a, b, 2*k+1, l, (l+r)/2);\n    ll vr = minimum(a, b, 2*k+2, (l+r)/2, r);\n    return min(vl, vr);\n  }\n  ll maximum(int a, int b, int k, int l, int r)\n  {\n    if(r <= a || b <= l) return -INF;\n    if(a <= l && r <= b) return maxi[k];\n    ll vl = maximum(a, b, 2*k+1, l, (l+r)/2);\n    ll vr = maximum(a, b, 2*k+2, (l+r)/2, r);\n    return max(vl, vr);\n  }\n  ll minimum(int a, int b)\n  {\n    return minimum(a, b, 0, 0, sz);\n  }\n  ll maximum(int a, int b)\n  {\n    return maximum(a, b, 0, 0, sz);\n  }\n};\n\nint main()\n{\n  ll N, M, K, A[20010];\n  cin >> N >> M >> K;\n  SegmentTree seg(N);\n  for(int i = 0; i < N; i++){\n    cin >> A[i];\n  }\n  ll dp[20010];\n  fill(dp, dp + 20010, INF);\n  dp[0] = 0;\n  for(int i = 0; i < N; i++){\n    ll maxi = -INF, mini = INF;    \n    for(int j = 1; j <= min(M, N-i); j++){\n      maxi = max(maxi, A[i+j-1]);\n      mini = min(mini, A[i+j-1]);\n      ll dif = maxi - mini;\n      dp[i + j] = min(dp[i + j], dp[i] + K + j*dif);\n    }\n  }\n  cout << dp[N] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:https://www.ioi-jp.org/joi/2015/2016-ho/2016-ho.pdf>\n?????????============================================================\nN(1<=N<=20000)???????????¬???????????????????????¬??????i?????§?????????Ai??§?????????\n\n???????????¬????????????????????????????????????????????±??????????????????????????¨?????????????????¨????????±??????\n??£?¶?????????????????????¬??????????????????????????¨?????§????????????\n\n?????¨????????±???????????§??§M(1<=M<=1000)?????§?????¬???????????????????????¨?????§??????\n??±????????¬?????????????????????????????????????????????????????±?????????????????§????????¬???????????§?????????a,\n??±????????????????°?????????¬???????????§?????????b, ??±?????????????????¬??????????????°???s??¨????????¨???, K+s*(a-b)??¨?????????\nK?????±???????????????????????§???????????¨????????±??§??±???\n\n??????????????°?????±?????¨?????????????????????????????¬????????????????????±??°??????????????¨??§??±??°???????????????\n???????????????????????§?????????????°????????????????\n=================================================================\n?§£??¬=============================================================\n================================================================\n*/\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M, K; cin >> N >> M >> K;\n\tvector<int> A(N); for (auto& in : A)cin >> in;\n\n//\tvector<vector<pair<ll, pair<int, int>>>> dp(N + 1, vector<pair<ll, pair<int, int>>>(M + 1, { LINF,{-INF,INF} }));\n//\tdp[0][0].first = 0;\n\tvector<vector<pair<ll, pair<int, int>>>> dp(2, vector<pair<ll, pair<int, int>>>(M, { LINF,{ -INF,INF } }));\n\tint cur = 0, next = 1;\n\tdp[0][0].first = 0;\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int j = 0; j < M;j++) {\n\t\t\tdp[next][j] = { LINF,{-INF,INF} };\n\t\t}\n\t\tfor (int j = 0; j < M;j++) {\n\t\t\tif (dp[cur][j].first == LINF)continue;\n\t\t\tif (j != M-1 && i != N-1) {\n\t\t\t\tdp[next][j+1] = min(dp[next][j + 1], { dp[cur][j].first,{ max(dp[cur][j].second.first,A[i]),min(dp[cur][j].second.second,A[i]) } });\n//\t\t\t\tdp[i + 1][j + 1] = min(dp[i + 1][j + 1], { dp[i][j].first,{max(dp[i][j].second.first,A[i]),min(dp[i][j].second.second,A[i])} });\n\t\t\t}\n\t\t\tdp[next][0] = min(dp[next][0], { dp[cur][j].first + (ll)K + (ll)(j + 1)*((ll)max(dp[cur][j].second.first,A[i]) - (ll)min(dp[cur][j].second.second,A[i])),{ -INF,INF } });\n//\t\t\tdp[i + 1][0] = min(dp[i + 1][0], { dp[i][j].first + (ll)K + (ll)(j+1)*((ll)max(dp[i][j].second.first,A[i]) - (ll)min(dp[i][j].second.second,A[i])),{-INF,INF} });\n\t\t}\n\t\tcur = !cur;\n\t\tnext = !next;\n\t}\n\tcout << dp[cur][0].first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf 10e18\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, n, m;\n  scanf(\"%lld%lld%lld\", &n, &m, &k);\n  ll a[n], **sum, dp[n];\n  sum = (ll**)malloc(sizeof(ll*) * (n + 10));\n  for(i = 0; i < n; ++i) sum[i] = (ll*)malloc(sizeof(ll) * (m + 10));\n  for(i = 0; i < n; ++i) scanf(\"%lld\", &a[i]);\n  for(i = 0; i < n; ++i) dp[i] = inf;\n  dp[0] = k;\n  for(i = 0; i < n; ++i) {\n    ll min = inf, max = 0;\n    for(j = 0; j < n; ++j) {\n      if(i - j >= 0) {\n        if(min > a[i - j]) min = a[i - j];\n        if(max < a[i - j]) max = a[i - j];\n        sum[i][j] = k + (j + 1) * (max - min);\n      }\n    }\n  }\n  for(i = 1; i < n; ++i) {\n    for(j = 0; j < m; ++j) {\n      if(i - j > 0) {\n        if(dp[i] > sum[i][j] + dp[i - j - 1]) dp[i] = sum[i][j] + dp[i - j - 1];\n      } else if(!(i - j)) {\n        if(dp[i] > sum[i][j]) dp[i] = sum[i][j];\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[n - 1]);\n  for(i = 0; i < n; ++i) free(sum[i]);\n  free(sum);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nstruct P {\n\tlong long ma, mi;\n};\nll dp[20001], n, m, k, a[20000],s;\nP c[200];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 9000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=90000000000;\n\t\tfor (ll y = i; y < i + x; ) {\n\t\t\tif (y % s == 0&&y+s<i+x) {\n\t\t\t\tma = max(c[(y / s)].ma, ma);\n\t\t\t\tmi = min(c[y / s].mi, mi);\n\t\t\t\ty += s;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tma = max(ma, a[y]);\n\t\t\t\tmi = min(mi, a[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\ts = floor(sqrt(n));\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tfor (ll i = 0; i < floor(i / s); i++) {\n\t\t\tll ma = -1, mi = 900000000000000;\n\t\t\tfor (ll j = i * s; j < (i + 1) * s; j++) {\n\t\t\t\tma = max(ma, a[j]);\n\t\t\t\tmi = min(mi, a[j]);\n\t\t\t}\n\t\t\tc[i].ma = ma;\n\t\t\tc[i].mi = mi;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nint main()\n{\n  int N, M, K, A[20000];\n  int64 dp[20001];\n  \n  scanf(\"%d %d %d\", &N, &M, &K);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &A[i]);\n  }\n\n  fill_n(dp, 20001, INF);\n  dp[0] = 0;\n  for(int i = 0; i < N; i++) {\n    int small = A[i], large = A[i];\n    for(int64 j = 0; j < min(M, N - i); j++) {\n      small = min(small, A[i + j]);\n      large = max(large, A[i + j]);\n      dp[i + j + 1] = min(dp[i + j + 1], dp[i] + K + (j + 1) * (large - small));\n    }\n  }\n  printf(\"%d\\n\", dp[N]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e18;\nll v[20001], dp[2][1010];\nll a[2][1010],b[2][1010];\nint main(){\n\tll n,m,k;\tcin>>n>>m>>k;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>v[i];\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[i][j]=INF;\n\t\t\ta[i][j]=INT_MIN;\tb[i][j]=INF;\n\t\t}\n\t}\n\tdp[0][0]=k;\ta[0][0]=b[0][0]=v[0];\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(dp[0][j]==LLONG_MAX)\tcontinue;\n\t\t\t//その箱に追加する場合\n\t\t\tif(j+1<m){\n\t\t\t\tdp[1][j+1]=dp[0][j];\n\t\t\t\ta[1][j+1]=max((ll)a[0][j],v[i]);\n\t\t\t\tb[1][j+1]=min((ll)b[0][j],v[i]);\n\t\t\t}\n\t\t\t//新しく箱を作る場合\n\t\t\tll num=k+dp[0][j];\n\t\t\tnum+=(a[0][j]-b[0][j])*(j+1);\n\t\t\tdp[1][0]=min(dp[1][0],num);\n\t\t\ta[1][0]=b[1][0]=v[i];\n\t\t}\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[0][j]=dp[1][j];\tdp[1][j]=LLONG_MAX;\n\t\t\ta[0][j]=a[1][j];\ta[1][j]=INT_MIN;\n\t\t\tb[0][j]=b[1][j];\tb[1][j]=INT_MAX;\n\t\t}\n\t}\n\tll ans=LLONG_MAX;\n\tfor(int i=0;i<m;i++){\n\t\tll num=dp[0][i];\n\t\tnum+=(a[0][i]-b[0][i])*(i+1);\n\t\tans=min(ans,num);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#define int long long\n#define INF 1000000000000000000\n#define REP(i,n) for(int i=1;i<=n;i++)\nint n,m,k;\nint a[20002];\nint mx[20002][1002];\nint mn[20002][1002];\nint cs[20002][1002];\nint sm[20002];\n\nsigned main(){\n  cin>>n>>m>>k;\n  REP(i,n)cin>>a[i];\n  REP(i,n)REP(j,m)mn[i][j-1]=INF;\n  REP(i,n)REP(j,m){\n    mx[i][j]=max(mx[i][j-1],a[i+j-1]);\n    mn[i][j]=min(mn[i][j-1],a[i+j-1]);\n    cs[i][j]=k+j*(mx[i][j]-mn[i][j]);\n  }\n  REP(i,n)sm[i]=INF;\n  REP(i,n)REP(j,m){\n    if(n<i-1+j)continue;\n    sm[i-1+j]=min(sm[i-1+j],sm[i-1]+cs[i][j]);\n  }\n  #ifdef DEBUG\n  REP(i,n){\n    REP(j,m)cout<<cs[i][j]<<\" \";\n    cout<<endl;\n  }\n  REP(i,n)cout<<sm[i]<<\" \";\n  cout<<endl;\n  #endif\n  cout<<sm[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll > P;\n\nll N, M, K;\nll ookisa[20000];\nll dp[20000][1001];\n\nP get(int a,int b) {\n\tP res;\n\tres.first = *max_element(ookisa + a, ookisa + b + 1);\n\tres.second = *min_element(ookisa + a, ookisa + b + 1);\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < N; i++)cin >> ookisa[i];\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < M; j++)dp[i][j] = 1145141919810893;\n\n\tdp[0][M - 1] = K;\n\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (dp[i][j] == 1145141919810893)continue;\n\t\t\tif (j == 0) {\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP minmax = get(i - (M - j - 1), i + 1);\n\n\t\t\t\tdp[i + 1][j - 1] = min(dp[i + 1][j - 1],\n\t\t\t\t\tdp[i - (M - j - 1)][M - 1] + (M - j + 1) * (minmax.first - minmax.second));\n\t\t\t\t\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 1145141919810893;\n\n\tfor (int i = 0; i < M; i++)ans = min(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing  ll =          long long int;\nusing ull = unsigned long long int;\nconst char en ='\\n';\nconst int  mod=1000000007;\n\nll n,m,k;\nvector<ll> orangees,memo;\n\n\nll dfs(ll index){\n\tif(index<0) return 0;\n\tif(index==0){\n\t\tmemo[0]=k;\n\t\treturn k;\n\t}\n\tif(memo[index]!=LLONG_MAX) return memo[index];\n\n\tll MIN=LLONG_MAX,MAX=LLONG_MIN;\n\tll start=max(index-m,0LL);\n\tfor(ll i=index;i>=start;--i){\n\t\tMIN=min(MIN,orangees[i]);\n\t\tMAX=max(MAX,orangees[i]);\n\t\tmemo[index]=min(memo[index],dfs(i-1)+k+(index-i+1)*(MAX-MIN));\n\t}\n\treturn memo[index];\n}\nint main(){\n\tcin.tie();\n\tios::sync_with_stdio(false);\n\tcin>>n>>m>>k;\n\torangees=vector<ll>(n);\n\tmemo    =vector<ll>(n);\n\tfor(auto& i:orangees) cin>>i;\n\tfill_n(memo.begin(),n,LLONG_MAX);\n\n\tcout<<dfs(n-1)<<en;\n\n\t/*\n\tfor(int i=0;i<n;i++) cout<<memo[i]<<' ';\n\tcout<<en;\n\t*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nlong long int n, m, k;\nlong long int a[20010];\nlong long int c[20010];\n\nint main(){\n\tscanf(\"%lld %lld %lld\", &n, &m, &k);\n\tfor(int i=1; i<=n; ++i) scanf(\"%lld\", &a[i]);\n\tc[1] = k;\n\tfor(int i=2; i<=n; ++i){\n\t\tlong long int t = 1e18;\n\t\tlong long int ma = 0;\n\t\tlong long int mi = 1e18;\n\t\tfor(int j=1; j<=m; ++j){\n\t\t\tif(i - j < 0) break;\n\t\t\tma = max(ma, a[i-j+1]);\n\t\t\tmi = min(mi, a[i-j+1]);\n\t\t\tt = min(t, c[i-j] + j * (ma - mi) + k);\n\t\t}\n\t\tc[i] = t;\n\t}\n\tprintf(\"%lld\\n\", c[n]);\n/*\tfor(int i=1; i<=n; ++i) printf(\"%lld\\t\", c[i]);\n\tprintf(\"\\n\");\n*/\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : DPTest.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\nusing namespace std;\nint N,M,K;\nint A[20001]={};\nconst long long INF=100000000000000;\nlong long dp[20001]={};\nint maxdp[20001][1001]={};\nint mindp[20001][1001]={};\n\nint maxD(int n2,int n3){\n\tint ans2=A[n2+n3];\n\tif(maxdp[n2][n3]>0)return maxdp[n2][n3];\n\tif(n3>1)ans2=max(maxD(n2,n3-1),A[n2+n3]);\n\tmaxdp[n2][n3]=ans2;\n\treturn ans2;\n}\nint minD(int n2,int n3){\n\tint ans2=A[n2+n3];\n\tif(mindp[n2][n3]>0)return mindp[n2][n3];\n\tif(n3>1)ans2=min(minD(n2,n3-1),A[n2+n3]);\n\tmindp[n2][n3]=ans2;\n\treturn ans2;\n}\n\nlong long calc(int n1){\n\tlong long ans=INF;\n\tif(dp[n1]>-1)return dp[n1];\n\tfor(int i=1;i<M+1&&i<n1+1;i++){\n\t\tans=min(ans,calc(n1-i)+(long long)K+(long long)i*(long long)(maxD(n1-i,i)-minD(n1-i,i)));\n\t}\n\tdp[n1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\tfill(dp,dp+20001,-1);\n\tdp[0]=0;\n\tcout<<calc(N)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll LLINF = 1LL << 60;\nint main()\n{\n    ll N, M, K;\n    ll dp[20005];\n    ll A[20005];\n    fill_n(dp, 20005, LLINF);\n    cin >> N >> M >> K;\n    dp[0] = 0;\n    for(ll i = 0; i < N; i++) cin >> A[i];\n    for(ll i = 0; i < N; i++) {\n        ll maxv = -1, minv = LLINF;\n        for(ll j = 0; j < M; j++) {\n            if(i + j >= N) continue;\n            maxv = max(A[i + j], maxv);\n            minv = min(A[i + j], minv);\n            dp[i + j + 1] = min(dp[i + j + 1], dp[i] + K + (j + 1) * (maxv - minv));\n        }\n    }\n    cout << dp[N] << endl;\n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nlong long N,M,K;\nlong long A[20001]={};\nlong long dp[20001];\nlong long mmD[20001][1001];\nconst long long INF=100000000000000000;\n\nlong long calc(long long n1){\n\tif(dp[n1]>-1)return dp[n1];\n\tlong long ans=INF;\n\tfor(long long i=1;i<M+1&&i<n1+1;++i){\n\t\t\tans=min(ans,calc(n1-i)+K+i*mmD[n1-i][i]);\n\t}\n\tdp[n1]=ans;\n\treturn ans;\n}\n\nint main() {\n\tcin>>N>>M>>K;\n\tfor(long long i=1;i<N+1;i++)cin>>A[i];\n\n\tfill(dp,dp+20001,-1);\n\tlong long maxD[1001]={};\n\tlong long minD[1001]={};\n\n\tfor(int i=0;i<N+1;i++){\n\t\tmaxD[0]=0;\n\t\tminD[0]=INF;\n\t\tfor(int j=1;j<M+1;j++){\n\t\t\tmaxD[j]=max(maxD[j-1],A[i+j]);\n\t\t\tminD[j]=min(minD[j-1],A[i+j]);\n\t\t\tmmD[i][j]=maxD[j]-minD[j];\n\t\t}\n\t}\n\tdp[0]=0;\n//\tlong long R;\n//\tfor(int i=1;i<N;i++){\n//\t\tfor(int j=0;j<M+1;j++)\n//\t\tR=calc(i,j);\n//\t}\n//\tR=calc(N,0);\n//\tcout<<R<<endl;\n\tcout<<calc(N)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<cassert>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst int IINF = INT_MAX;\n\nclass RMQ{\nprivate:\n  int limit,N;\n  vector<int> dat;\npublic:\n  void init(int n_){\n    N = n_;\n    limit = 1;\n    while(limit<n_)limit*=2;\n    dat.clear();\n    dat.resize(2*limit,-IINF);\n  }\n  \n  int _build(int cur,int L,int R,const vector<int> &buf){\n    if( !( 0 <= cur && cur < 2*limit ) ) return -IINF;\n    if( L == R-1 ) {\n      if( L >= N ) return -IINF;\n      dat[cur] = buf[L];\n    } else {\n      int vl = _build(cur*2+1,L,(L+R)/2,buf);\n      int vr = _build(cur*2+2,(L+R)/2,R,buf);\n      dat[cur] = max(vl,vr);\n    }\n    return dat[cur];\n  }\n\n  void build(const vector<int> &buf){ _build(0,0,limit,buf); };\n\n  void update(int k,int a){\n    k += limit-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n \n  int _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return -IINF;\n    else if(a<=l && r<=b)return dat[k];\n    int vl = _query(a,b,k*2+1,l,(l+r)/2);\n    int vr = _query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n\n  int query(int a,int b){ return _query(a,b,0,0,limit); }\n};\n\nclass RRMQ{\nprivate:\n  int limit,N;\n  vector<int> dat;\npublic:\n  void init(int n_){\n    N = n_;\n    limit = 1;\n    while(limit<n_)limit*=2;\n    dat.clear();\n    dat.resize(2*limit,IINF);\n  }\n  \n  int _build(int cur,int L,int R,const vector<int> &buf){\n    if( !( 0 <= cur && cur < 2*limit ) ) return IINF;\n    if( L == R-1 ) {\n      if( L >= N ) return IINF;\n      dat[cur] = buf[L];\n    } else {\n      int vl = _build(cur*2+1,L,(L+R)/2,buf);\n      int vr = _build(cur*2+2,(L+R)/2,R,buf);\n      dat[cur] = min(vl,vr);\n    }\n    return dat[cur];\n  }\n\n  void build(const vector<int> &buf){ _build(0,0,limit,buf); };\n\n  void update(int k,int a){\n    k += limit-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n \n  int _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return IINF;\n    else if(a<=l && r<=b)return dat[k];\n    int vl = _query(a,b,k*2+1,l,(l+r)/2);\n    int vr = _query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n\n  int query(int a,int b){ return _query(a,b,0,0,limit); }\n};\n\n#define MAX 20010\n\nll dp[MAX];\nint N,M;\nll K,A[MAX];\n\nvoid computer() {\n  RMQ maxt; RRMQ mint;\n  {\n    maxt.init(N);\n    mint.init(N);\n    vector<int> vec(N);\n    rep(i,N) vec[i] = A[i];\n    maxt.build(vec);\n    mint.build(vec);\n  }\n  rep(i,N+1) dp[i] = LLONG_MAX;\n  rep(i,N) {\n    dp[i] = ((i-1>=0)?dp[i-1]:0) + K;\n    for(int j=i-1;j>=0;--j) {\n      if( i - j + 1 > M ) break;\n      if( j - 1 >= 0 && dp[j-1] + K >= dp[i] ) continue;\n      ll maxi = maxt.query(j,i+1);\n      ll mini = mint.query(j,i+1);\n      dp[i] = min(dp[i],((j-1>=0)?dp[j-1]:0)+K+(ll)(i-j+1) * ( maxi - mini ));\n    }\n  }\n  cout << dp[N-1] << endl;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  rep(i,N) cin >> A[i];\n  computer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf 10e18\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, n, m;\n  scanf(\"%lld%lld%lld\", &n, &m, &k);\n  ll a[n], **sum, dp[n];\n  sum = (ll**)malloc(sizeof(ll*) * (n + 10));\n  for(i = 0; i < n; ++i) sum[i] = (ll*)malloc(sizeof(ll) * (m + 10));\n  for(i = 0; i < n; ++i) scanf(\"%lld\", &a[i]);\n  for(i = 0; i < n; ++i) dp[i] = inf;\n  dp[0] = k;\n  for(i = 0; i < n; ++i) {\n    ll min = inf, max = 0;\n    for(j = 0; j < m; ++j) {\n      if(i - j >= 0) {\n        if(min > a[i - j]) min = a[i - j];\n        if(max < a[i - j]) max = a[i - j];\n        sum[i][j] = k + (j + 1) * (max - min);\n      }\n    }\n  }\n  for(i = 1; i < n; ++i) {\n    for(j = 0; j < m; ++j) {\n      if(i - j > 0) {\n        if(dp[i] > sum[i][j] + dp[i - j - 1]) dp[i] = sum[i][j] + dp[i - j - 1];\n      } else if(!(i - j)) {\n        if(dp[i] > sum[i][j]) dp[i] = sum[i][j];\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[n - 1]);\n  for(i = 0; i < n; ++i) free(sum[i]);\n  free(sum);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nconst ll INF=0xfffffffff;\nconst P PINF=P(INF,-INF);\nP dat[80000]; //min max\nll n;\n\nvoid init(ll n_){\n\tn=1;\n\twhile(n<n_) n*=2;\n\trep(i,2*n-1) dat[i]=P(INF,-INF);\n\treturn;\n}\n\nvoid update(ll x,ll a){\n\tx+=n-1;\n\tdat[x]=P(a,a);\n\twhile(x>0){\n\t\tx=(x-1)/2;\n\t\tdat[x]=P(min(dat[x*2+1].fr,dat[x*2+2].fr),max(dat[x*2+1].sc,dat[x*2+2].sc) );\n\t}\n\treturn;\n}\n\nP query(ll a,ll b,ll k,ll l,ll r){\n\tif(b<=l||r<=a) return PINF;\n\tif(a<=l&&r<=b) return dat[k];\n\tP chl=query(a,b,k*2+1,l,(l+r)/2);\n\tP chr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn P(min(chl.fr,chr.fr),max(chl.sc,chr.sc));\n}\n\n\nll N,M,K;\nll A[20000];\n\n\nll dp[20000];//i???????????§?????±??°?????????????°??????????\n\nll calc(ll id,ll kosu){ // id?????§kosu\n\tll res=0;\n\tif(id-kosu>=0) res+=dp[id-kosu];\n\tP p=query(id-kosu+1,id+1,0,0,n);\n\tres+=(p.sc-p.fr)*kosu+K;\n\t//if(res<0) cout<<id<<\" \"<<kosu<<\" \"<<p.fr<<\" \"<<p.sc<<endl;\n\treturn res;\n}\n\n\n\nint main()\n{\n\tcin>>N>>M>>K;\n\tinit(N);\n\trep(i,N){\n\t\tcin>>A[i];\n\t\tupdate(i,A[i]);\n\t\tdp[i]=INF;\n\t}\n\trep(i,N){\n\t\trep1(j,M){\n\t\t\tif(i+1<j) continue;\n\t\t\tdp[i]=min(dp[i],calc(i,j));\n\t\t}\n\t}\n\tcout<<dp[N-1]<<endl;\n\t//rep(i,n*2-1) cout<<i<<\"=\"<<dat[i].fr<<dat[i].sc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m,k,a[20000];\n\tint dp[20001][1001];\n\tcin >> n >> m >> k;\n\tfor(int i = 0;i <= n;i++){\n\t\tfor(int j = 0;j <= 1000;j++) dp[i][j] = INF;\n\t}\n\tdp[0][0] = 0;\n\tdp[0][1000] = 0;\n\tfor(int i = 0;i < n;i++) cin >> a[i];\n\tfor(int i = 1;i <= n;i++){\n\t\tint mi = a[i - 1],ma = a[i - 1];\n\t\tfor(int j = 0;j < min(m,i);j++){\n\t\t\tdp[i][j] = dp[i - j - 1][1000] + k + (j + 1) * (ma - mi);\n\t\t\tdp[i][1000] = min(dp[i][1000],dp[i][j]);\n\t\t\tif(i - j - 2 >= 0) {\n\t\t\t\tmi = min(mi,a[i - j - 2]);\n\t\t\t\tma = max(ma,a[i - j - 2]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][1000] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 92234341346326\n#define ll long long\nusing namespace std;\nint main(){\n\tll A,B,N,M,K,a,U,flg=0,MAX=0,MIN=INF;\n\tcin>>N>>M>>K;\n\tll cost[N+1]={0};\n\tll size[N+1]={0};\n\tfor (int A=0;A<=N;A++) cost[A]=INF;\n\tcost[0]=0;\n\tfor (A=1;A<=N;A++) cin>>size[A];\n\tfor (A=1;A<=N;A++){\n\t\tfor (B=0;B<M&&B<=N;B++){\n\t\t\tfor (int C=A;C<=A+B&&C<=N;C++){\n\t\t\t\tif (MAX<size[C]) MAX=size[C];\n\t\t\t\tif (MIN>size[C]) MIN=size[C];\n\t\t\t}\n\t\t\tcost[A+B]=min(cost[A+B],K+(1+B)*(MAX-MIN)+cost[A-1]);\n\t\t\tMAX=0;\n\t\t\tMIN=INF;\n\t\t}\n\t}\n\tcout<<cost[N]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\nLL n, m, k, a[200100];\nLL memo[200100];\n\nLL dp(LL p) {\n\tLL res = LINF, minl = LINF, maxl = -1;\n\tif (p == 0)return memo[p] = k;\n\tif (p == -1)return 0;\n\tif (memo[p] != -1)return memo[p];\n\tfor (LL c = 1; c <= m; c++) {\n\t\tif (p - c + 1 < 0)break;\n\t\tminl = min(minl, a[p - c + 1]);\n\t\tmaxl = max(maxl, a[p - c + 1]);\n\t\tres = min(res, dp(p - c) + k + c*(maxl - minl));\n\t}\n\treturn memo[p] = res;\n}\n\nint main() {\n\tfor (int i = 0; i < 200100; i++)memo[i] = -1;\n\tcin >> n >> m >> k;\n\tfor (int i = 0; i < n; i++)cin >> a[i];\n\tcout << dp(n - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 200001\nconst int inf = 1e18;\n\nint mn[2][1010], mx[2][1010];\nint a[MAX], dp[2][1010];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tmn[1][j] = inf;\n\t\t\tmx[1][j] = 0;\n\t\t\tdp[1][j] = inf;\n\t\t}\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tmn[0][j] = mn[1][j];\n\t\t\tmx[0][j] = mx[1][j];\n\t\t\tdp[0][j] = dp[1][j];\n\t\t}\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < m;i++){\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf 10e18\ntypedef long long ll;\n \nint main(void) {\n  ll i, j, k, n, m;\n  scanf(\"%lld%lld%lld\", &n, &m, &k);\n  ll a[n], **sum, dp[n];\n  sum = (ll**)malloc(sizeof(ll*) * (n + 10));\n  for(i = 0; i < n; ++i) sum[i] = (ll*)malloc(sizeof(ll) * (m + 10));\n  for(i = 0; i < n; ++i) scanf(\"%lld\", &a[i]);\n  for(i = 0; i < n; ++i) dp[i] = inf;\n  dp[0] = k;\n  for(i = 0; i < n; ++i) {\n    ll min = inf, max = 0;\n    for(j = 0; j < m; ++j) {\n      if(i - j >= 0) {\n        if(min > a[i - j]) min = a[i - j];\n        if(max < a[i - j]) max = a[i - j];\n        sum[i][j] = k + (j + 1) * (max - min);\n      }\n    }\n  }\n  for(i = 1; i < n; ++i) {\n    for(j = 0; j < m; ++j) {\n      if(i - j > 0) {\n        if(dp[i] > sum[i][j] + dp[i - j - 1]) dp[i] = sum[i][j] + dp[i - j - 1];\n      } else if(!(i - j)) {\n        if(dp[i] > sum[i][j]) dp[i] = sum[i][j];\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[n - 1]);\n  for(i = 0; i < n; ++i) free(sum[i]);\n  free(sum);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<30)\n#define INFLL (1ll<<60)\ntypedef pair<int, int> P;\ntypedef pair<int, P> E;\n#define MOD (1000000007ll)\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\tb += MOD;\n\ta += b;\n\ta %= MOD;\n}\n\nint n,m;\nll memo[22222],a[22222],k;\nbool done[22222];\n\nll solve(int i = 0){\n\tint j;\n\tll mx,mn;\n\tif(done[i]){\n\t\treturn memo[i];\n\t}\n\tdone[i] = true;\n\tif(i == n){\n\t\tmemo[i] = 0ll;\n\t\treturn 0ll;\n\t}\n\tmemo[i] = solve(i+1)+k;\n\tmx = a[i];\n\tmn = a[i];\n\tfor(j=2; j<=m; ++j){\n\t\tif(i+j>n){\n\t\t\tbreak;\n\t\t}\n\t\tmx = max(mx,a[i+j-1]);\n\t\tmn = min(mn,a[i+j-1]);\n\t\tmemo[i] = min(memo[i],solve(i+j)+k+(mx-mn)*j);\n\t}\n\treturn memo[i];\n}\n\nint main(void){\n\tint i;\n\tfill(done,done+22222,false);\n\tcin >> n >> m >> k;\n\tfor(i=0; i<n; ++i){\n\t\tcin >> a[i];\n\t}\n\tcout << solve() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nconst ll INF=0xfffffffffffffff;\nconst P PINF=P(INF,-INF);\nP dat[80000]; //min max\nll n;\n\nvoid init(ll n_){\n\tn=1;\n\twhile(n<n_) n*=2;\n\trep(i,2*n-1) dat[i]=P(INF,-INF);\n\treturn;\n}\n\nvoid update(ll x,ll a){\n\tx+=n-1;\n\tdat[x]=P(a,a);\n\twhile(x>0){\n\t\tx=(x-1)/2;\n\t\tdat[x]=P(min(dat[x*2+1].fr,dat[x*2+2].fr),max(dat[x*2+1].sc,dat[x*2+2].sc) );\n\t}\n\treturn;\n}\n\nP query(ll a,ll b,ll k,ll l,ll r){\n\tif(b<=l||r<=a) return PINF;\n\tif(a<=l&&r<=b) return dat[k];\n\tP chl=query(a,b,k*2+1,l,(l+r)/2);\n\tP chr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn P(min(chl.fr,chr.fr),max(chl.sc,chr.sc));\n}\n\n\nll N,M,K;\nll A[20000];\n\n\nll dp[20000];//i???????????§?????±??°?????????????°??????????\n\nll calc(ll id,ll kosu){ // id?????§kosu\n\tll res=0;\n\tif(id-kosu>=0) res+=dp[id-kosu];\n\tP p=query(id-kosu+1,id+1,0,0,n);\n\tres+=(p.sc-p.fr)*kosu+K;\n\t//if(res<0) cout<<id<<\" \"<<kosu<<\" \"<<p.fr<<\" \"<<p.sc<<endl;\n\treturn res;\n}\n\n\n\nint main()\n{\n\tcin>>N>>M>>K;\n\tinit(N);\n\trep(i,N){\n\t\tcin>>A[i];\n\t\tupdate(i,A[i]);\n\t\tdp[i]=INF;\n\t}\n\trep(i,N){\n\t\trep1(j,M){\n\t\t\tif(i+1<j) continue;\n\t\t\tdp[i]=min(dp[i],calc(i,j));\n\t\t}\n\t}\n\tcout<<dp[N-1]<<endl;\n\t//rep(i,n*2-1) cout<<i<<\"=\"<<dat[i].fr<<dat[i].sc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint a[20005];\nint dp[20005];\n\nint main()\n{\n    int N, M, K; cin >> N >> M >> K;\n\n    for (int i = 0; i < N; ++i) {\n        cin >> a[i];\n        dp[i + 1] = 1e9;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        int mi = 1e9, ma = -1e9;\n\n        for (int j = 0; j < M; ++j) {\n            if (i + j >= N) continue;\n\n            mi = min(mi, a[i + j]);\n            ma = max(ma, a[i + j]);\n\n            dp[i + j + 1] = min(dp[i + j + 1], dp[i] + (j + 1) * (ma - mi) + K);\n        }\n    }\n\n    cout << dp[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 200001\nconst int inf = 1e18;\n\nint mn[2][1010], mx[2][1010];\nint a[MAX], dp[2][1010];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tmn[0][j] = mn[1][j];mn[1][j] = inf;\n\t\t\tmx[0][j] = mx[1][j];mx[1][j] = 0;\n\t\t\tdp[0][j] = dp[1][j];dp[1][j] = inf;\n\t\t}\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < n;i++){\n\t\tif(dp[0][i] == inf)continue;\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, x, a[20009]; long long dp[20009];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &x);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint l = 1999999999, r = -1; dp[i] = 1LL << 60;\n\t\tfor (int j = 1; j <= m && i - j >= 0; j++) {\n\t\t\tl = min(l, a[i - j]);\n\t\t\tr = max(r, a[i - j]);\n\t\t\tdp[i] = min(dp[i], dp[i - j] + x + 1LL * j * (r - l));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : DPTest.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\nusing namespace std;\nint N,M,K;\nint A[20001]={};\nconst long long INF=100000000000000;\nlong long dp[20001]={};\nint maxdp[20001][1001]={};\nint mindp[20001][1001]={};\n\nint maxD(int n2,int n3){\n\tint ans2=A[n2+n3];\n\tif(maxdp[n2][n3]>0)return maxdp[n2][n3];\n\tif(n3>1)ans2=max(maxD(n2,n3-1),A[n2+n3]);\n\tmaxdp[n2][n3]=ans2;\n\treturn ans2;\n}\nint minD(int n2,int n3){\n\tint ans2=A[n2+n3];\n\tif(mindp[n2][n3]>0)return mindp[n2][n3];\n\tif(n3>1)ans2=min(minD(n2,n3-1),A[n2+n3]);\n\tmindp[n2][n3]=ans2;\n\treturn ans2;\n}\n\nlong long calc(int n1){\n\tlong long ans=INF;\n\tif(dp[n1]>-1)return dp[n1];\n\tfor(int i=1;i<M+1&&i<n1+1;i++){\n\t\tans=min(ans,calc(n1-i)+(long long)K+(long long)i*(long long)(maxD(n1-i,i)-minD(n1-i,i)));\n\t}\n\tdp[n1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\tfill(dp,dp+20001,-1);\n\tdp[0]=0;\n\tcout<<calc(N)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 200001\nconst int inf = 1e18;\n\nint mn[2][1001], mx[2][1001];\nint a[MAX], dp[2][1001];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\t/*for(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tmn[0][j] = mn[1][j];mn[1][j] = inf;\n\t\t\tmx[0][j] = mx[1][j];mx[1][j] = 0;\n\t\t\tdp[0][j] = dp[1][j];dp[1][j] = inf;\n\t\t}*/\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < n;i++){\n\t\tif(dp[0][i] == inf)continue;\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) (v).begin(), (v).end()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (int i = (a); i >= n; --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* typedef */\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<vii> viii;\ntypedef pair<int, int> pii;\ntypedef double D;\ntypedef complex<D> P;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; std::cin >> x; return x;}\ntemplate <typename T> void print(T x) {std::cout << x << '\\n';}\ntemplate <typename T>\nvoid print(std::vector<T>& v, std::string s = \" \") {\n  REP(i, v.size()) {\n    if (i != 0) std::cout << s;\n    std::cout << v[i];\n  }\n  std::cout << '\\n';\n}\n\n/* }}} */\n\nsigned main()\n{\n  ll n, m, k;\n  cin >> n >> m >> k;\n  vector<ll> A(n); REP(i, n) cin >> A[i];\n  vector<ll> dp(n + 1, LINF);\n  dp[0] = 0;\n\n  REP(i, n) {\n    ll a = -LINF, b = LINF;\n    for (int j = 1; j <= m && i + j <= n; ++j) {\n      a = max(a, A[i + j - 1]);\n      b = min(b, A[i + j - 1]);\n      dp[i + j] = min(dp[i + j], dp[i] + k + j * (a - b));\n    }\n  }\n  print(dp[n]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M,K;\nint A[20000];\n\nint dp[20001];\n\nsigned main(){\n    cin>>N>>M>>K;\n    rep(i,N)cin>>A[i];\n\n    for(int i=1;i<=N;i++){\n        int mi=1001001001,ma=0;\n        dp[i]=1001001001001001001001ll;\n        for(int j=1;j<=M&&i-j>=0;j++){\n            chmax(ma,A[i-j]);\n            chmin(mi,A[i-j]);\n            chmin(dp[i],dp[i-j]+K+j*(ma-mi));\n        }\n    }\n\n    cout<<dp[N]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing  ll =          long long int;\nusing ull = unsigned long long int;\nconst char en ='\\n';\nconst int  mod=1000000007;\n\nint n,m,k;\nvector<int> orangees,memo;\n\n\nint dfs(int index){\n\tif(index<0) return 0;\n\tif(index==0){\n\t\tmemo[0]=k;\n\t\treturn k;\n\t}\n\tif(memo[index]!=INT_MAX) return memo[index];\n\n\tint MIN=INT_MAX,MAX=INT_MIN;\n\tint start=max(index-m,0);\n\tfor(int i=index;i>=start;--i){\n\t\tMIN=min(MIN,orangees[i]);\n\t\tMAX=max(MAX,orangees[i]);\n\t\tmemo[index]=min(memo[index],dfs(i-1)+k+(index-i+1)*(MAX-MIN));\n\t}\n\treturn memo[index];\n}\nint main(){\n\tcin.tie();\n\tios::sync_with_stdio(false);\n\n\n\tcin>>n>>m>>k;\n\torangees=vector<int>(n);\n\tmemo    =vector<int>(n);\n\tfor(auto& i:orangees) cin>>i;\n\tfill_n(memo.begin(),n,INT_MAX);\n\n\tcout<<dfs(n-1)<<en;\n\n\tfor(int i=0;i<n;i++) cout<<memo[i]<<' ';\n\tcout<<en;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nlong long N,M,K;\nlong long A[20001]={};\nlong long dp[20001][1001];\nlong long maxD[20001][1001];\nlong long minD[20001][1001];\nconst long long INF=100000000000000000;\n\nlong long calc(long long n1,long long m1){\n\tlong long ans=INF;\n\tif(dp[n1][m1]>-1)return dp[n1][m1];\n\tif(m1>0){\n\t\tans=calc(n1,0)+K+m1*(maxD[n1][m1]-minD[n1][m1]);\n\t}else{\n\t\tfor(long long i=1;i<M+1&&i<n1+1;++i){\n\t\t\tans=min(ans,calc(n1-i,i));\n\t\t}\n\t}\n\tdp[n1][m1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(long long i=1;i<N+1;i++)cin>>A[i];\n\n\tfill(dp[0],dp[20001],-1);\n\tfor(int i=0;i<N+1;i++){\n\t\tmaxD[i][0]=0;\n\t\tminD[i][0]=INF;\n\t\tfor(int j=1;j<M+1;j++){\n\t\t\tmaxD[i][j]=max(maxD[i][j-1],A[i+j]);\n\t\t\tminD[i][j]=min(minD[i][j-1],A[i+j]);\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tlong long R;\n\tfor(int i=1;i<N+1;i++)R=calc(i,0);\n\tcout<<R<<endl;\n//\tcout<<calc(N,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<cassert>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define MAX 20010\n\nll dp[MAX];\nint N,M;\nll K,A[MAX];\n\nvoid computer() {\n  rep(i,N+1) dp[i] = LLONG_MAX;\n  rep(i,N) {\n    dp[i] = ((i-1>=0)?dp[i-1]:0) + K;\n    ll maxi = A[i];\n    ll mini = A[i];\n    for(int j=i-1;j>=0;--j) {\n      if( i - j + 1 > M ) break;\n      maxi = max(maxi,A[j]);\n      mini = min(mini,A[j]);\n      dp[i] = min(dp[i],((j-1>=0)?dp[j-1]:0)+K+(ll)(i-j+1) * ( maxi - mini ));\n    }\n  }\n  cout << dp[N-1] << endl;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  rep(i,N) cin >> A[i];\n  computer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : DPTest.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\nusing namespace std;\nint N,M,K;\nint A[20001]={};\nconst long long INF=100000000000000;\nlong long dp[20001]={};\nint maxdp[20001][1001]={};\nint mindp[20001][1001]={};\n\nint maxD(int n2,int n3){\n\tint ans2=A[n2+n3];\n\tif(maxdp[n2][n3]>0)return maxdp[n2][n3];\n\tif(n3>1)ans2=max(maxD(n2,n3-1),A[n2+n3]);\n\tmaxdp[n2][n3]=ans2;\n\treturn ans2;\n}\nint minD(int n2,int n3){\n\tint ans2=A[n2+n3];\n\tif(mindp[n2][n3]>0)return mindp[n2][n3];\n\tif(n3>1)ans2=min(minD(n2,n3-1),A[n2+n3]);\n\tmindp[n2][n3]=ans2;\n\treturn ans2;\n}\n\nlong long calc(int n1){\n\tlong long ans=INF;\n\tif(dp[n1]>-1)return dp[n1];\n\tfor(int i=1;i<M+1&&i<n1+1;i++){\n\t\tans=min(ans,calc(n1-i)+(long long)K+(long long)i*(long long)(maxD(n1-i,i)-minD(n1-i,i)));\n\t}\n\tdp[n1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\tfill(dp,dp+20001,-1);\n\tdp[0]=0;\n\tcout<<calc(N)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp [[[ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)s)\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)s)\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* ]]] */\n\nll n, m, k;\nll a[20000];\nll dp[20010];\n\nint main(){\n  cin >> n >> m >> k;\n  rep(i, n) cin >> a[i];\n  \n  fill_n(dp, 20010, inf_ll);\n  dp[0] = 0;\n  rep(i, n){\n    ll s = 0, mn = a[i], mx = a[i];\n    rep(j, i, min(i + m, n)){\n      s += a[j];\n      chmin(mn, a[j]);\n      chmax(mx, a[j]);\n      ll c = k + (j - i + 1) * (mx - mn);\n      chmin(dp[j + 1], dp[i] + c);\n    }\n  }\n  \n  cout << dp[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF (10000000000000000LL)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nint main()\n{\n    int N,M;\n    long long K;\n    cin >> N >> M >> K;\n\n    vector<long long> A;\n\n    for(int i=0; i<N; ++i) {\n        long long temp;\n        cin >> temp;\n        A.push_back(temp);\n    }\n\n    vector<long long> dp(N);\n    long long mx=-1;\n    long long mn=INF;\n    for(int i=0; i<N; ++i) { // initialize\n        mx=MAX(mx,A[i]);\n        mn=MIN(mn,A[i]);\n        if(i<M) dp[i]=K+(i+1)*(mx-mn);\n        else dp[i]=INF;\n    }\n\n    int indx=1;\n    while(indx<N) {\n        mx=-1; mn=INF;\n        long long temp=dp[indx];\n        for(int k=1; k<=M && indx-k>=0 ; ++k) { // add one more box\n            mx=MAX(mx,A[indx-k+1]);\n            mn=MIN(mn,A[indx-k+1]);\n            temp=MIN(temp,dp[indx-k]+K+k*(mx-mn));\n        }\n        if(dp[indx]==temp) ++indx;\n        else dp[indx]=temp;\n    }\n\n    cout << dp[N-1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 92234341346326\n#define ll long long\nusing namespace std;\nint main(){\n\tll A,B,N,M,K,MAX=0,MIN=INF;\n\tcin>>N>>M>>K;\n\tll cost[N+1]={0};\n\tll size[N+1]={0};\n\tfor (int A=0;A<=N;A++) cost[A]=INF;\n\tcost[0]=0;\n\tfor (A=1;A<=N;A++) cin>>size[A];\n\tfor (A=1;A<=N;A++){\n\t\tfor (B=0;B<M&&B<N;B++){\n\t\t\tfor (int C=A;C<=A+B&&C<N;C++){\n\t\t\t\tif (MAX<size[C]) MAX=size[C];\n\t\t\t\tif (MIN>size[C]) MIN=size[C];\n\t\t\t}\n\t\t\tcost[A+B]=min(cost[A+B],K+(1+B)*(MAX-MIN)+cost[A-1]);\n\t\t\tMAX=0;\n\t\t\tMIN=INF;\n\t\t}\n\t}\n\tcout<<cost[N]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint N,M,K;\nint64_t A[20000];\nconstexpr int64_t INF = 1000000000000000;\n\nint64_t dp[20000];\n//[i?????°??????\nint64_t func(int i)\n{\n\tif(i>=N){return 0;}\n\tif(dp[i]>0){return dp[i];}\n\t\n\tint64_t min=A[i],max=A[i];\n\tint64_t min_cost=INF;\n\tfor(int nexti = i+1,i_end=std::min(i+M,N);nexti<=i_end;++nexti)\n\t{\n\t\tmin_cost = std::min(min_cost,\n\t\t\tfunc(nexti)+K+int64_t(nexti-i)*(max-min));\n\t\tmin=std::min(min, A[nexti]);\n\t\tmax=std::max(max, A[nexti]);\n\t}\n\treturn dp[i]=min_cost;\n}\n\nint main()\n{\n\tstd::cin.sync_with_stdio(false);\n\tstd::cin >> N>>M>>K;\n\tfor(int i =0 ;i < N;++i){\n\t\tstd::cin >> A[i];\n\t}\n\tstd::cout << func(0)<<std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll > P;\n\nll N, M, K;\nll ookisa[20000];\nll dp[20000][1001];\n\nP get(int a,int b) {\n\tP res;\n\tif (a < 0)a = 0;\n\tres.first = *max_element(ookisa + a, ookisa + b + 1);\n\tres.second = *min_element(ookisa + a, ookisa + b + 1);\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < N; i++)cin >> ookisa[i];\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < M; j++)dp[i][j] = 1145141919810893;\n\n\tdp[0][M - 1] = K;\n\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP minmax = get(i - (M - j - 1), i + 1);\n\t\t\t\tdp[i + 1][j - 1] = min(dp[i + 1][j - 1],\n\t\t\t\t\tdp[i - (M - j - 1)][M - 1] + (M - j + 1) * (minmax.first - minmax.second));\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 1145141919810893;\n\n\tfor (int i = 0; i < M; i++)ans = min(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <iostream>\n//#include <cstdio>\n#define INF (1 << 30)\n#define MAX 10004\nusing namespace std;\n\nint dp[MAX], a[MAX];\nint main(){\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tfill(dp, dp+MAX, 0);\n\tfor(int i = 1;i <= n;i++)cin >> a[i];\n\tint s = 0, ss = 0, x = a[1], y = a[1];\n\tint num = 1, p = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\tif(a[i] > y)y = a[i];\n\t\tif(a[i] < x)x = a[i];\n\t\tif(num != m+1)s = p+k+num*(y-x);\n\t\telse s = INF;\n\t\tss = dp[i-1]+k;\n\t\tif(s < ss){\n\t\t\tdp[i] = s;\n\t\t\t//cout << \"+\";\n\t\t}else{\n\t\t\tdp[i] = ss;\n\t\t\tx = y = a[i];\n\t\t\tnum = 1;\n\t\t\tp = dp[i-1];\n\t\t\t//cout << \"-\";\n\t\t}\n\t\tnum++;\n\t\t//cout << s << \" \";\n\t}\n\tcout << dp[n] << endl;\n\t//cout << endl;\n\tfor(int i = 1;i <= n;i++){\n\t\t//cout << dp[i] << \" \";\n\t}\n\treturn 0;\n}\n/*\n6 3 6\n1\n2\n3\n1\n2\n1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF LLONG_MAX/3\n#define int long long\nusing namespace std;\n\nint dp[20001];\nint d[20000];\nsigned main() {\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tdp[0] = 0;\n\tfill(dp + 1, dp + a + 1, INF);\n\tfor (int e = 0; e < a; e++)scanf(\"%lld\", &d[e]);\n\tfor (int f = 0; f <a; f++) {\n\t\tint MIN = INF, MAX = 0;\n\t\tfor (int g = f + 1,sum=0; g <=a&&sum<b; g++,sum++) {\n\t\t\tMIN = min(MIN, d[g-1]);\n\t\t\tMAX = max(MAX, d[g-1]);\n\t\t\tdp[g] = min(dp[g], dp[f] + c + (g - f)*(MAX - MIN));\n\t\t}\n\t}\n\tcout << dp[a] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : DPTest.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\nusing namespace std;\nint N,M,K;\nint A[20001]={};\nconst long long INF=1000000000;\nlong long dp[20001]={};\nint maxdp[20001][1001]={};\nint mindp[20001][1001]={};\n\nint maxD(int n2,int n3){\n\tint ans2=A[n2+n3];\n\tif(maxdp[n2][n3]>0)return maxdp[n2][n3];\n\tif(n3>1)ans2=max(maxD(n2,n3-1),A[n2+n3]);\n\tmaxdp[n2][n3]=ans2;\n\treturn ans2;\n}\nint minD(int n2,int n3){\n\tint ans2=A[n2+n3];\n\tif(mindp[n2][n3]>0)return mindp[n2][n3];\n\tif(n3>1)ans2=min(minD(n2,n3-1),A[n2+n3]);\n\tmindp[n2][n3]=ans2;\n\treturn ans2;\n}\n\nlong long calc(int n1){\n\tlong long ans=INF;\n\tif(dp[n1]>-1)return dp[n1];\n\tfor(int i=1;i<M+1&&i<n1+1;i++){\n\t\tans=min(ans,calc(n1-i)+(long long)K+(long long)i*(long long)(maxD(n1-i,i)-minD(n1-i,i)));\n\t}\n\tdp[n1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\tfill(dp,dp+20001,-1);\n\tdp[0]=0;\n\tcout<<calc(N)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using lim = numeric_limits<T>;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    ll k;\n    cin >> n >> m >> k;\n    vector<ll> A(n + 1);\n    for(int i = 1; i <= n; i++) {\n        cin >> A[i];\n    }\n    vector<ll> mem(n + 1, -1);\n    function<ll(int)> opt = [&](int i) {\n        ll& ans = mem[i];\n        if(ans == -1) {\n            if(i == 0) {\n                ans = 0;\n            } else {\n                ll a = A[i], b = A[i];\n                ans = lim<ll>::max();\n                for(int j = i - 1; j >= 0 and (i - j) <= m; j--) {\n                    ans = min(ans, opt(j) + k + (i - j) * (a - b));\n                    a = max(a, A[j]), b = min(b, A[j]);\n                }\n            }\n        }\n        return ans;\n    };\n    cout << opt(n) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 99999999999\n\n\nll** memo;\n\nenum Type{\n\tmax_value,\n\tmin_value,\n};\n\nstruct RMQ{\n\tvoid set(ll arg_minimum,ll arg_maximum){\n\t\tminimum = arg_minimum;\n\t\tmaximum = arg_maximum;\n\t}\n\tll minimum,maximum;\n};\n\nint N = 1;\nRMQ* Tree;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int index, ll orange){\n\n\tindex += N-1;\n\n\tTree[index].minimum = min(Tree[index].minimum,orange);\n\tTree[index].maximum = max(Tree[index].maximum,orange);\n\n\tindex = (index-1)/2;\n\n\twhile(true){\n\n\t\tTree[index].minimum = min(Tree[2*index+1].minimum,Tree[2*index+2].minimum);\n\t\tTree[index].maximum = max(Tree[2*index+1].maximum,Tree[2*index+2].maximum);\n\n\t\tif(index == 0)break;\n\t\telse{\n\t\t\tindex = (index-1)/2;\n\t\t}\n\t}\n}\n\n\nll find(int search_left,int search_right,int node_id,int node_left,int node_right,Type type){\n\n\tif(search_right < node_left || search_left > node_right){\n\t\tif(type == max_value){\n\t\t\treturn -1;\n\t\t}else{ //type == min_value;\n\t\t\treturn NUM;\n\t\t}\n\t}\n\n\tif(search_left <= node_left && search_right >= node_right){\n\t\tif(type == max_value){\n\t\t\treturn Tree[node_id].maximum;\n\t\t}else{\n\t\t\treturn Tree[node_id].minimum;\n\t\t}\n\t}\n\n\tif(type == min_value){\n\t\tll left_min = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_min = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn min(left_min,right_min);\n\t}else{ //type == max_value\n\t\tll left_max = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_max = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn max(left_max,right_max);\n\t}\n}\n\nint first_N,contain_Max,box_Cost;\n\nll recursive(int left,int width){\n\n\tll ret,next = NUM;\n\tif(memo[left][width] != -1){\n\t\treturn memo[left][width];\n\t}else{\n\n\t\tll min_orange = find(left,min(N-1,left+width-1),0,0,N-1,min_value);\n\t\tll max_orange = find(left,min(N-1,left+width-1),0,0,N-1,max_value);\n\t\tret = box_Cost+width*(max_orange-min_orange);\n\t}\n\n\tif(left + width <= first_N-1){\n\t\tfor(int i = 1; i <= contain_Max; i++){\n\t\t\tnext = min(next,recursive(left+width,i));\n\t\t}\n\t\treturn memo[left][width] = ret + next;\n\t}else{\n\t\treturn memo[left][width] = ret;\n\t}\n}\n\nvoid func(){\n\n\tll ans = NUM;\n\n\tfor(int i = 1; i <= contain_Max; i++){\n\t\tans = min(ans,recursive(0,i));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %lld\",&first_N,&contain_Max,&box_Cost);\n\n\tinit(first_N);\n\n\tmemo = new ll*[first_N];\n\tfor(int i = 0; i < first_N; i++){\n\t\tmemo[i] = new ll[contain_Max+1];\n\t\tfor(int k = 0; k <= contain_Max; k++)memo[i][k] = -1;\n\t}\n\n\tTree = (RMQ*)malloc(sizeof(RMQ)*(2*N));\n\n\tfor(int i = 0; i < 2*N-1; i++){\n\t\tTree[i].set(NUM,-1);\n\t}\n\n\tll tmp;\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld\",&tmp);\n\t\tupdate(i,tmp);\n\t}\n\n\tfunc();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 200001\nconst int inf = 1e18;\n\nint mn[2][1010], mx[2][1010];\nint a[MAX], dp[2][1010];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tmn[1][j] = inf;\n\t\t\tmx[1][j] = 0;\n\t\t\tdp[1][j] = inf;\n\t\t}\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tmn[0][j] = mn[1][j];\n\t\t\tmx[0][j] = mx[1][j];\n\t\t\tdp[0][j] = dp[1][j];\n\t\t}\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < m;i++){\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20001]{},d[20000];signed main() {int a, b, c;cin >> a >> b >> c;fill(dp + 1,dp + a + 1, LLONG_MAX/3);for (int e = 0; e < a; e++)scanf(\"%lld\", &d[e]);for (int f = 0; f <a; f++) {int MIN = LLONG_MAX/3, MAX = 0;for (int g = f + 1,sum=0; g <=a&&sum<b; g++,sum++) {MIN = min(MIN, d[g-1]);MAX = max(MAX, d[g-1]);dp[g] = min(dp[g], dp[f] + c + (g - f)*(MAX - MIN));}}cout << dp[a] << endl;}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nconst ll INF=0xfffffffffffffff;\nconst P PINF=P(INF,-INF);\nP dat[80000]; //min max\nll n;\n\nvoid init(ll n_){\n\tn=1;\n\twhile(n<n_) n*=2;\n\trep(i,2*n-1) dat[i]=P(INF,-INF);\n\treturn;\n}\n\nvoid update(ll x,ll a){\n\tx+=n-1;\n\tdat[x]=P(a,a);\n\twhile(x>0){\n\t\tx=(x-1)/2;\n\t\tdat[x]=P(min(dat[x*2+1].fr,dat[x*2+2].fr),max(dat[x*2+1].sc,dat[x*2+2].sc) );\n\t}\n\treturn;\n}\n\nP query(ll a,ll b,ll k,ll l,ll r){\n\tif(b<=l||r<=a) return PINF;\n\tif(a<=l&&r<=b) return dat[k];\n\tP chl=query(a,b,k*2+1,l,(l+r)/2);\n\tP chr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn P(min(chl.fr,chr.fr),max(chl.sc,chr.sc));\n}\n\n\nll N,M,K;\nll A[20000];\n\n\nll dp[20000];//i???????????§?????±??°?????????????°??????????\n\nll calc(ll id,ll kosu){ // id?????§kosu\n\tll res=0;\n\tif(id-kosu>=0) res+=dp[id-kosu];\n\tP p=query(id-kosu+1,id+1,0,0,n);\n\tres+=(p.sc-p.fr)*kosu+K;\n\t//if(res<0) cout<<id<<\" \"<<kosu<<\" \"<<p.fr<<\" \"<<p.sc<<endl;\n\treturn res;\n}\n\n\n\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&N,&M,&K);\n\tinit(N);\n\trep(i,N){\n\t\tscanf(\"%lld\",&A[i]);\n\t\tupdate(i,A[i]);\n\t\tdp[i]=INF;\n\t}\n\trep(i,N){\n\t\trep1(j,M){\n\t\t\tif(i+1<j) continue;\n\t\t\tdp[i]=min(dp[i],calc(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[N-1]);\n\t//rep(i,n*2-1) cout<<i<<\"=\"<<dat[i].fr<<dat[i].sc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint N,M,K;\nint A[20001]={};\nconst long long INF=100000000000000;\nlong long dp[20001]={};\nint maxdp[20001][1001]={};\nint mindp[20001][1001]={};\n\nint maxD(int n2,int n3){\n\tint ans2=A[n2+n3];\n\tif(maxdp[n2][n3]>0)return maxdp[n2][n3];\n\tif(n3>1)ans2=max(maxD(n2,n3-1),A[n2+n3]);\n\tmaxdp[n2][n3]=ans2;\n\treturn ans2;\n}\nint minD(int n2,int n3){\n\tint ans2=A[n2+n3];\n\tif(mindp[n2][n3]>0)return mindp[n2][n3];\n\tif(n3>1)ans2=min(minD(n2,n3-1),A[n2+n3]);\n\tmindp[n2][n3]=ans2;\n\treturn ans2;\n}\n\nlong long calc(int n1){\n\tlong long ans=INF;\n\tif(dp[n1]>-1)return dp[n1];\n\tfor(int i=1;i<M+1&&i<n1+1;i++){\n\t\tans=min(ans,calc(n1-i)+(long long)K+(long long)i*(long long)(maxD(n1-i,i)-minD(n1-i,i)));\n\t}\n\tdp[n1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\tfill(dp,dp+20001,-1);\n\tdp[0]=0;\n\tcout<<calc(N)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<cmath>\n#define int long long\n#define mod 1000000007\n#define for0(i, n) for(int i = 0; i < (n); i++)\n#define for1(i, n) for(int i = 1; i <= (n);i++)\nusing namespace std;\nint dp[21000], ar[21000], n, m, k;\nsigned main() {\n\tcin>>n>>m>>k;\n\tfor1(i, n)cin>>ar[i];\n\tfor(int i=2;i<=n+1;i++){\n\t\tdp[i]=dp[i-1]+k;\n\t\tint a=ar[i-1],b=ar[i-1];\n\t\tfor(int j=1;j<=min(m, i-1);j++){\n\t\t\ta=max(a,ar[i-j]);\n\t\t\tb=min(b,ar[i-j]);\n\t\t\tdp[i]=min(dp[i],dp[i-j]+k+j*(a-b));\n\t\t}\n\t}\n\tcout<<dp[n+1]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 99999999999999\n\n\nll* memo;\n\nenum Type{\n\tmax_value,\n\tmin_value,\n};\n\nstruct RMQ{\n\tvoid set(ll arg_minimum,ll arg_maximum){\n\t\tminimum = arg_minimum;\n\t\tmaximum = arg_maximum;\n\t}\n\tll minimum,maximum;\n};\n\nint N = 1;\nRMQ* Tree;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int index, ll orange){\n\n\tindex += N-1;\n\n\tTree[index].minimum = min(Tree[index].minimum,orange);\n\tTree[index].maximum = max(Tree[index].maximum,orange);\n\n\tindex = (index-1)/2;\n\n\twhile(true){\n\n\t\tTree[index].minimum = min(Tree[2*index+1].minimum,Tree[2*index+2].minimum);\n\t\tTree[index].maximum = max(Tree[2*index+1].maximum,Tree[2*index+2].maximum);\n\n\t\tif(index == 0)break;\n\t\telse{\n\t\t\tindex = (index-1)/2;\n\t\t}\n\t}\n}\n\n\nll find(int search_left,int search_right,int node_id,int node_left,int node_right,Type type){\n\n\tif(search_right < node_left || search_left > node_right){\n\t\tif(type == max_value){\n\t\t\treturn -1;\n\t\t}else{ //type == min_value;\n\t\t\treturn NUM;\n\t\t}\n\t}\n\n\tif(search_left <= node_left && search_right >= node_right){\n\t\tif(type == max_value){\n\t\t\treturn Tree[node_id].maximum;\n\t\t}else{\n\t\t\treturn Tree[node_id].minimum;\n\t\t}\n\t}\n\n\tif(type == min_value){\n\t\tll left_min = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_min = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn min(left_min,right_min);\n\t}else{ //type == max_value\n\t\tll left_max = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_max = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn max(left_max,right_max);\n\t}\n}\n\nll box_Cost;\nint first_N,contain_Max;\n\nll recursive(int left){\n\n\tif(left >= first_N)return 0;\n\n\tif(memo[left] != -1){\n\t\treturn memo[left];\n\t}else{\n\n\t\tll ret = NUM;\n\t\tll min_orange,max_orange;\n\n\t\tfor(int i = 1; i <= contain_Max; i++){\n\t\t\tif(left+i > first_N)continue;\n\n\t\t\t min_orange = find(left,min(N-1,left+i-1),0,0,N-1,min_value);\n\t\t\t max_orange = find(left,min(N-1,left+i-1),0,0,N-1,max_value);\n\t\t\t ret = min(ret,recursive(left+i) + i*(max_orange-min_orange)+box_Cost);\n\t\t}\n\t\treturn memo[left] = ret;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d %lld\",&first_N,&contain_Max,&box_Cost);\n\n\tinit(first_N);\n\n\tmemo = new ll[first_N];\n\tfor(int i = 0; i < first_N; i++){\n\t\tmemo[i] = -1;\n\t}\n\n\tTree = (RMQ*)malloc(sizeof(RMQ)*(2*N));\n\n\tfor(int i = 0; i < 2*N-1; i++){\n\t\tTree[i].set(NUM,-1);\n\t}\n\n\tll tmp;\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld\",&tmp);\n\t\tupdate(i,tmp);\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nll dp[20001], n, m, k, a[20000];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 1000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=10000000000;\n\t\tfor (ll y = i; y < i + x; y++) {\n\t\t\tma = max(ma, a[y]);\n\t\t\tmi = min(mi, a[y]);\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll LLINF = 1LL << 60;\nint main()\n{\n    ll N, M, K;\n    ll dp[20005];\n    ll A[20005];\n    fill_n(dp, 20005, LLINF);\n    cin >> N >> M >> K;\n    dp[0] = 0;\n    for(ll i = 0; i < N; i++) cin >> A[i];\n    for(ll i = 0; i < N; i++) {\n        ll maxv = -1, minv = LLINF;\n        for(ll j = 0; j < M; j++) {\n            maxv = max(A[i + j], maxv);\n            minv = min(A[i + j], minv);\n            dp[i + j + 1] = min(dp[i + j + 1], dp[i] + K + (j + 1) * (maxv - minv));\n        }\n    }\n    cout << dp[N] << endl;\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\n\n\nint N, M;\nll K, a[20000];\nll dp[20005];\n\nint main() {\n\tcin >> N >> M >> K;\n\trep(i, N) {\n\t\tcin >> a[i];\n\n\t\tdp[i + 1] = 1ll << 60;\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\n\t\tll amx = 0, amn = 1ll << 60;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (i + j >= N) break;\n\n\t\t\tamx = max(amx, a[i + j]);\n\t\t\tamn = min(amn, a[i + j]);\n\n\t\t\tdp[i + j + 1] = min(dp[i + j + 1], dp[i] + (K + (amx - amn)*(j + 1)));\n\t\t}\n\t}\n\n\tcout << dp[N] << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define ALL(obj) obj.begin(), obj.end()\n\nconst int iINF = 1e9;\nconst long long llINF = 1e18;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\ntemplate <typename T>\nint getFormer(const vector<T> &vec, T x) {\n    return upper_bound(vec.begin(), vec.end(), x) - vec.begin() - 1;\n}\n\ntemplate <typename T>\nint getLatter(const vector<T> &vec, T x) {\n    return lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n}\n\nint N, M, K;\nlong long A[20010], dp[20010];\n\nint main() {\n    cin >> N >> M >> K;\n    REP(i, N) { cin >> A[i]; }\n    fill_n(dp, 20010, llINF);\n    dp[0] = 0;\n\n    REP(i, N) {\n        long long mx = A[i], mn = A[i];\n        for (int j = 1; j < M + 1; j++) {\n            if (i + j < N + 1) {\n                dp[i + j] = min(dp[i + j], dp[i] + j * (mx - mn) + K);\n                mx = max(mx, A[i + j]);\n                mn = min(mn, A[i + j]);\n            }\n        }\n    }\n\n    cout << dp[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N, M, K;\nlong long int num[20001];\nlong long int dp[20001];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> M >> K;\n\tfor (int i = 1; i <= N; i++)cin >> num[i];\n\tfor (int i = 1; i <= N; i++)dp[i] = LLONG_MAX;\n\tfor (int i = 0; i < N; i++) {\n\t\tset<long long int >S;\n\t\tfor (int j = i + 1; j <= min(i + M, N); j++) {\n\t\t\tS.insert(num[j]);\n\t\t\tdp[j] = min(dp[j], dp[i] + K + (j - i)*(*S.rbegin() - *S.begin()));\n\t\t}\n\t}\n\tcout << dp[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nLL dp[20010];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, M, K;\n  cin >> N >> M >> K;\n  VL xs(N);\n  REP(i,N) cin >> xs[i];\n\n  dp[0] = 0;\n  REP(i,N){\n\tLL mx = xs[i], mn = xs[i];\n\tLL best = dp[i] + K;\n\tfor(int j=1;j<=min(M,i+1ll);++j){\n\t  maxi(mx, xs[i+1-j]);\n\t  mini(mn, xs[i+1-j]);\n\t  mini(best, dp[i+1-j] + K + (mx - mn) * j);\n\t}\n\tdp[i+1] = best;\n  }\n\n  cout << dp[N] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 3e18;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, K;\nint A[20005];\nint memo[20005];\n\ninline int rec(int now)\n{\n    if (~memo[now]) return memo[now];\n\n    int res = inf;\n    int mi = inf, ma = -inf;\n    \n    for (int i = 0, to = min(N - now, M); i < to; ++i) {\n        mi = min(mi, A[now + i]);\n        ma = max(ma, A[now + i]);\n\n        res = min(res, K + (ma - mi) * (i + 1) + rec(now + i + 1));\n    }\n\n    if (res == inf) res = 0;\n\n    return memo[now] = res;\n}\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    omajinai;\n    cin >> N >> M >> K;\n\n    rep(i, N) {\n        cin >> A[i];\n    }\n\n    memset(memo, -1, sizeof (memo));\n\n    cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nll dp[20001], a[20000];\nint main() {\n\tll n, m, k; scanf(\"%lld%lld%lld\", &n, &m, &k);\n\trep(i, n)scanf(\"%lld\", &a[i]);\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\trep(i, n) {\n\t\tll Min = INT_MAX, Max = 0;\n\t\tfor (ll j = 0; j < m&&j + i < n; j++) {\n\t\t\tMin = min(Min, a[j + i]);\n\t\t\tMax = max(Max, a[j + i]);\n\t\t\tdp[i + j + 1] = min(dp[i + j + 1], dp[i] + (Max - Min)*(j + 1) + k);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1ll<<60;\n\nint main(){\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<int> a(n);\n    for(int i = 0; i < n; i++)  cin >> a[i];\n\n    vector<ll> dp(n+1, INF);\n    dp[0] = 0;\n    for(int pi = 1; pi <= n; pi++){\n        int i = pi - 1;\n        int low = 1<<30, high = -1;\n        for(int j = 0; j < min(m, pi); j++){\n            low = min(low, a[i-j]);\n            high = max(high, a[i-j]);\n            dp[pi] = min(dp[pi], dp[pi-j-1] + k + (ll)(high-low)*(j+1));\n        }\n    }\n\n    cout << dp[n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint main(void)\n{\n\tint n,m,k,a[20001],i,j,mx,mi;\n\tlong long dp[20001];\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(i=1;i<=n;i++)\tscanf(\"%d\",&a[i]);\n\tfor(i=0;i<=n;i++)\tdp[i]=(long long)i*k;\n\tfor(i=0;i<n;i++)\t{\n//\t\tfor(j=0;j<=n;j++)\tprintf(\"%lld \",dp[j]);\tprintf(\"\\n\");\n\t\tmx=a[i+1];\tmi=a[i+1];\n\t\tfor(j=1;j<=m;j++)\t{\n\t\t\tif(j+i>n)\tbreak;\n\t\t\tmx=max(mx,a[i+j]);\n\t\t\tmi=min(mi,a[i+j]);\n\t\t\tdp[i+j]=min(dp[i+j],dp[i]+k+(long long)j*(mx-mi));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint a[20005];\nlong long dp[20005];\n\nint main()\n{\n    int N, M, K; cin >> N >> M >> K;\n\n    for (int i = 0; i < N; ++i) {\n        cin >> a[i];\n        dp[i + 1] = 3e18;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        int mi = 1e9, ma = -1e9;\n\n        for (int j = 0; j < M; ++j) {\n            if (i + j >= N) continue;\n\n            mi = min(mi, a[i + j]);\n            ma = max(ma, a[i + j]);\n\n            dp[i + j + 1] = min(dp[i + j + 1], dp[i] + (j + 1) * (ma - mi) + K);\n        }\n    }\n\n    cout << dp[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\n\nsigned main(void) {\n    int n,m,k;\n    cin >> n >> m >> k;\n    vi a(n);\n    rep(i,n)cin >> a[i];\n    vi dp(n+1,LINF);\n    rep(i,n){\n        int ma = 0;\n        int mi = INF;\n        rep(j,m)if(i-j >= 0){\n            //i-jについてかんがえる\n            ma = max(ma, a[i-j]);\n            mi = min(mi, a[i-j]);\n            int cost = k + (j+1)*(ma-mi);\n            if(i-j)cost += dp[i-j-1];\n            dp[i] = min(dp[i], cost);\n        }\n        //cout << i << \" \" << dp[i] << endl;\n    }\n    cout << dp[n-1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : AOJ.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\nusing namespace std;\n\nconst long long INF=100000000000000;\nint main() {\n\tlong long N,M;\n\tlong long K;\n\tlong long A[20001];\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\n\n\tlong long oldDP[1000]={};\n\tlong long DP[1000]={};\n\tlong long oldDmax[1000]={};\n\tlong long oldDmin[1000]={};\n\tlong long Dmax[1000]={};\n\tlong long Dmin[1000]={};\n\n\tfor(long long j=1;j<N+1;j++){\n\t\tfor(long long i=1;i<M+1;i++){\n\t\t\toldDP[i]=DP[i];\n\t\t\toldDmax[i]=Dmax[i];\n\t\t\toldDmin[i]=Dmin[i];\n\t\t}\n\t\tDP[1]=INF;\n\t\tfor(long long i=2;i<M+1;i++){\n\t\t\tDmax[1]=A[j];\n\t\t\tDmin[1]=A[j];\n\t\t\tDmax[i]=max(oldDmax[i-1],A[j]);\n\t\t\tDmin[i]=min(oldDmin[i-1],A[j]);\n\t\t\tDP[1]=min(DP[1],oldDP[i]+K+i*(Dmax[i]-Dmin[i]));\n\t\t\tDP[i]=oldDP[i-1];\n\t\t}\n\t}\n\tlong long R=INF;\n\tfor(int i=1;i<M+1;i++){\n\t\tR=min(R,oldDP[i]+K+i*(Dmax[i]-Dmin[i]));\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\npair<ll, pair<ll, ll> > dp[2][1010];\nint main(void){\n\tint N, M, K;\n\tll A[20020];\n\tcin >> N >> M >> K;\n\tpair<ll, pair<ll, ll> > init = {INF_LL, {INF_LL, 0}};\n\tREP(i, 2){\n\t\tREP(j, 1010){\n\t\t\tdp[i][j] = init;\n\t\t}\n\t}\n\tREP(i, N){\n\t\tcin >> A[i];\n\t}\n\tdp[1][1] = {K, {A[0], A[0]}};\n\tFOR(i, 1, N){\n\t\tREP(j, 1010){\n\t\t\tdp[(i+1)%2][j] = init;\n\t\t}\n\t\tREP(j, min(i+1, M+1)){\n\t\t\tif(0 < j && j < M){\n\t\t\t\tll cost = dp[i%2][j].fst-j*(dp[i%2][j].snd.snd-dp[i%2][j].snd.fst)+(j+1)*(max(dp[i%2][j].snd.snd, A[i])-min(dp[i%2][j].snd.fst, A[i]));\n\t\t\t\tif(dp[(i+1)%2][j+1].fst > cost){\n\t\t\t\t\tdp[(i+1)%2][j+1] = {cost, {min(dp[i%2][j].snd.fst, A[i]), max(dp[i%2][j].snd.snd, A[i])}};\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cost = dp[i%2][j].fst + K;\n\t\t\tif(dp[(i+1)%2][1].fst > cost){\n\t\t\t\tdp[(i+1)%2][1] = {cost, {A[i], A[i]}};\n\t\t\t}\n\t\t}\n\t}\n\tll res = INF_LL;\n\tREP(i, M+1){\n\t\tres = min(dp[N%2][i].fst, res);\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nll N, M, K;\n// ?????°???????????¨ [i,j)???????°????????????§??????logn??§\nconst int NMAX = 1 << 18;\nint n, dat_min[2*NMAX-1], dat_max[2*NMAX-1];\nvoid init(int n_) {\n  n = 1;\n  while(n < n_) n *= 2;\n  FOR(i,0,2*n-1) {\n    dat_min[i] = 1e9;\n    dat_max[i] = 0;\n  }\n}\n// k????????????a?????????\nvoid update(int k, int a) {\n  k += n - 1;\n  dat_min[k] = a;\n  dat_max[k] = a;\n  while(k > 0) {\n    k = (k - 1) / 2;\n    dat_min[k] = min(dat_min[k*2+1],dat_min[k*2+2]);\n    dat_max[k] = max(dat_max[k*2+1],dat_max[k*2+2]);\n  }\n}\n// [l(????????????), r(??????))????????§???????°????query(l,r,0,0,n)\nint query(int a, int b, int k, int l, int r, bool MAX) {\n  if(r <= a || b <= l) return MAX ? 0 : 1e9;\n  if(a <= l && r <= b) return MAX ? dat_max[k] : dat_min[k];\n  else {\n    int vl = MAX ? query(a,b,k*2+1,l,(l+r)/2,1) : query(a,b,k*2+1,l,(l+r)/2,0);\n    int vr = MAX ? query(a,b,k*2+2,(l+r)/2,r,1) : query(a,b,k*2+2,(l+r)/2,r,0);\n    return MAX ? max(vl, vr) : min(vl, vr);\n  }\n}\nll dp[200005];\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> N >> M >> K;\n  init(N+1);\n  ll A[N];\n  FOR(i,0,N) {\n    cin >> A[i];\n    update(i + 1, A[i]);\n  }\n  FOR(i,0,N+1) dp[i] = 1e18;\n  dp[0] = 0;\n  FOR(i,1,N+1) {\n    FOR(j, max(1LL, i - M + 1), i + 1) {\n      dp[i] = min(dp[i], dp[j-1] + K + ll(i-j+1) * (query(j,i+1,0,0,n,1)-query(j,i+1,0,0,n,0)));\n    }\n  }\n  cout << dp[N] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      : \n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M,K;\nint A[20001]={};\nint minD[20001][1001]={};\nint maxD[20001][1001]={};\nlong long dp[20001];\nconst int INF=2000000000;\nconst long long INF2=1000000000000000000;\n\nint calmaxD(int n2,int n3){\n\tint ans=INF;\n\tif(maxD[n2][n3]>-1)return maxD[n2][n3];\n\tif(n3==0){\n\t\tans=0;\n\t}else{\n\t\tans=max(calmaxD(n2,n3-1),A[n2+n3]);\n\t}\n\tmaxD[n2][n3]=ans;\n\treturn ans;\n}\nint calminD(int n2,int n3){\n\tint ans=INF;\n\tif(minD[n2][n3]>-1)return minD[n2][n3];\n\tif(n3==0){\n\t\tans=INF;\n\t}else{\n\t\tans=min(calminD(n2,n3-1),A[n2+n3]);\n\t}\n\tminD[n2][n3]=ans;\n\treturn ans;\n}\nlong long calc(int n1){\n\tlong long ans=INF2;\n\tif(dp[n1]>-1)return dp[n1];\n\tfor(int i=1;i<M+1&&i<n1+1;++i){\n\t\tans=min(ans,calc(n1-i)+(long long)K+(long long)i*(long long)((calmaxD(n1-i,i)-calminD(n1-i,i))));\n\t}\n\n\tdp[n1]=ans;\n\treturn ans;\n}\n\nint main() {\n\tcin>>N>>M>>K;\n\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\tfill(minD[0],minD[20001],-1);\n\tfill(maxD[0],maxD[20001],-1);\n\tfill(dp,dp+20001,-1);\n\tdp[0]=0;\n\tcout << calc(N) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long dp[22000], a[22000], n, m, k;\nint main() {\n\tcin >> n >> m >> k; for (int i = 0; i < 22000; i++)dp[i] = 1LL << 62;\n\tfor (int i = 0; i < n; i++)cin >> a[i]; dp[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long minx = 1LL<<62, maxn = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (i - j < 0)break; minx = min(minx, a[i - j]); maxn = max(maxn, a[i - j]);\n\t\t\tdp[i] = min(dp[i], dp[i - j] + k + (maxn - minx)*j);\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : AOJ.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\nusing namespace std;\n\nconst long long INF=100000000000000;\nint main() {\n\tlong long N,M;\n\tlong long K;\n\tlong long A[20001];\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\n\n\tlong long oldDP[1000]={};\n\tlong long DP[1000]={};\n\tlong long oldDmax[1000]={};\n\tlong long oldDmin[1000]={};\n\tlong long Dmax[1000]={};\n\tlong long Dmin[1000]={};\n\n\tfor(long long j=1;j<N+1;j++){\n\t\tfor(long long i=1;i<M+1;i++){\n\t\t\toldDP[i]=DP[i];\n\t\t\toldDmax[i]=Dmax[i];\n\t\t\toldDmin[i]=Dmin[i];\n\t\t}\n\t\tDP[1]=INF;\n\t\tDmax[1]=A[j];\n\t\tDmin[1]=A[j];\n\n\t\tfor(long long i=2;i<M+1;i++){\n\t\t\tDmax[i]=max(oldDmax[i-1],A[j]);\n\t\t\tDmin[i]=min(oldDmin[i-1],A[j]);\n\t\t\tDP[i]=oldDP[i-1];\n\t\t}\n\t\tfor(long long i=1;i<M+1;i++){\n\t\t\tDP[1]=min(DP[1],oldDP[i]+K+i*(oldDmax[i]-oldDmin[i]));\n\t\t}\n\t}\n\tlong long R=INF;\n\tfor(int i=1;i<M+1;i++){\n\t\tR=min(R,oldDP[i]+K+i*(Dmax[i]-Dmin[i]));\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll a[20000], shou[80000], dai[80000], dp[20000], n, m, k2;\nconst ll inf = 99999999999999999;\nint start, ruend;\nll ma, mi;\nvoid query(int a, int b, int k, int l, int r) {\n\t//a??????b???????°????//k???l??\\???r??\\????????????\n\tif (b<l || a>r) return;\n\tif (l >= a&&r <= b) {\n\t\tma = max(ma, dai[k]);\n\t\tmi = min(mi, shou[k]);\n\t}\n\telse {\n\t\tquery(a, b, k * 2 + 1, l, floor((l + r) / 2.0));\n\t\tquery(a, b, k * 2 + 2, ceil((l + r) / 2.0), r);\n\t}\n}\nll solve(int i) {\n\tif (i == n) return 0;\n\tll sum = inf;\n\tfor (int j = 1; j <= m&&i + j <= n; j++) {\n\t\tll res = k2;\n\t\tma = -1;\n\t\tmi = inf;\n\t\tquery(start + i, start + i + j - 1, 0, start, ruend);\n\t\tres += (j*(ma - mi));\n\t\tif (dp[i + j] != -1) sum = min(sum, res + dp[i + j]);\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i + j] = solve(i + j)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tscanf(\"%LL %LL %LL\", &n, &m, &k2);\n\tfor (ll i = 0; i < n * 4; i++) {\n\t\tshou[i] = inf;\n\t\tdai[i] = -1;\n\t}\n\tll io = 0, iop = 1;\n\twhile (iop < n) {\n\t\tio += iop;\n\t\tiop *= 2;\n\t}\n\tstart = io;\n\truend = io + iop - 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%LL\", &a[i]);\n\t\tdp[i] = -1;\n\t\tshou[start + i] = a[i];\n\t\tdai[start + i] = a[i];\n\t}\n\tfor (int i = start - 1; i >= 0; i--) {\n\t\tshou[i] = min(shou[i * 2 + 1], shou[i * 2 + 2]);\n\t\tdai[i] = max(dai[i * 2 + 1], dai[i * 2 + 2]);\n\t}\n\tcout << solve(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : AOJ.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\nusing namespace std;\n\nconst long long INF=100000000000000;\nint main() {\n\tlong long N,M;\n\tlong long K;\n\tlong long A[20001];\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<N+1;i++)cin>>A[i];\n\n\n\tlong long oldDP[1000]={};\n\tlong long DP[1000]={};\n\tlong long oldDmax[1000]={};\n\tlong long oldDmin[1000]={};\n\tlong long Dmax[1000]={};\n\tlong long Dmin[1000]={};\n\n\tfor(long long j=1;j<N+1;j++){\n\t\tfor(long long i=1;i<M+1;i++){\n\t\t\toldDP[i]=DP[i];\n\t\t\toldDmax[i]=Dmax[i];\n\t\t\toldDmin[i]=Dmin[i];\n\t\t}\n\t\tDP[1]=INF;\n\t\tDmax[1]=A[j];\n\t\tDmin[1]=A[j];\n\n\t\tfor(long long i=2;i<M+1;i++){\n\t\t\tDmax[i]=max(oldDmax[i-1],A[j]);\n\t\t\tDmin[i]=min(oldDmin[i-1],A[j]);\n\t\t\tDP[i]=oldDP[i-1];\n\t\t}\n\t\tfor(long long i=1;i<M+1;i++){\n\t\t\tDP[1]=min(DP[1],oldDP[i]+K+i*(oldDmax[i]-oldDmin[i]));\n\t\t}\n\t}\n\tlong long R=INF;\n\tfor(int i=1;i<M+1;i++){\n\t\tR=min(R,DP[i]+K+i*(Dmax[i]-Dmin[i]));\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <cstdint>\n\nint N,M,K;\nint64_t A[20009];\n\nint64_t func(int i, int j, int64_t min_a, int64_t max_a)\n{\n\tif(i >= N){return (max_a - min_a)*(M - j)+K;}\n\tint64_t res = 0;\n\tif(j <= 0){\n\t\tres += (max_a - min_a)*(M - 0)+K;\n\t\tres += func(i+1, M-1, A[i],A[i]);\n\t}\n\telse{\n\t\tres += std::min([&](){\n\t\t\treturn (max_a - min_a)*(M - j)+K + func(i+1, M-1, A[i],A[i]);\n\t\t}(), [&](){\n\t\t\treturn func(i+1, j-1, std::min(min_a, A[i]), std::max(max_a, A[i]));\n\t\t}());\n\t}\n\treturn res;\n}\nint main ()\n{\n\tscanf(\"%d %d %d\", &N, &M, &K);\n\tfor(int i = 0;i < N;++i){\n\t\tscanf(\"%lld\", &A[i]);\n\t}\n\t\n\tprintf(\"%lld\\n\", func(1, M-1, A[0], A[0]));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<string, int> psi;\n\nstatic const int INF = 1LL << 60;\nstatic const int MAX_N = 20005;\n\nint n, m, k, A[MAX_N], dp[MAX_N];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> m >> k;\n    for (int i = 0; i < n; ++i) {\n        cin >> A[i];\n    }\n\n    fill(dp, dp + MAX_N, INF);\n    dp[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        int tmax = 0, tmin = INF;\n        for (int j = 1; j <= m && i + j <= n; ++j) {\n            tmax = max(tmax, A[i + j - 1]);\n            tmin = min(tmin, A[i + j - 1]);\n            dp[i + j] = min(dp[i + j], dp[i] + k + j * (tmax - tmin));\n        }\n    }\n\n    cout << dp[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst ll INF = 1e16;\n\ntemplate <typename T, bool f>\nclass sparse_table {\n\tint n;\n\tvector<vector<T>> t;\n\tT merge(const T& l, const T& r) {\n\t\treturn f ? max(l, r) : min(l, r);\n\t}\npublic:\n\tsparse_table(const vector<T>& b) {\n\t\tn = b.size();\n\t\tt.push_back(b);\n\t\tfor (int i = 2, j = 1; i <= n; i <<= 1, j++) {\n\t\t\tt.push_back(vector<T>());\n\t\t\tfor (int k = 0; k + i <= n; k++) {\n\t\t\t\tt[j].push_back(merge(t[j - 1][k], t[j - 1][k + i / 2]));\n\t\t\t}\n\t\t}\n\t}\n\tT find(int l, int r) {\n\t\tr++;\n\t\tassert(0 <= l && l < r && r <= n);\n\t\tunsigned int w = r - l;\n\t\tint i = 31 - __builtin_clz(w);\n\t\treturn merge(t[i][l], t[i][r - (1 << i)]);\n\t}\n\tT operator[](int id) {\n\t\treturn t[0][id];\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tvector<ll> A(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t}\n\tsparse_table<ll, true> st1(A);\n\tsparse_table<ll, false> st2(A);\n\tvector<ll> dp(N + 1, INF);\n\tdp[0] = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = max(0, i - M + 1); j <= i; j++) {\n\t\t\tdp[i + 1] = min(dp[i + 1], dp[j] + K + (i - j + 1) * (st1.find(j, i) - st2.find(j, i)));\n\t\t}\n\t}\n\tcout << dp[N] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll a[20000],dp[20001];\nll n, m, k;\nconst ll inf = 98989899898989;\nint main() {\n\tcin >> n >> m >> k;\n\tfor (ll i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tdp[i] = inf;\n\t}\n\tdp[n] = inf;\n\tdp[0] = 0;\n\tll mi, ma;\n\tfor (ll i = 0; i < n; i++) {\n\t\tma = a[i];\n\t\tmi = a[i];\n\t\tfor (ll j = 1; j <= m&&i + j <= n; j++) {\n\t\t\tma = max(ma, a[i + j - 1]);\n\t\t\tmi = min(mi, a[i + j - 1]);\n\t\t\tdp[i + j] = min(dp[i + j], (dp[i] + k + j*(ma - mi)));\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n\nstatic const int MOD = 1000000007;\nusing ll = int64_t;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<ll> v(n);\n    for (auto &&i : v) scanf(\"%li\", &i);\n    vector<ll> dp(n+1, INF<ll>);\n    dp[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        ll l = v[i], r = v[i];\n        for (int j = i; j >= max(0, i-m+1); --j) {\n            chmin(dp[i+1], dp[j]+(r-l)*(i-j+1)+k);\n            if(j) chmax(r, v[j-1]), chmin(l, v[j-1]);\n        }\n    }\n    cout << dp[n] << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nint main()\n{\n  int N, M, K, A[20000];\n  int64 dp[20001];\n  \n  scanf(\"%d %d %d\", &N, &M, &K);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &A[i]);\n  }\n\n  fill_n(dp, 20001, INF);\n  dp[0] = 0;\n  for(int i = 0; i < N; i++) {\n    int small = A[i], large = A[i];\n    for(int64 j = 0; j < min(M, N - i); j++) {\n      small = min(small, A[i + j]);\n      large = max(large, A[i + j]);\n      dp[i + j + 1] = min(dp[i + j + 1], dp[i] + K + (j + 1) * (large - small));\n    }\n  }\n  printf(\"%lld\\n\", dp[N]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 92234341346326\n#define ll long long\nusing namespace std;\nint main(){\n\tll A,B,N,M,K,a,U,flg=0,MAX=0,MIN=INF;\n\tcin>>N>>M>>K;\n\tll cost[N+1]={0};\n\tll size[N+1]={0};\n\tfor (int A=0;A<=N;A++) cost[A]=INF;\n\tcost[0]=0;\n\tfor (A=1;A<=N;A++) cin>>size[A];\n\tfor (A=1;A<=N;A++){\n\t\tfor (B=0;B<M&&B<=N;B++){\n\t\t\tfor (int C=A;C<=A+B&&C<=N;C++){\n\t\t\t\tif (MAX<size[C]) MAX=size[C];\n\t\t\t\tif (MIN>size[C]) MIN=size[C];\n\t\t\t}\n\t\t\tcost[A+B]=min(cost[A+B],K+(1+B)*(MAX-MIN)+cost[A-1]);\n\t\t\tMAX=0;\n\t\t\tMIN=INF;\n\t\t}\n\t}\n\tcout<<cost[N]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nlong long N,M,K;\nlong long A[20001]={};\nlong long dp[20001][1001];\nlong long maxD[20001][1001];\nlong long minD[20001][1001];\nconst long long INF=100000000000000000;\n\nlong long calc(long long n1,long long m1){\n\tlong long ans=INF;\n\tif(dp[n1][m1]>-1)return dp[n1][m1];\n\tif(m1>0){\n\t\tans=calc(n1,0)+K+m1*(maxD[n1][m1]-minD[n1][m1]);\n\t}else{\n\t\tfor(long long i=1;i<M+1&&i<n1+1;++i){\n\t\t\tans=min(ans,calc(n1-i,i));\n\t\t}\n\t}\n\tdp[n1][m1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(long long i=1;i<N+1;i++)cin>>A[i];\n\n\tfill(dp[0],dp[20001],-1);\n\tfor(int i=0;i<N+1;i++){\n\t\tmaxD[i][0]=0;\n\t\tminD[i][0]=INF;\n\t\tfor(int j=1;j<M+1;j++){\n\t\t\tmaxD[i][j]=max(maxD[i][j-1],A[i+j]);\n\t\t\tminD[i][j]=min(minD[i][j-1],A[i+j]);\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tlong long R;\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=0;j<M+1;j++)\n\t\tR=calc(i,j);\n\t}\n\tR=calc(N,0);\n\tcout<<R<<endl;\n//\tcout<<calc(N,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1000000000000000000\ntypedef long long LL;\nusing namespace std;\nLL N,M,K;\nLL ary[20010],dp[20010];\nint main(){\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<=N;i++){\n\t\tcin>>ary[i];\n\t}\n\tfill(dp,dp+N+1,INF);\n\tLL a,b;\n\tdp[0]=0;\n\tfor(int i=0;i<N;i++){\n\t\ta=b=ary[i+1];\n\t\tfor(int j=1;j<=M&&(i+j)<=N;j++){\n\t\t\ta=max(a,ary[i+j]);\n\t\t\tb=min(b,ary[i+j]);\n\t\t\tdp[i+j]=min(dp[i+j],dp[i]+K+j*(a-b));\n\t\t}\n\t}\n\tcout<<dp[N]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll a[20000], shou[80000], dai[80000], dp[20000], n, m, k2;\nconst ll inf = 99999999999999999;\nint start, ruend;\nll ma, mi;\nvoid update(int i, ll x) {\n\tshou[i] = x;\n\tdai[i] = x;\n\twhile (i > 0) {\n\t\ti = floor((i - 1) / 2.0);\n\t\tshou[i] = min(shou[i * 2 + 1], shou[i * 2 + 2]);\n\t\tdai[i] = max(dai[i * 2 + 1], dai[i * 2 + 2]);\n\t}\n}\nvoid query(int a, int b, int k, int l, int r) {\n\t//a??????b???????°????//k???l??\\???r??\\????????????\n\tif (b<l || a>r) return;\n\tif (l >= a&&r <= b) {\n\t\tma = max(ma, dai[k]);\n\t\tmi = min(mi, shou[k]);\n\t}\n\telse {\n\t\tquery(a, b, k * 2 + 1, l, floor((l + r) / 2.0));\n\t\tquery(a, b, k * 2 + 2, ceil((l + r) / 2.0), r);\n\t}\n}\nll solve(int i) {\n\tif (i == n) return 0;\n\tll sum = inf;\n\tfor (int j = 1; j <= m&&i + j <= n; j++) {\n\t\tll res = k2;\n\t\tma = -1;\n\t\tmi = inf;\n\t\tquery(start + i, start + i + j - 1, 0, start, ruend);\n\t\tres += (j*(ma - mi));\n\t\tif (dp[i + j] != -1) sum = min(sum, res + dp[i + j]);\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i + j] = solve(i + j)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tcin >> n >> m >> k2;\n\tfor (ll i = 0; i < n * 4; i++) {\n\t\tshou[i] = inf;\n\t\tdai[i] = -1;\n\t}\n\tll io = 0, iop = 1;\n\twhile (iop < n) {\n\t\tio += iop;\n\t\tiop *= 2;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tdp[i] = -1;\n\t\tupdate(io + i, a[i]);\n\t}\n\tstart = io;\n\truend = io + iop - 1;\n\tcout << solve(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, x, a[20009]; long long dp[20009];\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &x);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint l = 1999999999, r = -1; dp[i] = 1LL << 60;\n\t\tfor (int j = 1; j <= m && i - j >= 0; j++) {\n\t\t\tl = min(l, a[i - j]);\n\t\t\tr = max(r, a[i - j]);\n\t\t\tdp[i] = min(dp[i], dp[i - j] + x + j * (r - l));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:https://www.ioi-jp.org/joi/2015/2016-ho/2016-ho.pdf>\n?????????============================================================\nN(1<=N<=20000)???????????¬???????????????????????¬??????i?????§?????????Ai??§?????????\n\n???????????¬????????????????????????????????????????????±??????????????????????????¨?????????????????¨????????±??????\n??£?¶?????????????????????¬??????????????????????????¨?????§????????????\n\n?????¨????????±???????????§??§M(1<=M<=1000)?????§?????¬???????????????????????¨?????§??????\n??±????????¬?????????????????????????????????????????????????????±?????????????????§????????¬???????????§?????????a,\n??±????????????????°?????????¬???????????§?????????b, ??±?????????????????¬??????????????°???s??¨????????¨???, K+s*(a-b)??¨?????????\nK?????±???????????????????????§???????????¨????????±??§??±???\n\n??????????????°?????±?????¨?????????????????????????????¬????????????????????±??°??????????????¨??§??±??°???????????????\n???????????????????????§?????????????°????????????????\n=================================================================\n?§£??¬=============================================================\n================================================================\n*/\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M, K; cin >> N >> M >> K;\n\tvector<int> A(N); for (auto& in : A)cin >> in;\n\n\tvector<vector<pair<ll, pair<int, int>>>> dp(N + 1, vector<pair<ll, pair<int, int>>>(M + 1, { LINF,{-INF,INF} }));\n\tdp[0][0].first = 0;\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int j = 0; j < M;j++) {\n\t\t\tif (dp[i][j].first == LINF)continue;\n\t\t\tif (j != M-1 && i != N-1) {\n\t\t\t\tdp[i + 1][j + 1] = min(dp[i + 1][j + 1], { dp[i][j].first,{max(dp[i][j].second.first,A[i]),min(dp[i][j].second.second,A[i])} });\n\t\t\t}\n\t\t\tdp[i + 1][0] = min(dp[i + 1][0], { dp[i][j].first + (ll)K + (ll)(j+1)*((ll)max(dp[i][j].second.first,A[i]) - (ll)min(dp[i][j].second.second,A[i])),{-INF,INF} });\n\t\t}\n\t}\n\tcout << dp[N][0].first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\npair<ll, pair<ll, ll> > dp[20020][1010];\nint main(void){\n\tint N, M, K;\n\tll A[20020];\n\tcin >> N >> M >> K;\n\tpair<ll, pair<ll, ll> > init = {INF_LL, {INF_LL, 0}};\n\tREP(i, 20020){\n\t\tREP(j, 1010){\n\t\t\tdp[i][j] = init;\n\t\t}\n\t}\n\tREP(i, N){\n\t\tcin >> A[i];\n\t}\n\tdp[1][1] = {K, {A[0], A[0]}};\n\tFOR(i, 1, N){\n\t\tREP(j, min(i+1, M+1)){\n\t\t\tif(0 < j && j < M){\n\t\t\t\tll cost = dp[i][j].fst-j*(dp[i][j].snd.snd-dp[i][j].snd.fst)+(j+1)*(max(dp[i][j].snd.snd, A[i])-min(dp[i][j].snd.fst, A[i]));\n\t\t\t\tif(dp[i+1][j+1].fst > cost){\n\t\t\t\t\tdp[i+1][j+1] = {cost, {min(dp[i][j].snd.fst, A[i]), max(dp[i][j].snd.snd, A[i])}};\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cost = dp[i][j].fst + K;\n\t\t\tif(dp[i+1][1].fst > cost){\n\t\t\t\tdp[i+1][1] = {cost, {A[i], A[i]}};\n\t\t\t}\n\t\t}\n\t}\n\tll res = INF_LL;\n\tREP(i, M+1){\n\t\tres = min(dp[N][i].fst, res);\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll > P;\n\nll N, M, K;\nll ookisa[20000];\nll dp[20000][1001];\n\nP get(int a,int b) {\n\tP res;\n\tres.first = *max_element(ookisa + a, ookisa + b + 1);\n\tres.second = *min_element(ookisa + a, ookisa + b + 1);\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < N; i++)cin >> ookisa[i];\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < M; j++)dp[i][j] = 1145141919810893;\n\n\tdp[0][0] = K;\n\n\tfor (int i = 1; i < N ; i++) {\n\n\t\tP minmax;\n\t\tminmax.first = ookisa[i], minmax.second = ookisa[i];\n\n\t\tfor (int j = 1; j < M; j++) {\n\t\t\tif (i - j >= 0) {\n\t\t\t\tminmax.first = max(minmax.first, ookisa[i - j]);\n\t\t\t\tminmax.second = min(minmax.second, ookisa[i - j]);\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - j][0] + (j + 1) * (minmax.first - minmax.second));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tdp[i][0] = min(dp[i][0], dp[i - 1][j] + K);\n\t\t}\n\n\t}\n\n\tll ans = 1145141919810893;\n\n\tfor (int i = 0; i < M; i++)ans = min(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll a[20000], shou[80000], dai[80000], dp[20000], n, m, k2;\nconst ll inf = 99999999999999999;\nint start, ruend;\nll ma, mi;\nvoid query(int a, int b, int k, int l, int r) {\n\t//a??????b???????°????//k???l??\\???r??\\????????????\n\tif (b<l || a>r) return;\n\tif (l >= a&&r <= b) {\n\t\tma = max(ma, dai[k]);\n\t\tmi = min(mi, shou[k]);\n\t}\n\telse {\n\t\tquery(a, b, k * 2 + 1, l, floor((l + r) / 2.0));\n\t\tquery(a, b, k * 2 + 2, ceil((l + r) / 2.0), r);\n\t}\n}\nll solve(int i) {\n\tif (i == n) return 0;\n\tll sum = inf;\n\tfor (int j = 1; j <= m&&i + j <= n; j++) {\n\t\tll res = k2;\n\t\tma = -1;\n\t\tmi = inf;\n\t\tquery(start + i, start + i + j - 1, 0, start, ruend);\n\t\tres += (j*(ma - mi));\n\t\tif (dp[i + j] != -1) sum = min(sum, res + dp[i + j]);\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i + j] = solve(i + j)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tcin >> n >> m >> k2;\n\tfor (ll i = 0; i < n * 4; i++) {\n\t\tshou[i] = inf;\n\t\tdai[i] = -1;\n\t}\n\tll io = 0, iop = 1;\n\twhile (iop < n) {\n\t\tio += iop;\n\t\tiop *= 2;\n\t}\n\tstart = io;\n\truend = io + iop - 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tdp[i] = -1;\n\t\tshou[start + i] = a[i];\n\t\tdai[start + i] = a[i];\n\t}\n\tfor (int i = start - 1; i >= 0; i--) {\n\t\tshou[i] = min(shou[i * 2 + 1], shou[i * 2 + 2]);\n\t\tdai[i] = max(dai[i * 2 + 1], dai[i * 2 + 2]);\n\t}\n\tcout << solve(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n    int n,m,k;\n    int a[100];\n    int sum=0;\n    cin>>n>>m>>k;\n    \n    for(int i=0;i<n;i+=m){\n        for(int j=0;j<m;j++){\n            cin>>a[j];\n        }\n        sort(a,a+m);\n        sum+=k+m*(a[m-1]-a[0]);\n    }\n    cout<<sum<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 20001\nconst int inf = 1e18;\n\nint mn[2][1001], mx[2][1001];\nint a[MAX], dp[2][1001];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\t/*for(int j = 0;j < 2;j++){\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tif(dp[j][k] == inf)printf(\"* \");\n\t\t\t\telse printf(\"%lld \", dp[j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tmn[0][j] = mn[1][j];mn[1][j] = inf;\n\t\t\tmx[0][j] = mx[1][j];mx[1][j] = 0;\n\t\t\tdp[0][j] = dp[1][j];dp[1][j] = inf;\n\t\t}\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < n;i++){\n\t\tif(dp[0][i] == inf)continue;\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*宣言*/\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nlong long int oranges[20001];\nlong long int n, m, K;\nint main()\n{\n\tcin >> n >> m >> K;\n\tfor (int i = 1; i <= n; i++)cin >> oranges[i];\n\tlong long int dp[20001];\n\tmemset(dp, 120, sizeof(dp));\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long int MAX = oranges[i];\n\t\tlong long int MIN = oranges[i];\n\t\tfor (int j = 0; j < min(m,n-i+1); j++) {\n\t\t\tMAX = max(MAX, oranges[i + j]);\n\t\t\tMIN = min(MIN, oranges[i + j]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\t7/31\n\t\t\tdp[i+j] = min(dp[i+j], dp[i - 1] + K + (j+1)*(MAX - MIN));\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nlong long f(int);\nlong long dp[20000];\n\nint n,m;\nlong long k;\nlong long a[20000];\n\nint main(){\n\tint i;\n\t\n\tcin>>n>>m>>k;\n\tfor(i=0;i<n;i++){\n\t\tdp[i]=-1;\n\t\tcin>>a[i];\n\t}\n\t\n\tcout<<f(0)<<endl;\n\t\n\treturn 0;\n}\n\nlong long f(int d){\n\tif(d==n) return 0;\n\tif(dp[d]!=-1) return dp[d];\n\tlong long cost=-1;\t//????°??????????\n\tlong long tmp;\t//????????????????????§????????????\n\tlong long max=a[d],min=a[d];\t//???????????¬??????????????????????????¬??????\n\tfor(int i=1;i<=m;i++){\n\t\t\n\t\tif(d+i<=n){\n\t\t\ttmp=f(d+i);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t\tif(max<a[d+i-1]) max=a[d+i-1];\n\t\tif(min>a[d+i-1]) min=a[d+i-1];\n\t\ttmp+=k+i*(max-min);\n\t\t\n\t\tif(cost==-1 || tmp<cost) cost=tmp;\n\t}\n\tdp[d]=cost;return cost;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing  ll =          long long int;\nusing ull = unsigned long long int;\nconst char en ='\\n';\nconst int  mod=1000000007;\n\nint n,m,k;\nvector<int> orangees,memo;\n\n\nint dfs(int index){\n\tif(index<0) return 0;\n\tif(memo[index]!=INT_MIN) return memo[index];\n\n\tint MIN=INT_MAX,MAX=INT_MIN;\n\tint start=max(index-m,0);\n\tfor(int i=index;i>=start;--i){\n\t\tMIN=min(MIN,orangees[i]);\n\t\tMAX=max(MAX,orangees[i]);\n\t\tmemo[index]=min(memo[index],dfs(i-1)+k+(index-i+1)*(MAX-MIN));\n\t}\n\treturn 0;\n}\nint main(){\n\tcin.tie();\n\tios::sync_with_stdio(false);\n\n\tcin>>n>>m>>k;\n\torangees=vector<int>(n);\n\tmemo    =vector<int>(n);\n\tfor(auto& i:orangees) cin>>i;\n\tfill_n(memo.begin(),n,INT_MIN);\n\n\tcout<<dfs(n-1)<<en;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nlong long n,m,k,a[20002],b[20002],m2,min,max,i;\nint main(void)\n{\t\n\tscanf(\"%lld %lld %lld\",&n,&m,&k);\n\tfor(i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\tfor(i=0;i<=n+1;i++) b[i]=1000000000000000;\n\tm2=0; max=0; min=1000000000000000; b[0]=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(m2==m) m2=0, max=0, min=1000000000000000, i=i-(m-1);\n\t\tm2++;\n\t\tif(max<a[i]) max=a[i];\n\t\tif(min>a[i]) min=a[i];\n\t\tif(b[i]>b[i-m2]+k+m2*(max-min)) b[i]=b[i-m2]+k+m2*(max-min);\n\t\t//printf(\"i=%d m2=%d b[i]=%d %d\\n\",i,m2,b[i],k+m2*(max-min));\n\t\tif(i==n&&m2>1) i=i-(m2-1), m2=0, max=0, min=1000000000000000;\n\t}\n\t//for(i=1;i<=n;i++) printf(\"%d %lld\\n\",i,b[i]);\n\tprintf(\"%lld\\n\",b[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<iostream>\n#include<tuple>\n#include<utility>\n#include<set>\nusing namespace std;\ntypedef long long int llint;\nconst llint big=((llint)1<<(llint)60);\n#define mt make_tuple\n#define mp make_pair\n#define fi first\n#define se second\n#define pub push_back\n#define res resize\n//JOI 2016 oranges\n//K+s*(maxore-minore)\n//dp????????????\n//dp[i]=i???????????§??°??????\n//TLE?????????\n//0 1 2\nint main(void){\n\tllint N,M,K,i,j,maxore,minore;\n\tllint ore[20001]={0};\n\tllint dp[20001]={0};\n\tcin>>N>>M>>K;\n\tfor(i=0;i<N;i++){\n\t\tdp[i+1]=big;\n\t\tcin>>ore[i];\n\t\tmaxore=0;\n\t\tminore=big;\n\t\tfor(j=i;j>max((llint)-1,i-M);j--){\n\t\t\tmaxore=max(maxore,ore[j]);\n\t\t\tminore=min(minore,ore[j]);\n\t\t\tdp[i+1]=min(dp[i+1],K+(i-j+1)*(maxore-minore)+dp[j]);\n\t\t}\n\t\t//cout<<\"de\"<<dp[i+1]<<endl;\n\t}\n\tcout<<dp[N]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing  ll =          long long int;\nusing ull = unsigned long long int;\nconst char en ='\\n';\nconst int  mod=1000000007;\n\nint n,m,k;\nvector<int> orangees,memo;\n\n\nint dfs(int index){\n\tif(index<0) return 0;\n\tif(index==0){\n\t\tmemo[0]=k;\n\t\treturn k;\n\t}\n\tif(memo[index]!=INT_MAX) return memo[index];\n\n\tint MIN=INT_MAX,MAX=INT_MIN;\n\tint start=max(index-m,0);\n\tfor(int i=index;i>=start;--i){\n\t\tMIN=min(MIN,orangees[i]);\n\t\tMAX=max(MAX,orangees[i]);\n\t\tmemo[index]=min(memo[index],dfs(i-1)+k+(index-i+1)*(MAX-MIN));\n\t}\n\treturn memo[index];\n}\nint main(){\n\tcin.tie();\n\tios::sync_with_stdio(false);\n\n\n\tcin>>n>>m>>k;\n\torangees=vector<int>(n);\n\tmemo    =vector<int>(n);\n\tfor(auto& i:orangees) cin>>i;\n\tfill_n(memo.begin(),n,INT_MAX);\n\n\tcout<<dfs(n-1)<<en;\n\t\n\t/*\n\tfor(int i=0;i<n;i++) cout<<memo[i]<<' ';\n\tcout<<en;\n\t*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<vector>\ntemplate<typename T> class SparseTable {\n public:\n  explicit SparseTable(const std::vector<T>& v, const std::function<bool(T, T)>& F = std::less<T>()) : V(v), F(F), table_(v.size()) {\n    for(auto i = 0; i < v.size(); ++i) table_[0].emplace_back(i);\n    for(auto i = 1; pow2(i) <= v.size(); ++i) {\n      for(auto j = 0; j + pow2(i) - 1 < v.size(); ++j) {\n        auto a = table_[i - 1][j + pow2(i - 1)];\n        auto b = table_[i - 1][j];\n        table_[i].emplace_back(F(v[a], v[b]) ? a : b);\n      }\n    }\n  }\n  T index(int l, int r) const {\n    auto d = leftmost(r - l + 1);\n    auto a = table_[d][r - pow2(d) + 1];\n    auto b = table_[d][l];\n    return F(V[a], V[b]) ? a : b;\n  }\n  T find(int l, int r) const {\n    return V[index(l, r)];\n  }\n private:\n  inline int pow2(int n) const {return 1 << n;}\n  inline int leftmost(int n) const {return std::__lg(n);}\n  const std::vector<T> V;\n  const std::function<bool(T, T)> F;\n  std::vector<std::vector<int>> table_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nconst LL INF = 1e18;\n\nint N, M;\nLL K;\nvector<LL> A;\n\nLL score(int l, int r) {\n  static SparseTable<LL> minimum(A);\n  static SparseTable<LL> maximum(A, greater<LL>());\n  return K + (r - l) * (maximum.find(l, r-1) - minimum.find(l, r-1));\n}\n\nLL dfs(int i) {\n  static vector<LL> memo(N, -1);\n  if(i == N) return 0;\n  if(~memo[i]) return memo[i];\n  LL res = INF;\n  for(auto w = 1; w <= M; ++w) if(i+w <= N) res = min(res, score(i,i+w)+dfs(i+w));\n  return memo[i] = res;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  A.resize(N);\n  for(auto& i: A) cin >> i;\n  cout << dfs(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<iostream>\n#include<tuple>\n#include<utility>\n#include<set>\nusing namespace std;\ntypedef long long int llint;\nconst llint big=((llint)1<<(llint)60);\n#define mt make_tuple\n#define mp make_pair\n#define fi first\n#define se second\n#define pub push_back\n#define res resize\n//JOI 2016 oranges\n//K+s*(maxore-minore)\n//dp????????????\n//dp[i]=i???????????§??°??????\n//TLE?????????\n//0 1 2\nint main(void){\n\tllint N,M,K,i,j,maxore,minore;\n\tllint ore[20001]={0};\n\tllint dp[20001]={0};\n\tcin>>N>>M>>K;\n\tfor(i=0;i<N;i++){\n\t\tdp[i+1]=big;\n\t\tcin>>ore[i];\n\t\tmaxore=0;\n\t\tminore=big;\n\t\tfor(j=i;j>max((llint)-1,i-M);j--){\n\t\t\tmaxore=max(maxore,ore[j]);\n\t\t\tminore=min(minore,ore[j]);\n\t\t\tdp[i+1]=min(dp[i+1],K+(i-j+1)*(maxore-minore)+dp[j]);\n\t\t}\n\t\t//cout<<\"de\"<<dp[i+1]<<endl;\n\t}\n\tcout<<dp[N]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nlong long L,R,A[20001],dp[20001];\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=1;i<=N;i++){\n    scanf(\"%lld\",&A[i]);\n    dp[i]=1e9;\n    L=R=A[i];\n    for(int j=1;j<=M&&i-j>=0;j++){\n      dp[i]=min(dp[i],dp[i-j]+(R-L)*j+K);\n      L=min(L,A[i-j]);R=max(R,A[i-j]);\n    }\n  }\n  printf(\"%lld\\n\",dp[N]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//h16-1 オレンジの出荷\n#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#include <boost/multiprecision/cpp_int.hpp>\nnamespace boost_multiprecision = boost::multiprecision;\n#define LL long long\n#define CINT boost_multiprecision::cpp_int\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775807\n#define LL_MAX 9223372036854775807\n#define segment_size 65536\n#define ROOP() while (true)\n\nint N,M;\nLL K;\nvector<LL> A;\n\nLL dp[20000];\nLL dp2[20000][1001];\n\nLL solve(int now){\n    if(now == N) return 0;\n    if(dp[now] != LL_MAX) return dp[now];\n\n    LL re = LL_MAX;\n    for(int i=1; i<M+1; i++){\n        if(now+i > N) break;\n        re = min(re, solve(now+i) + i * dp2[now][i] + K);\n    }\n    dp[now] = re;\n    //cout << now << \" \" << re << endl;\n    return re;\n}\n\nint main(){\n    cin >> N >> M >> K;\n    for(int i=0; i<N; i++){\n        LL tmp;\n        cin >> tmp;\n        A.push_back(tmp);\n\n        dp[i] = LL_MAX;\n    }\n\n    for(int i=0; i<N; i++){\n        LL ma = LL_MIN+1;\n        LL mi = LL_MAX-1;\n        for(int j=1; j<M+1; j++){\n            if(i+j > N) break;\n            ma = max(ma, A[i+j-1]);\n            mi = min(mi, A[i+j-1]);\n            dp2[i][j] = ma - mi;\n            //cout << i << \" \" << j << \" \" << ma << \" \" << mi;\n        }\n    }\n\n    cout << solve(0) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :\n// Version     :???8:45 9:41\n// 2nd 10:43 11:55\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nconst long long INF=2000000000000001;\n\nint main() {\n\tint N,M,K;\n\tcin>>N>>M>>K;\n\tlong long A;\n\n\tlong long R=0;\n\tlong long dp[1001]={};\n\tlong long dMax[1001]={};\n\tlong long dMin[1001]={}\n\t;\n\tfor(long long j=M;j>0;--j){\n\t\tdMin[j]=INF;\n\t\tdp[j]=INF;\n\t}\n\tfor(int i=0;i<N;++i){\n\t\tcin>>A;\n\t\tR=R+K;\n\t\tfor(long long j=M;j>1;--j){\n\t\t\tdMax[j]=max(dMax[j-1],A);\n\t\t\tdMin[j]=min(dMin[j-1],A);\n\t\t\tdp[j]=dp[j-1]-(j-1)*(dMax[j-1]-dMin[j-1])+j*(dMax[j]-dMin[j]);\n\t\t\tR=min(R,dp[j]);\n\t\t}\n\t\tdp[1]=dp[0]+K;\n\t\tdMax[1]=A;dMin[1]=A;\n\t\tdp[0]=R;\n\t}\n\n\tcout<<R<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint n, m, k;\nint a[20010];\nlong long int c[20010];\n\nint mini(int l, int r){\n\tint res = 1e9;\n\tfor(int i=0; i<r-l+1; ++i)\n\t\tres = min(res, a[l+i]);\n\treturn res;\n}\n\nint maxi(int l, int r){\n\tint res = 0;\n\tfor(int i=0; i<r-l+1; ++i)\n\t\tres = max(res, a[l+i]);\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor(int i=1; i<=n; ++i) scanf(\"%d\", &a[i]);\n\tc[1] = k;\n\tfor(int i=2; i<=n; ++i){\n\t\tlong long int t = 1e18;\n\t\tfor(int j=1; j<=m; ++j){\n\t\t\tif(i - j < 0) break;\n\t\t\tint mi, ma;\n\t\t\tmi = mini(i-j+1, i);\n\t\t\tma = maxi(i-j+1, i);\n\t\t\tt = min(t, c[i-j] + j * (ma - mi) + k);\n\t\t}\n\t\tc[i] = t;\n\t}\n\tprintf(\"%lld\\n\", c[n]);\n/*\tfor(int i=1; i<=n; ++i) printf(\"%lld\\t\", c[i]);\n\tprintf(\"\\n\");\n*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <bitset>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <list>\n#include <deque>\nusing namespace std;\n#define INF 10000000\n#define LLINF 1000000000000000\ntypedef pair<int, int> P;\ntypedef long long ll;\n#define pb push_back\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define VSORT(v) sort(v.begin(), v.end());\n#define fi first\n#define se second\n#define out(x) cout << x << endl;\nint dx[] = { 1, 0, -1, 0 }, dy[] = { 0,1,0,-1 };\nll MOD = 1000000007;\nstruct edge {\n\tll from, to, cost;\n};\n\nint n, m;\nlong long k, a[20005] = { 0 };\nlong long dp[20005] = { 0 };\nlong long c = 0;\nint main() {\n\tcin >> n >> m >> k;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\tdp[i] = LLINF;\n\t}\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long ma = a[i];\n\t\tlong long mi = a[i];\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (i - j+1 >= 1) {\n\t\t\t\tma = max(ma, a[i - j+1]);\n\t\t\t\tmi = min(mi, a[i - j+1]);\n\t\t\t}\n\t\t\tc = k + j*(ma-mi);\n\t\t\tif (i - j < 0) continue;\n\t\t\tdp[i] = min(dp[i], dp[i - j] + c);\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll > P;\n\nll N, M, K;\nll ookisa[20000];\nll dp[2000][1001];\n\nP get(int a,int b) {\n\tP res;\n\tres.first = *max_element(ookisa + a, ookisa + b + 1);\n\tres.second = *min_element(ookisa + a, ookisa + b + 1);\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < N; i++)cin >> ookisa[i];\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < M; j++)dp[i][j] = 1145141919810893;\n\n\tdp[0][M - 1] = K;\n\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP minmax = get(i - (M - j - 1), i + 1);\n\t\t\t\tdp[i + 1][j - 1] = min(dp[i + 1][j - 1],\n\t\t\t\t\tdp[i - (M - j - 1)][M - 1] + (M - j + 1) * (minmax.first - minmax.second));\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 1145141919810893;\n\n\tfor (int i = 0; i < M; i++)ans = min(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp [[[ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)s)\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)s)\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* ]]] */\n\nll n, m, k;\nll a[20000];\nll dp[20010];\n\nint main(){\n  cin >> n >> m >> k;\n  rep(i, n) cin >> a[i];\n  \n  fill_n(dp, 20010, inf_ll);\n  dp[0] = 0;\n  rep(i, n){\n    int s = 0, mn = a[i], mx = a[i];\n    rep(j, i, min(i + m, n)){\n      s += a[j];\n      chmin(mn, a[j]);\n      chmax(mx, a[j]);\n      int c = k + (j - i + 1) * (mx - mn);\n      chmin(dp[j + 1], dp[i] + c);\n    }\n  }\n  \n  cout << dp[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 3e18;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, K;\nint A[20005];\nint memo[20005];\n\ninline :int rec(int now)\n{\n    if (~memo[now]) return memo[now];\n\n    int res = inf;\n    int mi = inf, ma = -inf;\n    \n    for (int i = 0, to = min(N - now, M); i < to; ++i) {\n        mi = min(mi, A[now + i]);\n        ma = max(ma, A[now + i]);\n\n        res = min(res, K + (ma - mi) * (i + 1) + rec(now + i + 1));\n    }\n\n    if (res == inf) res = 0;\n\n    return memo[now] = res;\n}\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    omajinai;\n    cin >> N >> M >> K;\n\n    rep(i, N) {\n        cin >> A[i];\n    }\n\n    memset(memo, -1, sizeof (memo));\n\n    cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll N,M,K;\nll A[100005];\n\nll dp[20005];\n\nconst ll INF = 1000000000000000000LL;\n\nll solve(){\n  fill(dp,dp+N+1,INF);\n  dp[0] = 0;\n  for(ll i=1;i<=N;i++){\n    ll a = -INF, b= INF;      \n    for(ll j=i-1;j>=max(0LL,i-M);j--){\n      b = min( A[j], b );\n      a = max( A[j], a );\n      ll c = K + (i-j)*(a-b);\n      assert( c >= 0 );\n      dp[i] = min( dp[i], dp[j] + c );\n    }\n  }\n  return dp[N];\n}\n\nint main(){\n  cin >>N >> M >> K;\n  assert( N <= 20000 );\n  for(int i=0;i<N;i++)\n    cin >> A[i];\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define int long long\n\nint a[20005];\nint dp[20005];\n\nsigned main()\n{\n    int N, M, K; cin >> N >> M >> K;\n\n    for (int i = 0; i < N; ++i) {\n        cin >> a[i];\n        dp[i + 1] = 3e18;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        int mi = 1e9, ma = -1e9;\n\n        for (int j = 0; j < M; ++j) {\n            if (i + j >= N) continue;\n\n            mi = min(mi, a[i + j]);\n            ma = max(ma, a[i + j]);\n\n            dp[i + j + 1] = min(dp[i + j + 1], dp[i] + (j + 1) * (ma - mi) + K);\n        }\n    }\n\n    cout << dp[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define inf 10e18\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, n, m;\n  scanf(\"%lld%lld%lld\", &n, &m, &k);\n  ll a[n], sum[n][m], dp[n];\n  for(i = 0; i < n; ++i) scanf(\"%lld\", &a[i]);\n  for(i = 0; i < n; ++i) dp[i] = inf;\n  dp[0] = k;\n  for(i = 0; i < n; ++i) {\n    ll min = inf, max = 0;\n    for(j = 0; j < n; ++j) {\n      if(i - j >= 0) {\n        if(min > a[i - j]) min = a[i - j];\n        if(max < a[i - j]) max = a[i - j];\n        sum[i][j] = k + (j + 1) * (max - min);\n      }\n    }\n  }\n  for(i = 1; i < n; ++i) {\n    for(j = 0; j < m; ++j) {\n      if(i - j > 0) {\n        if(dp[i] > sum[i][j] + dp[i - j - 1]) dp[i] = sum[i][j] + dp[i - j - 1];\n      } else if(!(i - j)) {\n        if(dp[i] > sum[i][j]) dp[i] = sum[i][j];\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[n - 1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define INF 9223372036854775807\nll dp[20001];\nint main(void){\n\tll n,m,k,a[20001],i,j,min,max,temp;\n\tcin>>n>>m>>k;\n\tfor(i=1;i<=n;i++) cin>>a[i];\n//\tfor(i=1;i<=n;i++) cout<<a[i]<<endl;\n\tfor(i=0;i<=n;i++) dp[i]=INF;\n\tdp[0]=0;\n\tfor(i=0;i<n;i++){\n\t\tmin=INF; max=-1;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tif(i+j<=n){\n//\t\t\t\tcout<<'A'<<endl;\n\t\t\t\tif(min>a[i+j]) min=a[i+j];\n\t\t\t\tif(max<a[i+j]) max=a[i+j];\n\t\t\t\ttemp=dp[i]+k+j*(max-min);\n\t\t\t\tif(dp[i+j]>temp) dp[i+j]=temp;\n\t\t\t}\n\t\t}\n\t}\n/*\tcout<<endl;\n\tfor(i=0;i<=n;i++) cout<<dp[i]<<endl;\n\tcout<<endl;*/\n\tcout<<dp[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nstruct P {\n\tlong long ma, mi;\n};\nll dp[20001], n, m, k, a[20000];\nP c[200];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 9000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=90000000000;\n\t\tfor (ll y = i; y < i + x; ) {\n\t\t\tif (y % 100 == 0&&y+100<i+x) {\n\t\t\t\tma = max(c[(y / 100)].ma, ma);\n\t\t\t\tmi = min(c[y / 100].mi, mi);\n\t\t\t\ty += 100;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tma = max(ma, a[y]);\n\t\t\t\tmi = min(mi, a[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tfor (ll i = 0; i < floor(i / 100); i++) {\n\t\t\tll ma = -1, mi = 900000000000000;\n\t\t\tfor (ll j = i * 100; j < (i + 1) * 100; j++) {\n\t\t\t\tma = max(ma, a[j]);\n\t\t\t\tmi = min(mi, a[j]);\n\t\t\t}\n\t\t\tc[i].ma = ma;\n\t\t\tc[i].mi = mi;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nll N, M, K;\n// ?????°???????????¨ [i,j)???????°????????????§??????logn??§\nconst int NMAX = 50000;\nint n, dat_min[2*NMAX-1], dat_max[2*NMAX-1];\nvoid init(int n_) {\n  n = 1;\n  while(n < n_) n *= 2;\n  FOR(i,0,2*n-1) {\n    dat_min[i] = 1e9;\n    dat_max[i] = 0;\n  }\n}\n// k????????????a?????????\nvoid update(int k, int a) {\n  k += n - 1;\n  dat_min[k] = a;\n  dat_max[k] = a;\n  while(k > 0) {\n    k = (k - 1) / 2;\n    dat_min[k] = min(dat_min[k*2+1],dat_min[k*2+2]);\n    dat_max[k] = max(dat_max[k*2+1],dat_max[k*2+2]);\n  }\n}\n// [l(????????????), r(??????))????????§???????°????query(l,r,0,0,n)\nint query(int a, int b, int k, int l, int r, bool MAX) {\n  if(r <= a || b <= l) return MAX ? 0 : 1e9;\n  if(a <= l && r <= b) return MAX ? dat_max[k] : dat_min[k];\n  else {\n    int vl = MAX ? query(a,b,k*2+1,l,(l+r)/2,1) : query(a,b,k*2+1,l,(l+r)/2,0);\n    int vr = MAX ? query(a,b,k*2+2,(l+r)/2,r,1) : query(a,b,k*2+2,(l+r)/2,r,0);\n    return MAX ? max(vl, vr) : min(vl, vr);\n  }\n}\nll dp[20005];\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> N >> M >> K;\n  init(N+1);\n  ll A[N];\n  FOR(i,0,N) {\n    cin >> A[i];\n    update(i + 1, A[i]);\n  }\n  FOR(i,0,N+1) dp[i] = 1e18;\n  dp[0] = 0;\n  FOR(i,1,N+1) {\n    FOR(j, max(1LL, i - M + 1), i + 1) {\n      dp[i] = min(dp[i], dp[j-1] + K + ll(i-j+1) * (query(j,i+1,0,0,n,1) - query(j,i+1,0,0,n,0)));\n    }\n  }\n  cout << dp[N] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 200001\nconst int inf = 1e18;\n\nint mn[2][1001], mx[2][1001];\nint a[MAX], dp[2][1001];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\t/*for(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}*/\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tmn[0][j] = mn[1][j];mn[1][j] = inf;\n\t\t\tmx[0][j] = mx[1][j];mx[1][j] = 0;\n\t\t\tdp[0][j] = dp[1][j];dp[1][j] = inf;\n\t\t}\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < n;i++){\n\t\tif(dp[0][i] == inf)continue;\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define INF 1e+18\nusing namespace std;\n\nint main(){\n\tint n,m,k;\n\tlong long int a[20001];\n\tlong long int dp[20001];\n\tcin >> n >> m >> k;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> a[i + 1];\n\t\tdp[i + 1] = INF;\n\t}\n\tdp[0] = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tlong long int mi = INF,ma = 0;\n\t\tfor(int j = i + 1;j <= min(i + m,n);j++){\n\t\t\tmi = min(a[j],mi);\n\t\t\tma = max(a[j],ma);\n\t\t\tdp[j] = min(dp[j],dp[i] + (j - i) * (ma - mi) + k);\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define int long long\nint n,m,k,a[20002],dp[22222];\nsigned main(){\n  cin>>n>>m>>k;\n  r(i,n)cin>>a[i];\n  r(i,20002)dp[i]=1e16;\n  dp[0]=0;\n  for(int i=0;i<n;i++){\n    int MAX=0,MIN=1e16;\n    for(int j=0;j<m;j++){\n      if(i+j+1>n)continue;\n      MAX=max(MAX,a[i+j]);\n      MIN=min(MIN,a[i+j]);\n      dp[i+j+1]=min(dp[i+j+1],dp[i]+k+(j+1)*(MAX-MIN));\n    }\n  }\n  cout<<dp[n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nlong long int dp[20001];\nint main() {\n\tfor (int i = 0; i < 20001; ++i) {\n\t\tdp[i] = 0;\n\t}\n\tdp[0]= 0;\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<long long int>ws(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> ws[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong long int amin = 1e18;\n\t\tlong long int amax = 0;\n\t\tlong long int cost = K;\n\t\tfor (int j = 0; j < min(N-i,M); ++j) {\n\t\t\tamin = min(amin, ws[i + j]);\n\t\t\tamax = max(amax, ws[i + j]);\n\t\t\tdp[i + j + 1] = min(dp[i + j + 1], dp[i] + cost + (j+1)*(amax - amin));\n\t\t}\n\t}\n\tcout << dp[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll a[20000], shou[80000], dai[80000], dp[20000], n, m, k2;\nconst ll inf = 99999999999999999;\nint start, ruend;\nll ma, mi;\nvoid query(int a, int b, int k, int l, int r) {\n\t//a??????b???????°????//k???l??\\???r??\\????????????\n\tif (b<l || a>r) return;\n\tif (l >= a&&r <= b) {\n\t\tma = max(ma, dai[k]);\n\t\tmi = min(mi, shou[k]);\n\t}\n\telse {\n\t\tquery(a, b, k * 2 + 1, l, floor((l + r) / 2.0));\n\t\tquery(a, b, k * 2 + 2, ceil((l + r) / 2.0), r);\n\t}\n}\nll solve(int i) {\n\tif (i == n) return 0;\n\tll sum = inf;\n\tfor (int j = 1; j <= m&&i + j <= n; j++) {\n\t\tll res = k2;\n\t\tma = -1;\n\t\tmi = inf;\n\t\tquery(start + i, start + i + j - 1, 0, start, ruend);\n\t\tres += (j*(ma - mi));\n\t\tif (dp[i + j] != -1) sum = min(sum, res + dp[i + j]);\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i + j] = solve(i + j)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tcin >> n >> m >> k2;\n\tfor (ll i = 0; i < n * 4; i++) {\n\t\tshou[i] = inf;\n\t\tdai[i] = -1;\n\t}\n\tll io = 0, iop = 1;\n\twhile (iop < n) {\n\t\tio += iop;\n\t\tiop *= 2;\n\t}\n\tstart = io;\n\truend = io + iop - 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tdp[i] = -1;\n\t\tshou[start + i] = a[i];\n\t\tdai[start + i] = a[i];\n\t}\n\tfor (int i = start - 1; i >= 0; i--) {\n\t\tshou[i] = min(shou[i * 2 + 1], shou[i * 2 + 2]);\n\t\tdai[i] = max(dai[i * 2 + 1], dai[i * 2 + 2]);\n\t}\n\tcout << solve(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll > P;\n\nll N, M, K;\nll ookisa[20000];\nll dp[20000][1001];\n\nP get(int a,int b) {\n\tP res;\n\tres.first = *max_element(ookisa + a, ookisa + b + 1);\n\tres.second = *min_element(ookisa + a, ookisa + b + 1);\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < N; i++)cin >> ookisa[i];\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < M; j++)dp[i][j] = 1145141919810893;\n\n\tdp[0][M - 1] = K;\n\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tP minmax = get(i - (M - j - 1), i + 1);\n\t\t\t\tdp[i + 1][j - 1] = min(dp[i + 1][j - 1],\n\t\t\t\t\tdp[i - (M - j - 1)][M - 1] + (M - j + 1) * (minmax.first - minmax.second));\n\t\t\t\t/*\n\t\t\t\tdp[i + 1][M - 1] = min(dp[i + 1][M - 1], dp[i][j] + K);\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 1145141919810893;\n\n\tfor (int i = 0; i < M; i++)ans = min(ans, dp[N - 1][i]);\n\tcout << ans << endl;\n\tcout << 0 - M + 0 + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:https://www.ioi-jp.org/joi/2015/2016-ho/2016-ho.pdf>\n?????????============================================================\nN(1<=N<=20000)???????????¬???????????????????????¬??????i?????§?????????Ai??§?????????\n\n???????????¬????????????????????????????????????????????±??????????????????????????¨?????????????????¨????????±??????\n??£?¶?????????????????????¬??????????????????????????¨?????§????????????\n\n?????¨????????±???????????§??§M(1<=M<=1000)?????§?????¬???????????????????????¨?????§??????\n??±????????¬?????????????????????????????????????????????????????±?????????????????§????????¬???????????§?????????a,\n??±????????????????°?????????¬???????????§?????????b, ??±?????????????????¬??????????????°???s??¨????????¨???, K+s*(a-b)??¨?????????\nK?????±???????????????????????§???????????¨????????±??§??±???\n\n??????????????°?????±?????¨?????????????????????????????¬????????????????????±??°??????????????¨??§??±??°???????????????\n???????????????????????§?????????????°????????????????\n=================================================================\n?§£??¬=============================================================\n================================================================\n*/\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M, K; cin >> N >> M >> K;\n\tvector<int> A(N); for (auto& in : A)cin >> in;\n\n\tvector<vector<pair<ll, pair<int, int>>>> dp(N + 1, vector<pair<ll, pair<int, int>>>(M + 1, { LINF,{-INF,INF} }));\n\tdp[0][0].first = 0;\n\tfor (int i = 0; i < N;i++) {\n\t\tfor (int j = 0; j < M;j++) {\n\t\t\tif (dp[i][j].first == LINF)continue;\n\t\t\tif (j != M-1 && i != N-1) {\n\t\t\t\tdp[i + 1][j + 1] = min(dp[i + 1][j + 1], { dp[i][j].first,{max(dp[i][j].second.first,A[i]),min(dp[i][j].second.second,A[i])} });\n\t\t\t}\n\t\t\tdp[i + 1][0] = min(dp[i + 1][0], { dp[i][j].first + K + (j+1)*(max(dp[i][j].second.first,A[i]) - min(dp[i][j].second.second,A[i])),{-INF,INF} });\n\t\t}\n\t}\n\tcout << dp[N][0].first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nlong long int dp[20001];\nint main() {\n\tfor (int i = 0; i < 20001; ++i) {\n\t\tdp[i] =1e18;\n\t}\n\tdp[0]= 0;\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<long long int>ws(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> ws[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong long int amin = 1e18;\n\t\tlong long int amax = 0;\n\t\tlong long int cost = K;\n\t\tfor (int j = 0; j < min(N-i,M); ++j) {\n\t\t\tamin = min(amin, ws[i + j]);\n\t\t\tamax = max(amax, ws[i + j]);\n\t\t\tdp[i + j + 1] = min(dp[i + j + 1], dp[i] + cost + (j+1)*(amax - amin));\n\t\t}\n\t}\n\tcout << dp[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define repp(i, m, n) for(int i = m; i < n; i++)\n#define reps(i, n) for(int i = 1; i <= n; i++)\nconst int    INF = 1000000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pai;\ntypedef pair<ll,ll> pal;\n\n\n\nint main()\n{\n\tint n, m;\n\tll mx[1010], my[1010], mxn[1010], myn[1010];\n\tcin >> n >> m;\n\tll k, a[20010], dp[20010];\n\tcin >> k;\n\treps(i, n) cin >> a[i];\t\n\tdp[0]=0;\n\trep(i, m+1) mx[i]=INF, my[i]=0;\n\treps(i, n)\n\t{\n\t\tfor(ll l=1; l<=min(i, m); l++)\n\t\t{\n\t\t\tmxn[l]=min(mx[l-1], a[i]);\n\t\t\tmyn[l]=max(my[l-1], a[i]);\n\t\t\tif(l==1) dp[i]=dp[i-1]+k;\n\t\t\telse dp[i]=min(dp[i], dp[i-l]+k+l*(myn[l]-mxn[l]));\n\t\t}\n\t\treps(l, min(i, m)) mx[l]=mxn[l], my[l]=myn[l];\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nLL dp[20001];\nLL og[20001];\nint main(void){\n\tint n,m,k;\n\tint i,j;\n\tLL MAX;\n\tLL MIN;\n\tcin>>n>>m>>k;\n\tfor(i=0;i<n;i++){\n\t\tcin>>og[i];\n\t\tdp[i+1]=LLONG_MAX;\n\t}\n\tdp[0]=0;\n\tfor(i=0;i<n;i++){\n\t\tMAX=og[i];\n\t\tMIN=og[i];\n\t\tfor(j=1;j<=m;j++){\n\t\t\tLL ans=k+j*(MAX-MIN);\n\t\t\tdp[i+j]=min(dp[i+j],dp[i]+ans);\n\t\t\tMAX=max(MAX,og[i+j]);\n\t\t\tMIN=min(MIN,og[i+j]);\n\t\t\tif(i+j==n)\tbreak;\n\t\t}\n\t}\n\tcout<<dp[n]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2016-ho-t1.cpp\n *\n *  Created on: 2017/02/09\n *      Author: joi\n */\n\n#include<cstdio>\nint main(void){\n\tlong long dp[1001];\n\tlong long dpb[1001];\n\tint dpmin[1001];\n\tint dpmax[1000];\nint n;\nint m;\nlong long min;\n\tint a[20000];\n\tint k;\n\tint x;\n\tint y;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\nfor(int i=0;i<m;i++){\n\tdp[i]=0;\n\tdpb[i]=0;\n\tdpmax[i]=0;\n\tdpmin[i]=0;\n}\nfor(int i=0;i<n;i++){\n\tx=a[i];\nif(i<m-1)y=i;\nelse y=m-1;\n\tfor(int j=y;j>0;j--){\n\t\tdpb[j]=dp[j];\n\tif(dpmax[j-1]<x){\n\t\tdp[j]=((x-dpmin[j-1])*(j+1))-((dpmax[j-1]-dpmin[j-1])*(j))+dp[j-1];\n\t\tdpmax[j]=x;\n\t\tdpmin[j]=dpmin[j-1];\n\t}\n\telse if(dpmin[j-1]>x){\n\t\tdp[j]=((dpmax[j-1]-x)*(j+1))-((dpmax[j-1]-dpmin[j-1])*(j))+dp[j-1];\n\t\tdpmax[j]=dpmax[j-1];\n\t\tdpmin[j]=x;\n\t}\n\telse{\n\t\tdp[j]=dpmax[j-1]-dpmin[j-1]+dp[j-1];\n\t\tdpmax[j]=dpmax[j-1];\n\t\tdpmin[j]=dpmin[j-1];\n}\n\t}\n\tif(i==0){\n\t\tdp[i]=k;\n\t\tdpmax[i]=x;\n\t\tdpmin[i]=x;\n\t}\n\telse{\n\tdpb[0]=dp[0];\n\tmin=100000000000000000;\n\tfor(int j=0;j<m&&j<i;j++){\n\t\tif(min>dpb[j]){\nmin=dpb[j];\n\t\t}\n\t}\n\t\tdp[0]=min+k;\n\t\tdpmax[0]=x;\n\t\tdpmin[0]=x;\n\t}\n}\nmin=100000000000000000;\nfor(int i=0;i<m&&i<n;i++){\n\tif(min>dp[i])min=dp[i];\n}\nprintf(\"%lld\\n\",min);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<cassert>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define MAX 20010\n\nll dp[MAX];\nint N,M;\nll K,A[MAX];\n\nvoid computer() {\n  rep(i,N+1) dp[i] = LLONG_MAX;\n  rep(i,N) {\n    dp[i] = ((i-1>=0)?dp[i-1]:0) + K;\n    ll maxi = A[i];\n    ll mini = A[i];\n    for(int j=i-1;j>=0;--j) {\n      if( i - j + 1 > M ) break;\n      maxi = max(maxi,A[i]);\n      mini = min(mini,A[i]);\n      dp[i] = min(dp[i],((j-1>=0)?dp[j-1]:0)+K+(ll)(i-j+1) * ( maxi - mini ));\n    }\n  }\n  cout << dp[N-1] << endl;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  rep(i,N) cin >> A[i];\n  computer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nlong long N,M,K;\nlong long A[20001]={};\nlong long dp[20001][1001];\nlong long mmD[20001][1001];\nconst long long INF=100000000000000000;\n\nlong long calc(long long n1,long long m1){\n\tif(dp[n1][m1]>-1)return dp[n1][m1];\n\tlong long ans=INF;\n\tif(m1>0){\n\t\tans=calc(n1,0)+K+m1*mmD[n1][m1];\n\t}else{\n\t\tfor(long long i=1;i<M+1&&i<n1+1;++i){\n\t\t\tans=min(ans,calc(n1-i,i));\n\t\t}\n\t}\n\tdp[n1][m1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(long long i=1;i<N+1;i++)cin>>A[i];\n\n\tfill(dp[0],dp[20001],-1);\n\tlong long maxD[1001]={};\n\tlong long minD[1001]={};\n\n\tfor(int i=0;i<N+1;i++){\n\t\tmaxD[0]=0;\n\t\tminD[0]=INF;\n\t\tfor(int j=1;j<M+1;j++){\n\t\t\tmaxD[j]=max(maxD[j-1],A[i+j]);\n\t\t\tminD[j]=min(minD[j-1],A[i+j]);\n\t\t\tmmD[i][j]=maxD[j]-minD[j];\n\t\t}\n\t}\n\tdp[0][0]=0;\n//\tlong long R;\n//\tfor(int i=1;i<N;i++){\n//\t\tfor(int j=0;j<M+1;j++)\n//\t\tR=calc(i,j);\n//\t}\n//\tR=calc(N,0);\n//\tcout<<R<<endl;\n\tcout<<calc(N,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nlong long int dp[20001];\nint main() {\n\tfill(dp, dp + sizeof(dp), static_cast<long long int>(1e18));\n\tdp[0]= 0;\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<long long int>ws(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> ws[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong long int amin = 1e18;\n\t\tlong long int amax = 0;\n\t\tlong long int cost = K;\n\t\tfor (int j = 0; j < min(N-i,M); ++j) {\n\t\t\tamin = min(amin, ws[i + j]);\n\t\t\tamax = max(amax, ws[i + j]);\n\t\t\tdp[i + j + 1] = min(dp[i + j + 1], dp[i] + cost + (j+1)*(amax - amin));\n\t\t}\n\t}\n\tcout << dp[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 92234341346326\n#define ll long long\nusing namespace std;\nint main(){\n\tll A,B,N,M,K,a,U,flg=0,MAX=0,MIN=INF;\n\tcin>>N>>M>>K;\n\tll cost[N+1]={0};\n\tll size[N+1]={0};\n\tfor (int A=0;A<=N;A++) cost[A]=INF;\n\tcost[0]=0;\n\tfor (A=1;A<=N;A++) cin>>size[A];\n\tfor (A=1;A<=N;A++){\n\t\tfor (B=0;B<M&&B<=N;B++){\n\t\t\tfor (int C=A;C<=B&&C<=M;C++){\n\t\t\t\tif (MAX<size[C]) MAX=size[C];\n\t\t\t\tif (MIN>size[C]) MIN=size[C];\n\t\t\t}\n\t\t\tcost[A+B]=min(cost[A+B],K+(1+B)*(MAX-MIN)+cost[A-1]);\n\t\t\tMAX=0;\n\t\t\tMIN=INF;\n\t\t}\n\t}\n\tcout<<cost[N]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nlong long int max(long long int a,long long int b)\n{\n\tif(a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\nlong long int min(long long int a,long long int b)\n{\n\tif(a < b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nusing namespace std;\n\nlong long int N,M,K,A[20000];\n\ntypedef struct _stat\n{\n\tlong long int remain;\n\tlong long int cost;\n} stat;\n\nqueue<stat> qst;\n\nstat makestat(long long int remain,long long int cost)\n{\n\tstat t;\n\tt.remain = remain;\n\tt.cost = cost;\n\treturn t;\n}\n\nlong long int getmin(int begin,int end)\n{\n\tlong long int res = 922337203685477580;\n\tfor(int i = begin;i <= end;i++)\n\t{\n\t\tres = min(res,A[i]);\n\t}\n\treturn res;\n}\n\nlong long int getmax(int begin,int end)\n{\n\tlong long int res = 0;\n\tfor(int i = begin;i <= end;i++)\n\t{\n\t\tres = max(res,A[i]);\n\t}\n\treturn res;\n}\n\n\nint main(void)\n{\n\tcin >> N >> M >> K;\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\tqst.push(makestat(N,0));\n\tstat t;\n\tlong long int mincost = 922337203685477580;\n\twhile(!qst.empty())\n\t{\n\t\tt.remain = (qst.front()).remain;\n\t\tt.cost = (qst.front()).cost;\n\t\tqst.pop();\n\t\tfor(int i = 1;i < t.remain && i <= M;i++)\n\t\t{\n\t\t\tlong long int cost = K + i * (getmax(N-t.remain,N-t.remain+i-1) - getmin(N-t.remain,N-t.remain+i-1)) + t.cost;\n\t\t\tif(cost > 0)\n\t\t\t\tqst.push(makestat(t.remain - i,cost));\n\t\t}\n\t\tif(t.remain <= M)\n\t\t{\n\t\t\tlong long int cost = K + t.remain * (getmax(N-t.remain,N-1) - getmin(N-t.remain,N-1)) + t.cost;\n\t\t\tif(cost > 0)\n\t\t\tmincost = min(mincost,cost);\n\t\t}\n\t}\n\tcout << mincost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 99999999999\n\n\nll** memo;\n\nenum Type{\n\tmax_value,\n\tmin_value,\n};\n\nstruct RMQ{\n\tvoid set(ll arg_minimum,ll arg_maximum){\n\t\tminimum = arg_minimum;\n\t\tmaximum = arg_maximum;\n\t}\n\tll minimum,maximum;\n};\n\nint N = 1;\nRMQ* Tree;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int index, ll orange){\n\n\tindex += N-1;\n\n\tTree[index].minimum = min(Tree[index].minimum,orange);\n\tTree[index].maximum = max(Tree[index].maximum,orange);\n\n\tindex = (index-1)/2;\n\n\twhile(true){\n\n\t\tTree[index].minimum = min(Tree[2*index+1].minimum,Tree[2*index+2].minimum);\n\t\tTree[index].maximum = max(Tree[2*index+1].maximum,Tree[2*index+2].maximum);\n\n\t\tif(index == 0)break;\n\t\telse{\n\t\t\tindex = (index-1)/2;\n\t\t}\n\t}\n}\n\n\nll find(int search_left,int search_right,int node_id,int node_left,int node_right,Type type){\n\n\tif(search_right < node_left || search_left > node_right){\n\t\tif(type == max_value){\n\t\t\treturn -1;\n\t\t}else{ //type == min_value;\n\t\t\treturn NUM;\n\t\t}\n\t}\n\n\tif(search_left <= node_left && search_right >= node_right){\n\t\tif(type == max_value){\n\t\t\treturn Tree[node_id].maximum;\n\t\t}else{\n\t\t\treturn Tree[node_id].minimum;\n\t\t}\n\t}\n\n\tif(type == min_value){\n\t\tll left_min = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_min = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn min(left_min,right_min);\n\t}else{ //type == max_value\n\t\tll left_max = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_max = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn max(left_max,right_max);\n\t}\n}\n\nll box_Cost;\nint first_N,contain_Max;\n\nll recursive(int left,int width){\n\n\tll ret = 0,next = NUM;\n\tif(memo[left][width] != -1){\n\t\treturn memo[left][width];\n\t}else{\n\n\t\tll min_orange = find(left,min(N-1,left+width-1),0,0,N-1,min_value);\n\t\tll max_orange = find(left,min(N-1,left+width-1),0,0,N-1,max_value);\n\t\tret = box_Cost+width*(max_orange-min_orange);\n\t}\n\n\tif(left + width <= first_N-1){\n\t\tfor(int i = 1; i <= contain_Max; i++){\n\t\t\tnext = min(next,recursive(left+width,i));\n\t\t}\n\t\treturn memo[left][width] = ret + next;\n\t}else{\n\t\treturn memo[left][width] = ret;\n\t}\n}\n\nvoid func(){\n\n\tll ans = NUM;\n\n\tfor(int i = 1; i <= contain_Max; i++){\n\t\tans = min(ans,recursive(0,i));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %lld\",&first_N,&contain_Max,&box_Cost);\n\n\tinit(first_N);\n\n\tmemo = new ll*[first_N];\n\tfor(int i = 0; i < first_N; i++){\n\t\tmemo[i] = new ll[contain_Max+1];\n\t\tfor(int k = 0; k <= contain_Max; k++)memo[i][k] = -1;\n\t}\n\n\tTree = (RMQ*)malloc(sizeof(RMQ)*(2*N));\n\n\tfor(int i = 0; i < 2*N-1; i++){\n\t\tTree[i].set(NUM,-1);\n\t}\n\n\tll tmp;\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld\",&tmp);\n\t\tupdate(i,tmp);\n\t}\n\n\tfunc();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst long double PI = acos(-1);\nconstexpr long double EPS = 1e-15;\nconstexpr int inf = 2e9;\nconstexpr ll INF = 2e18;\nconstexpr ll MOD = 1e9+7;\nconstexpr ll MOD1 = 998244353;\ntypedef pair<ll,ll> P;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nint n, m, k;\nlong long a[21234];\nlong long dp[21234];\n\nint main(){\n    cin >> n >> m >> k;\n    REP(i, n) cin >> a[i];\n    REP(i, n){\n        dp[i] = INF;\n        long long mx = a[i], mn = a[i];\n        for(int j = 0; j < min(i + 1, m); ++j){\n           mx = max(mx, a[i - j]);\n           mn = min(mn, a[i - j]);\n           dp[i] = min(dp[i], dp[i - j - 1] + (mx - mn) * (j + 1) + k);\n        }\n    }\n    cout << dp[n - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,k,a[100005],dp[100005];\nlong long solve(long long p){\n\tif(p>n)return 1LL<<62;\n\tif(p==n)return 0;\n\tif(dp[p]>=1)return dp[p];\n\tlong long p1=1LL<<62,p2=0,ret=1LL<<62;\n\tfor(int i=p+1;i<=p+m;i++){\n\t\tp1=min(p1,a[i-1]);p2=max(p2,a[i-1]);\n\t\tret=min(ret,solve(i)+(p2-p1)*(i-p)+k);\n\t}\n\tdp[p]=ret;\n\treturn ret;\n}\nint main(){\n\tcin>>n>>m>>k;for(int i=0;i<n;i++)cin>>a[i];\n\tcout<<solve(0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1001001001001001\nusing namespace std;\ntypedef long long ll;\n\nll dp[2][20010];\nll ary[20010];\nint main(){\n\tll N,M,K;\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<=N;i++){\n\t\tcin>>ary[i];\n\t}\n\tfill(dp[0],dp[0]+N+1,INF);\n\tfill(dp[1],dp[1]+N+1,INF);\n\tdp[0][0]=0;\n\tint in=0,ou=1;\n\tll res=INF;\n\tfor(int i=0;i<N;i++){\n\t\tfill(dp[ou],dp[ou]+N+1,INF);\n\t\tll cnt,ma,mi;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tcnt=0;ma=0;mi=INF;\n\t\t\tfor(int k=1;k<=M&&j+k<=N;k++){\n\t\t\t\tma=max(ma,ary[j+k]);\n\t\t\t\tmi=min(mi,ary[j+k]);\n\t\t\t\tdp[ou][j+k]=min(dp[ou][j+k],dp[in][j]+K+k*(ma-mi));\n\t\t\t}\n\t\t}\n\t\tres=min(res,dp[ou][N]);\n\t\tswap(in,ou);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n\n#define MAX_N 20001\n\nusing namespace std;\n\nuint64_t N,M,K,A[MAX_N],T[MAX_N];\n\nuint64_t min(uint64_t a,uint64_t b)\n{\n\tif(a < b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nuint64_t max(uint64_t a,uint64_t b)\n{\n\tif(a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nuint64_t getmin(int begin,int end)\n{\n\tuint64_t res = UINT64_MAX;\n\tfor(int i = begin;i <= end;i++)\n\t\tres = min(res,A[i]);\n\treturn res;\n}\n\nuint64_t getmax(int begin,int end)\n{\n\tuint64_t res = 0;\n\tfor(int i = begin;i <= end;i++)\n\t\tres = max(res,A[i]);\n\treturn res;\n}\n\nuint64_t getsum(int begin,int end)\n{\n\tuint64_t res = 0;\n\tfor(int i = begin;i <= end;i++)\n\t\tres = res + A[i];\n\treturn res;\n}\n\nint main(void)\n{\n\tcin >> N >> M >> K;\n\tfor(int i = 0;i < MAX_N;i++)\n\t{\n\t\tT[i] = UINT64_MAX;\n\t}\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\tT[N] = 0;\n\tfor(int i = N-1;i >= 0;i--)\n\t{\n\t\tfor(int k = 1;k <= M && (i + k) <= N ;k++)\n\t\t{\n\t\t\tuint64_t cost = K + (k * (getmax(N-(i+k),(N-i)-1) - getmin(N-(i+k),(N-i)-1)));\n\t\t\tT[i] = min(T[i],T[i+k]+cost);\n\t\t}\n\t}\n\tcout << T[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e18;\nll v[20001], dp[2][1010];\nll a[2][1010],b[2][1010];\nint main(){\n\tll n,m,k;\tcin>>n>>m>>k;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>v[i];\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[i][j]=INF;\n\t\t\tb[i][j]=INF;\n\t\t}\n\t}\n\tdp[0][0]=k;\ta[0][0]=b[0][0]=v[0];\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(dp[0][j]==INF)\tcontinue;\n\t\t\t//その箱に追加する場合\n\t\t\tif(j+1<m){\n\t\t\t\tdp[1][j+1]=dp[0][j];\n\t\t\t\ta[1][j+1]=max((ll)a[0][j],v[i]);\n\t\t\t\tb[1][j+1]=min((ll)b[0][j],v[i]);\n\t\t\t}\n\t\t\t//新しく箱を作る場合\n\t\t\tll num=k+dp[0][j];\n\t\t\tnum+=(a[0][j]-b[0][j])*(j+1);\n\t\t\tdp[1][0]=min(dp[1][0],num);\n\t\t\ta[1][0]=b[1][0]=v[i];\n\t\t}\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[0][j]=dp[1][j];\tdp[1][j]=INF;\n\t\t\ta[0][j]=a[1][j];\ta[1][j]=0;\n\t\t\tb[0][j]=b[1][j];\tb[1][j]=INF;\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(int i=0;i<m;i++){\n\t\tll num=dp[0][i];\n\t\tnum+=(a[0][i]-b[0][i])*(i+1);\n\t\tans=min(ans,num);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N, M, K;\nlong long int num[20001];\nlong long int dp[20001];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> M >> K;\n\tfor (int i = 1; i <= N; i++)cin >> num[i];\n\tfor (int i = 1; i <= N; i++)dp[i] = LLONG_MAX;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long int mi = LLONG_MAX;\n\t\tlong long int MA = LLONG_MIN;\n\t\tfor (int j = i + 1; j <= min(i + M, N); j++) {\n\t\t\tmi = min(mi, num[j]);\n\t\t\tMA = max(MA, num[j]);\n\t\t\tdp[j] = min(dp[j], dp[i] + K + (j - i)*(MA - mi));\n\t\t}\n\t}\n\tcout << dp[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 92234341346326\n#define ll long long\nusing namespace std;\nint main(){\n\tll A,B,N,M,K,a,U,flg=0,MAX=0,MIN=INF;\n\tcin>>N>>M>>K;\n\tll cost[N+1]={0};\n\tll size[N+1]={0};\n\tfor (int A=0;A<=N;A++) cost[A]=INF;\n\tcost[0]=0;\n\tfor (A=1;A<=N;A++) cin>>size[A];\n\tfor (A=1;A<=N;A++){\n\t\tfor (B=0;B<M&&B<=N;B++){\n\t\t\tfor (int C=A;C<=A+B;C++){\n\t\t\t\tif (MAX<size[C]) MAX=size[C];\n\t\t\t\tif (MIN>size[C]) MIN=size[C];\n\t\t\t}\n\t\t\tcost[A+B]=min(cost[A+B],K+(1+B)*(MAX-MIN)+cost[A-1]);\n\t\t\tMAX=0;\n\t\t\tMIN=INF;\n\t\t}\n\t}\n\tcout<<cost[N]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<cassert>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int IINF = INT_MAX;\nconst char EMPTY = 'X';\n \nstruct Node{\n  int value;\n  /*\n    lazy : \n    A : ??????????????¶ ( ADD )\n    S : ?????????????´?????????????????????????????????¶ ( SET )\n\n    lazy_coef : \n    ????????????????????????????????????or???????????????????????????????¨????\n  */\n  char lazy;\n  int lazy_coef; \n  Node(int value=0,char lazy=EMPTY,int lazy_coef=0):value(value),lazy(lazy),lazy_coef(lazy_coef){}\n};\n \nclass SegmentTree{\npublic:\n  vector<Node> RMQ;\n  vector<int> minimum_dat,maximum_dat;\n  int limit,N; // N ???????´???°\n \n  void init(int tmp){\n    N = tmp;\n    int N_N = 1;\n    while(N_N < N)N_N *= 2;\n    limit = N_N;\n    RMQ.resize(3*limit);\n    minimum_dat.resize(3*limit);\n    maximum_dat.resize(3*limit);\n    rep(i,3*limit-1) {\n      RMQ[i] = Node();\n      minimum_dat[i] =  IINF;\n      maximum_dat[i] = -IINF;\n    }\n  }\n\n  /* \n     O(n)??§RMQ????????????\n     [L,R)\n     tuple<int,int,int>(?????????????°????????????§???)\n  */\n  tuple<int,int,int> _build(int cur,int L,int R,const vector<int> &buf){\n\n    if( !( 0 <= cur && cur < 2*limit-1 ) ) return tuple<int,int,int>(0,IINF,-IINF);\n    if( L == R-1 ){\n      if( L >= N ) return tuple<int,int,int>(0,IINF,-IINF);\n      //???????´??????????????????§????????´??? ( ??????????????????????????????????????§?????????????????´??? )\n      //buf[] ?????¨??????????????\\??? RMQ[cur].value = buf[L]; ??¨??????\n      // RMQ???L?????????????´????buf[L]??§??´??°\n      RMQ[cur].value = buf[L];\n      minimum_dat[cur] = buf[L];\n      maximum_dat[cur] = buf[L];\n      //???????´??????¨??????????????´???\n      //RMQ[cur] = 0; // RMQ ??????????´?????????§???????????? 1 ?????? RMQ[cur] = 1????????????...\n      //minimum_dat[cur] = 0;\n      //maximum_dat[cur] = 0;\n    } else {\n      tuple<int,int,int> vl = _build(cur*2+1,L,(L+R)/2,buf);\n      tuple<int,int,int> vr = _build(cur*2+2,(L+R)/2,R,buf);\n      RMQ[cur].value = get<0>(vl) + get<0>(vr);\n      minimum_dat[cur] = min(get<1>(vl),get<1>(vr));\n      maximum_dat[cur] = max(get<2>(vl),get<2>(vr));\n    }\n    return tuple<int,int,int>(RMQ[cur].value,minimum_dat[cur],maximum_dat[cur]);\n  }\n\n  //init?????????????????¨???????????¨!!! ??§????????¨limit?????£??????????????\\??£???????????????\n  void build(const vector<int> &buf) { _build(0,0,limit,buf); }\n\n  inline void value_evaluate(int index,int L,int R){\n    if( RMQ[index].lazy == 'A' ){\n      RMQ[index].value += ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] += RMQ[index].lazy_coef;\n      maximum_dat[index] += RMQ[index].lazy_coef;\n    } else if( RMQ[index].lazy == 'S' ){\n      RMQ[index].value = ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] = RMQ[index].lazy_coef;\n      maximum_dat[index] = RMQ[index].lazy_coef;\n    }\n  }\n   \n  inline void lazy_evaluate(int index,int L,int R){\n    value_evaluate(index,L,R);\n    if( index < limit && RMQ[index].lazy != EMPTY ) {\n      if( RMQ[index].lazy == 'A' ) {\n        if( RMQ[index*2+1].lazy == EMPTY ) RMQ[index*2+1].lazy = 'A'; \n        if( RMQ[index*2+2].lazy == EMPTY ) RMQ[index*2+2].lazy = 'A';\n        RMQ[index*2+1].lazy_coef += RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef += RMQ[index].lazy_coef;\n      } else if( RMQ[index].lazy == 'S') {\n        RMQ[index*2+1].lazy = RMQ[index*2+2].lazy = 'S';\n        RMQ[index*2+1].lazy_coef = RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef = RMQ[index].lazy_coef;\n      }\n    }\n    RMQ[index].lazy = EMPTY;\n    RMQ[index].lazy_coef = 0;\n  }\n \n  inline void value_update(int index){\n    RMQ[index].value = RMQ[index*2+1].value + RMQ[index*2+2].value;\n    minimum_dat[index] = min(minimum_dat[index*2+1],minimum_dat[index*2+2]);\n    maximum_dat[index] = max(maximum_dat[index*2+1],maximum_dat[index*2+2]);\n  }\n \n  /*\n  //[a,b)???????????????opr?????????\n  ??????????????¬??????[L,R)\n  [a,b)??????????´????????????????\n  opr ??? 'A'??????v????????? ( ADD )\n  opr ??? 'S'??????v????????? ( SET )\n  */\n  void _update(int a,int b,char opr,int v,int index,int L,int R){\n    /*\n      RMQ[index].lazy ???EMPTY??\\?????????????????????????????????????????§????????°\n      ???????????¶???????????????????????????\n    */\n    lazy_evaluate(index,L,R);\n \n    if( b <= L || R <= a )return;\n    if( a <= L && R <= b ){\n      /*\n        [L,R)???????????????????????\\??£????????§???????????§?????????????????? ( ???????????????????????´??°?????????????????´??°?????????, ????????£???????????¶?????????????????? )\n        [??????????????????]            [??????????????????]\n        [??????]  [??????]     => [??????,?????¶] [??????,?????¶]\n        ??????????????????????????????\n        ??????????????????????¨??????????????????¶????????????????????????\n      */\n      RMQ[index].lazy = opr; // ??????????????????????????¶????¨??????????????????????????????????\n      if( opr == 'A' )      RMQ[index].lazy_coef += v; \n      else if( opr == 'S' ) RMQ[index].lazy_coef = v; \n      lazy_evaluate(index,L,R);\n      return;\n    }\n \n    _update(a,b,opr,v,index*2+1,L,(L+R)/2);\n    _update(a,b,opr,v,index*2+2,(L+R)/2,R);\n    value_update(index);\n \n  }\n\n  // [a,b) ???????????? opr ?????????\n  void update(int a,int b,char opr,int v){ _update(a,b,opr,v,0,0,limit); } \n\n  tuple<int,int,int> _query(int a,int b,int index,int L,int R){\n    lazy_evaluate(index,L,R); //???????????????????????£??????????????\\??£????????????(?????¶????????????)????????§??????????????§??????????????£??????????????\\??????\n \n    if( b <= L || R <= a ) return make_tuple(0,IINF,-IINF);\n    if( a <= L && R <= b ) return make_tuple(RMQ[index].value,minimum_dat[index],maximum_dat[index]);\n\n\n    auto tmp1 = _query(a,b,index*2+1,L,(L+R)/2);\n    auto tmp2 = _query(a,b,index*2+2,(L+R)/2,R);\n    tuple<int,int,int> ret = make_tuple(get<0>(tmp1)+get<0>(tmp2),min(get<1>(tmp1),get<1>(tmp2)),max(get<2>(tmp1),get<2>(tmp2)));\n    value_update(index); //???????????§????????¨??????????????£???????????£??????????????§??????????????¨??£?????????????????????????????£?????????????????????\n    return ret;\n  }\n\n  // [a,b) ????????????????°????????????§????????????\n  tuple<int,int,int> query(int a,int b) { return _query(a,b,0,0,limit); }\n\n};\n\n\n\n#define MAX 20010\n\nll dp[MAX];\nint N,M;\nll K,A[MAX];\n\nvoid computer() {\n  SegmentTree rmq;\n  {\n    rmq.init(N);\n    vector<int> vec(N);\n    rep(i,N) vec[i] = A[i];\n    rmq.build(vec);\n  }\n  rep(i,N+1) dp[i] = LLONG_MAX;\n  rep(i,N) {\n    dp[i] = ((i-1>=0)?dp[i-1]:0) + K;\n    rep(j,i) {\n      if( i - j + 1 > M ) continue;\n      auto v = rmq.query(j,i+1);\n      ll maxi = get<2>(v);\n      ll mini = get<1>(v);\n      assert( maxi >= mini );\n      dp[i] = min(dp[i],((j-1>=0)?dp[j-1]:0)+K+(ll)(i-j+1) * ( maxi - mini ));\n    }\n  }\n  cout << dp[N-1] << endl;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  rep(i,N) cin >> A[i];\n  computer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 99999999999\n\n\nll** memo;\n\nenum Type{\n\tmax_value,\n\tmin_value,\n};\n\nstruct RMQ{\n\tvoid set(ll arg_minimum,ll arg_maximum){\n\t\tminimum = arg_minimum;\n\t\tmaximum = arg_maximum;\n\t}\n\tll minimum,maximum;\n};\n\nint N = 1;\nRMQ* Tree;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int index, ll orange){\n\n\tindex += N-1;\n\n\tTree[index].minimum = min(Tree[index].minimum,orange);\n\tTree[index].maximum = max(Tree[index].maximum,orange);\n\n\tindex = (index-1)/2;\n\n\twhile(true){\n\n\t\tTree[index].minimum = min(Tree[2*index+1].minimum,Tree[2*index+2].minimum);\n\t\tTree[index].maximum = max(Tree[2*index+1].maximum,Tree[2*index+2].maximum);\n\n\t\tif(index == 0)break;\n\t\telse{\n\t\t\tindex = (index-1)/2;\n\t\t}\n\t}\n}\n\n\nll find(int search_left,int search_right,int node_id,int node_left,int node_right,Type type){\n\n\tif(search_right < node_left || search_left > node_right){\n\t\tif(type == max_value){\n\t\t\treturn -1;\n\t\t}else{ //type == min_value;\n\t\t\treturn NUM;\n\t\t}\n\t}\n\n\tif(search_left <= node_left && search_right >= node_right){\n\t\tif(type == max_value){\n\t\t\treturn Tree[node_id].maximum;\n\t\t}else{\n\t\t\treturn Tree[node_id].minimum;\n\t\t}\n\t}\n\n\tif(type == min_value){\n\t\tll left_min = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_min = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn min(left_min,right_min);\n\t}else{ //type == max_value\n\t\tll left_max = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_max = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn max(left_max,right_max);\n\t}\n}\n\nint first_N,contain_Max,box_Cost;\n\nll recursive(int left,int width){\n\n\tll ret = 0,next = NUM;\n\tif(memo[left][width] != -1){\n\t\treturn memo[left][width];\n\t}else{\n\n\t\tll min_orange = find(left,min(N-1,left+width-1),0,0,N-1,min_value);\n\t\tll max_orange = find(left,min(N-1,left+width-1),0,0,N-1,max_value);\n\t\tret = box_Cost+width*(max_orange-min_orange);\n\t}\n\n\tif(left + width <= first_N-1){\n\t\tfor(int i = 1; i <= contain_Max; i++){\n\t\t\tnext = min(next,recursive(left+width,i));\n\t\t}\n\t\treturn memo[left][width] = ret + next;\n\t}else{\n\t\treturn memo[left][width] = ret;\n\t}\n}\n\nvoid func(){\n\n\tll ans = NUM;\n\n\tfor(int i = 1; i <= contain_Max; i++){\n\t\tans = min(ans,recursive(0,i));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %lld\",&first_N,&contain_Max,&box_Cost);\n\n\tinit(first_N);\n\n\tmemo = new ll*[first_N];\n\tfor(int i = 0; i < first_N; i++){\n\t\tmemo[i] = new ll[contain_Max+1];\n\t\tfor(int k = 0; k <= contain_Max; k++)memo[i][k] = -1;\n\t}\n\n\tTree = (RMQ*)malloc(sizeof(RMQ)*(2*N));\n\n\tfor(int i = 0; i < 2*N-1; i++){\n\t\tTree[i].set(NUM,-1);\n\t}\n\n\tll tmp;\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld\",&tmp);\n\t\tupdate(i,tmp);\n\t}\n\n\tfunc();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll v[20001], dp[2][1010];\nll a[2][1010],b[2][1010];\nint main(){\n\tll n,m,k;\tcin>>n>>m>>k;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>v[i];\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[i][j]=LLONG_MAX;\n\t\t\ta[i][j]=INT_MIN;\tb[i][j]=INT_MAX;\n\t\t}\n\t}\n\tdp[0][0]=k;\ta[0][0]=b[0][0]=v[0];\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(dp[0][j]==LLONG_MAX)\tcontinue;\n\t\t\t//その箱に追加する場合\n\t\t\tif(j+1<m){\n\t\t\t\tdp[1][j+1]=dp[0][j];\n\t\t\t\ta[1][j+1]=max((ll)a[0][j],v[i]);\n\t\t\t\tb[1][j+1]=min((ll)b[0][j],v[i]);\n\t\t\t}\n\t\t\t//新しく箱を作る場合\n\t\t\tll num=k+dp[0][j];\n\t\t\tnum+=(a[0][j]-b[0][j])*(j+1);\n\t\t\tdp[1][0]=min(dp[1][0],num);\n\t\t\ta[1][0]=b[1][0]=v[i];\n\t\t}\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[0][j]=dp[1][j];\tdp[1][j]=LLONG_MAX;\n\t\t\ta[0][j]=a[1][j];\ta[1][j]=INT_MIN;\n\t\t\tb[0][j]=b[1][j];\tb[1][j]=INT_MAX;\n\t\t}\n\t}\n\tll ans=LLONG_MAX;\n\tfor(int i=0;i<m;i++){\n\t\tll num=dp[0][i];\n\t\tnum+=(a[0][i]-b[0][i])*(i+1);\n\t\tans=min(ans,num);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) a.begin(),a.end()\n\nconst int inf = 3e18;\nint dp[20010];\n\nsigned main()\n{\n    int N, M, K; cin >> N >> M >> K;\n\n    vector<int> a(N);\n\n    rep(i, N) cin >> a[i];\n\n    rep(i, N+1) dp[i] = inf;\n    dp[0] = 0;\n\n    rep(i, N) {\n        int mi = inf, ma = 0;\n        rep(j, M) {\n            if (i + j >= N) continue;\n            mi = min(mi, a[i+j]);\n            ma = max(ma, a[i+j]);\n\n            dp[i + j + 1] = min(dp[i + j + 1], dp[i] + (ma - mi) * (j + 1) + K);\n        }\n    }\n\n    cout << dp[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 20001\nconst int inf = 1e18;\n\nint mn[2][MAX], mx[2][MAX];\nint a[MAX], dp[2][MAX];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\tfill((int*)(mn+1), (int*)(mn+2), inf);\n\t\tfill((int*)(mx+1), (int*)(mx+2), 0);\n\t\tfill((int*)(dp+1), (int*)(dp+2), inf);\n\t\t/*for(int j = 0;j < 2;j++){\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tif(dp[j][k] == inf)printf(\"* \");\n\t\t\t\telse printf(\"%d \", dp[j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tif(dp[1][0] > sum){\n\t\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t\t\tdp[1][0] = sum;\n\t\t\t}\n\t\t}\n\t\tswap(mn[0], mn[1]);\n\t\tswap(mx[0], mx[1]);\n\t\tswap(dp[0], dp[1]);\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < n;i++){\n\t\tif(dp[1][i] == inf)continue;\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nlong long int max(int a,int b)\n{\n\tif(a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\nlong long int min(int a,int b)\n{\n\tif(a < b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nusing namespace std;\n\nint N,M,K,A[20000];\n\ntypedef struct _stat\n{\n\tint remain;\n\tlong long int cost;\n} stat;\n\nqueue<stat> qst;\n\nstat makestat(int remain,int cost)\n{\n\tstat t;\n\tt.remain = remain;\n\tt.cost = cost;\n\treturn t;\n}\n\nint getmin(int begin,int end)\n{\n\tint res = 1000000000;\n\tfor(int i = begin;i <= end;i++)\n\t{\n\t\tres = min(res,A[i]);\n\t}\n\treturn res;\n}\n\nint getmax(int begin,int end)\n{\n\tint res = 0;\n\tfor(int i = begin;i <= end;i++)\n\t{\n\t\tres = max(res,A[i]);\n\t}\n\treturn res;\n}\n\n\nint main(void)\n{\n\tcin >> N >> M >> K;\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\tqst.push(makestat(N,0));\n\tstat t;\n\tlong long int mincost = 2147483647;\n\twhile(!qst.empty())\n\t{\n\t\tt.remain = (qst.front()).remain;\n\t\tt.cost = (qst.front()).cost;\n\t\tqst.pop();\n\t\tfor(int i = 1;i < t.remain && i <= M;i++)\n\t\t{\n\t\t\tint cost = K + i * (getmax(N-t.remain,N-t.remain+i-1) - getmin(N-t.remain,N-t.remain+i-1));\n\t\t\tqst.push(makestat(t.remain - i,cost+t.cost));\n\t\t}\n\t\tif(t.remain <= M)\n\t\t{\n\t\t\tint cost = K + t.remain * (getmax(N-t.remain,N-1) - getmin(N-t.remain,N-1));\n\t\t\tmincost = min(mincost,t.cost+cost);\n\t\t}\n\t}\n\tcout << mincost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m;\n  long long k,a[20001],ma,mi,sum[20001];\n  fill(sum,sum+20000,LLONG_MAX);\n  scanf(\"%d %d %lld\",&n,&m,&k);\n  a[0] = 0;\n  sum[0] = 0;\n  for(int i=1;i<=n;i++){\n    scanf(\"%d\",&a[i]);\n    ma = a[i];\n    mi = a[i];\n    sum[i] = sum[i-1] + k+(ma-mi);\n    for(int j=1;i-j > 0 && j<m;j++){\n      ma = max(ma,a[i-j]);\n      mi = min(mi,a[i-j]);\n      sum[i] = min(sum[i],sum[i-j-1] + k+(j+1)*(ma-mi));\n    }\n  }\n  cout << sum[n] << endl;\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nll dp[20001], n, m, k, a[20000];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 9000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=90000000000;\n\t\tfor (ll y = i; y < i + x; y++) {\n\t\t\tma = max(ma, a[y]);\n\t\t\tmi = min(mi, a[y]);\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nll dp[20000], a[20000];\nint main() {\n\tll n, m, k; scanf(\"%lld%lld%lld\", &n, &m, &k);\n\trep(i, n)scanf(\"%lld\", &a[i]);\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\trep(i, n) {\n\t\tll Min = INT_MAX, Max = 0;\n\t\tfor (ll j = 0; j < m&&j + i < n; j++) {\n\t\t\tMin = min(Min, a[j + i]);\n\t\t\tMax = max(Max, a[j + i]);\n\t\t\tdp[i + j + 1] = min(dp[i + j + 1], dp[i] + (Max - Min)*(j + 1) + k);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 99999999999999\n\n\nll** memo;\n\nenum Type{\n\tmax_value,\n\tmin_value,\n};\n\nstruct RMQ{\n\tvoid set(ll arg_minimum,ll arg_maximum){\n\t\tminimum = arg_minimum;\n\t\tmaximum = arg_maximum;\n\t}\n\tll minimum,maximum;\n};\n\nint N = 1;\nRMQ* Tree;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int index, ll orange){\n\n\tindex += N-1;\n\n\tTree[index].minimum = min(Tree[index].minimum,orange);\n\tTree[index].maximum = max(Tree[index].maximum,orange);\n\n\tindex = (index-1)/2;\n\n\twhile(true){\n\n\t\tTree[index].minimum = min(Tree[2*index+1].minimum,Tree[2*index+2].minimum);\n\t\tTree[index].maximum = max(Tree[2*index+1].maximum,Tree[2*index+2].maximum);\n\n\t\tif(index == 0)break;\n\t\telse{\n\t\t\tindex = (index-1)/2;\n\t\t}\n\t}\n}\n\n\nll find(int search_left,int search_right,int node_id,int node_left,int node_right,Type type){\n\n\tif(search_right < node_left || search_left > node_right){\n\t\tif(type == max_value){\n\t\t\treturn -1;\n\t\t}else{ //type == min_value;\n\t\t\treturn NUM;\n\t\t}\n\t}\n\n\tif(search_left <= node_left && search_right >= node_right){\n\t\tif(type == max_value){\n\t\t\treturn Tree[node_id].maximum;\n\t\t}else{\n\t\t\treturn Tree[node_id].minimum;\n\t\t}\n\t}\n\n\tif(type == min_value){\n\t\tll left_min = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_min = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn min(left_min,right_min);\n\t}else{ //type == max_value\n\t\tll left_max = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_max = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn max(left_max,right_max);\n\t}\n}\n\nll box_Cost;\nint first_N,contain_Max;\n\nll recursive(int left,int width){\n\n\tll ret = 0,next = NUM;\n\tif(memo[left][width] != -1){\n\t\treturn memo[left][width];\n\t}else{\n\n\t\tll min_orange = find(left,min(N-1,left+width-1),0,0,N-1,min_value);\n\t\tll max_orange = find(left,min(N-1,left+width-1),0,0,N-1,max_value);\n\t\tret = box_Cost+(ll)width*(max_orange-min_orange);\n\t}\n\n\tif(left + width <= first_N-1){\n\t\tfor(int i = 1; i <= contain_Max; i++){\n\t\t\tnext = min(next,recursive(left+width,i));\n\t\t}\n\t\treturn memo[left][width] = ret + next;\n\t}else{\n\t\treturn memo[left][width] = ret;\n\t}\n}\n\nvoid func(){\n\n\tll ans = NUM;\n\n\tfor(int i = 1; i <= contain_Max; i++){\n\t\tans = min(ans,recursive(0,i));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %lld\",&first_N,&contain_Max,&box_Cost);\n\n\tinit(first_N);\n\n\tmemo = new ll*[first_N];\n\tfor(int i = 0; i < first_N; i++){\n\t\tmemo[i] = new ll[contain_Max+1];\n\t\tfor(int k = 0; k <= contain_Max; k++)memo[i][k] = -1;\n\t}\n\n\tTree = (RMQ*)malloc(sizeof(RMQ)*(2*N));\n\n\tfor(int i = 0; i < 2*N-1; i++){\n\t\tTree[i].set(NUM,-1);\n\t}\n\n\tll tmp;\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld\",&tmp);\n\t\tupdate(i,tmp);\n\t}\n\n\tfunc();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#define int long long\n#define INF 1000000000000000000\n#define REP(i,n) for(int i=1;i<=n;i++)\nint n,m,k;\nint a[20002];\nint cs[20002][1002];\nint sm[20002];\n\nsigned main(){\n  cin>>n>>m>>k;\n  REP(i,n)cin>>a[i];\n  REP(i,n){\n    int mx=0;\n    int mn=INF;\n    REP(j,m){\n      mx=max(mx,a[i+j-1]);\n      mn=min(mn,a[i+j-1]);\n      cs[i][j]=k+j*(mx-mn);\n    }\n  }\n  REP(i,n)sm[i]=INF;\n  REP(i,n)REP(j,m){\n    if(n<i-1+j)continue;\n    sm[i-1+j]=min(sm[i-1+j],sm[i-1]+cs[i][j]);\n  }\n  #ifdef DEBUG\n  REP(i,n){\n    REP(j,m)cout<<cs[i][j]<<\" \";\n    cout<<endl;\n  }\n  REP(i,n)cout<<sm[i]<<\" \";\n  cout<<endl;\n  #endif\n  cout<<sm[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 99999999999999\n\n\nll** memo;\nll** memo2;\n\nenum Type{\n\tmax_value,\n\tmin_value,\n};\n\nstruct RMQ{\n\tvoid set(ll arg_minimum,ll arg_maximum){\n\t\tminimum = arg_minimum;\n\t\tmaximum = arg_maximum;\n\t}\n\tll minimum,maximum;\n};\n\nint N = 1;\nRMQ* Tree;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int index, ll orange){\n\n\tindex += N-1;\n\n\tTree[index].minimum = min(Tree[index].minimum,orange);\n\tTree[index].maximum = max(Tree[index].maximum,orange);\n\n\tindex = (index-1)/2;\n\n\twhile(true){\n\n\t\tTree[index].minimum = min(Tree[2*index+1].minimum,Tree[2*index+2].minimum);\n\t\tTree[index].maximum = max(Tree[2*index+1].maximum,Tree[2*index+2].maximum);\n\n\t\tif(index == 0)break;\n\t\telse{\n\t\t\tindex = (index-1)/2;\n\t\t}\n\t}\n}\n\n\nll find(int search_left,int search_right,int node_id,int node_left,int node_right,Type type){\n\n\tif(search_right < node_left || search_left > node_right){\n\t\tif(type == max_value){\n\t\t\treturn -1;\n\t\t}else{ //type == min_value;\n\t\t\treturn NUM;\n\t\t}\n\t}\n\n\tif(search_left <= node_left && search_right >= node_right){\n\t\tif(type == max_value){\n\t\t\treturn Tree[node_id].maximum;\n\t\t}else{\n\t\t\treturn Tree[node_id].minimum;\n\t\t}\n\t}\n\n\tif(type == min_value){\n\t\tll left_min = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_min = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn min(left_min,right_min);\n\t}else{ //type == max_value\n\t\tll left_max = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_max = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn max(left_max,right_max);\n\t}\n}\n\nll box_Cost;\nint first_N,contain_Max;\n\nll recursive(int left,int width){\n\n\tll ret = 0,next = NUM;\n\tif(memo[left][width] != -1){\n\t\treturn memo[left][width];\n\t}else{\n\n\t\tif(memo2[left][right] != -1){\n\t\t\tret = memo2[left][right];\n\t\t}else{\n\t\t\tll min_orange = find(left,min(N-1,left+width-1),0,0,N-1,min_value);\n\t\t\tll max_orange = find(left,min(N-1,left+width-1),0,0,N-1,max_value);\n\t\t\tmemo2[left][right] = box_Cost+(ll)width*(max_orange-min_orange);\n\t\t\tret = memo2[left][right];\n\t\t}\n\t}\n\n\tif(left + width <= first_N-1){\n\t\tfor(int i = 1; i <= contain_Max; i++){\n\t\t\tnext = min(next,recursive(left+width,i));\n\t\t}\n\t\treturn memo[left][width] = ret + next;\n\t}else{\n\t\treturn memo[left][width] = ret;\n\t}\n}\n\nvoid func(){\n\n\tll ans = NUM;\n\n\tfor(int i = 1; i <= contain_Max; i++){\n\t\tans = min(ans,recursive(0,i));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %lld\",&first_N,&contain_Max,&box_Cost);\n\n\tinit(first_N);\n\n\tmemo = new ll*[first_N];\n\tmemo2 = new ll*[first_N];\n\tfor(int i = 0; i < first_N; i++){\n\t\tmemo[i] = new ll[contain_Max+1];\n\t\tmemo2[i] = new ll[contain_Max+1];\n\t\tfor(int k = 0; k <= contain_Max; k++){\n\t\t\tmemo[i][k] = -1;\n\t\t\tmemo2[i][k] = -1;\n\t\t}\n\t}\n\n\tTree = (RMQ*)malloc(sizeof(RMQ)*(2*N));\n\n\tfor(int i = 0; i < 2*N-1; i++){\n\t\tTree[i].set(NUM,-1);\n\t}\n\n\tll tmp;\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld\",&tmp);\n\t\tupdate(i,tmp);\n\t}\n\n\tfunc();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint N,M,K;\nint A[20000];\nconstexpr int64_t INF = 10000000000000;\n\nint64_t dp[20000];\n//[i?????°??????\nint64_t func(int i)\n{\n\tif(i>=N){return 0;}\n\tif(dp[i]>0){return dp[i];}\n\t\n\tint min=A[i],max=A[i];\n\tint64_t min_cost=INF;\n\tfor(int nexti = i+1,i_end=std::min(i+M,N);nexti<=i_end;++nexti)\n\t{\n\t\tmin_cost = std::min(min_cost,\n\t\t\tfunc(nexti)+K+int64_t(nexti-i)*(max-min));\n\t\tmin=std::min(min, A[nexti]);\n\t\tmax=std::max(max, A[nexti]);\n\t}\n\treturn dp[i]=min_cost;\n}\n\nint main()\n{\n\tstd::cin.sync_with_stdio(false);\n\tstd::cin >> N>>M>>K;\n\tfor(int i =0 ;i < N;++i){\n\t\tstd::cin >> A[i];\n\t}\n\tstd::cout << func(0)<<std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nlong long int dp[20001];\nint main() {\n\tfill(dp, dp + sizeof(dp), static_cast<long long int>((1e18)));\n\tdp[0]= 0;\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<long long int>ws(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> ws[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong long int amin = 1e18;\n\t\tlong long int amax = 0;\n\t\tlong long int cost = K;\n\t\tfor (int j = 0; j < min(N-i,M); ++j) {\n\t\t\tamin = min(amin, ws[i + j]);\n\t\t\tamax = max(amax, ws[i + j]);\n\t\t\tdp[i + j + 1] = min(dp[i + j + 1], dp[i] + cost + (j+1)*(amax - amin));\n\t\t}\n\t}\n\tcout << dp[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nconst ll INF=0xfffffffffffffff;\nconst P PINF=P(INF,-INF);\n\nll N,M,K;\nll A[20000];\n\n\nll dp[20001];//i???????????§?????±??°?????????????°??????????\n\nP p;\n\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&N,&M,&K);\n\trep1(i,N){\n\t\tscanf(\"%lld\",&A[i]);\n\t\tdp[i]=INF;\n\t}\n\tdp[0]=0;\n\trep1(i,N){\n\t\tp=PINF;\n\t\trep(j,min(M,i)){\n\t\t\tp=P(min(p.fr,A[i-j]),max(p.sc,A[i-j]));\n\t\t\tdp[i]=min(dp[i],dp[i-j-1]+(p.sc-p.fr)*(j+1)+K);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[N]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n\n#define MAX_N 20001\n\nusing namespace std;\n\nuint64_t N,M,K,A[MAX_N],T[MAX_N];\n\nuint64_t min(uint64_t a,uint64_t b)\n{\n\tif(a < b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nuint64_t max(uint64_t a,uint64_t b)\n{\n\tif(a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\nint prev_end_min,prev_begin_min,prev_end_max,prev_begin_max,prev_min,prev_max;\nuint64_t getmin(int begin,int end)\n{\n\tif(prev_end_min == end && prev_begin_min == begin + 1)\n\t{\n\t\tif(prev_min > A[begin])\n\t\t{\n\t\t\tprev_min = A[begin];\n\t\t}\n\t\tprev_begin_min = begin;\n\t\treturn prev_min;\n\t}\n\telse\n\t{\n\t\tuint64_t res = UINT64_MAX;\n\t\tfor(int i = begin;i <= end;i++)\n\t\t\tres = min(res,A[i]);\n\t\tprev_begin_min = begin;\n\t\tprev_end_min = end;\n\t\tprev_min = res;\n\t\treturn res;\n\t}\n}\n\nuint64_t getmax(int begin,int end)\n{\n\tif(prev_end_max == end && prev_begin_max == begin + 1)\n\t{\n\t\tif(prev_max < A[begin])\n\t\t{\n\t\t\tprev_max = A[begin];\n\t\t}\n\t\tprev_begin_max = begin;\n\t\treturn prev_max;\n\t}\n\telse\n\t{\n\t\tuint64_t res = 0;\n\t\tfor(int i = begin;i <= end;i++)\n\t\t\tres = max(res,A[i]);\n\t\tprev_begin_max = begin;\n\t\tprev_end_max = end;\n\t\tprev_max = res;\n\t\treturn res;\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M >> K;\n\tfor(int i = 0;i < MAX_N;i++)\n\t{\n\t\tT[i] = UINT64_MAX;\n\t}\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\tT[N] = 0;\n\tfor(int i = N-1;i >= 0;i--)\n\t{\n\t\tfor(int k = 1;k <= M && (i + k) <= N ;k++)\n\t\t{\n\t\t\tuint64_t cost = K + (k * (getmax(N-(i+k),(N-i)-1) - getmin(N-(i+k),(N-i)-1)));\n\t\t\tT[i] = min(T[i],T[i+k]+cost);\n\t\t}\n\t}\n\tcout << T[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,K;\nlong long L,R,A[20001],dp[20001];\n\nint main(){\n  scanf(\"%d %d %d\",&N,&M,&K);\n  for(int i=1;i<=N;i++){\n    scanf(\"%lld\",&A[i]);\n    dp[i]=(1LL<<60);\n    L=R=A[i];\n    for(int j=1;j<=M&&i-j>=0;j++){\n      dp[i]=min(dp[i],dp[i-j]+(R-L)*j+K);\n      L=min(L,A[i-j]);R=max(R,A[i-j]);\n    }\n  }\n  printf(\"%lld\\n\",dp[N]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF (10000000000000000LL)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nint main()\n{\n    int N,M;\n    long long K;\n    cin >> N >> M >> K;\n\n    vector<long long> A;\n    for(int i=0; i<N; ++i) {\n        long long temp;\n        cin >> temp;\n        A.push_back(temp);\n    }\n\n    long long dp[2][N];\n    long long mn=INF;\n    long long mx=-1;\n\n    for(int i=0; i<N; ++i) {\n        if(i<M) {\n            mn=MIN(mn,A[i]);\n            mx=MAX(mx,A[i]);\n            dp[0][i]=K+(i+1)*(mx-mn);\n        } else {\n            dp[0][i]=INF;\n        }\n    }\n\n\n    for(int i=1; i<N; ++i) {\n        for(int j=0; j<N; ++j) {\n            long long temp=INF;\n            mn=INF; mx=-1;\n            for(int k=1; k<=M && j-k>=0; ++k) {\n                mn=MIN(mn,A[j-k+1]);\n                mx=MAX(mx,A[j-k+1]);\n                temp=MIN(temp,dp[(i-1)%2][j-k]+K+k*(mx-mn));\n            }\n            dp[i%2][j]=MIN(temp,dp[(i-1)%2][j]);\n        }\n    }\n\n    cout << dp[(N-1)%2][N-1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF 10000000;\nunsigned long long int dp[200001];\nunsigned long long int orange[200001];\nint main(){\n\tunsigned long long int _max, _min;\n\tunsigned long long int  N, M, K;\n\tdp[0] = 0;\n\tcin >> N >> M >> K;\n\tfor (int i = 1; i <= N; i++) cin >> orange[i];\n\tfor (int i = 1; i <= N; i++){\n\t\tdp[i] = INF;\n\t\t_max = 0;\n\t\t_min = INF;\n\t\tfor (int j = i; j <= i + M - 1 && j <= N; j++){\n\t\t\t_max = max(orange[j], _max);\n\t\t\t_min = min(orange[j], _min);\n\t\t\tdp[j] = min(dp[j], K + (j - i)*(_max - _min) + dp[i - 1]);\n\t\t}\n\t}\n\tcout << dp[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n#define N 20010\n#define M 1005\n#define LLINF 2000000000000000000LL\nll dp[N];\n\nint main(){\n  int n,m,k;\n  ll a[N];\n\n  scanf(\"%d%d%d\",&n,&m,&k);\n\n  for(int i=0;i<=n;i++){\n    dp[i] = LLINF;\n  }\n\n  for(int i=0;i<n;i++){\n    scanf(\"%lld\",a+i);\n  }\n  \n  dp[0] = 0;\n\n  for(int i=0;i<n;i++){\n    ll min_a = LLINF;\n    ll max_a = 0;\n\n    for(int j=0;j<m;j++){\n      if(i+j >= n) break;\n      \n      min_a = min(min_a,a[i+j]);\n      max_a = max(max_a,a[i+j]);\n\n      dp[i+j+1] = min(dp[i+j+1],dp[i]+(k+(j+1)*(max_a-min_a)));\n    }\n  }\n      \n  printf(\"%lld\\n\",dp[n]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\n\nconst int MAX_N=2e4;\n\nint N,M,K;\nint A[MAX_N];\n\nll dp[MAX_N+1];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin>>N>>M>>K;\n\tREP(i,N){\n\t\tcin>>A[i];\n\t}\n\tdp[0]=0;\n\tFOR(i,1,N+1){\n\t\tdp[i]=K+dp[i-1];\n\t\tint ma=A[i-1],mi=A[i-1];\n\t\tFOR(j,2,min(M,i)+1){\n\t\t\tma=max(ma,A[i-j]);\n\t\t\tmi=min(mi,A[i-j]);\n\t\t\tdp[i]=min(dp[i],K+(ll)j*(ma-mi)+dp[i-j]);\n\t\t}\n\t}\n\tcout<<dp[N]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint n, m, k;\nint a[20000];\nint dp[20000];\n\nint dfs(int id) {\n\tif (id >= n) return 0;\n\tif (dp[id] != 0) return dp[id];\n\n\tint ret = 2000000000000000000;\n\tint maxi = -1145141919;\n\tint mini = 1145141919;\n\tfor (int s = 1; s <= m; s++) {\n\t\tif (id + s > n) { continue; }\n\t\tmaxi = max(maxi, a[id + s - 1]);\n\t\tmini = min(mini, a[id + s - 1]);\n\t\tret = min(ret, dfs(id + s) + k + s * (maxi - mini));\n\t}\n\treturn (dp[id] = ret);\n}\n\nsigned main() {\n\tcin >> n >> m >> k;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tcout << dfs(0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nconst ll INF=0xfffffffffffffff;\nconst P PINF=P(INF,-INF);\n\nll N,M,K;\nll A[20001];\n\n\nll dp[20001];//i???????????§?????±??°?????????????°??????????\n\nP p;\n\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&N,&M,&K);\n\trep1(i,N){\n\t\tscanf(\"%lld\",&A[i]);\n\t\tdp[i]=INF;\n\t}\n\tdp[0]=0;\n\trep1(i,N){\n\t\tp=PINF;\n\t\trep(j,min(M,i)){\n\t\t\tp=P(min(p.fr,A[i-j]),max(p.sc,A[i-j]));\n\t\t\tdp[i]=min(dp[i],dp[i-j-1]+(p.sc-p.fr)*(j+1)+K);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[N]);\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nlong long N,M,K;\nlong long A[20001]={};\nlong long dp[20001][1001];\nlong long maxD[20001][1001];\nlong long minD[20001][1001];\nconst long long INF=100000000000000000;\n\nlong long calc(long long n1,long long m1){\n\tlong long ans=INF;\n\tif(dp[n1][m1]>-1)return dp[n1][m1];\n\tif(m1>0){\n\t\tans=calc(n1,0);\n\t}else{\n\t\tfor(long long i=1;i<M+1&&i<n1+1;++i){\n\t\t\tans=min(ans,calc(n1-i,0)+K+i*(maxD[n1-i][i]-minD[n1-i][i]));\n\t\t}\n\t}\n\tdp[n1][m1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(long long i=1;i<N+1;i++)cin>>A[i];\n\n\tfill(dp[0],dp[20001],-1);\n\tfor(int i=0;i<N+1;i++){\n\t\tmaxD[i][0]=0;\n\t\tminD[i][0]=INF;\n\t\tfor(int j=1;j<M+1;j++){\n\t\t\tmaxD[i][j]=max(maxD[i][j-1],A[i+j]);\n\t\t\tminD[i][j]=min(minD[i][j-1],A[i+j]);\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tlong long R=0;\n\tfor(int i=1;i<N+1;i++)R=calc(i,0);\n\tcout<<R<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nlong long N,M,K;\nlong long A[20001]={};\nlong long dp[20001];\nlong long mmD[20001][1001];\nconst long long INF=100000000000000000;\n\nlong long calc(long long n1,long long m1){\n\tif(dp[n1]>-1)return dp[n1];\n\tlong long ans=INF;\n\tif(m1>0){\n\t\tans=calc(n1,0);\n\t}else{\n\t\tfor(long long i=1;i<M+1&&i<n1+1;++i){\n\t\t\tans=min(ans,calc(n1-i,0)+K+i*mmD[n1-i][i]);\n\t\t}\n\t}\n\tdp[n1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(long long i=1;i<N+1;i++)cin>>A[i];\n\n\tfill(dp,dp+20001,-1);\n\tlong long maxD[1001]={};\n\tlong long minD[1001]={};\n\n\tfor(int i=0;i<N+1;i++){\n\t\tmaxD[0]=0;\n\t\tminD[0]=INF;\n\t\tfor(int j=1;j<M+1;j++){\n\t\t\tmaxD[j]=max(maxD[j-1],A[i+j]);\n\t\t\tminD[j]=min(minD[j-1],A[i+j]);\n\t\t\tmmD[i][j]=maxD[j]-minD[j];\n\t\t}\n\t}\n\tdp[0]=0;\n//\tlong long R;\n//\tfor(int i=1;i<N;i++){\n//\t\tfor(int j=0;j<M+1;j++)\n//\t\tR=calc(i,j);\n//\t}\n//\tR=calc(N,0);\n//\tcout<<R<<endl;\n\tcout<<calc(N,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing ll = long long;\nusing namespace std;\n\n#define Input(x) scanf(\"%lld\",&x)\n\nll n, m, k;\nll a[23456];\n\nconst ll INF = 123456789012345678;\n\nll memo[23456];\nll dfs(ll x_)\n{\n\tif (memo[x_] >= 0)return memo[x_];\n\tll minor = INF,maxor = 0;\n\tll answer = INF;\n\tfor (int box = 1; box <= m; ++box)\n\t{\n\t\tif (x_ - box < 0)break;\n\t\tminor = min(minor, a[x_ - box]);\n\t\tmaxor = max(maxor, a[x_ - box]);\n\t\tanswer = min(answer, dfs(x_ - box) + k + box * (maxor - minor));\n\t}\n\treturn memo[x_] = answer;\n}\n\nint main()\n{\n\tInput(n); Input(m); Input(k);\n\tfor (int i = 0; i < n; ++i)Input(a[i]);\n\tmemset(memo, 0xFF, sizeof(memo));\n\tmemo[0] = 0;\n\tprintf(\"%lld\\n\", dfs(n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 3e18;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, K;\nint A[20005];\nint memo[20005];\n\nint rec(int now)\n{\n    if (~memo[now]) return memo[now];\n\n    int res = inf;\n    int mi = inf, ma = -inf;\n    \n    for (int i = 0; i < min(N - now, M); ++i) {\n        mi = min(mi, A[now + i]);\n        ma = max(ma, A[now + i]);\n\n        res = min(res, K + (ma - mi) * (i + 1) + rec(now + i + 1));\n    }\n\n    if (res == inf) res = 0;\n\n    return memo[now] = res;\n}\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    omajinai;\n    cin >> N >> M >> K;\n\n    rep(i, N) {\n        cin >> A[i];\n    }\n\n    memset(memo, -1, sizeof (memo));\n\n    cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int IINF = INT_MAX;\nconst char EMPTY = 'X';\n \nstruct Node{\n  int value;\n  /*\n    lazy : \n    A : ??????????????¶ ( ADD )\n    S : ?????????????´?????????????????????????????????¶ ( SET )\n\n    lazy_coef : \n    ????????????????????????????????????or???????????????????????????????¨????\n  */\n  char lazy;\n  int lazy_coef; \n  Node(int value=0,char lazy=EMPTY,int lazy_coef=0):value(value),lazy(lazy),lazy_coef(lazy_coef){}\n};\n \nclass SegmentTree{\npublic:\n  vector<Node> RMQ;\n  vector<int> minimum_dat,maximum_dat;\n  int limit,N; // N ???????´???°\n \n  void init(int tmp){\n    N = tmp;\n    int N_N = 1;\n    while(N_N < N)N_N *= 2;\n    limit = N_N;\n    RMQ.resize(3*limit);\n    minimum_dat.resize(3*limit);\n    maximum_dat.resize(3*limit);\n    rep(i,3*limit-1) {\n      RMQ[i] = Node();\n      minimum_dat[i] =  IINF;\n      maximum_dat[i] = -IINF;\n    }\n  }\n\n  /* \n     O(n)??§RMQ????????????\n     [L,R)\n     tuple<int,int,int>(?????????????°????????????§???)\n  */\n  tuple<int,int,int> _build(int cur,int L,int R,const vector<int> &buf){\n\n    if( !( 0 <= cur && cur < 2*limit-1 ) ) return tuple<int,int,int>(0,IINF,-IINF);\n    if( L == R-1 ){\n      if( L >= N ) return tuple<int,int,int>(0,IINF,-IINF);\n      //???????´??????????????????§????????´??? ( ??????????????????????????????????????§?????????????????´??? )\n      //buf[] ?????¨??????????????\\??? RMQ[cur].value = buf[L]; ??¨??????\n      // RMQ???L?????????????´????buf[L]??§??´??°\n      RMQ[cur].value = buf[L];\n      minimum_dat[cur] = buf[L];\n      maximum_dat[cur] = buf[L];\n      //???????´??????¨??????????????´???\n      //RMQ[cur] = 0; // RMQ ??????????´?????????§???????????? 1 ?????? RMQ[cur] = 1????????????...\n      //minimum_dat[cur] = 0;\n      //maximum_dat[cur] = 0;\n    } else {\n      tuple<int,int,int> vl = _build(cur*2+1,L,(L+R)/2,buf);\n      tuple<int,int,int> vr = _build(cur*2+2,(L+R)/2,R,buf);\n      RMQ[cur].value = get<0>(vl) + get<0>(vr);\n      minimum_dat[cur] = min(get<1>(vl),get<1>(vr));\n      maximum_dat[cur] = max(get<2>(vl),get<2>(vr));\n    }\n    return tuple<int,int,int>(RMQ[cur].value,minimum_dat[cur],maximum_dat[cur]);\n  }\n\n  //init?????????????????¨???????????¨!!! ??§????????¨limit?????£??????????????\\??£???????????????\n  void build(const vector<int> &buf) { _build(0,0,limit,buf); }\n\n  inline void value_evaluate(int index,int L,int R){\n    if( RMQ[index].lazy == 'A' ){\n      RMQ[index].value += ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] += RMQ[index].lazy_coef;\n      maximum_dat[index] += RMQ[index].lazy_coef;\n    } else if( RMQ[index].lazy == 'S' ){\n      RMQ[index].value = ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] = RMQ[index].lazy_coef;\n      maximum_dat[index] = RMQ[index].lazy_coef;\n    }\n  }\n   \n  inline void lazy_evaluate(int index,int L,int R){\n    value_evaluate(index,L,R);\n    if( index < limit && RMQ[index].lazy != EMPTY ) {\n      if( RMQ[index].lazy == 'A' ) {\n        if( RMQ[index*2+1].lazy == EMPTY ) RMQ[index*2+1].lazy = 'A'; \n        if( RMQ[index*2+2].lazy == EMPTY ) RMQ[index*2+2].lazy = 'A';\n        RMQ[index*2+1].lazy_coef += RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef += RMQ[index].lazy_coef;\n      } else if( RMQ[index].lazy == 'S') {\n        RMQ[index*2+1].lazy = RMQ[index*2+2].lazy = 'S';\n        RMQ[index*2+1].lazy_coef = RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef = RMQ[index].lazy_coef;\n      }\n    }\n    RMQ[index].lazy = EMPTY;\n    RMQ[index].lazy_coef = 0;\n  }\n \n  inline void value_update(int index){\n    RMQ[index].value = RMQ[index*2+1].value + RMQ[index*2+2].value;\n    minimum_dat[index] = min(minimum_dat[index*2+1],minimum_dat[index*2+2]);\n    maximum_dat[index] = max(maximum_dat[index*2+1],maximum_dat[index*2+2]);\n  }\n \n  /*\n  //[a,b)???????????????opr?????????\n  ??????????????¬??????[L,R)\n  [a,b)??????????´????????????????\n  opr ??? 'A'??????v????????? ( ADD )\n  opr ??? 'S'??????v????????? ( SET )\n  */\n  void _update(int a,int b,char opr,int v,int index,int L,int R){\n    /*\n      RMQ[index].lazy ???EMPTY??\\?????????????????????????????????????????§????????°\n      ???????????¶???????????????????????????\n    */\n    lazy_evaluate(index,L,R);\n \n    if( b <= L || R <= a )return;\n    if( a <= L && R <= b ){\n      /*\n        [L,R)???????????????????????\\??£????????§???????????§?????????????????? ( ???????????????????????´??°?????????????????´??°?????????, ????????£???????????¶?????????????????? )\n        [??????????????????]            [??????????????????]\n        [??????]  [??????]     => [??????,?????¶] [??????,?????¶]\n        ??????????????????????????????\n        ??????????????????????¨??????????????????¶????????????????????????\n      */\n      RMQ[index].lazy = opr; // ??????????????????????????¶????¨??????????????????????????????????\n      if( opr == 'A' )      RMQ[index].lazy_coef += v; \n      else if( opr == 'S' ) RMQ[index].lazy_coef = v; \n      lazy_evaluate(index,L,R);\n      return;\n    }\n \n    _update(a,b,opr,v,index*2+1,L,(L+R)/2);\n    _update(a,b,opr,v,index*2+2,(L+R)/2,R);\n    value_update(index);\n \n  }\n\n  // [a,b) ???????????? opr ?????????\n  void update(int a,int b,char opr,int v){ _update(a,b,opr,v,0,0,limit); } \n\n  tuple<int,int,int> _query(int a,int b,int index,int L,int R){\n    lazy_evaluate(index,L,R); //???????????????????????£??????????????\\??£????????????(?????¶????????????)????????§??????????????§??????????????£??????????????\\??????\n \n    if( b <= L || R <= a ) return make_tuple(0,IINF,-IINF);\n    if( a <= L && R <= b ) return make_tuple(RMQ[index].value,minimum_dat[index],maximum_dat[index]);\n\n\n    auto tmp1 = _query(a,b,index*2+1,L,(L+R)/2);\n    auto tmp2 = _query(a,b,index*2+2,(L+R)/2,R);\n    tuple<int,int,int> ret = make_tuple(get<0>(tmp1)+get<0>(tmp2),min(get<1>(tmp1),get<1>(tmp2)),max(get<2>(tmp1),get<2>(tmp2)));\n    value_update(index); //???????????§????????¨??????????????£???????????£??????????????§??????????????¨??£?????????????????????????????£?????????????????????\n    return ret;\n  }\n\n  // [a,b) ????????????????°????????????§????????????\n  tuple<int,int,int> query(int a,int b) { return _query(a,b,0,0,limit); }\n\n};\n\n\n\n#define MAX 20010\n\nll dp[MAX];\nint N,M;\nll K,A[MAX];\n\nvoid computer() {\n  SegmentTree rmq;\n  {\n    rmq.init(N);\n    vector<int> vec(N);\n    rep(i,N) vec[i] = A[i];\n    rmq.build(vec);\n  }\n  rep(i,N+1) dp[i] = LLONG_MAX;\n  rep(i,N) {\n    dp[i] = ((i-1>=0)?dp[i-1]:0) + K;\n    for(int j=i-1;j>=0;--j) {\n      if( i - j + 1 > M ) break;\n      auto v = rmq.query(j,i+1);\n      ll maxi = get<2>(v);\n      ll mini = get<1>(v);\n      assert( maxi >= mini );\n      dp[i] = min(dp[i],((j-1>=0)?dp[j-1]:0)+K+(ll)(i-j+1) * ( maxi - mini ));\n    }\n  }\n  cout << dp[N-1] << endl;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  rep(i,N) cin >> A[i];\n  computer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll a[20000], shou[80000], dai[80000], dp[20000], n, m, k2;\nconst ll inf = 99999999999999999;\nint start, ruend;\nll ma, mi;\nvoid update(int i, ll x) {\n\tshou[i] = x;\n\tdai[i] = x;\n\twhile (i > 0) {\n\t\ti = floor((i - 1) / 2.0);\n\t\tshou[i] = min(shou[i * 2 + 1], shou[i * 2 + 2]);\n\t\tdai[i] = max(dai[i * 2 + 1], dai[i * 2 + 2]);\n\t}\n}\nvoid query(int a, int b, int k, int l, int r) {\n\t//a??????b???????°????//k???l??\\???r??\\????????????\n\tif (b<l || a>r) return;\n\tif (l >= a&&r <= b) {\n\t\tma = max(ma, dai[k]);\n\t\tmi = min(mi, shou[k]);\n\t}\n\telse {\n\t\tquery(a, b, k * 2 + 1, l, floor((l + r) / 2.0));\n\t\tquery(a, b, k * 2 + 2, ceil((l + r) / 2.0), r);\n\t}\n}\nll solve(int i) {\n\tif (i == n) return 0;\n\tll sum = inf;\n\tfor (int j = 1; j <= m&&i + j <= n; j++) {\n\t\tll res = k2;\n\t\tma = -1;\n\t\tmi = inf;\n\t\tquery(start + i, start + i + j - 1, 0, start, ruend);\n\t\tres += (j*(ma - mi));\n\t\tif (dp[i + j] != -1) sum = min(sum, res + dp[i + j]);\n\t\telse {\n\t\t\tsum = min(sum, res + (dp[i + j] = solve(i + j)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\tcin >> n >> m >> k2;\n\tfor (ll i = 0; i < n * 4; i++) {\n\t\tshou[i] = inf;\n\t\tdai[i] = -1;\n\t}\n\tll io = 0, iop = 1;\n\twhile (iop < n) {\n\t\tio += iop;\n\t\tiop *= 2;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tdp[i] = -1;\n\t\tupdate(io + i, a[i]);\n\t}\n\tstart = io;\n\truend = io + iop - 1;\n\tcout << solve(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll N, M, K;\nll A[20005];\nll cost[20005][1005];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> M >> K;\n\n\tfor (int i = 1;i <= N;i++){\n\t\tcin >> A[i];\n\t}\n\n\tfor (int i = 1;i <= N;i++){\n\t\tll MIN = LLONG_MAX;\n\t\tll MAX = -1;\n\t\tfor (int j = 0;j < M;j++){\n\t\t\tif(i+j > N) break;\n\t\t\tMIN = min(MIN, A[i+j]);\n\t\t\tMAX = max(MAX, A[i+j]);\n\t\t\tcost[i][j] = K + (j+1)*(MAX-MIN);\n\t\t}\n\t}\n\n\n\tll dp[20005]; fill(dp, dp+N+1, LLONG_MAX);\n\tdp[0] = 0;\n\n\tfor (int i = 0;i < N;i++){\n\t\tfor (int j = 0;j < M;j++){\n\t\t\tif(i+1+j > N) break;\n\t\t\tdp[i+1+j] = min(dp[i+1+j], dp[i]+cost[i+1][j]);\n\t\t}\n\t}\n\n\tcout << dp[N] << endl;\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint N,M,K;\nlong long int *orange;\nlong long int *memo;\nlong long int answer(int);\nint main(){\n    cin>>N>>M>>K;\n    orange=new long long int [N];\n    memo = new long long int [N]{0};\n    for(int i=0;i<N;++i){\n        cin>>orange[i];\n    }\n    cout<<answer(0)<<endl;\n    return 0;\n}\n\nlong long int answer(int npoint){\n    if(npoint==N)return 0;\n    else if(memo[npoint]!=0)return memo[npoint];\n    long long int nmin,nmax,na;\n    na=answer(npoint+1)+K;\n    nmin=orange[npoint];\n    nmax=nmin;\n    for(int nlong=1;nlong+npoint<N&&nlong<M;++nlong){\n        nmin=min(nmin,orange[npoint+nlong]);\n        nmax=max(nmax,orange[npoint+nlong]);\n        na=min(na,(nmax-nmin)*(nlong+1)+K+answer(nlong+npoint+1));\n    }\n    memo[npoint]=na;\n    return na;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nconst ll INF =0xfffffffffffffff;\nstruct T{\n\tll val,min,max;\n};\n\nT dp[2][1001];//\nT (*prv);\nT (*nxt);\nll N,M,K;\nll A[20001];\nll valmin[20001];\n\nint main()\n{\n\tscanf(\"%lld%lld%lld\",&N,&M,&K);\n\trep(i,N) scanf(\"%lld\",&A[i]);\n\tfill(dp[0],dp[2],T{INF,INF,-INF});\n\tprv=dp[0];\n\tnxt=dp[1];\n\tprv[1]=T{K,A[0],A[0]};\n\tvalmin[0]=K;\n\trep(i,N-1){\n\t\trep(j,M+1) nxt[j]=T{INF,INF,-INF};\n\t\tvalmin[i+1]=nxt[1].val=valmin[i]+K;\n\t\tnxt[1].min=nxt[1].max=A[i+1];\n\t\t\n\t\trep1(j,M-1){\n\t\t\tif(prv[j].val==INF) continue;\n\t\t\tnxt[j+1]=prv[j];\n\t\t\tif(prv[j].min<=A[i+1]&&A[i+1]<=prv[j].max){\n\t\t\t\tnxt[j+1].val+=(nxt[j+1].max-nxt[j+1].min);\n\t\t\t}\n\t\t\telse if(prv[j].max<A[i+1]){\n\t\t\t\tnxt[j+1].max=A[i+1];\n\t\t\t\tnxt[j+1].val+=(A[i+1]-prv[j].max)*j;\n\t\t\t\tnxt[j+1].val+=(nxt[j+1].max-nxt[j+1].min);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnxt[j+1].min=A[i+1];\n\t\t\t\tnxt[j+1].val+=(prv[j].min-A[i+1])*j;\n\t\t\t\tnxt[j+1].val+=(nxt[j+1].max-nxt[j+1].min);\n\t\t\t}\n\t\t\tvalmin[i+1]=min(valmin[i+1],nxt[j+1].val);\n\t\t}\n\t\tswap(nxt,prv);\n\t}\n\tprintf(\"%lld\\n\",valmin[N-1]);\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nlong long N,M,K;\nlong long A[20001]={};\nlong long dp[20001];\nlong long mmD[20001][1001];\nconst long long INF=100000000000000000;\n\nlong long calc(long long n1){\n\tif(dp[n1]>-1)return dp[n1];\n\tlong long ans=INF;\n\tfor(long long i=1;i<M+1&&i<n1+1;++i){\n\t\t\tans=min(ans,calc(n1-i)+K+i*mmD[n1-i][i]);\n\t}\n\tdp[n1]=ans;\n\treturn ans;\n}\n\nint main() {\n\tcin>>N>>M>>K;\n\tfor(long long i=1;i<N+1;i++)cin>>A[i];\n\n\tfill(dp,dp+20001,-1);\n\tlong long maxD[1001]={};\n\tlong long minD[1001]={};\n\n\tfor(int i=0;i<N+1;i++){\n\t\tmaxD[0]=0;\n\t\tminD[0]=INF;\n\t\tfor(int j=1;j<M+1&&(i+j)<N+1;j++){\n\t\t\tmaxD[j]=max(maxD[j-1],A[i+j]);\n\t\t\tminD[j]=min(minD[j-1],A[i+j]);\n\t\t\tmmD[i][j]=maxD[j]-minD[j];\n\t\t}\n\t}\n\tdp[0]=0;\n//\tlong long R;\n//\tfor(int i=1;i<N;i++){\n//\t\tfor(int j=0;j<M+1;j++)\n//\t\tR=calc(i,j);\n//\t}\n//\tR=calc(N,0);\n//\tcout<<R<<endl;\n\tcout<<calc(N)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e18;\nll v[20001], dp[2][1010];\nll a[2][1010],b[2][1010];\nint main(){\n\tll n,m,k;\tcin>>n>>m>>k;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>v[i];\n\t}\n\tfill((ll*)dp, (ll*)(dp+2), INF);\n\tfill((ll*)b, (ll*)(b+2), INF);\n\t/*fill((), ()(), INF);\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[i][j]=INF;\n\t\t\tb[i][j]=INF;\n\t\t}\n\t}*/\n\tdp[0][0]=k;\ta[0][0]=b[0][0]=v[0];\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(dp[0][j]==INF)\tcontinue;\n\t\t\t//その箱に追加する場合\n\t\t\tif(j+1<m){\n\t\t\t\tdp[1][j+1]=dp[0][j];\n\t\t\t\ta[1][j+1]=max((ll)a[0][j],v[i]);\n\t\t\t\tb[1][j+1]=min((ll)b[0][j],v[i]);\n\t\t\t}\n\t\t\t//新しく箱を作る場合\n\t\t\tll num=k+dp[0][j];\n\t\t\tnum+=(a[0][j]-b[0][j])*(j+1);\n\t\t\tdp[1][0]=min(dp[1][0],num);\n\t\t\ta[1][0]=b[1][0]=v[i];\n\t\t}\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[0][j]=dp[1][j];\tdp[1][j]=INF;\n\t\t\ta[0][j]=a[1][j];\ta[1][j]=0;\n\t\t\tb[0][j]=b[1][j];\tb[1][j]=INF;\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(int i=0;i<m;i++){\n\t\tll num=dp[0][i];\n\t\tnum+=(a[0][i]-b[0][i])*(i+1);\n\t\tans=min(ans,num);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nlong long N,M,K;\nlong long A[20001]={};\nlong long dp[20001][1001];\nlong long maxD[20001][1001];\nlong long minD[20001][1001];\nconst long long INF=100000000000000000;\n\nlong long calc(long long n1,long long m1){\n\tlong long ans=INF;\n\tif(dp[n1][m1]>-1)return dp[n1][m1];\n\tif(m1>0){\n\t\tans=calc(n1,0);\n\t}else{\n\t\tfor(long long i=1;i<M+1&&i<n1+1;++i){\n\t\t\tans=min(ans,calc(n1-i,0)+K+i*(maxD[n1-i][i]-minD[n1-i][i]));\n\t\t}\n\t}\n\tdp[n1][m1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(long long i=1;i<N+1;i++)cin>>A[i];\n\n\tfill(dp[0],dp[20001],-1);\n\tfor(int i=0;i<N+1;i++){\n\t\tmaxD[i][0]=0;\n\t\tminD[i][0]=INF;\n\t\tfor(int j=1;j<M+1;j++){\n\t\t\tmaxD[i][j]=max(maxD[i][j-1],A[i+j]);\n\t\t\tminD[i][j]=min(minD[i][j-1],A[i+j]);\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tcout<<calc(N,0)<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nlong long box[20001];\nint main(void)\n{\n\tint n,a[20001],m,k,i,j,MIN,MAX;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tbox[i]=0;\n\t}\n\tbox[0]=0;\n\tfor(i=1;i<=n;i++){\n\t\tMIN=1000000001;\n\t\tMAX=0;\n\t\tfor(j=0;j<m;j++){\n\t\t\tif(i+j>n){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tMIN=min(MIN,a[i+j]);\n\t\t\tMAX=max(MAX,a[i+j]);\n\t\t\tbox[i+j]=min(box[i+j],(long long)(MAX-MIN)*(j+1)+k+box[i-1]);\n\t\t\tif(box[i+j]==0){\n\t\t\t\tbox[i+j]=(long long)(MAX-MIN)*(j+1)+k+box[i-1];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",box[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nstruct P {\n\tlong long ma, mi;\n};\nll dp[20001], n, m, k, a[20000];\nP c[200];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 9000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=90000000000;\n\t\tfor (ll y = i; y < i + x; ) {\n\t\t\tif (y % 150 == 0&&y+150<i+x) {\n\t\t\t\tma = max(c[(y / 150)].ma, ma);\n\t\t\t\tmi = min(c[y / 150].mi, mi);\n\t\t\t\ty += 100;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tma = max(ma, a[y]);\n\t\t\t\tmi = min(mi, a[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tfor (ll i = 0; i < floor(i / 150); i++) {\n\t\t\tll ma = -1, mi = 900000000000000;\n\t\t\tfor (ll j = i * 150; j < (i + 1) * 150; j++) {\n\t\t\t\tma = max(ma, a[j]);\n\t\t\t\tmi = min(mi, a[j]);\n\t\t\t}\n\t\t\tc[i].ma = ma;\n\t\t\tc[i].mi = mi;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1001001001001001\nusing namespace std;\ntypedef long long ll;\n\nll dp[20010];\nll ary[20010];\nint main(){\n\tll N,M,K;\n\tcin>>N>>M>>K;\n\tfor(int i=1;i<=N;i++){\n\t\tcin>>ary[i];\n\t}\n\t/*\n\tfill(dp[0],dp[0]+N+1,INF);\n\tfill(dp[1],dp[1]+N+1,INF);\n\tdp[0][0]=0;\n\tint in=0,ou=1;\n\tll res=INF;\n\tfor(int i=0;i<N;i++){\n\t\tfill(dp[ou],dp[ou]+N+1,INF);\n\t\tll cnt,ma,mi;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tcnt=0;ma=0;mi=INF;\n\t\t\tfor(int k=1;k<=M&&j+k<=N;k++){\n\t\t\t\tma=max(ma,ary[j+k]);\n\t\t\t\tmi=min(mi,ary[j+k]);\n\t\t\t\tdp[ou][j+k]=min(dp[ou][j+k],dp[in][j]+K+k*(ma-mi));\n\t\t\t}\n\t\t}\n\t\tres=min(res,dp[ou][N]);\n\t\tswap(in,ou);\n\t}\n\t*/\n\tfill(dp,dp+N+1,INF);\n\tdp[0]=0;\n\tfor(int i=0;i<N;i++){\n\t\tll ma=0,mi=INF;\n\t\tfor(int j=1;j<=M&&i+j<=N;j++){\n\t\t\tma=max(ma,ary[i+j]);\n\t\t\tmi=min(mi,ary[i+j]);\n\t\t\tdp[i+j]=min(dp[i+j],dp[i]+K+j*(ma-mi));\n\t\t}\n\t}\n\tcout<<dp[N]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll N,M,K;\nll A[100005];\n\nll dp[20000];\n\nconst ll INF = 1000000000000000000LL;\n\nll solve(){\n  fill(dp,dp+N+1,INF);\n  dp[0] = 0;\n  for(ll i=1;i<=N;i++){\n    ll a = A[i-1], b = A[i-1];\n    for(ll j=i-1;j>=max(0LL,i-M);j--){\n      b = min( A[j], b );\n      a = max( A[j], a );\n      ll c = K + (i-j)*(a-b);\n      dp[i] = min( dp[i], dp[j] + c );\n    }\n  }\n  return dp[N];\n}\n\nint main(){\n  cin >>N >> M >> K;\n  assert( N < 50000 );\n  for(int i=0;i<N;i++)\n    cin >> A[i];\n  cout << solve() << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 200001\nconst int inf = 1e18;\n\nint mn[2][1010], mx[2][1010];\nint a[MAX], dp[2][1010];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tmn[0][j] = mn[1][j];mn[1][j] = inf;\n\t\t\tmx[0][j] = mx[1][j];mx[1][j] = 0;\n\t\t\tdp[0][j] = dp[1][j];dp[1][j] = inf;\n\t\t}\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < m;i++){\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nstruct P {\n\tlong long ma, mi;\n};\nll dp[20001], n, m, k, a[20000];\nP c[200], d[20000];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 9000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=90000000000;\n\t\tfor (ll y = i; y < i + x; ) {\n\t\t\tif (y % 100 == 0&&y+100<i+x) {\n\t\t\t\tma = max(c[(y / 100)].ma, ma);\n\t\t\t\tmi = min(c[y / 100].mi, mi);\n\t\t\t\ty += 100;\n\t\t\t}\n\t\t\telse if (y % 50 == 0 && y + 50 < i + x) {\n\t\t\t\tma = max(d[(y / 50)].ma, ma);\n\t\t\t\tmi = min(d[y / 50].mi, mi);\n\t\t\t\ty += 50;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tma = max(ma, a[y]);\n\t\t\t\tmi = min(mi, a[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tfor (ll i = 0; i < floor(i / 100); i++) {\n\t\t\tll ma = -1, mi = 900000000000000,ma2=ma,mi2=mi;\n\t\t\tfor (ll j = i * 100; j < (i + 1) * 100; j++) {\n\t\t\t\tma = max(ma, a[j]);\n\t\t\t\tmi = min(mi, a[j]);\n\t\t\t\tif (j == i+50) {\n\t\t\t\t\td[i * 2].ma = ma;\n\t\t\t\t\td[i * 2].mi - mi;\n\t\t\t\t\tma2 = -1;\n\t\t\t\t\tmi2 = 900000000000000;\n\t\t\t\t}\n\t\t\t\tma2 = max(ma2, a[j]);\n\t\t\t\tmi2 = min(mi2, a[j]);\n\t\t\t}\n\t\t\tc[i].ma = ma;\n\t\t\tc[i].mi = mi;\n\t\t\td[i * 2 + 1].ma = ma2;\n\t\t\td[i * 2 + 1].mi = mi2;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<cassert>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int IINF = INT_MAX;\nconst char EMPTY = 'X';\n \nstruct Node{\n  int value;\n  /*\n    lazy : \n    A : ??????????????¶ ( ADD )\n    S : ?????????????´?????????????????????????????????¶ ( SET )\n\n    lazy_coef : \n    ????????????????????????????????????or???????????????????????????????¨????\n  */\n  char lazy;\n  int lazy_coef; \n  Node(int value=0,char lazy=EMPTY,int lazy_coef=0):value(value),lazy(lazy),lazy_coef(lazy_coef){}\n};\n \nclass SegmentTree{\npublic:\n  vector<Node> RMQ;\n  vector<int> minimum_dat,maximum_dat;\n  int limit,N; // N ???????´???°\n \n  void init(int tmp){\n    N = tmp;\n    int N_N = 1;\n    while(N_N < N)N_N *= 2;\n    limit = N_N;\n    RMQ.resize(3*limit);\n    minimum_dat.resize(3*limit);\n    maximum_dat.resize(3*limit);\n    rep(i,3*limit-1) {\n      RMQ[i] = Node();\n      minimum_dat[i] =  IINF;\n      maximum_dat[i] = -IINF;\n    }\n  }\n\n  /* \n     O(n)??§RMQ????????????\n     [L,R)\n     tuple<int,int,int>(?????????????°????????????§???)\n  */\n  tuple<int,int,int> _build(int cur,int L,int R,const vector<int> &buf){\n\n    if( !( 0 <= cur && cur < 2*limit-1 ) ) return tuple<int,int,int>(0,IINF,-IINF);\n    if( L == R-1 ){\n      if( L >= N ) return tuple<int,int,int>(0,IINF,-IINF);\n      //???????´??????????????????§????????´??? ( ??????????????????????????????????????§?????????????????´??? )\n      //buf[] ?????¨??????????????\\??? RMQ[cur].value = buf[L]; ??¨??????\n      // RMQ???L?????????????´????buf[L]??§??´??°\n      RMQ[cur].value = buf[L];\n      minimum_dat[cur] = buf[L];\n      maximum_dat[cur] = buf[L];\n      //???????´??????¨??????????????´???\n      //RMQ[cur] = 0; // RMQ ??????????´?????????§???????????? 1 ?????? RMQ[cur] = 1????????????...\n      //minimum_dat[cur] = 0;\n      //maximum_dat[cur] = 0;\n    } else {\n      tuple<int,int,int> vl = _build(cur*2+1,L,(L+R)/2,buf);\n      tuple<int,int,int> vr = _build(cur*2+2,(L+R)/2,R,buf);\n      RMQ[cur].value = get<0>(vl) + get<0>(vr);\n      minimum_dat[cur] = min(get<1>(vl),get<1>(vr));\n      maximum_dat[cur] = max(get<2>(vl),get<2>(vr));\n    }\n    return tuple<int,int,int>(RMQ[cur].value,minimum_dat[cur],maximum_dat[cur]);\n  }\n\n  //init?????????????????¨???????????¨!!! ??§????????¨limit?????£??????????????\\??£???????????????\n  void build(const vector<int> &buf) { _build(0,0,limit,buf); }\n\n  inline void value_evaluate(int index,int L,int R){\n    if( RMQ[index].lazy == 'A' ){\n      RMQ[index].value += ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] += RMQ[index].lazy_coef;\n      maximum_dat[index] += RMQ[index].lazy_coef;\n    } else if( RMQ[index].lazy == 'S' ){\n      RMQ[index].value = ( R - L ) * RMQ[index].lazy_coef;\n      minimum_dat[index] = RMQ[index].lazy_coef;\n      maximum_dat[index] = RMQ[index].lazy_coef;\n    }\n  }\n   \n  inline void lazy_evaluate(int index,int L,int R){\n    value_evaluate(index,L,R);\n    if( index < limit && RMQ[index].lazy != EMPTY ) {\n      if( RMQ[index].lazy == 'A' ) {\n        if( RMQ[index*2+1].lazy == EMPTY ) RMQ[index*2+1].lazy = 'A'; \n        if( RMQ[index*2+2].lazy == EMPTY ) RMQ[index*2+2].lazy = 'A';\n        RMQ[index*2+1].lazy_coef += RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef += RMQ[index].lazy_coef;\n      } else if( RMQ[index].lazy == 'S') {\n        RMQ[index*2+1].lazy = RMQ[index*2+2].lazy = 'S';\n        RMQ[index*2+1].lazy_coef = RMQ[index].lazy_coef;\n        RMQ[index*2+2].lazy_coef = RMQ[index].lazy_coef;\n      }\n    }\n    RMQ[index].lazy = EMPTY;\n    RMQ[index].lazy_coef = 0;\n  }\n \n  inline void value_update(int index){\n    RMQ[index].value = RMQ[index*2+1].value + RMQ[index*2+2].value;\n    minimum_dat[index] = min(minimum_dat[index*2+1],minimum_dat[index*2+2]);\n    maximum_dat[index] = max(maximum_dat[index*2+1],maximum_dat[index*2+2]);\n  }\n \n  /*\n  //[a,b)???????????????opr?????????\n  ??????????????¬??????[L,R)\n  [a,b)??????????´????????????????\n  opr ??? 'A'??????v????????? ( ADD )\n  opr ??? 'S'??????v????????? ( SET )\n  */\n  void _update(int a,int b,char opr,int v,int index,int L,int R){\n    /*\n      RMQ[index].lazy ???EMPTY??\\?????????????????????????????????????????§????????°\n      ???????????¶???????????????????????????\n    */\n    lazy_evaluate(index,L,R);\n \n    if( b <= L || R <= a )return;\n    if( a <= L && R <= b ){\n      /*\n        [L,R)???????????????????????\\??£????????§???????????§?????????????????? ( ???????????????????????´??°?????????????????´??°?????????, ????????£???????????¶?????????????????? )\n        [??????????????????]            [??????????????????]\n        [??????]  [??????]     => [??????,?????¶] [??????,?????¶]\n        ??????????????????????????????\n        ??????????????????????¨??????????????????¶????????????????????????\n      */\n      RMQ[index].lazy = opr; // ??????????????????????????¶????¨??????????????????????????????????\n      if( opr == 'A' )      RMQ[index].lazy_coef += v; \n      else if( opr == 'S' ) RMQ[index].lazy_coef = v; \n      lazy_evaluate(index,L,R);\n      return;\n    }\n \n    _update(a,b,opr,v,index*2+1,L,(L+R)/2);\n    _update(a,b,opr,v,index*2+2,(L+R)/2,R);\n    value_update(index);\n \n  }\n\n  // [a,b) ???????????? opr ?????????\n  void update(int a,int b,char opr,int v){ _update(a,b,opr,v,0,0,limit); } \n\n  tuple<int,int,int> _query(int a,int b,int index,int L,int R){\n    lazy_evaluate(index,L,R); //???????????????????????£??????????????\\??£????????????(?????¶????????????)????????§??????????????§??????????????£??????????????\\??????\n \n    if( b <= L || R <= a ) return make_tuple(0,IINF,-IINF);\n    if( a <= L && R <= b ) return make_tuple(RMQ[index].value,minimum_dat[index],maximum_dat[index]);\n\n\n    auto tmp1 = _query(a,b,index*2+1,L,(L+R)/2);\n    auto tmp2 = _query(a,b,index*2+2,(L+R)/2,R);\n    tuple<int,int,int> ret = make_tuple(get<0>(tmp1)+get<0>(tmp2),min(get<1>(tmp1),get<1>(tmp2)),max(get<2>(tmp1),get<2>(tmp2)));\n    value_update(index); //???????????§????????¨??????????????£???????????£??????????????§??????????????¨??£?????????????????????????????£?????????????????????\n    return ret;\n  }\n\n  // [a,b) ????????????????°????????????§????????????\n  tuple<int,int,int> query(int a,int b) { return _query(a,b,0,0,limit); }\n\n};\n\n\n\n#define MAX 20010\n\nll dp[MAX];\nint N,M;\nll K,A[MAX];\n\nvoid computer() {\n  SegmentTree rmq;\n  {\n    rmq.init(N);\n    vector<int> vec(N);\n    rep(i,N) vec[i] = A[i];\n    rmq.build(vec);\n  }\n  rep(i,N+1) dp[i] = LLONG_MAX;\n  rep(i,N) {\n    dp[i] = ((i-1>=0)?dp[i-1]:0) + K;\n    rep(j,i) {\n      if( i - j + 1 > M ) continue;\n      auto v = rmq.query(j,i+1);\n      ll maxi = get<2>(v);\n      ll mini = get<1>(v);\n      assert( maxi >= mini );\n      dp[i] = min(dp[i],((j-1>=0)?dp[j-1]:0)+K+(ll)(i-j+1) * ( maxi - mini ));\n    }\n  }\n  cout << dp[N-1] << endl;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  rep(i,N) cin >> A[i];\n  computer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF (10000000000000000LL)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nint main()\n{\n    int N,M;\n    long long K;\n    cin >> N >> M >> K;\n\n    vector<long long> A;\n    for(int i=0; i<N; ++i) {\n        long long temp;\n        cin >> temp;\n        A.push_back(temp);\n    }\n\n    long long dp[2][N];\n    long long mn=INF;\n    long long mx=-1;\n\n    for(int i=0; i<N; ++i) {\n        if(i<M) {\n            mn=MIN(mn,A[i]);\n            mx=MAX(mx,A[i]);\n            dp[0][i]=K+(i+1)*(mx-mn);\n        } else {\n            dp[0][i]=INF;\n        }\n    }\n\n    long long ans=INF;\n\n    for(int i=1; i<N; ++i) {\n        for(int j=0; j<N; ++j) {\n            long long temp=INF;\n            mn=INF; mx=-1;\n            for(int k=1; k<=M && j-k>=0; ++k) {\n                mn=MIN(mn,A[j-k+1]);\n                mx=MAX(mx,A[j-k+1]);\n                temp=MIN(temp,dp[(i-1)%2][j-k]+K+k*(mx-mn));\n            }\n            dp[i%2][j]=temp;\n        }\n        ans=MIN(ans,dp[i%2][N-1]);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T> void chmin(T &a,T b){if(a>b) a=b;}\ntemplate<typename T> void chmax(T &a,T b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,k;\n  cin>>n>>m>>k;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  const Int INF = 1e15;\n  vector<Int> dp(n+1,INF);\n  dp[0]=0;\n  for(Int i=0;i<n;i++){\n    Int x=a[i],y=a[i];\n    chmin(dp[i+1],dp[i]+k);\n    for(Int j=0;j<m;j++){\n      if(i+j+1>n) break;\n      chmax(x,a[i+j]);\n      chmin(y,a[i+j]);\n      chmin(dp[i+j+1],dp[i]+k+(j+1)*(x-y));\n    }\n  }\n  cout<<dp[n]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nint N, M, K;\nll dp[20004];\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> N >> M >> K;\n  int A[N];\n  FOR(i,0,N) cin >> A[i];\n  FOR(i,0,N+1) dp[i] = 1e18;\n  dp[0] = 0;\n  FOR(i,0,N) {\n    int mn = 1e9;\n    int mx = 0;\n    for(int j = i; j >= 0 && j >= i - M + 1; j--) {\n      mx = max(mx, A[j]);\n      mn = min(mn, A[j]);\n      dp[i+1] = min(dp[i+1], dp[j] + K + ll(i - j + 1) * (mx - mn));\n    }\n  }\n  cout << dp[N] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#define int long long\n#define INF 1000000000000000000\n#define REP(i,n) for(int i=1;i<=n;i++)\nint n,m,k;\nint a[20002];\nint cs[20002][1002];\nint sm[20002];\n\nsigned main(){\n  cin>>n>>m>>k;\n  REP(i,n)cin>>a[i];\n  REP(i,n){\n    int mx=0;\n    int mn=INF;\n    REP(j,m){\n      if(n<i+j-1)continue;\n      mx=max(mx,a[i+j-1]);\n      mn=min(mn,a[i+j-1]);\n      cs[i][j]=k+j*(mx-mn);\n    }\n  }\n  REP(i,n)sm[i]=INF;\n  REP(i,n)REP(j,m){\n    if(n<i-1+j)continue;\n    sm[i-1+j]=min(sm[i-1+j],sm[i-1]+cs[i][j]);\n  }\n  #ifdef DEBUG\n  REP(i,n){\n    REP(j,m)cout<<cs[i][j]<<\" \";\n    cout<<endl;\n  }\n  REP(i,n)cout<<sm[i]<<\" \";\n  cout<<endl;\n  #endif\n  cout<<sm[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 20001\nconst int inf = 1e18;\n\nint mn[2][1001], mx[2][1001];\nint a[MAX], dp[2][1001];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\tfill((int*)(mn+1), (int*)(mn+2), inf);\n\t\tfill((int*)(mx+1), (int*)(mx+2), 0);\n\t\tfill((int*)(dp+1), (int*)(dp+2), inf);\n\t\t/*for(int j = 0;j < 2;j++){\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tif(dp[j][k] == inf)printf(\"* \");\n\t\t\t\telse printf(\"%lld \", dp[j][k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}\n\t\tswap(mn[0], mn[1]);\n\t\tswap(mx[0], mx[1]);\n\t\tswap(dp[0], dp[1]);\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < n;i++){\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,k,a[20005],dp[20005];\nlong long solve(long long p){\n\tif(p>n)return 1LL<<62;\n\tif(p==n)return 0;\n\tif(dp[p]>=1)return dp[p];\n\tlong long p1=1LL<<62,p2=0,ret=1LL<<62;\n\tfor(int i=p+1;i<=p+m;i++){\n\t\tp1=min(p1,a[i-1]);p2=max(p2,a[i-1]);\n\t\tret=min(ret,solve(i)+(p2-p1)*(i-p)+k);\n\t}\n\tdp[p]=ret;\n\treturn ret;\n}\nint main(){\n\tcin>>n>>m>>k;for(int i=0;i<n;i++)cin>>a[i];\n\tcout<<solve(0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : JOI.cpp\n// Author      :2015 ho3\n// Version     :???11:08\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n\nusing namespace std;\nlong long N,M,K;\nlong long A[20001]={};\nlong long dp[20001][1001];\nlong long maxD[20001][1001];\nlong long minD[20001][1001];\nconst long long INF=100000000000000000;\n\nlong long calc(long long n1,long long m1){\n\tif(dp[n1][m1]>-1)return dp[n1][m1];\n\tlong long ans=INF;\n\tif(m1>0){\n\t\tans=calc(n1,0)+K+m1*(maxD[n1][m1]-minD[n1][m1]);\n\t}else{\n\t\tfor(long long i=1;i<M+1&&i<n1+1;++i){\n\t\t\tans=min(ans,calc(n1-i,i));\n\t\t}\n\t}\n\tdp[n1][m1]=ans;\n\treturn ans;\n}\nint main() {\n\tcin>>N>>M>>K;\n\tfor(long long i=1;i<N+1;i++)cin>>A[i];\n\n\tfill(dp[0],dp[20001],-1);\n\tfor(int i=0;i<N+1;i++){\n\t\tmaxD[i][0]=0;\n\t\tminD[i][0]=INF;\n\t\tfor(int j=1;j<M+1;j++){\n\t\t\tmaxD[i][j]=max(maxD[i][j-1],A[i+j]);\n\t\t\tminD[i][j]=min(minD[i][j-1],A[i+j]);\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tlong long R;\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=0;j<M+1;j++)\n\t\tR=calc(i,j);\n\t}\n\tR=calc(N,0);\n\tcout<<R<<endl;\n//\tcout<<calc(N,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nstatic const ll INF = 1LL << 60;\nstatic const int MAX_N = 20000;\n \nint N, M; ll K;\nll A[MAX_N + 1];\n \nll memo[MAX_N + 1];\n \nint main(){\n    scanf(\"%d %d %lld\", &N, &M, &K);\n    fill(memo + 1, memo + N + 1, INF);\n    for(int i = 1; i < N + 1; i++) scanf(\"%lld\", &A[i]);\n    for(int i = 0; i < N + 1; i++){\n        ll a, b;\n    \tfor(int j = 0; j < M; j++){\n    \t    if(i + j > N) continue;\n    \t    if(j == 0) a = A[i], b = A[i];\n            else a = max(a, A[i + j]), b = min(b, A[i + j]);\n            memo[i + j] = min(memo[i + j], \nmemo[i - 1] + K + (j + 1) * (a - b));\n        }\n    }\n    printf(\"%lld\\n\", memo[N]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF (10000000000000000LL)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nint main()\n{\n    int N,M;\n    long long K;\n    cin >> N >> M >> K;\n\n    vector<long long> A;\n    for(int i=0; i<N; ++i) {\n        long long temp;\n        cin >> temp;\n        A.push_back(temp);\n    }\n\n    long long dp[2][N];\n    long long mn=INF;\n    long long mx=-1;\n\n    for(int i=0; i<N; ++i) {\n        if(i<M) {\n            mn=MIN(mn,A[i]);\n            mx=MAX(mx,A[i]);\n            dp[0][i]=K+(i+1)*(mx-mn);\n        } else {\n            dp[0][i]=INF;\n        }\n    }\n\n\n    for(int i=1; i<N; ++i) {\n        for(int j=0; j<N; ++j) {\n            long long temp=INF;\n            mn=INF; mx=-1;\n            for(int k=1; k<=M && j-k>=0; ++k) {\n                mn=MIN(mn,A[j-k+1]);\n                mx=MAX(mx,A[j-k+1]);\n                temp=MIN(temp,dp[(i-1)%2][j-k]+K+k*(mx-mn));\n            }\n            dp[i%2][j]=MIN(temp,dp[(i-1)%2][j]);\n        }\n    }\n\n    cout << dp[(N-1)%2][N-1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF (10000000000000000LL)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nint main()\n{\n    int N,M;\n    long long K;\n    cin >> N >> M >> K;\n\n    vector<long long> A;\n    for(int i=0; i<N; ++i) {\n        long long temp;\n        cin >> temp;\n        A.push_back(temp);\n    }\n\n    long long dp[2][N];\n    long long mn=INF;\n    long long mx=-1;\n\n    for(int i=0; i<N; ++i) {\n        if(i<M) {\n            mn=MIN(mn,A[i]);\n            mx=MAX(mx,A[i]);\n            dp[0][i]=K+(i+1)*(mx-mn);\n        } else {\n            dp[0][i]=INF;\n        }\n    }\n\n\n    for(int i=1; i<N; ++i) {\n        for(int j=i; j<N; ++j) {\n            long long temp=INF;\n            mn=INF; mx=-1;\n            for(int k=1; k<=M && j-k>=i-1; ++k) {\n                mn=MIN(mn,A[j-k+1]);\n                mx=MAX(mx,A[j-k+1]);\n                temp=MIN(temp,dp[(i-1)%2][j-k]+K+k*(mx-mn));\n            }\n            dp[i%2][j]=MIN(temp,dp[(i-1)%2][j]);\n        }\n    }\n\n    cout << dp[(N-1)%2][N-1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M, K, a[20009]; long long dp[20009];\nint main() {\n\tcin >> N >> M >> K;\n\tfor(int i = 0; i < N; i++) cin >> a[i];\n\tdp[0] = 0;\n\tfor(int i = 1; i <= N; i++) {\n\t\tint l = 1999999999, r = -l;\n\t\tdp[i] = 1LL << 60;\n\t\tfor(int j = 1; j <= M && i - j >= 0; j++) {\n\t\t\tl = min(l, a[i - j]);\n\t\t\tr = max(r, a[i - j]);\n\t\t\tdp[i] = min(dp[i], dp[i - j] + K + 1LL * j * (r - l));\n\t\t}\n\t}\n\tcout << dp[N] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<60)\n#define ll long long\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 20005;\n\nll A[MAX_N];\nll dp[MAX_N];\nint n,m;\nll K;\n\nint main()\n{\n\tll a,b;\n\tscanf(\"%d%d%lld\",&n,&m,&K);\n\trep(i,n){\n\t\tscanf(\"%lld\",&A[i]);\n\t}\n\tdp[n] = 0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tdp[i] = INF;\n\t\ta = b = A[i];\n\t\tfor(int j=i;j<i+m&&j<n;j++){\n\t\t\ta = max(a,A[j]);\n\t\t\tb = min(b,A[j]);\n\t\t\tdp[i] = min(dp[i],dp[j+1]+(j-i+1)*(a-b)+K);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define int long long\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FORR(i, a, b) for (int i = (a); i >= (b); i--)\n\n#define pb push_back\n#define VDEL(v, n) v.erase(v.begin() + (n))\n#define ALL(v) v.begin(), v.end()\n\n#define INT_INF 200000000\n\n#define TINT(str) atoi(str.c_str())\n#define TSTR(num) to_string(num)\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<vector<int>> VII;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\n//the end of library zone\n\nint N, M, K;\n\nint A[20000];\nint DP[20010];\n\nsigned main() {\n    cin >> N >> M >> K;\n\n    REP(i, N) {\n        int a;\n        cin >> a;\n        A[i] = a;\n\n        DP[i] = LLONG_MAX;\n    }\n\n    DP[N] = LLONG_MAX;\n    DP[0] = 0;\n\n    //配るDP\n    REP(i, N) {\n        int minv = LLONG_MAX;\n        int maxv = 0;\n\n        FOR(h, 1, M + 1) {\n            if((i + h) <= N) {\n\n                //最大値、最小値を更新\n                minv = min(minv, A[i + h - 1]);\n                maxv = max(maxv, A[i + h - 1]);\n\n                //最小値を更新\n                DP[i + h] = min(\n                    DP[i + h], \n                    (DP[i] + K + h * (maxv - minv))\n                );\n            }\n        }\n    }\n\n    cout << DP[N] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<cassert>\n#include<cstring>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\nconst int IINF = INT_MAX;\n\nclass RMQ{\nprivate:\n  int limit,N;\n  vector<int> dat;\npublic:\n  void init(int n_){\n    N = n_;\n    limit = 1;\n    while(limit<n_)limit*=2;\n    dat.clear();\n    dat.resize(2*limit,-IINF);\n  }\n  \n  int _build(int cur,int L,int R,const vector<int> &buf){\n    if( !( 0 <= cur && cur < 2*limit ) ) return -IINF;\n    if( L == R-1 ) {\n      if( L >= N ) return -IINF;\n      dat[cur] = buf[L];\n    } else {\n      int vl = _build(cur*2+1,L,(L+R)/2,buf);\n      int vr = _build(cur*2+2,(L+R)/2,R,buf);\n      dat[cur] = max(vl,vr);\n    }\n    return dat[cur];\n  }\n\n  void build(const vector<int> &buf){ _build(0,0,limit,buf); };\n\n  void update(int k,int a){\n    k += limit-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n \n  int _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return -IINF;\n    else if(a<=l && r<=b)return dat[k];\n    int vl = _query(a,b,k*2+1,l,(l+r)/2);\n    int vr = _query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n\n  int query(int a,int b){ return _query(a,b,0,0,limit); }\n};\n\nclass RRMQ{\nprivate:\n  int limit,N;\n  vector<int> dat;\npublic:\n  void init(int n_){\n    N = n_;\n    limit = 1;\n    while(limit<n_)limit*=2;\n    dat.clear();\n    dat.resize(2*limit,IINF);\n  }\n  \n  int _build(int cur,int L,int R,const vector<int> &buf){\n    if( !( 0 <= cur && cur < 2*limit ) ) return IINF;\n    if( L == R-1 ) {\n      if( L >= N ) return IINF;\n      dat[cur] = buf[L];\n    } else {\n      int vl = _build(cur*2+1,L,(L+R)/2,buf);\n      int vr = _build(cur*2+2,(L+R)/2,R,buf);\n      dat[cur] = min(vl,vr);\n    }\n    return dat[cur];\n  }\n\n  void build(const vector<int> &buf){ _build(0,0,limit,buf); };\n\n  void update(int k,int a){\n    k += limit-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n \n  int _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return IINF;\n    else if(a<=l && r<=b)return dat[k];\n    int vl = _query(a,b,k*2+1,l,(l+r)/2);\n    int vr = _query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n\n  int query(int a,int b){ return _query(a,b,0,0,limit); }\n};\n\n#define MAX 20010\n\nll dp[MAX];\nint N,M;\nll K,A[MAX];\n\nvoid computer() {\n  RMQ maxt; RRMQ mint;\n  {\n    maxt.init(N);\n    mint.init(N);\n    vector<int> vec(N);\n    rep(i,N) vec[i] = A[i];\n    maxt.build(vec);\n    mint.build(vec);\n  }\n  rep(i,N+1) dp[i] = LLONG_MAX;\n  rep(i,N) {\n    dp[i] = ((i-1>=0)?dp[i-1]:0) + K;\n    for(int j=i-1;j>=0;--j) {\n      if( i - j + 1 > M ) break;\n      ll maxi = maxt.query(j,i+1);\n      ll mini = mint.query(j,i+1);\n      dp[i] = min(dp[i],((j-1>=0)?dp[j-1]:0)+K+(ll)(i-j+1) * ( maxi - mini ));\n    }\n  }\n  cout << dp[N-1] << endl;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  rep(i,N) cin >> A[i];\n  computer();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e18;\nll v[20001], dp[2][1010];\nll a[2][1010],b[2][1010];\nint main(){\n\tll n,m,k;\tcin>>n>>m>>k;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>v[i];\n\t}\n\tfill((ll*)dp, (ll*)(dp+2), INF);\n\tfill((ll*)b, (ll*)(b+2), INF);\n\tdp[0][0]=k;\ta[0][0]=b[0][0]=v[0];\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(dp[0][j]==INF)continue;\n\t\t\t//その箱に追加する場合\n\t\t\tif(j+1<m){\n\t\t\t\tdp[1][j+1]=dp[0][j];\n\t\t\t\ta[1][j+1]=max((ll)a[0][j],v[i]);\n\t\t\t\tb[1][j+1]=min((ll)b[0][j],v[i]);\n\t\t\t}\n\t\t\t//新しく箱を作る場合\n\t\t\tll num=k+dp[0][j];\n\t\t\tnum+=(a[0][j]-b[0][j])*(j+1);\n\t\t\tdp[1][0]=min(dp[1][0],num);\n\t\t\ta[1][0]=b[1][0]=v[i];\n\t\t}\n\t\tfor(int j=0;j<m;j++){\n\t\t\tdp[0][j]=dp[1][j];\tdp[1][j]=INF;\n\t\t\ta[0][j]=a[1][j];\ta[1][j]=0;\n\t\t\tb[0][j]=b[1][j];\tb[1][j]=INF;\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(int i=0;i<m;i++){\n\t\t//ll num=dp[0][i];\n\t\tll num=dp[0][i]+(a[0][i]-b[0][i])*(i+1);\n\t\tans=min(ans,num);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1e+18\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m,k,a[20000];\n\tstatic int dp[20001][1001];\n\tcin >> n >> m >> k;\n\tfor(int i = 0;i <= n;i++){\n\t\tfor(int j = 0;j <= 1000;j++) dp[i][j] = INF;\n\t}\n\tdp[0][0] = 0;\n\tdp[0][1000] = 0;\n\tfor(int i = 0;i < n;i++) cin >> a[i];\n\tfor(int i = 1;i <= n;i++){\n\t\tint mi = a[i - 1],ma = a[i - 1];\n\t\tfor(int j = 0;j < min(m,i);j++){\n\t\t\tdp[i][j] = dp[i - j - 1][1000] + k + (j + 1) * (ma - mi);\n\t\t\tdp[i][1000] = min(dp[i][1000],dp[i][j]);\n\t\t\tif(i - j - 2 >= 0) {\n\t\t\t\tmi = min(mi,a[i - j - 2]);\n\t\t\t\tma = max(ma,a[i - j - 2]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][1000] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nll dp[200002],a[200002];\nll INF=1000100010001000100;\nint main(){\n    int n,m;\n    ll k;\n    cin>>n>>m>>k;\n    rep(i,n) cin>>a[i+1];\n    rep(i,n+1) dp[i]=INF;\n    dp[0]=0;\n    rep(i,n){\n        ll mx=0,mn=INF;\n        for(int j=1;j+i<=min(n,m+i);++j){\n            mn=min(mn,a[j+i]);\n            mx=max(mx,a[i+j]);\n            dp[i+j]=min(dp[i+j],dp[i]+k+(mx-mn)*j);\n        }\n    }\n    cout<<dp[n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nlong long int n, m, k;\nlong long int a[20010];\nlong long int c[20010];\n\nlong long int mini(int l, int r){\n\tlong long int res = 1e18;\n\tfor(int i=0; i<r-l+1; ++i)\n\t\tres = min(res, a[l+i]);\n\treturn res;\n}\n\nlong long int maxi(int l, int r){\n\tlong long int res = 0;\n\tfor(int i=0; i<r-l+1; ++i)\n\t\tres = max(res, a[l+i]);\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%lld %lld %lld\", &n, &m, &k);\n\tfor(int i=1; i<=n; ++i) scanf(\"%lld\", &a[i]);\n\tc[1] = k;\n\tfor(int i=2; i<=n; ++i){\n\t\tlong long int t = 1e18;\n\t\tfor(int j=1; j<=m; ++j){\n\t\t\tif(i - j < 0) break;\n\t\t\tlong long int mi, ma;\n\t\t\tmi = mini(i-j+1, i);\n\t\t\tma = maxi(i-j+1, i);\n\t\t\tt = min(t, c[i-j] + j * (ma - mi) + k);\n\t\t}\n\t\tc[i] = t;\n\t}\n\tprintf(\"%lld\\n\", c[n]);\n/*\tfor(int i=1; i<=n; ++i) printf(\"%lld\\t\", c[i]);\n\tprintf(\"\\n\");\n*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nint main()\n{\n  int N, M, K, A[20000];\n  int64 dp[20001];\n  \n  scanf(\"%d %d %d\", &N, &M, &K);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &A[i]);\n  }\n\n  fill_n(dp, 20001, INF);\n  dp[0] = 0;\n  for(int i = 0; i < N; i++) {\n    int small = A[i], large = A[i];\n    for(int j = 0; j < min(M, N - i); j++) {\n      small = min(small, A[i + j]);\n      large = max(large, A[i + j]);\n      dp[i + j + 1] = min(dp[i + j + 1], dp[i] + K + 1LL * (j + 1) * (large - small));\n    }\n  }\n  cout << dp[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<int> A(N); input(A);\n\tvector<int> v(N + 1);\n\trep(i, N) {\n\t\tcin >> A[i];\n\t\tint minv = 1ll << 60, maxv = -1;\n\t\tint ans = 1ll << 60;\n\t\trep(j, M * (i - j >= 0)) {\n\t\t\tint a = A[i - j];\n\t\t\tminv = min(minv, a);\n\t\t\tmaxv = max(maxv, a);\n\t\t\tans = min(ans, K + (j + 1) * (maxv - minv) + v[i - j]);\n\t\t}\n\t\tv[i + 1] = ans;\n\t}\n\tcout << v[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 99999999999999\n\n\nll** memo;\nll** memo2;\n\nenum Type{\n\tmax_value,\n\tmin_value,\n};\n\nstruct RMQ{\n\tvoid set(ll arg_minimum,ll arg_maximum){\n\t\tminimum = arg_minimum;\n\t\tmaximum = arg_maximum;\n\t}\n\tll minimum,maximum;\n};\n\nint N = 1;\nRMQ* Tree;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int index, ll orange){\n\n\tindex += N-1;\n\n\tTree[index].minimum = min(Tree[index].minimum,orange);\n\tTree[index].maximum = max(Tree[index].maximum,orange);\n\n\tindex = (index-1)/2;\n\n\twhile(true){\n\n\t\tTree[index].minimum = min(Tree[2*index+1].minimum,Tree[2*index+2].minimum);\n\t\tTree[index].maximum = max(Tree[2*index+1].maximum,Tree[2*index+2].maximum);\n\n\t\tif(index == 0)break;\n\t\telse{\n\t\t\tindex = (index-1)/2;\n\t\t}\n\t}\n}\n\n\nll find(int search_left,int search_right,int node_id,int node_left,int node_right,Type type){\n\n\tif(search_right < node_left || search_left > node_right){\n\t\tif(type == max_value){\n\t\t\treturn -1;\n\t\t}else{ //type == min_value;\n\t\t\treturn NUM;\n\t\t}\n\t}\n\n\tif(search_left <= node_left && search_right >= node_right){\n\t\tif(type == max_value){\n\t\t\treturn Tree[node_id].maximum;\n\t\t}else{\n\t\t\treturn Tree[node_id].minimum;\n\t\t}\n\t}\n\n\tif(type == min_value){\n\t\tll left_min = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_min = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn min(left_min,right_min);\n\t}else{ //type == max_value\n\t\tll left_max = find(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2,type);\n\t\tll right_max = find(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right,type);\n\n\t\treturn max(left_max,right_max);\n\t}\n}\n\nll box_Cost;\nint first_N,contain_Max;\n\nll recursive(int left,int width){\n\n\tll ret = 0,next = NUM;\n\tif(memo[left][width] != -1){\n\t\treturn memo[left][width];\n\t}else{\n\n\t\tif(memo2[left][width] != -1){\n\t\t\tret = memo2[left][width];\n\t\t}else{\n\t\t\tll min_orange = find(left,min(N-1,left+width-1),0,0,N-1,min_value);\n\t\t\tll max_orange = find(left,min(N-1,left+width-1),0,0,N-1,max_value);\n\t\t\tmemo2[left][width] = box_Cost+(ll)width*(max_orange-min_orange);\n\t\t\tret = memo2[left][width];\n\t\t}\n\t}\n\n\tif(left + width <= first_N-1){\n\t\tfor(int i = 1; i <= contain_Max; i++){\n\t\t\tnext = min(next,recursive(left+width,i));\n\t\t}\n\t\treturn memo[left][width] = ret + next;\n\t}else{\n\t\treturn memo[left][width] = ret;\n\t}\n}\n\nvoid func(){\n\n\tll ans = NUM;\n\n\tfor(int i = 1; i <= contain_Max; i++){\n\t\tans = min(ans,recursive(0,i));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %lld\",&first_N,&contain_Max,&box_Cost);\n\n\tinit(first_N);\n\n\tmemo = new ll*[first_N];\n\tmemo2 = new ll*[first_N];\n\tfor(int i = 0; i < first_N; i++){\n\t\tmemo[i] = new ll[contain_Max+1];\n\t\tmemo2[i] = new ll[contain_Max+1];\n\t\tfor(int k = 0; k <= contain_Max; k++){\n\t\t\tmemo[i][k] = -1;\n\t\t\tmemo2[i][k] = -1;\n\t\t}\n\t}\n\n\tTree = (RMQ*)malloc(sizeof(RMQ)*(2*N));\n\n\tfor(int i = 0; i < 2*N-1; i++){\n\t\tTree[i].set(NUM,-1);\n\t}\n\n\tll tmp;\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld\",&tmp);\n\t\tupdate(i,tmp);\n\t}\n\n\tfunc();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for(int(i) = 0; (i) < (n); (i)++)\n#define FOR(i, m, n) for(int(i) = (m); (i) < (n); (i)++)\n#define All(v) (v).begin(), (v).end()\n#define pb push_back\n#define MP(a, b) make_pair((a), (b))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\nconst int MOD = 1e9 + 7;\n\nll dp[20200];\n\nll N, M, K;\n\nll rec(ll i, vector<ll> &A) {\n    if(dp[i] != LINF) {\n        return dp[i];\n    }\n    ll ret = LINF;\n    ll ma = -LINF;\n    ll mi = LINF;\n    for(ll j = i - 1; j >= max(0LL, i - M); j--) {\n        ma = max(ma, A[j]);\n        mi = min(mi, A[j]);\n        ret = min(ret, rec(j, A) + K + (i - j) * (ma - mi));\n    }\n    return dp[i] = ret;\n}\n\nint main() {\n    cin >> N >> M >> K;\n    vector<ll> A(N);\n    rep(i, N) cin >> A[i];\n    rep(i, 20200) dp[i] = LINF;\n    dp[0] = 0;\n    cout << rec(N, A) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nstruct P {\n\tlong long ma, mi;\n};\nll dp[20001], n, m, k, a[20000];\nP c[200];\nll solve(ll i/*?????¬??????*/) {\n\tif (i == n) return 0;\n\tlong long sum = 9000000000000;\n\tfor (ll x = 1; x < min(n - i+1, m+1); x++) {\n\t\tll ma = -1, mi=90000000000;\n\t\tfor (ll y = i; y < i + x; ) {\n\t\t\tif (y % 100 == 0&&y+100<i+x) {\n\t\t\t\tma = max(c[(y / 100)].ma, ma);\n\t\t\t\tmi = min(c[y / 100].mi, mi);\n\t\t\t\ty += 100;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tma = max(ma, a[y]);\n\t\t\t\tmi = min(mi, a[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\tif (dp[i + x] != -1) {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + dp[i + x]);\n\t\t}\n\t\telse {\n\t\t\tsum = min(sum, (k+x*(ma - mi)) + (dp[i + x] = solve(i + x)));\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> n >> m >> k) {\n\t\tfor (ll i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (ll i = 0; i <= n; i++) {\n\t\t\t\tdp[i] = -1;\n\t\t}\n\t\tfor (ll i = 0; i < floor(i / 100); i++) {\n\t\t\tll ma = -1, mi = 900000000000000;\n\t\t\tfor (ll j = i * 100; j < (i + 1) * 100; j++) {\n\t\t\t\tma = max(ma, a[j]);\n\t\t\t\tmi = min(mi, a[j]);\n\t\t\t}\n\t\t\tc[i].ma = ma;\n\t\t\tc[i].mi = mi;\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 3e18;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint N, M, K;\nint A[20005];\nint memo[20005];\n\nint rec(int now)\n{\n    if (~memo[now]) return memo[now];\n\n    int res = inf;\n    int mi = inf, ma = -inf;\n    \n    for (int i = 0; i < min(N - now, M); ++i) {\n        mi = min(mi, A[now + i]);\n        ma = max(ma, A[now + i]);\n\n        res = min(res, K + (ma - mi) * (i + 1) + rec(now + i + 1));\n    }\n\n    if (res == inf) res = 0;\n\n    return memo[now] = res;\n}\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    cin >> N >> M >> K;\n\n    rep(i, N) {\n        cin >> A[i];\n    }\n\n    memset(memo, -1, sizeof (memo));\n\n    cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nlong long a[9];\nstruct P { string p; };\nbool operator<(P a, P b) {\n\tif (a.p.length() > b.p.length()) return false;\n\telse if (a.p.length() < b.p.length()) return true;\n\telse return a.p < b.p;\n}\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tP b[10000];\n\t\tfor (int i = 0; i < n; i++) cin >> b[i].p;\n\t\tsort(b, b + n);\n\t\tint f = 0,e=min(4,n);\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tfor (int j = 0; j < e; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\ta[f] = stoll(b[i].p + b[j].p);\n\t\t\t\t\tf++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(a, a + f);\n\t\tcout << a[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define min(a,b) a<b?a:b\nusing namespace std;\nlong long int dp[20005];\nint size[20005];\nconst long long int MAX=100000000000007;\nint main(){\n\tlong long int n,m,x;\n\tint i,j,k;\n\tlong long int ma,mb;\n\tfor(i=1;i<20005;i++){dp[i]=MAX;}\n\tcin>>n>>m>>x;\n\tfor(i=0;i<n;i++){\n\t\tcin>>size[i];\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tma=MAX,mb=0;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tif(i-j<0)break;\n\t\t\tif(size[i-j]<ma)ma=size[i-j];\n\t\t\tif(mb<size[i-j])mb=size[i-j];\n\t\t\tdp[i]=min(dp[i],dp[i-j]+x+(mb-ma)*j);\n\t\t}\n\t}\n\tcout<<dp[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\t\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <cassert>\n#define INF 2000000000000000\n#define MOD 1000000007\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define mk make_pair\n#define en endl\n#define RE return 0\n#define int ll\n#define P pair<int,int>\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\nint lcm(int a,int b){if(a==0){return b;} return a/gcd(a,b)*b;}\n\nint n,m,k;\nint a[20005];\n\nint dp[20005]; // i番目までのmin\n\nsigned main(){\n\tcin>>n>>m>>k;\n\tfor(int i=1; i<=n; i++) cin>>a[i];\n\t\n\tdp[0]=0;\n\tfor(int i=1; i<=20005; i++) dp[i]=INF;\n\tfor(int i=1; i<=n; i++){\n\t\tint ma=-1,mi=INF;\n\t\tfor(int j=i,c=0; j>=1&&c<m; c++,j--){\n\t\t\tma=max(ma, a[j]); mi=min(mi, a[j]);\n\t\t\tint aa=ma-mi;\n\t\t\tdp[i]=min(dp[i], k+dp[j-1]+(i-j+1)*aa);\n\t\t}\n\t}\n\tcout<<dp[n]<<en;\t\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define big (1<<25)\n#define maxAs(a,b) if((a)<(b)){(a)=(b);}\n#define minAs(a,b) if((a)>(b)){(a)=(b);}\n//cleared!\nusing namespace std;\n//joi2016-ho-1\n//Just odd industry???????????????????????????\nint main(void){\n    long long int N=0,M=0,K=0,i=0,j=0,x=0,gen=0,thmax=0,thmin=0;\n    vector<int> A;//?????¬???????????§??????\n    vector<long long int> cost;\n    scanf(\"%lld %lld %lld\",&N,&M,&K);\n    for(i=0;i<N;i++){\n        scanf(\"%lld\",&x);\n        A.push_back(x);\n    }\n    cost.push_back(0);\n    for(i=1;i<=N;i++){\n        gen=big;thmax=0;thmin=big;\n        gen*=big;thmin*=big;\n        for(j=1;j<=M;j++){\n            if(i-j<0){break;}\n            maxAs(thmax,A[i-j]);\n            minAs(thmin,A[i-j]);\n            minAs(gen,cost[i-j]+K+j*(thmax-thmin));\n        }\n        cost.push_back(gen);\n    }\n    printf(\"%lld\\n\",cost[N]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<string>\n#include<iostream>\n#include<tuple>\n#include<utility>\n#include<set>\nusing namespace std;\ntypedef long long int llint;\nconst llint big=((llint)1<<(llint)60);\n#define mt make_tuple\n#define mp make_pair\n#define fi first\n#define se second\n#define pub push_back\n#define res resize\n//JOI 2016 oranges\n//K+s*(maxore-minore)\n//dp????????????\n//dp[i]=i???????????§??°??????\n//TLE?????????\n//0 1 2\nint main(void){\n\tllint N,M,K,i,j,maxore,minore;\n\tllint ore[20001]={0};\n\tllint dp[20001]={0};\n\tcin>>N>>M>>K;\n\tfor(i=0;i<N;i++){\n\t\tdp[i+1]=big;\n\t\tcin>>ore[i];\n\t\tmaxore=0;\n\t\tminore=big;\n\t\tfor(j=i;j>max((llint)-1,i-M);j--){\n\t\t\tmaxore=max(maxore,ore[j]);\n\t\t\tminore=min(minore,ore[j]);\n\t\t\tdp[i+1]=min(dp[i+1],K+(i-j+1)*(maxore-minore)+dp[j]);\n\t\t}\n\t\t//cout<<\"de\"<<dp[i+1]<<endl;\n\t}\n\tcout<<dp[N]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 200001\nconst int inf = 1e18;\n\nint mn[2][1010], mx[2][1010];\nint a[MAX], dp[2][1010];\nsigned main(){\n\tint n, m, k;\n\tfill((int*)dp, (int*)(dp+2), inf);\n\tfill((int*)mn, (int*)(mn+2), inf);\n\tscanf(\"%lld%lld%lld\", &n, &m, &k);\n\tfor(int i = 0;i < n;i++)scanf(\"%lld\", &a[i]);\n\t\n\tdp[0][0] = k;\n\tmn[0][0] = mx[0][0] = a[0];\n\tfor(int i = 1;i < n;i++){\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tif(dp[0][j-1] == inf)continue;\n\t\t\tmn[1][j] = min(mn[0][j-1], a[i]);\n\t\t\tmx[1][j] = max(mx[0][j-1], a[i]);\n\t\t\tdp[1][j] = dp[0][j-1];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tif(dp[0][j] == inf)continue;\n\t\t\tint sum = dp[0][j]+(j+1)*(mx[0][j]-mn[0][j])+k;\n\t\t\tdp[1][0] = min(dp[1][0], sum);\n\t\t\tmx[1][0] = mn[1][0] = a[i];\n\t\t}\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tmn[0][j] = mn[1][j];mn[1][j] = inf;\n\t\t\tmx[0][j] = mx[1][j];mx[1][j] = 0;\n\t\t\tdp[0][j] = dp[1][j];dp[1][j] = inf;\n\t\t}\n\t}\n\t\n\tint ans = dp[0][0];\n\tfor(int i = 1;i < m;i++){\n\t\tint sum = dp[0][i]+(i+1)*(mx[0][i]-mn[0][i]);\n\t\tans = min(ans, sum);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint N, M, K;\nint A[20000];\nlong long dp[20001];\n\nint main() {\n  scanf(\"%d %d %d\", &N, &M, &K);\n  for (int i=0; i<N; i++) {\n    scanf(\"%d\", &A[i]);\n  }\n  dp[0] = 0LL;\n  for (int i=0; i<N; i++) {\n    int a = A[i], b = A[i];\n    long long m = (1LL<<60);\n    for (int j=0; j<M; j++) {\n      if (i-j < 0) break;\n      a = max(a, A[i-j]);\n      b = min(b, A[i-j]);\n      m = min(m, dp[i-j] + K + (long long)(j+1)*(a - b));\n    }\n    dp[i+1] = m;\n  }\n  printf(\"%lld\\n\", dp[N]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nsigned main() {\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<int> A(N);\n\tvector<int> v(N + 1);\n\trep(i, N) {\n\t\tcin >> A[i];\n\t\tint minv = 1ll << 60, maxv = -1;\n\t\tint ans = 1ll << 60;\n\t\trep(j, M * (i - j >= 0)) {\n\t\t\tint a = A[i - j];\n\t\t\tminv = min(minv, a);\n\t\t\tmaxv = max(maxv, a);\n\t\t\tans = min(ans, K + (j + 1) * (maxv - minv) + v[i - j]);\n\t\t}\n\t\tv[i + 1] = ans;\n\t}\n\tcout << v[N] << endl;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define S_MAX 20000\n#define N_MAX 20000\n#define M_MAX 1000\n#define INF 2000000000\n#define MOD 1000000007\n#define SMAP(a, b) ((a)!=(b))&&((a)^=((b)^=((a)^= (b))))\n\ntypedef unsigned long long ull;\ntypedef   signed long long dll;\n\nint n, m;\nint h, w;\nint i, j;\null k;\n\null a[N_MAX];\null b[N_MAX + 1];\n\ntypedef struct {\n\tint in;\n\tint out;\n} twoway;\n\nvoid solve(){\n\n\tb[0] = 0;\n\n\tfor (i = 1; i <= n; i++) {\n\t\tull rgmin = INF, rgmax = 0;\n\t\tull result = ~0;\n\n\t\tfor (j = 0; j < m && j < i; j++) {\n\t\t\tull cand;\n\t\t\tif (a[i - j - 1] < rgmin) rgmin = a[i - j - 1];\n\t\t\tif (a[i - j - 1] > rgmax) rgmax = a[i - j - 1];\n\t\t\tcand = b[i - j - 1] + (j + 1) * (rgmax - rgmin);\n\t\t\t// printf(\"range [%d-%d] %llu\\n\", i - j - 1, i - 1, cand);\n\t\t\tif (cand < result) result = cand;\n\t\t}\n\t\tb[i] = k + result;\n\n\t\t// printf(\"deb: %d %llu\\n\", i, b[i]);\n\t}\n\n\tprintf(\"%llu\\n\", b[n]);\n\n\treturn;\n}\n\nint main (void) {\n\tscanf(\"%d%d%llu\", &n, &m, &k);\n\tfor (i = 0; i < n; i++) scanf(\"%llu\", &a[i]);\n\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0625: Oranges\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define INF 0x3030303030303030LL\nint N, M, K;\nint a[20001];\nlong long memo[20001];\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nlong long rec(int k)\n{\n\tint i, lim;\n\tlong long min, max, t, ans;\n\n\tif (k >= N) return 0;\n\tif (memo[k] < INF) return memo[k];\n\tans = INF;\n\tmin = max = a[k];\n\tlim = k + M; if (lim > N) lim = N;\n\tfor (i = k; i < lim; i++) {\n\t\tif      (max < a[i]) max = a[i];\n\t\telse if (min > a[i]) min = a[i];\n\t\tt = rec(i+1) + K + (i-k+1) * (max-min);\n\t\tif (t < ans) ans = t;\n\t}\n\treturn memo[k] = ans;\n}\n\nint main()\n{\n\tint i;\n\n\tfgets(p=buf, 30, stdin);\n\tN = in(), p++, M = in(), p++, K = in();\n\tfor (i = 0; i < N; i++) {\n\t\tfgets(p=buf, 15, stdin);\n\t\ta[i] = in();\n\t}\n\tmemset(memo, 0x30, sizeof(memo));\n\tprintf(\"%lld\\n\", rec(0));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <inttypes.h>\n\nint N, M, K;\nint A[20000];\n\nuint64_t memo[20000];\n\nuint64_t search(int idx) {\n\tuint64_t ret, candidate;\n\tint min, max;\n\tint i;\n\tif (idx >= N) return 0;\n\tif (memo[idx]) return ~memo[idx];\n\tret = K + search(idx + 1);\n\tmin = max = A[idx];\n\tfor (i = 1; i + 1 <= M && idx + i < N; i++) {\n\t\tif (A[idx + i] < min) min = A[idx + i];\n\t\tif (A[idx + i] > max) max = A[idx + i];\n\t\tcandidate = K + (uint64_t)(i + 1) * (max - min) + search(idx + i + 1);\n\t\tif (candidate < ret) ret = candidate;\n\t}\n\treturn ~(memo[idx] = ~ret);\n}\n\nint main(void) {\n\tint i;\n\tif (scanf(\"%d%d%d\", &N, &M, &K) != 3) return 1;\n\tfor (i = 0; i < N; i++) {\n\t\tif (scanf(\"%d\", &A[i]) != 1) return 1;\n\t}\n\tprintf(\"%\"PRIu64\"\\n\", search(0));\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int k = sc.nextInt();\n        int[] oranges = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            oranges[i] = sc.nextInt();\n        }\n        long[] dp = new long[n + 1];\n        Arrays.fill(dp, Long.MAX_VALUE);\n        dp[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            long min = Long.MAX_VALUE;\n            long max = 0;\n            for (int j = 1; j <= m && i - j>= 0; j++) {\n                min = Math.min(min, oranges[i - j + 1]);\n                max = Math.max(max, oranges[i - j + 1]);\n                dp[i] = Math.min(dp[i], (max - min) * j + k + dp[i - j]);\n            }\n        }\n        System.out.println(dp[n]);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var m = int.Parse(line[1]);\n        var k = int.Parse(line[2]);\n        var a = new int[n + 1];\n        var dp = new long[n + 1];\n        for (int i = 1; i <= n; i++)\n        {\n            a[i] = int.Parse(Console.ReadLine().Trim());\n            dp[i] = long.MaxValue;\n        }\n        goDP(a, n, m, k, dp);\n        Console.WriteLine(dp[n]);\n    }\n    static void goDP(int[] a, int n, int m, int k, long[] dp)\n    {\n        dp[1] = k;\n        for (int i = 2; i <= n; i++)\n        {\n            var t = 0L;\n            var maxa = 0L; var mina = long.MaxValue;\n            for (int j = i; j >= Max(1, i - m + 1); j--)\n            {\n                maxa = Max(maxa, a[j]);\n                mina = Min(mina, a[j]);\n                t += a[j];\n                var w = dp[j - 1] + (maxa - mina) * (i - j + 1) + k;\n                dp[i] = Min(dp[i], w);\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace _0625\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tlong[] x = Console.ReadLine().Split().Select(long.Parse).ToArray();\n\t\t\tlong[] dp = new long[x[0] + 1];\n\t\t\tfor (int i = 1; i <= x[0]; i++) dp[i] = long.MaxValue;\n\t\t\tlong[] oranges = new long[x[0]];\n\t\t\tfor (int i = 0; i < x[0]; i++) oranges[i] = long.Parse(Console.ReadLine());\n\t\t\tfor (int i = 1; i <= x[0]; i++)\n\t\t\t{\n\t\t\t\tlong min = long.MaxValue; long max = 0;\n\t\t\t\tfor (int j = 1; j <= Math.Min(i, x[1]); j++)\n\t\t\t\t{\n\t\t\t\t\tmin = Math.Min(min, oranges[i - j]); max = Math.Max(max, oranges[i - j]);\n\t\t\t\t\tdp[i] = Math.Min(dp[i], dp[i - j] + x[2] + j * (max - min));\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(dp[x[0]]);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "n, m, k = gets.split.map(&:to_i)\na = ['dummy'] + (1..n).map { gets.to_i }\nt = [0]\n(1..n).each do |i|\n    min = Float::INFINITY\n    max = -min\n    opt = Float::INFINITY\n    i.downto(1) do |j|\n        break if i - j + 1 > m\n        min = a[j] if a[j] < min\n        max = a[j] if a[j] > max\n        x = t[j-1] + k + (max - min) * (i - j + 1)\n        opt = x if x < opt\n    end\n    t[i] = opt\nend\np t[-1]\n"
  },
  {
    "language": "Ruby",
    "code": "n, m, k = gets.chomp.split.map(&:to_i)\norange = []\nn.times{orange << gets.to_i}\ncost = [0]\nfor i in 0..(n-1)\n    min = max = orange[i]\n    s, min_cost = 1, cost[i] + k\n    (i-1).downto(0){|j|\n        s += 1\n        break if s > m\n        min = orange[j] if min > orange[j]\n        max = orange[j] if max < orange[j]\n        c = cost[j] + s * (max - min) + k\n        min_cost = c if min_cost > c\n    }\n    cost[i+1] = min_cost\nend\nputs cost[n]\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  n, m, k = map(int, raw_input().split())\n  alst = [0] + [int(raw_input()) for _ in range(n)]\n  INF = 10 ** 15\n  dp = [INF] * (n + 1)\n  dp[0] = 0\n  for i in range(1, n + 1):\n    a = b = alst[i]\n    diff = 0\n    x = k\n    dpi = INF\n    limit = i - m - 1 if i > m else -1\n    for j in range(i - 1, limit, -1):\n      x += diff\n      if dpi > dp[j] + x:\n        dpi = dp[j] + x\n      temp = alst[j]\n      if temp > b:\n        diff = temp - a\n        x = diff * (i - j) + k\n        b = temp\n        continue\n      if a > temp:\n        diff = b - temp\n        x = diff * (i - j) + k\n        a = temp\n\n    dp[i] = dpi\n  print dp[n]\n\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::io::{stdin, Read, StdinLock};\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::str::FromStr;\n#[allow(unused_imports)]\nuse std::collections::{HashSet, HashMap, BinaryHeap, VecDeque};\n#[allow(unused_imports)]\nuse std::vec::Vec;\n\n#[allow(dead_code)]\nconst INF: i32 = 1000_000_000;\n#[allow(dead_code)]\nconst INFLL: i64 = 1000_000_000_000_000_000;\n#[allow(dead_code)]\nconst EPS: f64 = 1.0e-10;\n#[allow(dead_code)]\nconst MOD: i32 = 1000_000_007;\n#[allow(dead_code)]\nconst MODLL: i64 = 1000_000_007;\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\n#[allow(dead_code)]\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner {cin: cin}\n    }\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)\n                    .skip_while(|c| c.is_whitespace())\n                    .take_while(|c| !c.is_whitespace())\n                    .collect::<String>();\n        token.parse::<T>().ok()\n    }\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    let (n, m, k): (usize, usize, i64) = (sc.read(), sc.read(), sc.read());\n    let mut a: Vec<_> = vec![0; n];\n    for i in 0..n {\n        a[i] = sc.read();\n    }\n    let a = a;\n\n    let mut dp: Vec<i64> = vec![INFLL; n + 1];\n    dp[0] = 0;\n    for i in 0..n {\n        let (mut mi, mut ma) = (INFLL, -INFLL);\n        for j in 0..m {\n            if i < j {\n                break;\n            }\n            mi = min(mi, a[i - j]);\n            ma = max(ma, a[i - j]);\n            dp[i + 1] = min(dp[i + 1], dp[i - j] + (ma - mi) * (j as i64 + 1) + k);\n        }\n    }\n    println!(\"{}\", dp[n]);\n}\n"
  }
]