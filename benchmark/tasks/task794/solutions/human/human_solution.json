[
  {
    "language": "Fortran",
    "code": "program odd_subrectangles\n  implicit none\n  integer(8), parameter :: md = 998244353_8\n  integer :: n, m, a(300,300) = 0, r, i, j\n  read(*,*) n, m\n  do i = 1, n\n    read(*,*) a(i,1:m)\n  end do\n  r = rank(a(1:n,1:m))\n  write(*,'(i0)') modulo(pow(2_8,n+m-1)-pow(2_8,n+m-r-1),md)\ncontains\n  function pow(x,i) result(n)\n    integer(8), intent(in) :: x\n    integer, intent(in) :: i\n    integer(8) :: n, p\n    integer :: m\n    n = 1_8\n    p = x\n    m = i\n    do while (m > 0)\n      if (btest(m,0)) n = mod(p*n,md)\n      p = mod(p*p,md)\n      m = rshift(m,1)\n    end do\n  end\n  integer function rank(a)\n    integer, intent(in) :: a(:,:)\n    integer :: x(size(a,1),size(a,2))\n    integer :: n, i\n    x = a\n    call normal_form(x)\n    rank = 0\n    n = size(a,1)\n    do i = n, 1, -1\n      if (sum(x(i,:)) == 0) cycle\n      rank = i\n      exit\n    end do\n  end\n  subroutine normal_form(a)\n    integer, intent(inout) :: a(:,:)\n    integer :: n, m, i, j, k\n    n = size(a,1)\n    m = size(a,2)\n    i = 1\n    do j = 1, m\n      if (sum(a(i:n,j)) == 0) cycle\n      if (a(i,j) == 0) then\n        do k = i+1, n\n          if (a(k,j) == 1) then\n            a(i,j:m) = mod(a(i,j:m)+a(k,j:m),2)\n            exit\n          end if\n        end do\n      end if\n      do k = 1, n\n        if (k == i) cycle\n        if (a(k,j) == 0) cycle\n        a(k,j:m) = mod(2+a(k,j:m)-a(i,j:m),2)\n      end do\n      i = i+1\n      if (i > n) exit\n    end do\n  end\nend program odd_subrectangles"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    bool a[n][m];\n    int r = 0;\n    for (int i = 0;i < n;++i) for (int j = 0;j < m;++j) cin >> a[i][j];\n    for (int i = 0;i < n;++i) {\n        int p = i,q = i;\n        for (int j = i;j < n;++j) {\n            if (a[p][q]) break;\n            for (int k = i;k < m;++k) if (a[j][k]) {\n                p = j;q = k;\n                break;\n            }\n        }\n        if (!a[p][q]) break;\n        r = i+1;\n        for (int j = i;j < n;++j) swap(a[j][i],a[j][q]);\n        for (int j = i;j < m;++j) swap(a[i][j],a[p][j]);\n        for (int j = 0;j < n;++j) if (i != j && a[j][i]) for (int k = i;k < m;++k) a[j][k] ^= a[i][k];\n        for (int j = 0;j < m;++j) if (i != j && a[i][j]) for (int k = i;k < n;++k) a[k][j] ^= a[k][i];\n    }\n    int x = 1,y = 1;\n    for (int i = 0;i < n+m-1;++i) {\n        x <<= 1;\n        x %= mod;\n    }\n    for (int i = 0;i < n+m-r-1;++i) {\n        y <<= 1;\n        y %= mod;\n    }\n    cout << (x-y+mod)%mod << endl;\n    //for (int i = 0;i < n;++i) p_ary(a[i],0,m,j);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG  // gcc\n    #define _LIBCPP_DEBUG 0 // clang\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define _GLIBCXX_DEBUG\n    // #define _LIBCPP_DEBUG 0\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check() { char bufc; if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"\\n----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\npublic:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(), last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n/* dump definition start */\n#ifdef LOCAL\n    #define dump(...) debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\", dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\n/* dump definition end */\n\n/* function utility start */\ntemplate <class T, class... types> T read(types... args) noexcept { T obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = pair<i32, i32>; using pll = pair<i64, i64>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using rheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\n/* using alias end */\n\n/* library start */\n\n#ifndef Modint_hpp\n#define Modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    static constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    constexpr modint(bool x = false) noexcept : val{x} {}\n    constexpr modint(int x) noexcept : val(x & 1) {}\n    constexpr modint(long long x) noexcept : val(x & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val &= other.val, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { assert(other.val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator-(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator*(const modint &other) const noexcept { return val && other.val; }\n    constexpr modint operator/(const modint &other) const noexcept { assert(other.val); return *this; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { assert(y.val); return x & 1 ? y : modint<2>{0}; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // Modint_hpp\n\n#ifndef Matrix_hpp\n#define Matrix_hpp\n#include <iostream>\n#include <iterator>\n#include <valarray>\n\n// Field must be a field.\ntemplate <class Field>\nclass matrix\n{\n    size_t h, w;\n    using row_type = std::valarray<Field>;\n    using data_type = std::valarray<std::valarray<Field>>;\n    data_type data;\n    friend std::istream &operator>>(std::istream &is, matrix &x)\n    {\n        for(size_t i = 0; i != x.h; ++i)\n        {\n            for(size_t j = 0; j != x.w; ++j) is >> x[i][j];\n        }\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const matrix &x)\n    {\n        for(size_t i = 0; i != x.h; ++i)\n        {\n            if(i) os << \"\\n\";\n            for(size_t j = 0; j != x.w; ++j) os << (j ? \" \" : \"\") << x.data[i][j];\n        }\n        return os;\n    }\n    friend matrix transpose(const matrix &x)\n    {\n        matrix res(x.w, x.h);\n        for(size_t i = 0; i != x.w; ++i)\n            for(size_t j = 0; j != x.h; ++j)\n                res[i][j] = x.data[j][i];\n        return res;\n    }\n    friend matrix pow(matrix x, long long n)\n    {\n        assert(x.is_square());\n        matrix res = identity(x.height());\n        while(n)\n        {\n            if(n & 1) res *= x;\n            x *= x, n >>= 1;\n        }\n        return res;\n    }\n    friend matrix inverse(const matrix &x)\n    {\n        assert(x.is_square());\n        size_t n = x.height();\n        matrix ext_x(x), e(identity(n)), res(n);\n        for(size_t i = 0; i < n; ++i) ext_x[i].insert(end(ext_x[i]), begin(e[i]), end(e[i]));\n        ext_x = ext_x.row_canonical_form();\n        for(size_t i = 0; i < n; ++i)\n        {\n            if(std::vector<Field>(begin(ext_x[i]), begin(ext_x[i]) + n) != e[i]) return matrix();\n            res[i] = std::vector<Field>(begin(ext_x[i]) + n, end(ext_x[i]));\n        }\n        return res;\n    }\npublic:\n    matrix(size_t _n = 0) : h(_n), w(_n) { resize(_n, _n);}\n    matrix(size_t _h, size_t _w) : h(_h), w(_w) { resize(_h, _w); }\n    matrix(const data_type &_data) : h(_data.size()), w(_data.size() ? _data[0].size() : 0), data(_data) {}\n    operator data_type() const { return data; }\n    size_t height() const { return h; }\n    size_t width() const { return w; }\n    bool is_square() const { return h == w; }\n    void resize(size_t h, size_t w, const Field val = Field(0)) { data.resize(h, std::valarray<Field>(val, w)); }\n    row_type &operator[](const size_t i) { assert(i < data.size()); return data[i]; }\n    static matrix identity(const size_t n)\n    {\n        data_type data(n, row_type(n));\n        for(size_t i = 0; i != n; ++i) data[i][i] = 1;\n        return data;\n    }\n    matrix operator-() const { return {-data}; }\n    matrix &operator+=(const matrix &other) { data += other.data; return *this; }\n    matrix &operator-=(const matrix &other) { data -= other.data; return *this; }\n    matrix &operator*=(matrix other)\n    {\n        matrix res(h, other.w);\n        other = transpose(other);\n        assert(res.w == other.h);\n        for(size_t i = 0; i < res.h; ++i)\n            for(size_t j = 0; j < other.h; ++j)\n                res[i][j] = (data[i] * other.data[j]).sum();\n        return *this = res;\n    }\n    matrix operator+(const matrix &x) const { return matrix(*this) += x; }\n    matrix operator-(const matrix &x) const { return matrix(*this) -= x; }\n    matrix operator*(const matrix &x) const { return matrix(*this) *= x; }\n    std::vector<size_t> row_canonicalize()\n    {\n        std::vector<size_t> pivots;\n        const size_t h = height(), w = width();\n        for(size_t j = 0, rank = 0; j != w; ++j)\n        {\n            bool ispiv = false;\n            for(size_t i = rank; i != h; ++i)\n            {\n                if(data[i][j] != Field{})\n                {\n                    if(ispiv)\n                    {\n                        const Field r = -data[i][j];\n                        for(size_t k = j; k != w; ++k) data[i][k] += data[rank][k] * r;\n                    }\n                    else\n                    {\n                        swap(data[rank], data[i]);\n                        Field r = data[rank][j];\n                        for(size_t k = j; k != w; ++k) data[rank][k] /= r;\n                        for(size_t k = 0; k != rank; ++k)\n                        {\n                            r = -data[k][j];\n                            for(size_t l = j; l != w; ++l) data[k][l] += data[rank][l] * r;\n                        }\n                        ispiv = true;\n                    }\n                }\n            }\n            if(ispiv)\n            {\n                ++rank;\n                pivots.emplace_back(j);\n            }\n        }\n        return pivots;\n    }\n    Field determinant() const\n    {\n        matrix<Field> x(*this);\n        assert(is_square());\n        size_t n = height();\n        Field res(1);\n        for(size_t j = 0; j < n; ++j)\n        {\n            bool ispiv = false;\n            for(size_t i = j; i < n; ++i)\n            {\n                if(x[i][j] != Field{})\n                {\n                    if(ispiv)\n                    {\n                        const Field r = -x[i][j];\n                        for(size_t k = j; k < n; ++k) x[i][k] += x[j][k] * r;\n                    }\n                    else\n                    {\n                        swap(x[i], x[j]);\n                        if(i != j) res = -res;\n                        const Field r = x[j][j];\n                        res *= r;\n                        for(size_t k = j; k < n; ++k) x[j][k] /= r;\n                        ispiv = true;\n                    }\n                }\n            }\n            if(!ispiv) return Field(0);\n        }\n        return res;\n    }\n};\n#endif\n\n/* library end */\n\n/* The main code follows. */\n\nusing mint=modint<998244353>;\n\nstruct solver\n{\n    solver()\n    {\n        input(int,h);\n        input(int,w);\n        input(matrix<modint<2>>,a,h,w);\n        int rank=a.row_canonicalize().size();\n        int kdim=w-rank;\n        cout << mint::pow(2,h)*(mint::pow(2,w-1)-mint::pow(2,kdim-1)) << \"\\n\";\n    }\n\n    void test()\n    {\n        matrix<int> a({{1,0},{0,-1}});\n        cout << a << \"\\n\";\n        a*=a;\n        cout << a << \"\\n\";\n        return;\n    }\n}; // struct solver\n\nint main(int argc, char *argv[])\n{\n    u32 t; // loop count\n#ifdef LOCAL\n    t = 1;\n#else\n    t = 1; // single test case\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--)\n    {\n        solver();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#define inf 20021225\n#define ll long long\n#define mdn 998244353\nusing namespace std;\n\nbitset<310> r[310]; int n,m;\nint gauss()\n{\n\tint w = 0;\n\tfor(int i=1,j;i<=n;i++)\n\t{\n\t\tif(!r[i][i])\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t\tif(r[j][i])\tbreak;\n\t\t\tif(!j)\tcontinue;\n\t\t\tswap(r[i],r[j]);\n\t\t}\n\t\tfor(j=i+1;j<=m;j++)\n\t\t\tif(r[j][i])\tr[j]^=r[i];\n\t\tif(r[i].count())\tw++;\n\t}\n\treturn w;\n}\nint ksm(int bs,int mi)\n{\n\tint ans = 1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=(ll)ans*bs%mdn;\n\t\tbs=(ll)bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tr[i][j] = x;\n\t\t}\n\tint ans = ksm(2,n+m-1)-ksm(2,n+m-1-gauss());\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint a[323][323], c[323], r[323];\nll dpr[323][2], dpc[323][2];\nconst int MOD = 998244353;\nint main()\n{\n    int m, n;\n    cin >> m >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= m; j++)\n        {\n            cin >> a[i][j];\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            r[i] += a[i][j], c[j] += a[i][j];\n    dpr[0][0] = dpc[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        dpr[i][0] = dpr[i - 1][0];\n        dpr[i][1] = dpr[i - 1][1];\n        if (r[i] & 1)\n        {\n            dpr[i][0] = (dpr[i][0] + dpr[i - 1][1]) % MOD;\n            dpr[i][1] = (dpr[i][1] + dpr[i - 1][0]) % MOD;\n        }\n        else\n        {\n            dpr[i][0] = dpr[i][0] * 2 % MOD;\n            dpr[i][1] = dpr[i][1] * 2 % MOD;\n        }\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        dpc[i][0] = dpc[i - 1][0];\n        dpc[i][1] = dpc[i - 1][1];\n        if (c[i] & 1)\n        {\n            dpc[i][0] = (dpc[i][0] + dpc[i - 1][1]) % MOD;\n            dpc[i][1] = (dpc[i][1] + dpc[i - 1][0]) % MOD;\n        }\n        else\n        {\n            dpc[i][0] = dpc[i][0] * 2 % MOD;\n            dpc[i][1] = dpc[i][1] * 2 % MOD;\n        }\n    }\n    cout << dpr[n][1] * dpc[m][1] % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst int NN=301;\nvoid print(bool p[NN][NN], int n, int m){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tcerr << (p[i][j]?1:0);\n\t\t}\n\t\tcerr << endl;\n\t}\n}\nint solve(bool p[NN][NN], int n, int m){\n\tint s=0;\n\tfor(int i=0;i<m;i++){\n\t\tint d=-1;\n\t\tfor(int j=s;j<n;j++){\n\t\t\tif(p[j][i]){\n\t\t\t\td=j;\n\t\t\t}\n\t\t}\n\t\tif(d==-1){\n\t\t\t//cerr << \"aaa\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(d!=s){\n\t\t\tfor(int j=i;j<m;j++){\n\t\t\t\tswap(p[s][j],p[d][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=s+1;j<n;j++){\n\t\t\tif(!p[j][i])continue;\n\t\t\tfor(int k=i;k<m;k++){\n\t\t\t\tp[j][k]^=p[s][k];\n\t\t\t}\n\t\t}\n\t\t//print(p,n,m);\n\t\ts++;\n\t\t//cerr << \"aa \" << s << endl;\n\t}\n\treturn s;\n}\n\nbool a[301][301];\nLL C[301][301];\nLL ps[301];\nconst LL M=998244353;\nint main() {\n\tint N,K;\n\tcin >> N >> K;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tint v;\n\t\t\tcin >>v;\n\t\t\tif(v){\n\t\t\ta[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tint s=solve(a,N,K);\n\t//cerr << s << endl;\n\tfor(int i=0;i<301;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%M;\n\t\t}\n\t}\n\tps[0]=1;\n\tfor(int i=1;i<301;i++){\n\t\tps[i]=ps[i-1]*2%M;\n\t}\n\tLL ret=0;\n\tfor(int i=1;i<=s;i++){\n\t\tfor(int j=1;j<=i;j+=2){\n\t\t\tret+=C[s][i]%M*C[i][j]%M*ps[s-i]%M*ps[N-s]%M*ps[K-s]%M;\n\t\t\tret%=M;\n\t\t}\n\t}\n\tcout << ret << endl;\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=998244353;\nconst int N=300;\n\nll n, m, k, u, v, x, y, t, a, b, ans, cnt;\nll tav[N+1];\nbitset<N> A[N], G[N];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\ttav[0]=1;\n\tfor (int i=1; i<=N; i++) tav[i]=tav[i-1]*2%mod;\n\tcin>>n>>m;\n\tfor (int i=0; i<n; i++) for (int j=0; j<m; j++){\n\t\tcin>>x;\n\t\tif (x) A[i].set(j);\n\t}\n\tfor (int i=0; i<N; i++){\n\t\tfor (int j=0; j<cnt; j++){\n\t\t\tint lb=G[j]._Find_first();\n\t\t\tif (A[i][lb]) A[i]^=G[j];\n\t\t}\n\t\tif (!A[i].count()) continue ;\n\t\tfor (int j=0; j<cnt; j++){\n\t\t\tint lb=A[i]._Find_first();\n\t\t\tif (G[j][lb]) G[j]^=A[i];\n\t\t}\n\t\tG[cnt++]=A[i];\n\t}\n\tans=(tav[n]-tav[n-cnt])*tav[m-1]%mod;\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nll power_mod(ll a,ll b,ll mod) {\n    if (b == 0) return 1;\n    if (b == 1) return a;\n    ll c = power_mod(a,b/2,mod);\n    if (b%2) return c*c%mod*a%mod;\n    else return c*c%mod;\n}\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    bool a[n][m];\n    int r = 0;\n    for (int i = 0;i < n;++i) for (int j = 0;j < m;++j) cin >> a[i][j];\n    for (int i = 0;i < min(n,m);++i) {\n        int p = i,q = i;\n        for (int j = i;j < n;++j) {\n            if (a[p][q]) break;\n            for (int k = i;k < m;++k) if (a[j][k]) {\n                p = j;q = k;\n                break;\n            }\n        }\n        if (!a[p][q]) break;\n        r = i+1;\n        for (int j = i;j < n;++j) swap(a[j][i],a[j][q]);\n        for (int j = i;j < m;++j) swap(a[i][j],a[p][j]);\n        for (int j = i+1;j < n;++j) if (a[j][i]) for (int k = i;k < m;++k) a[j][k] ^= a[i][k];\n        for (int j = i+1;j < m;++j) if (a[i][j]) for (int k = i;k < n;++k) a[k][j] ^= a[k][i];\n    }\n    cout << (power_mod(2,n+m-1,mod)-power_mod(2,n+m-r-1,mod)+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MOD = 998244353;\nconst int kN = 300 + 5;\nint n, m;\nint a[kN][kN];\n\nint power(int a, int b) {\n  int ret = 1;\n  while (b) {\n    if (b & 1) ret = ret * 1LL * a % MOD;\n    a = a * 1LL * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nint gauss() {\n  int ret = 0;\n  for (int i = 0, p = 0; i < n; ++ i) {\n    int k = -1;\n    while (k == -1 && p != n) {\n      for (int j = i; j < n; ++ j) {\n        if (a[j][p]) {\n          k = j;\n          break;\n        }\n      }\n      if (k == -1) {\n        ++ p;\n      }\n    }\n    if (k == -1) break;\n    ret ++;\n    for (int r = 0; r < m; ++ r)\n      std::swap(a[i][r], a[k][r]);\n    for (int w = i + 1; w < n; ++ w) {\n      if (a[w][p]) {\n        for (int r = 0; r < m; ++ r)\n          a[w][r] ^= a[i][r];\n      }\n    }\n    ++ p;\n  }\n  return ret;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++ i) {\n    for (int j = 0; j < m; ++ j) {\n      scanf(\"%d\", &a[i][j]);\n    }\n  }\n  int rank = gauss();\n  int result = (power(2, n) - power(2, n - rank) + MOD) % MOD * 1LL * power(2, m - 1) % MOD;\n  printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n\nstruct edge { int to, cost; };\n\nconst int INF = 1e18;\nconst int MOD = 1e9+7;\n\ntemplate<int mod=MOD>\nstruct ModRing {\n   int x;\n   ModRing() = default;\n   ModRing(int a) { x = ((a % mod) + mod) % mod; }\n\n   const ModRing operator+() const { return ModRing(x); }\n   const ModRing operator-() const { return ModRing((-x + mod) % mod); }\n\n   ModRing& operator+=(const ModRing& a) { (x += a.x) %= mod; return *this; }\n   ModRing& operator-=(const ModRing& a) { return *this += -a; }\n   ModRing& operator*=(const ModRing& a) { (x *= a.x) %= mod; return *this; }\n\n   ModRing& operator++() { return *this += 1; }\n   ModRing& operator--() { return *this -= 1; }\n\n   const ModRing operator+(const ModRing& a) const { return ModRing(*this) += a; }\n   const ModRing operator-(const ModRing& a) const { return ModRing(*this) -= a; }\n   const ModRing operator*(const ModRing& a) const { return ModRing(*this) *= a; }\n\n   bool operator<(const ModRing& a) const { return x < a.x; }\n   bool operator>(const ModRing& a) const { return a < *this; }\n   bool operator<=(const ModRing& a) const { return !(*this > a); }\n   bool operator>=(const ModRing& a) const { return !(*this < a); }\n   bool operator==(const ModRing& a) const { return !(*this < a) && !(*this > a); }\n   bool operator!=(const ModRing& a) const { return !(*this == a); }\n\n   const ModRing power(int n) const {\n      ModRing tmp = x, res = 1;\n      while (n > 0) { if ((n & 1) == 1) res *= tmp; tmp *= tmp; n >>= 1; }\n      return res;\n   }\n};\n\ntemplate<int mod>auto&operator<<(ostream&s,const ModRing<mod>&a){s<<a.x;return s;}\n\ntemplate<int mod=MOD>\nstruct FiniteField : ModRing<mod> {\n   FiniteField() = default;\n   FiniteField(int a) : ModRing<mod>(a) {}\n   FiniteField(const ModRing<mod>& a) : ModRing<mod>(a) {}\n\n   FiniteField inverse() const {\n      try { if (this->x == 0) throw \"0 have no inverse\"; }\n      catch (const char* e) { cerr << e << endl; }\n      return ModRing<mod>::power(mod-2);\n   }\n   FiniteField& operator/=(const FiniteField& a) { return *this = (*this *= a.inverse()); }\n   const FiniteField operator/(const FiniteField& a) const { return FiniteField(*this) /= a; }\n};\n\n\ntemplate<typename Field>\nstruct Matrix\n{\n   vector<vector<Field>> val;\n   int m, n;\n\n   Matrix() = default;\n   Matrix(int a, int b) : m(a), n(b) {\n      val.resize(m, vector<Field>(n));\n   }\n   Matrix(const vector<vector<Field>>& vec) { init(vec); }\n   void init(const vector<vector<Field>>& vec) {\n      m = vec.size(); n = vec[0].size();\n      val.resize(m, vector<Field>(n));\n      for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\n         val[i][j] = vec[i][j];\n   }\n\n   Matrix& operator=(const Matrix& mat) {\n      try { if (m != mat.m || n != mat.n) throw \"Matrix can't be substituted\"; }\n      catch (const char* e) { cerr << e << endl; }\n      for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\n         val[i][j] = mat.val[i][j];\n      return *this;\n   }\n\n   Field& operator()(int i, int j) {\n      try { if (i < 0 || m <= i || j < 0 || n <= j) throw \"Bad access\"; }\n      catch (const char* e) { cerr << e << endl; }\n      return val[i][j];\n   }\n   const Field operator()(int i, int j) const {\n      try { if (i < 0 || m <= i || j < 0 || n <= j) throw \"Bad access\"; }\n      catch (const char* e) { cerr << e << endl; }\n      return val[i][j];\n   }\n\n   Matrix& operator-() const {\n      Matrix tmp(m, n);\n      for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\n         tmp.val[i][j] = -val[i][j];\n      return tmp;\n   }\n\n   Matrix& operator+=(const Matrix& mat) {\n      try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n      catch (const char* e) { cerr << e << endl; }\n      for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\n         val[i][j] += mat.val[i][j];\n      return *this;\n   }\n   Matrix& operator-=(const Matrix& mat) {\n      try { if (m != mat.m || n != mat.n) throw \"Matrix can't be subtracted\"; }\n      catch (const char* e) { cerr << e << endl; }\n      return *this += -mat;\n   }\n   Matrix operator*=(const Matrix& mat) {\n      try { if (n != mat.m) throw \"Matrix can't be producted\"; }\n      catch (const char* e) { cerr << e << endl; }\n      Matrix tmp(m, mat.n);\n      for (int i = 0; i < m; i++) for (int j = 0; j < mat.n; j++) for (int k = 0; k < n; k++)\n         tmp.val[i][j] += val[i][k] * mat.val[k][j];\n      n = mat.n;\n      val.resize(m, vector<Field>(n));\n      return *this = tmp;\n   }\n\n   const Matrix operator+(const Matrix& mat) const { return Matrix(*this) += mat; }\n   const Matrix operator-(const Matrix& mat) const { return Matrix(*this) -= mat; }\n   const Matrix operator*(const Matrix& mat) const { return Matrix(*this) *= mat; }\n\n   Matrix transpose() const {\n      Matrix tmp(n, m);\n      for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\n         tmp.val[j][i] = val[i][j];\n      return tmp;\n   }\n\n   int gaussElimination() {\n      int swap_num = 0;\n      int col = 0;\n      for (int i = 0; i < m; i++) {\n         int pivot;\n         bool updated = false;\n         while (col < n) {\n            for (int j = i; j < m; j++) if (val[j][col] != 0) {\n               pivot = j;\n               updated = true;\n               break;\n            }\n            if (updated) break;\n            col++;\n         }\n         if (!updated) return swap_num;\n\n         if (i != pivot) {\n            swap(val[i], val[pivot]);\n            swap_num++;\n         }\n         for (int j = i+1; j < m; j++) {\n            Field ratio = val[j][col] / val[i][col];\n            for (int k = col; k < n; k++) val[j][k] -= val[i][k] * ratio;\n         }\n         col++;\n      }\n      return swap_num;\n   }\n\n   int rank() const {\n      Matrix A(val);\n      A.gaussElimination();\n      int j = 0;\n      for (int i = 0; i < m; i++) {\n         while (A.val[i][j] == 0) {\n            j++; if (j == n) return i;\n         }\n      }\n      return m;\n   }\n};\ntemplate<typename Field>ostream&operator<<(ostream&s,const Matrix<Field>&mat){s<<endl<<\"[\";for(int i=0;i<mat.m;i++){s<<\"[\";for(int j=0;j<mat.n;j++){s<<mat(i,j);if(j<mat.n-1)s<<\" \";}s<<\"]\";if(i<mat.m-1)s<<endl;}s<<\"]\";return s;}\n\ntemplate<typename Field>\nstruct SquareMatrix : Matrix<Field>\n{\n   int num;\n   SquareMatrix(int a=0) : Matrix<Field>(a, a) { num = a; }\n   SquareMatrix(const vector<vector<Field>>& vec) : num(vec.size()), Matrix<Field>(vec) {\n      try { if (vec.size() != vec[0].size()) throw \"Matrix isn't square matrix\"; }\n      catch (const char* e) { cerr << e << endl; }\n   }\n\n   Field determinant() const {\n      SquareMatrix A(*this);\n      int swap_num = A.gaussElimination();\n      Field det = (swap_num % 2 ? -1 : 1);\n      for (int i = 0; i < num; i++) det *= A(i,i);\n      return det;\n   }\n\n   SquareMatrix power(int n) const {\n      SquareMatrix A(*this);\n      vector<vector<Field>> E(num,vector<Field>(num));\n      for (int i = 0; i < num; i++) E[i][i] = 1;\n      SquareMatrix res(E);\n      while (n > 0) { if ((n & 1) == 1) res *= A; A *= A; n >>= 1; }\n      return res;\n   }\n};\n\nsigned main()\n{\n   int n, m; cin >> n >> m;\n\n   using GF2 = FiniteField<2>;\n   V<V<GF2>> a(n, V<GF2>(m));\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         int v; cin >> v;\n         a[i][j] = v;\n      }\n   }\n\n   Matrix<GF2> A(a);\n\n   int rank = A.rank();\n\n   using GF = FiniteField<998244353>;\n   GF ans = GF(2).power(n+m-1) - GF(2).power(n+m-rank-1);\n   cout << ans << endl;\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint rd(){\n    int a=0;char ch=getchar();\n    while(!isdigit(ch))ch=getchar();\n    while(isdigit(ch))a=(a<<1)+(a<<3)+(ch^48),ch=getchar();\n    return a;\n}\nll rdll(){\n    ll a=0;char ch=getchar();\n    while(!isdigit(ch))ch=getchar();\n    while(isdigit(ch))a=(a<<1)+(a<<3)+(ch^48),ch=getchar();\n    return a;\n}\n\nconst int N=304;\nconst ll p=998244353;\nint n,m,x;\nbitset<N>a[N],d[N];\nll expo(ll a,ll b){\n    ll c=1;\n    while(b){\n        if(b&1)c=c*a%p;\n        b>>=1,a=a*a%p;\n    }\n    return c;\n}\nvoid dbg(const bitset<N> &a){\n\tfor(int i=1;i<=m;i++)printf(\" %d\",a[i]);printf(\"\\n\");\n}\nint main(){\n\tn=rd(),m=rd();\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=m;j++)a[i][j]=rd();\n\tfor(int i=1;i<=n;i++)for(int j=m;j;j--)if(a[i][j]){//printf(\"a[%d]:\",i);dbg(a[i]);printf(\"d[%d]:\",j);dbg(d[j]);\n\t    if(d[j][j])a[i]^=d[j];\n\t    else{d[j]=a[i];break;}\n\t}\n\tfor(int i=1;i<=m;i++)x+=d[i][i];//printf(\"x=%d\\n\",x);\n\tprintf(\"%lld\",((expo(2,m)-expo(2,m-x)+p)%p)*expo(2,n-1)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// by tmt514\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#define SZ(x) ((int)(x).size())\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 998244353;\nLL bigmod(LL a, LL n) {\n  if(n==0) return 1;\n  if(n==1) return a%MOD;\n  return bigmod(a*a%MOD, n/2) * (n%2? a:1)%MOD;\n}\nint main(void) {\n  int n, m;\n  int a[305][305] = {};\n  cin >> n >> m;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      cin >> a[i][j];\n  int rank=0, w=0;\n  for(int i=0;i<n && i<m;i++) {\n    int g=-1;\n    for(int j=w;j<n;j++)\n      if(a[j][i]==1) {\n        g=j;\n        break;\n      }\n    if(g>=0) {\n      for(int k=i;k<m;k++)\n        swap(a[w][k], a[g][k]);\n      for(int j=w+1;j<n;j++)\n        for(int k=i;k<m;k++)\n          a[j][k] ^= a[w][k];\n      ++rank;\n      ++w;\n    }\n  }\n  LL t = bigmod(2, m-1) * (bigmod(2, n) - bigmod(2, n-rank)) % MOD;\n  t=(t+MOD)%MOD;\n  cout << t << endl;\n  \n      \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#ifdef MY_DEBUG\n#include \"header/header.hpp\"\n#else\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n#ifdef MY_DEBUG\n#include\"print.hpp\"\n#include\"debug.hpp\"\n#endif\n// }}}\n\nconst long long MOD = 998244353;\n\n//{{{ modular algebra\ntemplate<int mod=MOD>\nstruct Num{\n\tint v;\n\tNum(int n):v(n){}\n\tNum():v(0){}\n\toperator int() const {return v;}\n\toperator long long() const {return v;}\n\ttemplate<class T>\n\tNum operator =(int n){v=n;return *this;}\n\n\ttemplate<class T>\n\tinline void operator *=(const T &a) {\n\t\tv = (v*(long long)a)%mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator *(const T &a) {\n\t\tNum n(*this);n*=a;\n\t\treturn n;\n\t}\n\ttemplate<class T>\n\tinline void operator+=(const T &a){\n\t\tv+=(int)a;\n\t\tif(v>=mod)v-=mod;\n\t\t//\tassert(0<=v and v<mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator+(const T &a){\n\t\tNum n(*this);n+=a;\n\t\treturn n;\n\t}\n\tinline Num operator -(){\n\t\tif(v==0)return 0;\n\t\telse return Num(mod-v);\n\t}\n\ttemplate<class T>\n\tinline void operator -=(const T &a){\n\t\tv-=(int)a;\n\t\tif(v<0)v+=mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator -(const T &a){\n\t\tNum n(*this);n-=a;\n\t\treturn n;\n\t}\n\n#ifdef __GCD_H\n\tinline Num inv(){\n\t\treturn Num(invMod(this->v,mod));\n\t}\n\ttemplate<class T>\n\tinline void operator /=(const T &a){\n\t\t(*this)*=invMod((int)a,mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator /(const T &a){\n\t\tNum n(*this);n/=a;\n\t\treturn n;\n\t}\n#endif\n};\n\ntemplate<int mod=MOD>\nint abs(Num<mod> &a){\n\treturn a.v;\n}\ntemplate<class T, int mod>\nT& operator <<(T &os, const Num<mod> &n){\n\tos<<(int)n.v;\n\treturn os;\n}\n\ntemplate<class T, int mod>\nT& operator >>(T &is, Num<mod> &n){\n\tis>>n.v;\n\treturn is;\n}\n//}}}\ntypedef Num<MOD> mod_int;\n\n//{{{ mod_pow(Num<mod> x,Int k)\n/* (x^k)%m */\ntemplate<int mod=MOD>\ninline Num<mod> mod_pow(Num<mod> x, Int k){\n\tif(k==0) return 1;\n\tNum<mod> res(mod_pow(x,k/2));\n\tres*=res;\n\tif(k%2)res*=x;\n\treturn res;\n}\n//}}}\n\nInt N;\nInt M;\nvector<vector<Int>> a;\n\n//{{{ rix library: MATRIX<T> A(n); MATRIX<T> A(n,m); VECTOR<T> v(n);\ntemplate<class T>\nstruct VECTOR:public vector<T>{\n\tconst int &n;\n\tVECTOR(const int &n):n(n){\n\t\tthis->assign(n,0);\n\t}\n};\n\n// O( n )\ntemplate<class T>\nT inner_product(const VECTOR<T> &a, const VECTOR<T> &b) {\n\tT ans = 0;\n\tfor (int i = 0; i < a.n; ++i)\n\t\tans += a[i]*b[i];\n\treturn ans;\n}\n\ntemplate<class T>\nstruct MATRIX:vector<vector<T> > {\n\tconst int n,m;\n\tMATRIX(int n):n(n),m(n){\n\t\tthis->assign(n,vector<T>(n,0));\n\t}\n\tMATRIX(const pair<int,int> &p):n(p.first),m(p.second){\n\t\tthis->assign(n,vector<T>(m,0));\n\t}\n\t// O( n )\n\tvoid operator+=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] += B[i][j];\n\t}\n\tvoid operator-=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] -= B[i][j];\n\t}\n};\n\ntemplate<class T>\nMATRIX<T> identity(int n) {\n\tMATRIX<T> A(n);\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> zero(int n) {\n\tMATRIX<T> A(n);\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> operator+(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC+=B;\n\treturn C;\n}\ntemplate<class T>\nMATRIX<T> operator-(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC-=B;\n\treturn C;\n}\n// O( n^2 )\ntemplate<class T>\nVECTOR<T> operator*(const MATRIX<T> &A, const VECTOR<T> &x) {\n\tVECTOR<T> y(A.n);\n\tfor (int i = 0; i < A.n; ++i)\n\t\tfor (int j = 0; j < A.m; ++j)\n\t\t\ty[i] += T(A[i][j])*x[j];\n\treturn y;\n}\n// O( n^3 )\ntemplate<class T>\nMATRIX<T> operator*(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C({A.n,B.m});\n\tfor (int i = 0; i < C.n; ++i)\n\t\tfor (int j = 0; j < C.m; ++j)\n\t\t\tfor (int k = 0; k < A.m; ++k)\n\t\t\t\tC[i][j] += T(A[i][k])*B[k][j];\n\treturn C;\n}\n// O( n^3 )\ntemplate<class T>\nvoid operator*=(MATRIX<T> &A, const MATRIX<T> &B){\n\tA = A*B;\n}\n\n// O( n^3 log e )\ntemplate<class T>\nMATRIX<T> pow(const MATRIX<T> &A, long long e) {\n\treturn e == 0 ? identity<T>(A.size())  :\n\te % 2 == 0 ? pow(A*A, e/2) : A*pow(A, e-1);\n}\n\ntypedef int Number;\ntypedef MATRIX<Number> Matrix;\ntypedef VECTOR<Number> Vector;\n\n//}}}\n\n//{{{ gauss\ntemplate<class T>\nint gauss(MATRIX<T> &A, VECTOR<T> &b) {\n\t//int gauss(& A) {//returns rank\n\tconst int n = A.size(), m = A[0].size();\n\tint pi = 0;\n\tfor(int pj = 0;pj < m;pj++){\n\t\tfor(int i = pi+1; i < n; i++) {\n\t\t\tif (abs(A[i][pj]) > abs(A[pi][pj])) {\n\t\t\t\tswap(A[i], A[pi]);\n\t\t\t\tswap(b[i], b[pi]);\n\t\t\t}\n\t\t}\n\t\tif (abs(A[pi][pj]) > 0) {\n\t\t\tT d = A[pi][pj];//1/A[pi][pj]\n\t\t\tREP(j, m)A[pi][j] *= d;\n\t\t\tb[pi] *= d;\n\t\t\tREP(i,n){\n\t\t\t\tif(i==pi)continue;\n\t\t\t\tT k = A[i][pj];\n\t\t\t\tREP(j, m) A[i][j] -= k * A[pi][j];\n\t\t\t\tb[i] -= k * b[pi];\n\t\t\t}\n\t\t\tpi++;\n\t\t}\n\t\tif(pi==N)break;\n\t}\n\treturn pi;\n\t/*\n\t   for(int i = pi; i < n; i++)\n\t   if (abs(b[i]) > 0)\n\t   throw Inconsistent();\n\t   if (pi < m || pj < m)\n\t   throw Ambiguous();\n\t   for(int j = m-1; j >= 0; j--)\n\t   REP(i, j)\n\t   b[i] = modulo(b[i] - b[j] * A[i][j]);\n\t   */\n}\n//}}}\n\nvoid solve(){\n\tMATRIX<Num<2> > a2({N,M});\n\tVECTOR<Num<2> > b(N);\n\tREP(i,N)REP(j,M)a2[i][j] = a[i][j];\n\tint t = gauss(a2,b);\n\t/*\n\tREP(i,a2.size()){\n\t\tREP(j,a2[0].size()){\n\t\t\tcout<<a2[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<t<<endl;\n\t*/\n\tmod_int ans = mod_pow((mod_int)2,N) - mod_pow((mod_int)2,N-t);\n\tans *= mod_pow((mod_int)2,M-1);\n\tcout<<ans<<endl;\n}\n\n//{{{ main fucnction\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> N;\n\tcin >> M;\n\ta.assign(N, vector<Int>(M));\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < M ; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tsolve();\n\treturn 0;\n}\n\n//}}}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\n/*bool operator < (const vector<long long> &a,const vector<long long> &b){\n    bool ret=false;\n    DEBUG(\"called\");\n    for(long long i = 0; i < a.size(); i++){\n        if(a[i]>b[i]){\n            ret=false;\n            break;\n        }else if(a[i]<b[i]){\n            ret=true;\n            break;\n        }\n    }\n    return ret;\n}\n*/\nll cache_pow[600];\nll mpow(ll a){\n    static bool flag=false;\n    if(flag){\n        DEBUG(\"True\");\n        return cache_pow[a];\n    }else{\n        cache_pow[0]=1;\n        for(long long i = 1; i < 600; i++){\n            cache_pow[i]=(cache_pow[i-1]*2)%MOD;\n        }\n        flag=true;\n        return cache_pow[a];\n    }\n}\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    sort(a.begin(),a.end(),greater<vll>());\n    ll index=0;\n\n    vector<bitset<300>> A;\n    for(long long i = 0; i < a.size(); i++){\n        A.push_back(bitset<300>(0));\n        for(long long k = 0; k < a[i].size(); k++){\n            A[i][k]=a[i][k]==1;\n        }\n    }\n    ll rank=0;\n    for(long long i = 0; i < a.size(); i++){\n        DEBUG(i);\n        for(; index < a[i].size()&&a[i][index]==0; index++){\n            DEBUG(index);\n        }\n        if(index==a[i].size()){\n            break;\n        }\n        rank++;\n        for(long long j = i+1; j < a.size()&&a[j][index]==1; j++){\n            A[j]^=A[i];\n        }\n    }\n    DEBUG(rank);\n    cout<<mpow(M+N-1)-mpow(M+N-1-rank)<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#ifdef MY_DEBUG\n#include \"header/header.hpp\"\n#else\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n#ifdef MY_DEBUG\n#include\"print.hpp\"\n#include\"debug.hpp\"\n#endif\n// }}}\n\nconst long long MOD = 998244353;\n\n//{{{ modular algebra\ntemplate<int mod=MOD>\nstruct Num{\n\tint v;\n\tNum(int n):v(n){}\n\tNum():v(0){}\n\toperator int() const {return v;}\n\toperator long long() const {return v;}\n\ttemplate<class T>\n\tNum operator =(int n){v=n;return *this;}\n\n\ttemplate<class T>\n\tinline void operator *=(const T &a) {\n\t\tv = (v*(long long)a)%mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator *(const T &a) {\n\t\tNum n(*this);n*=a;\n\t\treturn n;\n\t}\n\ttemplate<class T>\n\tinline void operator+=(const T &a){\n\t\tv+=(int)a;\n\t\tif(v>=mod)v-=mod;\n\t\t//\tassert(0<=v and v<mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator+(const T &a){\n\t\tNum n(*this);n+=a;\n\t\treturn n;\n\t}\n\tinline Num operator -(){\n\t\tif(v==0)return 0;\n\t\telse return Num(mod-v);\n\t}\n\ttemplate<class T>\n\tinline void operator -=(const T &a){\n\t\tv-=(int)a;\n\t\tif(v<0)v+=mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator -(const T &a){\n\t\tNum n(*this);n-=a;\n\t\treturn n;\n\t}\n\n#ifdef __GCD_H\n\tinline Num inv(){\n\t\treturn Num(invMod(this->v,mod));\n\t}\n\ttemplate<class T>\n\tinline void operator /=(const T &a){\n\t\t(*this)*=invMod((int)a,mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator /(const T &a){\n\t\tNum n(*this);n/=a;\n\t\treturn n;\n\t}\n#endif\n};\n\ntemplate<int mod=MOD>\nint abs(Num<mod> &a){\n\treturn a.v;\n}\ntemplate<class T, int mod>\nT& operator <<(T &os, const Num<mod> &n){\n\tos<<(int)n.v;\n\treturn os;\n}\n\ntemplate<class T, int mod>\nT& operator >>(T &is, Num<mod> &n){\n\tis>>n.v;\n\treturn is;\n}\n//}}}\ntypedef Num<MOD> mod_int;\n\n//{{{ mod_pow(Num<mod> x,Int k)\n/* (x^k)%m */\ntemplate<int mod=MOD>\ninline Num<mod> mod_pow(Num<mod> x, Int k){\n\tif(k==0) return 1;\n\tNum<mod> res(mod_pow(x,k/2));\n\tres*=res;\n\tif(k%2)res*=x;\n\treturn res;\n}\n//}}}\n\nInt N;\nInt M;\nvector<vector<Int>> a;\nvector<vector<Int>> a2;\n\n//{{{ rix library: MATRIX<T> A(n); MATRIX<T> A(n,m); VECTOR<T> v(n);\ntemplate<class T>\nstruct VECTOR:public vector<T>{\n\tconst int &n;\n\tVECTOR(const int &n):n(n){\n\t\tthis->assign(n,0);\n\t}\n};\n\n// O( n )\ntemplate<class T>\nT inner_product(const VECTOR<T> &a, const VECTOR<T> &b) {\n\tT ans = 0;\n\tfor (int i = 0; i < a.n; ++i)\n\t\tans += a[i]*b[i];\n\treturn ans;\n}\n\ntemplate<class T>\nstruct MATRIX:vector<vector<T> > {\n\tconst int n,m;\n\tMATRIX(int n):n(n),m(n){\n\t\tthis->assign(n,vector<T>(n,0));\n\t}\n\tMATRIX(const pair<int,int> &p):n(p.first),m(p.second){\n\t\tthis->assign(n,vector<T>(m,0));\n\t}\n\t// O( n )\n\tvoid operator+=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] += B[i][j];\n\t}\n\tvoid operator-=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] -= B[i][j];\n\t}\n};\n\ntemplate<class T>\nMATRIX<T> identity(int n) {\n\tMATRIX<T> A(n);\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> zero(int n) {\n\tMATRIX<T> A(n);\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> operator+(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC+=B;\n\treturn C;\n}\ntemplate<class T>\nMATRIX<T> operator-(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC-=B;\n\treturn C;\n}\n// O( n^2 )\ntemplate<class T>\nVECTOR<T> operator*(const MATRIX<T> &A, const VECTOR<T> &x) {\n\tVECTOR<T> y(A.n);\n\tfor (int i = 0; i < A.n; ++i)\n\t\tfor (int j = 0; j < A.m; ++j)\n\t\t\ty[i] += T(A[i][j])*x[j];\n\treturn y;\n}\n// O( n^3 )\ntemplate<class T>\nMATRIX<T> operator*(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C({A.n,B.m});\n\tfor (int i = 0; i < C.n; ++i)\n\t\tfor (int j = 0; j < C.m; ++j)\n\t\t\tfor (int k = 0; k < A.m; ++k)\n\t\t\t\tC[i][j] += T(A[i][k])*B[k][j];\n\treturn C;\n}\n// O( n^3 )\ntemplate<class T>\nvoid operator*=(MATRIX<T> &A, const MATRIX<T> &B){\n\tA = A*B;\n}\n\n// O( n^3 log e )\ntemplate<class T>\nMATRIX<T> pow(const MATRIX<T> &A, long long e) {\n\treturn e == 0 ? identity<T>(A.size())  :\n\te % 2 == 0 ? pow(A*A, e/2) : A*pow(A, e-1);\n}\n\ntypedef int Number;\ntypedef MATRIX<Number> Matrix;\ntypedef VECTOR<Number> Vector;\n\n//}}}\n\n//{{{ gauss\ntemplate<class T>\nint gauss(MATRIX<T> &A/*, VECTOR<T> &b*/) {\n\t//int gauss(& A) {//returns rank\n\tconst int n = A.size(),m = A[0].size();\n\tint pi = 0;\n\tfor(int pj = 0;pj < m;pj++){\n\t\tfor(int i = pi+1; i < n; i++) {\n\t\t\tif (abs(A[i][pj]) > abs(A[pi][pj])) {\n\t\t\t\tswap(A[i], A[pi]);\n//\t\t\t\tswap(b[i], b[pi]);\n\t\t\t}\n\t\t}\n\t\tif (abs(A[pi][pj]) > 0) {\n\t\t\tT d = A[pi][pj];//1/A[pi][pj]\n\t\t\tREP(j, m)A[pi][j] *= d;\n//\t\t\tb[pi] *= d;\n\t\t\tREP(i,n){\n\t\t\t\tif(i==pi)continue;\n\t\t\t\tT k = A[i][pj];\n\t\t\t\tREP(j, m) A[i][j] -= k * A[pi][j];\n//\t\t\t\tb[i] -= k * b[pi];\n\t\t\t}\n\t\t\tpi++;\n\t\t}\n\t}\n\treturn pi;\n\t/*\n\t   for(int i = pi; i < n; i++)\n\t   if (abs(b[i]) > 0)\n\t   throw Inconsistent();\n\t   if (pi < m || pj < m)\n\t   throw Ambiguous();\n\t   for(int j = m-1; j >= 0; j--)\n\t   REP(i, j)\n\t   b[i] = modulo(b[i] - b[j] * A[i][j]);\n\t   */\n}\n//}}}\n\nvoid solve(){\n\tMATRIX<Num<2> > a2({N,M});\n\tVECTOR<Num<2> > b(M);\n\tREP(i,N)REP(j,M)a2[i][j] = a[i][j];\n\tint t = gauss(a2);\n\t/*\n\tREP(i,a2.size()){\n\t\tREP(j,a2[0].size()){\n\t\t\tcout<<a2[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<t<<endl;\n\t*/\n\tmod_int ans = mod_pow((mod_int)2,N) - mod_pow((mod_int)2,t-N);\n\tans *= mod_pow((mod_int)2,M-1);\n\tcout<<ans<<endl;\n}\n\n//{{{ main fucnction\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> N;\n\tcin >> M;\n\ta.assign(N, vector<Int>(M));\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < M ; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tsolve();\n\treturn 0;\n}\n\n//}}}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#define inf 20021225\n#define ll long long\n#define mdn 998244353\nusing namespace std;\n \nbitset<310> r[310],a[310]; int n,m;\nint gauss()\n{\n\tint w = 0;\n\tfor(int i=1,j;i<=min(n,m);i++)\n\t{\n\t\tif(!r[i][i])\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t\tif(r[j][i])\tbreak;\n\t\t\tif(j>n)\tcontinue;\n\t\t\tswap(r[i],r[j]);\n\t\t}\n\t\tfor(j=i+1;j<=n;j++)\tif(r[j][i])\n\t\t\tfor(int k=i;k<=m;k++)\tr[j][k]=r[i][k]^r[j][k];\n\t}\n\tfor(int i=1;i<=n;i++)\tif(r[i].any())\tw++;\n\t/**for(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=m;j;j--)\n\t\t{\n\t\t\tif(!r[i][j])\tcontinue;\n\t\t\tif(!a[j].any())\n\t\t\t{\n\t\t\t\ta[j]^=r[i],w++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\tr[i]^=a[j];\n\t\t}\n\t}*/\n\treturn w;\n}\nint ksm(int bs,int mi)\n{\n\tint ans = 1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=(ll)ans*bs%mdn;\n\t\tbs=(ll)bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tr[i][j] = x;\n\t\t}\n\tint ans = ksm(2,n+m-1)-ksm(2,n+m-1-gauss());\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VVI a(n, VI(m));\n    REP(i,n) REP(j,m) a[i][j] = in();\n\n    int r = 0, p = 0;\n    REP(i,min(n, m)){\n        while (p < m){\n            int j = -1;\n            FOR(k,i,n-1){\n                if (a[k][p]){\n                    j = k;\n                    break;\n                }\n            }\n            if (j == -1){\n                p++;\n                continue;\n            }\n            r = i + 1;\n            swap(a[i], a[j]);\n            FOR(j,i+1,n-1){\n                if (!a[j][i]) continue;\n                FOR(k,p,m-1) a[j][k] ^= a[i][k];\n            }\n            p++;\n            break;\n        }\n    }\n\n    ll ans = powll(2, m - 1) * (powll(2, n) - powll(2, n - r) + mod) % mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n  Int_ inv(){\n    return Int_(mpow(x,mod-2));\n  }\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<998244353> Int;\n\nInt mpow(Int a,lint k){\n  Int res=1;\n  while(k){\n    if(k&1) res=res*a;\n    a=a*a;\n    k>>=1;\n  }\n  return res;\n}\nconst int INF=5e8;\nint h,w;\nint ar[305][305];\n\nint calc_rank(){\n  int res=0;\n  REP(i,h){\n    int idx=-1;\n    REPN(j,h,i) if(ar[j][i]){\n      idx=j;\n      break;\n    }\n    if(idx==-1) continue;\n    if(idx!=i) REP(j,w) swap(ar[idx][j],ar[i][j]);\n    REPN(j,h,i+1) if(ar[j][i]){\n      REP(k,w) ar[j][k]^=ar[i][k];\n    }\n    ++res;\n  }\n  return res;\n}\nint main(){\n  cin>>h>>w;\n  REP(i,h) REP(j,w) cin>>ar[i][j];\n  int R=calc_rank();\n\n  Int res=(mpow(2,h)-mpow(2,h-R))*mpow(2,w-1);\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<algorithm>\n#define gt getchar()\n#define ll long long\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ninline int in()\n{\n\tint k=0;char ch=gt;\n\twhile(ch<'-')ch=gt;\n\twhile(ch>'-')k=k*10+ch-'0',ch=gt;\n\treturn k;\n}\nconst int N=2e5+5,YL=998244353;\ninline int ksm(int a,int k){int r=1;while(k){if(k&1)r=1ll*r*a%YL;a=1ll*a*a%YL,k>>=1;}return r;}\nstd::bitset<305>a[305],now;\nint n,m;\ninline void insert(std::bitset<305> x)\n{\n\tfor(int i=n;i>=1;--i)\n\t\tif(x[i])\n\t\t{\n\t\t\tif(a[i][i])x^=a[i];\n\t\t\telse {a[i]=x;break;}\n\t\t}\n}\nint main()\n{\n\tn=in(),m=in();int r=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tnow.reset();\n\t\tfor(int j=1;j<=m;++j)now[j]=in();\n\t\tinsert(now);\n\t}\n\tfor(int i=1;i<=n;++i)r+=(a[i].count()!=0);\n\tint ans=ksm(2,n)-ksm(2,n-r);if(ans<0)ans+=YL;\n\tans=1ll*ans*ksm(2,m-1)%YL;printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    int N, M;\n    cin>>N>>M;\n    vector<vector<int>> a(N, vector<int>(M));\n    for (auto &l: a)\n        for (int &c: l)\n            cin>>c;\n\n    for (int i=0; i<N; i++)\n    {\n        int px = -1, py;\n        for (int j=0; j<M && px==-1; j++)\n            for (int k=i; k<N && px==-1; k++)\n                if (a[k][j] != 0)\n                    px = j,\n                    py = k;\n        if (px==-1)\n            break;\n        a[i].swap(a[py]);\n        for (int j=i+1; j<N; j++)\n            if (a[j][py] != 0)\n                for (int k=0; k<M; k++)\n                    a[j][k] ^= a[i][k];\n    }\n    int r = 0;\n    for (int i=0; i<N; i++)\n        for (int j=0; j<M; j++)\n            if (a[i][j] != 0)\n                r = i+1;\n\n    long long MOD = 998244353;\n\n    long long call = 1;\n    for (int i=0; i<M; i++)\n        call = call*2%MOD;\n    long long czero = 1;\n    for (int i=0; i<M-r; i++)\n        czero = czero*2%MOD;\n    long long rall = 1;\n    for (int i=0; i<N-1; i++)\n        rall = rall*2%MOD;\n    cout<<(call-czero+MOD)%MOD*rall%MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n \n\nconst double __gauss_template_EPS = 1e-8;\n\nint Gauss(vector<vector<int>> &mat) {\n    // return rank\n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = rank; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[rank]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        int fs = mat[rank][i];\n\n        for(int j = rank+1; j < n; j++) {\n            int r = mat[j][i] / fs;\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[rank][k] * r;\n            }\n        }\n\n        rank++;\n    }\n\n    return rank;\n}\n\n \n \nconst long long __exp_template_MOD = MOD;\nconst long long mod = MOD;\nint qpow(int x, int n){ int y = 1; while(n){ if(n & 1) y = (ll) y * x % mod; x = (ll) x * x % mod; n >>= 1; } return y; }\n \nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n \nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n \n    printf(\"%lld\\n\", ((qpow(2, n+m-1) - qpow(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n \nvoid init() {\n    \n \n \n}\n \nint main () {\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 303, mod = 998244353;\n\nint n, m;\nbitset<max_n> b;\nvector<bitset<max_n>> v;\n\nint power(int n) {\n    int res = 1;\n    for (int i = 0; i < n; ++i) {\n        res *= 2;\n        res %= mod;\n    }\n    return res;\n}\n\nbool operator < (const bitset<max_n> &a, const bitset<max_n> &b) {\n    for (int i = 0; i < m; ++i) {\n        if (a[i] != b[i]) {\n            return a[i] < b[i];\n        }\n    }\n    return false;\n}\n\nvoid add(bitset<max_n> b) {\n    for (int i = 0; i < v.size(); ++i) {\n        if ((b ^ v[i]) < b) {\n            b ^= v[i];\n        }\n    }\n    if (b == 0) {\n        return;\n    }\n    for (int i = 0; i < v.size(); ++i) {\n        if ((b ^ v[i]) < v[i]) {\n            v[i] ^= b;\n        }\n    }\n    v.push_back(b);\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int x;\n            cin >> x;\n            b[j] = x;\n        }\n        add(b);\n    }\n    int ans = (power(n) + mod - power(n - v.size())) % mod;\n    ans = 1LL * ans * power(m - 1) % mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\nll P = 998244353;\nll mpow(ll a, ll b, ll p = -1){\n  ll ret = 1, num = a;\n  if(p==-1){\n    while(b>0){\n      if(b%2) ret *= num;\n      num = num * num;\n      b /= 2;\n    }\n  }else{\n    while(b>0){\n      if(b%2) ret = (ret*num)%p;\n      num = (num*num)%p;\n      b /= 2;\n    }\n  }\n  return ret;\n}\n\nint main(int argc, char const *argv[]) {\n  // 2^n+m-1(全体の半分)\n  // 自由度xに対し\n  // ans = 2^(n-1+m) - 2^(n-1 + x)\n  ll n, m;std::cin >> n >> m;\n  ll x = 0;\n  vvl dat = VV(n, m, 0, ll);\n\n  for(int i=0;i<n;i++) for(int j=0;j<m;j++) scanf(\"%lld\", &dat[i][j]);\n\n  ll st = 0;\n  for(int i=0;i<min(n, m);i++){\n    //i列目が1の行を探す\n    ll idx = -1;\n    for(int j=st;j<n;j++){\n      if(dat[j][i]){\n        idx = j;\n        break;\n      }\n    }\n    if(idx==-1) continue;\n    swap(dat[st], dat[idx]);\n\n    //stが今、st+1行目以降掃き出し\n    for(int j=st+1;j<n;j++){\n      if(!dat[j][i]) continue;\n      for(int k=i;k<m;k++) dat[j][k] ^= dat[st][k];\n    }\n    st++;\n  }\n  for(int i=0;i<n;i++){\n    bool f = true;\n    for(int j=0;j<m;j++){\n      if(dat[i][j]) {\n        f = false;\n        break;\n      }\n    }\n    if(!f) x++;\n  }\n  ll ans = (mpow(2, n-1+m, P) - mpow(2, n-1+m-x, P) +P)%P;\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing ll = long long;\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t pos = 0;\n    for (std::size_t i = 0; i < mat.C; i++) {\n        if (pos == mat.R) { return pos; }\n        std::size_t piv = pos;\n        for (std::size_t k = pos + 1; k < mat.R; k++) {\n            if (mat[k][i] != 0) { piv = k; }\n        }\n        if (mat[piv][i] == 0) { continue; }\n        std::swap(mat[pos], mat[piv]);\n        for (std::size_t j = i + 1; j < mat.C; j++) { mat[pos][j] /= mat[pos][i]; }\n        for (std::size_t j = pos + 1; j < mat.R; j++) {\n            for (std::size_t k = i + 1; k < mat.C; k++) { mat[j][k] -= mat[pos][k] * mat[j][i]; }\n        }\n        pos++;\n    }\n    return pos;\n}\nconstexpr ll MOD = 998244353;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<int> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<ll> bp(600, 1LL);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2 % MOD; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD) % MOD << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and must not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int Int;\n\ttypedef unsigned int UInt;\n\ttypedef long long Long;\n\ttypedef unsigned long long ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](ULong exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(ULong exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic IntMod Permutation(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / IntMod::Fact(n - r);\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nusing MMK = IntMod<998244353>;\n\nint N, M;\nint A[300][300];\nMMK Naive() {\n\tMMK ret = 0;\n\tREP(s, 0, 1 << N) {\n\t\tREP(t, 0, 1 << M) {\n\t\t\tint cnt = 0;\n\t\t\tREP(i, 0, N) {\n\t\t\t\tREP(j, 0, M) {\n\t\t\t\t\tif (!((1 << i) & s)) continue;\n\t\t\t\t\tif (!((1 << j) & t)) continue;\n\t\t\t\t\tcnt += A[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt % 2 == 1) {\n\t\t\t\t++ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint Rank() {\n\tint r = 0;\n\tREP(i, 0, N) {\n\t\tint k = r;\n\t\twhile (k < N && A[k][i] == 0) {\n\t\t\t++k;\n\t\t}\n\t\tif (k == N) continue;\n\t\tif (k != i) {\n\t\t\tREP(j, 0, N) {\n\t\t\t\tswap(A[i][j], A[k][j]);\n\t\t\t}\n\t\t}\n\n\t\tREP(k, i + 1, N) {\n\t\t\tif (A[k][i] == 1) {\n\t\t\t\tREP(j, i, N) {\n\t\t\t\t\tA[k][j] ^= A[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++r;\n\t}\n\treturn r;\n}\n\nint main() {\n\tcin >> N >> M;\n\tREP(i, 0, N) {\n\t\tREP(j, 0, M) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\t//MMK naive_ans = Naive();\n\n\tint r = Rank();\n\tMMK ans = r == 0 ? 0 : MMK(2)[r - 1] * (MMK(2)[r] - 1) * MMK(2)[N + M - 2 * r];\n\n\t//cout << naive_ans << endl;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n \n\nconst double __gauss_template_EPS = 1e-8;\n\nint Gauss(vector<vector<int>> &mat) {\n    // return rank\n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = rank; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[rank]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        int fs = mat[rank][i];\n\n        for(int j = rank+1; j < n; j++) {\n            int r = mat[j][i] / fs;\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[rank][k] * r;\n            }\n        }\n\n        rank++;\n    }\n\n    return rank;\n}\n\n \nconst long long __exp_template_MOD = MOD;\nconst long long mod = MOD;\nint qpow(int x, int n){ int y = 1; while(n){ if(n & 1) y = (ll) y * x % mod; x = (ll) x * x % mod; n >>= 1; } return y; }\n \nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n \nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n \n    printf(\"%lld\\n\", ((qpow(2, n+m-1) - qpow(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n \nvoid init() {\n    \n \n \n}\n \nint main () {\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdlib>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef long double ld;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\nconst int mod = 998244353;\n\nll mpow(ll x, ll n) {\n  ll res = 1;\n  while (n) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n /= 2;\n  }\n  return res;\n}\n\nint main() {\n  //mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<bitset<300>> v(n);\n  for (int i = 0; i < n; ++i) {\n    v[i].reset();\n    for (int j = 0; j < m; ++j) {\n      int t;\n      cin >> t;\n      if (t) v[i][j] = 1;\n    }\n  }\n  int r = 0;\n  for (int j = 0; j < m; ++j) {\n    for (int i = r; i < n; ++i) if (v[i][j]) {\n      swap(v[r], v[i]);\n      break;\n    }\n    if (!v[r][j]) continue;\n    for (int i = r + 1; i < n; ++i) if (v[i][j]) v[i] ^= v[r];\n    ++r;\n  }\n  ll res = mpow(2, m + n - 1) - mpow(2, n + m - r - 1);\n  cout << (res % mod + mod) % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MOD = 998244353;\nconst Int MAX = 1000;\nInt fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nInt COM(Int n, Int k) {\n    if (n < k || n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nInt POW(Int n, Int m) {\n    if (m == 0) return 1;\n    if (m % 2 == 0) return POW(n * n % MOD, m / 2);\n    return n * POW(n, m - 1) % MOD;\n}\nint gaussian_elimination(vector<vector<int>> &A) {\n    int N = A.size(), M = A[0].size();\n    int t = 0;\n    for (int i = 0; i < N; i++) {\n        for (; t < M; t++) {\n            for (int j = i; j < N; j++) {\n                if (A[j][t]) {\n                    swap(A[i], A[j]);\n                    break;\n                }\n            }\n            if (A[i][t]) break;\n        }\n        if (t >= M) return i;\n        for (int j = i + 1; j < N; j++) {\n            if (j != i && A[j][t]) {\n                for (int k = 0; k < M; k++) A[j][k] ^= A[i][k];\n            }\n        }\n        t++;\n    }\n    return N;\n}\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    COMinit();\n    int N, M; cin >> N >> M;\n    vector<vector<int>> A(N, vector<int>(M));\n    for (auto &row : A) for (auto &a : row) cin >> a;\n    int rank = gaussian_elimination(A);\n    Int ans = 0;\n    for (int i = 1; i <= rank; i++) {\n        for (int j = 1; j <= i; j += 2) {\n            ans = ans + COM(rank, i) * COM(i, j) % MOD * POW(2, M - i);\n        }\n    }\n    ans %= MOD;\n    ans = ans * POW(2, N - rank) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = 998244353ll;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n   ll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n   ll pow(ll a, ll b){if (b == 0) return 1; else if (b % 2 == 0) return pow(a * a, b / 2); else return pow(a * a, b / 2) * a;}\n   ll pow(ll a, ll b, ll m){if (b == 0) return 1; else if (b % 2 == 0) return (pow(a * a, b / 2, m) % m); else return (pow(a * a, b / 2) * a) % m;}\n   ll residue(ll a, ll m){return ((a % m) + m) % m;};\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\n\n//与えられたF2上の行列をAとして、(1 << (M * N - rank(A) - 1)) * ((1 << rank(A)) - 1 )が答え.\nll const MAX_M = 300, MAX_N = 300;\nll N, M;\nll a[MAX_N][MAX_M];\n\nll rnk(){\n   ll r = 0;\n   ll i = 0, j = 0;\n   while(i < N && j < M){\n      if(a[i][j]){\n         r++;\n         for(ll k = i + 1; k < N; k++){\n            for(ll l = j; l < M; l++){\n               a[k][l] = a[k][l] ^ a[i][l];\n            }\n         }\n         i++; j++;\n      }\n      else{\n         for(ll k = i + 1; k < N; k++){\n            if(a[k][j]){\n               for(ll l = j; l < M; l++){\n                  swap(a[i][l], a[k][l]);\n               }\n               break;\n            }\n         }\n         if(a[i][j]){\n            r++;\n            for(ll k = i + 1; k < N; k++){\n               for(ll l = j; l < M; l++){\n                  a[k][l] = a[k][l] ^ a[i][l];\n               }\n            }\n            i++; j++;\n         }\n         else{\n            j++;\n         }\n      }\n   }\n   return r;\n}\n\nint main(){\n   cin >> N >> M;\n   REP(i, N)REP(j, M) cin >> a[i][j];\n   ll r = rnk();\n   cout << residue(pow(2ll, M + N - 1, MOD) - pow(2ll, M + N - 1 - r, MOD), MOD) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\n\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\n\ntemplate <typename T> constexpr bool chmax(T &a, const T b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nconstexpr int MAX_ROW = 510;\nconstexpr int MAX_COL = 510;\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL> &operator[](const int &i) { return val[i]; }\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    rep(col, A.W) {\n        if(is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        rep(row, A.H) {\n            if(A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if(pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        rep(row, A.H) if(row != rank && A[row][col]) A[row] ^= A[rank];\n        rank++;\n    }\n    return rank;\n}\n\ntemplate <typename T> T mpow(T x, T n) {\n    T ret = 1;\n    while(n > 0) {\n        if(n & 1) (ret *= x) %= Mod;\n        (x *= x) %= Mod;\n        n = n >> 1;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n, m;\n    cin >> n >> m;\n    BitMatrix A(n, m);\n    rep(i, n) rep(j, m) {\n        bool a;\n        cin >> a;\n        A[i][j] = a;\n    }\n    int r = GaussJordan(A);\n\n    cout << (mpow<ll>(2, n + m - 1) - mpow<ll>(2, n + m - r - 1) + Mod) % Mod\n         << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T> LLI power(T n, T p, T m){if(p==0) return 1LL; if(p==1) return n; LLI k = power(n, p/2, m); return ((k*k)%m*(p%2?n:1))%m;}\n\nconst LLI mod = 998244353;\nconst double eps = 1e-9;\n\nint rank_bit_matrix(vector<vector<int>> mat){\n  int n = mat.size();\n  int m = mat[0].size();\n\n  int r = 0;\n  \n  REP(j,m){\n    int p = -1;\n    FOR(i,r,n){\n      if(mat[i][j]){\n\tp = i;\n\tbreak;\n      }\n    }\n    \n    if(p == -1) continue;\n\n    swap(mat[p], mat[r]);\n    \n    REP(i,n) if(i != r && mat[i][j]) REP(k,m) mat[i][k] ^= mat[r][k];\n    ++r;\n  }\n\n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  while(cin >> N >> M){\n    vector<vector<int>> a(N, vector<int>(M)); cin >> a;\n    int r = rank_bit_matrix(a);\n    dump(r);\n    \n    LLI ans = (power(2LL,(LLI)(N+M-1),mod) - power(2LL,(LLI)(N+M-r-1),mod) + mod) % mod;\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define mod(x) ((x % MOD) + MOD) % MOD\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define LB(c,x) (int)(lower_bound(ALL(c),x)-(c).begin())\n#define UB(c,x) (int)(upper_bound(ALL(c),x)-(c).begin())\n#define COUNT(c,x) (UB(c,x)-LB(c,x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DEL(v) decltype(v)().swap(v)\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\ntemplate<typename T1, typename T2> using P = pair<T1,T2>;\ntemplate<typename T> using V = vector<T>;\nstruct edge { int from, to; int cost; };\nbool operator< (const edge &edge1, const edge &edge2) { return edge1.cost < edge2.cost; };\nconst int INF = 1e18;\nconst int MOD = 998244353;\n\ntemplate<typename T> ostream& operator << (ostream& s, const V<T>& v) {\n   s << \"[\";\n   for (int i = 0; i < v.size(); i++) { s << v[i]; if (i < v.size() - 1) s << \" \"; }\n   s << \"]\";\n   return s;\n}\ntemplate<typename T1, typename T2> ostream& operator << (ostream& s, const P<T1,T2>& p) {\n   s << \"(\" << p.first << \",\" << p.second << \")\";\n   return s;\n}\n\nstruct GF2 {\n   int n;\n   GF2(int m=0) { n = m; }\n   const bool operator==(int m) const { return n == (m%2); }\n   const bool operator!=(int m) const { return n != (m%2); }\n   const bool operator>(const GF2 a) const { return n > a.n; }\n   const GF2 operator+(const GF2& a) const { return GF2{n ^ a.n}; }\n   const GF2 operator-(const GF2& a) const { return GF2{n ^ a.n}; }\n   const GF2 operator*(const GF2& a) const { return GF2{n * a.n}; }\n   const GF2 operator/(const GF2& a) const { if (a.n == 0) throw \"Can't devide by 0\"; return GF2{n / a.n}; }\n   GF2& operator+=(const GF2& a) { n ^= a.n; return *this; }\n   GF2& operator-=(const GF2& a) { n ^= a.n; return *this; }\n   GF2& operator*=(const GF2& a) { n *= a.n; return *this; }\n   GF2& operator/=(const GF2& a) { if (a.n == 0) throw \"Can't devide by 0\"; n /= a.n; return *this; }\n   GF2& operator=(int m) { n = m; return *this; }\n};\nconst GF2 abs(GF2 x) { return x; }\nostream& operator << (ostream& s, const GF2& a) { s << a.n; return s; }\n\ntemplate<typename T> class Matrix\n{\n   private:\n      vector<vector<T>> val;\n      int m, n;\n   public:\n      Matrix(int a=0, int b=0) : m(a), n(b) {\n         val.resize(m, vector<T>(n));\n      }\n      Matrix(const vector<vector<T>>& vec) : m(vec.size()), n(vec[0].size()) {\n         val.resize(m, vector<T>(n));\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] = vec[i][j];\n      }\n      ~Matrix() {\n         vector<vector<T>>().swap(val);\n      }\n      Matrix& operator=(const Matrix& mat) {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be substituted\"; }\n         catch (const char* e) { cerr << e << endl; }\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] = mat.val[i][j];\n         return *this;\n      }\n      T operator()(int i, int j) {\n         try { if (i < 0 || m <= i || j < 0 || n <= j) throw \"Bad access\"; }\n         catch (const char* e) { cerr << e << endl; }\n         return val[i][j];\n      }\n      const Matrix operator+(const Matrix& mat) const {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[i][j] = val[i][j] + mat.val[i][j];\n         return tmp;\n      }\n      const Matrix operator-(const Matrix& mat) const {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[i][j] = val[i][j] - mat.val[i][j];\n         return tmp;\n      }\n      const Matrix operator*(const Matrix& mat) const {\n         try { if (n != mat.m) throw \"Matrix can't be producted\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, mat.n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < mat.n; j++) for (int k = 0; k < n; k++) tmp.val[i][j] += val[i][k]*mat.val[k][j];\n         return tmp;\n      }\n      Matrix& operator+=(const Matrix& mat) {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] += mat.val[i][j];\n         return *this;\n      }\n      Matrix& operator-=(const Matrix& mat) {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] -= mat.val[i][j];\n         return *this;\n      }\n      Matrix operator*=(const Matrix& mat) {\n         try { if (n != mat.m) throw \"Matrix can't be producted\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, mat.n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < mat.n; j++) for (int k = 0; k < n; k++) tmp.val[i][j] += val[i][k]*mat.val[k][j];\n         n = mat.n;\n         val.resize(m, vector<T>(n));\n         *this = tmp;\n         return *this;\n      }\n      Matrix transpose() const {\n         Matrix tmp(n, m);\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[j][i] = val[i][j];\n         return tmp;\n      }\n      Matrix gaussElimination() const {\n         Matrix<T> A(val);\n         int col = 0;\n         for (int i = 0; i < m; i++) {\n            int pivot = i;\n            while (true) {\n               for (int j = i+1; j < m; j++) if (abs(A.val[j][col]) > abs(A.val[pivot][col])) pivot = j;\n               if (A.val[pivot][col] == 0) {\n                  col++;\n                  if (col == n) return A;\n               } else break;\n            }\n            swap(A.val[i], A.val[pivot]);\n            for (int j = i+1; j < m; j++) {\n               T ratio = A.val[j][col] / A.val[i][col];\n               for (int k = col; k < n; k++) A.val[j][k] -= A.val[i][k] * ratio;\n            }\n            col++;\n         }\n         return A;\n      }\n      int rank() const {\n         Matrix A = gaussElimination();\n         int j = 0;\n         for (int i = 0; i < m; i++) {\n            while (A.val[i][j] == 0) {\n               j++; if (j == n) return i;\n            }\n         }\n         return m;\n      }\n      ostream& info(ostream& s) const {\n         s << endl << \"[\";\n         for (int i = 0; i < m; i++) {\n            s << \"[\";\n            for (int j = 0; j < n; j++) {\n               s << val[i][j];\n               if (j < n-1) s << \" \";\n            }\n            s << \"]\"; if (i < m-1) s << endl;\n         }\n         s << \"]\";\n         return s;\n      }\n};\ntemplate<typename T> ostream& operator<<(ostream& s, const Matrix<T>& mat) {\n   mat.info(s);\n   return s;\n}\n\ntemplate<typename T> class SquareMatrix : public Matrix<T>\n{\n   private:\n      int num;\n   public:\n      SquareMatrix(int a=0) : Matrix<T>(a, a) { num = a; }\n      SquareMatrix(const vector<vector<T>>& vec) : num(vec.size()), Matrix<T>(vec) { \n         try { if (vec.size() != vec[0].size()) throw \"Matrix isn't square matrix\"; }\n         catch (const char* e) { cerr << e << endl; }\n      }\n      T determinant() {\n         Matrix<T> A = this->gaussElimination();\n         T det = 1;\n         for (int i = 0; i < num; i++) det *= A(i,i);\n         return det;\n      }\n};\n\n\nint powM(int x, int n) {\n   int res = 1;\n   while (n > 0) {\n      if ((n & 1) == 1) {\n         res = mod(res * x);\n      }\n      x = mod(x * x);\n      n >>= 1;\n   }\n   return res;\n}\n\nsigned main()\n{\n   int n, m; cin >> n >> m;\n   V<V<GF2>> a(n, V<GF2>(m));\n   REP(i, n) {\n      REP(j, m) {\n         int b; cin >> b;\n         a[i][j] = b;\n      }\n   }\n\n   Matrix<GF2> A(a);\n\n   int rank = A.rank();\n\n   int ans = mod(powM(2,n+m-1) - powM(2,n+m-rank-1));\n   cout << ans << endl;\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define maxn 330\nusing namespace std;\ninline int getint(){\n    char c=getchar();int x=0;bool p=0;\n    while((c>'9'||c<'0')&&c!='-')c=getchar();\n    if(c=='-')p=1,c=getchar();\n    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();\n    if(p)x=-x;return x;\n}\ninline int qpower(int x,int k){\n\tint ans=1;\n\tfor(;k;k>>=1,x=1ll*x*x)if(k&1)ans=1ll*ans*x%mod;\n\treturn ans;\n}\nint n,m,cnt,a[maxn][maxn],b[maxn][maxn];\nint main(){\n\tmemset(b,0,sizeof(b));\n\tn=getint(),m=getint();\n\tfor(int i=1;i<=n;++i)\n\tfor(int j=1;j<=m;++j)\n\ta[i][j]=getint();\n\tcnt=0;\n\tfor(int i=1;i<=n;++i)\n\tfor(int j=1;j<=m;++j)\n\tif(a[i][j]){\n\t\tif(!b[j][j]){\n\t\t\t++cnt;\n\t\t\tfor(int k=j;k<=m;++k)b[j][k]=a[i][k];\n\t\t\tbreak;\n\t\t}\n\t\telse for(int k=j;k<=m;++k)a[i][k]^=b[j][k];\n\t}\n\tint ans=qpower(2,n)-qpower(2,n-cnt);\n\tif(ans<0)ans+=mod;\n\tans=1ll*ans*qpower(2,m-1)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int ll;\ntypedef long double ld;\ntypedef pair<ll,ll> p2;\nll a[305][305],p[1005],hell=998244353;\nvector<ll> basis[305];\nll insert(vector<ll> &v){\n\tll n=ll(v.size());\n\tfor(ll i=0;i<n;i++){\n\t\tif(!v[i])\n\t\tcontinue;\n\t\tif(basis[i].empty()){\n\t\t\tbasis[i]=v;\n\t\t\treturn 1;\n\t\t}\n\t\tfor(ll j=0;j<n;j++)\n\t\tv[j]^=basis[i][j];\n\t}\n\treturn 0;\n}\nvoid solve(){\n\tll n,m,res=0;\n\tcin>>n>>m;\n\tfor(ll i=0;i<n;i++)\n\tfor(ll j=0;j<m;j++)\n\tcin>>a[i][j];\n\tfor(ll j=0;j<m;j++){\n\t\tvector<ll> v;\n\t\tfor(ll i=0;i<n;i++)\n\t\tv.push_back(a[i][j]);\n\t\tres+=insert(v);\n\t}\n\tll ans=(p[n+m-1]-p[n+m-res-1])%hell;\n\tif(ans<0)\n\tans+=hell;\n\tcout<<ans;\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    p[0]=1;\n    for(ll i=1;i<1005;i++)\n    p[i]=(2*p[i-1])%hell;\n    ll qc=1;\n    //cin>>qc;\n    for(ll i=1;i<=qc;i++)\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int MN = 305, P = 998244353;\n\ntypedef std::bitset<MN> bst;\n\nbst val[MN], vec[MN];\n\nint n, m, cnt;\n\ninline int fpw(int x, int k) {\n\tint res = 1;\n\tfor (; k; k >>= 1, x = (ll) x * x % P)\n\t\tif (k & 1) res = (ll) res * x % P;\n\treturn res;\n}\n\ninline int read() {\n\tint x; bool f; char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tval[i][j] = read();\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = m; j--; )\n\t\t\tif (val[i][j]) {\n\t\t\t\tif (vec[j].count()) val[i] ^= vec[j];\n\t\t\t\telse {\n\t\t\t\t\t++cnt;\n\t\t\t\t\tvec[j] = val[i];\n\t\t\t\t\tfor (int k = j; k--; )\n\t\t\t\t\t\tif (vec[j][k]) vec[j] ^= vec[k];\n\t\t\t\t\tfor (int k = j; ++k < m; )\n\t\t\t\t\t\tif (vec[k][j]) vec[k] ^= vec[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\tprintf(\"%lld\\n\", (ll)fpw(2, m - 1) * (fpw(2, n) - fpw(2, n - cnt) + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\t//ans= (2^(n+m) - 2^(n+m-rank))/2\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h,i,j,n,m;cin>>n>>m;\n\tvector<vector<int>>mat(n,vector<int>(m));\n\tint x=0;//rank\n\tvector<int>kara(m);\n\tfor(h=0;h<n;h++){\n\t\tfor(j=0;j<m;j++){cin>>mat[x][j];}\n\t\tfor(i=0;i<x;i++){\n\t\t\tint ifp=0;\n\t\t\twhile(ifp<m&&mat[i][ifp]==0){ifp++;}\n\t\t\tif(ifp!=m&&mat[x][ifp]){\n\t\t\t\tfor(j=0;j<m;j++){mat[x][j]^=mat[i][j];}\n\t\t\t}\n\t\t}\n\t\tif(mat[x]==kara){continue;}\n\t\t\n\t\tint bas=x;\n\t\twhile(bas>0&&mat[bas]>mat[bas-1]){swap(mat[bas],mat[bas-1]);bas--;}\n\t\tx++;\n\t\t/*cerr<<\"de\"<<endl;\n\t\tfor(i=0;i<x;i++){\n\t\t\tfor(j=0;j<m;j++){\n\t\t\t\tcerr<<mat[i][j];\n\t\t\t}cerr<<endl;\n\t\t}*/\n\t}\n\tllint ans=1;\n\tfor(i=0;i<x;i++){ans*=2;ans%=mod;}\n\tans--;\n\tfor(i=1;i<n+m-x;i++){ans*=2;ans%=mod;}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=998244353;\nconst long double eps=1e-60;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\n\nint main(){\n    ll n,m;cin>>n>>m;\n    vector<bitset<300>> v(n);\n    rep(i,n){\n        rep(j,m){\n            int a;cin>>a;\n            if(a)v[i].set(j);\n        }\n    }\n    ll cnt=n;\n    vb used(n,false);\n    rep(i,300){\n        ll k=-1;\n        rep(j,n)if(!used[j]&&v[j].test(i)){\n            if(k==-1){\n                k=j;used[j]=true;break;\n            }\n            else v[j]^=v[k];\n        }\n        if(k!=-1)cnt--;\n    }\n    out((modpow(2,n)-modpow(2,cnt)+mod)*modpow(2,m-1)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int N=300+7;\nconst int MOD=998244353;\n\nint add(int a,int b)\n{\n        a+=b;\n        if(a>=MOD)\n        {\n                a-=MOD;\n        }\n        if(a<0)\n        {\n                a+=MOD;\n        }\n        return a;\n}\n\nint mul(int a,int b)\n{\n        return a*(long long)b%MOD;\n}\n\nint expow(int a,int b)\n{\n        int res=1;\n        while(b)\n        {\n                if(b&1)\n                {\n                        res=mul(res,a);\n                }\n                a=mul(a,a);\n                b>>=1;\n        }\n        return res;\n}\n\nint inv(int n)\n{\n        return expow(n,MOD-2);\n}\n\nint fact[N];\n\nint comb(int n,int k)\n{\n        int x=fact[n];\n        int y=mul(fact[k],fact[n-k]);\n        y=expow(y,MOD-2);\n        return mul(x,y);\n}\n\nint n,m;\n\nint mll;\n\nmap<vector<int>,int>freq;\n\nint main()\n{\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n       // freopen(\"input\",\"r\",stdin);\n       // freopen(\"output\",\"w\",stdout);\n        fact[0]=1;\n        for(int i=1;i<N;i++)\n        {\n                fact[i]=mul(fact[i-1],i);\n        }\n        int cnt0=0;\n        cin>>n>>m;\n        mll=expow(2,m);\n        for(int i=1;i<=n;i++)\n        {\n                vector<int>ugar;\n                bool g=0;\n                for(int j=1;j<=m;j++)\n                {\n                        int x;\n                        cin>>x;\n                        ugar.push_back(x);\n                        if(x)\n                        {\n                                g=1;\n                        }\n                }\n                if(g==0) cnt0++;\n                freq[ugar]++;\n        }\n        int tot=expow(2,n);\n        int sum=0;\n        for(auto &it:freq)\n        {\n                int cnt=it.second;\n                sum+=cnt-1;\n        }\n       /// cout<<cnt0<<\"\\n\";\n        if(cnt0>0) sum++;\n        int lft=add(tot,-expow(2,sum));\n      ///  cout<<\"=\"<<lft<<\"\\n\";\n        int res=mul(lft,mll);\n       /// cout<<tot-lft<<\"\\n\";\n        res=mul(res,inv(2));\n        cout<<res<<\"\\n\";\n        return 0;\n        cout<<\"A: \"<<res<<\"\\n\";\n        return 0;\n}\n/**\n\n**/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...) 0\n#endif\n\ntemplate <ll mod>\nstruct modular {\n    ll value;\n    modular(ll x = 0) {\n        value = x % mod;\n        if (value < 0) value += mod;\n    }\n\n    modular& operator+=(modular other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(modular other) {\n        if ((value -= other.value) < 0) value += mod;\n        return *this;\n    }\n    modular& operator*=(modular other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(modular other) {\n        ll a = 0, b = 1, c = other.value, m = mod;\n        while (c != 0) {\n            ll t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    modular& operator^=(modular other) {\n        ll r = 1, x = value, n = other.value;\n        while (n > 0) {\n            if (n & 1) r = r * x % mod;\n            x = x * x % mod;\n            n >>= 1;\n        }\n        value = r;\n        return *this;\n    }\n    modular operator+(modular rhs) {\n        return modular(*this) += rhs;\n    }\n    modular operator-(modular rhs) {\n        return modular(*this) -= rhs;\n    }\n    modular operator*(modular rhs) {\n        return modular(*this) *= rhs;\n    }\n    modular operator/(modular rhs) {\n        return modular(*this) /= rhs;\n    }\n    modular operator^(modular rhs) {\n        return modular(*this) ^= rhs;\n    }\n    bool operator==(modular rhs) {\n        return value == rhs.value;\n    };\n    bool operator!=(modular rhs) {\n        return value != rhs.value;\n    };\n    bool operator<(modular rhs) {\n        return value < rhs.value;\n    }\n    bool operator>(modular rhs) {\n        return value > rhs.value;\n    }\n};\ntemplate <ll mod>\nstring to_string(modular<mod> x) {\n    return to_string(x.value);\n}\ntemplate <ll mod>\nostream& operator<<(ostream& stream, modular<mod> x) {\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream << x.value;\n}\ntemplate <ll mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream;\n}\nconst ll mod = 998244353;\nusing mint = modular<mod>;\n\nmint abs(mint a) {\n    return a.value;\n}\n\ntemplate <class T>\nstruct matrix {\n    vector<vector<T>> a;\n    matrix(int height, int width)\n        : a(height, vector<T>(width)) {}\n    matrix(int n)\n        : a(n, vector<T>(n)) {}\n    int size() {\n        return a.size();\n    }\n    inline vector<T>& operator[](int i) {\n        return a[i];\n    }\n};\ntemplate <class T>\nmatrix<T> operator*(matrix<T> a, matrix<T> b) {\n    matrix<T> r(a.size(), b[0].size());\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < b[0].size(); j++)\n            for (int k = 0; k < b.size(); k++) r[i][j] += a[i][k] * b[k][j];\n    return r;\n}\ntemplate <class T>\nmatrix<T> operator+(matrix<T> a, matrix<T> b) {\n    matrix<T> r(a.size(), a[0].size());\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++) r[i][j] = a[i][j] + b[i][j];\n    return r;\n}\ntemplate <class T>\nmatrix<T> operator-(matrix<T> a, matrix<T> b) {\n    matrix<T> r(a.size(), a[0].size());\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++) r[i][j] = a[i][j] - a[i][j];\n    return r;\n}\ntemplate <class T>\nmatrix<T> operator^(matrix<T> a, ll n) {\n    matrix<T> r(a.size());\n    for (int i = 0; i < a.size(); i++) r[i][i] = 1;\n    while (n > 0) {\n        if (n & 1) r = r * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate <class T>\nbool operator==(matrix<T> a, matrix<T> b) {\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++)\n            if (a[i][j] != b[i][j]) return false;\n    return true;\n}\ntemplate <class T>\nbool operator!=(matrix<T> a, matrix<T> b) {\n    return !(a == b);\n}\ntemplate <class T>\nvoid print(matrix<T> a) {\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++)\n            cout << a[i][j] << ((j != a[0].size() - 1) ? ' ' : '\\n');\n}\ntemplate <class T>\nstring to_string(matrix<T> a) {\n    return to_string(a.a);\n}\ntemplate <class T>\nint gaussian_elimination(matrix<T>& a, bool is_extended = false) {\n    int m = a.size(), n = a[0].size();\n    int rank = 0;\n    T det = 1;\n    for (int col = 0; col < n; ++col) {\n        if (is_extended && col == n - 1) break;\n        int pivot = -1;\n        T mx = 1e-5;\n        for (int row = rank; row < m; ++row) {\n            if (abs(a[row][col]) > mx) {\n                mx = abs(a[row][col]);\n                pivot = row;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(a[pivot], a[rank]);\n        auto fac = a[rank][col];\n        det *= fac;\n        for (int col2 = 0; col2 < n; col2++) a[rank][col2] /= fac;\n        for (int row = 0; row < m; row++) {\n            if (row != rank && abs(a[row][col]) > 1e-9) {\n                auto fac = a[row][col];\n                for (int col2 = 0; col2 < n; col2++) {\n                    a[row][col2] -= a[rank][col2] * fac;\n                    a[row][col2] %= 2;\n                    if (a[row][col2] < 0) a[row][col2] += 2;\n                }\n            }\n        }\n        rank++;\n    }\n    return rank;\n    // return (m == rank ? det : 0);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    matrix<int> a(n, m);\n    rep(i, 0, n) rep(j, 0, m) cin >> a[i][j];\n    int r = gaussian_elimination(a);\n    debug(r);\n    mint ans = (mint)2 ^ (mint)(n + m - 1);\n    ans -= (mint)2 ^ (mint)(n + m - r - 1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  template<class Int> ModInt(Int x) : v(x >= 0 ? x % P : -x % P ? P - -x % P : 0) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool) *this; }\n  M operator*(M rhs) const { return M(*this) *= rhs; }\n  M operator/(M rhs) const { return M(*this) /= rhs; }\n  M operator+(M rhs) const { return M(*this) += rhs; }\n  M operator-(M rhs) const { return M(*this) -= rhs; }\n  bool operator==(M rhs) const { return v == rhs.v; }\n  bool operator!=(M rhs) const { return !(*this == rhs); }\n  M& operator*=(M rhs) { v = (unsigned long long) v * rhs.v % P; return *this; }\n  M& operator/=(M rhs) { return *this *= rhs.inv(); }\n  M& operator+=(M rhs) { v = rhs.v < P - v ? v + rhs.v : v - (P - rhs.v); return *this; }\n  M& operator-=(M rhs) { v = rhs.v <= v ? v - rhs.v : v + (P - rhs.v); return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  template<class Int> M pow(Int n) const {\n    n = n >= 0 ? n % (P - 1) : P - 1 - -n % (P - 1);\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  template<class Int> friend M operator*(Int lhs, M rhs) { return M(lhs) *= rhs; }\n  template<class Int> friend M operator/(Int lhs, M rhs) { return M(lhs) /= rhs; }\n  template<class Int> friend M operator+(Int lhs, M rhs) { return M(lhs) += rhs; }\n  template<class Int> friend M operator-(Int lhs, M rhs) { return M(lhs) -= rhs; }\n  friend ostream& operator<<(ostream& os, M rhs) { return os << rhs.v; }\n  friend istream& operator>>(istream& is, M& rhs) { lint x; is >> x; rhs = x; return is; }\n  template<class Int> friend bool operator==(Int lhs, M rhs) { return M(lhs) == rhs; }\n  template<class Int> friend bool operator!=(Int lhs, M rhs) { return !(lhs == rhs); }\n};\nusing Mint = ModInt<998244353>;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  V< bitset<300> > a(n);\n  for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {\n    int x; cin >> x;\n    a[i][j] = x;\n  }\n  int r = 0;\n  for (int j = 0; j < m; ++j) {\n    for (int i = r + 1; i < n; ++i) if (a[i][j]) {\n      swap(a[r], a[i]);\n      break;\n    }\n    if (!a[r][j]) continue;\n    for (int i = 0; i < n; ++i) if (i != r and a[i][j]) {\n      a[i] ^= a[r];\n    }\n    if (++r == n) break;\n  }\n  Mint res = Mint(2).pow(n + m - 1) * (1 - Mint(2).pow(-r));\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T> LLI power(T n, T p, T m){if(p==0) return 1LL; if(p==1) return n; LLI k = power(n, p/2, m); return ((k*k)%m*(p%2?n:1))%m;}\n\nconst LLI mod = 998244353;\n\nclass Rational{\npublic:\n  int64_t nume, deno;\n  Rational(): nume(0), deno(1){}\n  Rational(int64_t num): nume(num), deno(1){} \n  Rational(int64_t num, int64_t den){\n    int64_t g = gcd(num,den);\n    nume = num/g;\n    deno = den/g;\n  }\n  Rational& operator+=(const Rational &a);\n  Rational& operator-=(const Rational &a);\n  Rational& operator*=(const Rational &a);\n  Rational& operator/=(const Rational &a);\n};\n\nostream& operator<<(ostream &os, const Rational &r){os << r.nume << \"/\" << r.deno; return os;}\nistream& operator>>(istream &is, Rational &r){\n  int64_t n; is >> n; r = n;\n  return is;\n}\n\nRational operator-(const Rational &a){return Rational(-a.nume, a.deno);}\n\nRational operator+(const Rational &a, const Rational &b){int64_t l = lcm(a.deno,b.deno); return Rational(a.nume*l/a.deno + b.nume*l/b.deno, l);}\nRational operator-(const Rational &a, const Rational &b){int64_t l = lcm(a.deno,b.deno); return Rational(a.nume*l/a.deno - b.nume*l/b.deno, l);}\nRational operator*(const Rational &a, const Rational &b){return Rational(a.nume*b.nume, a.deno*b.deno);}\nRational operator/(const Rational &a, const Rational &b){return Rational(a.nume*b.deno, a.deno*b.nume);}\n\nbool operator==(const Rational &a, const Rational &b){return a.nume == b.nume && a.deno == b.deno;}\nbool operator!=(const Rational &a, const Rational &b){return !(a==b);}\nbool operator<(const Rational &a, const Rational &b){return a.nume*b.deno < b.nume*a.deno;}\nbool operator<=(const Rational &a, const Rational &b){return a.nume*b.deno <= b.nume*a.deno;}\nbool operator>(const Rational &a, const Rational &b){return !(a<=b);}\nbool operator>=(const Rational &a, const Rational &b){return !(a<b);}\n\nRational& Rational::operator+=(const Rational &a){*this = *this+a; return *this;}\nRational& Rational::operator-=(const Rational &a){*this = *this-a; return *this;}\nRational& Rational::operator*=(const Rational &a){*this = *this*a; return *this;}\nRational& Rational::operator/=(const Rational &a){*this = *this/a; return *this;}\n\n\ntemplate <typename T> int rank_matrix(vector<vector<T>> mat){\n\n  int n = mat.size();\n  int m = mat[0].size();\n  int p = 0;\n  \n\n  REP(i,n){\n    if(p>=m) break;    \n\n    bool b = true;\n    FOR(j,i,n) if(mat[j][p] != 0) b = false;\n\n    if(b){\n      ++p;\n      continue;\n    }\n\n    if(mat[i][p] == 0){\n      FOR(j,i+1,n){\n\tif(mat[j][p] != 0){\n\t  swap(mat[i], mat[j]);\n\t  break;\n\t}\n      }\n    }\n    \n    FOR(j,i+1,n){\n      T t = mat[j][p] / mat[i][p];\n      REP(k,m) mat[j][k] -= mat[i][k] * t;\n    }\n  }\n\n  int r = 0;\n  REP(i,n){\n    REP(j,m){\n      if(mat[i][j] != 0){\n\t++r;\n\tbreak;\n      }\n    }\n  }\n\n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  while(cin >> N >> M){\n    vector<vector<Rational>> a(N, vector<Rational>(M)); cin >> a;\n    int r = rank_matrix(a);\n    \n    LLI ans = power(2LL,(LLI)(M-1),mod) * (power(2LL,(LLI)N,mod) - power(2LL,(LLI)(N-r),mod) + mod) % mod;\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t r = 0;\n    for (std::size_t c = 0; c < mat.C; c++) {\n        if (r == mat.R) { break; }\n        std::size_t piv = r;\n        for (; piv < mat.R and mat[piv][c] == 0; piv++) {}\n        if (piv == mat.R) { continue; }\n        std::swap(mat[r], mat[piv]);\n        const T p = mat[r][c];\n        for (std::size_t i = r; i < mat.R; i++) { mat[i][c] /= p; }\n        for (std::size_t j = 0; j < mat.C; j++) {\n            if (j == c) { continue; }\n            const T p = mat[r][j];\n            for (std::size_t i = 0; i < mat.R; i++) { mat[i][j] -= mat[i][c] * p; }\n        }\n        r++;\n    }\n    return r;\n}\nconstexpr int MOD = 998244353;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<int> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    auto pow = [](auto&& self, const long long p, const std::size_t n) -> long long { return n == 0 ? 1LL : n % 2 == 1 ? self(self, p, n - 1) * p % MOD : self(self, p * p % MOD, n / 2); };\n    std::cout << (pow(pow, 2, N + M - 1) - pow(pow, 2, N + M - R - 1) + MOD) % MOD << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG  // gcc\n    #define _LIBCPP_DEBUG 0 // clang\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define _GLIBCXX_DEBUG\n    // #define _LIBCPP_DEBUG 0\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check() { char bufc; if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"\\n----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\npublic:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(), last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n/* dump definition start */\n#ifdef LOCAL\n    #define dump(...) debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\", dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\n/* dump definition end */\n\n/* function utility start */\ntemplate <class T, class... types> T read(types... args) noexcept { T obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = pair<i32, i32>; using pll = pair<i64, i64>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using rheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\n/* using alias end */\n\n/* library start */\n\n#ifndef Modint_hpp\n#define Modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    friend constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    constexpr modint(bool x = false) noexcept : val{x} {}\n    constexpr modint(int x) noexcept : val(x & 1) {}\n    constexpr modint(long long x) noexcept : val(x & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val &= other.val, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { assert(other.val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator-(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator*(const modint &other) const noexcept { return val && other.val; }\n    constexpr modint operator/(const modint &other) const noexcept { assert(other.val); return *this; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { assert(y.val); return x & 1 ? y : modint<2>{0}; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // Modint_hpp\n\n#ifndef MATRIX_HPP\n#define MATRIX_HPP\n// #include <iostream>\n// K must be a field.\ntemplate <class K>\nclass matrix\n{\n    std::vector<std::vector<K>> mat;\n    friend std::istream &operator>>(std::istream &is, matrix &x)\n    {\n        size_t h = x.height(), w = x.width();\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j) is >> x[i][j];\n        }\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const matrix &x)\n    {\n        size_t h = x.height(), w = x.width();\n        for(size_t i = 0; i < h; ++i)\n        {\n            if(i) os << \"\\n\";\n            for(size_t j = 0; j < w; ++j) os << (j ? \" \" : \"\") << x.mat[i][j];\n        }\n        return os;\n    }\n    friend matrix pow(matrix x, long long n)\n    {\n        assert(x.is_square());\n        matrix res = identity(x.height());\n        while(n)\n        {\n            if(n & 1) res *= x;\n            x *= x, n >>= 1;\n        }\n        return res;\n    }\n    friend matrix inverse(const matrix &x)\n    {\n        assert(x.is_square());\n        size_t n = x.height();\n        matrix ext_x(x), e(identity(n)), res(n);\n        for(size_t i = 0; i < n; ++i) ext_x[i].insert(end(ext_x[i]), begin(e[i]), end(e[i]));\n        ext_x = ext_x.row_canonical_form();\n        for(size_t i = 0; i < n; ++i)\n        {\n            if(std::vector<K>(begin(ext_x[i]), begin(ext_x[i]) + n) != e[i]) return matrix();\n            res[i] = std::vector<K>(begin(ext_x[i]) + n, end(ext_x[i]));\n        }\n        return res;\n    }\npublic:\n    matrix() {}\n    matrix(size_t n) { assign(n, n);}\n    matrix(size_t h, size_t w) { assign(h, w); }\n    matrix(const matrix &x) : mat(x.mat) {}\n    matrix(const std::vector<std::vector<K>> _mat) : mat(_mat) {}\n    size_t height() const { return mat.size(); }\n    size_t width() const { return mat.empty() ? 0 : mat[0].size(); }\n    bool is_square() const { return height() == width(); }\n    void resize(size_t h, size_t w, const K v = K(0)) { mat.resize(h, std::vector<K>(w, v)); }\n    void assign(size_t h, size_t w, const K v = K()) { mat.assign(h, std::vector<K>(w, v)); }\n    std::vector<K> &operator[](const size_t i) { return mat[i]; }\n    static matrix identity(size_t n)\n    {\n        matrix ret(n, n);\n        for(size_t i = 0; i < n; ++i) ret[i][i] = K(1);\n        return ret;\n    }\n    matrix operator-() const\n    {\n        size_t h = height(), w = width();\n        matrix res(*this);\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                res[i][j] = -mat[i][j];\n            }\n        }\n        return res;\n    }\n    matrix operator&(const matrix &x) const { return matrix(*this) &= x; }\n    matrix operator|(const matrix &x) const { return matrix(*this) |= x; }\n    matrix operator^(const matrix &x) const { return matrix(*this) ^= x; }\n    matrix operator+(const matrix &x) const { return matrix(*this) += x; }\n    matrix operator-(const matrix &x) const { return matrix(*this) -= x; }\n    matrix operator*(const matrix &x) const { return matrix(*this) *= x; }\n    matrix &operator&=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                mat[i][j] &= x.mat[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator|=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                mat[i][j] |= x.mat[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator^=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                mat[i][j] ^= x.mat[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator+=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                mat[i][j] += x.mat[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator-=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                mat[i][j] -= x.mat[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator*=(const matrix &x)\n    {\n        size_t l = height(), m = width(), n = x.width();\n        assert(m == x.height());\n        matrix res(l, n);\n        for(size_t i = 0; i < l; ++i)\n        {\n            for(size_t j = 0; j < m; ++j)\n            {\n                for(size_t k = 0; k < n; ++k)\n                {\n                    res[i][k] += mat[i][j] * x.mat[j][k];\n                }\n            }\n        }\n        return *this = res;\n    }\n    std::vector<size_t> row_canonicalize()\n    {\n        std::vector<size_t> pivots;\n        const size_t h = height(), w = width();\n        for(size_t j = 0, rank = 0; j != w; ++j)\n        {\n            bool ispiv = false;\n            for(size_t i = rank; i != h; ++i)\n            {\n                if(mat[i][j] != K{})\n                {\n                    if(ispiv)\n                    {\n                        const K r = -mat[i][j];\n                        for(size_t k = j; k != w; ++k) mat[i][k] += mat[rank][k] * r;\n                    }\n                    else\n                    {\n                        swap(mat[rank], mat[i]);\n                        K r = mat[rank][j];\n                        for(size_t k = j; k != w; ++k) mat[rank][k] /= r;\n                        for(size_t k = 0; k != rank; ++k)\n                        {\n                            r = -mat[k][j];\n                            for(size_t l = j; l != w; ++l) mat[k][l] += mat[rank][l] * r;\n                        }\n                        ispiv = true;\n                    }\n                }\n            }\n            if(ispiv)\n            {\n                ++rank;\n                pivots.emplace_back(j);\n            }\n        }\n        return pivots;\n    }\n    K determinant() const\n    {\n        matrix<K> x(*this);\n        assert(is_square());\n        size_t n = height();\n        K res(1);\n        for(size_t j = 0; j < n; ++j)\n        {\n            bool ispiv = false;\n            for(size_t i = j; i < n; ++i)\n            {\n                if(x[i][j] != K{})\n                {\n                    if(ispiv)\n                    {\n                        const K r = -x[i][j];\n                        for(size_t k = j; k < n; ++k) x[i][k] += x[j][k] * r;\n                    }\n                    else\n                    {\n                        swap(x[i], x[j]);\n                        if(i != j) res = -res;\n                        const K r = x[j][j];\n                        res *= r;\n                        for(size_t k = j; k < n; ++k) x[j][k] /= r;\n                        ispiv = true;\n                    }\n                }\n            }\n            if(!ispiv) return K(0);\n        }\n        return res;\n    }\n};\n#endif\n\n/* library end */\n\n/* The main code follows. */\n\nusing mint=modint<998244353>;\n\nstruct solver\n{\n    solver()\n    {\n        input(int,h);\n        input(int,w);\n        input(matrix<modint<2>>,a,h,w);\n        int rank=a.row_canonicalize().size();\n        int kdim=w-rank;\n        cout << mint::pow(2,h)*(mint::pow(2,w-1)-mint::pow(2,kdim-1)) << \"\\n\";\n    }\n}; // struct solver\n\nint main(int argc, char *argv[])\n{\n    u32 t; // loop count\n#ifdef LOCAL\n    t = 1;\n#else\n    t = 1; // single test case\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--)\n    {\n        solver();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint mod = 998244353;\nstring XOR(string a, string b){\n    for(int i = 0; i < b.size(); i++)\n        a[i] ^= b[i];\n    return a;\n}\nint po(int x){\n    int ans = 1;\n    for(int i = 0; i < x; i++){\n        ans = ans + ans;\n        if(ans >= mod) ans -= mod;\n    }\n    return ans;\n}\nmain(){\n    int n, m;\n    cin >> n >> m;\n    int ans = 0;\n    vector<string> v;\n    string nul = \"\";\n    for(int i = 0; i < m; i++)\n        nul += (char)0;\n    for(int i = 1; i <= n; i++){\n        string x = \"\";\n        for(int i = 0; i < m; i++){\n            int t;\n            cin >> t;\n            x += t;\n        }\n        for(int j = v.size() - 1; j >= 0; j --){\n            x = min(x, XOR(x, v[j]));\n        }\n        v.push_back(x);\n        if(x == nul) ans++;\n        sort(v.begin(), v.end());\n    }\n    cout << (po(n+m-1) - po(ans + m - 1) + mod) % mod << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MOD = 998244353;\nconst Int MAX = 1000;\nInt fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nInt COM(Int n, Int k) {\n    if (n < k || n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nInt POW(Int n, Int m) {\n    if (m == 0) return 1;\n    if (m % 2 == 0) return POW(n * n % MOD, m / 2);\n    return n * POW(n, m - 1) % MOD;\n}\nint gaussian_elimination(vector<vector<int>> &A) {\n    int N = A.size(), M = A[0].size();\n    int t = 0;\n    for (int i = 0; i < N; i++) {\n        for (; t < M; t++) {\n            for (int j = i; j < N; j++) {\n                if (A[j][t]) {\n                    swap(A[i], A[j]);\n                    break;\n                }\n            }\n            if (A[i][t]) break;\n        }\n        if (t >= M) return i;\n        for (int j = i + 1; j < N; j++) {\n            if (j != i && A[j][t]) {\n                for (int k = 0; k < M; k++) A[j][k] ^= A[i][k];\n            }\n        }\n        t++;\n    }\n    return N;\n}\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    COMinit();\n    int N, M; cin >> N >> M;\n    vector<vector<int>> A(N, vector<int>(M));\n    for (auto &row : A) for (auto &a : row) cin >> a;\n    int rank = gaussian_elimination(A);\n    Int ans = 0;\n    for (int i = 1; i <= rank; i++) {\n        int t = (i + 1) / 2;\n        ans = ans + COM(rank, i) * t % MOD * POW(2, M - t) % MOD;\n    }\n    ans %= MOD;\n    ans = ans * POW(2, N - rank) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\nclass modulo_int {\npublic:\n  static constexpr int mod = T::value;\n  static_assert(mod > 0, \"mod must be positive\");\nprivate:\n  long long value;\n  constexpr void normalize() {\n    value %= mod;\n    if (value < 0) value += mod;\n  }\npublic:\n  constexpr modulo_int(long long value_ = 0): value(value_) { normalize(); }\n  constexpr modulo_int operator - () const { return modulo_int(mod - value); }\n  constexpr modulo_int operator ~ () const { return power(mod - 2); }\n  constexpr long long operator () () const { return value; }\n  constexpr modulo_int operator + (const modulo_int &rhs) const { return modulo_int(*this) += rhs; }\n  constexpr modulo_int &operator += (const modulo_int &rhs) {\n    if ((value += rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator - (const modulo_int &rhs) const { return modulo_int(*this) -= rhs; }\n  constexpr modulo_int &operator -= (const modulo_int &rhs) {\n    if ((value += mod - rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator * (const modulo_int &rhs) const { return modulo_int(*this) *= rhs; }\n  constexpr modulo_int &operator *= (const modulo_int &rhs) {\n    (value *= rhs.value) %= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator / (const modulo_int &rhs) const { return modulo_int(*this) /= rhs; }\n  constexpr modulo_int &operator /= (const modulo_int &rhs) {\n    return (*this) *= ~rhs;\n  }\n  constexpr bool operator == (const modulo_int &rhs) const {\n    return value == rhs();\n  }\n  constexpr bool operator != (const modulo_int &rhs) const {\n    return value != rhs();\n  }\n  constexpr modulo_int power (uint64_t exp) const {\n    modulo_int result(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) result *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return result;\n  }\n  friend std::istream &operator >> (std::istream &stream, modulo_int &lhs) {\n    stream >> lhs.value;\n    lhs.normalize();\n    return stream;\n  }\n  friend std::ostream &operator << (std::ostream &stream, const modulo_int &rhs) {\n    return stream << rhs.value;\n  }\n};\n\nusing modint = modulo_int<std::integral_constant<int, 998244353>>;\n\nint main() {\n  int N, M;\n  std::cin >> N >> M;\n  std::vector<std::vector<int>> grid(N, std::vector<int>(M));\n  for (auto &v: grid) {\n    for (auto &x: v) {\n      std::cin >> x;\n    }\n  }\n  int rank = 0;\n  for (int k: range(0, M)) {\n    int pivot;\n    for (pivot = rank; pivot < N; ++pivot) {\n      if (grid[pivot][k]) {\n        break;\n      }\n    }\n    if (pivot == N) {\n      continue;\n    }\n    std::swap(grid[rank], grid[pivot]);\n    for (int i: range(rank + 1, N)) {\n      if (grid[i][k]) {\n        for (int j: range(0, M)) {\n          grid[i][j] ^= grid[rank][j];\n        }\n      }\n    }\n    ++rank;\n  }\n  std::cout << (modint(2).power(M) - modint(2).power(M - rank)) * modint(2).power(N - 1) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T> LLI power(T n, T p, T m){if(p==0) return 1LL; if(p==1) return n; LLI k = power(n, p/2, m); return ((k*k)%m*(p%2?n:1))%m;}\n\nconst LLI mod = 998244353;\n\n\n\ntemplate <typename T> int rank_matrix(vector<vector<T>> mat){\n\n  int n = mat.size();\n  int m = mat[0].size();\n  int p = 0;\n  \n\n  REP(i,n){\n    if(p>=m) break;    \n\n    bool b = true;\n    FOR(j,i,n) if(mat[j][p] != 0) b = false;\n\n    if(b){\n      ++p;\n      continue;\n    }\n\n    if(mat[i][p] == 0){\n      FOR(j,i+1,n){\n\tif(mat[j][p] != 0){\n\t  swap(mat[i], mat[j]);\n\t  break;\n\t}\n      }\n    }\n    \n    FOR(j,i+1,n){\n      T t = mat[j][p] / mat[i][p];\n      REP(k,m) mat[j][k] -= mat[i][k] * t;\n    }\n  }\n\n  int r = 0;\n  REP(i,n){\n    REP(j,m){\n      if(mat[i][j] != 0){\n\t++r;\n\tbreak;\n      }\n    }\n  }\n\n  return r;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  while(cin >> N >> M){\n    vector<vector<int>> a(N, vector<int>(M)); cin >> a;\n\n    int r = rank_matrix(a);\n\n    LLI ans = power(2LL,(LLI)(M-1),mod) * (power(2LL,(LLI)N,mod) - power(2LL,(LLI)(N-r),mod) + mod) % mod;\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> ivec;\n\nconst int MOD=998244353;\nint INF=100100100100100;\n\nconst int MAX_COL=350;\nconst int MAX_ROW=350;\n\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint add(int a,int b){\n  return (a+b)%MOD;\n}\nint prod(int a,int b){\n  return (a*b)%MOD;\n}\n\nint beki(int a,int b)\n{\n\tif(b==0)return 1;\n\tint x=beki(a,b/2);\n\tif(b%2==0)return (x*x)%MOD;\n\telse return (((a*x)%MOD)*x)%MOD;\n}\n\nint inv(int a)\n{\n\treturn beki(a,MOD-2);\n}\n\nint powe[1000];\nsigned main(){\n  int n,m;cin>>n>>m;\n  BitMatrix B(n+1, m+1);\n  rep(i,n){\n    rep(j,m){\n      int po;cin>>po;\n      B.val[i][j]=po;\n    }\n  }\n  int rk=GaussJordan(B);\n  \n  rep(i,1000){\n    if(i==0)powe[0]=1;\n    else powe[i]=prod(powe[i-1],2);\n  }\n  cout<<prod(powe[m+n],prod(powe[rk]-1,inv(powe[rk+1])))<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#ifdef MY_DEBUG\n#include \"header/header.hpp\"\n#else\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n#ifdef MY_DEBUG\n#include\"print.hpp\"\n#include\"debug.hpp\"\n#endif\n// }}}\n\nconst long long MOD = 998244353;\n\n//{{{ modular algebra\ntemplate<int mod=MOD>\nstruct Num{\n\tint v;\n\tNum(int n):v(n){}\n\tNum():v(0){}\n\toperator int() const {return v;}\n\toperator long long() const {return v;}\n\ttemplate<class T>\n\tNum operator =(int n){v=n;return *this;}\n\n\ttemplate<class T>\n\tinline void operator *=(const T &a) {\n\t\tv = (v*(long long)a)%mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator *(const T &a) {\n\t\tNum n(*this);n*=a;\n\t\treturn n;\n\t}\n\ttemplate<class T>\n\tinline void operator+=(const T &a){\n\t\tv+=(int)a;\n\t\tif(v>=mod)v-=mod;\n\t\t//\tassert(0<=v and v<mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator+(const T &a){\n\t\tNum n(*this);n+=a;\n\t\treturn n;\n\t}\n\tinline Num operator -(){\n\t\tif(v==0)return 0;\n\t\telse return Num(mod-v);\n\t}\n\ttemplate<class T>\n\tinline void operator -=(const T &a){\n\t\tv-=(int)a;\n\t\tif(v<0)v+=mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator -(const T &a){\n\t\tNum n(*this);n-=a;\n\t\treturn n;\n\t}\n\n#ifdef __GCD_H\n\tinline Num inv(){\n\t\treturn Num(invMod(this->v,mod));\n\t}\n\ttemplate<class T>\n\tinline void operator /=(const T &a){\n\t\t(*this)*=invMod((int)a,mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator /(const T &a){\n\t\tNum n(*this);n/=a;\n\t\treturn n;\n\t}\n#endif\n};\n\ntemplate<int mod=MOD>\nint abs(Num<mod> &a){\n\treturn a.v;\n}\ntemplate<class T, int mod>\nT& operator <<(T &os, const Num<mod> &n){\n\tos<<(int)n.v;\n\treturn os;\n}\n\ntemplate<class T, int mod>\nT& operator >>(T &is, Num<mod> &n){\n\tis>>n.v;\n\treturn is;\n}\n//}}}\ntypedef Num<MOD> mod_int;\n\n//{{{ mod_pow(Num<mod> x,Int k)\n/* (x^k)%m */\ntemplate<int mod=MOD>\ninline Num<mod> mod_pow(Num<mod> x, Int k){\n\tif(k==0) return 1;\n\tNum<mod> res(mod_pow(x,k/2));\n\tres*=res;\n\tif(k%2)res*=x;\n\treturn res;\n}\n//}}}\n\nInt N;\nInt M;\nvector<vector<Int>> a;\n\n//{{{ rix library: MATRIX<T> A(n); MATRIX<T> A(n,m); VECTOR<T> v(n);\ntemplate<class T>\nstruct VECTOR:public vector<T>{\n\tconst int &n;\n\tVECTOR(const int &n):n(n){\n\t\tthis->assign(n,0);\n\t}\n};\n\n// O( n )\ntemplate<class T>\nT inner_product(const VECTOR<T> &a, const VECTOR<T> &b) {\n\tT ans = 0;\n\tfor (int i = 0; i < a.n; ++i)\n\t\tans += a[i]*b[i];\n\treturn ans;\n}\n\ntemplate<class T>\nstruct MATRIX:vector<vector<T> > {\n\tconst int n,m;\n\tMATRIX(int n):n(n),m(n){\n\t\tthis->assign(n,vector<T>(n,0));\n\t}\n\tMATRIX(const pair<int,int> &p):n(p.first),m(p.second){\n\t\tthis->assign(n,vector<T>(m,0));\n\t}\n\t// O( n )\n\tvoid operator+=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] += B[i][j];\n\t}\n\tvoid operator-=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] -= B[i][j];\n\t}\n};\n\ntemplate<class T>\nMATRIX<T> identity(int n) {\n\tMATRIX<T> A(n);\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> zero(int n) {\n\tMATRIX<T> A(n);\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> operator+(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC+=B;\n\treturn C;\n}\ntemplate<class T>\nMATRIX<T> operator-(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC-=B;\n\treturn C;\n}\n// O( n^2 )\ntemplate<class T>\nVECTOR<T> operator*(const MATRIX<T> &A, const VECTOR<T> &x) {\n\tVECTOR<T> y(A.n);\n\tfor (int i = 0; i < A.n; ++i)\n\t\tfor (int j = 0; j < A.m; ++j)\n\t\t\ty[i] += T(A[i][j])*x[j];\n\treturn y;\n}\n// O( n^3 )\ntemplate<class T>\nMATRIX<T> operator*(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C({A.n,B.m});\n\tfor (int i = 0; i < C.n; ++i)\n\t\tfor (int j = 0; j < C.m; ++j)\n\t\t\tfor (int k = 0; k < A.m; ++k)\n\t\t\t\tC[i][j] += T(A[i][k])*B[k][j];\n\treturn C;\n}\n// O( n^3 )\ntemplate<class T>\nvoid operator*=(MATRIX<T> &A, const MATRIX<T> &B){\n\tA = A*B;\n}\n\n// O( n^3 log e )\ntemplate<class T>\nMATRIX<T> pow(const MATRIX<T> &A, long long e) {\n\treturn e == 0 ? identity<T>(A.size())  :\n\te % 2 == 0 ? pow(A*A, e/2) : A*pow(A, e-1);\n}\n\ntypedef int Number;\ntypedef MATRIX<Number> Matrix;\ntypedef VECTOR<Number> Vector;\n\n//}}}\n\n//{{{ gauss\ntemplate<class T>\nint gauss(MATRIX<T> &A, VECTOR<T> &b) {\n\t//int gauss(& A) {//returns rank\n\tconst int n = A.size(), m = A[0].size();\n\tint pi = 0;\n\tfor(int pj = 0;pj < m;pj++){\n\t\tfor(int i = pi+1; i < n; i++) {\n\t\t\tif (abs(A[i][pj]) > abs(A[pi][pj])) {\n\t\t\t\tswap(A[i], A[pi]);\n\t\t\t\tswap(b[i], b[pi]);\n\t\t\t}\n\t\t}\n\t\tif(pi>=N){\n\t\t\twhile(1){\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (abs(A[pi][pj]) > 0) {\n\t\t\tT d = A[pi][pj];//1/A[pi][pj]\n\t\t\tREP(j, m)A[pi][j] *= d;\n\t\t\tb[pi] *= d;\n\t\t\tREP(i,n){\n\t\t\t\tif(i==pi)continue;\n\t\t\t\tT k = A[i][pj];\n\t\t\t\tREP(j, m) A[i][j] -= k * A[pi][j];\n\t\t\t\tb[i] -= k * b[pi];\n\t\t\t}\n\t\t\tpi++;\n\t\t}\n\t}\n\treturn pi;\n\t/*\n\t   for(int i = pi; i < n; i++)\n\t   if (abs(b[i]) > 0)\n\t   throw Inconsistent();\n\t   if (pi < m || pj < m)\n\t   throw Ambiguous();\n\t   for(int j = m-1; j >= 0; j--)\n\t   REP(i, j)\n\t   b[i] = modulo(b[i] - b[j] * A[i][j]);\n\t   */\n}\n//}}}\n\nvoid solve(){\n\tMATRIX<Num<2> > a2({N,M});\n\tVECTOR<Num<2> > b(N);\n\tREP(i,N)REP(j,M)a2[i][j] = a[i][j];\n\tint t = gauss(a2,b);\n\t/*\n\tREP(i,a2.size()){\n\t\tREP(j,a2[0].size()){\n\t\t\tcout<<a2[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<t<<endl;\n\t*/\n\tmod_int ans = mod_pow((mod_int)2,N) - mod_pow((mod_int)2,N-t);\n\tans *= mod_pow((mod_int)2,M-1);\n\tcout<<ans<<endl;\n}\n\n//{{{ main fucnction\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> N;\n\tcin >> M;\n\ta.assign(N, vector<Int>(M));\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < M ; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tsolve();\n\treturn 0;\n}\n\n//}}}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <ios> \n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <cmath>\n#include <bitset>\n#include <iostream>\n#include <iomanip>\n#include <ios> \n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <cmath>\n#include <bitset>\n#include <map>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define sz(c) ((int)(c).size())\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n//const int MAX=;\n\ntypedef double number;\nconst number eps = 1e-8;\ntypedef vector<number> arr;\ntypedef vector<arr> mat;\n\n// O( n )\nmat ide(int n) {\n  mat A(n, arr(n));\n  for (int i = 0; i < n; ++i) A[i][i] = 1;\n  return A;\n}\n// O( n )\nnumber in_prod(const arr &a, const arr &b) {\n  number ans = 0;\n  for (int i = 0; i < a.size(); ++i)\n    ans += a[i] * b[i];\n  return ans;\n}\n// O( n^2 )\narr mul(const mat &A, const arr &x) {\n  arr y(A.size());\n  for (int i = 0; i < A.size(); ++i)\n    for (int j = 0; j < A[0].size(); ++j)\n      y[i] = A[i][j] * x[j];\n  return y;\n}\n// O( n^3 )\nmat mul(const mat &A, const mat &B) {\n  mat C(A.size(), arr(B[0].size()));\n  for (int i = 0; i < C.size(); ++i)\n    for (int j = 0; j < C[i].size(); ++j)\n      for (int k = 0; k < A[i].size(); ++k)\n        C[i][j] += A[i][k] * B[k][j];\n  return C;\n}\n// O( n^3 log e )\nmat pow(const mat &A, int e) {\n  return e == 0 ? ide(A.size())  :\n     e % 2 == 0 ? pow(mul(A, A), e/2) : mul(A, pow(A, e-1));\n}\n// O( n^3 )\nnumber det(mat A) {\n  const int n = A.size();\n  number D = 1;\n  for (int i = 0; i < n; ++i) {\n    int pivot = i;\n    for (int j = i+1; j < n; ++j)\n      if (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[i]);\n    D *= A[i][i] * (i != pivot ? -1 : 1);\n    if (abs(A[i][i]) < eps) break;\n    for(int j = i+1; j < n; ++j)\n      for(int k = n-1; k >= i; --k)\n        A[j][k] -= A[i][k] * A[j][i] / A[i][i];\n  }\n  return D;\n}\n// O(n)\nnumber tr(const mat &A) {\n  number ans = 0;\n  for (int i = 0; i < A.size(); ++i)\n    ans += A[i][i];\n  return ans;\n}\n// O( n^3 ).\nint rnk(mat A) {\n  const int n = A.size(), m = A[0].size();\n  int r = 0;\n  for (int i = 0; r < n && i < m; ++i) {\n    int pivot = r;\n    for (int j = r+1; j < n; ++j)\n      if (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[r]);\n    if (abs(A[r][i]) < eps) continue;\n    for (int k = m-1; k >= i; --k)\n      A[r][k] /= A[r][i];\n    for(int j = r+1; j < n; ++j)\n      for(int k = i; k < m; ++k)\n        A[j][k] -= A[r][k] * A[j][i];\n    ++r;\n  }\n  return r;\n}\n\nconst ll MOD=998244353;\n\nll pw2(int a){\n\tif(a==0)return 1;\n\tll p=pw2(a/2);\n\tif(a%2==0) return (p*p)%MOD;\n\tif(a%2==1) return (2*p*p)%MOD;\n}\n\n\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n\tmat A(N,arr(M));\n\trep(i,N)rep(j,M)cin>>A[i][j];\n\tint r=rnk(A);\n\tcout<<(pw2(M+N-1)-pw2(M+N-r-1)+MOD)%MOD<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <complex>\n#include <cassert>\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define case(i) cout<<\"Case #\"<<i<<\": \"\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, ll> pr;\ntypedef complex<double> com;\nconst int mod = 1e9 + 7;\nconst int MOD = 998244353;\nconst ll INF = 1e18;\n\ntypedef double number;\nconst number eps = 1e-8;\ntypedef vector<number> array1;\ntypedef vector<array1> matrix;\n\nmatrix identity1(int n,int m) {\n\tmatrix A(n, array1(m));\n\treturn A;\n}\nint rank1(matrix A) {\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[r]);\n\t\tif (abs(A[r][i]) < eps) continue;\n\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\tA[r][k] /= A[r][i];\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tfor (int k = i; k < m; ++k)\n\t\t\t\tA[j][k] -= A[r][k] * A[j][i];\n\t\t++r;\n\t}\n\treturn r;\n}\n\nll mpow(int n, int k, int p) {\n\tif (k == 0)return 1;\n\tif (k % 2)return 1LL * n * mpow(n, k - 1, p) % p;\n\telse {\n\t\tll sub = mpow(n, k / 2, p);\n\t\treturn 1LL * sub * sub% p;\n\t}\n}\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<array1> a=identity1(n,m);\n\trep(i, 0, n) {\n\t\trep(j, 0, m) cin >> a[i][j];\n\t}\n\tll r = rank1(a);\n\tll ans = (mpow(2, n + m - 1, MOD) - mpow(2, n + m - r - 1, MOD) + MOD) % MOD;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n\n*/\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define gc() getchar()\n#define mod 998244353\ntypedef long long LL;\nconst int N=305;\n\nint A[N][N],B[N][N];\n\ninline int read()\n{\n\tint now=0;register char c=gc();\n\tfor(;!isdigit(c);c=gc());\n\tfor(;isdigit(c);now=now*10+c-48,c=gc());\n\treturn now;\n}\ninline int FP(int x,int k)\n{\n\tint t=1;\n\tfor(; k; k>>=1,x=1ll*x*x%mod)\n\t\tif(k&1) t=1ll*t*x%mod;\n\treturn t;\n}\n\nint main()\n{\n\tint n=read(),m=read();\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=m; ++j) A[i][j]=read();\n\tint r=0;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=m; ++j)\n\t\t\tif(A[i][j])//x>>j&1\n\t\t\t{\n\t\t\t\tif(B[j][j]) for(int k=j; k<=m; ++k) A[i][k]^=B[j][k];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int k=j; k<=m; ++k) B[j][k]=A[i][k];\n\t\t\t\t\t++r; break;\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%d\\n\",(FP(2,n+m-1)+mod-FP(2,n-r+m-1))%mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VVI a(n, VI(m));\n    REP(i,n) REP(j,m) a[i][j] = in();\n\n    int sum = 0;\n    REP(i,n) REP(j,m) sum ^= a[i][j];\n\n    VI si(n), sj(m);\n    REP(i,n) REP(j,m){\n        si[i] ^= a[i][j];\n        sj[j] ^= a[i][j];\n    }\n\n    VVI dpi(n + 1, VI(2)), dpj(m + 1, VI(2));\n    dpi[0][0] = dpj[0][0] = 1;\n    REP(i,n) REP(j,2){\n        dpi[i + 1][j] += dpi[i][j];\n        (dpi[i + 1][j ^ si[i]] += dpi[i][j]) %= mod;\n    }\n    REP(i,m) REP(j,2){\n        dpj[i + 1][j] += dpj[i][j];\n        (dpj[i + 1][j ^ si[i]] += dpj[i][j]) %= mod;\n    }\n\n    ll ans = 0;\n    REP(i,2) REP(j,2){\n        if ((i ^ j ^ sum) == 1) ans = (ans + divll(dpi[n][i] * dpj[m][j], 2)) % mod;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#define inf 20021225\n#define ll long long\n#define mdn 998244353\nusing namespace std;\n\nbitset<310> r[310]; int n,m;\nint gauss()\n{\n\tint w = 0;\n\tfor(int i=1,j;i<=min(n,m);i++)\n\t{\n\t\tif(!r[i][i])\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t\tif(r[j][i])\tbreak;\n\t\t\tif(j>n)\tcontinue;\n\t\t\tswap(r[i],r[j]);\n\t\t}\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tif(r[j][i])\tr[j]^=r[i];\n\t\tw++;\n\t}\n\treturn w;\n}\nint ksm(int bs,int mi)\n{\n\tint ans = 1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=(ll)ans*bs%mdn;\n\t\tbs=(ll)bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tr[i][j] = x;\n\t\t}\n\tint ans = ksm(2,n+m-1)-ksm(2,n+m-1-gauss());\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;++i)\n#define repd(i,a,b) for(int i=a;i>=b;--i)\n#define rvc(i,S) for(int i=0;i<(int)S.size();++i)\n#define fore(i,x) for(int i = head[x] ; i ; i = e[i].next)\n#define mp make_pair\n#define pb push_back\n#define int long long\n#define PII pair<int,int>\n#define maxn 1000005\n#define ll long long \n#define fi first\n#define int ll\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std; \nint n,m;\nconst int mo=998244353;\nint a[305][305];\nvoid SWAP(int x,int y)\n{ rep(i,1,m) swap(a[x][i],a[y][i]);}\nvoid solve(int x,int y)\n{rep(i,1,m) a[x][i]^=a[y][i];\n}\nsigned main()\n{ cin>>n>>m;\n  rep(i,1,n)rep(j,1,m) cin>>a[i][j];\n  int r=0;\n  rep(i,1,m)\n  {int k=0; \n   rep(j,r+1,n) if(a[j][i]){k=j;break;}\n   if(k) {r++;}\n   else continue;\n   SWAP(r,k);\n   rep(p,1,n)\n   {if(p!=r)\n     solve(p,r);\n   }\n  }\n  int add=1;\n  rep(i,1,n+m-1) add=(add*2)%mo;\n  int del=1;\n  rep(i,1,n+m-r-1) del=(del*2)%mo;\n  cout<<(add-del+mo)%mo<<endl; \n\t\n\t\n\t\nreturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG  // gcc\n    #define _LIBCPP_DEBUG 0 // clang\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define _GLIBCXX_DEBUG\n    // #define _LIBCPP_DEBUG 0\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check() { char bufc; if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"\\n----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\npublic:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(), last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n/* dump definition start */\n#ifdef LOCAL\n    #define dump(...) debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\", dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\n/* dump definition end */\n\n/* function utility start */\ntemplate <class T, class... types> T read(types... args) noexcept { T obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = pair<i32, i32>; using pll = pair<i64, i64>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using rheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\n/* using alias end */\n\n/* library start */\n\n#ifndef Modint_hpp\n#define Modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    static constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    constexpr modint(bool x = false) noexcept : val{x} {}\n    constexpr modint(int x) noexcept : val(x & 1) {}\n    constexpr modint(long long x) noexcept : val(x & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val &= other.val, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { assert(other.val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator-(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator*(const modint &other) const noexcept { return val && other.val; }\n    constexpr modint operator/(const modint &other) const noexcept { assert(other.val); return *this; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { assert(y.val); return x & 1 ? y : modint<2>{0}; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // Modint_hpp\n\n#ifndef Matrix_hpp\n#define Matrix_hpp\n// #include <iostream>\n// Field must be a field.\ntemplate <class Field>\nclass matrix\n{\n    std::valarray<std::valarray<Field>> data;\n    friend std::istream &operator>>(std::istream &is, matrix &x)\n    {\n        size_t h = x.height(), w = x.width();\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j) is >> x[i][j];\n        }\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const matrix &x)\n    {\n        size_t h = x.height(), w = x.width();\n        for(size_t i = 0; i < h; ++i)\n        {\n            if(i) os << \"\\n\";\n            for(size_t j = 0; j < w; ++j) os << (j ? \" \" : \"\") << x.data[i][j];\n        }\n        return os;\n    }\n    friend matrix pow(matrix x, long long n)\n    {\n        assert(x.is_square());\n        matrix res = identity(x.height());\n        while(n)\n        {\n            if(n & 1) res *= x;\n            x *= x, n >>= 1;\n        }\n        return res;\n    }\n    friend matrix inverse(const matrix &x)\n    {\n        assert(x.is_square());\n        size_t n = x.height();\n        matrix ext_x(x), e(identity(n)), res(n);\n        for(size_t i = 0; i < n; ++i) ext_x[i].insert(end(ext_x[i]), begin(e[i]), end(e[i]));\n        ext_x = ext_x.row_canonical_form();\n        for(size_t i = 0; i < n; ++i)\n        {\n            if(std::vector<Field>(begin(ext_x[i]), begin(ext_x[i]) + n) != e[i]) return matrix();\n            res[i] = std::vector<Field>(begin(ext_x[i]) + n, end(ext_x[i]));\n        }\n        return res;\n    }\npublic:\n    matrix(size_t n = 0) { resize(n, n);}\n    matrix(size_t h, size_t w) { resize(h, w); }\n    // matrix(const matrix &x) : data(x.data) {}\n    matrix(const std::vector<std::vector<Field>> _mat) : data(_mat) {}\n    size_t height() const { return data.size(); }\n    size_t width() const { return data.size() ? data[0].size() : 0; }\n    bool is_square() const { return height() == width(); }\n    void resize(size_t h, size_t w, const Field val = Field(0)) { data.resize(h, std::valarray<Field>(val, w)); }\n    std::valarray<Field> &operator[](const size_t i) { assert(i < data.size()); return data[i]; }\n    static matrix identity(size_t n)\n    {\n        matrix ret(n, n);\n        for(size_t i = 0; i < n; ++i) ret[i][i] = Field(1);\n        return ret;\n    }\n    matrix operator-() const\n    {\n        size_t h = height(), w = width();\n        matrix res(*this);\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                res[i][j] = -data[i][j];\n            }\n        }\n        return res;\n    }\n    matrix operator&(const matrix &x) const { return matrix(*this) &= x; }\n    matrix operator|(const matrix &x) const { return matrix(*this) |= x; }\n    matrix operator^(const matrix &x) const { return matrix(*this) ^= x; }\n    matrix operator+(const matrix &x) const { return matrix(*this) += x; }\n    matrix operator-(const matrix &x) const { return matrix(*this) -= x; }\n    matrix operator*(const matrix &x) const { return matrix(*this) *= x; }\n    matrix &operator&=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                data[i][j] &= x.data[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator|=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                data[i][j] |= x.data[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator^=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                data[i][j] ^= x.data[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator+=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                data[i][j] += x.data[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator-=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                data[i][j] -= x.data[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator*=(const matrix &x)\n    {\n        size_t l = height(), m = width(), n = x.width();\n        assert(m == x.height());\n        matrix res(l, n);\n        for(size_t i = 0; i < l; ++i)\n        {\n            for(size_t j = 0; j < m; ++j)\n            {\n                for(size_t k = 0; k < n; ++k)\n                {\n                    res[i][k] += data[i][j] * x.data[j][k];\n                }\n            }\n        }\n        return *this = res;\n    }\n    std::vector<size_t> row_canonicalize()\n    {\n        std::vector<size_t> pivots;\n        const size_t h = height(), w = width();\n        for(size_t j = 0, rank = 0; j != w; ++j)\n        {\n            bool ispiv = false;\n            for(size_t i = rank; i != h; ++i)\n            {\n                if(data[i][j] != Field{})\n                {\n                    if(ispiv)\n                    {\n                        const Field r = -data[i][j];\n                        for(size_t k = j; k != w; ++k) data[i][k] += data[rank][k] * r;\n                    }\n                    else\n                    {\n                        swap(data[rank], data[i]);\n                        Field r = data[rank][j];\n                        for(size_t k = j; k != w; ++k) data[rank][k] /= r;\n                        for(size_t k = 0; k != rank; ++k)\n                        {\n                            r = -data[k][j];\n                            for(size_t l = j; l != w; ++l) data[k][l] += data[rank][l] * r;\n                        }\n                        ispiv = true;\n                    }\n                }\n            }\n            if(ispiv)\n            {\n                ++rank;\n                pivots.emplace_back(j);\n            }\n        }\n        return pivots;\n    }\n    Field determinant() const\n    {\n        matrix<Field> x(*this);\n        assert(is_square());\n        size_t n = height();\n        Field res(1);\n        for(size_t j = 0; j < n; ++j)\n        {\n            bool ispiv = false;\n            for(size_t i = j; i < n; ++i)\n            {\n                if(x[i][j] != Field{})\n                {\n                    if(ispiv)\n                    {\n                        const Field r = -x[i][j];\n                        for(size_t k = j; k < n; ++k) x[i][k] += x[j][k] * r;\n                    }\n                    else\n                    {\n                        swap(x[i], x[j]);\n                        if(i != j) res = -res;\n                        const Field r = x[j][j];\n                        res *= r;\n                        for(size_t k = j; k < n; ++k) x[j][k] /= r;\n                        ispiv = true;\n                    }\n                }\n            }\n            if(!ispiv) return Field(0);\n        }\n        return res;\n    }\n};\n#endif\n\n/* library end */\n\n/* The main code follows. */\n\nusing mint=modint<998244353>;\n#include <valarray>\n\nstruct solver\n{\n    solver()\n    {\n        input(int,h);\n        input(int,w);\n        input(matrix<modint<2>>,a,h,w);\n        int rank=a.row_canonicalize().size();\n        int kdim=w-rank;\n        cout << mint::pow(2,h)*(mint::pow(2,w-1)-mint::pow(2,kdim-1)) << \"\\n\";\n    }\n}; // struct solver\n\nint main(int argc, char *argv[])\n{\n    u32 t; // loop count\n#ifdef LOCAL\n    t = 1;\n#else\n    t = 1; // single test case\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--)\n    {\n        solver();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxN=310;\nconst int Mod=998244353;\n\nint n,m;\nbitset<maxN> B[maxN];\nint C[maxN][maxN],Sm[maxN],pw[maxN];\n\nint main(){\n    pw[0]=1;for (int i=1;i<maxN;i++) pw[i]=2ll*pw[i-1]%Mod;\n    scanf(\"%d%d\",&n,&m);\n    int cnt=0,one=0;\n    for (int i=1;i<=n;i++){\n        bitset<maxN> I;I.reset();\n        for (int j=1;j<=m;j++){\n            int x;scanf(\"%d\",&x);I[j]=x;\n        }\n        bool flag=0;\n        for (int j=1;j<=m;j++)\n            if (I[j]){\n                if (B[j]==0){\n                    B[j]=I;flag=1;break;\n                }\n                else I^=B[j];\n            }\n        if (flag==0) ++cnt;\n    }\n\n    printf(\"%lld\\n\",1ll*(pw[n]-pw[cnt]+Mod)%Mod*pw[m-1]%Mod);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\nint pow(int x, int pow) {\n\tint res = 1, t = x;\n\twhile (pow) {\n\t\tif (pow & 1) {\n\t\t\tres = 1LL * res * t % MOD;\n\t\t}\n\t\tt = 1LL * t * t % MOD;\n\t\tpow >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tint** mat = new int*[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tmat[i] = new int[m];\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> mat[i][j];\n\t\t}\n\t}\n\tint cur = 0;\n\tfor (int c = 0; cur < n && c < m; c++) {\n\t\tfor (int r = cur; r < n; r++) {\n\t\t\tif (mat[r][c]) {\n\t\t\t\tswap(mat[cur], mat[r]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!mat[cur][c]) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int r = 0; r < n; r++) {\n\t\t\tif (r != cur && mat[r][c]) {\n\t\t\t\tfor (int k = c; k < m; k++) {\n\t\t\t\t\tmat[r][k] ^= mat[cur][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcur++;\n\t}\n\n\tint tot = pow(2, n + m - 1);\n\ttot -= pow(2, n + m - cur - 1);\n\tif (tot < 0) {\n\t\ttot += MOD;\n\t}\n\tcout << tot << endl;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdelete mat[i];\n\t}\n\tdelete mat;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\nll P = 998244353;\nll mpow(ll a, ll b, ll p = -1){\n  ll ret = 1, num = a;\n  if(p==-1){\n    while(b>0){\n      if(b%2) ret *= num;\n      num = num * num;\n      b /= 2;\n    }\n  }else{\n    while(b>0){\n      if(b%2) ret = (ret*num)%p;\n      num = (num*num)%p;\n      b /= 2;\n    }\n  }\n  return ret;\n}\n\nint main(int argc, char const *argv[]) {\n  // 2^n+m-1(全体の半分)\n  // 自由度xに対し\n  // ans = 2^(n-1+m) - 2^(n-1 + x)\n  ll n, m;std::cin >> n >> m;\n  ll x = 0;\n  vvl dat = VV(n, m, 0, ll);\n\n  for(int i=0;i<n;i++) for(int j=0;j<m;j++) scanf(\"%lld\", &dat[i][j]);\n\n  ll st = 0;\n  for(int i=0;i<min(n, m);i++){\n    //i列目が1の行を探す\n    ll idx = -1;\n    for(int j=st;j<n;j++){\n      if(dat[j][i]){\n        idx = j;\n        break;\n      }\n    }\n    if(idx==-1) continue;\n    swap(dat[st], dat[idx]);\n\n    //stが今、st+1行目以降掃き出し\n    for(int j=st+1;j<n;j++){\n      if(!dat[j][i]) continue;\n      for(int k=i;k<m;k++) dat[j][k] ^= dat[st][k];\n    }\n    st++;\n  }\n  for(int i=0;i<n;i++){\n    bool f = true;\n    for(int j=0;j<m;j++){\n      if(dat[i][j]) {\n        f = false;\n        break;\n      }\n    }\n    if(!f) x++;\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      std::cout << dat[i][j];\n    }\n    std::cout << '\\n';\n  }\n  */\n  ll ans = (mpow(2, n-1+m, P) - mpow(2, n-1+m-x) +P)%P;\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n,m,a[N][N],b[N][N];\nll qpow(ll a,ll n)\n{\n    ll ans=1;\n    while(n)\n    {\n        if(n&1) ans=ans*a%mod;\n        a=a*a%mod;\n        n>>=1;\n    }\n    return ans;\n}\nint guass(int n)\n{\n    int ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        int p=i;\n        while(p<=n&&!a[i][p]) p++;\n        if(p==n+1) {ans++;continue;}\n        swap(a[i],a[p]);\n        for(int j=i+1;j<=n;j++)\n            if(a[j][i])\n            for(int k=i;k<=n;k++)\n            a[j][k]^=a[i][k];\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        scanf(\"%d\",&a[i][j]);\n    int r=0;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        if(a[i][j])\n        {\n            if(b[j][j]) for(int k=j;k<=m;k++) a[i][k]^=b[j][k];\n            else\n            {\n                for(int k=j;k<=m;k++) b[j][k]=a[i][k];\n                r++;break;\n            }\n        }\n    printf(\"%lld\\n\",qpow(2,n-1)*(qpow(2,m)+mod-qpow(2,m-r))%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "/// Containers Start\n#include <algorithm>\n#include <bitset>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n/// C Header Files\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <math.h>\n#include <stdio.h>\n/// Containers End\n\nusing namespace std;\n\n/// Math Start\n#define PI acos(-1.0)\n#define Pi 3.141592653589793\n#define EPS (1e-7)\n#define INF (0x3f3f3f3f)\n/// Math End\n\n/// Extra Start\n#define nn '\\n'\n#define pb push_back\n#define ull unsigned long long\n#define ll long long\n// #define MOD 1000000007\n#define MOD 998244353\n#define sz(a) int((a).size())\n#define space \" \"\n#define All(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n/// Extra End\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define Cini(a)                                                                \\\n    int a;                                                                     \\\n    cin >> a;\n#define Cinii(a, b)                                                            \\\n    int a, b;                                                                  \\\n    cin >> a >> b;\n#define Ciniii(a, b, c)                                                        \\\n    int a, b, c;                                                               \\\n    cin >> a >> b >> c;\n#define Cins(s)                                                                \\\n    string s;                                                                  \\\n    cin >> s;\n#define Cinss(s1, s2)                                                          \\\n    string s1, s2;                                                             \\\n    cin >> s1 >> s2;\n#define Cinc(c)                                                                \\\n    char c;                                                                    \\\n    cin >> c;\n/// Functions End\n\n/// Graph Start\nstruct edge {\n    int from, to;\n    long long cost;\n};\n/// Graph End\n\n/// Debug Start\n#define deb(x) cout << #x << \": \" << x << endl\n#define deb2(x, y) cout << #x << \": \" << x << '\\t' << #y << \": \" << y << endl;\n#define deb3(x, y, z)                                                          \\\n    cout << #x << \": \" << x << '\\t' << #y << \": \" << y << '\\t' << #z << \": \"   \\\n         << z << endl;\n/// Debug End\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\n/**>>>>>>>>>>>>>>>>>>> END <<<<<<<<<<<<<<<<<<**/\n\n/// template\n\n#define int long long\n\nsigned main(void) {\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n    ll N,M;\n    cin >> N >> M;\n    int a[N + 1][M + 1], row[N + 1], col[M + 1];\n    fill(row, row + N + 1, 0);\n    fill(col, col + N + 1, 0);\n    vector<pair<int, int> > p;\n    rep(i, N) rep(j, M) cin >> a[i + 1][j + 1];\n    rep(i, N) {\n        rep(j, M) { row[1 + i] += a[i + 1][j + 1]; }\n    }\n    rep(i, M) {\n        rep(j, N) { col[1 + i] += a[j+1][i+1]; }\n    }\n    long long dp[N + 1];\n    long long mypow2[301];\n    mypow2[0] = 1LL;\n    rep(i, 300) mypow2[i + 1] = (mypow2[i] * 2LL) % MOD;\n    fill(dp, dp + N + 1, 0LL);\n    dp[0] = 0LL;\n    for (ll i = 1; i <= N; i++) {\n        dp[i] =  ((dp[i-1] + ((M-row[i]) * dp[i-1])%MOD)%MOD + ((row[i])*(mypow2[i-1+M]-dp[i-1]))%MOD)%MOD;\n    }\n    cout << dp[N]/2LL << nn;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 998244353;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint gauss_jordan(vector<bitset<300>> &a){\n    int n = a.size(), m = 300;\n    int cnt = 0;\n    for (int i = 0; i < m && cnt != n; ++i) {\n        int p = cnt;\n        for (int j = cnt; j < n; ++j) {\n            if(a[j][i]){\n                p = j;\n                break;\n            }\n        }\n        if((a[p][i]) == 0) continue;\n        swap(a[cnt], a[p]);\n        for (int j = 0; j < n; ++j) {\n            if(cnt == j) continue;\n            if(a[j][i]) a[j] ^= a[cnt];\n        }\n        cnt++;\n    }\n    a.erase(a.begin()+cnt, a.begin()+n);\n    return cnt;\n}\n\ntemplate <class T>\nT pow_ (T x, T n, T M){\n    uint64_t u = 1, xx = x;\n    while (n > 0){\n        if (n&1) u = u * xx % M;\n        xx = xx * xx % M;\n        n >>= 1;\n    }\n    return static_cast<T>(u);\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<bitset<300>> v(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int x;\n            scanf(\"%d\" ,&x);\n            if(x) v[i].set(j);\n        }\n    }\n    int rank = gauss_jordan(v);\n    ll ans1 = pow_(2, m-1, MOD), ans2 = MOD+pow_(2, n, MOD)-pow_(2, n-rank, MOD);\n    cout << (ans1*ans2)%MOD << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=998244353;\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\nconst double EPS=1E-8;//小さい数\nint mat_rank(mat A) {\n    int N = A.size(), M = A[0].size();\n    int res = 0;\n    for(int i=0; i<M; i++) {\n        // 絶対値が最も大きいものを探す\n        double max_elem = 0; int piv = -1;\n        for(int j=res; j<N; j++) {\n            if(abs(A[j][i]) > max_elem) {\n                max_elem = abs(A[j][i]);\n                piv = j;\n            }\n        }\n        if(piv < 0) continue;\n        swap(A[res], A[piv]);\n        for(int k=0; k<M; k++) {\n            A[res][k] = (1.0 * A[res][k] / A[res][i]);\n        }\n        for(int j=0; j<N; j++) {\n            if(j == res) continue;\n            double mul = A[j][i];\n            for(int k=0; k<M; k++) {\n                A[j][k] = A[j][k] - mul * A[res][k];\n            }\n        }\n        res++;\n    }\n    return res;\n}\nll mod_pow(ll x, ll n, ll mod){\n    if (n==0) return 1;\n    ll res=mod_pow(x*x%mod, n/2, mod);\n    if (n%2==1) res=res*x%mod;\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N,M;\n    cin>>N>>M;\n    mat a(N,vec(M,0));\n    rep(i,0,N){\n        rep(j,0,M){\n            cin>>a[i][j];\n        }\n    }\n    cout <<(mod_pow(2LL, N+M-1, MOD)-mod_pow(2LL, N+M-1-mat_rank(a), MOD)+MOD)%MOD<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\n\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\n\ntemplate <typename T> constexpr bool chmax(T &a, const T b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nconstexpr int MAX_ROW = 510;\nconstexpr int MAX_COL = 510;\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL> &operator[](const int &i) { return val[i]; }\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    rep(col, A.W) {\n        if(is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        rep(row, A.H) {\n            if(A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if(pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        rep(row, A.H) if(row != rank && A[row][col]) A[row] ^= A[rank];\n        rank++;\n    }\n    return rank;\n}\n\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt &p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt &p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt &p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt &p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt &p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt &p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt &p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(const int64_t &n) const {\n        ModInt ret(1), mul(x);\n        int64_t k = n % (M - 1);\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n, m;\n    cin >> n >> m;\n    BitMatrix A(n, m);\n    rep(i, n) rep(j, m) {\n        bool a;\n        cin >> a;\n        A[i][j] = a;\n    }\n    int r = GaussJordan(A);\n\n    using modint = ModInt<Mod>;\n    modint m2(2);\n    cout << m2.pow(n + m - 1) - m2.pow(n + m - r - 1) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int p=998244353;\nint n,m,a[505][505],pw[505];\nbitset<505> b[505];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tbitset<505> x;\n\t\tfor(int j=1,y;j<=m;j++){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tx[j-1]=y;\n\t\t}\n\t\tfor(int j=m-1;j>=0;j--)\n\t\t\tif(x[j]){\n\t\t\t\tif(b[j].any())x^=b[j];\n\t\t\t\telse{b[j]=x;break;}\n\t\t\t}\n\t}\n\tfor(int i=pw[0]=1;i<=n||i<=m;i++)pw[i]=2*pw[i-1]%p;\n\tint rk=0;\n\tfor(int i=0;i<=m-1;i++)if(b[i].any())rk++;\n\tint ans=1ll*(pw[n]-pw[n-rk])*pw[m-1]%p;\n\tprintf(\"%d\\n\",(ans+p)%p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mo 998244353\n#define N 310\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nint a[N][N],p[N][N];\nint m,n,sum;\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nint main(){\n\tread(n);read(m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)read(a[i][j]);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=m;j>=1;j--){\n\t\t\tif (p[j][j]==0){\n\t\t\t\tif (a[i][j]==1){\n\t\t\t\t\tfor (int k=1;k<=j;k++) p[j][k]=a[i][k];\n\t\t\t\t\tsum++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor (int k=1;k<=j;k++) a[i][k]^=p[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tif (sum>m) {while(1) sum++;}\n\tcout<<((po(2,m)-po(2,m-sum)+mo)%mo)*po(2,n-1)%mo<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\nconst int N=305;\nconst int mod=998244353;\nint powmod(int x, int k)\n{\n\tint ans=1;\n\tfor(;k;k>>=1,x=(ll)x*x%mod) if(k&1) ans=(ll)ans*x%mod;\n\treturn ans;\n}\nint inv(int x){ return powmod(x,mod-2);}\nint a[N][N];\nint main()\n{\n\tint n,m,i,j,k;\n\tscanf(\"%i %i\",&n,&m);\n\tfor(i=1;i<=n;i++) for(j=1;j<=m;j++) scanf(\"%i\",&a[i][j]);\n\tint r=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tbool ok=0;\n\t\tfor(j=r+1;j<=n;j++)\n\t\t{\n\t\t\tif(a[j][i])\n\t\t\t{\n\t\t\t\tfor(k=i;k<=n;k++) swap(a[j][k],a[r+1][k]);\n\t\t\t\tok=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\t\tr++;\n\t\tfor(j=r+1;j<=n;j++) if(a[j][i])\n\t\t{\n\t\t\tint mul=(ll)(mod-a[j][i])*inv(a[r][i])%mod;\n\t\t\tfor(k=i;k<=n;k++) a[j][k]=(a[j][k]+(ll)a[r][k]*mul%mod)%mod;\n\t\t}\n\t}\n\tint ans=1,sol=1;\n\tfor(i=1;i<=n+m-1;i++) ans=ans*2%mod;\n\tfor(i=1;i<=n+m-r-1;i++) sol=sol*2%mod;\n\tans-=sol;\n\tif(ans<0) ans+=mod;\n\tprintf(\"%i\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n\tfact.resize(n+1);\n\tinv.resize(n+1);\n\tinvfact.resize(n+1);\n\tfact[0]=inv[0]=invfact[0]=1;\n\tinv[1]=1;\n\trep(i,n){\n\t\tfact[i+1]=fact[i]*(i+1)%mod;\n\t\tif(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n\t\tinvfact[i+1]=invfact[i]*inv[i+1]%mod;\n\t}\n}\nll perm(int n,int k){\n\tif(n<0||k<0||k>n)return 0;\n\treturn fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n\tif(n<0||k<0||k>n)return 0;\n\treturn (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n\tll ret=1;\n\twhile(k){\n\t\tif(k&1)ret=ret*n%mod;\n\t\tn=n*n%mod;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tmod_build();\n\tint n,m;\n\tcin>>n>>m;\n\tint a[n][m];\n\trep(i,n)rep(j,m)cin>>a[i][j];\n\tint cnt=0;\n\trep(i,n){\n\t\tbool ok=false;\n\t\tint idx = -1;\n\t\tfor(int j=cnt;j<m;++j)if(a[i][j]==1)ok=true,idx=j;\n\t\tif(!ok)continue;\n\t\tif(a[i][cnt]!=1){\n\t\t\trep(k,n)swap(a[k][cnt],a[k][idx]);\n\t\t}\n\t\trep(j,m){\n\t\t\tif(!a[i][j]||j==cnt)continue;\n\t\t\trep(k,n)a[k][j]^=a[k][cnt];\n\t\t}\n\t\t++cnt;\n\t}\n\tll ans=powmod(2,m+n-1);\n\tans+=mod-powmod(2,n+m-cnt-1);\n\tcout<<ans%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\n\n\ntemplate<typename T>\nstruct Matrix {\n    vector<vector<T>> A;\n\n    Matrix() {}\n\n    Matrix(size_t n, size_t m) : A(n, vector<T>(m)) {}\n\n    Matrix(size_t n) : A(n, vector<T>(n)) {};\n\n    size_t height() const {\n        return (A.size());\n    }\n\n    size_t width() const {\n        return (A[0].size());\n    }\n\n    inline const vector<T> &operator[](int k) const {\n        return (A.at(k));\n    }\n\n    inline vector<T> &operator[](int k) {\n        return (A.at(k));\n    }\n\n    static Matrix I(size_t n) {\n        Matrix B(n);\n        for (int i = 0; i < n; i++) B[i][i] = 1;\n        return (B);\n    }\n\n    Matrix operator-() const {\n        size_t n = height(), m = width();\n        Matrix B = *this;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                B[i][j] = -B[i][j];\n        return (B);\n    }\n\n    Matrix &operator+=(const Matrix &B) {\n        size_t n = height(), m = width();\n        assert(n == B.height() && m == B.width());\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                A[i][j] += B[i][j];\n        return (*this);\n    }\n\n    Matrix &operator-=(const Matrix &B) {\n        return (*this += -B);\n    }\n\n    Matrix &operator*=(const Matrix &B) {\n        size_t n = height(), m = B.width(), p = width();\n        assert(p == B.height());\n        Matrix C(n, m);\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++)\n                for(int k = 0; k < p; k++)\n                    C[i][j] += A[i][k] * B[k][j];\n        A.swap(C.A);\n        return (*this);\n    }\n\n    Matrix pow(int64_t k) {\n        Matrix B = Matrix::I(height()), tmp = *this;\n        while (k > 0) {\n            if (k & 1) B *= tmp;\n            tmp *= tmp;\n            k >>= 1LL;\n        }\n        return (B);\n    }\n\n    const Matrix operator+(const Matrix &B) const {\n        return (Matrix(*this) += B);\n    }\n\n    const Matrix operator-(const Matrix &B) const {\n        return (Matrix(*this) -= B);\n    }\n\n    const Matrix operator*(const Matrix &B) const {\n        return (Matrix(*this) *= B);\n    }\n\n    friend ostream &operator<<(ostream &os, Matrix &B) {\n        size_t n = B.height(), m = B.width();\n        for(int i = 0; i < n; i++) {\n            os << (i == 0 ? \"[\" : \" \");\n            for(int j = 0; j < m; j++) {\n                os << B[i][j] << (j == m-1 ? \"]\" : \",\");\n            }\n            os << (i == n-1 ? \"]\\n\" : \",\\n\");\n        }\n        return (os);\n    }\n\n    int GaussJordanElimination() {\n        int rank = 0;\n        for (int col = 0; col < width(); ++col) {\n            int pivot = -1;\n            for (int row = rank; row < height(); ++row) {\n                if (A[row][col] != T{0}) {\n                    pivot = row;\n                    break;\n                }\n            }\n            if (pivot == -1) continue;\n            swap(A[rank], A[pivot]);\n            T topLeft = A[rank][col];\n            for (int c = col; c < width(); ++c) {\n                A[rank][c] /= topLeft;\n            }\n            for (int row = rank+1; row < height(); ++row) {\n                T ratio = A[row][col];\n                for (int c = col; c < width(); ++c)\n                    A[row][c] -= ratio * A[rank][c];\n            }\n            ++rank;\n        }\n        return (rank);\n    }\n};\n\nvoid test() {\n    auto A = Matrix<int>(3,5),\n         B = Matrix<int>(),\n         C = Matrix<int>(5);\n    B = A;\n\n    cout << A[0][0] << endl;\n    A[0][0] = 3;\n\n    A += B;\n    -A;\n    A *= C;\n    A -= B;\n    C.pow(4);\n\n    cout << A << endl;\n\n    auto I = Matrix<int>::I(3);\n    cout << I << endl;\n\n    I[1][0] = I[2][1] = 1;\n    cout << I << endl;\n\n    int rank = I.GaussJordanElimination();\n    cout << I << endl;\n    cout << rank << endl;\n\n}\n\n\ntemplate<long long mod>\nstruct modint {\n    using LL = long long;\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint inv() const { return pow(mod-2); }\n\n    modint& operator+=(const modint& rhs) {\n        (val += rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (val *= rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.inv();\n    }\n\n    const modint operator+(const modint& rhs) const {\n        return modint(*this) += rhs;\n    }\n    const modint operator-(const modint& rhs) const {\n        return modint(*this) -= rhs;\n    }\n    const modint operator*(const modint& rhs) const {\n        return modint(*this) *= rhs;\n    }\n    const modint operator/(const modint& rhs) const {\n        return modint(*this) /= rhs;\n    }\n\n    const modint pow(LL n) const {\n        modint ret = 1, tmp = val;\n        while (n > 0) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.val;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    using GF2 = modint<2>;\n\n    int n, m; cin >> n >> m;\n    Matrix<GF2> A(n, m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> A[i][j];\n        }\n    }\n\n    int rank = A.GaussJordanElimination();\n\n    using Int = modint<998244353>;\n\n    Int ans = Int(2).pow(n+m-1) - Int(2).pow(n+m-rank-1);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int p=998244353;\nint a[305][305],b[305][305];\nint read() {\n\tchar c=getchar(); int x=0,f=1;\n\twhile (c<'0' || c>'9') {\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint fpow(int x,int k) {\n\tint ans=1;\n\twhile (k) {\n\t\tif (k&1) ans=1LL*ans*x%p;\n\t\tx=1LL*x*x%p;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n=read(),m=read();\n\tfor (int i=1; i<=n; i++) {\n\t\tfor (int j=1; j<=m; j++) {\n\t\t\ta[i][j]=read();\n\t\t}\n\t}\n\tfor (int i=1; i<=m; i++) {\n\t\tfor (int j=n; j>=1; j--) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tif (b[j][j]) for (int k=1; k<=j; k++) a[i][k]^=b[j][k];\n\t\t\t\telse {\n\t\t\t\t\tfor (int k=1; k<=j; k++) b[j][k]=a[i][k];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tfor (int j=1; j<=n; j++) if (b[j][j]) ++cnt;\n\tprintf(\"%d\\n\", ((fpow(2,n+m-1)-fpow(2,n+m-cnt-1))%p+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 302;\nconst int MOD = 998244353;\n\nstruct equation {\n\n\tvector<int> coeff;\n\tint val;\n\n\tvoid init(int n) {\n\t\tcoeff.resize(n);\n\t\tval = 0;\n\t}\n\n};\n\nint n, m, a[MAX_N][MAX_N];\nequation e[MAX_N];\n\nvoid readInput() {\n\tcin >> n >> m;\n\n\tfor (int i=0; i<n; ++i) {\n\t\tfor (int j=0; j<m; ++j)\n\t\t\tcin >> a[i][j];\n\t}\n}\n\nvoid initEquationSystem() {\n\tfor (int i=0; i<n; ++i) {\n\t\te[i].init(m);\n\t\tfor (int j=0; j<m; ++j)\n\t\t\te[i].coeff[j] = a[i][j];\n\t\te[i].val = 0;\n\t}\n\t// PR0(e[1].coeff, m);\n}\n\nint64_t pw(int n, int k) {\n\tif (k==0)\n\t\treturn 1;\n\n\tint64_t tmp = pw(n, k/2);\n\n\tif (k%2)\n\t\treturn tmp * tmp % MOD * n % MOD;\n\treturn tmp * tmp % MOD;\n}\n\nvoid solve() {\n\tfor (int i=0; i<m; ++i) {\n\t\tfor (int j=i; j<n; ++j)\n\t\t\tif (e[j].coeff[i])\n\t\t\t\tswap(e[i], e[j]);\n\n\t\tfor (int j=i+1; j<n; ++j) {\n\t\t\tif (e[j].coeff[i]==0)\n\t\t\t\tcontinue;\n\t\t\tfor (int k=0; k<m; ++k)\n\t\t\t\te[i].coeff[k] ^= e[i].coeff[k];\n\t\t\te[j].val ^= e[i].val;\n\t\t}\n\t}\n\t// PR0(e[1].coeff, m);\n\n\tint64_t tmp = 1;\n\n\tfor (int i=0; i<m; ++i) {\n\t\tif (i>=n || e[i].coeff[i]==0)\n\t\t\ttmp = tmp * 2 % MOD;\n\t}\n\n\tcout << pw(2, n-1) * (pw(2, m) - tmp + MOD) % MOD;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\treadInput();\n\tinitEquationSystem();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "// by tmt514\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#define SZ(x) ((int)(x).size())\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 998244353;\nLL bigmod(LL a, LL n) {\n  if(n==0) return 1;\n  if(n==1) return a%MOD;\n  return bigmod(a*a%MOD, n/2) * (n%2? a:1)%MOD;\n}\nint main(void) {\n  int n, m;\n  int a[305][305];\n  cin >> n >> m;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      cin >> a[i][j];\n  int rank=0;\n  for(int i=0;i<n;i++) {\n    int g=-1;\n    for(int j=i;j<n;j++)\n      if(a[j][i]==1) {\n        g=j;\n        break;\n      }\n    if(g>=0) {\n      for(int k=i;k<m;k++)\n        swap(a[i][k], a[g][k]);\n      for(int j=i+1;j<n;j++)\n        for(int k=i;k<m;k++)\n          a[j][k] ^= a[i][k];\n      ++rank;\n    }\n  }\n  LL t = bigmod(2, m-1) * (bigmod(2, n) - bigmod(2, n-rank)) % MOD;\n  t=(t+MOD)%MOD;\n  cout << t << endl;\n  \n      \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    auto add = [&m](vector<long>& to, vector<long>& from){\n        for(int i = 0; i < m; ++i)to[i] ^= from[i];\n    };\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)if(a[i][now])add(a[j], a[i]);\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\n\nint compute_rank(vector< vector< double > > A) {\n    int n = A.size();\n    int m = A[0].size();\n\n    int rank = max(n, m);\n    vector<bool> row_selected(n, false);\n    for (int i = 0; i < m; ++i) {\n        int j;\n        for (j = 0; j < n; ++j) {\n            if (!row_selected[j] && abs(A[j][i]) > EPS)\n                break;\n        }\n\n        if (j == n) {\n            --rank;\n        } else {\n            row_selected[j] = true;\n            for (int p = i + 1; p < m; ++p)\n                A[j][p] /= A[j][i];\n            for (int k = 0; k < n; ++k) {\n                if (k != j && abs(A[k][i]) > EPS) {\n                    for (int p = i + 1; p < m; ++p)\n                        A[k][p] -= A[j][p] * A[k][i];\n                }\n            }\n        }\n    }\n    return rank;\n}\n\nvector< vector< double > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    // cout << mod * mod << endl;\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            double x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = compute_rank(a);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n + m - 1);\n    ll nr = fast_pow(2LL, n + m - rank - 1);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD(nn - nr) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\nconst li mod = 998244353;\n\n\nstruct matrix_f2 {\n    typedef unsigned long long bits;\n    vector<vector<bits> > data;\n    const int bits_size;\n    int row, col, array_size;\n\n    static bits bit(const int p) {\n        return 1ULL << p;\n    }\n\n    static matrix_f2 ident (const int d) {\n        matrix_f2 id(d);\n        for (int i = 0; i < d; ++i) {\n            id.set_at(i, i, 1);\n        }\n        return id;\n    }\n\n    matrix_f2 (const int n): bits_size(sizeof(bits) * 8), row(n), col(n), array_size((col + bits_size - 1) / bits_size) {\n        data = vector<vector<bits> >(row, vector<bits>(col, 0));\n    }\n\n    matrix_f2 (const int r, const int c) : bits_size(sizeof(bits) * 8), row(r), col(c), array_size((col + bits_size - 1) / bits_size) {\n        data = vector<vector<bits> >(row, vector<bits>(col, 0));\n    }\n\n    matrix_f2 (const matrix_f2& orig): data(orig.data), bits_size(orig.bits_size), row(orig.row), col(orig.col), array_size(orig.array_size) {\n\n    }\n\n    int get_at (const int i, const int j) const {\n        return (data[i][j / bits_size] >> (j % bits_size)) & 1;\n    }\n\n    void set_at(const int i, const int j, const int v) {\n        int array_pos = j / bits_size;\n        int bit_pos = j - array_pos * bits_size;\n        if (v) {\n            data[i][array_pos] |= bit(bit_pos);\n        } else {\n            data[i][array_pos] &= ~(bit(bit_pos));\n        }\n        return;\n    }\n\n    matrix_f2 trans() const {\n        matrix_f2 ret(col, row);\n        for (int i = 0; i < ret.row; ++i) {\n            for (int j = 0; j < ret.col; ++j) {\n                ret.set_at(i, j, get_at(j, i));\n            }\n        }\n        return ret;\n    }\n\n    matrix_f2 operator+(const matrix_f2& op) const {\n        if (op.row != row || op.col != col) {\n            cerr << \"matrix_f2::operator+ : dimension error.\";\n            return matrix_f2(0);\n        }\n        matrix_f2 ret(row, col);\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < array_size; ++j) {\n                ret.data[i][j] = data[i][j] ^ op.data[i][j];\n            }\n        }\n        return ret;\n    }\n\n    matrix_f2 operator*(const matrix_f2& op) const {\n        if (col != op.row) {\n            cerr << \"matrix_f2::operator* : dimension error.\";\n            return matrix_f2(0);\n        }\n        matrix_f2 ret(row, op.col), opt = op.trans();\n        for (int i = 0; i < ret.row; ++i) {\n            for (int j = 0; j < ret.col; ++j) {\n                int v = 0;\n                for (int k = 0; k < array_size; ++k) {\n                    v ^= __builtin_parityll(data[i][k] & opt.data[j][k]);\n                }\n                ret.set_at(i, j, v);\n            }\n        }\n        return ret;\n    }\n\n    matrix_f2 operator^(const int n) const {\n        if (n == 1) return matrix_f2(*this);\n        if (n == 0) return ident(row);\n        matrix_f2 sqr = *this ^ (n / 2);\n        matrix_f2 ret = sqr * sqr;\n        return n % 2 ? ret * (*this) : ret;\n    }\n\n    void append_vector (const vector<int>& v) {\n        if (row != v.size()) {\n            cerr << \"matrix_f2::append_vector : dimension error.\";\n            return;\n        }\n        const int array_pos = col / bits_size;\n        const int bit_pos = col - array_pos * bits_size;\n\n        if (bit_pos == 0) {\n            for (int i = 0; i < row; ++i) {\n                data[i].push_back(0);\n            }\n            ++array_size;\n        }\n        ++col;\n\n        for (int i = 0; i < row; ++i) {\n            if (v[i]) {\n                data[i][array_pos] |= bit(bit_pos);\n            }\n        }\n        return;\n    }\n\n    int gauss_jordan () {\n        int dim = 0;\n        for (int c = 0; c < col; ++c) {\n            int r = dim;\n            for (; r < row; ++r) {\n                if (get_at(r, c)) break;\n            }\n            if (r == row) continue;\n            swap(data[dim], data[r]);\n\n            for (int r = 0; r < row; ++r) {\n                if (r == dim) continue;\n                if (get_at(r, c)) {\n                    for (int i = 0; i < array_size; ++i) {\n                        data[r][i] ^= data[dim][i];\n                    }\n                }\n            }\n            ++dim;\n        }\n        return dim;\n    }\n\n    void print() {\n        for (int i = 0; i < row; ++i) {\n            for (int j = 0; j < col; ++j) {\n                cout << get_at(i, j) << ' ';\n            }\n            cerr << endl;\n        }\n        return;\n    }\n};\n\n\nli pow(li x, li n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return x;\n    }\n\n    li sq = pow(x, n / 2);\n    if (n & 1) {\n        return sq * sq % mod * x % mod;\n    }\n    return sq * sq % mod;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    matrix_f2 matrix(n, m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int elem;\n            cin >> elem;\n            matrix.set_at(i, j, elem);\n        }\n    }\n\n    li rank = matrix.gauss_jordan();\n\n    vector<li> even(rank + 1, 0), odd(rank + 1, 0);\n    even[0] = 1;\n    for (int i = 1; i <= rank; ++i) {\n        even[i] = (even[i - 1] * 3 + odd[i - 1]) % mod;\n        odd[i] = (odd[i - 1] * 3 + even[i - 1]) % mod;\n    }\n\n    li ans = odd[rank] * pow(2LL, (n - rank) + (m - rank)) % mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T,typename U>bool chmin(T& a,const U& b){return a>b?(a=b,1):0;}\ntemplate<typename T,typename U>bool chmax(T& a,const U& b){return a<b?(a=b,1):0;}\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=998244353;\nconstexpr double EPS=1e-9;\n\ntemplate<uint M>\nstruct modint{\n\tuint val;\n\tmodint(uint x=0):val((x%M+M)%M){}\n\tmodint pow(uint r)const{\n\t\tll a=val,x=1;\n\t\tfor(;r;r>>=1){\n\t\t\tif(r&1)\n\t\t\t\t(x*=a)%=M;\n\t\t\t(a*=a)%=M;\n\t\t}\n\t\treturn x;\n\t}\n\tmodint inv()const{\n\t\tll x=1;\n\t\tfor(ll a=val,b=M,u=0;b;){\n\t\t\tll t=a/b;\n\t\t\tswap(a-=b*t,b);\n\t\t\tswap(x-=u*t,u);\n\t\t}\n\t\treturn (x+M)%M;\n\t}\n\tmodint& operator=(const modint& x)&{val=x.val; return *this;}\n\tmodint& operator+=(const modint& x)&{if((val+=x.val)>=M) val-=M; return *this;}\n\tmodint& operator-=(const modint& x)&{if((val+=M-x.val)>=M) val-=M; return *this;}\n\tmodint& operator*=(const modint& x)&{val=(ll)val*x.val%M; return *this;}\n\tmodint& operator/=(const modint& x)&{val=(ll)val*x.inv().val%M; return *this;}\n\texplicit operator uint()const{return val;}\n};\n\ntemplate<uint M> bool operator==(const modint<M>& a,const modint<M>& b){return a.val==b.val;}\ntemplate<uint M> bool operator!=(const modint<M>& a,const modint<M>& b){return a.val!=b.val;}\ntemplate<uint M> modint<M> operator+(modint<M> a,const modint<M>& b){a+=b; return a;}\ntemplate<uint M> modint<M> operator-(modint<M> a,const modint<M>& b){a-=b; return a;}\ntemplate<uint M> modint<M> operator*(modint<M> a,const modint<M>& b){a*=b; return a;}\ntemplate<uint M> modint<M> operator/(modint<M> a,const modint<M>& b){a/=b; return a;}\ntemplate<uint M> ostream& operator<<(ostream& os,const modint<M>& x){return os<<x.val;}\n\nusing mint=modint<MOD>;\n\nvoid RowReduction(vvi& a)\n{\n\tint m=a.size(),n=a[0].size();\n\tfor(int i=0,j=0;i<m&&j<n;){\n\t\tint p=-1;\n\t\trepi(k,i,m) if(a[k][j]){\n\t\t\tp=k;\n\t\t\tbreak;\n\t\t}\n\t\tif(p==-1){\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\t\tswap(a[i],a[p]);\n\t\trep(k,m) if(k!=i&&a[k][j])\n\t\t\trepi(l,j,n)\n\t\t\t\ta[k][l]^=a[i][l];\n\t\ti++,j++;\n\t}\n}\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tfor(int m,n;cin>>m>>n&&m|n;){\n\t\tvvi a(m,vi(n));\n\t\trep(i,m) rep(j,n) cin>>a[i][j];\n\t\tRowReduction(a);\n\t\tint r=0;\n\t\trep(i,m) r+=any_of(all(a[i]),[](int x){return x;});\n\t\tmint res=(mint(2).pow(n)-mint(2).pow(n-r))*mint(2).pow(m-1);\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nint a[305][305];\n\nvoid swapRows(int mat[305][305], int i, int j, int w)\n{\n\tfor(int k = 0; k < w; k++) swap(mat[i][k], mat[j][k]);\n}\n\nvoid GaussianElimination(int mat[305][305], int w, int h)\n{\n\tint r = 0;\n\tfor(int i = 0; i < w && r < h; i++){\n\t\tif(mat[i][r] == 0){\n\t\t\tint max_val = 0, max_j;\n\t\t\tfor(int j = r+1; j < h; j++){\n\t\t\t\tif(mat[j][i] > max_val){\n\t\t\t\t\tmax_val = mat[j][i];\n\t\t\t\t\tmax_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max_val == 0) goto end;\n\t\t\tswapRows(mat, r, max_j, w);\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < h; j++){\n\t\t\tif(j == r) continue;\n\t\t\tif(mat[j][i] == 0) continue;\n\t\t\tfor(int k = 0; k <= w; k++){\n\t\t\t\tmat[j][k] ^= mat[r][k];\n\t\t\t}\n\t\t}\n\t\tr++;\n\t\tend:;\n\t}\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\t\n\tGaussianElimination(a, w, h);\n\t\n\tllint rank = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tbool flag = false;\n\t\tfor(int j = 0; j < w; j++) if(a[i][j]) flag = true;\n\t\tif(flag) rank++;\n\t}\n\t\n\tllint nsize = 1, dsize = 1;\n\tfor(int i = 0; i < h-rank; i++) nsize *= 2, nsize %= mod;\n\tfor(int i = 0; i < h; i++) dsize *= 2, dsize %= mod;\n\tllint ans = (dsize - nsize + mod) % mod;\n\tfor(int i = 0; i < w-1; i++) ans *= 2, ans %= mod;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst ll mod=998244353;\nconst int maxn=310;\nint n,m,cnt;\nll mi[maxn],ans;\nbitset<maxn> a,p[maxn];\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m); mi[0]=1; int x;\n\tfor (int i=1;i<=max(n,m);i++) mi[i]=mi[i-1]*2%mod;\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=0;j<m;j++) read(x),a.set(j,x);\n\t\tfor (int j=m-1;j>=0;j--) {\n\t\t\tif (a[j]==0) continue;\n\t\t\tif (p[j].none()) { p[j]=a; cnt++; break; }\n\t\t\ta^=p[j];\n\t\t}\n\t}\n\tans=(mi[n]-mi[n-cnt]+mod)*mi[m-1]%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MOD 998244353\n#define MAX 350\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint fpow(int a,int b)\n{\n\tint s=1;\n\twhile(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}\n\treturn s;\n}\nint n,m,a[MAX][MAX],s[MAX];\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=m;++j)\n\t\t\ts[i]+=(a[i][j]=read());\n\tint tot=0;\n\tfor(int i=1;i<=n;++i)tot+=s[i]==0;\n\tint ans=1ll*(fpow(2,n)-fpow(2,tot)+MOD)*fpow(2,m-1)%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fec(i, x, y) (int i = head[x], y = g[i].to; i; i = g[i].ne, y = g[i].to)\n#define dbg(...) fprintf(stderr, __VA_ARGS__)\n#define File(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n#define fi first\n#define se second\n#define pb push_back\n\ntemplate<typename A, typename B> inline char SMAX(A &a, const B &b) {return a < b ? a = b , 1 : 0;}\ntemplate<typename A, typename B> inline char SMIN(A &a, const B &b) {return b < a ? a = b , 1 : 0;}\n\ntypedef long long ll; typedef unsigned long long ull; typedef std::pair<int, int> pii;\n\ntemplate<typename I>\ninline void read(I &x) {\n\tint f = 0, c;\n\twhile (!isdigit(c = getchar())) c == '-' ? f = 1 : 0;\n\tx = c & 15;\n\twhile (isdigit(c = getchar())) x = (x << 1) + (x << 3) + (c & 15);\n\tf ? x = -x : 0;\n}\n\nconst int N = 300 + 7;\nconst int P = 998244353;\n\nint n, m, a[N][N], b[N][N], r;\n\ninline int fpow(int x, int y) {\n\tint ans = 1;\n\tfor (; y; y >>= 1, x = (ll)x * x % P) if (y & 1) ans = (ll)ans * x % P;\n\treturn ans;\n}\n\nint main() {\n\t#ifdef hzhkk\n\tfreopen(\"hkk.in\", \"r\", stdin);\n\t#endif\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= m; ++j) read(a[i][j]);\n\tfor (int i = 1; i <= n; ++i){\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tif (a[i][j])\n\t\t\t\tif (!b[j][j]) {\n\t\t\t\t\tfor (int k = 1; k <= m; ++k) b[j][k] = a[i][k];\n\t\t\t\t\t++r;\n\t\t\t\t\tbreak;\n\t\t\t\t} else for (int k = 1; k <= m; ++k) a[i][k] ^= b[j][k];\n\t}\n\tprintf(\"%lld\\n\", (ll)fpow(2, m - 1) * (fpow(2, n) + P - fpow(2, n - r)) % P);\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nostream &operator<<(ostream &os, const pint &a) { os << \"(\" << a.fi << \",\" << a.se << \")\"; return os; }\nostream &operator<<(ostream &os, const vector<int> &a) {\n\tos<<\"[\";\n\trep(i,a.size()){\n\t\tos<<a[i];\n\t\tif(i<a.size()-1) os<<\",\";\n\t}\n\tos<<\"]\";\n\treturn os; \n}\nvector<vector<int> > mat;\nint ma[334][334];\nlint mo=998244353;\nlint zyo(lint x,lint y){\n    lint ret=1,a=x;\n    while(y>0){\n    \tif(y%2==1) ret=(ret*a)%mo;\n    \ta=(a*a)%mo;y/=2;\n    }\n    return ret;\n}\nint main()\n{\n\tmemset(ma,0,sizeof(ma));\n\tint n,m;\n\tcin>>n>>m;\n\trep(i,n) rep(j,m) cin>>ma[i][j];\n\tif(n<m){\n\t\trep(i,m) REP(j,i+1,m) swap(ma[i][j],ma[j][i]);\n\t\tswap(n,m);\n\t}\n\trep(i,n){\n\t\tvector<int> cl(m,0);\n\t\tmat.pb(cl);\n\t\trep(j,m) mat[i][j]=ma[i][j]%2;\n\t}\n\t//rep(i,n) cout<<mat[i]<<endl;\n\t//rep(i,n) rep(j,m) mat[i][j]%=2;\n\tint rank=0;\n\trep(i,m){\n\t\t//if(rank>=m) continue;\n\t\tREP(j,rank,n){\n\t\t\tif(mat[j][i]>0) swap(mat[j],mat[rank]);\n\t\t}\n\t\tif(mat[rank][i]<1){\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,n){\n\t\t\tif(j==rank || mat[j][i]==0) continue;\n\t\t\tREP(k,i,m){\n\t\t\t\t//if(k<i) assert(mat[rank][k]==0);\n\t\t\t\tmat[j][k]+=mat[rank][k];mat[j][k]%=2;\n\t\t\t}\n\t\t}\n\t\trank++;\n\t}\n\t//rep(i,n) cout<<mat[i]<<endl;\n\t//cout<<n<<m<<rank<<endl;\n\t//lint zyo=1;rep(i,rank) zyo=(zyo*2)%mo;zyo--;\n\tlint out=zyo(2,rank);out--;\n\tout*=zyo(2,m-1);out%=mo;\n\tout*=zyo(2,n-rank);out%=mo;\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=310;\nconst int mod=998244353;\nbitset<MAXN>a[MAXN],b[MAXN];\nint n,m,x,ans;\nlong long poww(long long x,long long y)\n{\n\tlong long ans=1;\n\tfor (;y;y>>=1,x=(x*x)%mod) if (y&1) ans=(ans*x)%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\tfor (int j=1;j<=m;j++) \n\t{\n\t\tscanf(\"%d\",&x);\n\t\tif (x==1) a[i].set(j);\n\t}\n\t}    for (int i=1;i<=n;i++)\n    {\n    \tfor (int j=1;j<=m;j++) \n    \t\tif (!a[i][j]) continue;\n    \telse\n    \t\tif (!b[j].any()) {\n    \t\t\tb[j]=a[i]; break;\n    \t\t}\n    \t\telse a[i]^=b[j];\n    }\n    for (int i=1;i<=max(n,m);i++) if (b[i].any()) ans++;\n    cout << (poww(2,n)-poww(2,n-ans)+mod)%mod*poww(2,m-1)%mod << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n\n        for(int j = i+1; j < n; j++) if(mat[j][i]) {\n\n            for(int k = rank; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k];\n            }\n        }\n\n        rank++;\n    }\n\n    return rank;\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DEBUG_OUTPUT_ENABLED 1\n\t#define DBG(X) dout << #X << \"=\" << (X) << '\\n';\n\t#define SAY(X) dout << (X) << '\\n';\n\t#define dout   __debug::instance\n#else\n\t#define DEBUG_OUTPUT_ENABLED 0\n\t#define DBG(X) 42;\n\t#define SAY(X) 42;\n\t#define dout CannotCompileBecauseOfDebugOutput\n#endif\n\nusing namespace std;\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld  = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const set<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const multiset<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\nnamespace __debug {\n\tstruct DebugStream {\n\t\tprivate:\n\t\t\tbool is_first;\n\t\tpublic:\n\t\t\tDebugStream(bool _is_first): is_first(_is_first) {}\n\t\t\ttemplate<typename T> DebugStream operator<<(const T& value) const {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\tcout << value;\n\t\t\t\treturn DebugStream(false);\n\t\t\t};\n\n\t\t\ttemplate<typename T> DebugStream printArray(T* l, T* r) {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\twhile(l != r) {\n\t\t\t\t\tcout << (*l);\n\t\t\t\t\t++l;\n\t\t\t\t\tif(l == r) {\n\t\t\t\t\t\tcout << '\\n';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn DebugStream(false);\n\t\t\t}\n\t};\n\tDebugStream instance(true);\n};\n\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF  = (ll)(2e18);\n\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T> inline T fetch() { T ret; cin >> ret; return ret; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for(auto& elem: ret) cin >> elem; return ret; }\nconst int MAXN = 307;\nconst int MOD  = 998244353;\ninline int add(int x, int y) {\n\treturn (x + y >= MOD ? x + y - MOD : x + y);\n}\ninline int sub(int x, int y) {\n\treturn (x - y < 0 ? x - y + MOD : x - y);\n}\ninline int mult(int x, int y) {\n\tll r = x * 1LL * y;\n\tif(r >= MOD) r %= MOD;\n\treturn (int)r;\n}\nint pw2[MAXN];\nbitset<MAXN> G[MAXN], basis[MAXN];\nint n, m;\ninline int GaussAdd(bitset<MAXN> v) {\n\tfor(int i = 0; i < MAXN; ++i) if(v[i]) {\n\t\tif(basis[i].count()) {\n\t\t\tv ^= basis[i];\n\t\t} else {\n\t\t\tbasis[i] = v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid solve() {\n\tpw2[0] = 1;\n\tfor(int i = 1; i < MAXN; ++i) pw2[i] = add(pw2[i - 1], pw2[i - 1]);\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; ++i) for(int j = 0; j < m; ++j) G[i][j] = fetch<int>();\n\tint szBasis = 0;\n\tfor(int i = 0; i < n; ++i) szBasis += GaussAdd(G[i]);\n\tint countZero = pw2[n - szBasis];\n\tint countNonZero = sub(pw2[n], countZero);\n\tint answ = mult(countNonZero, pw2[m - 1]);\n\tcout << answ << '\\n';\n}\n\nint main() {\n\tfast_io();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n    long N, M;\n    cin >> N >> M;\n    vector<vector<long>> a(N, vector<long>(M));\n    long s(0);\n    for(auto& i : a)\n        for(auto& j : i){\n            scanf(\"%ld\", j);\n            s += j;\n        }\n    if(s & 1){\n        cout << modpow(N + M - 1) << endl;\n    }\n    else{\n        puts(\"sorry\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n//        mat<COL_SIZE> b(r);\n//        for(int i = 0; i < r; i++) b[i] = a[i];\n        auto b = a;\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n        return a[index];\n    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<305>a(m+5);\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = a.rank();\n    cerr << r << endl;\n    cout << (mod_pow(2,n+m-1) - mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int Mod=998244353;\nint n,m;\n#define Maxn 305\nint num[Maxn][Maxn];\nbool vis[Maxn];\nint val[Maxn][Maxn];\ninline int Fast_Pow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*a%Mod;\n\t\ta=1ll*a*a%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\ninline void rd(int &x){\n\tx=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')ch=getchar();\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t}\n}\n\nint main(){\n\trd(n);rd(m);\n\tfor(register int i=1;i<=n;++i)\n\t    for(register int j=1;j<=m;++j)rd(num[i][j]);\n\tint res=Fast_Pow(2,n);\n\tint T=0;\n\tfor(register int i=1;i<=n;++i)\n\t    for(register int j=m;j>=1;--j)\n\t        if(num[i][j]){\n\t\t\t\tif(!vis[j]){\n\t\t\t\t\tfor(register int k=1;k<=m;++k)val[j][k]=num[i][k];\n\t\t\t\t\tvis[j]=true;\n\t\t\t\t\tT++;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tfor(register int k=1;k<=m;++k)num[i][k]^=val[j][k];\n\t\t\t\t}\n\t        }\n\tres=(res-Fast_Pow(2,n-T)+Mod)%Mod;\n\tprintf(\"%d\\n\",1ll*res*Fast_Pow(2,m-1)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nvoid radd(int &x, int y)\n{\n\tx=add(x,y);\n}\n\ntypedef bitset<350> b100;\n\nb100 mini(b100 a, b100 b)\n{\n\tfor(int i=332;i>=0;i--)\n\t{\n\t\tif(a[i]!=b[i])\n\t\t{\n\t\t\tif(a[i]) return b;\n\t\t\telse return a;\n\t\t}\n\t}\n\treturn a;\n}\n\nstruct gausselim\n{\n\tll cnt[333][2];\n\tint rank;\n\tb100 cyc[333];\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < 333; i++)\n\t\t{\n\t\t\tcyc[i] = cnt[i][0] = cnt[i][1] = 0;\n\t\t}\n\t\trank = 0;\n\t}\n\tvoid addval(b100 x)\n\t{\n\t\tfor(int i = 0; i < 333; i++)\n\t\t{\n\t\t\tcnt[i][x[i]]++;\n\t\t}\n\t}\n\tvoid add(b100 x)\n\t{\n\t\tfor(int i = 332; i >= 0; i--)\n\t\t{\n\t\t\tif(x[i])\n\t\t\t{\n\t\t\t\tif(cyc[i]==0)\n\t\t\t\t{\n\t\t\t\t\tcyc[i] = x;\n\t\t\t\t\trank++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = mini(x, (x^cyc[i]));\n\t\t}\t\n\t}\n};\n\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tgausselim g; g.init();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tb100 b; b.reset();\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tint x; cin>>x;\n\t\t\tif(x) b.set(j,1);\n\t\t}\n\t\tg.add(b);\n\t}\n\tcout<<mult(modpow(2,m-1),add(modpow(2,n),MOD-modpow(2,n-g.rank)))<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate<Int MOD>\nstruct ModInt {\n    constexpr static Int mod = MOD;\n    Int v;\n\n    ModInt(long long _v = 0) : v(set(_v)) {}\n    ModInt(const ModInt &r) : v(set(r.v)) {}\n\n    inline static Int set(const Int x) { return x < 0 ? (x % mod) + mod : x % mod; }\n    inline void set() { v = set(v); }\n\n    bool operator<(ModInt r) const { return v < r.v; }\n    bool operator>(ModInt r) const { return r.v < v; }\n    bool operator==(ModInt r) const { return v == r.v; }\n    bool operator!= (ModInt r) const { return v != r.v; }\n\n    ModInt operator-() const { return ModInt(v ? mod - v : v); }\n    ModInt &operator=(const ModInt &r) { if (this != &r) v = set(r.v); return *this; }\n    ModInt &operator+=(ModInt r) { (v += r.v) %= mod; return *this; }\n    ModInt &operator-=(ModInt r) { (v -= r.v - mod) %= mod; return *this; }\n    // ModInt &operator*=(ModInt r) { v = (__uint128_t(v) * r.v) % mod; return *this; }\n    ModInt &operator*=(ModInt r) { v = 1ULL * v * r.v % mod; return *this; }\n    ModInt &operator/=(ModInt r) { *this *= r.inv(); return *this; }\n    ModInt operator+(ModInt r) const { return ModInt(*this) += r; }\n    ModInt operator-(ModInt r) const { return ModInt(*this) -= r; }\n    ModInt operator*(ModInt r) const { return ModInt(*this) *= r; }\n    ModInt operator/(ModInt r) const { return ModInt(*this) /= r; }\n\n    ModInt inv() const {\n        long long a = v, b = mod, u = 1, w = 0;\n        while (b) {\n            long long t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * w, w);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(Int e) {\n        ModInt a = *this, x(1);\n        for ( ; 0 < e; e >>= 1) { if (e & 1) x *= a; a *= a; }\n        return x;\n    }\n    inline ModInt pow(ModInt &e) { return pow(e.v); }\n};\n\nstd::ostream &operator<<(std::ostream &os, const auto &r) { return os << r.v; }\nstd::istream &operator>>(std::istream &is, auto &r) { is >> r.v; r.set();return is; }\n\nusing Mod2 = ModInt<2>;\nusing Type = ModInt<998244353>;\nusing Vector = vector<Mod2>;\nusing Matrix = vector<Vector>;\n\nint Rank(Matrix &A) {\n    const int N = A.size(), M = A[0].size();\n    int rank = 0;\n    vector<bool> used(N, false);\n\n    for (int c = 0; c < M; ++c) {\n        int pivot = 0;\n        while (pivot < N && (used[pivot] || A[pivot][c] == 0)) ++pivot;\n        if (pivot == N) continue;\n\n        ++rank;\n        used[pivot] = true;\n        Mod2 v = A[pivot][c];\n        for (int j = 0; j < N; ++j) A[pivot][j] /= v;\n        for (int r = 0; r < N; ++r) {\n            if (r == pivot) continue;\n            for (int j = c + 1; j < M; ++j)\n                A[r][j] -= A[r][c] * A[pivot][j];\n        }\n    }\n\n    return rank;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    Matrix A(n, Vector(m));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            cin >> A[i][j];\n\n    int rank = Rank(A);\n    Type res = Type(2).pow(m + n - 1) - Type(2).pow(m + n - rank - 1);\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"out2.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n#define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \n// void bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid amax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid amin(T& x, T y) {\n    x = min(x, y);\n}\n\n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-12;\nconst int maxn = 5e4 + 3, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst int base2 = 998244353;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % base2;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % base2;\n    }\n}\n\nconst int N = 305;\n\nint gauss (vector < bitset<N> > a, int n, int m) {    \n    vector<int> where (m, -1);\n    \n    int rank = max(n, m);\n    for (int col=0, row=0; col<m && row<n; ++col) {\n        for (int i=row; i<n; ++i)\n            if (a[i][col]) {\n                swap (a[i], a[row]);\n                break;\n            }\n        if (!a[row][col]) {\n            rank--;\n            continue;\n        }\n        where[col] = row;\n\n        for (int i=0; i<n; ++i)\n            if (i != row && a[i][col])\n                a[i] ^= a[row];\n        ++row;\n    }\n\n    return rank;\n}\n\nint main() {\n    // files1;\n\n    int n, m;\n    cin >> n >> m;\n    vector<bitset<N> > a(n);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            bool x;\n            cin >> x;\n            a[i][j] = x;\n        }\n\n    int r = gauss(a, n, m);\n    cout << ((binpow(2, n + m - 1) - binpow(2, n + m - r - 1)) % base2 + base2) % base2;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 998244353;\n\n// 階段行列を求める O(min(H,W)HW/64)\n// 列に応じてbitsetのbit長を変えろ\nusing mat = vector<bitset<305>>;\nmat gauss_jordan(mat a) {\n    const int h = a.size(), w = a[0].size();\n    int rank = 0;\n    REP(i, min(w, h)) {\n        int pivot = -1;\n        FOR(j, rank, h) if(a[j][i]) {pivot = j; break;}\n        if(pivot == -1) continue;\n        swap(a[rank], a[pivot]);\n        REP(j, h) if(j != rank && a[j][i]) a[j] ^= a[rank];\n        rank++;\n    }\n    return a;\n}\n\n// 二分累乗\nll binpow(ll x, ll e) {\n  ll ret = 1, p = x;\n  while(e > 0) {\n    if(e&1) {(ret *= p) %= MOD; e--;}\n    else {(p *= p) %= MOD; e /= 2;} \n  }\n  return ret;\n};\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll h, w;\n    cin >> h >> w;\n    mat a(h);\n    REP(i, h) REP(j, w) {\n        ll b; cin >> b;\n        if(b) a[i].set(j);\n    }\n\n    auto ret = gauss_jordan(a);\n    ll rank = h;\n    REP(i, h) {\n        bool flag = false;\n        REP(j, w) if(ret[i][j]) flag = true;\n        if(!flag) {\n            rank = i;\n            break;\n        }\n    }\n\n    // (2^h - 2^(h-rank)) * 2^(w-1)\n    ll ans = ((binpow(2, h) - binpow(2, h-rank)) % MOD + MOD) % MOD;\n    (ans *= binpow(2, w-1)) %= MOD;\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define rollcall cout << \"I'm Sucu.\" << endl;\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define fi first\n#define se second\n// debug\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p){\n  os << \"(\" << p.first << \",\" << p.second << \")\";return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v){\n  for (auto it = v.begin();it != v.end();++it){\n    if(it != v.begin())os << \" \";os << *it;\n      }return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp){\n  for(auto x: mp)os << \"(\" << x.first << \",\" << x.second << \")\" << endl;\n  return os;\n}\ntemplate<typename T, int SIZE>\nint array_length(const T (&)[SIZE]){return SIZE;}\ntemplate<typename T, int N>\nvoid PRINTF(const T (&a)[N], int s = N, int t = -1, bool f = true){\n\tif(t == -1){rep(i,s){if(i)cout << \" \";cout << a[i];}}\n\telse repi(i,s,t){if(i!=s)cout << \" \";cout << a[i];}\n\tif(f)cout << \"\\n\";\n}\ntemplate<typename T, int N1, int N2>\nvoid PRINTF(const T (&a)[N1][N2], int h = N1, int w = N2){\n\trep(i,h){rep(j,w){cout << a[i][j] << \" \\n\"[j==w-1];}}\n}\nstring substr(const string &str, int S1, int S2 = -1){\n  if(S2 == -1)return str.substr(S1);\n  return str.substr(S1, S2-S1);\n}\n// typedef\ntypedef complex<double> Point;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nconst int mod = 998244353;\n\nvector<int> mat[400];\nvoid XOR(vi &A, vi &B){\n  int n = A.size();\n  rep(i,n)A[i] ^= B[i];\n}\n\nint Pow(int x, int n){\n  if(n < 0)n += mod-1;\n  int ans = 1;\n  while(n > 0){\n    if(n & 1)ans = (ans*x)%mod;\n    x = (x*x)%mod;\n    n >>= 1;\n  }\n  return ans;\n}\n\nint calc_rank(int h, int w){\n  int r = 0;\n  rep(j,w){\n    int pivot = -1;\n    rep(i,h)if(mat[i][j]){\n      pivot = i;break;\n    }\n    if(pivot == -1)continue;\n    swap(mat[pivot], mat[r]);\n    rep(i,h)if(i != pivot){\n      if(mat[i][j])XOR(mat[i], mat[pivot]);\n    }\n    r++;\n  }\n  return r;\n}\n\nsigned main(){\n  int h, w;\n  scanf(\"%lld%lld\", &h, &w);\n  rep(i,h)rep(j,w){\n    int tmp;scanf(\"%lld\", &tmp);\n    mat[i].pb(tmp);\n  }\n  int r = calc_rank(h, w);\n  int ans = Pow(2, h)-Pow(2, h-r);\n  ans = (ans%mod)*Pow(2, w-1);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = 305, mod = 998244353;\nint n, m, pow2[N << 1];\nvector< bitset<N> > basis;\n\nvoid updBasis(bitset<N> val) {\n    for (int i = 0; i < (int)basis.size(); ++i) {\n        if (!val.count() ) return ;\n        auto _ = basis[i];\n        int f_ = -1;\n        for (int j = 0; j < N; ++j) if (_[j]) f_ = j;\n        int fVal = -1;\n        for (int j = 0; j < N; ++j) if (val[j]) fVal = j;\n        if (f_ == fVal) val ^= _;\n        else {\n            if (f_ < fVal) basis.insert(basis.begin() + i, val);\n            else basis.insert(basis.begin() + i + 1, val);\n            return ;\n        }\n    }\n    if (val.count() ) basis.push_back(val);\n}\n\nint add(int _a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n    return _a;\n}\nint sub(int _a, int _b) { return add(_a, mod - _b); }\nint mul(int _a, int _b) { return (int)( (ll)_a * _b % mod); }\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        bitset<N> val;\n        for (int j = 1; j <= m; ++j) {\n            int a; cin >> a;\n            val[j] = a;\n        }\n        updBasis(val);\n    }\n\n    pow2[0] = 1; for (int i = 1; i < (N << 1); ++i) pow2[i] = (int)(2 * pow2[i - 1] % mod);\n\n    cout << sub(pow2[n + m - 1], pow2[n + m - 1 - (int)basis.size()]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353; //1000000007;\n\n\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    vector<vector<ll>> a(n,vector<ll>(m));\n    for(auto &I:a){\n        for(auto &T:I){cin>>T;}\n    }\n    vector<vector<ll>> b(n,vector<ll>(m));\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        for(int h=i;h<n;h++){\n            for(int w=0;w<m;w++){b[h][w]=a[h][w];}\n        }\n        for(int h=i;h<n;h++){\n            for(int w=1;w<m;w++){\n                b[h][w]+=b[h][w-1];\n                b[h][w]&=1;\n            }\n        }\n        for(int h=i+1;h<n;h++){\n            for(int w=0;w<m;w++){\n                b[h][w]+=b[h-1][w];\n                b[h][w]&=1;\n            }\n        }\n        for(int h=i;h<n;h++){\n            ll cnt0=1,cnt1=0;\n            for(int w=0;w<m;w++){\n                if(b[h][w]&1){ans+=cnt0; cnt1++; ans%=MOD; cnt1%=MOD;}\n                else{ans+=cnt1; cnt0++; ans%=MOD; cnt0%=MOD;}\n            }\n        }\n    }\n    ans%=MOD;\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = rank; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[rank]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n\n        for(int j = rank+1; j < n; j++) if(mat[j][i]) {\n\n            for(int k = rank; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k];\n            }\n        }\n\n        rank++;\n    }\n\n    return rank;\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"E.in\", \"r\", stdin);\n\tfreopen (\"E.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 310, Mod = 998244353;\n\ninline int fpm(int x, int power) {\n\tint res = 1;\n\tfor (; power; power >>= 1, x = 1ll * x * x % Mod)\n\t\tif (power & 1) res = 1ll * res * x % Mod;\n\treturn res;\n}\n\nusing Info = bitset<N>;\n\nInfo A[N];\n\nint n, m;\n\nstruct Linear_Base {\n\n\tInfo Base[N]; int res = 0;\n\n\tvoid Insert(Info cur) {\n\t\tbool flag = false;\n\t\tFordown (i, m, 1) \n\t\t\tif (cur[i]) {\n\t\t\t\tif (Base[i].any()) cur ^= Base[i];\n\t\t\t\telse { Base[i] = cur; flag = true; break; }\n\t\t\t}\n\t\tif (!flag) ++ res; \n\t}\n\n} T;\n\n\nint main () {\n\t\n\tFile();\n\n\tn = read(); m = read();\n\n\tFor (i, 1, n) {\n\t\tFor (j, 1, m) A[i][j] = read();\n\t\tT.Insert(A[i]);\n\t}\n\n\tint ans = 1ll * (fpm(2, n) - fpm(2, T.res) + Mod) * fpm(2, m - 1) % Mod;\n\tprintf (\"%d\\n\", ans);\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define mp make_pair\n\nvoid print(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cout<<a[i]<<' ';\n    cout<<endl;\n}\n\nvoid get(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cin>>a[i];\n}\n\nconst ll p = 998244353;\n\nll mul(ll a, ll b) {\n    return (1LL * a * b) % p;\n}\n\nll add(ll a, ll b) {\n    int s = (a+b);\n    s = s%p;\n    if (s<0) s+=p; \n    return s;\n}\n\nll po(ll a, ll  deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    ll t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    \n    int n, m;\n    cin>>n>>m;\n    \n    vector<bitset<320>> a(n);\n    \n    \n    \n    bool t;\n    \n    for (int i = 0; i<n; i++)\n    for (int j = 0; j<m; j++) {cin>>t; a[i][j] = t;}\n    \n    vector<bool> visited(n);\n    \n    int degbasis = 0;\n    \n    for (int i = 0; i<m; i++)\n    {\n        int idx = 0;\n        while (idx<n && !(a[idx][i]==1&&!visited[idx])) idx++;\n        if (idx==n) continue;\n        visited[idx] = true;\n        degbasis++;\n        for (int j = 0; j<n; j++) if (j!=idx&&a[j][i]==1) a[j]^=a[idx];\n    }\n    \n    //cout<<degbasis<<endl;\n    \n    ll total = po(2, m+n - 1) - po(2, m+n-1-degbasis);\n    total%=p;\n    if (total<0) total+=p;\n    cout<<total;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll N=3000+7;\nconst ll MOD=998244353;\n\nll add(ll a,ll b)\n{\n        ll s=a+b;\n        s%=MOD;\n        s+=MOD;\n        s%=MOD;\n        return s;\n}\n\nll mul(ll a,ll b)\n{\n        return a*(long long)b%MOD;\n}\n\nll expow(ll a,ll b)\n{\n        ll res=1;\n        while(b)\n        {\n                if(b&1)\n                {\n                        res=mul(res,a);\n                }\n                a=mul(a,a);\n                b>>=1;\n        }\n        return res;\n}\n\nll inv(ll n)\n{\n        return expow(n,MOD-2);\n}\n\nll fact[N];\n\nll comb(ll n,ll k)\n{\n        ll x=fact[n];\n        ll y=mul(fact[k],fact[n-k]);\n        y=expow(y,MOD-2);\n        return mul(x,y);\n}\n\nll n,m;\n\nll mll;\n\nmap<vector<ll>,ll>freq;\n\nint32_t main()\n{\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n      //  freopen(\"input\",\"r\",stdin);\n      //  freopen(\"output\",\"w\",stdout);\n        fact[0]=1;\n        for(ll i=1;i<N;i++)\n        {\n                fact[i]=mul(fact[i-1],i);\n        }\n        ll cnt0=0;\n        cin>>n>>m;\n        mll=expow(2,m);\n        for(ll i=1;i<=n;i++)\n        {\n                vector<ll>ugar;\n                bool g=0;\n                for(ll j=1;j<=m;j++)\n                {\n                        ll x;\n                        cin>>x;\n                        ugar.push_back(x);\n                        if(x)\n                        {\n                                g=1;\n                        }\n                }\n              ///  sort(ugar.begin(),ugar.end());\n                if(g==0) cnt0++;\n                freq[ugar]++;\n        }\n        ll tot=expow(2,n);\n        ll sum=0;\n        for(auto &it:freq)\n        {\n                ll cnt=it.second;\n                sum+=cnt-1;\n        }\n       /// cout<<cnt0<<\"\\n\";\n        if(cnt0>0) sum++;\n        ll lft=add(tot,-expow(2,sum));\n      ///  cout<<\"=\"<<lft<<\"\\n\";\n        ll res=mul(lft,mll);\n       /// cout<<tot-lft<<\"\\n\";\n        res=mul(res,inv(2));\n        cout<<res<<\"\\n\";\n        return 0;\n        cout<<\"A: \"<<res<<\"\\n\";\n        return 0;\n}\n/**\n\n**/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing ll = long long;\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t pos = 0;\n    for (std::size_t i = 0; i < mat.C; i++) {\n        if (pos == mat.R) { break; }\n        std::size_t piv = pos;\n        for (std::size_t k = pos + 1; k < mat.R; k++) {\n            if (mat[k][i] != 0) { piv = k; }\n        }\n        if (mat[piv][i] == 0) { continue; }\n        std::swap(mat[pos], mat[piv]);\n        for (std::size_t j = i + 1; j < mat.C; j++) { mat[pos][j] /= mat[pos][i]; }\n        for (std::size_t j = pos + 1; j < mat.R; j++) {\n            for (std::size_t k = i + 1; k < mat.C; k++) { mat[j][k] -= mat[pos][k] * mat[j][i]; }\n        }\n        pos++;\n    }\n    return pos;\n}\nconstexpr ll MOD = 998244353LL;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<ll> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<ll> bp(600, 1LL);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2 % MOD; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD) % MOD << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nconst int mod=998244353;\nint n,m,a[N][N],now[N],in[N],p[N][N],r;\ninline int poww(int a,int b){\n  int res=1;\n  for(;b;b>>=1,a=1ll*a*a%mod)\n    if(b&1)res=1ll*res*a%mod;\n  return res;\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=m;j++) scanf(\"%d\",&a[i][j]);\n  for(int i=1;i<=n;i++){\n    memcpy(now,a[i],sizeof(now));\n    for(int j=1;j<=m;j++)\n      if(now[j]){\n    if(in[j])for(int k=j;k<=m;k++)now[k]^=p[j][k];\n    else{in[j]=1;memcpy(p[j],now,sizeof(p[j]));r++;break;}\n      }\n  }\n  printf(\"%lld\\n\",1ll*(poww(2,n)-poww(2,n-r)+mod)%mod*poww(2,m-1)%mod);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nconst int N=700;\nint n,m,a[N][N];\nint od[N],ev[N],bit[N],xxj[N];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n\n\tint u=max(n,m);\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=u;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i])\n\t\t{\n\t\t\tint fl=0;\n\t\t\tfor(int j=i+1;j<=m;j++) fl|=a[i][j];\n\t\t\tif(fl) swap(a[i],a[++u]);\n\t\t\tcontinue;\n\t\t}\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=u;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n/*\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tif(xxj[j])\n\t\t\t\t\tfor(int k=j;k<=m;k++)\n\t\t\t\t\t\ta[i][k]^=a[xxj[j]][k];\n\t\t\t\telse {xxj[j]=i;cnt++;break;}\n\t\t\t}\n\t}\n*/\tbit[0]=1;\n\tfor(int i=1;i<=u;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\nconst int N = 500;\nint gauss (vector < bitset<N> > a, int n, int m) {\n    vector<int> where (m, -1);\n    for (int col=0, row=0; col<m && row<n; ++col) {\n        for (int i=row; i<n; ++i)\n            if (a[i][col]) {\n                swap (a[i], a[row]);\n                break;\n            }\n        if (! a[row][col])\n            continue;\n        where[col] = row;\n\n        for (int i=0; i<n; ++i)\n            if (i != row && a[i][col])\n                a[i] ^= a[row];\n        ++row;\n    }\n\n    int rank = n;\n\n    for(int i = 0 ; i < n ; i++){\n        bool has_one = false;\n\n        for(int j = 0 ; j < m ; j++){\n            if(a[i][j]){\n                has_one = true;\n                break;\n            }\n        }\n\n        if(!has_one){\n            rank--;\n        }\n    }\n\n    return rank;    \n}\n\nvector< bitset< N > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    // cout << mod * mod << endl;\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            int x;\n            cin >> x;\n            a[i][j] = x; \n        }\n    }\n\n    int rank = gauss(a, n, m);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n + m - 1);\n    ll nr = fast_pow(2LL, n + m - rank - 1);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD(nn - nr) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const {\n        long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u);\n    }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r;\n}\ntypedef ModInt<998244353> mint;\nint gauss(vector<vector<int>> A) {\n    int n = A.size(), m = A[0].size();\n    int r = 0;\n    for (int i = 0; r < n && i < m; ++i) {\n        int piv = r;\n        rep(j, r + 1, n) if (A[j][i] > A[piv][i]) piv = j;\n        A[r].swap(A[piv]);\n        if (abs(A[r][i]) == 0) continue;\n        rrep(k, m - 1, i) A[r][k] /= A[r][i];\n        rep(j, r + 1, n) rrep(k, m - 1, i) A[j][k] ^= A[r][k] * A[j][i];\n        ++r;\n    }\n    return r;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nint N, M;\nint v[606];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n\n    vector<vector<int>> v(N, vector<int>(M));\n\n    rep(i, 0, N) rep(j, 0, M) {\n        int a; cin >> a;\n        v[i][j] = a;\n    }\n\n    int R = gauss(v);\n\n    mint ans = ((mint(2) ^ N) - (mint(2) ^ (N-R))) * (mint(2) ^ (M - 1));\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 998244353\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nclass MTwo{\npublic:\n    using t = bool;\n    static t id() {\n        return false;\n    }\n\tstatic t e() {\n        return true;\n    }\n\t// * \n    static t op1(const t& l, const t& r){\n        return l && r;\n    }\n\t// + \n\tstatic t op2(const t& l, const t& r){\n        return l ^ r;\n    }\n\t// - \n\tstatic t op3(const t& x){\n        return x;\n    }\n\t// /\n\tstatic t op4(const t& x) {\n        return x;\n    }\n};\ntemplate< typename M >\nstruct Matrix{\n\tusing T = typename M::t;\n\tint H;\n\tint W;\n\tvector<T> data;\n    Matrix(int n_)\n        : H(n_), W(n_), data(n_ * n_, M::id()) {}\n    Matrix(int h_, int w_)\n        : H(h_), W(w_), data(h_ * w_, M::id()) {}\n\tMatrix(int n_,vector<T> d_)\n        : H(n_), W(n_) {data = d_;}\n    Matrix(int h_, int w_, vector<T> d_)\n        : H(h_), W(w_) {data = d_;}\n  \tvoid Update(int h,int w,T x){\n    \tdata[h*W+w] = x;\n  \t}\n  \tconst T Get(int h,int w){\n    \treturn data[h*W+w];\n  \t}\n\tint Rank(){\n\t\tint ans = 0;\n\t\tvector<T> A(H*W);\n\t\tvector<bool> used(H);\n\t\tfor(int i=0;i<H*W;i++){\n\t\t\tA[i] = data[i];\n\t\t}\n\t\tfor(int i=0;i<W;i++){\n\t\t\tint nonzero = 0;\n\t\t\twhile(nonzero < H && (used[nonzero] || A[nonzero*W+i] == M::id())){\n\t\t\t\tnonzero++;\n\t\t\t}\n\t\t\tif(nonzero == H){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans++;\n\t\t\tused[nonzero] = true;\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(used[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tT d = M::op3(M::op1(M::op4(A[nonzero*W+i]),A[j*W+i])); \n\t\t\t\tfor(int k=i;k<W;k++){\n\t\t\t\t\tA[j*W+k] = M::op2(A[j*W+k],M::op1(A[nonzero*W+k],d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn ans;\n\t}\n\tstatic Matrix I(int N){\n\t\tMatrix ans(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans.Update(i,i,M::e());\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Plus(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op2(A.Get(i,j),B.Get(i,j)));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Minus(Matrix& A){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op3(A.Get(i,j)));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Minus(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op2(A.Get(i,j),M::op3(B.Get(i,j))));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Prod(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = B.W;\n\t\tint K = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tT c = M::id();\n\t\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\t\tc = M::op2(c,M::op1(A.Get(i,k),B.Get(k,j)));\n\t\t\t\t}\n\t\t\t\tans.Update(i,j,c);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Pow(Matrix A,long r){\n\t\tint n = A.H;\n\t\tMatrix ans = I(n);\n\t\twhile(r){\n\t\t\tif(r % 2 == 1){\n\t\t\t\tans = Prod(ans,A);\n\t\t\t}\n\t\t\tA = Prod(A,A);\n\t\t\tr /= 2;\n\t\t}\n\t\treturn ans;\n\t}\n};\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tvector<bool> A(N*M);\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\tint x = rei();\n\t\t\tA[i*M+j] = x % 2 == 1;\n\t\t}\n\t}\n\tMatrix<MTwo> mat(N,M,A);\n\tint r = mat.Rank();\n\tlong ans1 = 1;\n\tlong ans2 = 1;\n\tfor(int i=0;i<N+M-1;i++){\n\t\tans1 *= 2;\n\t\tans1 %= mod;\n\t}\n\tfor(int i=0;i<N+M-r-1;i++){\n\t\tans2 *= 2;\n\t\tans2 %= mod;\n\t}\n\tcout << (ans1 - ans2 + mod) % mod << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\nusing namespace std;\n\nconst int mod=998244353;\n\nbitset<300> d[300],a[300];\n\nint modpow(int x,int p){\n\tint res=1;\n\twhile(p){\n\t\tif(p&1) res=1L*res*x%mod;\n\t\tx=1L*x*x%mod;\n\t\tp>>=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\ta[j][i]=x;\n\t\t}\n\t}\n\t\n\tint r=0;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=n-1;j>=0;j--){\n\t\t\tif(a[i][j]==1){\n\t\t\t\tif(!d[j][j]) d[j]=a[i],r++;\n\t\t\t\ta[i]^=d[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << 1L*modpow(2,n-1)*(modpow(2,m)-modpow(2,m-r)+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint a[323][323] , c[323], r[323];\nll dpr[323][323][2], dpc[323][323][2];\nconst int MOD = 998244353;\nint main()\n{\n    int m, n;\n    cin >> m >> n;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= m; j++)\n        {\n            cin >> a[i][j];\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        r[i]=r[i-1];\n        for (int j = 1; j <= m; j++)\n        {   \n            if (i==1) c[j]=c[j-1];\n            r[i] += a[i][j], c[j] += a[i][j];\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        dpr[i][0][0] = dpc[i][0][0] = 1;\n        for (int j = 1; j <= m; j++)\n        {\n            dpr[i][j][0] = dpr[i][j - 1][0];\n            dpr[i][j][1] = dpr[i][j - 1][1];\n            if (a[i][j] & 1)\n            {\n                dpr[i][j][0] = (dpr[i][j][0] + dpr[i][j-1][1]) % MOD;\n                dpr[i][j][1] = (dpr[i][j][1] + dpr[i][j-1][0]) % MOD;\n            }\n            else\n            {\n                dpr[i][j][0] = dpr[i][j][0] * 2 % MOD;\n                dpr[i][j][1] = dpr[i][j][1] * 2 % MOD;\n            }\n        }\n    }\n    for (int j = 1; j <= m; j++)\n    {\n        for (int i = 1; i <= n; i++)\n        {\n            dpc[j][i][0] = dpc[j][i-1][0];\n            dpc[j][i][1] = dpc[j][i-1][1];\n            if (a[i][j] & 1)\n            {\n                dpc[j][i][0] = (dpc[j][i][0] + dpc[j][i-1][1]) % MOD;\n                dpc[j][i][1] = (dpc[j][i][1] + dpc[j][i-1][0]) % MOD;\n            }\n            else\n            {\n                dpc[j][i][0] = dpc[j][i][0] * 2 % MOD;\n                dpc[j][i][1] = dpc[j][i][1] * 2 % MOD;\n            }\n        }\n    }\n    ll ans=0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= m; j++)\n        {\n            if ((r[i]&1)&&(c[j]&1))ans=(ans+dpr[i][m][1]*dpc[j][n][1]%MOD)%MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 998244353;\n\nint64 power_mod(int64 a, int n) {\n  int64 ret = 1;\n  for (; n; n >>= 1) {\n    if (n & 1) ret = ret * a % MOD;\n    a = a * a % MOD;\n  }\n  return ret;\n}\n\nconst int N = 300 + 10;\nint a[N][N];\nint gauss(int a[N][N], int n, int m) {\n  int i;\n  for (i = 0; i < n && i < m; ++i) {\n    int p, q;\n    for (p = i; p < n; ++p) {\n      for (q = i; q < m; ++q) {\n        if (a[p][q]) break;\n      }\n      if (q < m) break;\n    }\n    if (p == n) break;\n    if (p != i) {\n      for (int j = i; j < m; ++j) {\n        swap(a[i][j], a[p][j]);\n      }\n    }\n    if (q != i) {\n      for (int j = i; j < n; ++j) {\n        swap(a[j][i], a[j][q]);\n      }\n    }\n    for (int j = i + 1; j < n; ++j) {\n      if (a[j][i]) {\n        for (int k = i; k < m; ++k) {\n          a[j][k] ^= a[i][k];\n        }\n      }\n    }\n  }\n  return i;\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      scanf(\"%d\", &a[i][j]);\n    }\n  }\n  int rk = gauss(a, n, m);\n  int ret = (power_mod(2, n) + MOD - power_mod(2, n - rk)) *\n    power_mod(2, m - 1) % MOD;\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass reverse_range {private:struct I {int x;int operator*() {return x-1;}bool operator!=(I& lhs) {return x>lhs.x;}void operator++() {--x;}};I i, n;public:reverse_range(int n) :i({ 0 }), n({ n }){}reverse_range(int i, int n) :i({ i }), n({ n }){}I& begin() {return n;}I& end() {return i;}};\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }reverse_range operator!(){return reverse_range(*i,*n);}};\n\nconstexpr int mod = 998244353;\nint R,C;\nint A[312][312];\nLL pow_mod(LL a,LL n,int M=mod){\n    LL res=1;\n    a%=M;\n    while(n){\n        if(n&1)\n            res=(res*a)%M;\n        a=(a*a)%M;\n        n>>=1;\n    }\n    return res;\n}\nint get_rank(){\n    int ret = 0;\n    for(int c:range(C)){\n        int id=-1;\n        for(int i:range(ret,R)){\n            if(A[i][c]==1){\n                id=i;\n            }\n        }\n        if(id==-1)continue;\n        for(int j:range(C)){\n            swap(A[ret][c],A[id][c]);\n        }\n        ret++;\n        for(int i:range(ret,R)){\n            if(A[i][c]==1)for(int j:range(C)){\n                A[i][j] = A[i][j] xor A[ret-1][j];\n            }\n        }\n    }\n    return ret;\n}\nint main(){\n    cin>>R>>C;\n    for(int i:range(R))for(int j:range(C)){\n        cin>>A[i][j];\n    }\n    LL ret=pow_mod(2,R+C-1)-pow_mod(2,R+C-1-get_rank())+mod;\n    cout<<ret%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __BINARY_MATRIX_H__\n#define __BINARY_MATRIX_H__\n\n#include <vector>\n#include <functional>\n#include <iostream>\n#include <initializer_list>\n#include <iterator>\n\nclass BinaryMatrixBoolReference {\n\tuint64_t& var_m;\n\tuint64_t mask_m;\n\npublic:\n\tBinaryMatrixBoolReference(const BinaryMatrixBoolReference&) = default;\n\tBinaryMatrixBoolReference(uint64_t& var, int bit);\n\n\tBinaryMatrixBoolReference& operator=(bool value);\n\tBinaryMatrixBoolReference& operator|=(bool value);\n\tBinaryMatrixBoolReference& operator&=(bool value);\n\tBinaryMatrixBoolReference& operator^=(bool value);\n\n\toperator bool() const;\n\n\tvoid Flip();\n\tvoid Swap(BinaryMatrixBoolReference& other);\n};\n\nvoid swap(BinaryMatrixBoolReference& left, BinaryMatrixBoolReference& right);\n\nclass BinaryMatrixRowConstIterator {\n\tstatic const int BITS = 64;\n\t\npublic:\n\tusing iterator_category = std::random_access_iterator_tag;\n\tusing difference_type = int64_t;\n\tusing value_type = bool;\n\tusing reference = bool;\n\tusing pointer = bool*;\n\nprotected:\n\tuint64_t* ptr_m;\n\tint64_t offset_m;\n\npublic:\n\tBinaryMatrixRowConstIterator() = default;\n\tBinaryMatrixRowConstIterator(const uint64_t* ptr, int64_t offset);\n\tBinaryMatrixRowConstIterator(const BinaryMatrixRowConstIterator&) = default;\n\tBinaryMatrixRowConstIterator& operator=(const BinaryMatrixRowConstIterator&) = default;\n\n\treference operator*() const;\n\treference operator->() const;\n\treference operator[](difference_type offset) const;\n\n\tBinaryMatrixRowConstIterator& operator++();\n\tBinaryMatrixRowConstIterator& operator--();\n\tBinaryMatrixRowConstIterator operator++(int);\n\tBinaryMatrixRowConstIterator operator--(int);\n\n\tBinaryMatrixRowConstIterator& operator+=(difference_type offset);\n\tBinaryMatrixRowConstIterator& operator-=(difference_type offset);\n\n\tstatic int Compare(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right);\n};\n\nbool operator==(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right);\nbool operator!=(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right);\nbool operator<(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right);\nbool operator<=(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right);\nbool operator>(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right);\nbool operator>=(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right);\n\nBinaryMatrixRowConstIterator operator+(const BinaryMatrixRowConstIterator& itr, int offset);\nBinaryMatrixRowConstIterator operator+(int offset, const BinaryMatrixRowConstIterator& itr);\nBinaryMatrixRowConstIterator operator-(const BinaryMatrixRowConstIterator& itr, int offset);\n\n\nclass BinaryMatrixRowIterator : public BinaryMatrixRowConstIterator {\n\tusing Base = BinaryMatrixRowConstIterator;\n\tstatic const int BITS = 64;\n\npublic:\n\tusing iterator_category = std::random_access_iterator_tag;\n\tusing difference_type = std::ptrdiff_t;\n\tusing value_type = bool;\n\tusing reference = BinaryMatrixBoolReference;\n\tusing pointer = BinaryMatrixBoolReference*;\n\n\tBinaryMatrixRowIterator() = default;\n\tBinaryMatrixRowIterator(uint64_t* ptr, int64_t offset);\n\tBinaryMatrixRowIterator(const BinaryMatrixRowIterator&) = default;\n\tBinaryMatrixRowIterator& operator=(const BinaryMatrixRowIterator&) = default;\n\n\treference operator*() const;\n\treference operator->() const;\n\treference operator[](int offset) const;\n\n\tBinaryMatrixRowIterator& operator++();\n\tBinaryMatrixRowIterator& operator--();\n\tBinaryMatrixRowIterator operator++(int);\n\tBinaryMatrixRowIterator operator--(int);\n\n\tBinaryMatrixRowIterator& operator+=(difference_type offset);\n\tBinaryMatrixRowIterator& operator-=(difference_type offset);\n};\n\nBinaryMatrixRowIterator operator+(const BinaryMatrixRowIterator& itr, int offset);\nBinaryMatrixRowIterator operator+(int offset, const BinaryMatrixRowIterator& itr);\nBinaryMatrixRowIterator operator-(const BinaryMatrixRowIterator& itr, int offset);\n\n\nclass BinaryMatrixRow {\n\tusing Reference = BinaryMatrixBoolReference;\n\tusing Iterator = BinaryMatrixRowIterator;\n\tusing ConstIterator = BinaryMatrixRowConstIterator;\n\tstatic const int BITS = 64;\n\n\tint size_m = 0;\n\tstd::vector<uint64_t> arr_m;\npublic:\n\tBinaryMatrixRow() = default;\n\tBinaryMatrixRow(int size);\n\tBinaryMatrixRow(const BinaryMatrixRow&) = default;\n\tBinaryMatrixRow(BinaryMatrixRow&&) = default;\n\n\tBinaryMatrixRow& operator=(const BinaryMatrixRow&) = default;\n\tBinaryMatrixRow& operator=(BinaryMatrixRow&&) = default;\n\n\tBinaryMatrixRow& operator+=(const BinaryMatrixRow& right);\n\t\n\tReference operator[](int index);\n\tbool operator[](int index) const;\n\n\tint Size() const;\n\tvoid Clear();\n\tvoid Flip();\n\n\tIterator begin();\n\tIterator end();\n\tConstIterator begin() const;\n\tConstIterator end() const;\n\nprivate:\n\tstatic int Popcount(uint64_t value);\npublic:\n\tint Count() const;\n\n\tstatic int Compare(const BinaryMatrixRow& left, const BinaryMatrixRow& right);\n};\n\nbool operator==(const BinaryMatrixRow& left, const BinaryMatrixRow& right);\nbool operator!=(const BinaryMatrixRow& left, const BinaryMatrixRow& right);\nbool operator<(const BinaryMatrixRow& left, const BinaryMatrixRow& right);\nbool operator<=(const BinaryMatrixRow& left, const BinaryMatrixRow& right);\nbool operator>(const BinaryMatrixRow& left, const BinaryMatrixRow& right);\nbool operator>=(const BinaryMatrixRow& left, const BinaryMatrixRow& right);\nBinaryMatrixRow operator+(const BinaryMatrixRow& left, const BinaryMatrixRow& right);\n\n\nclass BinaryMatrix {\npublic:\n\tusing Row = BinaryMatrixRow;\n\tusing Iterator = std::vector<Row>::iterator;\n\tusing ConstIterator = std::vector<Row>::const_iterator;\n\nprivate:\n\tint height_m = 0;\n\tint width_m = 0;\n\tstd::vector<Row> mat_m;\n\npublic:\n\tBinaryMatrix() = default;\n\tBinaryMatrix(int height, int width);\n\tBinaryMatrix(int height, int width, const std::function<bool(int, int)>& func);\n\tBinaryMatrix(const std::initializer_list<std::initializer_list<bool>>& lists);\n\t\n\tBinaryMatrix(const BinaryMatrix&) = default;\n\tBinaryMatrix(BinaryMatrix&&) = default;\n\n\tBinaryMatrix& operator=(const BinaryMatrix&) = default;\n\tBinaryMatrix& operator=(BinaryMatrix&&) = default;\n\n\tBinaryMatrixRow& operator[](int index);\n\tconst BinaryMatrixRow& operator[](int index) const;\n\n\tconst BinaryMatrix& operator+() const;\n\tconst BinaryMatrix& operator-() const;\n\n\tBinaryMatrix& operator+=(const BinaryMatrix& right);\n\tBinaryMatrix& operator-=(const BinaryMatrix& right);\n\tBinaryMatrix& operator*=(const BinaryMatrix& right);\n\tBinaryMatrix& operator*=(bool scalar);\n\n\tIterator begin();\n\tIterator end();\n\tConstIterator begin() const;\n\tConstIterator end() const;\n\n\tint Height() const;\n\tint Width() const;\n\tbool Is_square() const;\n\n\tBinaryMatrix Trans() const;\n\tBinaryMatrix Inverse() const;\n\tbool Determinant() const;\n\tint Rank() const;\n\tBinaryMatrix Block(int top, int bottom, int left, int right) const;\n\n\tstatic bool Is_addable(const BinaryMatrix& left, const BinaryMatrix& right);\n\tstatic bool Is_multipliable(const BinaryMatrix& left, const BinaryMatrix& right);\n\n\tstatic int Compare(const BinaryMatrix& left, const BinaryMatrix& right);\n\tstatic BinaryMatrix Multiply(const BinaryMatrix& left, const BinaryMatrix& right);\n\n\tstatic BinaryMatrix Identity(int size);\n\tstatic BinaryMatrix Join_horizontally(const BinaryMatrix& left, const BinaryMatrix& right);\n\tstatic BinaryMatrix Join_vertically(const BinaryMatrix& top, const BinaryMatrix& bottom);\n};\n\nbool operator==(const BinaryMatrix& left, const BinaryMatrix& right);\nbool operator!=(const BinaryMatrix& left, const BinaryMatrix& right);\nbool operator<(const BinaryMatrix& left, const BinaryMatrix& right);\nbool operator<=(const BinaryMatrix& left, const BinaryMatrix& right);\nbool operator>(const BinaryMatrix& left, const BinaryMatrix& right);\nbool operator>=(const BinaryMatrix& left, const BinaryMatrix& right);\n\nBinaryMatrix operator+(const BinaryMatrix& left, const BinaryMatrix& right);\nBinaryMatrix operator-(const BinaryMatrix& left, const BinaryMatrix& right);\nBinaryMatrix operator*(const BinaryMatrix& left, const BinaryMatrix& right);\nBinaryMatrix operator*(const BinaryMatrix& matrix, bool scalar);\nBinaryMatrix operator*(bool scalar, const BinaryMatrix& matrix);\n\nstd::ostream& operator<<(std::ostream& ost, const BinaryMatrix& matrix);\n\nstruct BinaryMatrixReductionInfo {\n\tBinaryMatrix matrix;\n\tint rank;\n\tbool determinant;\n};\n\nBinaryMatrixReductionInfo Reduce_by_gauss(const BinaryMatrix& mat_arg, int row_max = -1);\n\n#endif\n\n#ifdef ONLY_MY_ENVIR\n#include \"BinaryMatrix.h\"\n#endif\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\n#include <algorithm>\n#include <cassert>\n\n/*-----------------------------------------*/\n/*----   BinaryMatrixRowConstIterator   ---*/\n/*-----------------------------------------*/\n\nBinaryMatrixRowConstIterator::BinaryMatrixRowConstIterator(const uint64_t* ptr, int64_t offset)\n\t: ptr_m(const_cast<uint64_t*>(ptr)), offset_m(offset) {\n}\n\nBinaryMatrixRowConstIterator::reference BinaryMatrixRowConstIterator::operator*() const {\n\tint pos = offset_m / BITS;\n\tint bit = offset_m % BITS;\n\treturn ptr_m[pos] & ((uint64_t)1 << bit);\n}\n\nBinaryMatrixRowConstIterator::reference BinaryMatrixRowConstIterator::operator->() const {\n\treturn *(*this);\n}\n\nBinaryMatrixRowConstIterator::reference BinaryMatrixRowConstIterator::operator[](difference_type offset) const {\n\treturn *(*this + offset);\n}\n\nBinaryMatrixRowConstIterator& BinaryMatrixRowConstIterator::operator++() {\n\t++offset_m;\n\treturn *this;\n}\n\nBinaryMatrixRowConstIterator& BinaryMatrixRowConstIterator::operator--() {\n\t--offset_m;\n\treturn *this;\n}\n\nBinaryMatrixRowConstIterator BinaryMatrixRowConstIterator::operator++(int) {\n\tBinaryMatrixRowConstIterator preserved(*this);\n\t++(*this);\n\treturn preserved;\n}\n\nBinaryMatrixRowConstIterator BinaryMatrixRowConstIterator::operator--(int) {\n\tBinaryMatrixRowConstIterator preserved(*this);\n\t--(*this);\n\treturn preserved;\n}\n\nBinaryMatrixRowConstIterator& BinaryMatrixRowConstIterator::operator+=(difference_type offset) {\n\toffset_m += offset;\n\treturn *this;\n}\n\nBinaryMatrixRowConstIterator& BinaryMatrixRowConstIterator::operator-=(difference_type offset) {\n\toffset_m -= offset;\n\treturn *this;\n}\n\nint BinaryMatrixRowConstIterator::Compare(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right) {\n\tassert(left.ptr_m == right.ptr_m);\n\n\tif (left.offset_m < right.offset_m) return -1;\n\tif (left.offset_m > right.offset_m) return 1;\n\treturn 0;\n}\n\nbool operator==(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right) {\n\treturn BinaryMatrixRowConstIterator::Compare(left, right) == 0;\n}\n\nbool operator!=(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right) {\n\treturn BinaryMatrixRowConstIterator::Compare(left, right) != 0;\n}\n\nbool operator<(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right) {\n\treturn BinaryMatrixRowConstIterator::Compare(left, right) < 0;\n}\n\nbool operator<=(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right) {\n\treturn BinaryMatrixRowConstIterator::Compare(left, right) <= 0;\n}\n\nbool operator>(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right) {\n\treturn BinaryMatrixRowConstIterator::Compare(left, right) > 0;\n}\n\nbool operator>=(const BinaryMatrixRowConstIterator& left, const BinaryMatrixRowConstIterator& right) {\n\treturn BinaryMatrixRowConstIterator::Compare(left, right) >= 0;\n}\n\nBinaryMatrixRowConstIterator operator+(const BinaryMatrixRowConstIterator& itr, int offset) {\n\tBinaryMatrixRowConstIterator ret(itr);\n\tret += offset;\n\treturn ret;\n}\n\nBinaryMatrixRowConstIterator operator+(int offset, const BinaryMatrixRowConstIterator& itr) {\n\tBinaryMatrixRowConstIterator ret(itr);\n\tret += offset;\n\treturn ret;\n}\n\nBinaryMatrixRowConstIterator operator-(const BinaryMatrixRowConstIterator& itr, int offset) {\n\tBinaryMatrixRowConstIterator ret(itr);\n\tret -= offset;\n\treturn ret;\n}\n\n/*-----------------------------------------*/\n/*------   BinaryMatrixRowIterator   ------*/\n/*-----------------------------------------*/\n\nBinaryMatrixRowIterator::BinaryMatrixRowIterator(uint64_t* ptr, int64_t offset) \n\t: Base(ptr, offset) {\n}\n\nBinaryMatrixRowIterator::reference BinaryMatrixRowIterator::operator*() const {\n\tint pos = offset_m / BITS;\n\tint bit = offset_m % BITS;\n\treturn reference(ptr_m[pos], bit);\n}\n\nBinaryMatrixRowIterator::reference BinaryMatrixRowIterator::operator->() const {\n\treturn *(*this);\n}\n\nBinaryMatrixRowIterator::reference BinaryMatrixRowIterator::operator[](int offset) const {\n\treturn *(*this + offset);\n}\n\nBinaryMatrixRowIterator& BinaryMatrixRowIterator::operator++() {\n\tBase::operator++();\n\treturn *this;\n}\n\nBinaryMatrixRowIterator& BinaryMatrixRowIterator::operator--() {\n\tBase::operator--();\n\treturn *this;\n}\n\nBinaryMatrixRowIterator BinaryMatrixRowIterator::operator++(int) {\n\tBinaryMatrixRowIterator preserved(*this);\n\t++(*this);\n\treturn preserved;\n}\n\nBinaryMatrixRowIterator BinaryMatrixRowIterator::operator--(int) {\n\tBinaryMatrixRowIterator preserved(*this);\n\t--(*this);\n\treturn preserved;\n}\n\nBinaryMatrixRowIterator& BinaryMatrixRowIterator::operator+=(difference_type offset) {\n\tBase::operator+=(offset);\n\treturn *this;\n}\n\nBinaryMatrixRowIterator& BinaryMatrixRowIterator::operator-=(difference_type offset) {\n\tBase::operator-=(offset);\n\treturn *this;\n}\n\nBinaryMatrixRowIterator operator+(const BinaryMatrixRowIterator& itr, int offset) {\n\tBinaryMatrixRowIterator ret(itr);\n\tret += offset;\n\treturn ret;\n}\n\nBinaryMatrixRowIterator operator+(int offset, const BinaryMatrixRowIterator& itr) {\n\tBinaryMatrixRowIterator ret(itr);\n\tret += offset;\n\treturn ret;\n}\n\nBinaryMatrixRowIterator operator-(const BinaryMatrixRowIterator& itr, int offset) {\n\tBinaryMatrixRowIterator ret(itr);\n\tret -= offset;\n\treturn ret;\n}\n\n/*-----------------------------------------*/\n/*-----   BinaryMatrixBoolReference   -----*/\n/*-----------------------------------------*/\n\nBinaryMatrixBoolReference::BinaryMatrixBoolReference(uint64_t& var, int bit)\n\t: var_m(var), mask_m((uint64_t)1 << bit) {\n}\n\nBinaryMatrixBoolReference& BinaryMatrixBoolReference::operator=(bool value) {\n\tif (value) {\n\t\tvar_m |= mask_m;\n\t} else {\n\t\tvar_m &= ~mask_m;\n\t}\n\treturn *this;\n}\n\nBinaryMatrixBoolReference& BinaryMatrixBoolReference::operator|=(bool value) {\n\tif (value) {\n\t\tvar_m |= mask_m;\n\t}\n\treturn *this;\n}\n\nBinaryMatrixBoolReference& BinaryMatrixBoolReference::operator&=(bool value) {\n\tif (!value) {\n\t\tvar_m &= ~mask_m;\n\t}\n\treturn *this;\n}\n\nBinaryMatrixBoolReference& BinaryMatrixBoolReference::operator^=(bool value) {\n\tif (value) {\n\t\tvar_m ^= mask_m;\n\t}\n\treturn *this;\n}\n\nBinaryMatrixBoolReference::operator bool() const {\n\treturn var_m & mask_m;\n}\n\nvoid BinaryMatrixBoolReference::Flip() {\n\tvar_m ^= mask_m;\n}\n\nvoid BinaryMatrixBoolReference::Swap(BinaryMatrixBoolReference& other) {\n\tif (*this == other) return;\n\tFlip();\n\tother.Flip();\n}\n\nvoid swap(BinaryMatrixBoolReference& left, BinaryMatrixBoolReference& right) {\n\tleft.Swap(right);\n}\n\n/*-----------------------------------------*/\n/*----------   BinaryMatrixRow   ----------*/\n/*-----------------------------------------*/\n\nBinaryMatrixRow::BinaryMatrixRow(int size) \n\t: size_m(size), arr_m((size + BITS - 1) / BITS) {\n}\n\nBinaryMatrixRow& BinaryMatrixRow::operator+=(const BinaryMatrixRow& right) {\n\tassert(size_m == right.size_m);\n\n\tfor (int i = 0; i < arr_m.size(); ++i) {\n\t\tarr_m[i] ^= right.arr_m[i];\n\t}\n\treturn *this;\n}\n\nBinaryMatrixRow::Reference BinaryMatrixRow::operator[](int index) {\n\tint pos = index / BITS;\n\tint bit = index % BITS;\n\treturn Reference(arr_m[pos], bit);\n}\n\nbool BinaryMatrixRow::operator[](int index) const {\n\tint pos = index / BITS;\n\tint bit = index % BITS;\n\treturn arr_m[pos]& ((uint64_t)1 << bit);\n}\n\nint BinaryMatrixRow::Size() const {\n\treturn size_m;\n}\n\nvoid BinaryMatrixRow::Clear() {\n\tstd::fill(arr_m.begin(), arr_m.end(), 0);\n}\n\nvoid BinaryMatrixRow::Flip() {\n\tfor (uint64_t& value : arr_m) {\n\t\tvalue = ~value;\n\t}\n\n\t// 使用していない領域は 0 にする\n\tint rest_bit = size_m % BITS;\n\tif (rest_bit == 0) return;\n\n\tuint64_t mask = ((uint64_t)1 << rest_bit) - 1;\n\tarr_m.back() &= mask;\n}\n\nBinaryMatrixRow::Iterator BinaryMatrixRow::begin() {\n\treturn Iterator(arr_m.data(), 0);\n}\n\nBinaryMatrixRow::Iterator BinaryMatrixRow::end() {\n\treturn Iterator(arr_m.data(), size_m);\n}\n\nBinaryMatrixRow::ConstIterator BinaryMatrixRow::begin() const {\n\treturn ConstIterator(arr_m.data(), 0);\n}\n\nBinaryMatrixRow::ConstIterator BinaryMatrixRow::end() const {\n\treturn ConstIterator(arr_m.data(), size_m);\n}\n\nint BinaryMatrixRow::Popcount(uint64_t value) {\n#ifdef _MSC_VER\n\treturn __popcnt64(value);\n#elif defined(__GNUC__)\n\treturn __builtin_popcountll(value);\n#else\n\tvalue = (value & 0x5555555555555555) + ((value >> 1) & 0x5555555555555555);\n\tvalue = (value & 0x3333333333333333) + ((value >> 2) & 0x3333333333333333);\n\tvalue = (value & 0x0f0f0f0f0f0f0f0f) + ((value >> 4) & 0x0f0f0f0f0f0f0f0f);\n\tvalue = (value & 0x00ff00ff00ff00ff) + ((value >> 8) & 0x00ff00ff00ff00ff);\n\tvalue = (value & 0x0000ffff0000ffff) + ((value >> 16) & 0x0000ffff0000ffff);\n\tvalue = (value & 0x00000000ffffffff) + ((value >> 32) & 0x00000000ffffffff);\n\treturn value;\n#endif\n}\n\nint BinaryMatrixRow::Count() const {\n\tint sum = 0;\n\tfor (int64_t value : arr_m) {\n\t\tsum += Popcount(value);\n\t}\n\treturn sum;\n}\n\n/* 注意: 辞書順ではない(bit を下位から使用しているため) */\nint BinaryMatrixRow::Compare(const BinaryMatrixRow& left, const BinaryMatrixRow& right) {\n\tif (left.size_m < right.size_m) return -1;\n\tif (left.size_m > right.size_m) return 1;\n\n\tconst int N = left.arr_m.size();\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (left.arr_m[i] < right.arr_m[i]) return -1;\n\t\tif (left.arr_m[i] > right.arr_m[i]) return 1;\n\t}\n\treturn 0;\n}\n\nbool operator==(const BinaryMatrixRow& left, const BinaryMatrixRow& right) {\n\treturn BinaryMatrixRow::Compare(left, right) == 0;\n}\n\nbool operator!=(const BinaryMatrixRow& left, const BinaryMatrixRow& right) {\n\treturn BinaryMatrixRow::Compare(left, right) != 0;\n}\n\nbool operator<(const BinaryMatrixRow& left, const BinaryMatrixRow& right) {\n\treturn BinaryMatrixRow::Compare(left, right) < 0;\n}\n\nbool operator<=(const BinaryMatrixRow& left, const BinaryMatrixRow& right) {\n\treturn BinaryMatrixRow::Compare(left, right) <= 0;\n}\n\nbool operator>(const BinaryMatrixRow& left, const BinaryMatrixRow& right) {\n\treturn BinaryMatrixRow::Compare(left, right) > 0;\n}\n\nbool operator>=(const BinaryMatrixRow& left, const BinaryMatrixRow& right) {\n\treturn BinaryMatrixRow::Compare(left, right) >= 0;\n}\n\nBinaryMatrixRow operator+(const BinaryMatrixRow& left, const BinaryMatrixRow& right) {\n\tBinaryMatrixRow ret(left);\n\tret += right;\n\treturn ret;\n}\n\n/*-----------------------------------------*/\n/*------------   BinaryMatrix   -----------*/\n/*-----------------------------------------*/\n\nBinaryMatrix::BinaryMatrix(int height, int width) \n\t: height_m(height), width_m(width), mat_m(height, Row(width)) {\n}\n\nBinaryMatrix::BinaryMatrix(int height, int width, const std::function<bool(int, int)>& func)\n\t: BinaryMatrix(height, width) {\n\n\tfor (int i = 0; i < height_m; ++i) {\n\t\tfor (int j = 0; j < width_m; ++j) {\n\t\t\tmat_m[i][j] = func(i, j);\n\t\t}\n\t}\n}\n\nBinaryMatrix::BinaryMatrix(const std::initializer_list<std::initializer_list<bool>>& lists) {\n\tint height = lists.size();\n\tint width = 0;\n\tfor (const auto& list : lists) {\n\t\twidth = std::max<int>(width, list.size());\n\t}\n\n\t*this = BinaryMatrix(height, width);\n\n\tint i = 0;\n\tfor (const auto& list : lists) {\n\t\tint j = 0;\n\t\tfor (bool value : list) {\n\t\t\tmat_m[i][j] = value;\n\t\t\t++j;\n\t\t}\n\t\t++i;\n\t}\n}\n\nBinaryMatrixRow& BinaryMatrix::operator[](int index) {\n\treturn mat_m[index];\n}\n\nconst BinaryMatrixRow& BinaryMatrix::operator[](int index) const {\n\treturn mat_m[index];\n}\n\nconst BinaryMatrix& BinaryMatrix::operator+() const {\n\treturn *this;\n}\n\nconst BinaryMatrix& BinaryMatrix::operator-() const {\n\treturn *this;\n}\n\nBinaryMatrix& BinaryMatrix::operator+=(const BinaryMatrix& right) {\n\tassert(Is_addable(*this, right));\n\t\n\tfor (int i = 0; i < height_m; ++i) {\n\t\tmat_m[i] += right.mat_m[i];\n\t}\n\treturn *this;\n}\n\nBinaryMatrix& BinaryMatrix::operator-=(const BinaryMatrix& right) {\n\t*this += right;\n\treturn *this;\n}\n\nBinaryMatrix& BinaryMatrix::operator*=(const BinaryMatrix& right) {\n\tassert(Is_multipliable(*this, right));\n\n\t*this = Multiply(*this, right);\n\treturn *this;\n}\n\nBinaryMatrix& BinaryMatrix::operator*=(bool scalar) {\n\tif (!scalar) {\n\t\tfor (Row& row : mat_m) {\n\t\t\trow.Clear();\n\t\t}\n\t}\n\treturn *this;\n}\n\nBinaryMatrix::Iterator BinaryMatrix::begin() {\n\treturn mat_m.begin();\n}\n\nBinaryMatrix::Iterator BinaryMatrix::end() {\n\treturn mat_m.end();\n}\n\nBinaryMatrix::ConstIterator BinaryMatrix::begin() const {\n\treturn mat_m.begin();\n}\n\nBinaryMatrix::ConstIterator BinaryMatrix::end() const {\n\treturn mat_m.end();\n}\n\nint BinaryMatrix::Height() const {\n\treturn height_m;\n}\n\nint BinaryMatrix::Width() const {\n\treturn width_m;\n}\n\nbool BinaryMatrix::Is_square() const {\n\treturn height_m == width_m;\n}\n\nBinaryMatrix BinaryMatrix::Trans() const {\n\tBinaryMatrix ret(width_m, height_m);\n\n\tfor (int i = 0; i < height_m; ++i) {\n\t\tfor (int j = 0; j < width_m; ++j) {\n\t\t\tret.mat_m[j][i] = mat_m[i][j];\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\n/* これより計算量の良い方法はある？ */\nBinaryMatrix BinaryMatrix::Inverse() const {\n\tassert(Is_square());\n\n\tconst int size = height_m;\n\tBinaryMatrix extended = Join_horizontally(*this, BinaryMatrix::Identity(size));\n\tconst auto& res = Reduce_by_gauss(extended, size);\n\n\tif (res.rank < size) throw std::runtime_error(\"matrix not invertible\");\n\treturn res.matrix.Block(0, size, size, 2 * size);\n}\n\nbool BinaryMatrix::Determinant() const {\n\tassert(Is_square());\n\n\tconst auto& res = Reduce_by_gauss(*this);\n\treturn res.determinant;\n}\n\nint BinaryMatrix::Rank() const {\n\tconst auto& res = Reduce_by_gauss(*this);\n\treturn res.rank;\n}\n\n/* 要高速化 */\nBinaryMatrix BinaryMatrix::Block(int top, int bottom, int left, int right) const {\n\tBinaryMatrix ret(bottom - top, right - left);\n\n\tfor (int i = top; i < bottom; ++i) {\n\t\tfor (int j = left; j < right; ++j) {\n\t\t\tret.mat_m[i - top][j - left] = mat_m[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool BinaryMatrix::Is_addable(const BinaryMatrix& left, const BinaryMatrix& right) {\n\treturn left.height_m == right.height_m && left.width_m == right.width_m;\n}\n\nbool BinaryMatrix::Is_multipliable(const BinaryMatrix& left, const BinaryMatrix& right) {\n\treturn left.width_m == right.height_m;\n}\n\n/* 注意: 辞書順ではない(bit を下位から使用しているため) */\nint BinaryMatrix::Compare(const BinaryMatrix& left, const BinaryMatrix& right) {\n\tif (left.height_m < right.height_m) return -1;\n\tif (left.height_m > right.height_m) return 1;\n\tif (left.width_m < right.width_m) return -1;\n\tif (left.width_m > right.width_m) return 1;\n\n\tconst int M = left.height_m;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint res_comp = BinaryMatrixRow::Compare(left.mat_m[i], right.mat_m[i]);\n\t\tif (res_comp != 0) return res_comp;\n\t}\n\treturn 0;\n}\n\nBinaryMatrix BinaryMatrix::Multiply(const BinaryMatrix& left, const BinaryMatrix& right) {\n\tassert(Is_multipliable(left, right));\n\t\n\tconst int L = left.height_m;\n\tconst int M = left.width_m;\n\tconst int N = right.width_m;\n\n\tBinaryMatrix ret(L, N);\n\n\tconst BinaryMatrix tr = right.Trans();\n\tfor (int i = 0; i < L; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tret.mat_m[i][j] = (left.mat_m[i] + right.mat_m[j]).Count() % 2;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nBinaryMatrix BinaryMatrix::Identity(int size) {\n\tBinaryMatrix ret(size, size);\n\n\tfor (int i = 0; i < size; ++i) {\n\t\tret.mat_m[i][i] = 1;\n\t}\n\treturn ret;\n}\n\n/* 要高速化 */\nBinaryMatrix BinaryMatrix::Join_horizontally(const BinaryMatrix& left, const BinaryMatrix& right) {\n\tassert(left.height_m == right.height_m);\n\n\tBinaryMatrix ret(left.height_m, left.width_m + right.width_m);\n\n\tfor (int i = 0; i < left.height_m; ++i) {\n\t\tfor (int j = 0; j < left.width_m; ++j) {\n\t\t\tret.mat_m[i][j] = left.mat_m[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < right.height_m; ++i) {\n\t\tfor (int j = 0; j < right.width_m; ++j) {\n\t\t\tret.mat_m[i][j + left.width_m] = right.mat_m[i][j];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nBinaryMatrix BinaryMatrix::Join_vertically(const BinaryMatrix& top, const BinaryMatrix& bottom) {\n\tassert(top.width_m == bottom.width_m);\n\n\tBinaryMatrix ret(top.height_m + bottom.height_m, top.width_m);\n\n\tfor (int i = 0; i < top.height_m; ++i) {\n\t\tret.mat_m[i] = top.mat_m[i];\n\t}\n\n\tfor (int i = 0; i < bottom.height_m; ++i) {\n\t\tret.mat_m[i + top.height_m] = bottom.mat_m[i];\n\t}\n\n\treturn ret;\n}\n\nbool operator==(const BinaryMatrix& left, const BinaryMatrix& right) {\n\treturn BinaryMatrix::Compare(left, right) == 0;\n}\n\nbool operator!=(const BinaryMatrix& left, const BinaryMatrix& right) {\n\treturn BinaryMatrix::Compare(left, right) != 0;\n}\n\nbool operator<(const BinaryMatrix& left, const BinaryMatrix& right) {\n\treturn BinaryMatrix::Compare(left, right) < 0;\n}\n\nbool operator<=(const BinaryMatrix& left, const BinaryMatrix& right) {\n\treturn BinaryMatrix::Compare(left, right) <= 0;\n}\n\nbool operator>(const BinaryMatrix& left, const BinaryMatrix& right) {\n\treturn BinaryMatrix::Compare(left, right) > 0;\n}\n\nbool operator>=(const BinaryMatrix& left, const BinaryMatrix& right) {\n\treturn BinaryMatrix::Compare(left, right) >= 0;\n}\n\nBinaryMatrix operator+(const BinaryMatrix& left, const BinaryMatrix& right) {\n\tBinaryMatrix ret(left);\n\tret += right;\n\treturn ret;\n}\n\nBinaryMatrix operator-(const BinaryMatrix& left, const BinaryMatrix& right) {\n\tBinaryMatrix ret(left);\n\tret -= right;\n\treturn ret;\n}\n\nBinaryMatrix operator*(const BinaryMatrix& left, const BinaryMatrix& right) {\n\treturn BinaryMatrix::Multiply(left, right);\n}\n\nBinaryMatrix operator*(const BinaryMatrix& matrix, bool scalar) {\n\tBinaryMatrix ret(matrix);\n\tret *= scalar;\n\treturn ret;\n}\n\nBinaryMatrix operator*(bool scalar, const BinaryMatrix& matrix) {\n\tBinaryMatrix ret(matrix);\n\tret *= scalar;\n\treturn ret;\n}\n\nstd::ostream& operator<<(std::ostream& ost, const BinaryMatrix& matrix) {\n\tfor (int i = 0; i < matrix.Height(); ++i) {\n\t\tfor (int j = 0; j < matrix.Width(); ++j) {\n\t\t\tost << matrix[i][j];\n\t\t\tif (j + 1 == matrix.Width()) {\n\t\t\t\tost << std::endl;\n\t\t\t} else {\n\t\t\t\tost << ' ';\n\t\t\t}\n\t\t}\n\t}\n\treturn ost;\n}\n\n\nBinaryMatrixReductionInfo Reduce_by_gauss(const BinaryMatrix& mat_arg, int row_max) {\n\tBinaryMatrix mat = mat_arg;\n\tif (row_max == -1) {\n\t\trow_max = mat.Width();\n\t}\n\n\tconst int M = mat.Height();\n\tconst int N = mat.Width();\n\n\tint rank = 0;\n\tfor (int row = 0; row < row_max; ++row) {\n\t\t/* ピボット選択 */\n\t\tint pivot_i = -1;\n\t\tfor (int i = rank; i < M; ++i) {\n\t\t\tif (mat[i][row]) {\n\t\t\t\tpivot_i = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* 列 curr_j 内の値がすべて 0 なら飛ばす */\n\t\tif (pivot_i == -1) continue;\n\n\t\t/* 入れ替え */\n\t\tif (pivot_i != rank) {\n\t\t\tusing std::swap;\n\t\t\tswap(mat[pivot_i], mat[rank]);\t\t// 実装注意\n\t\t}\n\n\t\t/* 基本変形 */\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (i == rank) continue;\n\t\t\tif (!mat[i][row]) continue;\n\n\t\t\tmat[i] += mat[rank];\n\t\t}\n\t\t++rank;\n\t}\n\n\tBinaryMatrixReductionInfo ret;\n\tret.matrix = std::move(mat);\n\tret.rank = rank;\n\tret.determinant = (rank == M);\n\treturn ret;\n}\n#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and must not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int Int;\n\ttypedef unsigned int UInt;\n\ttypedef long long Long;\n\ttypedef unsigned long long ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](ULong exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(ULong exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic IntMod Permutation(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / IntMod::Fact(n - r);\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#include \"LazySegmentTree.h\"\n#include \"BinaryMatrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nusing MK = IntMod<998244353>;\n\nint N, M;\nint main() {\n\tcin >> N >> M;\n\t\n\tBinaryMatrix mat(N, M);\n\tfor (auto&& row : mat) {\n\t\tfor (auto val : row) {\n\t\t\tval = Next<int>();\n\t\t}\n\t}\n\n\tint rank = mat.Rank();\n\tint rem = N + M - 2 * rank;\n\tcout << MK(2).Pow(rank + rem - 1) * (MK(2).Pow(rank) - 1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\n/*bool operator < (const vector<long long> &a,const vector<long long> &b){\n    bool ret=false;\n    DEBUG(\"called\");\n    for(long long i = 0; i < a.size(); i++){\n        if(a[i]>b[i]){\n            ret=false;\n            break;\n        }else if(a[i]<b[i]){\n            ret=true;\n            break;\n        }\n    }\n    return ret;\n}\n*/\nll cache_pow[600];\nll mpow(ll a){\n    static bool flag=false;\n    if(flag){\n        DEBUG(\"True\");\n        return cache_pow[a];\n    }else{\n        cache_pow[0]=1;\n        for(long long i = 1; i < 600; i++){\n            cache_pow[i]=(cache_pow[i-1]*2)%MOD;\n        }\n        flag=true;\n        return cache_pow[a];\n    }\n}\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    ll index=0;\n\n    vector<bitset<300>> A;\n    for(long long i = 0; i < a.size(); i++){\n        A.push_back(bitset<300>(0));\n        for(long long k = 0; k < a[i].size(); k++){\n            A[i][k]=a[i][k]==1;\n        }\n    }\n    ll rank=0;\n    for(long long i = 0; i < a.size(); i++){\n        DEBUG(i);\n        for(; index < a[i].size(); index++){\n            DEBUG(index);\n            for(long long j = i; j < a.size(); j++){\n                if(A[j][index]==1){\n                    if(j!=i)\n                        swap(A[j],A[i]);\n                    goto OUT;\n                }\n            }\n        }\n        OUT:\n        if(index==a[i].size()){\n            break;\n        }\n        rank++;\n        for(long long j = i+1; j < a.size(); j++){\n            if(A[j][index]==1){\n                A[j]^=A[i];\n            }\n        }\n    }\n    DEBUG(rank);\n    cout<<mpow(M+N-1)-mpow(M+N-1-rank)<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconstexpr long long mod = 998244353;\ntypedef pair<int, int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint kj[100005], kji[100005];\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nvoid setkj(int n) {\n\tkj[0] = 1;\n\trep(i, n)kj[i + 1] = kj[i] * (i + 1) % mod;\n\trep(i, n + 1)kji[i] = modpow(kj[i], mod - 2);\n}\nint comb(int r, int c) {\n\tif (c<0 || r<c)return 0;\n\treturn kj[r] * kji[c] % mod*kji[r - c] % mod;\n}\nint GJ(mat &A) {\n\tint N = A.size(), M = A[0].size();\n\tint rnk = 0;\n\trep(i, M) {\n\t\tint pivot = -1;\n\t\tfor (int j = rnk; j < N; j++) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j; break;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1)continue;\n\t\tswap(A[pivot], A[rnk]);\n\n\t\trep(j, N) {\n\t\t\tif (j != rnk&&A[j][i]) {\n\t\t\t\trep(k, M) {\n\t\t\t\t\tA[j][k] ^= A[rnk][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trnk++;\n\t}\n\n\tint res = 0;\n\trep(i, N) {\n\t\trep(j, M) {\n\t\t\tif (A[i][j]) {\n\t\t\t\tres++; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tsetkj(305);\n\tint n, m; cin >> n >> m;\n\tmat A(n);\n\trep(i, n) {\n\t\tA[i].resize(m);\n\t\trep(j, m)cin >> A[i][j];\n\t}\n\tint r = GJ(A);\n\n\t/*\n\trep(i, n) {\n\t\trep(j, m)cout << A[i][j]; cout << endl;\n\t}\n\tcout << r << endl;\n\t*/\n\n\tint ans = modpow(2, n - r)*modpow(2, m - r) % mod;\n\tint d = 0;\n\tfor (int i = 1; i <= r; i += 2) {\n\t\td += modpow(3, r - i)*comb(r, i) % mod;\n\t\td %= mod;\n\t}\n\tcout << d*ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#define inf 20021225\n#define ll long long\n#define mdn 998244353\nusing namespace std;\n\nbitset<310> r[310]; int n,m;\nint gauss()\n{\n\tint w = 0;\n\tfor(int i=1,j;i<=n;i++)\n\t{\n\t\tif(!r[i][i])\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t\tif(r[j][i])\tbreak;\n\t\t\tif(j>n)\tcontinue;\n\t\t\tswap(r[i],r[j]);\n\t\t}\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tif(r[j][i])\tr[j]^=r[i];\n\t\tif(r[i].count())\tw++;\n\t}\n\treturn w;\n}\nint ksm(int bs,int mi)\n{\n\tint ans = 1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=(ll)ans*bs%mdn;\n\t\tbs=(ll)bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tr[i][j] = x;\n\t\t}\n\tint ans = ksm(2,n+m-1)-ksm(2,n+m-1-gauss());\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        rank++;\n\n        for(int j = i+1; j < n; j++) {\n            int r = mat[j][i];\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k] * r;\n            }\n        }\n    }\n\n    return rank;\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, j, k) for (int i = j; i < (int)k; i++)\n#define pb push_back\n#define mt make_tuple\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef complex<ld> point;\ntypedef vector<int> vi;\n\ninline void fileIO(string s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\n\ntemplate <class T, class S>\ninline bool smin(T &a, S b) {\n  return (T)b < a ? a = b, 1 : 0;\n}\ntemplate <class T, class S>\ninline bool smax(T &a, S b) {\n  return a < (T)b ? a = b, 1 : 0;\n}\n\nconstexpr int MOD = 924844033;\nconstexpr int N = 302;\n\ntemplate <typename T>\ninline T mod(T &v) {\n  return v = (v % MOD + MOD) % MOD;\n}\ntemplate <typename S, typename T>\ninline S add(S &l, T r) {\n  return mod(l += r);\n}\nll po(ll v, ll u) {\n  return u ? po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD : 1;\n}\n\nint n, m, id[N], sz;\nbitset<N> tmp, paye[N];\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifndef LOCAL\n  // fileIO(\"superposition\");\n#endif\n  memset(id, -1, sizeof(id));\n  cin >> n >> m;\n  rep(i, 0, n) {\n    rep(j, 0, m) {\n      bool local;\n      cin >> local;\n      tmp[j] = local;\n    }\n    rep(j, 0, m) if (~id[j] && tmp[j]) tmp ^= paye[id[j]];\n    if (tmp.count()) {\n      id[tmp._Find_first()] = sz;\n      rep(j, 0, sz) paye[j] ^= tmp;\n      paye[sz++] = tmp;\n    }\n  }\n\n  ll res = po(2, n) - po(2, n - sz) + MOD;\n  mod(res *= po(2, m - 1));\n  cout << res << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 1005\n#define MP make_pair\ntypedef long long LL;\nconst int mod = 998244353;\n\nint n, m;\nint a[500][500];\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tscanf(\"%d\", &a[j][i]);\n\t\n\tswap(n, m); \n\tint r = 1;\n\tfor (int i = 1; i <= m; ++i)\n\t{\n\t\tint k = -1;\n\t\tfor (int j = r; j <= n; ++j)\n\t\t\tif (a[j][i]) k = j;\n\t\t\n\t\tif (k == -1) continue;\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tswap(a[k][j], a[r][j]);\n\t\tfor (int j = r + 1; j <= n; ++j)\n\t\t{\n\t\t\tif (!a[j][i]) continue;\n\t\t\tfor (int l = i; l <= m; ++l)\n\t\t\t\ta[j][l] ^= a[r][l];\n\t\t}\n\t\t++r;\n\t}\n\tint t = 1;\n\tr--; r = m - r;\n\twhile (r--) t = t * 2 % mod;\n\t\n\tLL ans = 1;\n\tint t1 = 1, t2 = 1;\n\tfor (int i = 1; i <= m; ++i)\n\t\tt1 = t1 * 2 % mod;\n\tfor (int i = 1; i < n; ++i)\n\t\tt2 = t2 * 2 % mod;\n\t\n\tans = 1LL * (t1 - t) * t2 % mod;\n\tif (ans < 0) ans += mod;\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int mod = 998244353;\nint a[300][300];\nlong long b[301];\nint f[300];\n\nint main() {\n    int n, m, c, i, j, k, l;\n    long long ans = 0;\n    \n    scanf(\"%d %d\", &n, &m);\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n    \n    b[0] = 1;\n    for (i = 1; i <= 300; i++) b[i] = b[i - 1] * 2 % mod;\n    \n    c = m;\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n            if (f[j] == 1) continue;\n            if (a[i][j] == 1) break;\n        }\n        \n        if (j == m) continue;\n        \n        c--;\n        f[j] = 1;\n        \n        for (k = j + 1; k < m; k++) {\n            if (a[i][k] == 0) continue;\n            \n            for (l = i; l < n; l++) a[l][k] ^= a[l][j];\n        }\n        \n        ans += b[c] * b[n - 1];\n        ans %= mod;\n    }\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<bitset>\n#include<stack>\nusing namespace std;\n#define MOD 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nbitset<324> mat[324];\nInt cnt,n, m,a;\nInt mod_pow(Int x, Int a, Int m = MOD){\n  if(a == 0)return 1;\n  Int res = mod_pow(x, a / 2, m);\n  res = res * res % m;\n  if(a % 2)res *= x;\n  return res % m;\n}\n\nInt inv(Int x, Int m = MOD){\n  return mod_pow(x, m-2, m);\n}\n\n\nint main(){\n  cin >> n >> m;\n  for(int i = 0;i < n;i++){\n    for(int j = 0;j < m;j++){\n      cin >> a;\n      if(a)mat[i].set(j);\n    }\n  }\n  for(int i = 0;i < n;i++){\n\tif(i == m)break;\n    int st = i;\n    while(st < n && !mat[st][i])st++;\n    if(st == n)continue;\n    cnt++;\n    if(st != i)swap(mat[st], mat[i]);\n    for(int j = i;j < m;j++){\n      if(mat[j][i])mat[j] ^= mat[i];\n    }\n  }\n  cout << ((mod_pow(2, n+m) - mod_pow(2,n+m-cnt))*inv(2) % MOD+ MOD )% MOD << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...) 0\n#endif\n\ntemplate <ll mod>\nstruct modular {\n    ll value;\n    modular(ll x = 0) {\n        value = x % mod;\n        if (value < 0) value += mod;\n    }\n\n    modular& operator+=(modular other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(modular other) {\n        if ((value -= other.value) < 0) value += mod;\n        return *this;\n    }\n    modular& operator*=(modular other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(modular other) {\n        ll a = 0, b = 1, c = other.value, m = mod;\n        while (c != 0) {\n            ll t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    modular& operator^=(modular other) {\n        ll r = 1, x = value, n = other.value;\n        while (n > 0) {\n            if (n & 1) r = r * x % mod;\n            x = x * x % mod;\n            n >>= 1;\n        }\n        value = r;\n        return *this;\n    }\n    modular operator+(modular rhs) {\n        return modular(*this) += rhs;\n    }\n    modular operator-(modular rhs) {\n        return modular(*this) -= rhs;\n    }\n    modular operator*(modular rhs) {\n        return modular(*this) *= rhs;\n    }\n    modular operator/(modular rhs) {\n        return modular(*this) /= rhs;\n    }\n    modular operator^(modular rhs) {\n        return modular(*this) ^= rhs;\n    }\n    bool operator==(modular rhs) {\n        return value == rhs.value;\n    };\n    bool operator!=(modular rhs) {\n        return value != rhs.value;\n    };\n    bool operator<(modular rhs) {\n        return value < rhs.value;\n    }\n    bool operator>(modular rhs) {\n        return value > rhs.value;\n    }\n};\ntemplate <ll mod>\nstring to_string(modular<mod> x) {\n    return to_string(x.value);\n}\ntemplate <ll mod>\nostream& operator<<(ostream& stream, modular<mod> x) {\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream << x.value;\n}\ntemplate <ll mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream;\n}\nconst ll mod = 998244353;\nusing mint = modular<mod>;\n\nmint abs(mint a) {\n    return a.value;\n}\n\ntemplate <class T>\nstruct matrix {\n    vector<vector<T>> a;\n    matrix(int height, int width)\n        : a(height, vector<T>(width)) {}\n    matrix(int n)\n        : a(n, vector<T>(n)) {}\n    int size() {\n        return a.size();\n    }\n    inline vector<T>& operator[](int i) {\n        return a[i];\n    }\n};\ntemplate <class T>\nmatrix<T> operator*(matrix<T> a, matrix<T> b) {\n    matrix<T> r(a.size(), b[0].size());\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < b[0].size(); j++)\n            for (int k = 0; k < b.size(); k++) r[i][j] += a[i][k] * b[k][j];\n    return r;\n}\ntemplate <class T>\nmatrix<T> operator+(matrix<T> a, matrix<T> b) {\n    matrix<T> r(a.size(), a[0].size());\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++) r[i][j] = a[i][j] + b[i][j];\n    return r;\n}\ntemplate <class T>\nmatrix<T> operator-(matrix<T> a, matrix<T> b) {\n    matrix<T> r(a.size(), a[0].size());\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++) r[i][j] = a[i][j] - a[i][j];\n    return r;\n}\ntemplate <class T>\nmatrix<T> operator^(matrix<T> a, ll n) {\n    matrix<T> r(a.size());\n    for (int i = 0; i < a.size(); i++) r[i][i] = 1;\n    while (n > 0) {\n        if (n & 1) r = r * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate <class T>\nbool operator==(matrix<T> a, matrix<T> b) {\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++)\n            if (a[i][j] != b[i][j]) return false;\n    return true;\n}\ntemplate <class T>\nbool operator!=(matrix<T> a, matrix<T> b) {\n    return !(a == b);\n}\ntemplate <class T>\nvoid print(matrix<T> a) {\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++)\n            cout << a[i][j] << ((j != a[0].size() - 1) ? ' ' : '\\n');\n}\ntemplate <class T>\nstring to_string(matrix<T> a) {\n    return to_string(a.a);\n}\ntemplate <class T>\nint gaussian_elimination(matrix<T>& a, bool is_extended = false) {\n    int m = a.size(), n = a[0].size();\n    int rank = 0;\n    T det = 1;\n    for (int col = 0; col < n; ++col) {\n        if (is_extended && col == n - 1) break;\n        int pivot = -1;\n        T mx = 1e-5;\n        for (int row = rank; row < m; ++row) {\n            if (abs(a[row][col]) > mx) {\n                mx = abs(a[row][col]);\n                pivot = row;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(a[pivot], a[rank]);\n        auto fac = a[rank][col];\n        det *= fac;\n        for (int col2 = 0; col2 < n; col2++) a[rank][col2] /= fac;\n        for (int row = 0; row < m; row++) {\n            if (row != rank && abs(a[row][col]) > 1e-9) {\n                auto fac = a[row][col];\n                for (int col2 = 0; col2 < n; col2++) {\n                    a[row][col2] -= a[rank][col2] * fac;\n                    a[row][col2] %= 2;\n                    if (a[row][col2] < 0) a[row][col2]++;\n                }\n            }\n        }\n        rank++;\n    }\n    return rank;\n    // return (m == rank ? det : 0);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    matrix<int> a(n, m);\n    rep(i, 0, n) rep(j, 0, m) cin >> a[i][j];\n    int r = gaussian_elimination(a);\n    debug(r);\n    mint ans = (mint)2 ^ (mint)(n + m - 1);\n    ans -= (mint)2 ^ (mint)(n + m - r - 1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n[yahoo-procon2019-qual] E - Odd Subrectangles\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n\ntypedef int Number;\ntypedef vector<Number> Array;\ntypedef vector<Array> Matrix;\nconst Number eps = 0;\n\nint mat_rank(Matrix A) {\n    const int n = A.size(), m = A[0].size();\n    int r = 0;\n    for (int i = 0; r < n && i < m; ++i) {\n        int pivot = r;\n        for (int j = r + 1; j < n; ++j) {\n            if (A[j][i]) {\n                pivot = j;\n                break;\n            }\n        }\n        swap(A[pivot], A[r]);\n        if (A[r][i] <= eps) {\n            continue;\n        }\n        for (int j = r + 1; j < n; ++j) {\n            if (A[j][i]) {\n                for (int k = i; k < m; ++k) {\n                    A[j][k] ^= A[r][k];\n                }\n            }\n        }\n        ++r;\n    }\n    return r;\n}\n\nconst ll MOD = 998244353;\n\nint N, M;\nMatrix a;\n\nll pow2(int n) {\n    ll ret = 1;\n    for (int i = 0; i < n; i++) {\n        ret = (ret << 1) % MOD;\n    }\n    return ret;\n}\n\nll solve() {\n    int r = mat_rank(a);\n    return (pow2(N + M - 1) + MOD - pow2(N + M - r - 1)) % MOD;\n}\n\nint main() {\n    cin >> N >> M;\n\n    a.resize(N);\n    for (int i = 0; i < N; i++) {\n        a[i].resize(M);\n        for (int j = 0; j < M; j++) {\n            cin >> a[i][j];\n        }\n    }\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nauto no = [](){cout << \"NO\"; exit(0);};\nauto read = [](){int x; cin >> x; return x;};\n#define maxn 300\nconst LL mod = 998244353;\nint A[maxn][maxn];\nLL power(LL a, LL m){\n\tLL res = 1;\n\tfor(int i = 0; i < m; i += 1) res = res * a % mod;\n\treturn res;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tint N, M;\n\tcin >> N >> M;\n\tfor(int i = 0; i < N; i += 1)\n\t\tfor(int j = 0; j < M; j += 1) cin >> A[i][j];\n\tint X = min(N, M);\n\tfor(int i = 0; i < X; i += 1){\n\t\tint t = i;\n\t\tfor(int j = i; j < N; j += 1) if(A[j][i]) t = j;\n\t\tfor(int j = 0; j < M; j += 1) swap(A[i][j], A[t][j]);\n\t\tif(A[i][i] == 0) continue;\n\t\telse for(int j = i + 1; j < N; j += 1) if(A[j][i]){\n\t\t\tfor(int k = i; k < M; k += 1) A[j][k] ^= A[i][k];\n\t\t}\n\t}\n\tint O = 0;\n\tfor(int i = 0; i < N; i += 1){\n\t\tint ok = 1;\n\t\tfor(int j = 0; j < M; j += 1) if(A[i][j]) ok = 0;\n\t\tO += ok;\n\t}\n\t//cout << N << O << M;\n\tcout << (power(2, N) - power(2, O)) * power(2, M - 1) % mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,a[305][305];\n\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>a[i][j];\n\tint nxt = 1;\n\tfor(int j=1;j<=m;j++){\n\t\tint pck = -1;\n\t\tfor(int x=nxt;x<=n;x++){\n\t\t\tif(a[x][j] == 1){\n\t\t\t\tpck = x; break;\n\t\t\t}\n\t\t}\n\t\tif(pck == -1) continue;\n\t\trepn(j,m) swap(a[nxt][j],a[pck][j]);\n\t\tfor(int x=nxt+1;x<=n;x++){\n\t\t\tif(a[x][j] == 1){\n\t\t\t\tfor(int jj=j;jj<=m;jj++){\n\t\t\t\t\ta[x][jj] ^= a[nxt][jj];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnxt++;\n\t}\n\tint ans = n+1-nxt; \n\tll A = 1;\n\trep(i,ans) A = A*2LL%mod;\n\tll B = 1;\n\trep(i,n) B = B*2LL%mod;\n\tB -= A;\n\trep(i,m-1) B = B*2LL%mod;\n\tcout << (B%mod+mod)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 998244353;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\nclass Solver2 {\n public:\n  int n, m;\n  vector<vector<int>> a;\n  Solver2(LL n, LL m) : n(n), m(m), a(n, vector<int>(m)){};\n\n  int sweep(vector<vector<int>> X) {\n    int rank = 0;\n    for (int col = 0; col < m; ++col) {\n      int nonzeroRow = -1;\n      for (int r = 0; r < n; ++r) {\n        if (X[r][col]) {\n          nonzeroRow = r;\n          break;\n        }\n      }\n      if (nonzeroRow == -1) continue;\n      rank++;\n      for (int r = nonzeroRow + 1; r < n; ++r) {\n        if (X[r][col]) {\n          for (int c = col; c < m; ++c) {\n            X[r][c] ^= X[nonzeroRow][c];\n          }\n        }\n      }\n    }\n    return rank;\n  }\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        cin >> a[i][j];\n      }\n    }\n    int rank = sweep(a);\n\n    cout << (Modint<>(2).mpow(rank) - 1) * Modint<>(2).mpow(n - rank) * Modint<>(2).mpow(m - 1) << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nostream &operator<<(ostream &os, const pint &a) { os << \"(\" << a.fi << \",\" << a.se << \")\"; return os; }\nostream &operator<<(ostream &os, const vector<int> &a) {\n\tos<<\"[\";\n\trep(i,a.size()){\n\t\tos<<a[i];\n\t\tif(i<a.size()-1) os<<\",\";\n\t}\n\tos<<\"]\";\n\treturn os; \n}\nvector<vector<int> > mat;\nint ma[334][334];\nlint mo=998244353;\nlint zyo(lint x,lint y){\n    lint ret=1,a=x;\n    while(y>0){\n    \tif(y%2==1) ret=(ret*a)%mo;\n    \ta=(a*a)%mo;y/=2;\n    }\n    return ret;\n}\nint main()\n{\n\tmemset(ma,0,sizeof(ma));\n\tint n,m;\n\tcin>>n>>m;\n\trep(i,n) rep(j,m) cin>>ma[i][j];\n\tif(n<m){\n\t\trep(i,m) REP(j,i+1,m) swap(ma[i][j],ma[j][i]);\n\t\tswap(n,m);\n\t}\n\trep(i,n){\n\t\tvector<int> cl(m,0);\n\t\tmat.pb(cl);\n\t\trep(j,m) mat[i][j]=ma[i][j]%2;\n\t}\n\t//rep(i,n) cout<<mat[i]<<endl;\n\t//rep(i,n) rep(j,m) mat[i][j]%=2;\n\tint rank=0;\n\trep(i,m){\n\t\t//if(rank>=m) continue;\n\t\tREP(j,rank,n){\n\t\t\tif(mat[j][i]>0) swap(mat[j],mat[rank]);\n\t\t}\n\t\tif(mat[rank][i]<1){\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,n){\n\t\t\tif(mat[j][i]==0) continue;\n\t\t\trep(k,m){\n\t\t\t\tif(k<i) assert(mat[rank][k]==0);\n\t\t\t\tmat[j][k]+=mat[rank][k];mat[j][k]%=2;\n\t\t\t}\n\t\t}\n\t\trank++;\n\t}\n\t//cout<<n<<m<<rank<<endl;\n\t//lint zyo=1;rep(i,rank) zyo=(zyo*2)%mo;zyo--;\n\tlint out=zyo(2,rank);out--;\n\tout*=zyo(2,m-1);out%=mo;\n\tout*=zyo(2,n-rank);out%=mo;\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nll mo=998244353;\n\nconst int MAT=402;\nint A[402][402];\n\nint gf2_rank(int A[MAT][MAT]) { /* input */\n\tint i,j,k;\n\tFOR(i,H) {\n\t\tint be=i,mi=W+1;\n\t\tfor(j=i;j<H;j++) {\n\t\t\tFOR(k,W) if(A[j][k]) break;\n\t\t\tif(k<mi) be=j,mi=k;\n\t\t}\n\t\tif(mi>=W) break;\n\t\tFOR(j,W) swap(A[i][j],A[be][j]);\n\t\t\n\t\tFOR(j,H) if(i!=j&&A[j][mi]) {\n\t\t\tFOR(k,W) A[j][k] ^= A[i][k];\n\t\t}\n\t}\n\treturn i;\n}\n\nll dp[603][603];\nll p2[3030];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) FOR(x,W) cin>>A[y][x];\n\tif(H<W) {\n\t\tFOR(y,400) FOR(x,400) if(y<x) swap(A[y][x],A[x][y]);\n\t\tswap(H,W);\n\t}\n\t\n\tp2[0]=1;\n\tFOR(i,305) p2[i+1]=p2[i]*2%mo;\n\t\n\tx=gf2_rank(A);\n\tll ret=(p2[x]+mo-1)*p2[H-x]%mo*p2[W-1]%mo;\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,a) for(int i=start[(a)];i;i=e[i].next)\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\ninline int read()\n{\n\tint sum=0,p=1;char ch=getchar();\n\twhile(!(('0'<=ch && ch<='9') || ch=='-'))ch=getchar();\n\tif(ch=='-')p=-1,ch=getchar();\n\twhile('0'<=ch && ch<='9')sum=sum*10+ch-48,ch=getchar();\n\treturn sum*p;\n}\n\nconst int mod=998244353;\nconst int maxn=320;\n\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(ll)ans*a%mod;\n\t\tb>>=1;\n\t\ta=(ll)a*a%mod;\n\t}\n\treturn ans;\n}\n\nint a[maxn][maxn],n,m;\nbitset<320>b[maxn];\nbitset<320>s[maxn];int vis[maxn];\n\ninline void insert(bitset<320> x)\n{\n\tDREP(i,m,1)if(x[i])\n\t{\n\t\tif(!vis[i]){ s[i]=x;vis[i]=1; break;}\n\t\telse x^=s[i];\n\t}\n}\n\ninline void init()\n{\n\tn=read();m=read();\n\tREP(i,1,n)REP(j,1,m)a[i][j]=read();\n\tREP(j,1,m)\n\t{\n\t\tint s=0;\n\t\tREP(i,1,n)s+=a[i][j];\n\t\tif(s&1)REP(i,1,n)a[i][j]^=1;\n\t}\n\tREP(i,1,n)REP(j,1,m)if(a[i][j])b[i].set(j);\n\tREP(i,1,n)\n\t{\n\t\tinsert(b[i]);\n\t}\n}\n\ninline void doing()\n{\n\tint ss=0; REP(i,1,m)ss+=vis[i];\n\tint ans=(ll)(power(2,n)-power(2,n-ss)+mod)*power(2,m-1)%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <chrono>\n#include <ctime>\n#include <bitset>\n#include <iterator>\n#include <cmath>\n#include <stack>\n#include <random>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr ll mod = 998244353;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nint mat[301][301];\n\nvoid xori(int k, int i) {\n  if (k==i) return;\n  for(int j=0; j<=300; j++) {\n    mat[k][j] ^= mat[i][j];\n  }\n}\n\nvoid xorj(int k, int j) {\n  if (k==j) return;\n  for(int i=0; i<=300; i++) {\n    mat[i][k] ^= mat[i][j];\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m; cin >> n >> m;\n  \n  rep(i, n) {\n    rep(j, m) {\n      cin >> mat[i][j];\n    }\n  }\n\n  int maxk = min(n, m);\n  int rank = 0;\n  rep(k, maxk) {\n    int pi, pj; bool find = false;\n    for(int i=k; i<n; i++) {\n      for(int j=k; j<m; j++) {\n        if (mat[i][j]) {\n          //debug(i);debugln(j);\n          pi = i;\n          pj = j;\n          find = true;\n          break;\n        }\n      }\n      if (find) break;\n    }\n    if (!find) {\n      // calc rank\n      break;\n    }\n    rank++;\n    //debug(k);debug(pi);debugln(pj);\n    xori(k, pi);\n    xorj(k, pj);\n    for(int i=k+1; i<n; i++) {\n      if (mat[i][k]) {\n        xori(i, k);\n      }\n    }\n  }\n  //debugln(rank);\n  int c = n+m-1;\n  int d = n+m-rank-1;\n\n  int ansc = 1;\n  int ansd = 1;\n  while(c--) {\n    ansc <<= 1;\n    ansc %= mod;\n  }\n  while(d--) {\n    ansd <<= 1;\n    ansd %= mod;\n  }\n  cout << (ansc+mod-ansd)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\n\nint compute_rank(vector< vector< double > > A) {\n    int n = A.size();\n    int m = A[0].size();\n\n    int rank = n;\n    vector<bool> row_selected(n, false);\n    for (int i = 0; i < m; ++i) {\n        int j;\n        for (j = 0; j < n; ++j) {\n            if (!row_selected[j] && abs(A[j][i]) > EPS)\n                break;\n        }\n\n        if (j == n) {\n            // --rank;\n        } else {\n            row_selected[j] = true;\n            for (int p = i + 1; p < m; ++p)\n                A[j][p] /= A[j][i];\n            for (int k = 0; k < n; ++k) {\n                if (k != j && abs(A[k][i]) > EPS) {\n                    for (int p = i + 1; p < m; ++p)\n                        A[k][p] -= A[j][p] * A[k][i];\n                }\n            }\n        }\n    }\n\n    for(int i = 0 ; i < n ; i++){\n        bool has_one = false;\n\n        for(int j = 0 ; j < m ; j++){\n            if(!(abs(A[i][j]) < EPS)){\n                has_one = true;\n                break;\n            }\n        }\n\n        if(!has_one){\n            rank--;\n        }\n    }\n\n    return rank;\n}\n\nvector< vector< double > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    // cout << mod * mod << endl;\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            double x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = compute_rank(a);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n + m - 1);\n    ll nr = fast_pow(2LL, n + m - rank - 1);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD(nn - nr) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353; //1000000007;\n\nll mod_pow(ll a,ll x){\n    ll ret=1;\n    while(x>0){\n        if(x&1){(ret*=a)%=MOD;}\n        (a*=a)%=MOD;\n        x>>=1;\n    }\n    return ret;\n}\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    vector<vector<ll>> A(n,vector<ll>(m));\n    for(auto &I:A){for(auto &T:I){cin>>T;}}\n    ll cnt=m;\n    ll w=0;\n    for(int i=0;i<n && w<m;i++,w++){\n        for(int h=i+1;h<n;h++){\n            if(A[i][w]==0 && A[h][w]==1){swap(A[i],A[h]);}\n        }\n        if(A[i][w]==0){cnt--; i--; continue;}\n        for(int h=i+1;h<n;h++){\n            if(A[h][w]){\n                for(int w=0;w<m;w++){\n                    A[h][w]^=A[i][w];\n                }\n            }\n        }\n        if(i+1==n){cnt-=m-w-1;}\n    }\n    ll ans=mod_pow(2,n+m-1)-mod_pow(w,n+m-cnt-1);\n    ans%=MOD;\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n  Int_ inv(){\n    return Int_(mpow(x,mod-2));\n  }\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<998244353> Int;\n\nInt mpow(Int a,lint k){\n  Int res=1;\n  while(k){\n    if(k&1) res=res*a;\n    a=a*a;\n    k>>=1;\n  }\n  return res;\n}\nconst int INF=5e8;\nint h,w;\nint ar[305][305];\n\nint calc_rank(){\n  int res=0;\n  int row=0;\n  REP(i,w){\n    int idx=-1;\n    REPN(j,h,row) if(ar[j][i]){\n      idx=j;\n      break;\n    }\n    if(idx==-1){\n      continue;\n    }\n    if(idx!=row) REP(j,w) swap(ar[idx][j],ar[row][j]);\n    REPN(j,h,i+1) if(ar[j][i]){\n      REP(k,w) ar[j][k]^=ar[row][k];\n    }\n    ++res;\n    ++row;\n  }\n  return res;\n}\nint main(){\n  cin>>h>>w;\n  REP(i,h) REP(j,w) cin>>ar[i][j];\n  int R=calc_rank();\n\n  Int res=(mpow(2,h)-mpow(2,h-R))*mpow(2,w-1);\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<bitset>\n#include<stack>\nusing namespace std;\n#define MOD 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nbitset<324> mat[324];\nInt cnt,n, m,a;\nInt mod_pow(Int x, Int a, Int m = MOD){\n  if(a == 0)return 1;\n  Int res = mod_pow(x, a / 2, m);\n  res = res * res % m;\n  if(a % 2)res *= x;\n  return res % m;\n}\n\nInt inv(Int x, Int m = MOD){\n  return mod_pow(x, m-2, m);\n}\n\n\nint main(){\n  cin >> n >> m;\n  for(int i = 0;i < n;i++){\n    for(int j = 0;j < m;j++){\n      cin >> a;\n      if(a)mat[i].set(j);\n    }\n  }\n  int p = 0;\n  for(int i = 0;i < n;i++){\n    if(p == m)continue;\n    int st = i;\n    while(st < n && !mat[st][p])st++;\n    if(st == n){\n      p++;\n      i--;\n      continue;\n    }\n    cnt++;\n    if(st != i)swap(mat[st], mat[i]);\n    for(int j = i+1;j < n;j++){\n      if(mat[j][p])mat[j] ^= mat[i];\n    }\n  }\n  cout << ((mod_pow(2, n+m) - mod_pow(2,n+m-cnt))*inv(2) % MOD+ MOD )% MOD << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n//x,yがax+by=gcd(a,b)の解になる\nll extgcd(ll a, ll b, ll& x, ll& y) {\n\tll d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n//aのmod mでの逆元を求める\nll mod_inverse(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\nconst int N_MAX = 1 << 18;\nll p[N_MAX];\nvoid init() {\n\tp[0] = 1;\n\trep1(i, N_MAX - 1) {\n\t\tp[i] = p[i - 1] * i%mod;\n\t}\n}\n//xCyを求める\nll comb(ll x, ll y, ll m) {\n\tif (x < y)return 0;\n\tll res = p[x];\n\t(res *= mod_inverse(p[y], m)) %= mod;\n\t(res *= mod_inverse(p[x - y], m)) %= mod;\n\treturn res;\n}\nll mod_pow(ll x, int n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nint n, m;\nint a[300][300];\nint calcrank() {\n\tint res = 0;\n\tint le = 0;\n\trep(i, m) {\n\t\tbool ansed = false;\n\t\tRep(j,le, n) {\n\t\t\tif (a[j][i]) {\n\t\t\t\tswap(a[j], a[i]);\n\t\t\t\tansed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ansed) {\n\t\t\tRep(j, le + 1, n) {\n\t\t\t\tif (a[j][i]) {\n\t\t\t\t\trep(l, m) {\n\t\t\t\t\t\ta[j][l] ^= a[i][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++; le++;\n\t\t}\n\t}\n\treturn res;\n}\nll inv2 = (1 + mod) / 2;\nll inv4 = inv2 * inv2%mod;\nll inv34 = 3 * inv4%mod;\nint main() {\n\tinit();\n\tcin >> n >> m;\n\tint num = 0;\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tint r = calcrank();\n\tll ans = 0;\n\tfor (int j = 1; j <= r; j += 2) {\n\t\tll csum = mod_pow(2, (n - r)+(m - r));\n\t\tcsum = csum * comb(r, j, mod) %mod*mod_pow(3, r - j) % mod;\n\t\t(ans += csum) %= mod;\n\t}\n\tcout << ans << endl;\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,a) for(int i=start[(a)];i;i=e[i].next)\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\ninline int read()\n{\n\tint sum=0,p=1;char ch=getchar();\n\twhile(!(('0'<=ch && ch<='9') || ch=='-'))ch=getchar();\n\tif(ch=='-')p=-1,ch=getchar();\n\twhile('0'<=ch && ch<='9')sum=sum*10+ch-48,ch=getchar();\n\treturn sum*p;\n}\n\nconst int mod=998244353;\nconst int maxn=320;\n\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(ll)ans*a%mod;\n\t\tb>>=1;\n\t\ta=(ll)a*a%mod;\n\t}\n\treturn ans;\n}\n\nint a[maxn][maxn],n,m;\nbitset<320>b[maxn];\nbitset<320>s[maxn];int vis[maxn];\n\ninline void insert(bitset<320> x)\n{\n\tDREP(i,m,1)if(x[i])\n\t{\n\t\tif(!vis[i]){ s[i]=x;vis[i]=1; break;}\n\t\telse x^=s[i];\n\t}\n}\n\ninline void init()\n{\n\tn=read();m=read();\n\tREP(i,1,n)REP(j,1,m)a[i][j]=read();\n\tREP(j,1,m)\n\t{\n\t\tint s=0;\n\t\tREP(i,1,n)s+=a[i][j];\n\t\t//if(s&1)REP(i,1,n)a[i][j]^=1;\n\t}\n\tREP(i,1,n)REP(j,1,m)if(a[i][j])b[i].set(j);\n\tREP(i,1,n)\n\t{\n\t\tinsert(b[i]);\n\t}\n}\n\ninline void doing()\n{\n\tint ss=0; REP(i,1,m)ss+=vis[i];\n\tint ans=(ll)(power(2,n)-power(2,n-ss)+mod)*power(2,m-1)%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n    const int MAX =200002;\nconst int MOD =  998244353;\nint modpow(int a, int n, int mod) {\n    int res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n     signed main(){\n  int n,m,k;\n  cin>>n>>m;\n  bitset<300> a[n];\n  for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n      cin>>k;\n      if(k)a[i].set(j);\n      else a[i].reset(j);\n  }\n  int j0=0;\n  for(int i=0;i<m;i++){\n      for(int j=j0;j<n;j++){\n          if(a[j][i]){\n              swap(a[j],a[j0]);\n              break;\n          }\n      }\n      if(a[j0][i]){\n          for(int j=j0+1;j<n;j++){\n              if(a[j][i])a[j]^=a[j0];\n          }\n          j0++;\n      }\n  }\n\n  cout<<(MOD+modpow(2,n,MOD)-modpow(2,n-j0,MOD))%MOD*modpow(2,m-1,MOD)%MOD<<endl;\n\n\n\n     }\n\n\n \n\n\n \n\n\n\n\n\n\n    \n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 302;\nconst int MOD = 998244353;\n\nbitset<N>a[N];\nint32_t main() {\n\n    int n, m;\n    cin >> n >> m;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    // n ecuatii cu m necunoscute, rezultatul e 0\n    for(int i = 0; i < n; ++i) {\n        a[i][m] = 0;\n    }\n\n    int l = 0, c = 0, var_free = 0;\n    while(l < n && c < m) {\n        int poz = -1;\n        for(int i = l; i < n && poz == -1; i++)\n            if(a[i][c] != 0)\n                poz = i;\n\n        if(poz == -1) {\n            // n-am putut gasi, e deja 0\n            c++;\n            var_free++; // este variabila libea\n            continue;\n        }\n        swap(a[l], a[poz]);\n        for(int i = l + 1; i < n; ++i)\n            a[i] ^= a[l];\n        l++;\n    }\n    vector<long long>p2(n + m + 1);\n    p2[0] = 1;\n    for(int i = 1; i <= n + m; ++i)\n        p2[i] = 2 * p2[i - 1] % MOD;\n    int aux1, aux2;\n\n    aux1 = (p2[n] - 1 + MOD) % MOD, aux2 = p2[m - 1];\n    int answer = (1LL * aux1 * aux2) % MOD;\n\n    aux1 = (p2[var_free] - 1 + MOD) % MOD, aux2 = p2[m - 1];\n\n    cout << answer;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, vector<vector<int>>& scc, stack<int>& S, vector<int>& inS, vector<int>& low,vector<int>& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(vector<int>());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph& g, vector<vector<int>>& scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tvector<int> num(n), low(n);\n\tstack<int> S;\n\tvector<int> inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\nclass SumSegTree {\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\t// 区間[l,r)の総和\n\tll sum(ll l, ll r) {\n\t\tll ret = 0;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)ret += dat[l];\n\t\t\tif ((r & 1) == 0)ret += dat[r - 1];\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\nwhile (n > 0) {\n\tif (n & 1) res = res * x % mod;\n\tx = x * x % mod;\n\tn >>= 1;\n}\nreturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n);\n\t\tinv[n - 1] = mod_inv(fact[n - 1]);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\n\nvoid rowReduction(vector<bitset<330>> mat, vector<bitset<330>>& basis) {//掃き出し法\n\tfor (auto e : mat) {\n\t\tfor (auto b : basis) {\n\t\t\tauto tmp = e ^ b;\n\t\t\tfor (int i = 329; i >= 0; i--) {\n\t\t\t\tif (e[i] > tmp[i]) {\n\t\t\t\t\te = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (e[i] < tmp[i])break;\n\t\t\t}\n\t\t}\n\t\tif (e != 0)\n\t\t\tbasis.push_back(e);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tconstexpr ll mod = 998244353;\n\tll n, m;\n\tcin >> n >> m;\n\tMatrix a(n, Array(m));\n\tREP(i, n)REP(j, m)cin >> a[i][j];\n\tvector<bitset<330>> mat(n);\n\tREP(i, n)REP(j, m)mat[i][j] = a[i][j] % 2;\n\tvector<bitset<330>> basis;\n\trowReduction(mat, basis);\n\tll ans = mod_pow(2, n + m - 1, mod);\n\t(ans += mod - mod_pow(2, n + m - basis.size() - 1, mod)) %= mod;\n\tcout << ans << \"\\n\";\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 998244353\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nclass MTwo{\npublic:\n    using t = bool;\n    static t id() {\n        return false;\n    }\n\tstatic t e() {\n        return true;\n    }\n\t// * \n    static t op1(const t& l, const t& r){\n        return l && r;\n    }\n\t// + \n\tstatic t op2(const t& l, const t& r){\n        return l ^ r;\n    }\n\t// - \n\tstatic t op3(const t& x){\n        return x;\n    }\n\t// /\n\tstatic t op4(const t& x) {\n        return x;\n    }\n};\ntemplate< typename M >\nstruct Matrix{\n\tusing T = typename M::t;\n\tint H;\n\tint W;\n\tvector<T> data;\n    Matrix(int n_)\n        : H(n_), W(n_), data(n_ * n_, M::id()) {}\n    Matrix(int h_, int w_)\n        : H(h_), W(w_), data(h_ * w_, M::id()) {}\n\tMatrix(int n_,vector<T> d_)\n        : H(n_), W(n_) {data = d_;}\n    Matrix(int h_, int w_, vector<T> d_)\n        : H(h_), W(w_) {data = d_;}\n  \tvoid Update(int h,int w,T x){\n    \tdata[h*W+w] = x;\n  \t}\n  \tconst T Get(int h,int w){\n    \treturn data[h*W+w];\n  \t}\n\tint Rank(){\n\t\tint ans = 0;\n\t\tvector<T> A(H*W);\n\t\tfor(int i=0;i<H*W;i++){\n\t\t\tA[i] = data[i];\n\t\t}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tint nonzero = -1;\n\t\t\tfor(int j=i;j<W;j++){\n\t\t\t\tif(A[j*W+i] != M::id()){\n\t\t\t\t\tnonzero = j;\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nonzero != -1){\n\t\t\t\tfor(int j=i;j<W;j++){\n\t\t\t\t\tT temp = A[nonzero*W+j];\n\t\t\t\t\tA[nonzero*W+j] = A[i*W+j];\n\t\t\t\t\tA[i*W+j] = temp;\n\t\t\t\t}\n\t\t\t\tfor(int j=i+1;j<H;j++){\n\t\t\t\t\tT d = M::op3(M::op1(M::op4(A[i*W+i]),A[j*W+i])); \n\t\t\t\t\tfor(int k=i;k<W;k++){\n\t\t\t\t\t\tA[j*W+k] = M::op2(A[j*W+k],M::op1(A[i*W+k],d));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn ans;\n\t}\n\tstatic Matrix I(int N){\n\t\tMatrix ans(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans.Update(i,i,M::e());\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Plus(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op2(A.Get(i,j),B.Get(i,j)));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Minus(Matrix& A){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op3(A.Get(i,j)));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Minus(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op2(A.Get(i,j),M::op3(B.Get(i,j))));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Prod(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = B.W;\n\t\tint K = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tT c = M::id();\n\t\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\t\tc = M::op2(c,M::op1(A.Get(i,k),B.Get(k,j)));\n\t\t\t\t}\n\t\t\t\tans.Update(i,j,c);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Pow(Matrix A,long r){\n\t\tint n = A.H;\n\t\tMatrix ans = I(n);\n\t\twhile(r){\n\t\t\tif(r % 2 == 1){\n\t\t\t\tans = Prod(ans,A);\n\t\t\t}\n\t\t\tA = Prod(A,A);\n\t\t\tr /= 2;\n\t\t}\n\t\treturn ans;\n\t}\n};\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tvector<bool> A(N*M);\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\tint x = rei();\n\t\t\tA[i*M+j] = x % 2 == 1;\n\t\t}\n\t}\n\tMatrix<MTwo> mat(N,M,A);\n\tint r = mat.Rank();\n\tlong ans1 = 1;\n\tlong ans2 = 1;\n\tfor(int i=0;i<N+M-1;i++){\n\t\tans1 *= 2;\n\t\tans1 %= mod;\n\t}\n\tfor(int i=0;i<N+M-r-1;i++){\n\t\tans2 *= 2;\n\t\tans2 %= mod;\n\t}\n\tcout << (ans1 - ans2 + mod) % mod << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#define inf 20021225\n#define ll long long\n#define mdn 998244353\nusing namespace std;\n\nbitset<310> r[310]; int n,m;\nint gauss()\n{\n\tint w = 0;\n\tfor(int i=1,j;i<=n;i++)\n\t{\n\t\tif(!r[i][i])\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t\tif(r[j][i])\tbreak;\n\t\t\tif(j>n)\tcontinue;\n\t\t\tswap(r[i],r[j]);\n\t\t}\n\t\tfor(j=i+1;j<=m;j++)\n\t\t\tif(r[j][i])\tr[j]^=r[i];\n\t\tif(r[i].count())\tw++;\n\t}\n\treturn w;\n}\nint ksm(int bs,int mi)\n{\n\tint ans = 1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=(ll)ans*bs%mdn;\n\t\tbs=(ll)bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tr[i][j] = x;\n\t\t}\n\tint ans = ksm(2,n+m-1)-ksm(2,n+m-1-gauss());\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    using mint = mod_int<998244353>;\n    vector a(N, vint(M));\n    rep(i, N) rep(j, M) { cin >> a[i][j]; }\n    int r = 0;\n    rep(i, min(N, M)) {\n        sort(a.begin() + r, a.begin() + N), reverse(a.begin() + r, a.begin() + N);\n        for (int j = r + 1; j < N; j++) {\n            if (a[r][i] == a[j][i]) {\n                for (int k = i; k < M; k++) { a[j][k] ^= a[r][k]; }\n            }\n        }\n        if (a[r][i]) { r++; }\n    }\n    cout << mint(2).pow(N + M - 1) - mint(2).pow(N + M - r - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// LHiC氏.\n// https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4214380\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repx(i, a, b) for(int i = a; i < b; i++)\nconst LL MOD = 998244353;\nconst int MAXN = 310;\nbitset<MAXN> bb[MAXN];\n\nLL pw(LL a, LL b){\n    LL ans = 1;\n    while(b){\n        while(!(b & 1)) b >>= 1, a = (a * a) % MOD;\n        ans = (ans * a) % MOD, --b;\n    }\n    return ans;\n}\n\nint main(){\n    int n, m, x;\n    scanf(\"%d %d\", &n, &m);\n    rep(i, n){\n        rep(j, m){\n            scanf(\"%d\", &x);\n            bb[i][j] = x;\n        }\n    }\n    int now = 0;\n    rep(i, m){\n        int fl = 0;\n        repx(j, now, n){\n            if(bb[j][i]){\n                fl = 1;\n                swap(bb[j], bb[now]);\n                break;\n            }\n        }\n        if(!fl) continue;\n        repx(j, now + 1, n) if(bb[j][i]) bb[j] ^= bb[now];\n        ++now;\n    }\n    LL go = (pw(2, n) + MOD - pw(2, n - now)) % MOD;\n    printf(\"%lld\\n\", (go * pw(2, m - 1)) % MOD);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 325501;\nconst int MOD = 1e9 + 7;\n\nint n, m;\nvector<int> a[500];\nvector<int> st[500];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            int x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n    int sz = 0;\n    for (int i = 0; i < n; i++)\n    {\n        int t = -1;\n        for (int j = 0; j < m; j++)\n        {\n            if (a[i][j] && st[j].size() == 0)\n            {\n                t = j;\n                break;\n            }\n            else\n            {\n                if (a[i][j])\n                {\n                    for (int k = 0; k < m; k++)\n                    {\n                        a[i][j] = a[i][j] ^ st[j][k];\n                    }\n                }\n            }\n        }\n        if (t > -1)\n        {\n            st[t] = a[i];\n            sz++;\n        }\n    }\n    cout << inq(2, m - 1) * (inq(2, n) - inq(2, n - sz) + MOD) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <map>\n#include <set>\n#include <sys/timeb.h>\n#include <fstream>\n#include <random>\n#include <regex>\n#include <chrono>\n#include <bitset>\n#include <cassert>\n#include <iomanip>\n#include <limits>\n#include <stack>\n\nusing namespace std;\n\n#define DEBUG_\n\n#define repr(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repr(i,0,n)\n#define reprrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) reprrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n#define MOD 1000000007\n#define MOD2 998244353\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\n\n#ifdef DEBUG_\n#define DEB\n#else\n#define DEB if(false)\n#endif\n\n#ifdef DEBUG_\n#define dump(...) DUMPOUT<<\"  \"; \\\ndump_func(string(#__VA_ARGS__) + \":\", \"[\" + to_string(__LINE__) + \":\" + __FUNCTION__ + \"]\"); \\\nDUMPOUT<<\"    \"; \\\ndump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<Pi> vPi;\ntypedef vector<Pll> vPll;\ntypedef vector<Pd>vPd;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<Pi> > vvPi;\ntypedef vector<vector<vector<int> > > vvvi;\ntypedef vector<vector<vector<ll> > > vvvll;\ntypedef vector<vector<vector<Pi> > > vvvPi;\ntypedef vector<vector<vector<vector<Pi> > > > vvvvPi;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<Pi, vector<Pi>, greater<Pi> > pqlP;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate<class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nstring debug_show(Pi a) {\n\treturn \"(\" + to_string(a.first) + \",\" + to_string(a.second) + \")\";\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n\tDUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& head, Tail&&... tail) {\n\tDUMPOUT << head;\n\tif (sizeof...(Tail) <= 1) {\n\t\tDUMPOUT << \" \";\n\t}\n\telse {\n\t\tDUMPOUT << \", \";\n\t}\n\tdump_func(std::move(tail)...);\n}\n\n// vector\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec) is >> x;\n\treturn is;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, const pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// vector\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& vec) {\n\tos << \"{\";\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tos << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// map\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, map<T, U>& map_var) {\n\tos << \"{\";\n\trepi(itr, map_var) {\n\t\tos << \"(\" << itr->first << \",\" << itr->second << \")\";\n\t\titr++;\n\t\tif (itr == map_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// set\ntemplate<typename T>\nostream& operator << (ostream& os, set<T>& set_var) {\n\tos << \"{\";\n\trepi(itr, set_var) {\n\t\tos << \"  \" << *itr << endl;\n\t\titr++;\n\t\tif (itr == set_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\nstring YN(bool y, int id = 0) { if (id)cout << id; return (y ? \"YES\" : \"NO\"); }\nstring yn(bool y, int id = 0) { if (id)cout << id; return (y ? \"Yes\" : \"No\"); }\nstring ON(bool y, int id = 0) { if (id)cout << id; return (y ? \"OK\" : \"NG\"); }\n\nint dir4[4][2] = { { 0,-1 },{ -1,0 },{ 1,0 },{ 0,1 } };\nint dir8[8][2] = { { -1,-1 },{ 0,-1 },{ 1,-1 },{ -1,0 },{ 1,0 },{ -1,1 },{ 0,1 },{ 1,1 } };\nchar dirchar[4] = { '<','^','>','v' };\n\n// [a,b)\nint irand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_int_distribution<int> dist(a, b - 1);\n\treturn dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_real_distribution<double> dist(a, b);\n\treturn dist(Rand);\n}\n\nstruct Edge {\nint from, to, cost;\nbool operator<(Edge e) {\nreturn cost < e.cost;\n}\n};\nusing Graph = vec<vec<Edge>>;\n\nostream& operator << (ostream& os, Edge &edge) {\nos << \"(\" << edge.from << \"->\" << edge.to << \":\" << edge.cost << \")\";\nreturn os;\n}\n\n//======================================================\n\nll powMod(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint matrix_rank(vvi m) {\n\tint H = m.size();\n\tint W = m[0].size();\n\tint r = 0;\t// 暫定のランク（今見ている段）\n\trep(i, W) {\n\t\tif (m[r][i] == 0) {\n\t\t\tbool find = false;\n\t\t\trepr(j, r + 1, H) {\n\t\t\t\tif (m[j][i] == 1) {\n\t\t\t\t\tswap(m[r], m[j]);\n\t\t\t\t\tfind = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!find)continue;\n\t\t}\n\t\trepr(j, r + 1, H) {\n\t\t\tif (m[j][i] == 1) {\n\t\t\t\trepr(k, i, W) {\n\t\t\t\t\tm[j][k] ^= m[r][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr++;\n\t\tif (r == H)break;\n\t}\n\treturn r;\n}\n\nint main(void) {\n\tint H, W;\n\tcin >> H >> W;\n\tvvi m(H, vi(W));\n\tcin >> m;\n\tint r = matrix_rank(m);\n\tint k = W - r;\n\tll ans = powMod(2, W, MOD2) - powMod(2, k, MOD2) + MOD2;\n\tans %= MOD;\n\tans *= powMod(2, H - 1, MOD2);\n\tans %= MOD2;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\nint N, M;\nint A[311][311];\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &M);\n    REP (i, N) REP (j, M) scanf(\"%d\", &A[i][j]);\n\n    int r = 0, c = 0;\n    while (r < N && c < M) {\n\tint p = -1;\n\tfor (int i=r; i<N; i++) if (A[i][c]) {\n\t    p = i;\n\t    break;\n\t}\n\tif (p == -1) {\n\t    c++;\n\t    continue;\n\t}\n\tfor (int j=c; j<M; j++) swap(A[r][j], A[p][j]);\n\tREP (i, N) if (i != p && A[i][c]) {\n\t    for (int j=c; j<M; j++) A[i][j] ^= A[p][j];\n\t}\n\tr++;\n    }\n\n    Mint ans = (Mint(2).pow(r) - 1) * Mint(2).pow(N-r) * Mint(2).pow(M-1);\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mo 998244353\n#define N 310\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nint a[N][N],p[N][N];\nint m,n,sum;\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nint main(){\n\tread(n);read(m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)read(a[i][j]);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=m;j>=1;j--){\n\t\t\tif (p[j][j]==0){\n\t\t\t\tif (a[i][j]==1){\n\t\t\t\t\tfor (int k=1;k<=j;k++) p[j][k]=a[i][k];\n\t\t\t\t\tsum++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor (int k=1;k<=j;k++) a[i][k]^=p[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<((po(2,m)-po(2,m-sum)+mo)%mo)*po(2,n-1)%mo<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=320,mo=998244353;\n\nint a[N][N];\nint n,m;\n\ninline ll ksm(ll o,ll t)\n{\n\tll y=1;\n\tfor(;t;t>>=1,o=o*o%mo)\n\tif(t&1)y=y*o%mo;\n\treturn y;\n}\n\nbool bz[N];\n\ninline int get()\n{\n\tfo(i,1,m){\n\t\tint kk=0;\n\t\tfo(l,1,n)if(a[l][i]==1&&!bz[l]){\n\t\t\tkk=l; break;\n\t\t}\n\t\tbz[kk]=true;\n\t\tfo(l,1,n)if(!bz[l]&&a[l][i])\n\t\tfo(j,i,m)a[l][j]^=a[kk][j];\n\t}\n\tint ans=0;\n\tfo(i,1,n){\n\t\tint op=0;\n\t\tfo(l,1,m)op=op|a[i][l];\n\t\tans=ans+op;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n)fo(l,1,m)scanf(\"%d\",&a[i][l]);\n\tint r=get();\n\tll da=(ksm(2,n+m-1)-ksm(2,n+m-1-r)+mo)%mo;\n\tcout<<da;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst int NN=301;\nbool solve(bool p[NN][NN], int n, int m){\n\tint s=0;\n\tfor(int i=0;i<m;i++){\n\t\tint d=-1;\n\t\tfor(int j=s;j<n;j++){\n\t\t\tif(p[j][i]){\n\t\t\t\td=j;\n\t\t\t}\n\t\t}\n\t\tif(d==-1){\n\t\t\tcontinue;\n\t\t}\n\t\tif(d!=i){\n\t\t\tfor(int j=i;j<m;j++){\n\t\t\t\tswap(p[i][j],p[d][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=s+1;j<n;j++){\n\t\t\tif(!p[j][i])continue;\n\t\t\tfor(int k=i;k<n+1;k++){\n\t\t\t\tp[j][k]^=p[i][k];\n\t\t\t}\n\t\t}\n\t\ts++;\n\t}\n\treturn s;\n}\n\nbool a[301][301];\nLL C[301][301];\nconst LL M=998244353;\nint main() {\n\tint N,K;\n\tcin >> N >> K;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tint v;\n\t\t\tcin >>v;\n\t\t\tif(v){\n\t\t\ta[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tint s=solve(a,N,K);\n\tcerr << s << endl;\n\tfor(int i=0;i<301;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%M;\n\t\t}\n\t}\n\tLL ret=0;\n\tfor(int i=1;i<=s;i+=2){\n\t\tret+=C[s][i];\n\t\tret%=M;\n\t}\n\tcout << ret << endl;\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, j, k) for (int i = j; i < (int)k; i++)\n#define pb push_back\n#define mt make_tuple\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef complex<ld> point;\ntypedef vector<int> vi;\n\ninline void fileIO(string s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\n\ntemplate <class T, class S>\ninline bool smin(T &a, S b) {\n  return (T)b < a ? a = b, 1 : 0;\n}\ntemplate <class T, class S>\ninline bool smax(T &a, S b) {\n  return a < (T)b ? a = b, 1 : 0;\n}\n\nconstexpr int MOD = 924844033;\nconstexpr int N = 302;\n\ntemplate <typename T>\ninline T mod(T &v) {\n  return v = (v % MOD + MOD) % MOD;\n}\ntemplate <typename S, typename T>\ninline S add(S &l, T r) {\n  return mod(l += r);\n}\nll po(ll v, ll u) {\n  return u ? po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD : 1;\n}\n\nint n, m, id[N];\nvector<bitset<N>> paye;\nbitset<N> tmp;\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifndef LOCAL\n  // fileIO(\"superposition\");\n#endif\n  memset(id, -1, sizeof(id));\n  cin >> n >> m;\n  rep(i, 0, n) {\n    rep(j, 0, m) {\n      bool local;\n      cin >> local;\n      tmp[j] = local;\n    }\n    while (tmp.count()) {\n      int pos = tmp._Find_first();\n      if (!~id[pos]) break;\n      tmp ^= paye[id[pos]];\n    }\n    if (tmp.count()) {\n      rep(i, 0, m) if (~id[i] && tmp[i]) tmp ^= paye[id[i]];\n      id[tmp._Find_first()] = paye.size();\n      for (auto &e : paye) e ^= tmp;\n      paye.pb(tmp);\n    }\n  }\n\n  ll res = po(2, n) - po(2, n - paye.size()) + MOD;\n  mod(res *= po(2, m - 1));\n  cout << res << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  template<class Int> ModInt(Int x) : v(x >= 0 ? x % P : -x % P ? P - -x % P : 0) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool) *this; }\n  M operator*(M rhs) const { return M(*this) *= rhs; }\n  M operator/(M rhs) const { return M(*this) /= rhs; }\n  M operator+(M rhs) const { return M(*this) += rhs; }\n  M operator-(M rhs) const { return M(*this) -= rhs; }\n  bool operator==(M rhs) const { return v == rhs.v; }\n  bool operator!=(M rhs) const { return !(*this == rhs); }\n  M& operator*=(M rhs) { v = (unsigned long long) v * rhs.v % P; return *this; }\n  M& operator/=(M rhs) { return *this *= rhs.inv(); }\n  M& operator+=(M rhs) { v = rhs.v < P - v ? v + rhs.v : v - (P - rhs.v); return *this; }\n  M& operator-=(M rhs) { v = rhs.v <= v ? v - rhs.v : v + (P - rhs.v); return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  template<class Int> M pow(Int n) const {\n    n = n >= 0 ? n % (P - 1) : P - 1 - -n % (P - 1);\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  template<class Int> friend M operator*(Int lhs, M rhs) { return M(lhs) *= rhs; }\n  template<class Int> friend M operator/(Int lhs, M rhs) { return M(lhs) /= rhs; }\n  template<class Int> friend M operator+(Int lhs, M rhs) { return M(lhs) += rhs; }\n  template<class Int> friend M operator-(Int lhs, M rhs) { return M(lhs) -= rhs; }\n  friend ostream& operator<<(ostream& os, M rhs) { return os << rhs.v; }\n  friend istream& operator>>(istream& is, M& rhs) { lint x; is >> x; rhs = x; return is; }\n  template<class Int> friend bool operator==(Int lhs, M rhs) { return M(lhs) == rhs; }\n  template<class Int> friend bool operator!=(Int lhs, M rhs) { return !(lhs == rhs); }\n};\nusing Mint = ModInt<998244353>;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  V< bitset<300> > a(n);\n  for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {\n    int x; cin >> x;\n    a[i][j] = x;\n  }\n  int r = 0;\n  for (int j = 0; j < m; ++j) {\n    for (int i = r + 1; i < n; ++i) if (a[i][j]) {\n      swap(a[r], a[i]);\n      break;\n    }\n    if (!a[r][j]) continue;\n    for (int i = 0; i < n; ++i) if (i != r and a[i][j]) {\n      a[i] ^= a[r];\n    }\n    ++r;\n  }\n  Mint res = Mint(2).pow(n + m - 1) * (1 - Mint(2).pow(-r));\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 998244353LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                // C[i][j] += A[i][k] * B[k][j]; // modなし\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// Matrix Library End\n\n// N * M 行列のランクを求める\ntemplate <typename T>\nint mat_rank(Matrix<T> A) {\n    int N = A.size(), M = A[0].size();\n\n    int WID = min(N, M), res = 0;\n    for(int i=0; i<WID; i++) {\n        // 絶対値が最も大きいものを探す\n        T max_elem = 0; int piv = -1;\n        for(int j=res; j<N; j++) {\n            if(abs(A[j][i]) > max_elem) {\n                max_elem = abs(A[j][i]);\n                piv = j;\n            }\n        }\n\n        // fprintf(stderr, \"# piv = %lld\\n\", piv);\n        if(piv < 0) continue;\n            \n        // res 行目を piv 行目に変えて、行基本変形\n        swap(A[res], A[piv]);\n\n        // res 行目を正規化\n        // 行列が整数の場合とかやばそう\n        // 基本的に引数は double の行列に限定すべきでは？\n        for(int k=0; k<M; k++) {\n            A[res][k] = (T)(1.0 * A[res][k] / A[res][i]);\n        }\n        \n        for(int j=0; j<N; j++) {\n            if(j == res) continue;\n            assert(A[res][i] != 0);\n            T mul = A[j][i];\n            for(int k=0; k<M; k++) {\n                A[j][k] = (T)(A[j][k] - mul * A[res][k]);\n            }\n        }\n        res++;\n\n        /*\n        fprintf(stderr, \"# matrix debug\\n\");\n        for(int x=0; x<N; x++) {\n            for(int y=0; y<M; y++) {\n                fprintf(stderr, \"%lld \", A[x][y]);\n            }\n            fprintf(stderr, \"\\n\");\n        }\n        */\n    }\n    return res;\n}\n\nconst int MAXN = 610;\nint pow2[MAXN + 10];\nsigned main() {\n    pow2[0] = 1;\n    for(int i=1; i<=MAXN; i++) pow2[i] = (pow2[i-1] * 2) % MOD;\n    \n    int N, M; cin >> N >> M;\n    Matrix<int> mat;\n    init_mat(mat, N, M);\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            cin >> mat[i][j];\n        }\n    }\n\n    int rank = mat_rank(mat);\n    int ansA = pow2[N + M - 1];\n    int ansB = pow2[N + M - rank - 1];\n    fprintf(stderr, \"matrix rank = %lld\\n\", rank);\n    printf(\"%lld\\n\", (ansA - ansB + MOD) % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int N=300+7;\nconst int MOD=998244353;\n\nint add(int a,int b)\n{\n        a+=b;\n        if(a>=MOD)\n        {\n                a-=MOD;\n        }\n        if(a<0)\n        {\n                a+=MOD;\n        }\n        return a;\n}\n\nint mul(int a,int b)\n{\n        return a*(long long)b%MOD;\n}\n\nint expow(int a,int b)\n{\n        int res=1;\n        while(b)\n        {\n                if(b&1)\n                {\n                        res=mul(res,a);\n                }\n                a=mul(a,a);\n                b>>=1;\n        }\n        return res;\n}\n\nint inv(int n)\n{\n        return expow(n,MOD-2);\n}\n\nint fact[N];\n\nint comb(int n,int k)\n{\n        int x=fact[n];\n        int y=mul(fact[k],fact[n-k]);\n        y=expow(y,MOD-2);\n        return mul(x,y);\n}\n\nint n,m;\n\nint mll;\n\nmap<vector<int>,int>freq;\n\nint main()\n{\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n       // freopen(\"input\",\"r\",stdin);\n       // freopen(\"output\",\"w\",stdout);\n        fact[0]=1;\n        for(int i=1;i<N;i++)\n        {\n                fact[i]=mul(fact[i-1],i);\n        }\n        int cnt0=0;\n        cin>>n>>m;\n        mll=expow(2,m);\n        for(int i=1;i<=n;i++)\n        {\n                vector<int>ugar;\n                bool g=0;\n                for(int j=1;j<=m;j++)\n                {\n                        int x;\n                        cin>>x;\n                        ugar.push_back(x);\n                        if(x)\n                        {\n                                g=1;\n                        }\n                }\n                if(g==0) cnt0++;\n                freq[ugar]++;\n        }\n        int tot=expow(2,n);\n        int sum=0;\n        for(auto &it:freq)\n        {\n                int cnt=it.second;\n                sum+=cnt-1;\n        }\n       /// cout<<cnt0<<\"\\n\";\n        if(cnt0>0) sum++;\n        int lft=add(tot,-expow(2,sum));\n      ///  cout<<\"=\"<<lft<<\"\\n\";\n        int res=mul(lft,mll);\n       /// cout<<tot-lft<<\"\\n\";\n        res=mul(res,inv(2));\n        cout<<res<<\"\\n\";\n        return 0;\n        cout<<\"A: \"<<res<<\"\\n\";\n        return 0;\n}\n/**\n\n**/\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\n\nvoid norm(VV<int>& a) {\n\tint n = a.size(), m = a[0].size();\n\tREP(j, m) {\n\t\tint pivot = -1;\n\t\tREP(i, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tpivot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) continue;\n\n\t\tFOR(i, pivot + 1, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tREP(k, m) {\n\t\t\t\t\ta[i][k] ^= a[pivot][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tMAT(int, a, n, m);\n\n\tREP(_, 2) {\n\t\tnorm(a);\n\t\tVV<int> b(m, V<int>(n));\n\t\tREP(i, n) REP(j, m) {\n\t\t\tb[j][i] = a[i][j];\n\t\t}\n\t\tstd::swap(n, m);\n\t\tstd::swap(a, b);\n\t}\n\n\tint one = 0;\n\tint zero = 0;\n\tREP(i, n) {\n\t\tbool f = false;\n\t\tREP(j, m) if (a[i][j]) f = true;\n\t\tif (f) ++one;\n\t\telse ++zero;\n\t}\n\tREP(j, m) {\n\t\tbool f = false;\n\t\tREP(i, n) if (a[i][j]) f = true;\n\t\tif (f) /*++one*/;\n\t\telse ++zero;\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= one; i += 2) {\n\t\tint sum = Combination(one, i);\n\t\t(sum *= powMod(2, one - i, MOD)) %= MOD;\n\t\t(sum *= powMod(2, zero, MOD)) %= MOD;\n\t\t(ans += sum) %= MOD;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 998244353LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                // C[i][j] += A[i][k] * B[k][j]; // modなし\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// Matrix Library End\n\n// N * M 行列のランクを求める\ntemplate <typename T>\nint mat_rank(Matrix<T> A) {\n    int N = A.size(), M = A[0].size();\n\n    int WID = min(N, M), res = 0;\n    for(int i=0; i<WID; i++) {\n        // 絶対値が最も大きいものを探す\n        T max_elem = 0; int piv = -1;\n        for(int j=res; j<N; j++) {\n            if(abs(A[j][i]) > max_elem) {\n                max_elem = abs(A[j][i]);\n                piv = j;\n            }\n        }\n\n        // fprintf(stderr, \"# piv = %lld\\n\", piv);\n        if(piv < 0) continue;\n            \n        // res 行目を piv 行目に変えて、行基本変形\n        swap(A[res], A[piv]);\n\n        /*\n        fprintf(stderr, \"# matrix debug\\n\");\n        for(int x=0; x<N; x++) {\n            for(int y=0; y<M; y++) {\n                fprintf(stderr, \"%lld \", A[x][y]);\n            }\n            fprintf(stderr, \"\\n\");\n        }\n        */\n            \n        for(int j=0; j<N; j++) {\n            if(j == res) continue;\n            assert(A[res][i] != 0);\n            double ratio = 1.0 * A[j][i] / A[res][i];\n            for(int k=0; k<M; k++) {\n                A[j][k] = (T)(A[j][k] - ratio * A[res][k]);\n            }\n        }\n        res++;\n    }\n    return res;\n}\n\nconst int MAXN = 610;\nint pow2[MAXN + 10];\nsigned main() {\n    pow2[0] = 1;\n    for(int i=1; i<=MAXN; i++) pow2[i] = (pow2[i-1] * 2) % MOD;\n    \n    int N, M; cin >> N >> M;\n    Matrix<int> mat;\n    init_mat(mat, N, M);\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            cin >> mat[i][j];\n        }\n    }\n\n    int rank = mat_rank(mat);\n    int ansA = pow2[N + M - 1];\n    int ansB = pow2[N + M - rank - 1];\n    fprintf(stderr, \"matrix rank = %lld\\n\", rank);\n    printf(\"%lld\\n\", (ansA - ansB + MOD) % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n\n#define cMOD 998244353ULL\n#define cINF ((1ull<<62)-1)\n#define cINFINT ((1<<30)-1)\n\n\ntemplate <typename T>\nvoid calcFactional_mod( size_t size, \n\tvector<T>& fac, vector<T>& inv, vector<T>& facInv, T mod )\n{\n\tfor( T i = 2; i < size; ++i )\n\t{\n\t\tfac[i] = fac[i - 1] * i % mod; // n! % mod\n\t\tinv[i] = mod - inv[mod % i] * ( mod / i ) % mod; // 逆元計算 (n)^-1 % mod\n\t\tfacInv[i] = facInv[i - 1] * inv[i] % mod; // (n!)^-1 % mod\n\t}\n}\ntemplate <typename T>\nT pow_mod(T x, T n, T mod)\n{\n\tT res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (res * x) % mod;\n\t\tx = (x * x) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\ntemplate< typename T >\nclass Matrix\n{\npublic:\n\texplicit Matrix( size_t row_size, size_t col_size )\n\t{\n\t\tassign( row_size, col_size );\n\t}\n\n\tvoid assign( size_t row_size, size_t col_size )\n\t{\n\t\tmElement.assign( row_size, vector<T>() );\n\t\tREP( i, row_size ) mElement[i].assign( col_size, T(0) );\n\t}\n\n\tconst vector<T>& operator[] ( size_t row ) const\n\t{ return mElement[row]; }\n\tvector<T>& operator[] ( size_t row )\n\t{ return mElement[row]; }\n\n\tconst size_t rowSize() const\n\t{ return mElement.size(); }\n\tconst size_t colSize() const\n\t{ return mElement[0].size(); }\n\n\t/*T get( size_t row, size_t col ) const\n\t{ return mElement[row][col]; }\n\tvoid set( size_t row, size_t col, T value )\n\t{ mElement[row][col] = value; }*/\n\n\tMatrix<T> operator* ( const Matrix& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.rowSize() );\n\t\tMatrix ret( this->rowSize(), rhs.colSize() );\n\t\tREP( i, ret.rowSize() )\n\t\tREP( k, k_ )\n\t\tREP( j, ret.colSize() )\n\t\t\tret[i][j] = ret[i][j] + (*this)[i][k] * rhs[k][j];\n\t\treturn ret;\n\t}\n\n\tvector<T> operator* ( const vector<T>& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.size() );\n\t\tvector<T> ret( this->rowSize(), T() );\n\t\tREP( i, ret.size() )\n\t\tREP( k, k_ )\n\t\t\tret[i] = ret[i] + (*this)[i][k] * rhs[k];\n\t\treturn ret;\n\t}\n\n\t// O( N^3 )\n\t// Ax = b を解く\n\t// T = double にしないと割り算で狂うので注意\n\tstruct GaussJordanData\n\t{\n\t\tint rank = 0;\n\t\tint result = 0; // -1:解なし 0:不定 1:解あり\n\t\tvector<T> solution;\n\t};\n\tGaussJordanData gaussJordan() const\n\t{\n\t\tvector<T> b( rowSize(), 0 );\n\t\treturn gaussJordan( b );\n\t}\n\tGaussJordanData gaussJordan( const vector<T>& b ) const\n\t{\n\t\tGaussJordanData data;\n\t\tdata.result = 1;\n\n\t\t// 1列余分に取って、そこにbを入れる\n\t\tMatrix<T> B( rowSize(), colSize() + 1 );\n\t\tREP( i, rowSize() ) REP( j, colSize() + 1 )\n\t\t{\n\t\t\tif( j < colSize() ) B[i][j] = (*this)[i][j];\n\t\t\telse B[i][j] = b[i];\n\t\t}\n\n\t\tfor( int i = 0, j = 0; i < rowSize() && j < colSize(); ++i, ++j )\n\t\t{\n\t\t\t// j列目の値の絶対値が大きい行をi行目に持ってくる\n\t\t\tsize_t pivot = i;\n\t\t\tfor( int k = i + 1; k < rowSize(); ++k )\n\t\t\t\tif( abs( B[k][j] )> abs( B[pivot][j] ) ) pivot = k;\n\t\t\tswap( B[i], B[pivot] );\n\t\t\t// 解が一意でない\n\t\t\tif( abs( B[i][j] ) < numeric_limits<double>::epsilon() )\n\t\t\t{\n\t\t\t\t--i;\n\t\t\t\tdata.result = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Rankを1増やす\n\t\t\t++data.rank;\n\t\t\t// [i][j]を1にするようにi行目を割る\n\t\t\tfor( int l = j + 1; l <= colSize(); ++l )\n\t\t\t\tB[i][l] /= B[i][j];\n\t\t\tB[i][j] = 1;\n\t\t\t// k番目の行からi番目の行を引いて、j番目の列の数を消去\n\t\t\tREP( k, rowSize() ) if( k != i )\n\t\t\t{\n\t\t\t\tT coef = B[k][j];\n\t\t\t\tfor( int l = j; l <= colSize(); ++l )\n\t\t\t\t\tB[k][l] -= coef * B[i][l];\n\t\t\t}\n\t\t}\n\n\t\t// 解xを作る\n\t\tdata.solution.assign( colSize(), T() );\n\t\tfor( int i = 0, j = 0; j < colSize(); ++i, ++j )\n\t\t{\n\t\t\tif( i >= rowSize() || B[i][j] == 0 )\n\t\t\t{\n\t\t\t\tdata.solution[j] = 0;\n\t\t\t\t--i; continue;\n\t\t\t}\n\t\t\telse data.solution[j] = *( B[i].rbegin() );\n\t\t}\n\n\t\t// 解なしかをチェック\n\t\tif( data.result == 0 || ( data.rank ) < b.size() )\n\t\t{\n\t\t\tauto m = ( *this ) * data.solution;\n\t\t\tREP( i, m.size() ) if( m[i] != b[i] )\n\t\t\t{ data.result = -1; break; }\n\t\t}\n\t\tif( data.result != -1 )\n\t\t{\n\t\t\t// 解が一意\n\t\t\tif( data.rank == colSize() ) data.result = 1;\n\t\t\t// 解が不定\n\t\t\telse data.result = 0;\n\t\t}\n\t\t\n\t\treturn data;\n\t}\n\nprotected:\n\tvector<vector<T>> mElement;\n};\n\n\nint main()\n{\n\tauto mod = cMOD;\n\tauto add = [mod]      ( ll a, ll b ) { return ( a + b ) % mod; };\n\tauto sub = [mod]      ( ll a, ll b ) { return ( a + mod -b ) % mod; };\n\tauto mul = [mod]      ( ll a, ll b ) { return a * b % mod; };\n\tauto pow = [mod]      ( ll a, ll b ) { return pow_mod<ll>( a, b, mod ); };\n\t\n\tull n,m; cin >> n >> m;\n\tMatrix<double> mtx( n, m );\n\tREP( i, n ) REP( j, m ) cin >> mtx[i][j];\n\t\n\tauto data = mtx.gaussJordan();\n\tll ans = sub( pow( 2, n + m - 1 ), pow( 2, n + m - data.rank - 1 ) );\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...) 0\n#endif\n\ntemplate <ll mod>\nstruct modular {\n    ll value;\n    modular(ll x = 0) {\n        value = x % mod;\n        if (value < 0) value += mod;\n    }\n\n    modular& operator+=(modular other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(modular other) {\n        if ((value -= other.value) < 0) value += mod;\n        return *this;\n    }\n    modular& operator*=(modular other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(modular other) {\n        ll a = 0, b = 1, c = other.value, m = mod;\n        while (c != 0) {\n            ll t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    modular& operator^=(modular other) {\n        ll r = 1, x = value, n = other.value;\n        while (n > 0) {\n            if (n & 1) r = r * x % mod;\n            x = x * x % mod;\n            n >>= 1;\n        }\n        value = r;\n        return *this;\n    }\n    modular operator+(modular rhs) {\n        return modular(*this) += rhs;\n    }\n    modular operator-(modular rhs) {\n        return modular(*this) -= rhs;\n    }\n    modular operator*(modular rhs) {\n        return modular(*this) *= rhs;\n    }\n    modular operator/(modular rhs) {\n        return modular(*this) /= rhs;\n    }\n    modular operator^(modular rhs) {\n        return modular(*this) ^= rhs;\n    }\n    bool operator==(modular rhs) {\n        return value == rhs.value;\n    };\n    bool operator!=(modular rhs) {\n        return value != rhs.value;\n    };\n    bool operator<(modular rhs) {\n        return value < rhs.value;\n    }\n    bool operator>(modular rhs) {\n        return value > rhs.value;\n    }\n};\ntemplate <ll mod>\nstring to_string(modular<mod> x) {\n    return to_string(x.value);\n}\ntemplate <ll mod>\nostream& operator<<(ostream& stream, modular<mod> x) {\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream << x.value;\n}\ntemplate <ll mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream;\n}\nconst ll mod = 998244353;\nusing mint = modular<mod>;\n\nmint abs(mint a) {\n    return a.value;\n}\n\ntemplate <class T>\nstruct matrix {\n    vector<vector<T>> a;\n    matrix(int height, int width)\n        : a(height, vector<T>(width)) {}\n    matrix(int n)\n        : a(n, vector<T>(n)) {}\n    int size() {\n        return a.size();\n    }\n    inline vector<T>& operator[](int i) {\n        return a[i];\n    }\n};\ntemplate <class T>\nmatrix<T> operator*(matrix<T> a, matrix<T> b) {\n    matrix<T> r(a.size(), b[0].size());\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < b[0].size(); j++)\n            for (int k = 0; k < b.size(); k++) r[i][j] += a[i][k] * b[k][j];\n    return r;\n}\ntemplate <class T>\nmatrix<T> operator+(matrix<T> a, matrix<T> b) {\n    matrix<T> r(a.size(), a[0].size());\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++) r[i][j] = a[i][j] + b[i][j];\n    return r;\n}\ntemplate <class T>\nmatrix<T> operator-(matrix<T> a, matrix<T> b) {\n    matrix<T> r(a.size(), a[0].size());\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++) r[i][j] = a[i][j] - a[i][j];\n    return r;\n}\ntemplate <class T>\nmatrix<T> operator^(matrix<T> a, ll n) {\n    matrix<T> r(a.size());\n    for (int i = 0; i < a.size(); i++) r[i][i] = 1;\n    while (n > 0) {\n        if (n & 1) r = r * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate <class T>\nbool operator==(matrix<T> a, matrix<T> b) {\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++)\n            if (a[i][j] != b[i][j]) return false;\n    return true;\n}\ntemplate <class T>\nbool operator!=(matrix<T> a, matrix<T> b) {\n    return !(a == b);\n}\ntemplate <class T>\nvoid print(matrix<T> a) {\n    for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < a[0].size(); j++)\n            cout << a[i][j] << ((j != a[0].size() - 1) ? ' ' : '\\n');\n}\ntemplate <class T>\nstring to_string(matrix<T> a) {\n    return to_string(a.a);\n}\ntemplate <class T>\nint gaussian_elimination(matrix<T>& a, bool is_extended = false) {\n    int m = a.size(), n = a[0].size();\n    int rank = 0;\n    T det = 1;\n    for (int col = 0; col < n; ++col) {\n        if (is_extended && col == n - 1) break;\n        int pivot = -1;\n        T mx = 1e-5;\n        for (int row = rank; row < m; ++row) {\n            if (abs(a[row][col]) > mx) {\n                mx = abs(a[row][col]);\n                pivot = row;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(a[pivot], a[rank]);\n        auto fac = a[rank][col];\n        det *= fac;\n        for (int col2 = 0; col2 < n; col2++) a[rank][col2] /= fac;\n        for (int row = 0; row < m; row++) {\n            if (row != rank && abs(a[row][col]) > 1e-9) {\n                auto fac = a[row][col];\n                for (int col2 = 0; col2 < n; col2++) {\n                    a[row][col2] -= a[rank][col2] * fac;\n                }\n            }\n        }\n        rank++;\n    }\n    return rank;\n    // return (m == rank ? det : 0);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    matrix<int> a(n, m);\n    rep(i, 0, n) rep(j, 0, m) cin >> a[i][j];\n    int r = gaussian_elimination(a);\n    debug(r);\n    mint ans = (mint)2 ^ (mint)(n + m - 1);\n    ans -= (mint)2 ^ (mint)(n + m - r - 1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n//const ll MOD = 1e9+7;\nconst ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<ll mod> struct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x (y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    Mod_Int &operator += (const Mod_Int &p) {\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p) {\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p) {\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int &operator ++ () {return *this += (Mod_Int)1;}\n\n    Mod_Int operator ++ (int) {\n        Mod_Int tmp = *this;\n        ++*this;\n        return tmp;\n    }\n\n    Mod_Int &operator -- () {return *this -= (Mod_Int)1;}\n\n    Mod_Int operator -- (int) {\n        Mod_Int tmp = *this;\n        --*this;\n        return tmp;\n    }\n\n    Mod_Int operator - () const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow (ll n) const {\n        Mod_Int now = *this, ret = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse () const {\n        return pow(mod-2);\n    }\n};\n\nusing mint = Mod_Int<MOD>;\nconst int MAX_N = 1e6;\nmint fac[MAX_N+1], ifac[MAX_N+1];\n\nvoid init(){\n    fac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = fac[i-1]*i;\n    }\n    ifac[MAX_N] = fac[MAX_N].inverse();\n    rep3(i, MAX_N, 1){\n        ifac[i-1] = ifac[i]*i;\n    }\n}\n\nmint comb(int n, int k){\n    return fac[n]*ifac[n-k]*ifac[k];\n}\n\nmint perm(int n, int k){\n    return fac[n]*ifac[n-k];\n}\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\n\nint mat_rank(mat &A){\n    int m = sz(A), n = sz(A[0]);\n    int now = 0, ret = 0;\n    rep(j, n){\n        int pivot = now;\n        rep2(i, now, m-1){\n            if(A[i][j] > A[pivot][j]) pivot = i; \n        }\n        swap(A[now], A[pivot]);\n        if(A[now][j] == 0) continue;\n        ret++;\n        rep(i, m){\n            if(i == now) continue;\n            rep2(k, j+1, n-1) A[i][k] ^= (A[i][j]*A[now][k]);\n            A[i][j] = 0;\n        }\n        now++;\n        if(now == m) break;\n    }\n    return ret;\n}\n\nint main(){\n    int M, N;\n    cin >> M >> N;\n    mat A(M, vec(N));\n    rep(i, M){\n        rep(j, N) cin >> A[i][j];\n    }\n    int r = mat_rank(A);\n    mint ans, tw = 2;\n    ans = tw.pow(N+M-1) - tw.pow(N+M-r-1);\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconstexpr long long mod = 998244353;\ntypedef pair<int, int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint kj[100005], kji[100005];\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nvoid setkj(int n) {\n\tkj[0] = 1;\n\trep(i, n)kj[i + 1] = kj[i] * (i + 1) % mod;\n\trep(i, n + 1)kji[i] = modpow(kj[i], mod - 2);\n}\nint comb(int r, int c) {\n\tif (c<0 || r<c)return 0;\n\treturn kj[r] * kji[c] % mod*kji[r - c] % mod;\n}\nint GJ(mat &A) {\n\tint N = A.size(), M = A[0].size();\n\tint rnk = 0;\n\trep(i, M) {\n\t\tif (i == M - 1)break;\n\t\tint pivot = -1;\n\t\tfor (int j = rnk; j < N; j++) {\n\t\t\tif (A[i][j]) {\n\t\t\t\tpivot = j; break;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1)continue;\n\t\tswap(A[pivot], A[rnk]);\n\n\t\trep(j, N) {\n\t\t\tif (j != rnk&&A[j][i]) {\n\t\t\t\trep(k, M) {\n\t\t\t\t\tA[j][k] ^= A[rnk][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trnk++;\n\t}\n\n\tint res = 0;\n\trep(i, N) {\n\t\trep(j, M) {\n\t\t\tif (A[i][j]) {\n\t\t\t\tres++; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tsetkj(305);\n\tint n, m; cin >> n >> m;\n\tmat A(n);\n\trep(i, n) {\n\t\tA[i].resize(m);\n\t\trep(j, m)cin >> A[i][j];\n\t}\n\tint r = GJ(A);\n\t\n\tint ans = modpow(2, n - r)*modpow(2, m - r) % mod;\n\tint d = 0;\n\tfor (int i = 1; i <= r; i += 2) {\n\t\td += modpow(3, r - i)*comb(r, i) % mod;\n\t\td %= mod;\n\t}\n\tcout << d*ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint N, M;\nint mod = 998244353;\n\nint power(int a, int n){\n    if (n == 0) {\n        return 1;\n    } else if (n % 2 == 0) {\n        int b = power(a, n / 2);\n        return 1ll * b * b % mod;\n    } else {\n        return 1ll * a * power(a, n - 1) % mod;\n    }\n}\n\nint main() {\n    cin >> N >> M;\n    vector<int> row(N);\n    for (int i = 0; i < N; i++) {\n        for (int j = M - 1; j >= 0; j--) {\n            int a;\n            cin >> a;\n            if (a) row[i] += 1 << j;\n        }\n    }\n    \n//    rank計算\n    int rank = 0;\n    for (int j = M - 1; j >= 0; j--) {\n        int pivot = -1;\n        for (int i = rank; i < N; i++) {\n            if (row[i] >> j) {\n                pivot = i;\n                break;\n            }\n        }\n        if (pivot != -1) {\n            swap(row[rank], row[pivot]);\n            for (int i = rank + 1; i < N; i++) if (row[i] >> j) row[i] ^= row[rank];\n            rank++;\n        }\n    }\n    int a = power(2, N + M - 1), b = power(2, N + M - rank - 1);\n    cout << (a < b? a - b + mod: a - b) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nll mo=998244353;\n\nconst int MAT=402;\nint A[402][402];\n\nint gf2_rank(int A[MAT][MAT]) { /* input */\n\tint i,j,k;\n\tFOR(i,H) {\n\t\tint be=i,mi=H+1;\n\t\tfor(j=i;j<H;j++) {\n\t\t\tFOR(k,W) if(A[j][k]) break;\n\t\t\tif(k<mi) be=j,mi=k;\n\t\t}\n\t\tif(mi>=H) break;\n\t\tFOR(j,W) swap(A[i][j],A[be][j]);\n\t\t\n\t\tFOR(j,H) if(i!=j&&A[j][mi]) {\n\t\t\tFOR(k,W) A[j][k] ^= A[i][k];\n\t\t}\n\t}\n\treturn i;\n}\n\nll dp[603][603];\nll p2[3030];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) FOR(x,W) cin>>A[y][x];\n\tif(H<W) {\n\t\tFOR(y,400) FOR(x,400) if(y<x) swap(A[y][x],A[x][y]);\n\t\tswap(H,W);\n\t}\n\tgf2_rank(A);\n\t\n\tp2[0]=1;\n\tFOR(i,305) p2[i+1]=p2[i]*2%mo;\n\t\n\tdp[0][0]=1;\n\t\n\tFOR(y,H) {\n\t\tint num=0;\n\t\tFOR(x,400) num+=A[y][x];\n\t\t\n\t\tFOR(x,400+1) if(dp[y][x]) {\n\t\t\t(dp[y+1][x]+=dp[y][x])%=mo;\n\t\t\t(dp[y+1][x+num]+=dp[y][x])%=mo;\n\t\t}\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=400;i++) ret+=dp[H][i]*p2[W-1]%mo;\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nconst int mod = 998244353;\n\n/// --- math {{{ ///\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll d;\n  return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n    : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n}\nll modinv(ll a, ll mod) {\n  ll x, y;\n  extgcd(a, mod, x, y);\n  if(x < 0) x += mod;\n  return x;\n}\nll modpow(ll a, ll b, ll mod) {\n  ll r = 1;\n  a %= mod;\n  while(b) {\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\n/// }}}--- ///\n\n\n/// --- ModInt Library {{{ ///\n#include <ostream>\ntemplate < ll mod = (ll) 1e9 + 7 >\nstruct ModInt {\n  // math {{{\n  static inline ll extgcd(ll a, ll b, ll &x, ll &y) {\n    ll d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline ll modinv(ll a) {\n    ll x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0) x += mod;\n    return x;\n  }\n  static inline ll modpow(ll a, ll b) {\n    if(b < 0) b = -b, a = modinv(a);\n    ll r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  ll val;\n  constexpr ModInt() : val(0) {}\n  constexpr ModInt(ll t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModInt(ll t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // ModInt <arithmetic-operator>[=] ModInt {{{\n  ModInt operator+(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModInt operator-(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModInt operator*(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModInt operator/(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModInt &operator+=(ModInt const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModInt &operator-=(ModInt const &rhs) { return *this += -rhs; }\n  ModInt &operator*=(ModInt const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModInt &operator/=(ModInt const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModInt operator++(int) {\n    ModInt tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModInt operator--(int) {\n    ModInt tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModInt &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModInt &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModInt operator-() const { return ModInt(val == 0 ? 0 : mod - val, 0); }\n  // ModInt <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModInt operator+(T const &rhs) const {\n      return ModInt(val + rhs % mod);\n    }\n  template < typename T >\n    ModInt operator-(T const &rhs) const {\n      return ModInt(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModInt operator*(T const &rhs) const {\n      return ModInt(val * (rhs % mod));\n    }\n  template < typename T >\n    ModInt operator/(T const &rhs) const {\n      return ModInt(val * modinv(rhs));\n    }\n  template < typename T >\n    ModInt &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModInt inv() const { return ModInt(modinv(val), 0); }\n  ModInt operator~() const { return inv(); }\n  friend ostream &operator<<(ostream &os, ModInt const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModInt operator==(const ModInt &a) const { return val == a.val; }\n  ModInt operator!=(const ModInt &a) const { return val != a.val; }\n  ModInt operator==(const ll &a) const { return val == ModInt(a); }\n  ModInt operator!=(const ll &a) const { return val != ModInt(a); }\n  // }}}\n  // T <arithmetic-operator> ModInt {{{\n  friend constexpr ModInt operator+(ll a, ModInt const &mv) {\n    return ModInt(a % mod + mv.val);\n  }\n  friend constexpr ModInt operator-(ll a, ModInt const &mv) {\n    return ModInt(a % mod - mv.val);\n  }\n  friend constexpr ModInt operator*(ll a, ModInt const &mv) {\n    return ModInt((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModInt operator/(ll a, ModInt const &mv) {\n    return ModInt((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModInt operator^(ll x) const { return pow(*this, x); }\n  ModInt &operator^=(ll x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModInt pow(ModInt x, ll y) { return ModInt(modpow(x.val, y), 0); }\n  // }}}\n};\n/// }}}--- ///\n\nusing modint = ModInt<2>;\n\n// matrank, degree_of_freedom {{{\n#include <vector>\ntemplate < class T >\nint matrank(vector< vector< T > > mat) {\n  size_t n = mat.size(), m = mat[0].size();\n  size_t now = 0;\n  for(size_t i = 0; i < m; i++) {\n    int pivot = now;\n    // pivotting\n    for(size_t j = now + 1; j < n; j++) {\n      if(mat[pivot][i] != T(0)) break;\n      pivot = j;\n    }\n    if(mat[pivot][i] == T(0)) continue;\n    swap(mat[now], mat[pivot]);\n    for(size_t j = i + 1; j < m; j++) {\n      mat[now][j] /= mat[now][i];\n    }\n    for(size_t j = now + 1; j < n; j++)\n      for(size_t k = i + 1; k < m; k++) {\n        mat[j][k] -= mat[j][i] * mat[now][k];\n      }\n    now++;\n    if(now == n) break;\n  }\n  return now;\n}\ntemplate < class T >\nint degree_of_freedom(const vector< vector< T > > &mat) {\n  return mat[0].size() - matrank(mat);\n}\n// }}}\n\nint h, w;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> h >> w;\n  vector<vector<modint>> v(h, vector<modint>(w));\n  for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) {\n    int a; cin >> a;\n    v[i][j] = a;\n  }\n  // 若干の考察と次元定理\n  cout << (modpow(2, w, mod) - modpow(2, w - matrank(v), mod) + mod) * modpow(2, h - 1, mod) % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<bitset>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\nusing namespace std;\n\nconst int mod=998244353,N=305;\nint mi[N],n,m,k,ans,a[N][N];\nbitset<N>b[N],x;\n\nint main(){\n\tmi[0]=1; rep(i,1,300) mi[i]=2ll*mi[i-1]%mod;\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n){\n\t\tx.reset(); int l=-1;\n\t\trep(j,0,m-1) scanf(\"%d\",a[i]+j),x.set(j,a[i][j]);\n\t\trep(j,0,m-1) if (x[j]){\n\t\t\tif (b[j].any()) x^=b[j]; else{ b[j]=x; l=j; break; }\n\t\t}\n\t\tif (l==-1) k++;\n\t}\n\tans=(1ll*mi[m]*mi[k]+1ll*mi[m-1]*(mi[n]+mod-mi[k]))%mod;\n\tprintf(\"%lld\\n\",(1ll*mi[n]*mi[m]+mod-ans)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 998244353LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                // C[i][j] += A[i][k] * B[k][j]; // modなし\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// Matrix Library End\n\n// N * M 行列のランクを求める\ntemplate <typename T>\nint mat_rank(Matrix<T> A) {\n    int N = A.size(), M = A[0].size();\n\n    for(int i=0; i<N; i++) {\n        {\n            // 非零要素を探す (i 列目以降で、どこかが非零である列があればよい)\n            T nonzero = 0; int piv = -1;\n            for(int j=i; j<N; j++) {\n                for(int k=0; k<M; k++) {\n                    if(A[j][k] != 0) {\n                        nonzero = A[j][k];\n                        piv = k;\n                    }\n                }\n            }\n            // 非零要素が存在しない\n            if(nonzero == 0) return i;\n            \n            // i 列目と piv 列目を入れ替える\n            for(int j=0; j<N; j++) {\n                swap(A[j][i], A[j][piv]);\n            }\n        }\n\n        {\n            // i 列目の中で、絶対値が最も大きいものを探す\n            T max_elem = 0; int piv = -1;\n            for(int j=i; j<N; j++) {\n                if(abs(A[j][i]) > max_elem) {\n                    max_elem = abs(A[j][i]);\n                    piv = j;\n                }\n            }\n\n            // i 行目を piv 行目に変えて、行基本変形\n            swap(A[i], A[piv]);\n\n            /*\n            for(int x=0; x<N; x++) {\n                for(int y=0; y<M; y++) {\n                    fprintf(stderr, \"%lld \", A[x][y]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n            */\n            \n            for(int j=0; j<N; j++) {\n                if(i == j) continue;\n                assert(A[i][i] != 0);\n                T ratio = 1.0 * A[j][i] / A[i][i];\n                for(int k=0; k<N; k++) {\n                    A[j][k] = A[j][k] - ratio * A[i][k];\n                }\n            }\n        }\n    }\n    return N;\n}\n\nconst int MAXN = 610;\nint pow2[MAXN + 10];\nsigned main() {\n    pow2[0] = 1;\n    for(int i=1; i<=MAXN; i++) pow2[i] = (pow2[i-1] * 2) % MOD;\n    \n    int N, M; cin >> N >> M;\n    Matrix<int> mat;\n    init_mat(mat, N, M);\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            cin >> mat[i][j];\n        }\n    }\n\n    int rank = mat_rank(mat);\n    int ansA = pow2[N + M - 1];\n    int ansB = pow2[N + (M - rank) - 1];\n    fprintf(stderr, \"matrix rank = %lld\\n\", rank);\n    printf(\"%lld\\n\", (ansA - ansB + MOD) % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint H, W;\nlong long mod = 998244353;\nvector<int> A[309];\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tA[i].resize(W, 0);\n\t\tfor (int j = 0; j < W; j++) cin >> A[i][j];\n\t}\n\tsort(A, A + H);\n\n\tfor (int i = W - 1; i >= 0; i--) {\n\t\tint pos = 0;\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tint cnt = 0; for (int k = i + 1; k < W; k++) { if (A[j][k] == 1) cnt++; }\n\t\t\tif (cnt == 0) { pos = j; }\n\t\t}\n\t\tfor (int j = pos - 1; j >= 0; j--) {\n\t\t\tif (A[j][i] == 0) continue;\n\t\t\tfor (int k = 0; k < W; k++) A[j][k] ^= A[pos][k];\n\t\t}\n\t\tsort(A, A + H);\n\t}\n\n\tvector<int> ZERO(W, 0);\n\tlong long v = 1;\n\tfor (int i = 0; i < H; i++) {\n\t\tif (A[i] == ZERO) { v *= 2; v %= mod; }\n\t}\n\tlong long p = 1; for (int i = 0; i < H; i++) { p *= 2; p %= mod; }\n\tlong long q = 1; for (int i = 0; i < W; i++) { q *= 2; q %= mod; }\n\tlong long r = (p - v + mod)*q%mod;\n\tif (r % 2 == 1) r += mod; r /= 2;\n\tcout << r << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MOD 998244353\n\nvector< vector<int> > A;\n\nlong long power(long long N, long long expo)\n{\n    long long ans = 1;\n    \n    while(expo)\n    {\n        if(expo % 2)\n            ans = ans * N % MOD;\n        \n        N = N * N % MOD;\n        expo /= 2;\n    }\n    \n    return ans;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(NULL), cout.tie(NULL);\n\n    int N, M;\n    cin >> N >> M;\n    \n    for(int i=0; i<N; i++)\n    {\n        vector<int> B(M, 0);\n        A.push_back(B);\n        \n        for(int j=0; j<M; j++)\n        {\n            int x;\n            cin >> x;\n            \n            A[i][j] = x;\n        }\n    }\n    \n    long long ans = power(2, N) + MOD - 1;\n    \n    for(int i=0; i<N; i++)\n    {\n        int f = -1;\n        sort(A.begin()+i, A.end(), greater< vector<int> >());\n        \n        for(int j=0; j<M; j++)\n        {\n            if(A[i][j] == 1)\n            {\n                f = j;\n                break;\n            }\n        }\n        \n        if(f == -1)\n        {\n            ans += MOD - power(2, N-i) + 1;\n            break;\n        }\n        \n        for(int j=i+1; j<N; j++)\n        {\n            if(A[j][f] == 1)\n            {\n                for(int k=f; k<M; k++)\n                    A[j][k] ^= A[i][k];\n            }\n        }\n    }\n    \n    cout << ans % MOD * power(2, M-1) % MOD << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\n// <<<\n// >>> gauss jordan for vector<bitset>\ntemplate <size_t N>\nint gauss_jordan(vector<bitset<N>> &a) {\n    const int h = a.size();\n    int i = 0;\n    for (int j = 0; i < h && j < (int)N; j++) {\n        int k = i; while (k < h && !a[k][j]) k++;\n        if (k == h) continue;\n        swap(a[i],a[k]);\n        rep (k,h) if (k != i && a[k][j]) a[k] ^= a[i];\n        i++;\n    }\n    return i;\n}\n// <<<\n// >>> modint\ntemplate <uint32_t md>\nclass modint {\n    static_assert(md < (1u<<31), \"\");\n    using M = modint;\n    using i64 = int64_t;\n    uint32_t x;\npublic:\n    static constexpr uint32_t mod = md;\n    constexpr modint(i64 x = 0) : x((x%=md) < 0 ? x+md : x) { }\n    constexpr i64 val() const { return x; }\n    constexpr explicit operator i64() const { return x; }\n    constexpr bool operator==(M r) const { return x == r.x; }\n    constexpr bool operator!=(M r) const { return x != r.x; }\n    constexpr M operator+() const { return *this; }\n    constexpr M operator-() const { return M()-*this; }\n    constexpr M& operator+=(M r) { x += r.x; x = (x < md ? x : x-md); return *this; }\n    constexpr M& operator-=(M r) { x += md-r.x; x = (x < md ? x : x-md); return *this; }\n    constexpr M& operator*=(M r) { x = (uint64_t(x)*r.x)%md; return *this; }\n    constexpr M& operator/=(M r) { return *this *= r.inv(); }\n    constexpr M operator+(M r) const { return M(*this) += r; }\n    constexpr M operator-(M r) const { return M(*this) -= r; }\n    constexpr M operator*(M r) const { return M(*this) *= r; }\n    constexpr M operator/(M r) const { return M(*this) /= r; }\n    friend constexpr M operator+(i64 x, M y) { return M(x)+y; }\n    friend constexpr M operator-(i64 x, M y) { return M(x)-y; }\n    friend constexpr M operator*(i64 x, M y) { return M(x)*y; }\n    friend constexpr M operator/(i64 x, M y) { return M(x)/y; }\n    constexpr M inv() const { assert(x > 0); return pow(md-2); }\n    constexpr M pow(i64 n) const {\n        n %= md-1;\n        if (n < 0) n = (-n)*(md-2)%(md-1);\n        M v = *this, r = 1;\n        for (; n > 0; n >>= 1, v *= v) if (n&1) r *= v;\n        return r;\n    }\n#ifdef LOCAL\n    friend string to_s(M r) { return to_s(r.val(), mod); }\n#endif\n    friend ostream& operator<<(ostream& os, M r) { return os << r.val(); }\n    friend istream& operator>>(istream& is, M &r) { i64 x; is >> x; r = x; return is; }\n};\n// <<<\nconstexpr int64_t MOD = 998244353;\n//constexpr int64_t MOD = 1e9+7;\nusing mint = modint<MOD>;\n// >>> mod table\ntemplate <int32_t mod>\nstruct ModTable {\n    static constexpr int32_t Size = 1e6 + 10;\n    static_assert(Size <= mod, \"\");\n    using ll = int64_t;\n    int32_t fact[Size], finv[Size], inv[Size];\n    ModTable() {\n        fact[0] = fact[1] = finv[0] = finv[1] = inv[1] = 1;\n        for (int i = 2; i < Size; i++) {\n            fact[i] = ll(fact[i-1])*i % mod;\n            inv[i] = mod - ll(inv[mod%i])*(mod/i) % mod;\n            finv[i] = ll(finv[i-1])*inv[i] % mod;\n        }\n    }\n};\nconst ModTable<MOD> mod_tab;\n\nmodint<MOD> fact(int n) {\n    assert(0 <= n); assert(n < ModTable<MOD>::Size);\n    return mod_tab.fact[n];\n}\nmodint<MOD> finv(int n) {\n    assert(0 <= n); assert(n < ModTable<MOD>::Size);\n    return mod_tab.finv[n];\n}\nmodint<MOD> C(int n, int k) {\n    if (n < 0 || k < 0 || n < k) return 0;\n    return fact(n)*finv(k)*finv(n-k);\n}\nmodint<MOD> P(int n, int k) {\n    assert(k >= 0);\n    return fact(n)*finv(n-k);\n}\nmodint<MOD> sgn(int n) { return n%2 == 0 ? +1 : -1; }\n// <<<\n\nint32_t main() {\n    int n,m; cin >> n >> m;\n    vector<bitset<300>> a(n);\n    rep (i,n) rep (j,m) {\n        int x; cin >> x;\n        a[i][j] = x;\n    }\n\n    int r = gauss_jordan(a);\n    mint ans = 0;\n    for (int i = 1; i <= r; i += 2) {\n        ans += C(r,i)*mint(3).pow(r-i)*mint(2).pow(n+m-2*r);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"out2.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n#define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \n// void bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid amax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid amin(T& x, T y) {\n    x = min(x, y);\n}\n\n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-12;\nconst int maxn = 5e4 + 3, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst int base2 = 998244353;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % base2;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % base2;\n    }\n}\n\nconst int N = 305;\n\nint gauss (vector < bitset<N> > a, int n, int m) {    \n    int rank = max(n, m);\n    vector<char> line_used (n);\n    for (int i=0; i<m; ++i) {\n        int j;\n        for (j=0; j<n; ++j)\n            if (!line_used[j] && a[j][i])\n                break;\n        if (j == n)\n            --rank;\n        else {\n            line_used[j] = true;\n            for (int k=0; k<n; ++k)\n                if (k != j && a[k][i])\n                    a[k] ^= a[j];\n                    // for (int p=i+1; p<m; ++p)\n                    //     a[k][p] ^= a[j][p] * a[k][i];\n        }\n    }\n    return rank;\n}\n\nint main() {\n    // files1;\n\n    int n, m;\n    cin >> n >> m;\n    vector<bitset<N> > a(n);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            bool x;\n            cin >> x;\n            a[i][j] = x;\n        }\n\n    int r = gauss(a, n, m);\n    cout << (binpow(2, n + m - 1) - binpow(2, n + m - r - 1) + base2) % base2;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 300, md = 998244353;\nint n, m, p2[N + 1];\nvector<bitset<N> > g;\n\nvoid ad(bitset<N> v){\n\tint j = 0;\n\tf(i, 0, g.size()){\n\t\tif (v.none())return;\n\t\twhile (!v[j])++j;\n\t\tif (g[i][j])v ^= g[i];\n\t\telse {\n\t\t\tg.insert(g.begin() + i, v);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (v.any())g.push_back(v);\n}\n\nint main(){\n\tp2[0] = 1;\n\tf(i, 1, N + 1)p2[i] = (ll)p2[i - 1] * 2 % md;\n\tscanf(\"%d%d\", &n, &m);\n\tf(i, 0, n){\n\t\tbitset<N> v;\n\t\tf(j, 0, m){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t)v[j] = true;\n\t\t}\n\t\tad(v);\n\t}\n\tint an = p2[n] - p2[n - g.size()] + md;\n\tan = (ll)an * p2[m - 1] % md;\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main () {\n  int temp, odd, even;\n  int m, n;\n  cin >> m >> n;\n  vector<vector<int>> scount;\n  scount.push_back(vector<int> (n + 1, 0));\n  for (int i = 0; i < m; i++) {\n    vector<int> sc(1, 0);\n    for (int j = 0; j < n; j++) {\n      cin >> temp;\n      sc.push_back(scount[i][j] - scount[i][j - 1]  + sc[j] + temp);\n    }\n    scount.push_back(sc);\n  }\n  odd = even = 0;\n  \n  for (int i = 1; i < scount.size(); i++)\n    for (int j = 1; j < scount[i].size(); j++) {\n      if (scount[i][j] % 2 == 0)\n        even++;\n  \t  else\n        odd++;\n    }\n  \n  cout << ((even % 998244353) * (odd % 998244353)) % 998244353;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n        mat<COL_SIZE> b(r);\n        for(int i = 0; i < r; i++) b[i] = a[i];\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n        return a[index];\n    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<300>a(n);\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = a.rank();\n    cerr << r << endl;\n    cout << (mod_pow(2,n+m-1) - mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) (int)x.size()\n#define sz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nint n, m;\nbitset <310> B[310];\n\nll pw[1010];\nconst ll mod =  998244353;\n\nint main() {\n\tpw[0] = 1;\n\tfor(int i=1;i<1010;i++) pw[i] = pw[i-1] * 2 % mod;\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=m;j++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tif(x & 1) B[i][j] = 1;\n\t\t}\n\t}\n\tint t = 1;\n\tfor(int i=1;i<=m;i++) {\n\t\tint f = -1;\n\t\tfor(int j=t;j<=n;j++) if(B[j][i]) {\n\t\t\tf = j; break;\n\t\t}\n\t\tif(f == -1) continue;\n\t\tswap(B[t], B[f]);\n\t\tfor(int j=t+1;j<=n;j++) {\n\t\t\tif(B[j][i]) B[j] ^= B[t];\n\t\t}\n\t\t++t;\n\t}\n\tint r = t - 1;\n\tll ans = (pw[n+m-1] - pw[n+m-1-r] + mod) % mod;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nint a[300][300];\n\nsigned main(){\n\n//\t  cin.tie(0);\n  //  \t\t\tios::sync_with_stdio(false);\n\n\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)cin>>a[i][j];\n\t\n\tfor(int j=0;j<m;j++){\n\t\tint it=-1;\n\t\tfor(int i=0;i<n;i++)if(a[i][j]){\n\t\t\tbool bo=0;\n\t\t\tfor(int h=0;h<j;h++)if(a[i][h]==1) bo=1;\n\t\t\tif(bo) continue;\n\t\t\tit=i;\n\t\t\tbreak;\n\t\t}\n\t\tif(it>=0){\n\t\t\tfor(int i=0;i<n;i++)if(i!=it)if(a[i][j]){\n\t\t\t\t\n\t\t\t\tfor(int j=0;j<m;j++) a[i][j]^=a[it][j];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\tint wa=0;\n\tfor(int i=0;i<n;i++){\n\tint e=0;\n\t\tfor(int j=0;j<m;j++)if(a[i][j])e++;\n\t\tif(e==0) wa++;\n\t}\n\t\n\t\n\tmod=998244353;\n\t\n\tint dame=beki(2,wa,mod);\n\tint ok=(beki(2,n,mod)+mod-dame)%mod;\n\t\n\tint ans1=dame*beki(2,m,mod)%mod;\n\tint ans2=ok*beki(2,m-1,mod)%mod;\n\t\n\tint ans=(ans1+ans2)%mod;\n\t\n\tint zen=beki(2,m+n,mod);\n\tcout<<(zen+mod-ans)%mod<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T> LLI power(T n, T p, T m){if(p==0) return 1LL; if(p==1) return n; LLI k = power(n, p/2, m); return ((k*k)%m*(p%2?n:1))%m;}\n\nconst LLI mod = 998244353;\nconst double eps = 1e-9;\n\nint rank_bit_matrix(vector<vector<int>> mat){\n  int n = mat.size();\n  int m = mat[0].size();\n\n  int r = 0;\n  \n  REP(i,n){\n\n    int p = -1;\n    FOR(j,r,m){\n      if(mat[i][j]){\n\tp = j;\n\tbreak;\n      }\n    }\n    if(p == -1) continue;\n\n    swap(mat[p], mat[r]);\n    \n    REP(j,m) if(j != r && mat[i][j]) REP(k,m) mat[j][k] ^= mat[r][k];\n    ++r;\n  }\n\n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  while(cin >> N >> M){\n    vector<vector<int>> a(N, vector<int>(M)); cin >> a;\n    int r = rank_bit_matrix(a);\n    dump(r);\n    \n    LLI ans = (power(2LL,(LLI)(N+M-1),mod) - power(2LL,(LLI)(N+M-r-1),mod) + mod) % mod;\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll N = 303, M = 998244353;\nll qpow(ll a,ll b)\n{\n    ll r = 1;\n    for (;b;b>>=1,a=a*a%M)\n        if (b & 1)\n            r = r * a % M;\n    return r;\n}\nbitset<N> a[N];\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    ll n,m;\n    cin >> n >> m;\n    for (ll i = 0; i < n; ++i)\n        for (ll j = 0; j < m; ++j) {\n            ll x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    ll r = 0;\n    for (ll i = 0; i < n; ++i) {\n        ll j = a[i]._Find_first();\n        if (j >= m)\n            continue;\n        ++r;\n        for (ll k = i + 1; k < n; ++k)\n            if (a[k][j])\n                a[k] ^= a[i];\n    }\n    cout << (qpow(2,n) + M - qpow(2,n-r)) * qpow(2,m-1) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <bitset>\n\nconst int MOD = 998244353;\n\nint main() {\n  int N, M; scanf(\"%d%d\", &N, &M);\n  std::bitset<300> A[300];\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < M; ++j) {\n      int a; scanf(\"%d\", &a);\n      A[i][j] = a;\n    }\n  }\n  int r = 0;\n  for(int j = 0; j < M; ++j) {\n    int min_i = N;\n    for(int i = r; i < N; ++i) {\n      if(A[i][j]) {\n        min_i = i;\n        break;\n      }\n    }\n    if(min_i == N) continue;\n    if(min_i > r) {\n      A[r] ^= A[min_i];\n    }\n    for(int i = r + 1; i < N; ++i) {\n      if(A[i][j]) {\n        A[i] ^= A[r];\n      }\n    }\n    ++r;\n  }\n  // fprintf(stderr, \"r = %d\\n\", r);\n  int count = 1;\n  for(int i = 0; i < r; ++i) count = 2 * count % MOD;\n  --count; if(count < 0) count += MOD;\n  for(int i = r; i < N + M - 1; ++i) count = 2 * count % MOD;\n  printf(\"%d\\n\", count);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-9;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll matrixrank(vector< vector<double> > mat) {\n    ll h = mat.size();\n    ll w = mat[0].size();\n    ll now = 0;\n    for (ll i = 0; i < w; i++) {\n        ll pivot = now;\n        for (ll j = now + 1; j < h; j++) {\n            if (abs(mat[pivot][i]) > eps) {\n                break;\n            }\n            pivot = j;\n        }\n        if (abs(mat[pivot][i]) < eps) {\n            continue;\n        }\n        swap(mat[now], mat[pivot]);\n        for (ll j = i + 1; j < w; j++) {\n            mat[now][j] /= mat[now][i];\n        }\n        for (ll j = now + 1; j < h; j++) {\n            for (ll k = i + 1; k < w; k++) {\n                mat[j][k] -= mat[j][i] * mat[now][k];\n            }\n        }\n        now++;\n        if (now == h) {\n            break;\n        }\n    }\n    return now;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n    ll a[N][M];\n    REP(i, 0, N) {\n        REP(j, 0, M) {\n            cin >> a[i][j];\n        }\n    }\n    vector< vector<double> > mat(N);\n    REP(i, 0, N) {\n        mat[i].resize(M);\n        REP(j, 0, M) {\n            mat[i][j] = a[i][j];\n        }\n    }\n    ll rank = matrixrank(mat);\n    // cout << rank << endl;\n    ll ans = modminus(modpower(2, N + M - 1), modpower(2, N + M - rank - 1));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll n,m,i,j,k,u,mat[305][305],ans=0;\nll mod=998244353; \nll pow(ll a,ll b)\n{\n\tll ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)scanf(\"%lld\",&mat[i][j]);\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tfor(j=ans+1;j<=n;j++)\n\t\t{\n\t\t\tif(mat[j][i])\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\tfor(k=j+1;k<=n;k++)if(mat[k][i])for(u=i;u<=m;u++)mat[k][u]=mat[k][u]^mat[j][u];\n\t\t\t\tfor(k=i;k<=m;k++)swap(mat[j][k],mat[ans][k]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(pow(2LL,m+n-1)-pow(2LL,m-ans+n-1)+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\nconst ll MOD = 1000000007;\n\ninline void add(ll &x, ll y) { x += y; if (x >= MOD) x -= MOD; }\n\ntypedef vector<vi> mat;\n\nint get_rank(mat A) //mod 2\n{\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r+1; j < n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswap(A[pivot], A[r]);\n\t\tif (A[r][i] == 0) continue;\n\t\tfor (int j = r+1; j < n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tfor (int k = i; k < m; ++k) {\n\t\t\t\t\tA[j][k] ^= A[r][k];\n\t\t\t\t}       \n\t\t\t}\n\t\t}\n\t\t++r;\n\t}\n\treturn r;\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tmat A(N, vi(M));\n\n\trep(i, N) {\n\t\trep(j, M) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\tint r = get_rank(A);\n\n\tll all = 1, dec = 1;\n\trep(i, N+M-1) all = all * 2 % MOD;\n\trep(i, N+M-r-1) dec = dec * 2 % MOD;\n\tcout << (all - dec + MOD) % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define IL inline\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned int U;\ntypedef unsigned long long LLU;\ntypedef pair<int,int> PII;\ntypedef long double LD;\nIL LL read()\n{\n\tLL x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\treturn x*f;\n}\n#define io read()\nconst int mod=998244353;\nIL LL ksm(LL x,int y)\n{\n\tLL tmp=1;\n\twhile(y){\n\t\tif(y&1)\ttmp=tmp*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\t\n\t}\n\treturn tmp;\n}\nIL void upd(int &x,int y)\n{\n\tx+=y;\n\tif(x>=mod)\tx-=mod;\t\n}\nconst int N=308;\nint n,m;\nbitset<N> a[N];\nint ans;\nIL void gauss()\n{\n\tint i,j;\n\tfor(i=1,j=1;j<=m;++j){\n\t\tif(a[i][j]==0){\n\t\t\tint t;\n\t\t\tfor(t=i+1;t<=n;++t){\n\t\t\t\tif(a[t][j])\tbreak;\n\t\t\t}\n\t\t\tif(t>n)\tcontinue;\n\t\t\tswap(a[t],a[i]);\n\t\t}\n\t\tfor(int t=i+1;t<=n;++t){\n\t\t\tif(a[t][j])\ta[t]^=a[i];\t\n\t\t}\n\t\t++i;\n\t}\n\t//(i-1)个主元 \n\tfor(int t=i+1;t<=n;++t){\n\t\tif(a[t][m+1]){\n\t\t\tans=0;\n\t\t\treturn;\n\t\t}\n\t}\n\tans=ksm(2,m-i+1);\n}\nint main()\n{\n\tn=io;m=io;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=m;++j){\n\t\t\ta[i][j]=io;\t\n\t\t}\n\t}\n\tgauss();\n\tprintf(\"%lld\",(ksm(2,n+m-1)-ksm(2,n-1)*ans%mod+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nconst int MX = 307;\n\nusing bs = bitset<MX>;\n\nbs a[MX];\nint pw[2 * MX];\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n, m;\n    cin >> n >> m;\n    pw[0] = 1;\n    for (int i = 1; i < 2 * MX; i++) {\n        pw[i] = (pw[i - 1] + pw[i - 1]) % MOD;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            int x;\n            cin >> x;\n            if (x == 1) {\n                a[i][j] = true;\n            }\n        }\n    }\n\n    int basis = 0;\n    int ptr = 1;\n    for (int i = 1; i <= m; i++) {\n        int pos = ptr;\n        while (pos <= n && a[pos][i] == false) {\n            pos++;\n        }\n        if (pos == n + 1) {\n            continue;\n        }\n        basis++;\n        swap(a[pos], a[ptr]);\n        for (int j = ptr + 1; j <= n; j++) {\n            if (a[j][i]) {\n                a[j] ^= a[ptr];\n            }\n        }\n        ptr++;\n    }\n\n    int nz = (pw[n] - pw[n - basis] + MOD) % MOD;\n    int ans = (1ll * nz * pw[m - 1]) % MOD;\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> //STLͨ���㷨\n#include <cmath> //������ѧ����\n#include <cstdio> //��������/�������\n#include <iostream> //����������/���\n#include <cstring> //�ַ�������\n#include <string> //�ַ�����\n#include <ctime> //�������ʱ��ĺ���\n#define itn int\n#define fro for\n#define ll long long\n#define reg register\n#define inf 1234567890\n#define rep(i,a,b,c) for (int i=a;i<=b;i+=c)\n/*#include <bitset> //STLλ������\n#include <cstype> //�ַ�����\n#include <cerrno> //���������\n#include <complex> //������\n#include <clocale> //���屾�ػ�����\n#include <cstdlib> //������������ڴ���亯��\n#include <deque> //STL˫�˶�������\n#include <exception> //�쳣������\n#include <fstream> //�ļ�����/���\n#include <functional> //STL�������㺯��(���������)\n#include <limits> //�����������������ֵ����\n#include <list> //STL�����б�����\n#include <map> //STLӳ������\n#include <iomanip> //����������/���\n#include <ios> //��������/���֧��\n#include <iosfwd> //����/���ϵͳʹ�õ�ǰ������\n#include <istream> //����������\n#include <ostream> //���������\n#include <queue> //STL��������\n#include <set> //STL��������\n#include <sstream> //�����ַ�������\n#include <stack> //STL��ջ����\n#include <stdexcept> //��׼�쳣��\n#include <streambuf> //�ײ�����/���֧��\n#include <utility> //STLͨ��ģ����\n#include <vector> //STL��̬��������\n#include <cwchar.h>//���ַ�����������/���\n#include <cwctype.h> //���ַ�����*/\n\nusing namespace std;\n\nint ans;\n\nint max(int x,int y){return x>y?x:y;}\n\nint min(int x,int y){return x<y?x:y;}\n\nint abs(int x){return x>0?x:-x;}\n\nint gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\n\nvoid exgcd(int a,int b,int &d,int &x,int &y){if (!b){d=a,x=1,y=0;}else{exgcd(b,a%b,d,y,x);y-=x*(a/b);}}\n\n\ninline char read() {\n\tstatic const int IN_LEN = 1000000;\n\tstatic char buf[IN_LEN], *s, *t;\n\treturn (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);\n}\ntemplate<class T>\ninline void read(T &x) {\n\tstatic bool iosig;\n\tstatic char c;\n\tfor (iosig = false, c = read(); !isdigit(c); c = read()) {\n\t\tif (c == '-') iosig = true;\n\t\tif (c == -1) return;\n\t}\n\tfor (x = 0; isdigit(c); c = read()) x = x * 10 + (c ^ '0');\n\tif (iosig) x = -x;\n}\n\nchar sr[10000000],z[20];int C=-1,Z=0;\nvoid Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(int x){\n\tif (x<0) sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\n//int find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}\n\n//void add(int x,int y,int z){to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;}\nconst int mod=998244353,N=512;\nint a[N][N],s[N][N];\n\nint quick_power(ll a,int b){ll r=1;for (;b;b>>=1,a=a*a%mod)if (b&1) r=r*a%mod;return r;}\n\nint main()\n{\n\tint n,m;\n\tread(n);read(m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++) read(a[i][j]);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tif (a[i][j])\n\t\t\t{\n\t\t\t\tif (!s[i][j])\n\t\t\t\t{\n\t\t\t\t\tfor (int k=j;k<=m;k++) s[i][k]=a[i][k];\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int k=j;k<=m;k++) s[i][k]^=a[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans=1ll*(quick_power(2,n)-quick_power(2,n-ans))*quick_power(2,m-1)%mod;\n\t(ans+=mod)%=mod;\n\tcout<<ans;\n\treturn 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\nusing BS=bitset<333>;\n\nBS a[333];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,m;\n\tcin>>n>>m;\n\trep(i,n){\n\t\ta[i].reset();\n\t\trep(j,m){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x) a[i][j]=1;\n\t\t}\n\t}\n\tint o=0;\n\trep(j,m){\n\t\tint tmp=-1;\n\t\treps(i,o,n)if(a[i][j]){\n\t\t\ttmp=i; break;\n\t\t}\n\t\tif(tmp<0) continue;\n\t\tif(o!=tmp) swap(a[o],a[tmp]);\n\t\trep(i,n)if(i!=o && a[i][j]) a[i]^=a[o];\n\t\t++o;\n\t}\n\t// rep(i,n){rep(j,m) cout<<a[i][j];cout<<endl;}\n\tmint ker=1;\n\tint t=0;\n\trep(i,n)if(a[i].count()==0) ker+=ker, ++t;\n\tassert(t+o==n);\n\tout(ker,1);\n\tmint re=modpow(mint(2),m-1);\n\tcout<<re*(modpow(mint(2),n)-ker)<<endl;\n\t// cout<<(1ll<<4)*((1ll<<5)-1)%MOD<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 305;\nconst int MOD = 998244353;\nbitset<N> a[N]; \nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile(k) {\n\t\tif(k&1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD; \n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = m-1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t) a[i].flip(j);\n\t\t}\n\t}\n \tfor (int i = 0; i < n; i++) {\n \t\tfor (bitset<N> b : base) {\n \t\t\tbitset<N> bb = b^a[i];\n \t\t\tfor (int j = m-1; j >= 0; j--) {\n \t\t\t\tif(bb[j] < a[i][j]) {\n \t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t }\n\t\t\t}\n\t\t }\t\n\t\t if(a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", (q_pow(2, n+m-1) - q_pow(2, n+m-1-cnt) + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=998244353;\nint n,m,ans,A[305][305],two[605],dp[305][305];\nvoid up(int &x){if (x>=P) x-=P;}\n\nint xor_guass(int m, int n) //AÊÇÒì»ò·½³Ì×éÏµÊý¾ØÕó ·µ»ØÖÈ\n{\n    int i = 0, j = 0, k, r, u;\n    while(i < m && j < n){//µ±Ç°ÕýÔÚ´¦ÀíµÚi¸ö·½³Ì,µÚj¸ö±äÁ¿\n        r = i;\n        for(int k = i; k < m; k++) if(A[k][j]){r = k; break;}\n        if(A[r][j]){\n             if(r != i) for(k = 0; k <= n; k++) swap(A[r][k], A[i][k]);\n             //ÏûÔªÍê³ÉÖ®ºóµÚiÐÐµÄµÚÒ»¸ö·Ç0ÁÐÊÇµÚjÁÐ,ÇÒµÚu>iÐÐµÄµÚjÁÐÈ«ÊÇ0\n            for(u = i + 1; u < m; u++) if(A[u][j])\n                for(k = i; k <= n; k++) A[u][k] ^= A[i][k];\n            i++;\n        }\n        j++;\n    }\n    return i;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tA[j-1][i-1]=x;\n\t\t}\n\t \n\ttwo[0]=1;\n\tfor (int i=1;i<=n+m;i++)\n\t\ttwo[i]=two[i-1]*2%P;\n\tans=1ll*(two[n]-two[min(n,m)-xor_guass(m,n)]+P)*two[m-1]%P; \n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=998244353;\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\nconst double EPS=1E-8;//小さい数\nint ran=0;\nvec gauss_jordan(const mat& A, const vec& b){\n    int n=A.size();\n    mat B(n, vec(n+1));\n    rep(i,0,n){\n        rep(j,0,n){\n            B[i][j]=A[i][j];\n        }\n    }\n    //行列Aの後ろにbを並べ同時に処理する\n    rep(i,0,n) B[i][n]=b[i];\n    rep(i,0,n){\n        //注目している変数の係数の絶対値が大きい式をi番目に持ってくる\n        int pivot=i;\n        rep(j,i,n){\n            if(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n        }\n        swap(B[i], B[pivot]);\n        \n        //解がないか、一意でない\n        //ここの実装難しい\n        if(abs(B[i][i])<EPS) return vec();\n        //注目している変数の係数を1にする\n        rep(j,i+1,n+1) B[i][j]/=B[i][i];\n        rep(j,0,n){\n            if(i!=j){\n                //j番目の式からi番目の変数を消去\n                rep(k,i+1,n+1) B[j][k]-=B[j][i]*B[i][k];\n            }\n        }\n    }\n    vec x(n);\n    rep(i,0,n) x[i]=B[i][n];\n    return x;\n}\nll mod_pow(ll x, ll n, ll mod){\n    if (n==0) return 1;\n    ll res=mod_pow(x*x%mod, n/2, mod);\n    if (n%2==1) res=res*x%mod;\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N,M;\n    cin>>N>>M;\n    mat a(N,vec(M,0));\n    rep(i,0,N){\n        rep(j,0,M){\n            cin>>a[i][j];\n        }\n    }\n    vec b(1,0);\n    gauss_jordan(a, b);\n    rep(i,0,N){\n        bool t=false;;\n        rep(j,0,M){\n            if(a[i][j]==1) t=true;\n        }\n        if(t) ran++;\n    }\n    cout <<(mod_pow(2LL, N+M-1, MOD)-mod_pow(2LL, N+M-1-ran, MOD)+MOD)%MOD<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, S default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\nint _main();\nint main()\n{\n    cout << setprecision(12);\n    return _main();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD   998244353LL\n\nbool swap_row(ll a[303][303], ll rows, ll cols, ll pos_row, ll pos_col)\n{\n    ll dpos_row = pos_row;\n    while (!a[dpos_row][pos_col] && dpos_row < rows) dpos_row++;\n    if (dpos_row == rows) return false;\n    if (dpos_row == pos_row) return true;\n\n    rep (i, cols) {\n        ll tmp = a[pos_row][i];\n        a[pos_row][i] = a[dpos_row][i];\n        a[dpos_row][i] = tmp;\n    }\n\n    return true;\n}\n\nll calc_rank(ll a[303][303], ll rows, ll cols)\n{\n    ll pos_row = 0LL;\n\n    rep (pos_col, cols) {\n        bool found = swap_row(a, rows, cols, pos_row, pos_col);\n        if (!found) continue;\n\n        srep (row, pos_row+1LL, rows) {\n            if (!a[row][pos_col]) continue;\n            rep (col, cols) {\n                a[row][col] -= a[pos_row][col];\n                a[row][col] &= 1LL;\n            }\n        }\n\n        pos_row++;\n        if (pos_row >= rows) break;\n\n        debug_printf(\"---- pos_row=%lld\\n\", pos_row);\n        rep (i, rows) {\n            rep (j, cols) debug_printf(\"%lld \", a[i][j]);\n            debug_printf(\"\\n\");\n        }\n\n    }\n\n    debug_printf(\"---- gauss a\\n\");\n    rep (i, rows) {\n        rep (j, cols) debug_printf(\"%lld \", a[i][j]);\n        debug_printf(\"\\n\");\n    }\n\n    ll rank = 0LL;\n\n    rep (row, rows) {\n        rep (col, cols) {\n            if (a[row][col]) {\n                rank = row + 1LL;\n                break;\n            }\n        }\n    }\n\n    debug_printf(\"---- rank = %lld\\n\", rank);\n    return rank;\n}\n\nint _main()\n{\n    ll rows; llin(rows);\n    ll cols; llin(cols);\n    static ll a[303][303];\n    rep (i, rows) rep (j, cols) llin(a[i][j]);\n\n    ll colcnt_all = mod_pow(2LL, cols, MOD);\n    debug_printf(\"colcnt_all = %lld\\n\", colcnt_all);\n\n    ll rank = calc_rank(a, rows, cols);\n\n    // rank + dim(kernel_set) == cols\n    ll dim_kernel_set = cols - rank;\n\n    ll colcnt_invalid = mod_pow(2LL, dim_kernel_set, MOD);\n    ll colcnt_valid = colcnt_all - colcnt_invalid;\n    debug_printf(\"---- colcnt_valid = %lld\\n\", colcnt_valid);\n\n    ll ans = colcnt_valid * mod_pow(2LL, rows, MOD);\n    ans %= MOD;\n    ans *= mod_inv(2LL, MOD);\n    ans %= MOD;\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, vector<vector<int>>& scc, stack<int>& S, vector<int>& inS, vector<int>& low,vector<int>& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(vector<int>());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph& g, vector<vector<int>>& scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tvector<int> num(n), low(n);\n\tstack<int> S;\n\tvector<int> inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\nclass SumSegTree {\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\t// 区間[l,r)の総和\n\tll sum(ll l, ll r) {\n\t\tll ret = 0;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)ret += dat[l];\n\t\t\tif ((r & 1) == 0)ret += dat[r - 1];\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn ret;\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\nwhile (n > 0) {\n\tif (n & 1) res = res * x % mod;\n\tx = x * x % mod;\n\tn >>= 1;\n}\nreturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n);\n\t\tinv[n - 1] = mod_inv(fact[n - 1]);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\n\nvoid rowReduction(vector<bitset<330>> mat, vector<bitset<330>>& basis) {//掃き出し法\n\tfor (auto e : mat) {\n\t\tfor (auto b : basis) {\n\t\t\tauto tmp = e ^ b;\n\t\t\tfor (int i = 329; i >= 0; i--) {\n\t\t\t\tif (e[i] < tmp[i]) {\n\t\t\t\t\te = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (e[i] > tmp[i])break;\n\t\t\t}\n\t\t}\n\t\tif (e != 0)\n\t\t\tbasis.push_back(e);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tconstexpr ll mod = 998244353;\n\tll n, m;\n\tcin >> n >> m;\n\tMatrix a(n, Array(m));\n\tREP(i, n)REP(j, m)cin >> a[i][j];\n\tvector<bitset<330>> mat(n);\n\tREP(i, n)REP(j, m)mat[i][j] = a[i][j] % 2;\n\tvector<bitset<330>> basis;\n\trowReduction(mat, basis);\n\tll ans = mod_pow(2, n + m - 1, mod);\n\t(ans += mod - mod_pow(2, n + m - basis.size() - 1, mod)) %= mod;\n\tcout << ans << \"\\n\";\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define N 100005\nconst int mod=998244353;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\nint main(){\n    int n,m;\n    scanf(\"%d %d\",&n,&m);\n    bitset<300> b[305];\n    for(int i = 0;i<n;i++){\n        for(int j = 0;j<m;j++){\n            int x;\n            scanf(\"%d\",&x);\n            b[i][j]=x;\n        }\n    }\n    vector<bitset<300> > v;\n    int tot=n;\n    for(int i = 0;i<n;i++){\n        for(auto &it:v){\n            for(int k = 0;k<m;k++){\n                if(it[k]||b[i][k]){\n                    if(it[k]&&b[i][k]){\n                        b[i]^=it;\n                    }\n                    else if(it[k]){\n\n                    }\n                    else{\n                        swap(b[i],it);\n                    }\n                    break;\n                }\n            }\n        }\n        if(b[i].count()!=0){\n            v.pb(b[i]);\n            tot--;\n        }\n    }\n    LL ans=(f_pow(2,n)-f_pow(2,tot))*f_pow(2,m-1)%mod;\n    ans=((ans+mod)%mod);\n    printf(\"%lld\\n\",ans);\n}\n/*\n\n\n     0   \n     1   1\n     2   3\n     3 5  1 0 0\n    4*/"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\n\nvoid norm(VV<int>& a) {\n\tint n = a.size(), m = a[0].size();\n\tREP(j, m) {\n\t\tint pivot = -1;\n\t\tREP(i, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tpivot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) continue;\n\n\t\tFOR(i, pivot + 1, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tREP(k, m) {\n\t\t\t\t\ta[i][k] ^= a[pivot][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tMAT(int, a, n, m);\n\n\tREP(_, 2) {\n\t\tnorm(a);\n\t\tVV<int> b(m, V<int>(n));\n\t\tREP(i, n) REP(j, m) {\n\t\t\tb[j][i] = a[i][j];\n\t\t}\n\t\tstd::swap(n, m);\n\t\tstd::swap(a, b);\n\t}\n\n\tint one = 0;\n\tint zero = 0;\n\tREP(i, n) {\n\t\tbool f = false;\n\t\tREP(j, m) if (a[i][j]) f = true;\n\t\tif (f) ++one;\n\t\telse ++zero;\n\t}\n\tREP(j, m) {\n\t\tbool f = false;\n\t\tREP(i, n) if (a[i][j]) f = true;\n\t\tif (f) /*++one*/;\n\t\telse ++zero;\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= one; i += 2) {\n\t\tint sum = Combination(one, i);\n\t\t(sum *= powMod(2, zero, MOD)) %= MOD;\n\t\t(ans += sum) %= MOD;\n\t}\n\tans = powMod(2, n + m - 1, MOD) - ans;\n\tans %= MOD;\n\tif (ans < 0) ans += MOD;\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\nconst int N=305;\nconst int mod=998244353;\nint powmod(int x, int k)\n{\n\tint ans=1;\n\tfor(;k;k>>=1,x=(ll)x*x%mod) if(k&1) ans=(ll)ans*x%mod;\n\treturn ans;\n}\nint inv(int x){ return powmod(x,mod-2);}\nint a[N][N];\nint main()\n{\n\tint n,m,i,j,k;\n\tscanf(\"%i %i\",&n,&m);\n\tfor(i=1;i<=n;i++) for(j=1;j<=m;j++) scanf(\"%i\",&a[i][j]);\n\tint r=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tbool ok=0;\n\t\tfor(j=r+1;j<=n;j++)\n\t\t{\n\t\t\tif(a[j][i])\n\t\t\t{\n\t\t\t\tfor(k=i;k<=m;k++) swap(a[j][k],a[r+1][k]);\n\t\t\t\tok=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\t\tr++;\n\t\tfor(j=r+1;j<=n;j++) if(a[j][i])\n\t\t{\n\t\t\tint mul=(ll)(mod-a[j][i])*inv(a[r][i])%mod;\n\t\t\tfor(k=i;k<=m;k++) a[j][k]=(a[j][k]+(ll)a[r][k]*mul%mod)%mod;\n\t\t}\n\t}\n\tint ans=1,sol=1;\n\tfor(i=1;i<=n+m-1;i++) ans=ans*2%mod;\n\tfor(i=1;i<=n+m-r-1;i++) sol=sol*2%mod;\n\tans-=sol;\n\tif(ans<0) ans+=mod;\n\tprintf(\"%i\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=998244353;\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\nconst double EPS=1E-8;//小さい数\nint mat_rank(mat A) {\n    int N = A.size(), M = A[0].size();\n    int res = 0;\n    for(int i=0; i<M; i++) {\n        // 絶対値が最も大きいものを探す\n        double max_elem = 0; int piv = -1;\n        for(int j=res; j<N; j++) {\n            if(abs(A[j][i])-EPS > max_elem) {\n                max_elem = abs(A[j][i]);\n                piv = j;\n            }\n        }\n        if(piv < 0) continue;\n        swap(A[res], A[piv]);\n        for(int k=0; k<M; k++) {\n            A[res][k] = (1.0 * A[res][k] / A[res][i]);\n        }\n        for(int j=0; j<N; j++) {\n            if(j == res) continue;\n            double mul = A[j][i];\n            for(int k=0; k<M; k++) {\n                A[j][k] = A[j][k] - mul * A[res][k];\n            }\n        }\n        res++;\n    }\n    return res;\n}\nll mod_pow(ll x, ll n, ll mod){\n    if (n==0) return 1;\n    ll res=mod_pow(x*x%mod, n/2, mod);\n    if (n%2==1) res=res*x%mod;\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N,M;\n    cin>>N>>M;\n    mat a(N,vec(M,0));\n    rep(i,0,N){\n        rep(j,0,M){\n            cin>>a[i][j];\n        }\n    }\n    cout <<(mod_pow(2LL, N+M-1, MOD)-mod_pow(2LL, N+M-1-mat_rank(a), MOD)+MOD)%MOD<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=998244353;\nlong long n,m,a[333][333],pw[666],cnt,pos,cur;\nvoid gauss()\n{\n\tfor (long long i=1;i<=m;i++)\n\t{\n\t\tpos=-1;\n\t\tfor (long long j=i;j<=n;j++)\n\t\t{\n\t\t\tif (a[j][i])\n\t\t\t{\n\t\t\t\tpos=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~pos)\n\t\t{\n\t\t\tcnt++;\n\t\t\tfor (long long j=1;j<=m;j++) swap(a[i][j],a[pos][j]);\n\t\t\tfor (long long j=i+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif (a[j][i])\n\t\t\t\t{\n\t\t\t\t\tfor (long long k=i;k<=m;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][k]^=a[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} \nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tfor (long long j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tpw[0]=1;\n\tfor (long long i=1;i<=600;i++) pw[i]=pw[i-1]*2%mod;\n\tgauss();\n\tcur=pw[m-cnt];\n\tprintf(\"%lld\\n\",((pw[n+m-1]-pw[n-1]*cur)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define mod 998244353\nusing namespace std;\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') {\n        if (c == '-') f = -1;\n        c = getchar();\n    }\n    while (c >= '0' && c <= '9') {\n        x = x * 10 + c - '0';\n        c = getchar();\n    }\n    return x * f;\n}\n\nint base[302][302];\nint a[302];\nint sum, n, m;\n\nlong long fsp(int p) {\n    long long rt = 1, base = 2;\n    while (p) {\n        if (p & 1) (rt *= base) %= mod;\n        (base *= base) %= mod;\n        p >>= 1;\n    }\n    return rt;\n}\n\nvoid work() {\n    for (int i = m; i >= 1; --i) {\n        if (!a[i]) continue;\n        if (!base[i][i]) {\n            sum--;\n            for (int j = 1; j <= i; ++j) {\n                base[i][j] = a[j];\n            }\n            for (int j = 1; j < i; ++j) {\n                if (!base[i][j]) continue;\n                for (int k = 1; k <= j; ++k) {\n                    base[i][k] ^= base[j][k];\n                }\n            }\n            for (int j = i + 1; j <= m; ++j) {\n                if (!base[j][i]) continue;\n                for (int k = 1; k <= i; ++k) {\n                    base[j][k] ^= base[i][k];\n                }\n            }\n            break;\n        } else {\n            for (int j = 1; j <= i; ++j) {\n                a[j] ^= base[i][j];\n            }\n        }\n    }\n    return ;\n}\n\nint main() {\n    n = sum = read(), m = read();\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            a[j] = read();\n        }\n        work();\n    }\n    printf(\"%lld\", fsp(m - 1) * (fsp(n) + mod - fsp(sum)) % mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <map>\n#include <set>\n#include <sys/timeb.h>\n#include <fstream>\n#include <random>\n#include <regex>\n#include <chrono>\n#include <bitset>\n#include <cassert>\n#include <iomanip>\n#include <limits>\n#include <stack>\n\nusing namespace std;\n\n#define DEBUG_\n\n#define repr(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repr(i,0,n)\n#define reprrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) reprrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n#define MOD 1000000007\n#define MOD2 998244353\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\n\n#ifdef DEBUG_\n#define DEB\n#else\n#define DEB if(false)\n#endif\n\n#ifdef DEBUG_\n#define dump(...) DUMPOUT<<\"  \"; \\\ndump_func(string(#__VA_ARGS__) + \":\", \"[\" + to_string(__LINE__) + \":\" + __FUNCTION__ + \"]\"); \\\nDUMPOUT<<\"    \"; \\\ndump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<Pi> vPi;\ntypedef vector<Pll> vPll;\ntypedef vector<Pd>vPd;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<Pi> > vvPi;\ntypedef vector<vector<vector<int> > > vvvi;\ntypedef vector<vector<vector<ll> > > vvvll;\ntypedef vector<vector<vector<Pi> > > vvvPi;\ntypedef vector<vector<vector<vector<Pi> > > > vvvvPi;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<Pi, vector<Pi>, greater<Pi> > pqlP;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate<class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nstring debug_show(Pi a) {\n\treturn \"(\" + to_string(a.first) + \",\" + to_string(a.second) + \")\";\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n\tDUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& head, Tail&&... tail) {\n\tDUMPOUT << head;\n\tif (sizeof...(Tail) <= 1) {\n\t\tDUMPOUT << \" \";\n\t}\n\telse {\n\t\tDUMPOUT << \", \";\n\t}\n\tdump_func(std::move(tail)...);\n}\n\n// vector\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec) is >> x;\n\treturn is;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// pair\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, const pair<T, U>& pair_var) {\n\tos << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n\treturn os;\n}\n// vector\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& vec) {\n\tos << \"{\";\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tos << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// map\ntemplate<typename T, typename U>\nostream& operator << (ostream& os, map<T, U>& map_var) {\n\tos << \"{\";\n\trepi(itr, map_var) {\n\t\tos << \"(\" << itr->first << \",\" << itr->second << \")\";\n\t\titr++;\n\t\tif (itr == map_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\n// set\ntemplate<typename T>\nostream& operator << (ostream& os, set<T>& set_var) {\n\tos << \"{\";\n\trepi(itr, set_var) {\n\t\tos << \"  \" << *itr << endl;\n\t\titr++;\n\t\tif (itr == set_var.end()) os << \", \";\n\t\titr--;\n\t}\n\tos << \"}\";\n\treturn os;\n}\nstring YN(bool y, int id = 0) { if (id)cout << id; return (y ? \"YES\" : \"NO\"); }\nstring yn(bool y, int id = 0) { if (id)cout << id; return (y ? \"Yes\" : \"No\"); }\nstring ON(bool y, int id = 0) { if (id)cout << id; return (y ? \"OK\" : \"NG\"); }\n\nint dir4[4][2] = { { 0,-1 },{ -1,0 },{ 1,0 },{ 0,1 } };\nint dir8[8][2] = { { -1,-1 },{ 0,-1 },{ 1,-1 },{ -1,0 },{ 1,0 },{ -1,1 },{ 0,1 },{ 1,1 } };\nchar dirchar[4] = { '<','^','>','v' };\n\n// [a,b)\nint irand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_int_distribution<int> dist(a, b - 1);\n\treturn dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n\tstatic mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n\tuniform_real_distribution<double> dist(a, b);\n\treturn dist(Rand);\n}\n\nstruct Edge {\nint from, to, cost;\nbool operator<(Edge e) {\nreturn cost < e.cost;\n}\n};\nusing Graph = vec<vec<Edge>>;\n\nostream& operator << (ostream& os, Edge &edge) {\nos << \"(\" << edge.from << \"->\" << edge.to << \":\" << edge.cost << \")\";\nreturn os;\n}\n\n//======================================================\n\nll powMod(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint matrix_rank(vvi m) {\n\tint H = m.size();\n\tint W = m[0].size();\n\tint r = 0;\t// 暫定のランク（今見ている段）\n\trep(i, W) {\n\t\tif (m[r][i] == 0) {\n\t\t\tbool find = false;\n\t\t\trepr(j, r + 1, H) {\n\t\t\t\tif (m[j][i] == 1) {\n\t\t\t\t\tswap(m[r], m[j]);\n\t\t\t\t\tfind = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!find)continue;\n\t\t}\n\t\trepr(j, r + 1, H) {\n\t\t\tif (m[j][i] == 1) {\n\t\t\t\trepr(k, i, W) {\n\t\t\t\t\tm[j][k] ^= m[r][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr++;\n\t\tif (r == H)break;\n\t}\n\treturn r;\n}\n\nint main(void) {\n\tint H, W;\n\tcin >> H >> W;\n\tvvi m(H, vi(W));\n\tcin >> m;\n\tint r = matrix_rank(m);\n\tint k = W - r;\n\tll ans = powMod(2, W, MOD2) - powMod(2, k, MOD2) + MOD2;\n\tans %= MOD2;\n\tans *= powMod(2, H - 1, MOD2);\n\tans %= MOD2;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VVI a(n, VI(m));\n    REP(i,n) REP(j,m) a[i][j] = in();\n\n    int r = 0, p = 0;\n    REP(i,n){\n        while (p < m){\n            int j = -1;\n            FOR(k,i,n-1){\n                if (a[k][p]){\n                    j = k;\n                    break;\n                }\n            }\n            if (j == -1){\n                p++;\n                continue;\n            }\n            r = i + 1;\n            swap(a[i], a[j]);\n            FOR(j,i+1,n-1){\n                if (!a[j][i]) continue;\n                FOR(k,p,m-1) a[j][k] ^= a[i][k];\n            }\n            p++;\n            break;\n        }\n    }\n\n    ll ans = powll(2, m - 1) * (powll(2, n) - powll(2, n - r) + mod) % mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t r = 0;\n    for (std::size_t c = 0; c < mat.C; c++) {\n        if (c == mat.R) { break; }\n        std::size_t piv = c;\n        for (; piv < mat.R and mat[piv][c] == 0; piv++) {}\n        if (piv == mat.R) { continue; }\n        std::swap(mat[r], mat[piv]);\n        const T p = mat[r][c];\n        for (std::size_t i = 0; i < mat.R; i++) { mat[i][c] /= p; }\n        for (std::size_t j = 0; j < mat.C; j++) {\n            if (j == c) { continue; }\n            const T p = mat[r][j];\n            for (std::size_t i = 0; i < mat.R; i++) { mat[i][j] -= mat[i][c] * p; }\n        }\n        r++;\n    }\n    return r;\n}\nusing ll = long long;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T MOD() { return 1000000007; }\ntemplate <typename T, T mod = MOD<T>()>\nclass ModInt\n{\nprivate:\n    T value;\n    static T pow(const T p, const T n) { return p < 0 ? pow(mod + p, n) : n == 0 ? 1 : n % 2 == 1 ? pow(p, n - 1) * p % mod : pow(p * p % mod, n / 2); }\n    static T inv(const T p) { return pow(p, mod - 2); }\n\npublic:\n    ModInt() : value{0} {}\n    ModInt(const T val) : value{((val % mod) + mod) % mod} {}\n    ModInt(const ModInt<T, mod>& n) : value{n()} {}\n    ModInt<T, mod>& operator=(const ModInt<T, mod>& n) { return value = n(), (*this); }\n    ModInt<T, mod>& operator=(const T v) { return value = (mod + v % mod) % mod, (*this); }\n    ModInt<T, mod> operator+() const { return *this; }\n    ModInt<T, mod> operator-() const { return ModInt{mod - value}; }\n    ModInt<T, mod> operator+(const ModInt<T, mod>& val) const { return ModInt{value + val()}; }\n    ModInt<T, mod> operator-(const ModInt<T, mod>& val) const { return ModInt{value - val() + mod}; }\n    ModInt<T, mod> operator*(const ModInt<T, mod>& val) const { return ModInt{value * val()}; }\n    ModInt<T, mod> operator/(const ModInt<T, mod>& val) const { return ModInt{value * inv(val())}; }\n    ModInt<T, mod>& operator+=(const ModInt<T, mod>& val) { return (((value += val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const ModInt<T, mod>& val) { return (((value -= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const ModInt<T, mod>& val) { return (((value *= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const ModInt<T, mod>& val) { return (((value *= inv(val())) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod> operator+(const T val) const { return ModInt{value + val}; }\n    ModInt<T, mod> operator-(const T val) const { return ModInt{value - val}; }\n    ModInt<T, mod> operator*(const T val) const { return ModInt{value * val}; }\n    ModInt<T, mod> operator/(const T val) const { return ModInt{value * inv(val)}; }\n    ModInt<T, mod>& operator+=(const T val) { return (((value += val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const T val) { return (((value -= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const T val) { return (((value *= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const T val) { return (((value *= inv(val)) %= mod) += mod) %= mod, (*this); }\n    bool operator==(const ModInt<T, mod>& val) const { return value == val.value; }\n    bool operator!=(const ModInt<T, mod>& val) const { return not(*this == val); }\n    bool operator==(const T val) const { return value == (mod + val % mod) % mod; }\n    bool operator!=(const T val) const { return not(*this == val); }\n    T operator()() const { return value; }\n};\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator+(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator-(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{-n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator*(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() * val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator/(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>(val) / n; }\ntemplate <typename T, T mod>\ninline bool operator==(const T val, const ModInt<T, mod>& n) { return n == val; }\ntemplate <typename T, T mod>\ninline bool operator!=(const T val, const ModInt<T, mod>& n) { return not(val == n); }\ntemplate <typename T, T mod>\ninline std::istream& operator>>(std::istream& is, ModInt<T, mod>& n)\n{\n    T v;\n    return is >> v, n = v, is;\n}\ntemplate <typename T, T mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<T, mod>& n) { return (os << n()); }\nusing mint = ModInt<int, MOD<int>()>;\nusing mll = ModInt<ll, MOD<ll>()>;\nconstexpr int MOD2 = 998244353;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<ModInt<int, 2>> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<int> bp(600, 1);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2 % MOD2; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD2) % MOD2 << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    bool a[n][m];\n    int r = 0;\n    for (int i = 0;i < n;++i) for (int j = 0;j < m;++j) cin >> a[i][j];\n    for (int i = 0;i < n;++i) {\n        int p = i,q = i;\n        for (int j = i;j < n;++j) {\n            if (a[p][q]) break;\n            for (int k = i;k < m;++k) if (a[j][k] == 1) {\n                p = j;q = k;\n                break;\n            }\n        }\n        if (a[p][q] == 0) break;\n        r = i+1;\n        if (q != i) for (int j = i;j < n;++j) a[j][i] ^= a[j][q];\n        if (p != i) for (int j = i;j < m;++j) a[i][j] ^= a[p][j];\n        for (int j = i+1;j < n;++j) if (a[j][i] == 1) for (int k = i;k < m;++k) a[j][k] ^= a[i][k];\n        for (int j = i+1;j < m;++j) if (a[i][j] == 1) for (int k = i;k < n;++k) a[k][j] ^= a[k][i];\n    }\n    int x = 1,y = 1;\n    for (int i = 0;i < n+m-1;++i) {\n        x <<= 1;\n        x %= mod;\n    }\n    for (int i = 0;i < n+m-r-1;++i) {\n        y <<= 1;\n        y %= mod;\n    }\n    cout << (x-y+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 998244353;\n\n// 階段行列を求める O(min(H,W)HW/64)\n// 列に応じてbitsetのbit長を変えろ\nusing mat = vector<bitset<300>>;\nmat gauss_jordan(mat a) {\n    const int h = a.size(), w = a[0].size();\n    int rank = 0;\n    REP(i, min(w, h)) {\n        int pivot = -1;\n        FOR(j, rank, h) if(a[j][i]) {pivot = j; break;}\n        if(pivot == -1) continue;\n        swap(a[rank], a[pivot]);\n        REP(j, h) if(j != rank && a[j][i]) a[j] ^= a[rank];\n        rank++;\n    }\n    return a;\n}\n\n// ダブリング O(funcの計算量*log(e))\ntemplate<typename T=ll, typename F=function<T(T,T)>>\nT binpow(T x, ll e, F func=[](T a, T b){return a*b%MOD;}, T d=1) {\n  T ret = d, p = x;\n  while(e > 0) {\n    if(e&1) {ret = func(ret, p); e--;}\n    else {p = func(p, p); e /= 2;} \n  }\n  return ret;\n};\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll h, w;\n    cin >> h >> w;\n    mat a(h);\n    REP(i, h) REP(j, w) {\n        ll b; cin >> b;\n        if(b) a[i].set(j);\n    }\n\n    auto ret = gauss_jordan(a);\n    ll rank = h;\n    REP(i, h) {\n        bool flag = false;\n        REP(j, w) if(ret[i][j]) flag = true;\n        if(!flag) {\n            rank = i;\n            break;\n        }\n    }\n\n    // (2^h - 2^(h-rank)) * 2^(w-1)\n    ll ans = ((binpow(2, h) - binpow(2, h-rank)) % MOD + MOD) % MOD;\n    (ans *= binpow(2, w-1)) %= MOD;\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint a[305][305];\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) cin >> a[i][j];\n\t}\n\t\n\t// a[i][m + 1] = 0\n\tint rank = 0;\n\tfor (int col = 1; col <= m; ++col) {\n\t\tint row = 0;\n\t\tfor (int i = 1; i <= n; ++i) if (a[i][col]) row = i;\n\t\tif (!row) {\n\t\t\t++rank; continue;\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) if (i != row && a[i][col]) {\n\t\t\tfor (int j = 1; j <= m; ++j) a[i][j] ^= a[row][j];\n\t\t}\n\t}\n\t\n\t// 2^(m + n - 1) - 2^(rank + n - 1)\n\tint tmp = 1, res = 1;\n\tstatic const int mod = 998244353;\n\tfor (int i = 1; i <= m + n - 1; ++i) res = 2LL * res % mod;\n\tfor (int i = 1; i <= rank + n - 1; ++i) tmp = 2LL * tmp % mod;\n\t\n\tres = (res - tmp) % mod;\n\tif (res < 0) res += mod;\n\t\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 998244353LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                // C[i][j] += A[i][k] * B[k][j]; // modなし\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// Matrix Library End\n\n// N * M 行列のランクを求める\n// 整数行列でも基本変形時に分数になるので double 型に限定しています\nint mat_rank(Matrix<double> A) {\n    int N = A.size(), M = A[0].size();\n\n    int res = 0;\n    for(int i=0; i<M; i++) {\n        // 絶対値が最も大きいものを探す\n        double max_elem = 0; int piv = -1;\n        for(int j=res; j<N; j++) {\n            if(abs(A[j][i]) > max_elem) {\n                max_elem = abs(A[j][i]);\n                piv = j;\n            }\n        }\n        \n        if(piv < 0) continue;\n            \n        // res 行目を piv 行目に変えて、行基本変形\n        swap(A[res], A[piv]);\n\n        // res 行目を正規化\n        for(int k=0; k<M; k++) {\n            A[res][k] = 1.0 * A[res][k] / A[res][i];\n        }\n        \n        for(int j=0; j<N; j++) {\n            if(j == res) continue;\n            assert(A[res][i] != 0);\n            double mul = A[j][i];\n            for(int k=0; k<M; k++) {\n                A[j][k] = A[j][k] - mul * A[res][k];\n            }\n        }\n        res++;\n    }\n    return res;\n}\n\nconst int MAXN = 610;\nint pow2[MAXN + 10];\nsigned main() {\n    pow2[0] = 1;\n    for(int i=1; i<=MAXN; i++) pow2[i] = (pow2[i-1] * 2) % MOD;\n    \n    int N, M; cin >> N >> M;\n    Matrix<double> mat;\n    init_mat(mat, N, M);\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            cin >> mat[i][j];\n        }\n    }\n\n    int rank = mat_rank(mat);\n    int ansA = pow2[N + M - 1];\n    int ansB = pow2[N + M - rank - 1];\n    fprintf(stderr, \"matrix rank = %lld\\n\", rank);\n    printf(\"%lld\\n\", (ansA - ansB + MOD) % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst ll MOD = 998244353;\n\n\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n\nconst int MAXN = 310;\n\nbitset<MAXN> bb[MAXN];\n\nint n, m;\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tbb[i][j] = x;\n\t\t}\n\tint now = 0;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint fl = 0;\n\t\tfor (int j = now; j < n; ++j)\n\t\t\tif (bb[j][i]) {\n\t\t\t\tfl = 1;\n\t\t\t\tswap(bb[j], bb[now]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!fl)\n\t\t\tcontinue;\n\t\tfor (int j = now + 1; j < n; ++j) {\n\t\t\tif (bb[j][i])\n\t\t\t\tbb[j] ^= bb[now];\n\t\t}\n\t\t++now;\n\t}\n\tll go = (pw(2, n) + MOD - pw(2, n - now)) % MOD;\n\tcout << (go * pw(2, m - 1)) % MOD << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 998244353\n\nint n, m, r, ans;\nbitset<300> bm[300];\nbool u[300];\nint ta;\n\nint po(int p) {\n\tlong long re = 1, b = 2;\n\twhile (p) {\n\t\tif (p & 1)\n\t\t\tre = re * b % MOD;\n\t\tb = b * b % MOD;\n\t\tp >>= 1;\n\t}\n\treturn re;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &ta);\n\t\t\tif (ta)\n\t\t\t\tbm[i].set(j);\n\t\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tta = -1;\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (!u[j] && bm[j].test(i)) {\n\t\t\t\tu[j] = 1;\n\t\t\t\tta = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (ta == -1)\n\t\t\tcontinue;\n\t\tr++;\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (!u[j] && bm[j].test(i))\n\t\t\t\tbm[j] ^= bm[ta];\n\t}\n\tans = po(n + m - 1) + MOD - po(n + m - r - 1);\n\tif (ans >= MOD)\n\t\tans -= MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t r = 0;\n    for (std::size_t c = 0; c < mat.C; c++) {\n        if (r == mat.R) { return r; }\n        std::size_t piv = r;\n        for (; piv < mat.R and mat[piv][c] == 0; piv++) {}\n        if (piv == mat.R) { continue; }\n        std::swap(mat[r], mat[piv]);\n        const T p = mat[r][c];\n        for (std::size_t i = r; i < mat.R; i++) { mat[i][c] /= p; }\n        for (std::size_t j = 0; j < mat.C; j++) {\n            if (j == c) { continue; }\n            const T p = mat[r][j];\n            for (std::size_t i = 0; i < mat.R; i++) { mat[i][j] -= p * mat[i][c]; }\n        }\n        r++;\n    }\n    return r;\n}\nusing ll = long long;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T MOD() { return 1000000007; }\ntemplate <typename T, T mod = MOD<T>()>\nclass ModInt\n{\nprivate:\n    T value;\n    static T pow(const T p, const T n) { return p < 0 ? pow(mod + p, n) : n == 0 ? 1 : n % 2 == 1 ? pow(p, n - 1) * p % mod : pow(p * p % mod, n / 2); }\n    static T inv(const T p) { return pow(p, mod - 2); }\n\npublic:\n    ModInt() : value{0} {}\n    ModInt(const T val) : value{((val % mod) + mod) % mod} {}\n    ModInt(const ModInt<T, mod>& n) : value{n()} {}\n    ModInt<T, mod>& operator=(const ModInt<T, mod>& n) { return value = n(), (*this); }\n    ModInt<T, mod>& operator=(const T v) { return value = (mod + v % mod) % mod, (*this); }\n    ModInt<T, mod> operator+() const { return *this; }\n    ModInt<T, mod> operator-() const { return ModInt{mod - value}; }\n    ModInt<T, mod> operator+(const ModInt<T, mod>& val) const { return ModInt{value + val()}; }\n    ModInt<T, mod> operator-(const ModInt<T, mod>& val) const { return ModInt{value - val() + mod}; }\n    ModInt<T, mod> operator*(const ModInt<T, mod>& val) const { return ModInt{value * val()}; }\n    ModInt<T, mod> operator/(const ModInt<T, mod>& val) const { return ModInt{value * inv(val())}; }\n    ModInt<T, mod>& operator+=(const ModInt<T, mod>& val) { return (((value += val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const ModInt<T, mod>& val) { return (((value -= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const ModInt<T, mod>& val) { return (((value *= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const ModInt<T, mod>& val) { return (((value *= inv(val())) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod> operator+(const T val) const { return ModInt{value + val}; }\n    ModInt<T, mod> operator-(const T val) const { return ModInt{value - val}; }\n    ModInt<T, mod> operator*(const T val) const { return ModInt{value * val}; }\n    ModInt<T, mod> operator/(const T val) const { return ModInt{value * inv(val)}; }\n    ModInt<T, mod>& operator+=(const T val) { return (((value += val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const T val) { return (((value -= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const T val) { return (((value *= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const T val) { return (((value *= inv(val)) %= mod) += mod) %= mod, (*this); }\n    bool operator==(const ModInt<T, mod>& val) const { return value == val.value; }\n    bool operator!=(const ModInt<T, mod>& val) const { return not(*this == val); }\n    bool operator==(const T val) const { return value == (mod + val % mod) % mod; }\n    bool operator!=(const T val) const { return not(*this == val); }\n    T operator()() const { return value; }\n};\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator+(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator-(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{-n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator*(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() * val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator/(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>(val) / n; }\ntemplate <typename T, T mod>\ninline bool operator==(const T val, const ModInt<T, mod>& n) { return n == val; }\ntemplate <typename T, T mod>\ninline bool operator!=(const T val, const ModInt<T, mod>& n) { return not(val == n); }\ntemplate <typename T, T mod>\ninline std::istream& operator>>(std::istream& is, ModInt<T, mod>& n)\n{\n    T v;\n    return is >> v, n = v, is;\n}\ntemplate <typename T, T mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<T, mod>& n) { return (os << n()); }\nusing mint = ModInt<int, MOD<int>()>;\nusing mll = ModInt<ll, MOD<ll>()>;\nconstexpr int MOD2 = 998244353;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<ModInt<int, 2>> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<int> bp(600, 1);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2 % MOD2; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD2) % MOD2 << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 998244353\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint H, W;\nint A[302][302];\n\nint main()\n{\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) scanf(\"%d\", &(A[i][j]));\n\t}\n\tint piv = 0;\n\tfor (int i = 0; i < W; ++i) {\n\t\tint r = -1;\n\t\tfor (int j = piv; j < H; ++j) {\n\t\t\tif (A[j][i] == 1) {\n\t\t\t\tr = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (r == -1) continue;\n\t\tif (r != piv) for (int j = 0; j < W; ++j) swap(A[r][j], A[piv][j]);\n\t\tfor (int j = 0; j < H; ++j) if (j != piv && A[j][i] == 1) {\n\t\t\tfor (int k = i; k < W; ++k) A[j][k] ^= A[piv][k];\n\t\t}\n\t\t++piv;\n\t}\n\ti64 ret = 1;\n\tfor (int i = 0; i < H; ++i) ret = ret * 2 % MOD;\n\ti64 sub = 1;\n\tfor (int i = 0; i < (H - piv); ++i) sub = sub * 2 % MOD;\n\tret += MOD - sub;\n\tret %= MOD;\n\tfor (int i = 0; i < W - 1; ++i) ret = ret * 2 % MOD;\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll Ten(int n){\n\treturn n==0?1:Ten(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tstatic constexpr int base=mod;\n\tint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\tv=vv%mod;\n\t\tif(v<0)v+=mod;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt(0)-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\tv+=rhs.v;\n\t\tif(v>=mod)v-=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\tv-=rhs.v;\n\t\tif(v<0)v+=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ll(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\toperator*=(rhs.inv());\n\t\treturn *this;\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\ntemplate<int mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<int mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n\n//using mint=ModInt<1000000007>;\nusing mint=ModInt<998244353>;\n\nconst int Vmax=2000010;\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\nsigned main(){\n\tint n=read(),m=read();\n\tvector<vi> a(n,vi(m,0));\n\tREP(i,n){\n\t\tREP(j,m)\n\t\t\ta[i][j]=read();\n\t}\n\tint ker=0;\n\tREP(i,n){\n\t\tint p=-1;\n\t\tREP(j,m){\n\t\t\tif(a[i][j])\n\t\t\t\tp=j;\n\t\t}\n\t\tif(p==-1)\n\t\t\tker++;\n\t\telse{\n\t\t\tFOR(k,i+1,n)if(a[k][p]){\n\t\t\t\tREP(j,m)\n\t\t\t\t\ta[k][j]^=a[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tprint((mint(2).pow(n)-mint(2).pow(ker))*mint(2).pow(m-1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main () {\n  int temp, odd, even;\n  int m, n;\n  cin >> m >> n;\n  vector<vector<int>> scount;\n  scount.push_back(vector<int> (n + 1, 0));\n  for (int i = 0; i < m; i++) {\n    vector<int> sc(1, 0);\n    for (int j = 0; j < n; j++) {\n      cin >> temp;\n      sc.push_back(scount[i][j] - scount[i][j - 1]  + sc[j] + temp);\n    }\n    scount.push_back(sc);\n  }\n  odd = even = 0;\n  \n  for (int i = 1; i < scount.size(); i++)\n    for (int j = 1; j < scount[i].size(); j++) {\n      if (scount[i][j] % 2 == 0)\n        even++;\n  \t  else\n        odd++;\n    }\n  \n  cout << ((even % 998244353) * (odd % 998244353) + odd) % 998244353;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MOD 998244353\n#define MAX 350\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint fpow(int a,int b)\n{\n\tint s=1;\n\twhile(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}\n\treturn s;\n}\nint n,m,tot,a[MAX][MAX],s[MAX];\nint p[MAX][MAX];bool vis[MAX];\nvoid Insert(int x)\n{\n\tfor(int i=1;i<=m;++i)\n\t\tif(a[x][i])\n\t\t{\n\t\t\tif(vis[i])\n\t\t\t{\n\t\t\t\tfor(int j=1;j<=m;++j)a[x][j]^=p[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++tot;vis[i]=true;\n\t\t\tfor(int j=1;j<=m;++j)p[i][j]=a[x][j];\n\t\t}\n}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=m;++j)\n\t\t\ts[i]+=(a[i][j]=read());\n\tfor(int i=1;i<=n;++i)Insert(i);\n\tint ans=1ll*(fpow(2,n)-fpow(2,n-tot)+MOD)*fpow(2,m-1)%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VVI a(n, VI(m));\n    REP(i,n) REP(j,m) a[i][j] = in();\n\n    int sum = 0;\n    REP(i,n) REP(j,m) sum ^= a[i][j];\n\n    VI si(n), sj(m);\n    REP(i,n) REP(j,m){\n        si[i] ^= a[i][j];\n        sj[j] ^= a[i][j];\n    }\n\n    VVI dpi(n + 1, VI(2)), dpj(m + 1, VI(2));\n    dpi[0][0] = dpj[0][0] = 1;\n    REP(i,n) REP(j,2){\n        dpi[i + 1][j] += dpi[i][j];\n        (dpi[i + 1][j ^ si[i]] += dpi[i][j]) %= mod;\n    }\n    REP(i,m) REP(j,2){\n        dpj[i + 1][j] += dpj[i][j];\n        (dpj[i + 1][j ^ sj[i]] += dpj[i][j]) %= mod;\n    }\n\n    ll ans = 0;\n    REP(i,2) REP(j,2){\n        if ((i ^ j ^ sum) == 1) ans = (ans + divll(dpi[n][i] * dpj[m][j], 2)) % mod;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#include <random>\n#include <iomanip>\n#include <bitset>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 998244353;\nconstexpr long double eps = 1e-6;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << v[i];\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 1010101\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n \nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nusing ld = long double;\n\nint mat_rank(vector<vector<int>>& a) {\n    int n = (int)a.size(), m = (int)a[0].size();\n    int ret = 0;\n    vector<bool> used(n, false);\n    REP(j, m) {\n        REP(i, n) {\n            if(used[i]) continue;\n            if(a[i][j]) {\n                ret++;\n                used[i] = true;\n                REP(k, n) {\n                    if(used[k]) continue;\n                    if(a[k][j] == 0) continue;\n                    REP(l, m) a[k][l] ^= a[i][l];\n                }\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> a(n, vector<int>(m));\n    REP(i, n) REP(j, m) cin >> a[i][j];\n    int r = mat_rank(a);\n    mi ans = (mod_pow(2, m) - mod_pow(2, m - r)) * mod_pow(2, n - 1);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Author: isaf27 (Ivan Safonov)\n*/\n\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int dxt[6] = {0, 0, -1, -1, 1, 1};\nconst int dyt[6] = {-2, 2, 1, -1, -1, 1};\nconst int alf = 26;\nconst int dig = 10;\nconst int two = 2;\nconst int th = 3;\nconst ll prost = 239;\nconst ll bt = 30;\nconst ld eps = 1e-8;\nconst ll INF = 1e18 + 239;\nconst int BIG = 1e9 + 239;\nconst int MOD = 998244353; //1e9 + 7; //;\nconst ll MOD2 = (ll)MOD * (ll)MOD;\n\n//random\nmt19937 rnd(239); //rnd(chrono::high_resolution_clock::now().time_since_epoch().count())\n\n//constants\nconst int M = 2e5 + 239;\nconst int N = 2e3 + 239;\nconst int L = 20;\nconst int T = (1 << 20);\nconst int B = trunc(sqrt(M)) + 1;\nconst int X = 310;\n\nint n, m;\nbitset<X> a[X];\nbool used[X];\n\nint32_t main()\n{\n    #ifdef ONPC\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n        {\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    int pr = 1;\n    for (int x = 0; x < m; x++)\n    {\n        int t = -1;\n        for (int i = 0; i < n; i++)\n            if (!used[i] && a[i][x])\n            {\n                t = i;\n                break;\n            }\n        if (t == -1)\n        {\n            pr = (pr * 2) % MOD;\n            continue;\n        }\n        used[t] = true;\n        for (int i = 0; i < n; i++)\n            if (!used[i] && a[i][x])\n                a[i] ^= a[t];\n    }\n    int ans = 1;\n    for (int i = 0; i < m; i++)\n        ans = (ans * 2) % MOD;\n    ans -= pr;\n    if (ans < 0) ans += MOD;\n    for (int i = 0; i < n - 1; i++)\n        ans = (ans * 2) % MOD;\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nostream &operator<<(ostream &os, const pint &a) { os << \"(\" << a.fi << \",\" << a.se << \")\"; return os; }\nostream &operator<<(ostream &os, const vector<int> &a) {\n\tos<<\"[\";\n\trep(i,a.size()){\n\t\tos<<a[i];\n\t\tif(i<a.size()-1) os<<\",\";\n\t}\n\tos<<\"]\";\n\treturn os; \n}\nvector<vector<int> > mat;\nint ma[334][334];\nlint mo=998244353;\nlint zyo(lint x,lint y){\n    lint ret=1,a=x;\n    while(y>0){\n    \tif(y%2==1) ret=(ret*a)%mo;\n    \ta=(a*a)%mo;y/=2;\n    }\n    return ret;\n}\nint main()\n{\n\tmemset(ma,0,sizeof(ma));\n\tint n,m;\n\tcin>>n>>m;\n\trep(i,n) rep(j,m) cin>>ma[i][j];\n\tif(n<m){\n\t\trep(i,m) REP(j,i+1,m) swap(ma[i][j],ma[j][i]);\n\t\tswap(n,m);\n\t}\n\trep(i,n){\n\t\tvector<int> cl(m,0);\n\t\tmat.pb(cl);\n\t\trep(j,m) mat[i][j]=ma[i][j]%2;\n\t}\n\t//rep(i,n) cout<<mat[i]<<endl;\n\t//rep(i,n) rep(j,m) mat[i][j]%=2;\n\tint rank=0;\n\trep(i,m){\n\t\t//if(rank>=m) continue;\n\t\tREP(j,rank,n){\n\t\t\tif(mat[j][i]>0) swap(mat[j],mat[rank]);\n\t\t}\n\t\tif(mat[rank][i]<1){\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,n){\n\t\t\tif(mat[j][i]==mat[rank][i]) continue;\n\t\t\trep(k,m){\n\t\t\t\tmat[j][k]+=mat[rank][k];mat[j][k]%=2;\n\t\t\t}\n\t\t}\n\t\trank++;\n\t}\n\t//cout<<n<<m<<rank<<endl;\n\t//lint zyo=1;rep(i,rank) zyo=(zyo*2)%mo;zyo--;\n\tlint out=zyo(2,rank);out--;\n\tout*=zyo(2,m-1);out%=mo;\n\tout*=zyo(2,n-rank);out%=mo;\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=998244353;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst double EPS=1E-8;//小さい数\nint mat_rank(mat A) {\n    int N = A.size(), M = A[0].size();\n    int res = 0;\n    for(int i=0; i<M; i++) {\n        // 絶対値が最も大きいものを探す\n        double max_elem = 0; int piv = -1;\n        for(int j=res; j<N; j++) {\n            if(abs(A[j][i]) > max_elem) {\n                max_elem = abs(A[j][i]);\n                piv = j;\n            }\n        }\n        if(piv < 0) continue;\n        swap(A[res], A[piv]);\n        /*for(int k=0; k<M; k++) {\n            A[res][k] = (1.0 * A[res][k] / A[res][i]);\n        }*/\n        for(int j=0; j<N; j++) {\n            if(j == res) continue;\n            int mul = A[j][i];\n            for(int k=0; k<M; k++) {\n                A[j][k] = ((A[j][k] - mul * A[res][k])%2+2)%2;\n            }\n        }\n        res++;\n    }\n    return res;\n}\nll mod_pow(ll x, ll n, ll mod){\n    if (n==0) return 1;\n    ll res=mod_pow(x*x%mod, n/2, mod);\n    if (n%2==1) res=res*x%mod;\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N,M;\n    cin>>N>>M;\n    mat a(N,vec(M,0));\n    rep(i,0,N){\n        rep(j,0,M){\n            cin>>a[i][j];\n        }\n    }\n    cout <<(mod_pow(2LL, N+M-1, MOD)-mod_pow(2LL, N+M-1-mat_rank(a), MOD)+MOD)%MOD<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = 305, mod = 998244353;\nint n, m, pow2[N << 1];\nvector< bitset<N> > basis;\n\nvoid updBasis(bitset<N> val) {\n    for (auto _ : basis) {\n        int f_ = -1;\n        for (int i = 0; i < N; ++i) if (_[i]) f_ = i;\n        int fVal = -2;\n        for (int i = 0; i < N; ++i) if (_[i]) fVal = i;\n        if (f_ == fVal) val ^= _;\n    }\n    if (val.count() ) basis.push_back(val);\n}\n\nint add(int _a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n    return _a;\n}\nint sub(int _a, int _b) { return add(_a, mod - _b); }\nint mul(int _a, int _b) { return (int)( (ll)_a * _b % mod); }\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        bitset<N> val;\n        for (int j = 1; j <= m; ++j) {\n            int a; cin >> a;\n            val[j] = a;\n        }\n        updBasis(val);\n    }\n\n    pow2[0] = 1; for (int i = 1; i < (N << 1); ++i) pow2[i] = (int)(2 * pow2[i - 1] % mod);\n\n    cout << sub(pow2[n + m - 1], pow2[n + m - 1 - (int)basis.size()]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\n\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\n\ntemplate <typename T> constexpr bool chmax(T &a, const T b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nconstexpr int MAX_ROW = 510;\nconstexpr int MAX_COL = 510;\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL> &operator[](const int &i) { return val[i]; }\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    rep(col, A.W) {\n        if(is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        rep(row, A.H) {\n            if(A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if(pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        rep(row, A.H) if(row != rank && A[row][col]) A[row] ^= A[rank];\n        rank++;\n    }\n    return rank;\n}\n\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt &p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt &p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt &p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt &p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt &p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt &p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt &p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(const int64_t &n) const {\n        ModInt ret(1), mul(x);\n        int64_t k = n % (M - 1);\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n, m;\n    cin >> n >> m;\n    BitMatrix A(n, m);\n    rep(i, n) rep(j, m) {\n        int a;\n        cin >> a;\n        if(a) A[i].set(j);\n    }\n    int r = GaussJordan(A);\n\n    using modint = ModInt<Mod>;\n    modint m2(2);\n    cout << m2.pow(n + m - 1) - m2.pow(n + m - r - 1) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nbitset <333> a[333];\nint n, m;\nconst int mod = 998244353;\nlong long pw[333];\n\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%d %d\", &n, &m);\n\tpw[0] = 1;\n\tfor(int i = 1; i <= max(n, m); i++) {\n\t\tpw[i] = pw[i - 1] * 2;\n\t\tpw[i] %= mod;\n\t} \n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\ta[i][j] = x;\n\t\t}\n\t}\n\tint ptr = 0;\n\tfor(int j = 0; j < m; j++) {\n\t\tfor(int i = ptr; i < n; i++) {\n\t\t\tif(a[i][j] == 1) {\n\t\t\t\tswap(a[ptr], a[i]);\n\t\t\t\tfor(int x = 0; x < n; x++) {\n\t\t\t\t\tif(x != ptr && a[x][j] == 1) {\n\t\t\t\t\t\ta[x] ^= a[ptr];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlong long res = pw[m-1] * (pw[n] - pw[n - ptr]);\n\tres %= mod;\n\tif(res < 0) res += mod;\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"out2.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n#define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \n// void bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid amax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid amin(T& x, T y) {\n    x = min(x, y);\n}\n\n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-12;\nconst int maxn = 5e4 + 3, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst int base2 = 998244353;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % base2;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % base2;\n    }\n}\n\nconst int N = 305;\n\nint gauss (vector < bitset<N> > a, int n, int m) {    \n    int rank = max(n, m);\n    vector<char> line_used (n);\n    for (int i=0; i<m; ++i) {\n        int j;\n        for (j=0; j<n; ++j)\n            if (!line_used[j] && a[j][i])\n                break;\n        if (j == n)\n            --rank;\n        else {\n            line_used[j] = true;\n            for (int k=0; k<n; ++k)\n                if (k != j && a[k][i])\n                    a[k] ^= a[j];\n                    // for (int p=i+1; p<m; ++p)\n                    //     a[k][p] ^= a[j][p] * a[k][i];\n        }\n    }\n    return rank;\n}\n\nint main() {\n    // files1;\n\n    int n, m;\n    cin >> n >> m;\n    vector<bitset<N> > a(n);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            bool x;\n            cin >> x;\n            a[i][j] = x;\n        }\n\n    int r = gauss(a, n, m);\n    cout << ((binpow(2, n + m - 1) - binpow(2, n + m - r - 1)) % base2 + base2) % base2;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define mp make_pair\n\nvoid print(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cout<<a[i]<<' ';\n    cout<<endl;\n}\n\nvoid get(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cin>>a[i];\n}\n\nconst ll p = 998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    s = s%p;\n    if (s<0) s+=p; \n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    \n    int n, m;\n    cin>>n>>m;\n    \n    vector<bitset<320>> a(n);\n    \n    bool t;\n    \n    for (int i = 0; i<n; i++)\n    for (int j = 0; j<m; j++) {cin>>t; a[i][j] = t;}\n    \n    vector<bool> visited(n);\n    \n    int degbasis = 0;\n    \n    for (int i = 0; i<m; i++)\n    {\n        int idx = 0;\n        while (idx<n && !(a[idx][i]==1&&!visited[idx])) idx++;\n        if (idx==n) continue;\n        visited[idx] = true;\n        degbasis++;\n        for (int i = 0; i<n; i++) if (i!=idx) a[i]^=a[idx];\n    }\n    \n    //cout<<degbasis<<endl;\n    \n    int total = po(2, m+n - 1);\n    //cout<<total<<endl;\n    total=add(total, -po(2, m+n-1-degbasis));\n    if (total<0) total+=p;\n    cout<<total;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\nusing BS=bitset<333>;\n\nBS a[333];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,m;\n\tcin>>n>>m;\n\trep(i,n){\n\t\ta[i].reset();\n\t\trep(j,m){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x) a[i][j]=1;\n\t\t}\n\t}\n\tint o=0;\n\trep(j,m){\n\t\tint tmp=-1;\n\t\treps(i,o,n)if(a[i][j]){\n\t\t\ttmp=i; break;\n\t\t}\n\t\tif(tmp<0) continue;\n\t\tif(o!=tmp) swap(a[o],a[tmp]);\n\t\trep(i,n)if(i!=o && a[i][j]) a[i]^=a[o];\n\t\t++o;\n\t}\n\t// rep(i,n){rep(j,m) cout<<a[i][j];cout<<endl;}\n\tmint ker=1;\n\tint t=0;\n\trep(i,n)if(a[i].count()==0) ker+=ker, ++t;\n\tassert(t+o==n);\n\tout(ker,1);\n\tmint re=modpow(mint(2),m-1);\n\tcout<<re*(modpow(2,n)-ker)<<endl;\n\t// cout<<(1ll<<4)*((1ll<<5)-1)%MOD<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void wri(ll a){write(a); putchar(' ');}\ninline void writeln(ll a){write(a); puts(\"\");}\nconst int N=300,mod=998244353;\nint get(int n){\n\tint ans=1;\n\tfor(int i=1;i<=n;i++)ans=ans*2%mod;\n\treturn ans;\n}\nbitset<N> s[N];\nsigned main(){\n\tint n=read(),m=read();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++)s[i][j]=read();\n\t}\n\tint rk=0;\n\tfor(int i=0,j=0;i<m;i++){\n\t\tfor(int k=j;k<n;k++)if(s[k][i]){swap(s[k],s[j]); break;}\n\t\tif(!s[j][i])continue; else rk++;\n\t\tfor(int k=j+1;k<n;k++)if(s[k][i])s[k]^=s[j];\n\t\tj++;\n\t}\n\tint ans=get(n)-get(n-rk);\n\tcout<<(ll)ans*get(m-1)<<endl;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YESNO OUT(three(solve(),\"YES\",\"NO\"))\n#define YesNo OUT(three(solve(),\"Yes\",\"No\"))\n#define WL(A,B) OUT(three(solve(),A,B))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(b);i>=(LL)(a);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n#define all ALL\n#define pb emplace_back\n#define eb pb\n#define int long long\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntemplate<class T> inline bool chmax(int a, int b, T c, T d) { return c > d ? a : b; }\ntemplate<class T> inline bool chmin(int a, int b, T c, T d) { return c > d ? a : b; }\ntypedef int LL;\ntypedef double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef tuple<int, int, int, int> tapu;\ntypedef vector<tapu> Vtapu;\ntypedef priority_queue<ut, VI, greater<LL> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 1e6 + 1000;\nconst int SIZE2 = 4010;\nconst int SIZE3 = 430;\nconst int SIZE = SIZE1;\nconst int MAPSIZE = 40;\nconst LL p =998244353;\nconst LL INF = 1LL << 30;\nconst long double EPS = 1e-7;\nconst LL inf = 1000000000;\ntypedef pair<ld, ut> pld;\nut N, M, K, L, Q,  H, W, R;\nVI edges[SIZE];\nLL vals[SIZE], answer = zero;\n//LL maps[SIZE2][SIZE2];\nLL A[SIZE3][SIZE3],B[SIZE],C[SIZE],D[SIZE],E[SIZE];\nLL def = 0;\nvoid rev(int a) {\n\tREP(i, W) {\n\t\tdef ^= A[a][i];\n\t\tA[a][i] ^= 1;\n\t}\n}\nvoid xors(int a, int b) {\n\tREP(i, W)\n\t\tA[a][i] ^= A[b][i];\n}\nvoid swaps(int a, int b) {\n\tREP(i, W)\n\t\tswap(A[a][i], A[b][i]);\n}\nLL power(LL x) {\n\tLL ans = 1;\n\tREP(i, x) ans = ans * 2 % p;\n\treturn ans;\n}\nLL solve() {\n\tcin >> H >> W;\n\tREP(i, H) REP(j, W) {\n\t\tcin >> A[i][j];\n\t}\n\tLL ans = 0,rank=0;\n\tREP(j, W) {\n\t\tFOR(i,j,H) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tswaps(i, j);\n\t\t\t\tFOR(k, j + 1, H) {\n\t\t\t\t\tif (A[k][j]) xors(k, j);\n\t\t\t\t}\n\t\t\t\trank++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (power( H + W - 1) % p - power(H+W-rank-1) % p + p) % p;\n\t//return ;\n}\n\n\n\n\n//!!!!!!!!!!!!!!!!!!!実装を詰める!!!!!!!!!!!!!!!!!!!!!!!!!\nsigned main() {\n\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(0);\n\tcout << solve() << endl;\n\t\n\t//cin >> N;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nconstexpr int MOD = 998244353;\nstd::size_t N, M;\ntemplate <typename T>\nstd::size_t Rank(std::vector<std::vector<T>> mat)\n{\n    std::size_t r = 0;\n    for (std::size_t c = 0; c < M; c++) {\n        if (r == N) { break; }\n        std::size_t piv = r;\n        for (; piv < N and mat[piv][c] == 0; piv++) {}\n        if (piv == N) { continue; }\n        std::swap(mat[r], mat[piv]);\n        const T p = mat[r][c];\n        for (std::size_t i = r; i < N; i++) { mat[i][c] /= p; }\n        for (std::size_t j = 0; j < M; j++) {\n            if (j == c) { continue; }\n            const T p = mat[r][j];\n            for (std::size_t i = 0; i < N; i++) { mat[i][j] -= mat[i][c] * p; }\n        }\n        r++;\n    }\n    return r;\n}\n\nint main()\n{\n    std::cin >> N >> M;\n    std::vector<std::vector<int>> a(N, std::vector<int>(M));\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<int> bp(600, 1);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2 % MOD; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD) % MOD << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\ntypedef long long LL;\ntemplate <typename F, typename S> std::ostream& operator<<(ostream& os, const pair<F,S>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\"; for(const T& a: v){ os << a << \", \"; } os << \"]\"; return os; }\ntemplate <typename K, typename V> ostream& operator<<(ostream& os, const map<K,V>& m) {\n    os << \"{\"; for(const auto& p: m){ os << p.first <<\":\"<< p.second << \", \"; } os << \"]\"; return os; }\n\nconst LL MOD=998244353;\nLL pow2(LL base, LL cnt){\n    for(LL i = 0; i < cnt; ++i){\n        base = (base*2) % MOD;\n    }\n    return base;\n}\n\nint main(){\n    LL n, m;\n    cin >> n >> m;\n    vector<vector<LL>> a(n, vector<LL>(m, 0));\n    for(LL i = 0; i < n; ++i){\n        for(LL j = 0; j < m; ++j){\n            cin >> a[i][j];\n        }\n    }\n    LL cnt = 0;\n    for(LL i = 0; i < n; ++i){\n        bool check = false;\n        if(accumulate(a[i].begin(), a[i].end(), 0) == 0) check=true;\n        for(LL j = i+1; j < n; ++j){\n            if(a[i] == a[j]){\n                check = true;\n                break;\n            }\n        }\n        if(check){\n            cnt += 1;\n        }else{\n            for(LL j = i+1; j < n; ++j){\n                for(LL k = 0; k < m; ++k){\n                    a[j][k] = (a[j][k] + a[i][k]) % 2;\n                }\n            }\n        }\n    }\n\n    cerr << \"cnt=\" << cnt << endl;\n    LL base = pow2(1, m+n-1);\n    LL part = pow2(1, m+cnt-1);\n    LL ans = (base + MOD - part) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=310;\nconst int mod=998244353;\nbitset<MAXN>a[MAXN],b[MAXN];\nint n,m,x;\nlong long poww(long long x,long long y)\n{\n\tlong long ans=1;\n\tfor (;y;y>>=1,x=(x*x)%mod) if (y&1) ans=(ans*x)%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\tfor (int j=1;j<=m;j++) \n\t{\n\t\tscanf(\"%d\",&x);\n\t\tif (x==1) a[i].set(j);\n\t}\n\t}\n    for (int i=1;i<=n;i++)\n    {\n    \tfor (int j=1;j<=m;j++) \n    \t\tif (!b[j].any()) {\n    \t\t\tb[j]=a[i]; break;\n    \t\t}\n    \t\telse a[i]^=b[j];\n    }\n    int ans=0;\n    for (int i=1;i<=n;i++) \n    \t if (!b[i].any()) ans++;\n    cout << (poww(2,n)-poww(2,ans)+mod)%mod*poww(2,m-1)%mod << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MOD 998244353\n\nusing namespace std;\n\nlong long map[301][2][2]; // col, usedrow_mod2, sum_mod2\nint N, M;\nint a[300][300];\n\nvoid search(int col, int* mask) {\n    map[col][0][0] = 0;\n    map[col][0][1] = 0;\n    map[col][1][0] = 0;\n    map[col][1][1] = 0;\n    if (col == M-1) {\n        // backtrack\n        // use this col\n        for (int i=0; i<N; i++) {\n            if (mask[i] == 0) continue;\n            if (a[col][i] == 1) {\n                // use\n                map[col][0][0] += map[col+1][1][1];\n                map[col][0][1] += map[col+1][1][0];\n                map[col][1][0] += map[col+1][0][1];\n                map[col][1][1] += map[col+1][0][0];\n                // no use\n                map[col][0][0] += map[col+1][0][0];\n                map[col][0][1] += map[col+1][0][1];\n                map[col][1][0] += map[col+1][1][0];\n                map[col][1][1] += map[col+1][1][1];\n            } else {\n                // use\n                map[col][0][0] += map[col+1][1][0];\n                map[col][0][1] += map[col+1][1][1];\n                map[col][1][0] += map[col+1][0][0];\n                map[col][1][1] += map[col+1][0][1];\n                // no use\n                map[col][0][0] += map[col+1][0][0];\n                map[col][0][1] += map[col+1][0][1];\n                map[col][1][0] += map[col+1][1][0];\n                map[col][1][1] += map[col+1][1][1];\n            }\n            map[col][0][0] %= MOD;\n            map[col][0][1] %= MOD;\n            map[col][1][0] %= MOD;\n            map[col][1][1] %= MOD;\n        }\n        // wont use this col\n        for (int i=0; i<N; i++) {\n            if (mask[i] == 0) continue;\n            // use\n            map[col][0][0] += map[col+1][1][0];\n            map[col][0][1] += map[col+1][1][1];\n            map[col][1][0] += map[col+1][0][0];\n            map[col][1][1] += map[col+1][0][1];\n            // no use\n            map[col][0][0] += map[col+1][0][0];\n            map[col][0][1] += map[col+1][0][1];\n            map[col][1][0] += map[col+1][1][0];\n            map[col][1][1] += map[col+1][1][1];\n\n            map[col][0][0] %= MOD;\n            map[col][0][1] %= MOD;\n            map[col][1][0] %= MOD;\n            map[col][1][1] %= MOD;\n        }\n        return;\n    }\n\n    int one_mask[300] = {0};\n    int zero_mask[300] = {0};\n    for (int i=0; i<N; i++) {\n        if (mask[i] == 0)continue;\n        if (a[col][i] == 1) one_mask[i] = 1;\n        else zero_mask[i] = 1;\n    }\n    search(col+1, one_mask);\n    // now map[col+1][:][:] has one_mask data\n    // use this col\n    map[col][0][0] = map[col+1][0][0];\n    map[col][0][1] = map[col+1][0][1];\n    map[col][1][0] = map[col+1][1][1];\n    map[col][1][1] = map[col+1][1][0];\n    // no use\n    map[col][0][0] += map[col+1][0][0];\n    map[col][0][1] += map[col+1][0][1];\n    map[col][1][0] += map[col+1][1][0];\n    map[col][1][1] += map[col+1][1][1];\n\n    map[col][0][0] %= MOD;\n    map[col][0][1] %= MOD;\n    map[col][1][0] %= MOD;\n    map[col][1][1] %= MOD;\n\n\n    search(col+1, zero_mask);\n    map[col][0][0] += map[col+1][0][0];\n    map[col][0][1] += map[col+1][0][1];\n    map[col][1][0] += map[col+1][1][0];\n    map[col][1][1] += map[col+1][1][1];\n\n    map[col][0][0] %= MOD;\n    map[col][0][1] %= MOD;\n    map[col][1][0] %= MOD;\n    map[col][1][1] %= MOD;\n    // no use\n    map[col][0][0] += map[col+1][0][0];\n    map[col][0][1] += map[col+1][0][1];\n    map[col][1][0] += map[col+1][1][0];\n    map[col][1][1] += map[col+1][1][1];\n\n    map[col][0][0] %= MOD;\n    map[col][0][1] %= MOD;\n    map[col][1][0] %= MOD;\n    map[col][1][1] %= MOD;\n}\n    \nint first_mask[300];\nint main() {\n    cin >> N >> M;\n    map[M][0][0] = 1;\n    //map[M][1][0] = 1;\n    //map[M][0][1] = 1;\n    //map[M][1][1] = 1;\n    for (int i=0; i<N; i++) {\n        for (int j=0; j<M; j++) cin >> a[i][j];\n    }\n    for (int i=0; i<N; i++) first_mask[i] = 1;\n\n    search(0, first_mask);\n    cout << (map[0][0][1] + map[0][1][1]) % MOD << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst LL mod=998244353;\nLL n,m,a[310][310],cnt=0;\nLL c[310][310];\nLL Pow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&m);\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tfor(LL j=1;j<=m;j++) scanf(\"%lld\",&a[i][j]);\n\t\tfor(LL j=1;j<=m;j++)\n\t\t{\n\t\t\tif(!a[i][j]) continue;\n\t\t\tif(!c[j][j])\n\t\t\t{\n\t\t\t\tfor(LL k=j;k<=m;k++) c[j][k]=a[i][k];\n\t\t\t\tcnt++;break;\n\t\t\t}\n\t\t\telse for(LL k=j;k<=m;k++) a[i][k]^=c[j][k];\n\t\t}\n\t}\n\tprintf(\"%lld\",(Pow(2,n)-Pow(2,n-cnt)+mod)%mod*Pow(2,m-1)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "//行・列基本変形しても答えが変わらないというギャグ。\n//ランクrとすると、本質は(1, 1)をi箇所、{(0,0),(0,1),(1,0)}をr-i箇所作る問題。これは算数。\n#include <iostream>\n#include <vector>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef vector<int> Array;\ntypedef vector<Array> Mat;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn a * powmod(a, n - 1, mod) % mod;\n}\n\nint mod = 998244353;\nint fact[301];\nint finv[301];\n\nint comb(int n, int k) {\n\treturn fact[n] * finv[k] % mod * finv[n - k] % mod;\n}\n\nvoid henkei(Mat &a) {\n\tint h = a.size();\n\tint w = a[0].size();\n\t\n\tint i, j, k;\n\tint cor = 0;\n\t\n\trep(i, w) {\n\t\tfor (j = cor; j < h; j++) {\n\t\t\tif (a[j][i] == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == h) continue;\n\t\t\n\t\tint pos = j;\n\t\trep(j, w) {\n\t\t\tswap(a[cor][j], a[pos][j]);\n\t\t}\n\t\t\n\t\tfor (j = cor + 1; j < h; j++) {\n\t\t\tif (a[j][i] == 0) continue;\n\t\t\trep(k, w) {\n\t\t\t\ta[j][k] ^= a[cor][k];\n\t\t\t}\n\t\t}\n\t\tcor++;\n\t}\n}\n\nvoid tenti(Mat &a) {\n\tint h = a.size();\n\tint w = a[0].size();\n\tMat b(w, Array(h));\n\t\n\tint i, j;\n\trep(i, h) rep(j, w) b[j][i] = a[i][j];\n\ta = b;\n}\n\nint _rank(Mat &a) {\n\tint i;\n\trep(i, a.size()) {\n\t\tif (i >= a[0].size() || a[i][i] == 0) break;\n\t}\n\treturn i;\n}\n\nvoid print(Mat &a) {\n\tint h = a.size();\n\tint w = a[0].size();\n\tint i, j;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcout << a[i][j];\n\t\t\tif (j + 1 < w) cout << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tfact[0] = finv[0] = 1;\n\tfor (i = 1; i <= 300; i++) {\n\t\tfact[i] = i * fact[i - 1] % mod;\n\t\tfinv[i] = powmod(fact[i], mod - 2, mod);\n\t}\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tMat a(n, Array(m));\n\trep(i, n) rep(j, m) cin >> a[i][j];\n\thenkei(a);\n\ttenti(a);\n\thenkei(a);\n\tprint(a);\n\tint r = _rank(a);\n\tint ans = 0;\n\tfor (int i = 1; i <= r; i += 2) {\n\t\tans += comb(r, i) * powmod(3, r - i, mod) % mod;\n\t\tans %= mod;\n\t}\n\tans *= powmod(2, n + m - 2 * r, mod);\n\tans %= mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 998244353;\nint add(int &a, const int &b) {\n\ta = (a + b) % MOD;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M;\n\tcin >> N >> M;\n\tvector<vector<int> > A(N, vector<int>(M));\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\n\tint cur = 0;\n\tint t = -1;\n\tfor (int k = 0; k < M; k++) {\n\t\tt = -1;\n\t\tfor (int i = cur + 1; i < N; i++) {\n\t\t\tif (A[i][k] == 1) {\n\t\t\t\tt = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (t == -1)continue;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (t != i) {\n\t\t\t\tif (A[i][k] == 1) {\n\t\t\t\t\tfor (int j = k; j < M; j++) {\n\t\t\t\t\t\tA[i][j] ^= A[t][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(A[t], A[cur]);\n\t\tcur++;\n\t\tif (cur >= N)break;\n\t}\n\n\n\t//for (int i = 0; i < N; i++) {\n\t//\tfor (int j = 0; j < M; j++) {\n\t//\t\tcerr << A[i][j] << \" \";\n\t//\t}\n\t//\tcerr << endl;\n\t//}\n\n\n\t//int base = 1;\n\t//for (int i = 0; i < N; i++) {\n\t//\tint sum = 0;\n\t//\tfor (int j = 0; j < M; j++) {\n\t//\t\tsum += A[i][j];\n\t//\t}\n\t//\tif (sum == 0) {\n\t//\t\tswap(A[i], A.back());\n\t//\t\tA.pop_back();\n\t//\t\tN = A.size();\n\t//\t\tbase = (base * 2) % MOD;\n\t//\t}\n\t//}\n\n\t//for (int j = 0; j < M; j++) {\n\t//\tint sum = 0;\n\t//\tfor (int i = 0; i < N; i++) {\n\t//\t\tsum += A[i][j];\n\t//\t}\n\t//\tif (sum == 0) {\n\t//\t\tfor (int i = 0; i < N; i++) {\n\t//\t\t\tswap(A[i][j], A[i].back());\n\t//\t\t\tA[i].pop_back();\n\t//\t\t}\n\t//\t\tM = A[0].size();\n\t//\t\tbase = (base * 2) % MOD;\n\t//\t}\n\t//}\n\n\t/*cerr << N << \" \" << M << endl;\n\n\tif (N == 0 || M == 0) {\n\t\treturn 0;\n\t}\n*/\n\n\n\n\t//for (int i = 0; i < N; i++) {\n\t//\tfor (int j = 0; j < M; j++) {\n\t//\t\tcerr << A[i][j] << \" \";\n\t//\t}\n\t//\tcerr << endl;\n\t//}\n\n\tint X = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum += A[i][j];\n\t\t}\n\t\tif (sum > 0)X++;\n\t}\n\n\t//cerr << X << endl;\n\n\tres = 0;\n\tvector<vector<int> > dp(X + 1, vector<int>(X + 1, 0));\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= X; i++) {\n\t\tfor (int j = 0; j <= X; j++) {\n\t\t\tif (j > 0)add(dp[i][j], dp[i - 1][j - 1]);\n\t\t\tadd(dp[i][j], 3 * dp[i - 1][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= X; i += 2) {\n\t\tadd(res, dp[X][i]);\n\t}\n\n\tfor (int i = 0; i < N + M - X - X; i++) {\n\t\tres = (res * 2) % MOD;\n\t}\n\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <bitset>\n#define mod 998244353\n\ntypedef std::bitset<301> BS;\n\nBS d[301];\nBS a[301];\n\nint qpow(int x, int p)\n{\n\tint ans = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ans = 1ll * ans * x % mod;\n\t\tx = 1ll * x * x % mod; p >>= 1; \n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\ta[j][i] = x;\n\t\t}\n\tint cnt = 0;\n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = n; j >= 1; j--)\n\t\t{\n\t\t\tif(a[i][j] == 1)\n\t\t\t{\n\t\t\t\tif(!d[j][j]) d[j] = a[i], cnt++;\n\t\t\t\ta[i] ^= d[j];\n\t\t\t}\n\t\t}\n\tprintf(\"%lld\\n\", 1ll * qpow(2, n - 1) * (qpow(2, m) - qpow(2, m - cnt) + mod) % mod);\n}\n\n//对于一维的情况，如果有1，那么答案是2^(len-1)，否则为0\n//考虑选出某几列，如果把这几列中每一行的数字xor起来后有至少一行为1，那么就有2^(n-1)的贡献\n//把每一列看成一个数，题目转化成 问有多少个列的子集异或和不为0\n//考虑异或和为0的子集个数，构造线性基，那么对每个不在线性基中的数，都可以选或不选(加上几个在线性基中的数都能xor出0)\n//所以为2^(m-cnt)，cnt为在线性基中的数的个数\n//ans = 2 ^ (n-1) * (2 ^ m - 2 ^ (m-cnt) ) "
  },
  {
    "language": "C++",
    "code": "#pragma region kyopro_template\n#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x, v) for (auto &x : v)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ((int)(v).size())\n#define mem(a, val) memset(a, val, sizeof(a))\n#define ini(...)   \\\n  int __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inl(...)         \\\n  long long __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define ins(...)      \\\n  string __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inc(...)    \\\n  char __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define in2(s, t)                           \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i]);                         \\\n  }\n#define in3(s, t, u)                        \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i]);                   \\\n  }\n#define in4(s, t, u, v)                     \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i], v[i]);             \\\n  }\n#define rep(i, N) for (long long i = 0; i < (long long)(N); i++)\n#define repr(i, N) for (long long i = (long long)(N)-1; i >= 0; i--)\n#define rep1(i, N) for (long long i = 1; i <= (long long)(N); i++)\n#define repr1(i, N) for (long long i = (N); (long long)(i) > 0; i--)\nusing namespace std;\nvoid solve();\nusing ll = long long;\ntemplate <class T = ll>\nusing V = vector<T>;\nusing vi = vector<int>;\nusing vl = vector<long long>;\nusing vvi = vector<vector<int>>;\nusing vd = V<double>;\nusing vs = V<string>;\nusing vvl = vector<vector<long long>>;\nusing P = pair<long long, long long>;\nusing vp = vector<P>;\nusing pii = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nconstexpr int inf = 1001001001;\nconstexpr long long infLL = (1LL << 61) - 1;\ntemplate <typename T, typename U>\ninline bool amin(T &x, U y) {\n  return (y < x) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\ninline bool amax(T &x, U y) {\n  return (x < y) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\nll ceil(T a, U b) {\n  return (a + b - 1) / b;\n}\nconstexpr ll TEN(int n) {\n  ll ret = 1, x = 10;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x;\n    n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  int s = (int)v.size();\n  for (int i = 0; i < s; i++) os << (i ? \" \" : \"\") << v[i];\n  return os;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (auto &x : v) is >> x;\n  return is;\n}\nvoid in() {}\ntemplate <typename T, class... U>\nvoid in(T &t, U &... u) {\n  cin >> t;\n  in(u...);\n}\nvoid out() { cout << \"\\n\"; }\ntemplate <typename T, class... U>\nvoid out(const T &t, const U &... u) {\n  cout << t;\n  if (sizeof...(u)) cout << \" \";\n  out(u...);\n}\ntemplate <typename T>\nvoid die(T x) {\n  out(x);\n  exit(0);\n}\n\n#ifdef NyaanDebug\n#include \"NyaanDebug.h\"\n#define trc(...)                   \\\n  do {                             \\\n    cerr << #__VA_ARGS__ << \" = \"; \\\n    dbg_out(__VA_ARGS__);          \\\n  } while (0)\n#define trca(v, N)       \\\n  do {                   \\\n    cerr << #v << \" = \"; \\\n    array_out(v, N);     \\\n  } while (0)\n#define trcc(v)                             \\\n  do {                                      \\\n    cerr << #v << \" = {\";                   \\\n    each(x, v) { cerr << \" \" << x << \",\"; } \\\n    cerr << \"}\" << endl;                    \\\n  } while (0)\n#else\n#define trc(...)\n#define trca(...)\n#define trcc(...)\nint main() { solve(); }\n#endif\n\nstruct IoSetupNya {\n  IoSetupNya() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    cerr << fixed << setprecision(7);\n  }\n} iosetupnya;\n\ninline int popcount(unsigned long long a) { return __builtin_popcountll(a); }\ninline int lsb(unsigned long long a) { return __builtin_ctzll(a); }\ninline int msb(unsigned long long a) { return 63 - __builtin_clzll(a); }\ntemplate <typename T>\ninline int getbit(T a, int i) {\n  return (a >> i) & 1;\n}\ntemplate <typename T>\ninline void setbit(T &a, int i) {\n  a |= (1LL << i);\n}\ntemplate <typename T>\ninline void delbit(T &a, int i) {\n  a &= ~(1LL << i);\n}\ntemplate <typename T>\nint lb(const vector<T> &v, const T &a) {\n  return lower_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nint ub(const vector<T> &v, const T &a) {\n  return upper_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nvector<T> mkrui(const vector<T> &v) {\n  vector<T> ret(v.size() + 1);\n  for (int i = 0; i < int(v.size()); i++) ret[i + 1] = ret[i] + v[i];\n  return ret;\n};\ntemplate <typename T>\nvector<int> mkord(const vector<T> &v, function<bool(T, T)> f) {\n  vector<int> ord(v.size());\n  iota(begin(ord), end(ord), 0);\n  sort(begin(ord), end(ord), f);\n  return ord;\n}\ntemplate <typename T>\nvector<T> mkuni(const vector<T> &v) {\n  vector<T> ret(v);\n  sort(ret.begin(), ret.end());\n  ret.erase(unique(ret.begin(), ret.end()), ret.end());\n  return ret;\n}\n\n#pragma endregion\n\nconstexpr long long MOD = /** 1000000007;  //*/ 998244353;\n\ntemplate <size_t N>\nbitset<N> gcd(bitset<N> x, bitset<N> y) {\n  int xm = int(N) - 1, ym = int(N) - 1;\n  while (xm != -1 && x[xm] == 0) xm--;\n  while (ym != -1 && y[ym] == 0) ym--;\n  if (xm < ym) swap(x, y), swap(xm, ym);\n  while (ym >= 0) {\n    x ^= y << (xm - ym);\n    while (xm != -1 && x[xm] == 0) xm--;\n    while (ym != -1 && y[ym] == 0) ym--;\n    if (xm < ym) swap(x, y), swap(xm, ym);\n  }\n  return x;\n}\n\ntemplate <size_t MAX_H, size_t MAX_W>\nstruct BitMat {\n  int H, W;\n  bitset<MAX_W> a[MAX_H];\n  BitMat(int h, int w) : H(h), W(w) {}\n  inline bitset<MAX_W> &operator[](int i) { return a[i]; }\n};\n\ntemplate <size_t MAX_H, size_t MAX_W>\nint Gauss(BitMat<MAX_H, MAX_W> &A, bool is_greater = true,\n          bool is_extended = false) {\n  int rank = 0, H = A.H, W = (is_extended ? A.W - 1 : A.W);\n  for (int j = (is_greater ? W - 1 : 0); j != (is_greater ? -1 : W);\n       j += (is_greater ? -1 : 1)) {\n    for (int i = rank; i < H; i++) {\n      if (A[i][j] == 1) {\n        swap(A[rank], A[i]);\n        for (int k = 0; k < H; k++) {\n          if (k != rank && A[k][j]) A[k] ^= A[rank];\n        }\n        rank++;\n        break;\n      }\n    }\n  }\n  if (is_extended) {\n    for (int i = rank; i < H; i++)\n      if (A[i][W] == 1) return -1;\n  }\n  return rank;\n}\ntemplate <size_t MAX_H, size_t MAX_W>\nvoid OrthogonalComplement(BitMat<MAX_H, MAX_W> &A, int N) {\n  int rank = 0;\n  while (rank < N && A[rank].any()) rank++;\n  for (int i = 0; i < rank; i++) {\n    int j = A[i]._Find_first();\n    if (j != i)\n      for (int k = 0; k < rank; k++) {\n        int buf = A[k][i];\n        A[k][i] = A[k][j];\n        A[k][j] = buf;\n      }\n  }\n  for (int i = rank; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      A[i][j] = (j < rank ? A[j][i] : i == j);\n    }\n  }\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static constexpr int get_mod() { return mod; }\n};\nusing mint = ModInt<MOD>;\nusing vm = vector<mint>;\n\nvoid solve() {\n  using Mat = BitMat<501,501>;\n  ini(N,M);\n  Mat m(N,M);\n  rep(i,N)rep(j,M){ini(n);m[i][j]=n;}\n  int r=Gauss(m);\n  out(mint(2).pow(N+M-1)-mint(2).pow(N+M-1-r));\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\n#ifdef ONPC\n    mt19937 rnd(231);\n    mt19937_64 rndll(231);\n#else\n    mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n    mt19937_64 rndll(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nconst int Mod = 998244353;\n\nint Bpow(int x, ll y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 2e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 20;\n\nint q[300][300][2];\n\nint p[300][300];\n\nint a[300];\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    int ans = 0;\n    for (int i = 0; i < m; i++)\n        for (int j = i; j < m; j++)\n            q[i][j][0] = 1;\n    for (int its = 0; its < n; its++) {\n        for (int i = 0; i < m; i++)\n            cin >> a[i];\n        for (int i = 0; i < m; i++) {\n            int w = 0;\n            for (int j = i; j < m; j++) {\n                w ^= a[j];\n                p[i][j] ^= w;\n                ans = ad(ans, q[i][j][p[i][j] ^ 1]);\n                q[i][j][p[i][j]]++;\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    int N, M;\n    cin>>N>>M;\n    vector<vector<int>> a(N, vector<int>(M));\n    for (auto &l: a)\n        for (int &c: l)\n            cin>>c;\n\n    for (int i=0; i<N; i++)\n    {\n        int px = -1, py;\n        for (int j=0; j<M && px==-1; j++)\n            for (int k=i; k<N && px==-1; k++)\n                if (a[k][j] != 0)\n                    px = j,\n                    py = k;\n        if (px==-1)\n            break;\n        a[i].swap(a[py]);\n        for (int j=i+1; j<N; j++)\n            if (a[j][px] != 0)\n                for (int k=0; k<M; k++)\n                    a[j][k] ^= a[i][k];\n    }\n    int r = 0;\n    for (int i=0; i<N; i++)\n        for (int j=0; j<M; j++)\n            if (a[i][j] != 0)\n                r = i+1;\n\n    long long MOD = 998244353;\n\n    long long call = 1;\n    for (int i=0; i<M; i++)\n        call = call*2%MOD;\n    long long czero = 1;\n    for (int i=0; i<M-r; i++)\n        czero = czero*2%MOD;\n    long long rall = 1;\n    for (int i=0; i<N-1; i++)\n        rall = rall*2%MOD;\n    cout<<(call-czero+MOD)%MOD*rall%MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int Mx = 300;\nconst int mod = 998244353;\nll p2[Mx + 1];\n\ntypedef bitset<Mx> * It;\n\nbool bsLess(const bitset<Mx> &b1, const bitset<Mx> &b2) {\n\tfor (int i = Mx - 1; i >= 0; --i)\n\t\tif (b1[i] != b2[i])\n\t\t\treturn b1[i] < b2[i];\n\treturn false;\n}\n\nll f(It first, It last, const int pos) {\n\tif (pos < 0 || first == last)\n\t\treturn p2[last - first];\n\n\tIt pLast = prev(last);\n\tif (pLast[pos] == 0)\n\t\treturn f(first, last, pos - 1);\n\tfor (It it = first; it < pLast; ++it)\n\t\tif ((*it)[pos])\n\t\t\t*it ^= *pLast;\n\treturn f(first, pLast, pos - 1);\n}\n\nbitset<Mx> a[300];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i <= Mx; ++i)\n\t\tp2[i] = (p2[i - 1] * 2) % mod;\n\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\ta[i][j] = x;\n\t\t}\n\n\tsort(a, a + n, bsLess);\n\tll res = f(a, a + n, m - 1);\n\tres = (p2[n] - res) * p2[m - 1];\n\tcout << (res % mod + mod) % mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 303, mod = 998244353;\n\nint a[N][N];\n\nint main() {\n  int r, c;\n  scanf(\"%d %d\", &r, &c);\n  for (int i = 0; i < r; ++i) {\n    for (int j = 0; j < c; ++j)\n      scanf(\"%d\", a[i]+j);\n  }\n  int cnt = 0;\n  for (int k = 0; k < c; ++k) {\n    int idx = -1;\n    for (int i = cnt; i < r; ++i) {\n      if (a[i][k])\n        idx = i;\n    }\n    if (idx == -1) continue;\n    for (int i = 0; i < c; ++i)\n      swap(a[cnt][i], a[idx][i]);\n    for (int i = cnt+1; i < r; ++i) {\n      if (a[i][k] == 0) continue;\n      for (int j = 0; j < c; ++j) {\n        a[i][j] ^= a[cnt][j];\n      }\n    }\n    ++cnt;\n  }\n  long long ans = 1;\n  for (int i = 0; i < cnt; ++i)\n    ans = ans * 2 % mod;\n  --ans;\n  for (int i = 0; i < c-1 + r - cnt; ++i) {\n    ans = ans * 2 % mod;\n  }\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nll ans = 0;\nconst ll mo = 998244353;\nll mypow(ll a, ll b)\n{\n  ll res = 1;\n  a %= mo;\n  while (b)\n  {\n    if (b & 1)\n      res = res * a % mo;\n    a = a * a % mo;\n    b >>= 1;\n  }\n  return res;\n}\nint main()\n{\nll n , m ;\ncin >> n >> m ;\nvector<vector<ll>> v(n, vector<ll>(m,0) );\nrep(i,n)rep(j,m)cin >> v[i][j];\nvector<bool>see(m,1);\nrep(j,m){\n  bool a=0;\n  ll ind=0;\n  rep(i,n){\n    if(v[i][j]&&a==0&&see[i]){a=1;ind=i;}\n    else if(v[i][j]&&a){\n      rep(k,m){\n        v[i][k]=(v[i][k]+v[ind][k])%2;\n      }\n    }\n  }\n  if(a)see[ind]=0;\n}\nll c=0;\nrep(i,n){\n  ll t=0;\n  rep(j,m)t+=v[i][j];\n  if(t==0)c++;\n}\nauto modmul = [](auto... modx) {\n  ll res = 1;\n  for (auto modx_ : {modx...})\n  {\n    res *= modx_;\n    res %= mo;\n  }\n  return res;\n};\nans=modmul(mypow(2,m-1),mypow(2,n)-mypow(2,c)+mo);\ncout << ans << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bitset>\n#include<cstdio>\n#include<algorithm>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\nusing namespace std;\n\nconst int N=510,mod=998244353;\nint n,m,y,rk,ans,a[N][N],pw[N];\nbitset<N> b[N],x;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m); pw[0]=1;\n\trep(i,1,n){\n\t\trep(j,1,m) scanf(\"%d\",&y),x[j-1]=y;\n\t\tfor(int j=m-1; j>=0; j--)\n\t\t\tif (x[j]){\n\t\t\t\tif (b[j].any()) x^=b[j];\n\t\t\t\t else{ b[j]=x; break; }\n\t\t\t}\n\t}\n\trep(i,1,min(n,m)) pw[i]=2*pw[i-1]%mod;\n\trep(i,0,m-1) if (b[i].any()) rk++;\n\tans=1ll*(pw[n]-pw[n-rk])*pw[m-1]%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 2500;\nconst int K = 19;\nint n, q;\nint mod = 998244353;\nint a[N][N], f[N], invf[N];\nvector < pair < int, int > > v;\nint binpow(int x, int y){\n    if (y == 0) return 1;\n    if (y % 2) return x * binpow(x, y - 1) % mod;\n    int z = binpow(x, y / 2);\n    return z * z % mod;\n}\nint c(int n, int k){\n    if (k < 0) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= m; j++) cin >> a[i][j];\n    }\n    int r = 0;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= m; j++){\n            if (a[i][j] != 0){\n                for (int l = j + 1; l <= m; l++){\n                    if (a[i][l] == 1){\n                        for (int k = 1; k <= n; k++){\n                            if (j != l)\n                            a[k][l] ^= a[k][j];\n                        }\n                    }\n                }\n                r++;\n                break;\n            }\n        }\n    }\n    cout << (binpow(2, n + m - 1) - binpow(2, n + m - 1 - r) + mod) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "/************************************************\n * Au: Hany01\n * Date: Feb 10th, 2019\n * Prob: yahoo2019_e\n * Email: hany01dxx@gmail.com & hany01@foxmail.com\n * Inst: Yali High School\n************************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\n#define Rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define X first\n#define Y second\n#define PB(a) push_back(a)\n#define MP(a, b) make_pair(a, b)\n#define SZ(a) ((int)(a).size())\n#define ALL(a) a.begin(), a.end()\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 WoXiHuanNiA\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate <typename T> inline T read() {\n\tregister T _, __; register char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n//EOT\n\n\nconst int MAXN = 305;\n\nint n, m, a[MAXN][MAXN];\n\nint main() {\n#ifdef hany01\n\tfreopen(\"yahoo2019_e.in\", \"r\", stdin);\n\tfreopen(\"yahoo2019_e.out\", \"w\", stdout);\n#endif\n\n\tn = read<int>(), m = read<int>();\n\tFor(i, 1, n) For(j, 1, m)\n\t\ta[i][j] = read<int>() ^ a[i - 1][j] ^ a[i][j - 1] ^ a[i - 1][j - 1];\n\n\tint ans = 0;\n\tFor(l1, 0, n - 1) For(l2, l1 + 1, n) {\n\t\tint cnt[2] = {0, 0};\n\t\tFor(i, 0, m) {\n\t\t\tint t = a[l1][i] ^ a[l2][i];\n\t\t\tans += cnt[t ^ 1], ++ cnt[t];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing type = double;\nusing Vec = vector<type>;\nusing Mat = vector<Vec>;\n\nconst double EPS = 1e-6;\nbool isZero(type x) { return abs(x) <= EPS; }\n\n// sweep mat[i][j] 0<=i<m && 0<=j<c(default c=n)\n// return Vec{j| i,j s.t. minj mat[i][j]!=0}\nvector<int> sweep(Mat& mat, int c = -1) {\n  if (c == -1) c = mat[0].size();\n  int m = mat.size(), n = mat[0].size();\n  int row = 0;\n  vector<int> res;\n  for (int j = 0; j < c; j++) {\n    if (row == m) break;\n    int tar = -1;\n    type v = 0;\n    for (int i = row; i < m; i++) {\n      if (!isZero(mat[i][j]) && abs(v) < abs(mat[i][j])) {\n        tar = i;\n        v = mat[i][j];\n      }\n    }\n    if (tar == -1) continue;\n    if (row != tar) swap(mat[row], mat[tar]);\n    for (int i = 0; i < m; i++) {\n      if (i == row) continue;\n      if (!isZero(mat[i][j])) {\n        type r = mat[i][j] / mat[row][j];\n        for (int k = j; k < n; k++) {\n          mat[i][k] -= r * mat[row][k];\n        }\n      }\n    }\n    res.push_back(j);\n    row++;\n  }\n  return res;\n}\n\ntype det(Mat mat) {\n  sweep(mat);\n  type res = 1;\n  int sz = mat.size();\n  for (int i = 0; i < sz; i++) {\n    if (isZero(mat[i][i])) return type(0);\n    res *= mat[i][i];\n  }\n  return res;\n}\n\nint myrank(Mat mat) { return sweep(mat).size(); }\n\nusing ll = long long;\nconstexpr ll mod = 998244353;\n\ntemplate <typename T>\nT mypow(T a, T b) {\n  if (b == 0) return 1;\n  T tmp = mypow(a, b / 2);\n  if (b % 2)\n    return (((tmp * tmp) % mod) * a) % mod;\n  else\n    return (tmp * tmp) % mod;\n}\n\nint main() {\n    ll n,m;cin>>n>>m;\n    Mat a(n, Vec(m));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            cin >> a[i][j];\n        }\n    }\n    int r = myrank(a);\n    ll ret = mypow(2LL, n+m-1) + mod - mypow(2LL, n+m-r-1);\n    cout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t N>\nsize_t rankF2(vector<bitset<N>>& a, long n, long m){ // calculate rank of matrix in F_2\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)if(a[j][now])a[j] ^= a[i];\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<bitset<300>> a(N);\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0, k; j < N; ++j){\n        scanf(\"%d\", &k);\n        a[j][i] = k > 0;\n    }\n    else for(auto& i : a)for(int j = 0, k; j < M; ++j){\n        scanf(\"%d\", &k);\n        i[j] = k > 0;\n    }\n\n    auto r = rankF2(a, N, M);\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\n#define BIT_N 333\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef bitset<BIT_N> Bit;\nvector<int> baseNum;\n\nll pow_two[2 * BIT_N];\n\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 333333\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nvector<Bit> gauss(vector<Bit> v, ll &ran){\n\tran = 0;\n\tREP(i,BIT_N) {\n\t\tint pla = -1;\n\t\tfor(int j = ran;j < v.size();j++){\n\t\t\tif(v[j][i] == 1){\n\t\t\t\tpla = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pla != -1){\n\t\t\tswap(v[ran], v[pla]);\n\t\t\tfor(int j = 0;j < v.size();j++){\n\t\t\t\tif(j != ran && v[j][i] == 1)v[j] ^= v[ran];\n\t\t\t}\n\t\t\tran++;\n\t\t}\n\t}\n\treturn v;\n}\n\nint main(){\n\t\n\tpow_two[0] = 1;\n\tREP(i,2 * BIT_N - 1)pow_two[i+1] = pow_two[i] * 2 % MOD;\n\t\n\tvector<Bit> v;\n\tll n, m;cin >> n >> m;\n\tREP(i,n){\n\t\tBit now;\n\t\tREP(j,m){\n\t\t\tint a;cin >> a;\n\t\t\tif(a)now[j] = 1;\n\t\t}\n\t\tv.PB(now);\n\t}\n\t\n\tll ran = 0;\n\tll ans = 0;\n\tgauss(v, ran);\n\tll kake = pow_two[n-ran] * pow_two[m-ran] % MOD;\n\t//cout << \"kake \" << kake << endl;\n\tfor(int i = 1;i <= ran;i+=2){\n\t\tll now = combination(ran, i) * pow_two[ran - i] * 2 % MOD;\n\t\tnow = max(1LL, (now - 2 + MOD) % MOD);\n\t\tans = (ans + now * kake % MOD) % MOD;\n\t\t//cout << \"now \" << now << endl;\n\t}\n\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 998244353;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M;\n    cin >> N >> M;\n    vvec<int> A(N,vec<int>(M));\n    for(int i=0;i<N;i++) for(int j=0;j<M;j++) cin >> A[i][j];\n    vec<mint> pow2(max(N,M)+1,1);\n    for(int i=1;i<=max(N,M);i++) pow2[i] = pow2[i-1]*2;\n    int rank = 0;\n    for(int j=0;j<M;j++){\n        bool update = false;\n        for(int i=0;i<N;i++) if(A[i][j]){\n            swap(A[i],A[rank]);\n            update = true;\n            break;\n        }\n        if(update){\n            for(int i=0;i<N;i++) if(i!=rank){\n                for(int k=j;k<M;k++) (A[i][k] += A[rank][k])%=2;\n            }\n            rank++;\n        }\n        if(rank==N) break;\n    }\n    cout << pow2[N-1]*(pow2[M]-pow2[M-rank]) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define FL \"a\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double dd;\nconst int N=305;\nconst int inf=2147483647;\nconst dd pi=acos(-1);\nconst ll INF=1ll<<60;\nconst int mod=998244353;\ninline ll read(){\n  ll data=0,w=1;char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n  if(ch=='-')w=-1,ch=getchar();\n  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n  return data*w;\n}\ninline void file(){\n  freopen(FL\".in\",\"r\",stdin);\n  freopen(FL\".out\",\"w\",stdout);\n}\n\nint n,m,a[N][N],now[N],p[N],r;\ninline int poww(int a,int b){\n  int res=1;\n  for(;b;b>>=1,a=1ll*a*a%mod)\n    if(b&1)res=1ll*res*a%mod;\n  return res;\n}\n\nint main()\n{\n  n=read();m=read();\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=m;j++)a[i][j]=read();\n  for(int i=1;i<=n;i++){\n    memcpy(now,a[i],sizeof(now));\n    for(int j=1;j<=m;j++)\n      if(now[j]){\n\tif(p[j])for(int k=j;k<=m;k++)now[k]^=a[p[j]][k];\n\telse{p[j]=i,r++;break;}\n      }\n  }\n  printf(\"%lld\\n\",1ll*(poww(2,n)-poww(2,n-r)+mod)%mod*poww(2,m-1)%mod);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing MINT = ModInt<998244353>;\nusing mint = ModInt<2>;\n\nconst mint zero(0);\nconst mint one(1);\nbool iszero(mint x){\n\treturn x.v==0;\n}\nbool isone(mint x){\n\treturn x.v==1;\n}\n\ntemplate<class T>\nstruct Matrix{\n\tint H,W;\n\tVV<T> a;\n\n\tMatrix() : H(0),W(0){}\n\tMatrix(int H,int W) : H(H),W(W),a( VV<T>(H,V<T>(W)) ){}\n\tMatrix(const VV<T>& v) : H(v.size()), W(v[0].size()), a(v){}\n\n\tstatic Matrix E(int n){\n\t\tMatrix a(n,n);\n\t\trep(i,n) a.set(i,i,1);\n\t\treturn a;\n\t}\n\n\tT at(int i,int j) const {\n\t\treturn a[i][j];\n\t}\n\tvoid set(int i,int j,T v){\n\t\ta[i][j] = v;\n\t}\n\n\tMatrix operator+(const Matrix& r) const {\n\t\tassert(H==r.H && W==r.W);\n\t\tVV<T> v(H,V<T>(W));\n\t\trep(i,H) rep(j,W) v[i][j] = a[i][j] + r.a[i][j];\n\t\treturn Matrix(v);\n\t}\n\tMatrix operator-(const Matrix& r) const {\n\t\tassert(H==r.H && W==r.W);\n\t\tVV<T> v(H,V<T>(W));\n\t\trep(i,H) rep(j,W) v[i][j] = a[i][j] - r.a[i][j];\n\t\treturn Matrix(v);\n\t}\n\tMatrix operator*(const Matrix& r) const {\n\t\tassert(W==r.H);\n\t\tVV<T> v(H,V<T>(r.W));\n\t\trep(i,H) rep(k,W) rep(j,r.W) v[i][j] += a[i][k] * r.a[k][j];\n\t\treturn Matrix(v);\n\t}\n\tMatrix& operator+=(const Matrix& r){return (*this)=(*this)+r;}\n\tMatrix& operator-=(const Matrix& r){return (*this)=(*this)-r;}\n\tMatrix& operator*=(const Matrix& r){return (*this)=(*this)*r;}\n\n\t/*\n\t\t副作用がある, 基本的に自分でこれを呼ぶことはない\n\t\t掃き出し法をする\n\t\t左からvar列が掃き出す対象で、それより右は同時に値を変更するだけ(e.g. 逆行列は右に単位行列おいてから掃き出す)\n\t\t行swap, 列swap は行わない\n\n\t\trank を返す\n\t*/\n\tint sweep(int var){\n\t\tint rank = 0;\n\t\tvector<bool> used(H);\n\t\trep(j,var){\n\t\t\tint i=0;\n\t\t\twhile(i<H && (used[i]||iszero(a[i][j]))) i++;\n\t\t\tif(i==H) continue;\n\t\t\tused[i] = true;\n\t\t\trank++;\n\t\t\tT t = a[i][j];\n\t\t\trep(k,W) a[i][k] = a[i][k]/t;\n\t\t\trep(k,H) if(k!=i){\n\t\t\t\tT t = a[k][j];\n\t\t\t\trep(l,W) a[k][l] = a[k][l]-a[i][l]*t;\n\t\t\t}\n\t\t}\n\t\treturn rank;\n\t}\n\n\tfriend ostream& operator<<(ostream &o,const Matrix& A){\n\t\trep(i,A.H){\n\t\t\trep(j,A.W) o<<A.a[i][j]<<\" \";\n\t\t\to<<endl;\n\t\t}\n\t\treturn o;\n\t}\n};\ntemplate<class T>\nint getrank(Matrix<T> A){\n\treturn A.sweep(A.W);\n}\n\nMINT pw(MINT x,int p){\n\tMINT a = 1;\n\trep(i,p) a *= x;\n\treturn a;\n}\n\n\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tMatrix<mint> A(H,W);\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tA.set(i,j,x);\n\t\t}\n\t}\n\tint r = getrank(A);\n\tMINT ans = pw(2,H) - pw(2,H-r);\n\tans *= pw(2,W-1);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int mod = 998244353;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> a(n, vector<int>(m));\n  for (auto &ai : a) {\n    for (auto &aij : ai) {\n      cin >> aij;\n    }\n  }\n  ll dp[n][m][2][2][2];\n  fill(dp[0][0][0][0], dp[n][0][0][0], 0);\n  dp[0][0][0][0][0] = dp[0][0][0][1][0] = dp[0][0][0][0][1] = dp[0][0][a[0][0]][1][1] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      for (int o = 0; o < 2; o++) {\n        for (int r = 0; r < 2; r++) {\n          for (int c = 0; c < 2; c++) {\n            int o2 = r && c ? (o ^ a[i][j]) : o;\n            if (i) {\n              dp[i][j][o2][r][c] += dp[i - 1][j][o][0][c];\n              dp[i][j][o2][r][c] += dp[i - 1][j][o][1][c];\n            }\n            if (j) {\n              dp[i][j][o2][r][c] += dp[i][j - 1][o][r][0];\n              dp[i][j][o2][r][c] += dp[i][j - 1][o][r][1];\n            }\n            if (i && j) {\n              dp[i][j][o2][r][c] -= dp[i - 1][j - 1][o][0][0];\n              dp[i][j][o2][r][c] -= dp[i - 1][j - 1][o][1][0];\n              dp[i][j][o2][r][c] -= dp[i - 1][j - 1][o][0][1];\n              dp[i][j][o2][r][c] -= dp[i - 1][j - 1][o][1][1];\n            }\n            dp[i][j][o2][r][c] %= mod;\n          }\n        }\n      }\n    }\n  }\n  ll t = 0;\n  for (int r = 0; r < 2; r++) {\n    for (int c = 0; c < 2; c++) {\n      t += dp[n - 1][m - 1][1][r][c];\n    }\n  }\n  t %= mod;\n  cout << t << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\ntypedef unsigned int uint;\nusing namespace std;\n\nconst ll mod = 998244353LL;\n\nll power_mod(ll num, ll power) {\n    ll prod = 1;\n    num %= mod;\n    while (power > 0) {\n        if (power & 1) {\n            prod = prod * num % mod;\n        }\n        num = num * num % mod;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint main() {\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m, A[300][300];\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> A[i][j];\n        }\n    }\n\n    int rank = 0;\n    for (int j = 0; j < m; j++) {\n        int pivot = -1;\n\n        for (int i = rank; i < n; i++) {\n            if (A[i][j]) {\n                pivot = i;\n                break;\n            }\n        }\n\n        if (pivot >= 0) {\n            if (pivot != rank) {\n                for (int k = 0; k < m; k++) {\n                    swap(A[pivot][k], A[rank][k]);\n                }\n            }\n\n            for (int i = rank + 1; i < n; i++) {\n                if (A[i][j]) {\n                    for (int k = 0; k < m; k++) {\n                        A[i][k] ^= A[rank][k];\n                    }\n                }\n            }\n\n            rank++;\n        }\n    }\n\n    cout << (power_mod(2LL, (ll)(n+m-1)) - power_mod(2LL, (ll)(n+m-rank-1))) % mod << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n,m,a[N][N];\nll qpow(ll a,ll n)\n{\n    ll ans=1;\n    while(n)\n    {\n        if(n&1) ans=ans*a%mod;\n        a=a*a%mod;\n        n>>=1;\n    }\n    return ans;\n}\nint guass(int n)\n{\n    int ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        int p=i;\n        while(p<=n&&!a[p][i]) p++;\n        if(p==n+1) {ans++;continue;}\n        swap(a[i],a[p]);\n        for(int j=i+1;j<=n;j++)\n            if(a[j][i])\n            for(int k=i;k<=n;k++)\n            a[j][k]^=a[i][k];\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        scanf(\"%d\",&a[i][j]);\n    int s=max(n,m);\n    int ans=guass(s);\n    if(n>m) ans-=n-m;\n    printf(\"%lld\\n\",qpow(2,n-1)*(qpow(2,m)+mod-qpow(2,ans))%mod);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\n/*bool operator < (const vector<long long> &a,const vector<long long> &b){\n    bool ret=false;\n    DEBUG(\"called\");\n    for(long long i = 0; i < a.size(); i++){\n        if(a[i]>b[i]){\n            ret=false;\n            break;\n        }else if(a[i]<b[i]){\n            ret=true;\n            break;\n        }\n    }\n    return ret;\n}\n*/\nll cache_pow[600];\nll mpow(ll a){\n    static bool flag=false;\n    if(flag){\n        DEBUG(\"True\");\n        return cache_pow[a];\n    }else{\n        cache_pow[0]=1;\n        for(long long i = 1; i < 600; i++){\n            cache_pow[i]=(cache_pow[i-1]<<1)%MOD;\n        }\n        flag=true;\n        return cache_pow[a];\n    }\n}\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    sort(a.begin(),a.end(),greater<vll>());\n    ll index=0;\n\n    vector<bitset<300>> A;\n    for(long long i = 0; i < a.size(); i++){\n        A.push_back(bitset<300>(0));\n        for(long long k = 0; k < a[i].size(); k++){\n            A[i][k]=a[i][k]==1;\n        }\n    }\n    ll rank=0;\n    for(long long i = 0; i < a.size(); i++){\n        DEBUG(i);\n        for(; index < a[i].size()&&a[i][index]==0; index++){\n            DEBUG(index);\n        }\n        if(index==a[i].size()){\n            break;\n        }\n        rank++;\n        for(long long j = i+1; j < a.size()&&a[j][index]==1; j++){\n            A[j]^=A[i];\n        }\n    }\n    DEBUG(rank);\n    cout<<mpow(M+N-1)-mpow(M+N-1-rank)<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n\tfact.resize(n+1);\n\tinv.resize(n+1);\n\tinvfact.resize(n+1);\n\tfact[0]=inv[0]=invfact[0]=1;\n\tinv[1]=1;\n\trep(i,n){\n\t\tfact[i+1]=fact[i]*(i+1)%mod;\n\t\tif(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n\t\tinvfact[i+1]=invfact[i]*inv[i+1]%mod;\n\t}\n}\nll perm(int n,int k){\n\tif(n<0||k<0||k>n)return 0;\n\treturn fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n\tif(n<0||k<0||k>n)return 0;\n\treturn (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n\tll ret=1;\n\twhile(k){\n\t\tif(k&1)ret=ret*n%mod;\n\t\tn=n*n%mod;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tmod_build();\n\tint n,m;\n\tcin>>n>>m;\n\tint a[n][m];\n\trep(i,n)rep(j,m)cin>>a[i][j];\n\tint cnt=0;\n\trep(i,n){\n\t\tbool ok=false;\n\t\tint idx = -1;\n\t\tfor(int j=cnt;j<m;++j)if(a[i][j]==1)ok=true,idx=j;\n\t\tif(!ok)continue;\n\t\tif(a[i][cnt]!=1){\n\t\t\trep(k,n)swap(a[k][cnt],a[k][idx]);\n\t\t}\n\t\trep(k,n)REP(j,cnt,m)a[k][j]^=a[k][cnt];\n\t}\n\tll ans=powmod(2,m+n-1);\n\tans+=mod-powmod(2,n+m-cnt-1);\n\tcout<<ans%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\nconstexpr int MOD = 998244353;\nusing mint = ModInt<MOD>;\n\nvoid bool_elimination(std::vector<std::vector<int>>& mat) {\n    int n = mat.size(), m = mat.front().size();\n\n    for (int l = 0; l < n; ++l) {\n        {\n            auto& v = *std::max_element(mat.begin() + l, mat.end());\n            std::swap(v, mat[l]);\n        }\n\n        const auto& v = mat[l];\n        for (int i = l + 1; i < n; ++i) {\n            auto u = mat[i];\n            for (int j = 0; j < m; ++j) u[j] ^= v[j];\n            if (u < mat[i]) std::swap(u, mat[i]);\n        }\n    }\n}\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n\n    auto mat = vec(n, vec(m, 0));\n    for (auto& v : mat) {\n        for (auto& x : v) {\n            std::cin >> x;\n        }\n    }\n    bool_elimination(mat);\n\n    int r = std::count_if(mat.begin(), mat.end(),\n                          [](const auto& v) {\n                              return any_of(v.begin(), v.end(), [](auto x) { return x; });\n                          });\n\n    std::vector<mint> dp{1, 0};\n    for (int i = 0; i < r; ++i) {\n        std::vector<mint> ndp(2);\n        for (int j = 0; j < 2; ++j) {\n            ndp[j] = dp[j] * 3 + dp[1 - j];\n        }\n        std::swap(dp, ndp);\n    }\n\n    mint ans = dp[1];\n    std::cout << ans * mint(2).pow(n + m - r * 2) << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing type = long double;\nusing Vec = vector<type>;\nusing Mat = vector<Vec>;\n\nconst double EPS = 1e-12;\nbool isZero(type x) { return abs(x) <= EPS; }\n\n// sweep mat[i][j] 0<=i<m && 0<=j<c(default c=n)\n// return Vec{j| i,j s.t. minj mat[i][j]!=0}\nvector<int> sweep(Mat& mat, int c = -1) {\n  if (c == -1) c = mat[0].size();\n  int m = mat.size(), n = mat[0].size();\n  int row = 0;\n  vector<int> res;\n  for (int j = 0; j < c; j++) {\n    if (row == m) break;\n    int tar = -1;\n    type v = 0;\n    for (int i = row; i < m; i++) {\n      if (!isZero(mat[i][j]) && abs(v) < abs(mat[i][j])) {\n        tar = i;\n        v = mat[i][j];\n      }\n    }\n    if (tar == -1) continue;\n    if (row != tar) swap(mat[row], mat[tar]);\n    for (int i = 0; i < m; i++) {\n      if (i == row) continue;\n      if (!isZero(mat[i][j])) {\n        type r = mat[i][j] / mat[row][j];\n        for (int k = j; k < n; k++) {\n          mat[i][k] -= r * mat[row][k];\n        }\n      }\n    }\n    res.push_back(j);\n    row++;\n  }\n  return res;\n}\n\ntype det(Mat mat) {\n  sweep(mat);\n  type res = 1;\n  int sz = mat.size();\n  for (int i = 0; i < sz; i++) {\n    if (isZero(mat[i][i])) return type(0);\n    res *= mat[i][i];\n  }\n  return res;\n}\n\nint myrank(Mat mat) { return sweep(mat).size(); }\n\nusing ll = long long;\nconstexpr ll mod = 998244353;\n\ntemplate <typename T>\nT mypow(T a, T b) {\n  if (b == 0) return 1;\n  T tmp = mypow(a, b / 2);\n  if (b % 2)\n    return (((tmp * tmp) % mod) * a) % mod;\n  else\n    return (tmp * tmp) % mod;\n}\n\nint main() {\n    ll n,m;cin>>n>>m;\n    Mat a(n, Vec(m));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            cin >> a[i][j];\n        }\n    }\n    int r = myrank(a);\n    ll ret = mypow(2LL, n+m-1) + mod - mypow(2LL, n+m-r-1);\n    cout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n \nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n \nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n \n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = rank; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[rank]);\n                ok = true;\n                break;\n            }\n        }\n \n        if(!ok) continue;\n \n        for(int j = rank+1; j < n; j++) if(mat[j][i]) {\n \n            for(int k = i; k < n; k++) {\n \n                mat[j][k] ^= mat[rank][k];\n            }\n        }\n\n        rank++;\n    }\n \n    return rank;\n}\n \n \n \nconst long long __exp_template_MOD = MOD;\nconst long long mod = MOD;\nint qpow(int x, int n){ int y = 1; while(n){ if(n & 1) y = (ll) y * x % mod; x = (ll) x * x % mod; n >>= 1; } return y; }\n \nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n \nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n \n    printf(\"%lld\\n\", ((qpow(2, n+m-1) - qpow(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n \nvoid init() {\n    \n \n \n}\n \nint main () {\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        rank++;\n\n        for(int j = i+1; j < n; j++) if(mat[j][i]) {\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k];\n            }\n        }\n    }\n\n    return rank;\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 1e18;\nlong long int mod = 1000000007;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1 , number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1 , number1);\n    }\n}\n\nll i,j,k,ii,jj,n,m,a,b,c,d,e,f,g,h,r,w,l,num,ans,ok,ng,mid;\nll x[500005],y[500005],z[500005];\nll dp[305][305];\nll sum[305];\nchar s[500005],t[500005],u[500005];\nbool dame,flag;\n//string s;\n\nint main(){\n\tcin >> n >> m;\n\tans = 1;\n\tfor(i=1;i<=n;i++){\n\t\tdame = true;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tcin >> x[j];\n\t\t\tif(x[j] == 1)dame = false;\n\t\t}\n\t\tif(dame){\n\t\t\ta++;\n\t\t\tans *= 2;\n\t\t}else{\n\t\t\tfor(j=1;j<=m;j++){\n\t\t\t\tdp[i-a][j] = x[j];\n\t\t\t}\n\t\t}\n\t}\n\tn -= a;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=m;j++){\n\t\t\tsum[i] += dp[i][j];\n\t\t\t//pe(dp[i][j]);\n\t\t}\n\t\t//el;\n\t}\n\t//sum[i] := i行目の総和\n\tdame = true;\n\tfor(i=1;i<=n;i++){\n\t\tif(sum[i] % 2 == 1){\n\t\t\tdame = false;\n\t\t}\n\t}\n\tif(!dame){\n\t\tans *= (rui(2,m-1)* (rui(2,n) - 1));\n\t}else{\n\t\tfor(j=1;j<=m;j++){\n\t\t\tsum[j] = 0;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tsum[j] += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tdame = true;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tif(sum[j] % 2 == 1)dame = false;\n\t\t}\n\t\tif(!dame){\n\t\t\tans *= (rui(2,n-1)* (rui(2,m) - 1));\n\t\t}else{\n\t\t\tans = 0;\n\t\t}\n\t}\n\tp(ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nconst ll MOD=998244353;\nll n,m,a[310][310];\n\nll ad(ll x,ll y){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll rnk(ll n,ll m,ll M[][310]){\n  ll d=0;\n  fr(j,m){\n    bool f=0;\n    if(M[d][j]==0){\n      f=1;\n      for(ll i=d;i++<n-1;){\n        if(M[i][j]!=0){swap(M[d],M[i]);f=0;}\n      }\n    }\n    if(f && j<m-1) continue;\n    if(f) return d;\n    for(ll i=d;i++<n-1;){\n      if(M[i][j]==0) continue;\n      for(ll k=j;k<m;k++){\n        M[i][k]=(M[i][k]+M[d][k])%2;\n      }\n    }\n    d++;\n    if(d==n) return n;\n  }\n}\n\nint main(){\n  cin>>n>>m;\n  fr(i,n) fr(j,m) cin>>a[i][j];\n  cout<<ad(pwr(2,n+m-1),MOD-pwr(2,n+m-1-rnk(n,m,a)))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nll mod = 998244353;\nvvi a;\n\nvoid _main(istream &inp){\n    int n,m;\n    inp >> n >> m;\n    a = vvi(n, vi(m));\n    rep(x,n) rep(y,m) inp >> a[x][y];\n    //debug(a);\n    rep(x,n) rep(y,m) a[x][y]%=2;\n    int rank = 0;\n    int cur_x = 0;\n    rep(y,m){\n        FOR(x,cur_x+1,n){\n            if(a[x][y]==1 && a[cur_x][y]==0){\n                swap(a[x], a[cur_x]);\n            }\n            if(a[x][y]==1 && a[cur_x][y]==1){\n                rep(y2,m) a[x][y2]^=a[cur_x][y2];\n            }\n            \n        }\n        if(a[cur_x][y]==1){\n            rank += 1;\n            cur_x += 1;\n            if(cur_x>=n)break;\n        }\n    }\n    //debug(rank);\n    //debug(a);\n    ll ret = 1;\n    rep(i,rank) ret = 2*ret%mod;\n    ret = (ret+mod-1)%mod;\n    rep(i,n+m-rank-1 ) ret = 2*ret%mod;\n    cout << ret << endl;\n\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<math.h>\n#include<algorithm>\n#include<numeric>\n#include<list>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<ULL> VULL;\n\ntypedef signed short Hitoketa;\n\nclass MYCP {\npublic:\n\n\tstatic const LL TEISUU = 1000 * 1000 * 1000 + 7;\n\n\tstatic LL DebugFlag;\n\n\t//数値を区切って文字列にする\n\tstatic string MakeString_LongLong(vector<long long> const& numbers, string const& str) {\n\t\tif (numbers.size() == 0)return \"\";\n\t\tstring result = \"\" + to_string(numbers[0]);\n\t\tfor (long long i = 1; i < numbers.size(); i++) {\n\t\t\tresult += str;\n\t\t\tresult += to_string(numbers[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//空白で区切る為のオーバーロード\n\tstatic string MakeString_LongLong(vector<long long> const& numbers) {\n\t\tif (numbers.size() == 0)return \"\";\n\t\tstring result = \"\" + to_string(numbers[0]);\n\t\tfor (long long i = 1; i < numbers.size(); i++) {\n\t\t\tresult += \" \";\n\t\t\tresult += to_string(numbers[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\n\n\t//文字列の配列を改行を挟んでまとめる\n\tstatic string MakeString_VectorString(vector<string> const& str) {\n\t\tstring result = \"\";\n\t\tfor (long long i = 0; i < str.size(); i++) {\n\t\t\tresult += str[i] + \"\\n\";\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//文字列を必要な個数だけ読み取る\n\tstatic vector<string> MyReadLineSplit(LL n) {\n\t\tvector<string> str(n);\n\t\tfor (long long i = 0; i < n; i++) {\n\t\t\tstd::cin >> str[i];\n\t\t}\n\n\t\treturn str;\n\t}\n\n\t//数値を必要な個数だけ読み取る\n\tstatic vector<long long> ReadInts(long long number) {\n\t\tvector<long long> a(number);\n\t\tfor (int i = 0; i < number; i++) {\n\t\t\tstd::cin >> a[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t//渡された自然数が素数ならtureを返す\n\tstatic bool PrimeCheck_Int(long long number) {\n\t\tif (number < 2)return false;\n\n\t\tfor (ULL i = 2; i*i <= number; i++) {\n\t\t\tif (number%i == 0)return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t//渡された数値以下の素数表を作る\n\tstatic vector<long long> MakePrimeList(long long n) {\n\t\tvector<long long> list;\n\t\tLL i, j, p;\n\t\tbool flag;\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tflag = true;\n\t\t\tfor (j = 0; j < list.size(); j++) {\n\n\t\t\t\tif (!(list[j] * list[j] <= i))break;\n\n\t\t\t\tif (i%list[j] == 0) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)list.push_back(i);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\n\n\t//文字列の分割\n\tstatic vector<string> split(string const& str, char sep)\n\t{\n\t\tvector<std::string> v;        // 分割結果を格納するベクター\n\t\tauto first = str.begin();              // テキストの最初を指すイテレータ\n\t\twhile (first != str.end()) {         // テキストが残っている間ループ\n\t\t\tauto last = first;                      // 分割文字列末尾へのイテレータ\n\t\t\twhile (last != str.end() && *last != sep)       // 末尾 or セパレータ文字まで進める\n\t\t\t\tlast++;\n\t\t\tv.push_back(string(first, last));       // 分割文字を出力\n\t\t\tif (last != str.end())\n\t\t\t\tlast++;\n\t\t\tfirst = last;          // 次の処理のためにイテレータを設定\n\t\t}\n\t\treturn v;\n\t}\n\n\t//合計を求める\n\tstatic LL Sum(vector<LL> a) {\n\t\tLL i, sum = 0;\n\n\t\tfor (i = 0; i < a.size(); i++) {\n\t\t\tsum += a[i];\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\t//小文字ならtrueを返す\n\tstatic bool Komoji(char a) {\n\t\tif (a >= 'a'&&a <= 'z')return true;\n\n\t\treturn false;\n\t}\n\n\t//大文字ならtrueを返す\n\tstatic bool Oomoji(char a) {\n\t\tif (a >= 'A'&&a <= 'Z')return true;\n\n\t\treturn false;\n\t}\n\n\t//切り上げの整数値割り算\n\tstatic LL KiriageWarizan(LL a, LL b) {\n\t\tLL result = a / b;\n\n\t\tif (a%b > 0)result++;\n\n\t\treturn result;\n\t}\n\n\t//最大公約数\n\tstatic LL GreatestCommonFactor(LL a, LL b) {\n\t\tLL temp;\n\t\tif (a < b) {\n\t\t\ttemp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\twhile (true)\n\t\t{\n\t\t\ttemp = a % b;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\tif (b == 0)break;\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t//最小公倍数\n\tstatic LL LeastCommonMultiple(LL a, LL b) {\n\t\treturn (a / GreatestCommonFactor(a, b))*b;\n\t}\n\n\t//素因数分解\n\tstatic vector<VLL> PrimeFactorization(LL n) {\n\t\tVLL p_list, s_list;\n\n\t\tLL i, j, k, count;\n\n\t\tfor (i = 2; n > 1; i++) {\n\t\t\tif (i*i > n) {\n\t\t\t\tp_list.push_back(n);\n\t\t\t\ts_list.push_back(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (n%i == 0) {\n\t\t\t\tcount = 0;\n\t\t\t\twhile (n%i==0)\n\t\t\t\t{\n\t\t\t\t\tn /= i;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\n\t\t\t\tp_list.push_back(i);\n\t\t\t\ts_list.push_back(count);\n\t\t\t}\n\t\t}\n\n\t\tvector<VLL> result;\n\t\tresult.push_back(p_list);\n\t\tresult.push_back(s_list);\n\n\t\treturn result;\n\t}\n\n\t//組み合わせ nCr\n\tstatic LL Combination(LL n, LL r) {\n\t\tr = min(r, n - r);\n\n\t\tVLL p(n + 1, 0);\n\n\t\tLL i, j, k, a, b, c;\n\n\t\tfor (i = 1; i <= r; i++) {\n\t\t\tauto temp = MYCP::PrimeFactorization(i);\n\n\t\t\tfor (j = 0; j < temp[0].size(); j++) {\n\t\t\t\tp[temp[0][j]] -= temp[1][j];\n\t\t\t}\n\n\t\t\ta = i + n - r;\n\t\t\ttemp = MYCP::PrimeFactorization(a);\n\n\t\t\tfor (j = 0; j < temp[0].size(); j++) {\n\t\t\t\tp[temp[0][j]] += temp[1][j];\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tLL result = 1;\n\n\t\tfor (i = 0; i < p.size(); i++) {\n\t\t\tif (p[i] > 0) {\n\n\t\t\t\tfor (j = 0; j < p[i]; j++) {\n\t\t\t\t\tresult *= i;\n\t\t\t\t\tresult %= MYCP::TEISUU;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tstatic LL DebugPrintf(string output) {\n\n\t\tif (MYCP::DebugFlag != 0) {\n\t\t\tstd::cout << output << endl;\n\t\t}\n\n\t\treturn MYCP::DebugFlag;\n\t}\n\n\tstatic  LL DebugCin() {\n\t\tLL a;\n\n\t\tif (MYCP::DebugFlag != 0) {\n\t\t\tcin >> a;\n\t\t}\n\n\t\treturn a;\n\t}\n};\nLL MYCP::DebugFlag = 0;\n\n//累積和を求めるクラス\nclass Syakutori {\nprivate:\n\tvector<LL> list;\n\npublic:\n\n\tvoid MakeArray(vector<LL> data) {\n\t\tLL i;\n\t\tlist = data;\n\t\tlist.push_back(0);\n\t\tlist[0] = 0;\n\t\tfor (i = 1; i < list.size(); i++) {\n\t\t\tlist[i] = list[i - 1] + data[i - 1];\n\t\t}\n\n\t}\n\n\tLL Sum(LL start, LL end) {\n\t\tif (end < start) {\n\t\t\tstd::cout << \"startがendより大きいです\";\n\t\t\treturn 0;\n\t\t}\n\t\tif (start < 0 || end >= list.size()) {\n\t\t\tstd::cout << \"範囲が異常\";\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn list[end] - list[start];\n\t}\n\n};\n\nclass Unlimited_Integer {\nprivate:\n\tHitoketa sign;\n\tvector<Hitoketa> numbers;\n\n\n\n\npublic:\n\n\tUnlimited_Integer(string value) {\n\t\tLL i, j, k;\n\n\t\tthis->sign = 1;\n\t\tk = 0;\n\n\t\tif (value[0] == '-') {\n\t\t\tsign = -1;\n\t\t\tk = 1;\n\t\t}\n\n\t\tvector<Hitoketa> temp(value.size() - k, 100);\n\n\t\tthis->numbers = temp;\n\n\t\tfor (i = value.size() - 1, j = 0; i >= k; i--, j++) {\n\t\t\tthis->numbers[j] = (Hitoketa)(value[i] - '0');\n\t\t}\n\n\t}\n\n\tUnlimited_Integer(LL value) {\n\t\tUnlimited_Integer temp(to_string(value));\n\t\tthis->Copy(temp);\n\t}\n\n\tUnlimited_Integer() {\n\t\tUnlimited_Integer temp(0);\n\t\tthis->Copy(temp);\n\t}\n\n\tstring To_string() {\n\t\tLL i, j, k;\n\n\t\tstring result = \"\";\n\n\t\tif (this->sign == -1) {\n\t\t\tresult += \"-\";\n\t\t}\n\n\t\tfor (i = this->numbers.size() - 1; i >= 0; i--) {\n\t\t\tresult += (char)(this->numbers[i] + '0');\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tvoid Copy(Unlimited_Integer a) {\n\t\tthis->numbers = a.numbers;\n\t\tthis->sign = a.sign;\n\t}\n\n\tvoid operator =(Unlimited_Integer const& a) {\n\t\tthis->Copy(a);\n\t}\n\n\tUnlimited_Integer operator +(Unlimited_Integer const& a) {\n\t\tUnlimited_Integer result;\n\n\t\tLL max_keta = max(a.numbers.size(), this->numbers.size()) + 1;\n\n\t\tif (true) {\n\t\t\tVLL temp(max_keta, 0);\n\n\n\t\t}\n\t}\n};\n\n\n\n//ここからメイン\nint main(void) {\n\tMYCP::DebugFlag = 0;\n\n\tLL i, j, k, n, m;\n\tLL a, b;\n\tLL x;\n\n\tcin >> k >> a >> b;\n\n\tif (k < a) {\n\t\tcout << k + 1 << endl;\n\t\treturn 0;\n\t}\n\n\tif (b - a <= 2) {\n\t\tcout << k + 1 << endl;\n\t\treturn 0;\n\t}\n\n\tk -= a;\n\tk++;\n\n\tm = k / 2;\n\n\tx = a;\n\n\tx += m * (b - a);\n\n\tx += (k % 2);\n\n\tcout << x << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> operator^(const vector<int> &a, const vector<int> &b) {\n    vector<int> res((int)a.size());\n    for (int i = 0; i < (int)a.size(); ++i)\n        res[i] = (a[i] ^ b[i]);\n    return res;\n}\n\nbool operator<(const vector<int> &a, const vector<int> &b) {\n    for (int i = 0; i < (int)a.size(); ++i) {\n        if (a[i] == b[i]) continue;\n        return a[i] < b[i];\n    }\n    return false;\n}\n\nconst int mod = 998244353;\n\nint main() {\n    int n, m; scanf(\"%d%d\", &n, &m);\n    vector<vector<int>> a(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j)\n            scanf(\"%d\", &a[i][j]);\n    }\n    vector<vector<int>> basis;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < (int)basis.size(); ++j)\n            a[i] = min(a[i], a[i] ^ basis[j]);\n        if (count(a[i].begin(), a[i].end(), 1) > 0)\n            basis.push_back(a[i]);\n    }\n    int way = 1;\n    for (int i = 0; i < n - (int)basis.size(); ++i)\n        way = way * 2 % mod;\n    int ans = 1;\n    for (int i = 0; i < n; ++i)\n        ans = ans * 2 % mod;\n    ans = (ans + mod - way) % mod;\n    int mult = 1;\n    for (int i = 0; i < m - 1; ++i) \n        mult = mult * 2 % mod;\n    printf(\"%d\\n\", ans * 1ll * mult % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 302;\nconst int MOD = 998244353;\n\nstruct equation {\n\n\tvector<int> coeff;\n\tint val;\n\n\tvoid init(int n) {\n\t\tcoeff.resize(n);\n\t\tval = 0;\n\t}\n\n};\n\nint n, m, a[MAX_N][MAX_N];\nequation e[MAX_N];\n\nvoid readInput() {\n\tcin >> n >> m;\n\n\tfor (int i=0; i<n; ++i) {\n\t\tfor (int j=0; j<m; ++j)\n\t\t\tcin >> a[i][j];\n\t}\n}\n\nvoid initEquationSystem() {\n\tfor (int i=0; i<n; ++i) {\n\t\te[i].init(m);\n\t\tfor (int j=0; j<m; ++j)\n\t\t\te[i].coeff[j] = a[i][j];\n\t\te[i].val = 0;\n\t}\n\t// PR0(e[1].coeff, m);\n}\n\nint64_t pw(int n, int k) {\n\tif (k==0)\n\t\treturn 1;\n\n\tint64_t tmp = pw(n, k/2);\n\n\tif (k%2)\n\t\treturn tmp * tmp % MOD * n % MOD;\n\treturn tmp * tmp % MOD;\n}\n\nvoid solve() {\n\tfor (int i=0; i<n; ++i) {\n\t\tfor (int j=i+1; j<n; ++j) {\n\t\t\tif (e[i].coeff<e[i].coeff)\n\t\t\t\tswap(e[i], e[j]);\n\t\t}\n\n\t\tint pos = -1;\n\n\t\tfor (int j=0; j<m; ++j) {\n\t\t\tif (e[i].coeff[j]) {\n\t\t\t\tpos = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int j=i+1; j<n; ++j) {\n\t\t\tif (pos>-1 && e[j].coeff[pos]) {\n\t\t\t\tfor (int k=0; k<m; ++k)\n\t\t\t\t\te[j].coeff[k] ^= e[i].coeff[k];\n\t\t\t\te[j].val ^= e[i].val;\n\t\t\t}\n\t\t}\n\t}\n\t// PR0(e[0].coeff, m);\n\n\tint tmp = m;\n\n\tfor (int i=n-1; i>=0; --i)\n\t\ttmp -= (accumulate(e[i].coeff.begin(), e[i].coeff.end(), 0)>0);\n\t// debug(tmp);\n\n\tcout << pw(2, n-1) * (pw(2, m) - pw(2, tmp) + MOD) % MOD;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\treadInput();\n\tinitEquationSystem();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    bool a[n][m];\n    int r = 0;\n    for (int i = 0;i < n;++i) for (int j = 0;j < m;++j) cin >> a[i][j];\n    for (int i = 0;i < n;++i) {\n        int p = i,q = i;\n        for (int j = i;j < n;++j) {\n            if (a[p][q]) break;\n            for (int k = i;k < m;++k) if (a[j][k]) {\n                p = j;q = k;\n                break;\n            }\n        }\n        if (!a[p][q]) break;\n        r = i+1;\n        for (int j = i;j < n;++j) swap(a[j][i],a[j][q]);\n        for (int j = i;j < m;++j) swap(a[i][j],a[p][j]);\n        for (int j = i+1;j < n;++j) if (a[j][i]) for (int k = i;k < m;++k) a[j][k] ^= a[i][k];\n        for (int j = i+1;j < m;++j) if (a[i][j]) for (int k = i;k < n;++k) a[k][j] ^= a[k][i];\n    }\n    int x = 1,y = 1;\n    for (int i = 0;i < n+m-1;++i) {\n        x <<= 1;\n        x %= mod;\n    }\n    for (int i = 0;i < n+m-r-1;++i) {\n        y <<= 1;\n        y %= mod;\n    }\n    cout << (x-y+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ri register int\nconst int N=500005,M=998244353;\nint n,m,i,j,ans,vis[305];\nbitset<305> p[305],a[305];\nlong long qpow(long long a,long long b)\n{\n\tlong long s=a,ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*s%M;\n\t\ts=s*s%M;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\",&t);\n\t\t\ta[i][j-1]=t;\n\t\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=m-1;j>=0;--j)\n\t\t\tif(a[i][j])\n\t\t\t\tif(vis[j]==0)\n\t\t\t\t{\n\t\t\t\t\tp[j]=a[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvis[j]=1;\n\t\t\t\t\ta[i]^=p[j];\n\t\t\t\t}\n\t\tif(j<0)\n\t\t\tans++;\n\t}\n\tcout<<((qpow(2,n)-qpow(2,ans))*qpow(2,m-1)%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N,M;\nint A[303][303];\n\nint Gauss(){\n    int rank=0;\n    for(int j=0;j<M;j++){\n        int pivot=-1;\n        for(int i=rank;i<N;i++){\n            if(A[i][j]){\n                pivot=i;\n                break;\n            }\n        }\n\n        if(pivot>=0){\n            if(pivot!=rank){\n                for(int k=0;k<M;k++) swap(A[pivot][k],A[rank][k]);\n            }\n            for(int i=rank+1;i<N;i++){\n                if(A[i][j]){\n                    for(int k=0;k<M;k++) A[i][k]^=A[rank][k];\n                }\n            }\n            rank++;\n        }\n    }\n    return rank;\n}\n\nll my_pow(ll x,ll n){\n    ll res=1;\n    while(n>0){\n        if(n&1) res=res*x%MOD;\n        x=x*x%MOD;\n        n/=2;\n    }\n    return res;\n}\n\nint main(){\n  cin>>N>>M;\n  for(int i=0;i<N;i++) for(int j=0;j<M;++j) cin>>A[i][j];\n\n  int rank=Gauss();\n\n  cout<<my_pow(2ll,N-1+M)-my_pow(2ll,N-1+M-rank)<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\t// input\n\tint N, M;\n\tcin >> N >> M;\n\n\tbool A[300][300];\n\t\n\tfor (int row = 0; row < N; row++) {\n\t\tfor (int col = 0; col < M; col++) {\n\t\t\tint input;\n\t\t\tcin >> input;\n\t\t\tif (input == 1)A[row][col] = true;\n\t\t\telse A[row][col] = false;\n\t\t}\n\t}\n\n\n\t// calc\n\tint count = 0;\n\t\n\n\n\tfor (int row = 0; row < N; row++) {\n\t\tfor (int col = 0; col < M; col++) {\n\n\n\n\t\t\t//row,colを再左下とした部分集合を全探索\n\t\t\tfor (int r = row; r >= 0; r--) {\n\t\t\t\tfor (int c = col; c >= 0; c--) {\n\n\t\t\t\t\tbool flg = false;\n\n\t\t\t\t\tfor (int rr = r; rr <= row; rr++) {\n\t\t\t\t\t\tfor (int cc = c; cc <= col; cc++) {\n\t\t\t\t\t\t\tif(A[rr][cc]) flg = flg ^ A[rr][cc];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (flg) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcount %= 998244353;\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n\n\n\n\n\tcout << count;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        rank++;\n\n        for(int j = i+1; j < n; j++) if(mat[j][i]) {\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k];\n            }\n        }\n    }\n\n    return rank;\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\nconst long long mod = MOD;\nint qpow(int x, int n){ int y = 1; while(n){ if(n & 1) y = (ll) y * x % mod; x = (ll) x * x % mod; n >>= 1; } return y; }\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n\n    printf(\"%lld\\n\", ((qpow(2, n+m-1) - qpow(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _DEBUG\ntemplate <typename ... Args>\nvoid debugPrintf(const char *format, Args const & ... args) {\n\tfprintf(stdout, format, args ...);\n\tfflush(stdout);\n}\n#else\n#define debugPrintf(...)\n#endif\n\nconst int MOD = 998244353;\n\nusing bs = bitset<300>;\n\nll solve(vector<bs> v, const int m) {\n\tconst int n = sz(v);\n\n\tint removed = 0;\n\tFOR(j, m) {\n\t\tint found = -1;\n\t\tfor (int i = removed; i < n; i++) {\n\t\t\tif (v[i][j]) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found == -1) continue;\n\t\tswap(v[removed], v[found]);\n\t\tFOR(i, n) {\n\t\t\tif (i != removed && v[i][j]) {\n\t\t\t\tv[i] ^= v[removed];\n\t\t\t}\n\t\t}\n\t\tremoved++;\n\t}\n\n\tconst int freeColRows = n + m - removed * 2;\n\n\tPll ans = { 1,0 };\n\tFOR(i, removed) {\n\t\tPll nxt;\n\t\tnxt.second = (ans.first * 1 + ans.second * 3) % MOD;\n\t\tnxt.first = (ans.first * 3 + ans.second * 1) % MOD;\n\t\tans = nxt;\n\t}\n\tll ml = mod_pow(2, freeColRows, MOD);\n\n\treturn ans.second * ml % MOD;\n}\n\nll naive(vector<bs> v, const int m) {\n\tconst int n = sz(v);\n\n\tint ans = 0;\n\tFOR(a, 1 << n) FOR(b, 1 << m) {\n\t\tint x = 0;\n\t\tFOR(i, n) if (a & (1 << i)) FOR(j, m) {\n\t\t\tif (b & (1 << j)) {\n\t\t\t\tx ^= (int)v[i][j];\n\t\t\t}\n\t\t}\n\t\tif (x == 1) ans++;\n\t}\n\n\treturn ans;\n}\n\nvoid test() {\n\tfor(;;) {\n\t\tconst int n = 3, m = 3;\n\t\tvector<bs> v(n);\n\t\tFOR(i, n) FOR(j, m) if (rand() % 2) v[i][j] = 1;\n\t\tll a1 = solve(v, m);\n\t\tll a2 = naive(v, m);\n\t\tif (a1 != a2) {\n\t\t\tcout << \"?\";\n\n\t\t\tll a3 = solve(v, m);\n\t\t\tll a4 = naive(v, m);\n\t\t}\n\t}\n}\n\nint main() {\n\t// test();\n\n\tint n, m; reader(n, m);\n\tvector<bs> v(n);\n\tFOR(i, n) {\n\t\tFOR(j, m) {\n\t\t\tint x; reader(x);\n\t\t\tif (x == 1) v[i].set(j);\n\t\t}\n\t}\n\n\tll ans = solve(v, m);\n\twriterLn(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<bitset>\n#include<stack>\nusing namespace std;\n#define MOD 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nbitset<324> mat[324];\nInt cnt,n, m,a;\nInt mod_pow(Int x, Int a, Int m = MOD){\n  if(a == 0)return 1;\n  Int res = mod_pow(x, a / 2, m);\n  res = res * res % m;\n  if(a % 2)res *= x;\n  return res % m;\n}\n\nInt inv(Int x, Int m = MOD){\n  return mod_pow(x, m-2, m);\n}\n\n\nint main(){\n  cin >> n >> m;\n  for(int i = 0;i < n;i++){\n    for(int j = 0;j < m;j++){\n      cin >> a;\n      if(a)mat[i].set(j);\n    }\n  }\n\n  for(int i = 0;i < n;i++){\n    int st = i;\n    while(st < m && !mat[st][i])st++;\n    if(st == m)continue;\n    cnt++;\n    if(st != i)swap(mat[st], mat[i]);\n    for(int j = i;j < m;j++){\n      if(mat[j][i])mat[j] ^= mat[i];\n    }\n  }\n  cout << ((mod_pow(2, n+m) - mod_pow(2,n+m-cnt))*inv(2) % MOD+ MOD )% MOD << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 2500;\nconst int K = 19;\nint n, q;\nint mod = 998244353;\nint a[N][N], f[N], invf[N], used[N];\nvector < pair < int, int > > v;\nint binpow(int x, int y){\n    if (y == 0) return 1;\n    if (y % 2) return x * binpow(x, y - 1) % mod;\n    int z = binpow(x, y / 2);\n    return z * z % mod;\n}\nint c(int n, int k){\n    if (k < 0) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= m; j++) cin >> a[i][j];\n    }\n    int r = 0;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= m; j++){\n            if (a[i][j] != 0 && !used[j]){\n                used[j] = 1;\n                for (int l = 1; l <= m; l++){\n                    if (l != j && a[i][l] == 1){\n                        for (int k = 1; k <= n; k++){\n                            a[k][l] ^= a[k][j];\n                        }\n                    }\n                }\n                r++;\n                break;\n            }\n        }\n    }\n    cout << (binpow(2, n + m - 1) - binpow(2, n + m - 1 - r) + mod) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int Mx = 300;\nconst int mod = 998244353;\nll p2[Mx + 1];\n\ntypedef bitset<Mx> * It;\n\nbool bsLess(const bitset<Mx> &b1, const bitset<Mx> &b2) {\n\tfor (int i = Mx - 1; i >= 0; --i)\n\t\tif (b1[i] != b2[i])\n\t\t\treturn b2[i];\n\treturn false;\n}\n\nll f(It first, It last, const int pos) {\n\tif (pos < 0 || first == last) {\n\t\tassert(all_of(first, last, [](const bitset<Mx> &x) {\n\t\t\treturn x == 0;\n\t\t}));\n\t\treturn p2[last - first];\n\t}\n\n\tIt pLast = prev(last);\n\tif ((*pLast)[pos] == 0)\n\t\treturn f(first, last, pos - 1);\n\tfor (It it = first; it < pLast; ++it)\n\t\tif ((*it)[pos])\n\t\t\t*it ^= *pLast;\n\treturn f(first, pLast, pos - 1);\n}\n\nbitset<Mx> a[300];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i <= Mx; ++i)\n\t\tp2[i] = (p2[i - 1] * 2) % mod;\n\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = 0;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\ta[i][j] = x;\n\t\t}\n\t}\n\n\tsort(a, a + n, bsLess);\n\tll res = f(a, a + n, m - 1);\n\tcerr << res << endl;\n\tres = (p2[n] - res) * p2[m - 1];\n\tcout << (res % mod + mod) % mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\nusing std::cin; using std::cout;\nusing std::endl;\nusing std::bitset; using std::map;\nusing std::queue; using std::priority_queue;\nusing std::set; using std::string;\nusing std::stringstream; using std::vector;\nusing std::pair; using std::make_pair;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<ULL, ULL> puu;\n#ifdef DEBUG\nusing std::cerr;\n#define pass cerr << \"[\" << __FUNCTION__ << \"] : line = \" << __LINE__ << endl;\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)                                                     \\\n  {                                                                            \\\n    cerr << #a << \" = {\";                                                      \\\n    for (int qwq = (st); qwq <= (n); ++qwq)                                    \\\n      if (qwq == (st))                                                         \\\n        cerr << a[qwq];                                                        \\\n      else                                                                     \\\n        cerr << \", \" << a[qwq];                                                \\\n    cerr << \"}\" << endl;                                                       \\\n  }\n#define displayv(a) displaya(a, 0, (int)(a.size() - 1))\n#include <ctime>\nclass MyTimer {\n    clock_t st;\npublic:\n    MyTimer() { cerr << std::fixed << std::setprecision(0); reset(); }\n    ~MyTimer() { report(); }\n    void reset() { st = clock_t(); }\n    void report() {  cerr << \"Time consumed: \" << (clock() - st) * 1e3 / CLOCKS_PER_SEC << \"ms\" << endl; }\n} myTimer;\n#else\n#define cerr if(false) std::cout\n#define pass ;\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(a) ;\nclass MyTimer {\npublic: void reset() {} void report() {}\n} myTimer;\n#endif\n\ntemplate<typename A, typename B>\nstd::ostream& operator << (std::ostream &cout, const pair<A, B> &x) {\n    return cout << \"(\" << x.first << \", \" << x.second << \")\";\n}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) { return a > b ? a = b, true : false; }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) { return a < b ? a = b, true : false; }\n#ifndef LOCAL\nchar pool[1<<15|1],*it=pool+32768;\n#define getchar() (it>=pool+32768?(pool[fread(pool,sizeof(char),1<<15,stdin)]=EOF,*((it=pool)++)):*(it++))\n#endif\ninline int readint() {\n    int a = 0; char c = getchar(), p = 0;\n    while(isspace(c)) c = getchar();\n    if(c == '-') p = 1, c = getchar();\n    while(isdigit(c)) a = a*10 + c - '0', c = getchar();\n    return p ? -a : a;\n}\n\nconst int maxN = 300 + 5;\nconst int P = 998244353;\nint n, m;\nusing Bitset = bitset<maxN>;\nBitset a[maxN];\n\nint GaussianElimination() {\n    int i = 0, col = 0;\n    for(; i < n && col < m; ++ i, ++ col) {\n        int u = -1;\n        for(int j = i; j < n; ++ j)\n            if(a[j][col]) u = j;\n        if(u == -1) {\n            --i; continue;\n        }\n        else if(u != i) std::swap(a[i], a[u]);\n//        printf(\"pivot (%d, %d)\\n\", i, col);\n        for(int j = i + 1; j < n; ++ j)\n            if(a[j][col])\n                a[j] ^= a[i];\n    }\n    return i;\n}\n\nint pow2(int n) {\n    int ans = 1;\n    while(n --) (ans += ans) >= P ? ans -= P : 2333;\n    return ans;\n}\n\nint main() {\n    n = readint(); m = readint();\n    for(int i = 0; i < n; ++ i)\n        for(int j = 0; j < m; ++ j)\n            a[i][j] = readint();\n    int rk = GaussianElimination();\n    int a = pow2(n + m - 1), b = pow2(n + m - rk - 1);\n    a -= b;\n    if(a < 0) a += P;\n    cout << a << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,k,n) for(int i=k;i<=n;i++)\n#define rep2(i,k,n) for(int i=k;i>=n;i--)\n#define mod 998244353\nusing namespace std;\ninline void upd(int& x,int y){\n\tx+=y;\n\tx-= (x>=mod) ? mod : 0;\n}\nconst int N=305;\nint pw[N<<1],f[N],a[N][N],n,m;\nint main(){\n\tpw[0]=1;rep(i,1,600)pw[i]=pw[i-1],upd(pw[i],pw[i-1]);\n\trep(i,1,N-1)f[i]=pw[(i-1)<<1],upd(f[i],f[i-1]),upd(f[i],f[i-1]);\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n)rep(j,1,m)scanf(\"%d\",&a[i][j]);\n\tint r=0;\n\trep(i,1,m){\n\t\tint t=0;\n\t\trep(j,r+1,n)if(a[j][i]){t=j;break;}\n\t\tif(!t)continue;\n\t\tr++;\n\t\trep(j,1,m)swap(a[r][j],a[t][j]);\n\t\trep(j,r+1,n)if(a[j][i]){\n\t\t\trep(k,i,m)a[j][k]^=a[r][k];\n\t\t}\n\t}\n\tint ans=1ll*f[r]*pw[n-r]%mod*pw[m-r]%mod;\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n     \nconst int maxn(305);\nconst int mod(998244353);\n\ninline void Inc(int &x, int y) {\n    x = x + y >= mod ? x + y - mod : x + y;\n}\n\ninline void Dec(int &x, int y) {\n    x = x - y < 0 ? x - y + mod : x - y;\n}\n\ninline int Add(int x, int y) {\n    return x + y >= mod ? x + y - mod : x + y;\n}\n\ninline int Sub(int x, int y) {\n    return x - y < 0 ? x - y + mod : x - y;\n}\n\ninline int Pow(ll x, int y) {\n    ll ret = 1;\n    for (; y; y >>= 1, x = x * x % mod)\n        if (y & 1) ret = ret * x % mod;\n    return ret;\n}\n\nint n, m, ans, cnt, tot;\nbitset <maxn> a, b[maxn];\n\ninline void Insert() {\n\tint i;\n\tif (tot == m) return;\n\tfor (i = 1; i <= m; ++i)\n\t\tif (a[i]) {\n\t\t\tif (!b[i][i]) {\n\t\t\t\tb[i] = a, ++tot;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ta ^= b[i];\n\t\t}\n\treturn;\n}\n\nint main() {\n\tint i, j, v;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i <= n; ++i) {\n\t\ta.reset();\n\t\tfor (j = 1; j <= m; ++j) {\n\t\t\tscanf(\"%d\", &v);\n\t\t\tif (v) a.set(j);\n\t\t}\n\t\tInsert();\n\t}\n\tans = Pow(2, n), Dec(ans, Pow(2, n - tot));\n\tans = (ll)ans * Pow(2, m - 1) % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<math.h>\n#include<algorithm>\n#include<numeric>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<ULL> VULL;\n\nclass MYCP {\npublic:\n\n\t//数値を区切って文字列にする\n\tstatic string MakeString_LongLong(vector<long long> const& numbers, string const& str) {\n\t\tif (numbers.size() == 0)return \"\";\n\t\tstring result = \"\" + to_string(numbers[0]);\n\t\tfor (long long i = 1; i < numbers.size(); i++) {\n\t\t\tresult += str;\n\t\t\tresult += to_string(numbers[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//空白で区切る為のオーバーロード\n\tstatic string MakeString_LongLong(vector<long long> const& numbers) {\n\t\tif (numbers.size() == 0)return \"\";\n\t\tstring result = \"\" + to_string(numbers[0]);\n\t\tfor (long long i = 1; i < numbers.size(); i++) {\n\t\t\tresult += \" \";\n\t\t\tresult += to_string(numbers[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\n\n\t//文字列の配列を改行を挟んでまとめる\n\tstatic string MakeString_VectorString(vector<string> const& str) {\n\t\tstring result = \"\";\n\t\tfor (long long i = 0; i < str.size(); i++) {\n\t\t\tresult += str[i] + \"\\n\";\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//文字列を必要な個数だけ読み取る\n\tstatic vector<string> MyReadLineSplit(LL n) {\n\t\tvector<string> str(n);\n\t\tfor (long long i = 0; i < n; i++) {\n\t\t\tstd::cin >> str[i];\n\t\t}\n\n\t\treturn str;\n\t}\n\n\t//数値を必要な個数だけ読み取る\n\tstatic vector<long long> ReadInts(long long number) {\n\t\tvector<long long> a(number);\n\t\tfor (int i = 0; i < number; i++) {\n\t\t\tstd::cin >> a[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t//渡された自然数が素数ならtureを返す\n\tstatic bool PrimeCheck_Int(long long number) {\n\t\tif (number < 2)return false;\n\n\t\tfor (ULL i = 2; i*i <= number; i++) {\n\t\t\tif (number%i == 0)return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t//渡された数値以下の素数表を作る\n\tstatic vector<long long> MakePrimeList(long long n) {\n\t\tvector<long long> list;\n\t\tLL i, j, p;\n\t\tbool flag;\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tflag = true;\n\t\t\tfor (j = 0; j < list.size(); j++) {\n\n\t\t\t\tif (!(list[j] * list[j] <= i))break;\n\n\t\t\t\tif (i%list[j] == 0) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)list.push_back(i);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\n\n\t//文字列の分割\n\tstatic vector<string> split(string const& str, char sep)\n\t{\n\t\tvector<std::string> v;        // 分割結果を格納するベクター\n\t\tauto first = str.begin();              // テキストの最初を指すイテレータ\n\t\twhile (first != str.end()) {         // テキストが残っている間ループ\n\t\t\tauto last = first;                      // 分割文字列末尾へのイテレータ\n\t\t\twhile (last != str.end() && *last != sep)       // 末尾 or セパレータ文字まで進める\n\t\t\t\tlast++;\n\t\t\tv.push_back(string(first, last));       // 分割文字を出力\n\t\t\tif (last != str.end())\n\t\t\t\tlast++;\n\t\t\tfirst = last;          // 次の処理のためにイテレータを設定\n\t\t}\n\t\treturn v;\n\t}\n\n\t//合計を求める\n\tstatic LL Sum(vector<LL> a) {\n\t\tLL i, sum = 0;\n\n\t\tfor (i = 0; i < a.size(); i++) {\n\t\t\tsum += a[i];\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\t//小文字ならtrueを返す\n\tstatic bool Komoji(char a) {\n\t\tif (a >= 'a'&&a <= 'z')return true;\n\n\t\treturn false;\n\t}\n\n\t//大文字ならtrueを返す\n\tstatic bool Oomoji(char a) {\n\t\tif (a >= 'A'&&a <= 'Z')return true;\n\n\t\treturn false;\n\t}\n\n\tstatic LL GreatestCommonFactor(LL a, LL b) {\n\t\tLL temp;\n\t\tif (a < b) {\n\t\t\ttemp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\twhile (true)\n\t\t{\n\t\t\ttemp = a % b;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\tif (b == 0)break;\n\t\t}\n\n\t\treturn a;\n\t}\n\n\tstatic LL LeastCommonMultiple(LL a, LL b) {\n\t\treturn (a / GreatestCommonFactor(a, b))*b;\n\t}\n\n};\n\n//累積和を求めるクラス\nclass Syakutori {\nprivate:\n\tvector<LL> list;\n\npublic:\n\n\tvoid MakeArray(vector<LL> data) {\n\t\tLL i;\n\t\tlist = data;\n\t\tlist.push_back(0);\n\t\tlist[0] = 0;\n\t\tfor (i = 1; i < list.size(); i++) {\n\t\t\tlist[i] = list[i - 1] + data[i - 1];\n\t\t}\n\n\t}\n\n\tLL Sum(LL start, LL end) {\n\t\tif (end < start) {\n\t\t\tcout << \"startがendより大きいです\";\n\t\t\treturn 0;\n\t\t}\n\t\tif (start < 0 || end >= list.size()) {\n\t\t\tcout << \"範囲が異常\";\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn list[end] - list[start];\n\t}\n\n\n\n\n};\n\nstring strnum = \"0123456789\";\nstring alpS = \"abcdefghijklmnopqrstuvwxyz\";\nstring alpL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nint sizealp = (int)(alpS.size());\nint mod = 1e9 + 7;\n\nint main(void) {\n\tint a[3], b[3];\n\tfor (int i = 0; i < 3; i++)\n\t\tcin >> a[i] >> b[i];\n\tint baketu[5] = {0};\n\tfor (int i = 0; i < 3; i++) {\n\t\tbaketu[a[i]] += a[i] / a[i];\n\t\tbaketu[b[i]] += b[i] / b[i];\n\t}\n\tfor (int i = 0; i < 5; i++) {\n\t\tif (baketu[i] == 3) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 998244353LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                // C[i][j] += A[i][k] * B[k][j]; // modなし\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// Matrix Library End\n\n// N * M 行列のランクを求める\ntemplate <typename T>\nint mat_rank(Matrix<T> A) {\n    int N = A.size(), M = A[0].size();\n\n    int WID = min(N, M), res = 0;\n    for(int i=0; i<WID; i++) {\n        // 絶対値が最も大きいものを探す\n        T max_elem = 0; int piv = -1;\n        for(int j=res; j<N; j++) {\n            if(abs(A[j][i]) > max_elem) {\n                max_elem = abs(A[j][i]);\n                piv = j;\n            }\n        }\n\n        fprintf(stderr, \"# piv = %lld\\n\", piv);\n        if(piv < 0) continue;\n            \n        // i 行目を piv 行目に変えて、行基本変形\n        swap(A[i], A[piv]);\n        res++;\n\n        fprintf(stderr, \"# matrix debug\\n\");\n        for(int x=0; x<N; x++) {\n            for(int y=0; y<M; y++) {\n                fprintf(stderr, \"%lld \", A[x][y]);\n            }\n            fprintf(stderr, \"\\n\");\n        }\n            \n        for(int j=0; j<N; j++) {\n            if(i == j) continue;\n            assert(A[i][i] != 0);\n            double ratio = 1.0 * A[j][i] / A[i][i];\n            for(int k=0; k<M; k++) {\n                A[j][k] = (T)(A[j][k] - ratio * A[i][k]);\n            }\n        }\n    }\n    return res;\n}\n\nconst int MAXN = 610;\nint pow2[MAXN + 10];\nsigned main() {\n    pow2[0] = 1;\n    for(int i=1; i<=MAXN; i++) pow2[i] = (pow2[i-1] * 2) % MOD;\n    \n    int N, M; cin >> N >> M;\n    Matrix<int> mat;\n    init_mat(mat, N, M);\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            cin >> mat[i][j];\n        }\n    }\n\n    int rank = mat_rank(mat);\n    int ansA = pow2[N + M - 1];\n    int ansB = pow2[N + M - rank - 1];\n    fprintf(stderr, \"matrix rank = %lld\\n\", rank);\n    printf(\"%lld\\n\", (ansA - ansB + MOD) % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        rank++;\n\n        int fs = mat[i][i];\n\n        for(int j = i+1; j < n; j++) {\n            int r = mat[j][i] / fs;\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k] * r;\n            }\n        }\n    }\n\n    return rank;\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    if(b == 1) return a;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<bitset>\nusing namespace std;\nint gi(){\n\tint x=0,w=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')w=0,ch=getchar();\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\nconst int N=305;\nconst int mod=998244353;\nint n,m,r,bin[N];bitset<N>p[N];\nvoid insert(bitset<N>x){\n\tfor(int j=1;j<=m;++j)\n\t\tif(x[j])\n\t\t\tif(p[j][j])x^=p[j];\n\t\t\telse{p[j]=x;++r;return;}\n}\nint main(){\n\tn=gi();m=gi();\n\tfor(int i=1;i<=n;++i){\n\t\tbitset<N>x;x.reset();\n\t\tfor(int j=1;j<=m;++j)x[j]=gi();\n\t\tinsert(x);\n\t}\n\tfor(int i=bin[0]=1;i<N;++i)bin[i]=(bin[i-1]<<1)%mod;\n\tprintf(\"%lld\\n\",1ll*(bin[n]-bin[n-r]+mod)*bin[m-1]%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n2 2\n0 1\n1 0\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=305;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nbitset<maxn> b[maxn];\n\nbitset<maxn> head[maxn];\nbool vis[maxn];\nint main()\n{\n\tIOS;\n\tint n,m;\n\tcin>>n>>m;\n\tREP(i,n) REP(j,m){\n\t\tbool tmp;\n\t\tcin>>tmp;\n\t\tb[i][j]=tmp;\n\t}\n\n\tint cnt=0;\n\tREP(i,n){\n\t\tbool flag=0;\n\t\tfor(int j=m-1;j>=0;j--) if(b[i][j]){\n\t\t\tif(vis[j]){\n\t\t\t\tb[i]^=head[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvis[j]=1;\n\t\t\t\thead[j]=b[i];\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) cnt++;\n\t}\n\n\tcout<<(mypow(2,n)-mypow(2,cnt)+MOD)*(mypow(2,m-1))%MOD<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(0);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(0);\n        for(; j < n; ++j)if(i ^ j && a[j][now])for(int k = 0; k < m; ++k)a[j][k] ^= a[i][k];\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> a[333];\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i].resize(m);\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t}\n\tint p = 998244353;\n\tint r = [](vector<int> *m, int R, int C) {\n\t\tint i = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tint k;\n\t\t\tfor (k = i; k < R; k++)\n\t\t\t\tif (m[k][j]) goto p;\n\t\t\tcontinue;\n\t\tp:\n\t\t\tswap(m[k], m[i]);\n\t\t\tfor (k = 0; k < R; k++)\n\t\t\t\tif (k != i && m[k][j])\n\t\t\t\t\tfor (int l = j; l < C; l++)\n\t\t\t\t\t\tm[k][l] ^= m[i][l];\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}(a, n, m);\n\tint x = 0;\n\tfor (int i : {0, r}) {\n\t\tint y = 1;\n\t\tfor (int j = 0; j < n + m - 1 - i; j++)\n\t\t\t(y += y) %= p;\n\t\t(x += i ? p - y : y) %= p;\n\t}\n\tcout << x << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdlib>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef long double ld;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\nconst int mod = 998244353;\n\nll mpow(ll x, ll n) {\n  ll res = 1;\n  while (n) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n /= 2;\n  }\n  return res;\n}\n\nint main() {\n  //mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<bitset<301>> v(n);\n  for (int i = 0; i < n; ++i) {\n    v[i].reset();\n    for (int j = 0; j < m; ++j) {\n      int t;\n      cin >> t;\n      v[i][j] = t;\n    }\n  }\n  int r = 0;\n  for (int j = 0; j < m && r < n; ++j) {\n    for (int i = r + 1; i < n; ++i) if (v[i][j]) {\n      swap(v[r], v[i]);\n      break;\n    }\n    if (!v[r][j]) continue;\n    for (int i = r + 1; i < n; ++i) if (v[i][j]) v[i] ^= v[r];\n    ++r;\n  }\n  cerr << r << endl;\n  ll res = mpow(2, m + n - 1) - mpow(2, n + m - r - 1);\n  cout << (res % mod + mod) % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mo 998244353\n#define N 310\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nll a[N][N],p[N][N];\nll m,n,sum;\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nint main(){\n\tread(n);read(m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)read(a[i][j]);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=m;j>=1;j--){\n\t\t\tif (p[j][j]==0){\n\t\t\t\tif (a[i][j]==1){\n\t\t\t\t\tfor (int k=1;k<=j;k++) p[j][k]=a[i][k];\n\t\t\t\t\tsum++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif (a[i][j]==1)for (int k=1;k<=j;k++) a[i][k]^=p[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<((po(2,n)-po(2,n-sum)+mo)%mo)*po(2,m-1)%mo<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bitset>\n#include<cstdio>\n#include<algorithm>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\nusing namespace std;\n\nconst int N=510,mod=998244353;\nint n,m,y,rk,ans,a[N][N],pw[N];\nbitset<N> b[N];\n\nint main(){\n\tscanf(\"%d%d\",&n,&m); pw[0]=1;\n\trep(i,1,n){\n\t\tbitset<N>x(0);\n\t\trep(j,1,m) scanf(\"%d\",&y),x[j-1]=y;\n\t\tfor(int j=m-1; ~j; j--)\n\t\t\tif (x[j]){\n\t\t\t\tif (b[j].any()) x^=b[j];\n\t\t\t\t else{ b[j]=x; break; }\n\t\t\t}\n\t}\n\trep(i,1,max(n,m)) pw[i]=2*pw[i-1]%mod;\n\trep(i,0,m-1) if (b[i].any()) rk++;\n\tans=1ll*(pw[n]-pw[n-rk])*pw[m-1]%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n\n#define cMOD 998244353ULL\n#define cINF ((1ull<<62)-1)\n#define cINFINT ((1<<30)-1)\n\n\ntemplate <typename T>\nvoid calcFactional_mod( size_t size, \n\tvector<T>& fac, vector<T>& inv, vector<T>& facInv, T mod )\n{\n\tfor( T i = 2; i < size; ++i )\n\t{\n\t\tfac[i] = fac[i - 1] * i % mod; // n! % mod\n\t\tinv[i] = mod - inv[mod % i] * ( mod / i ) % mod; // 逆元計算 (n)^-1 % mod\n\t\tfacInv[i] = facInv[i - 1] * inv[i] % mod; // (n!)^-1 % mod\n\t}\n}\ntemplate <typename T>\nT pow_mod(T x, T n, T mod)\n{\n\tT res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (res * x) % mod;\n\t\tx = (x * x) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\ntemplate< typename T >\nclass Matrix\n{\npublic:\n\texplicit Matrix( size_t row_size, size_t col_size )\n\t{\n\t\tassign( row_size, col_size );\n\t}\n\n\tvoid assign( size_t row_size, size_t col_size )\n\t{\n\t\tmElement.assign( row_size, vector<T>() );\n\t\tREP( i, row_size ) mElement[i].assign( col_size, T(0) );\n\t}\n\n\tconst vector<T>& operator[] ( size_t row ) const\n\t{ return mElement[row]; }\n\tvector<T>& operator[] ( size_t row )\n\t{ return mElement[row]; }\n\n\tconst size_t rowSize() const\n\t{ return mElement.size(); }\n\tconst size_t colSize() const\n\t{ return mElement[0].size(); }\n\n\t/*T get( size_t row, size_t col ) const\n\t{ return mElement[row][col]; }\n\tvoid set( size_t row, size_t col, T value )\n\t{ mElement[row][col] = value; }*/\n\n\tMatrix<T> operator* ( const Matrix& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.rowSize() );\n\t\tMatrix ret( this->rowSize(), rhs.colSize() );\n\t\tREP( i, ret.rowSize() )\n\t\tREP( k, k_ )\n\t\tREP( j, ret.colSize() )\n\t\t\tret[i][j] = ret[i][j] + (*this)[i][k] * rhs[k][j];\n\t\treturn ret;\n\t}\n\n\tvector<T> operator* ( const vector<T>& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.size() );\n\t\tvector<T> ret( this->rowSize(), T() );\n\t\tREP( i, ret.size() )\n\t\tREP( k, k_ )\n\t\t\tret[i] = ret[i] + (*this)[i][k] * rhs[k];\n\t\treturn ret;\n\t}\n\n\t// O( N^3 )\n\t// Ax = b を解く\n\t// T = double にしないと割り算で狂うので注意\n\tstruct GaussJordanData\n\t{\n\t\tint rank = 0;\n\t\tint result = 0; // -1:解なし 0:不定 1:解あり\n\t\tvector<T> solution;\n\t};\n\tGaussJordanData gaussJordan() const\n\t{\n\t\tvector<T> b( rowSize(), 0 );\n\t\treturn gaussJordan( b );\n\t}\n\tGaussJordanData gaussJordan( const vector<T>& b ) const\n\t{\n\t\tGaussJordanData data;\n\t\tdata.result = 1;\n\n\t\t// 1列余分に取って、そこにbを入れる\n\t\tMatrix<T> B( rowSize(), colSize() + 1 );\n\t\tREP( i, rowSize() ) REP( j, colSize() + 1 )\n\t\t{\n\t\t\tif( j < colSize() ) B[i][j] = (*this)[i][j];\n\t\t\telse B[i][j] = b[i];\n\t\t}\n\n\t\tfor( int i = 0, j = 0; i < rowSize() && j < colSize(); ++i, ++j )\n\t\t{\n\t\t\t// j列目の値の絶対値が大きい行をi行目に持ってくる\n\t\t\tsize_t pivot = i;\n\t\t\tfor( int k = i + 1; k < rowSize(); ++k )\n\t\t\t\tif( abs( B[k][j] )> abs( B[pivot][j] ) ) pivot = k;\n\t\t\tswap( B[i], B[pivot] );\n\t\t\t// 解が一意でない\n\t\t\tif( abs( B[i][j] ) <= numeric_limits<T>::epsilon() )\n\t\t\t{\n\t\t\t\t--i;\n\t\t\t\tdata.result = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Rankを1増やす\n\t\t\t++data.rank;\n\t\t\t// [i][j]を1にするようにi行目を割る\n\t\t\tfor( int l = j + 1; l <= colSize(); ++l )\n\t\t\t\tB[i][l] /= B[i][j];\n\t\t\tB[i][j] = 1;\n\t\t\t// k番目の行からi番目の行を引いて、j番目の列の数を消去\n\t\t\tREP( k, rowSize() ) if( k != i )\n\t\t\t{\n\t\t\t\tT coef = B[k][j];\n\t\t\t\tfor( int l = j; l <= colSize(); ++l )\n\t\t\t\t\tB[k][l] -= coef * B[i][l];\n\t\t\t}\n\t\t}\n\n\t\t// 解xを作る\n\t\tdata.solution.assign( colSize(), T() );\n\t\tfor( int i = 0, j = 0; j < colSize(); ++i, ++j )\n\t\t{\n\t\t\tif( i >= rowSize() || B[i][j] == 0 )\n\t\t\t{\n\t\t\t\tdata.solution[j] = 0;\n\t\t\t\t--i; continue;\n\t\t\t}\n\t\t\telse data.solution[j] = *( B[i].rbegin() );\n\t\t}\n\n\t\t// 解なしかをチェック\n\t\tif( data.result == 0 || ( data.rank ) < b.size() )\n\t\t{\n\t\t\tauto m = ( *this ) * data.solution;\n\t\t\tREP( i, m.size() ) if( m[i] != b[i] )\n\t\t\t{ data.result = -1; break; }\n\t\t}\n\t\tif( data.result != -1 )\n\t\t{\n\t\t\t// 解が一意\n\t\t\tif( data.rank == colSize() ) data.result = 1;\n\t\t\t// 解が不定\n\t\t\telse data.result = 0;\n\t\t}\n\t\t\n\t\treturn data;\n\t}\n\nprotected:\n\tvector<vector<T>> mElement;\n};\n\n\nint main()\n{\n\tauto mod = cMOD;\n\tauto add = [mod]      ( ll a, ll b ) { return ( a + b ) % mod; };\n\tauto sub = [mod]      ( ll a, ll b ) { return ( a + mod -b ) % mod; };\n\tauto mul = [mod]      ( ll a, ll b ) { return a * b % mod; };\n\tauto pow = [mod]      ( ll a, ll b ) { return pow_mod<ll>( a, b, mod ); };\n\t\n\tll n, m; cin >> n >> m;\n\tMatrix<int> mtx( n, m );\n\tREP( i, n ) REP( j, m ) cin >> mtx[i][j];\n\t\n\tauto data = mtx.gaussJordan();\n\tauto ans = sub( pow( 2, n + m - 1 ), pow( 2, n + m - data.rank - 1 ) );\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"out2.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n#define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \n// void bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid amax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid amin(T& x, T y) {\n    x = min(x, y);\n}\n\n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-12;\nconst int maxn = 5e4 + 3, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst int base2 = 998244353;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % base2;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % base2;\n    }\n}\n\nconst int N = 305;\n\nint gauss (vector < bitset<N> > a, int n, int m) {    \n    int rank = min(n, m);\n    vector<char> line_used (n);\n    for (int i=0; i<m; ++i) {\n        int j;\n        for (j=0; j<n; ++j)\n            if (!line_used[j] && a[j][i])\n                break;\n        if (j == n)\n            --rank;\n        else {\n            line_used[j] = true;\n            for (int k=0; k<n; ++k)\n                if (k != j && a[k][i])\n                    a[k] ^= a[j];\n        }\n    }\n    return rank;\n}\n\nint main() {\n    // files1;\n\n    int n, m;\n    cin >> n >> m;\n    vector<bitset<N> > a(n);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            bool x;\n            cin >> x;\n            a[i][j] = x;\n        }\n\n    int r = gauss(a, n, m);\n    cout << ((binpow(2, n + m - 1) - binpow(2, n + m - r - 1)) % base2 + base2) % base2;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,a[305][305];\n\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>a[i][j];\n\tint nxt = 1;\n\tfor(int j=1;j<=m;j++){\n\t\tint pck = -1;\n\t\tfor(int x=nxt;x<=n;x++){\n\t\t\tif(a[x][j] == 1){\n\t\t\t\tpck = x; break;\n\t\t\t}\n\t\t}\n\t\tif(pck == -1) continue;\n\t\trepn(j,m) swap(a[nxt][j],a[pck][j]);\n\t\tfor(int x=1;x<=n;x++){\n\t\t\tif(a[x][j] == 1){\n\t\t\t\tfor(int jj=1;jj<=m;jj++){\n\t\t\t\t\ta[x][jj] ^= a[pck][jj];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnxt++;\n\t}\n\tint ans = n+1-nxt;\n\tll A = 1;\n\trep(i,ans) A = A*2LL%mod;\n\trep(i,m-1) A = A*2LL%mod;\n\tll B = 1;\n\trep(i,n+m-1) B = B*2LL%mod;\n\tB -= A;\n\tcout << (B%mod+mod)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <tuple>\ntemplate <typename T> constexpr T my_abs(const T &x) { return x < 0 ? -x : x; }\nusing ll = long long;\nconstexpr int MOD = 998244353;\ninline int quick_pow(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (ll)res * a % MOD;\n\t\ta = (ll)a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint fact[305], inv[305], arr[305][305], dp[305];\ninline int C(int n, int m) { return (ll)fact[n] * inv[m] % MOD * inv[n - m] % MOD; }\nint main()\n{\n\t// freopen(\"yahoo2019-E.in\", \"r\", stdin);\n\tint n, m, k = 0, ans = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tscanf(\"%d\", arr[i] + j);\n\t}\n\tfact[0] = inv[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD;\n\t\tinv[i] = quick_pow(fact[i], MOD - 2);\n\t}\n\tfor (int col = 0; col < m; col++)\n\t{\n\t\tint row = k;\n\t\twhile (row < n && !arr[row][col])\n\t\t\trow++;\n\t\tif (row >= n)\n\t\t\tcontinue;\n\t\tstd::swap(arr[row], arr[k]);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (!arr[i][col] || i == k)\n\t\t\t\tcontinue;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tarr[i][j] ^= arr[row][j];\n\t\t}\n\t\tk++;\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tsum += arr[i][j];\n\t\tfor (int j = m - sum; j >= 0; j--)\n\t\t\t(dp[j + sum] += dp[j]) %= MOD;\n\t}\n\tfor (int i = 0; i <= m; i++)\n\t{\n\t\tint coef = 0;\n\t\tfor (int j = 1; j <= i; j += 2)\n\t\t\t(coef += C(i, j)) %= MOD;\n\t\tans = (ans + (ll)dp[i] * coef % MOD * quick_pow(2, m - i)) % MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = rank; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        rank++;\n\n        for(int j = i+1; j < n; j++) if(mat[j][i]) {\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k];\n            }\n        }\n    }\n\n    return rank;\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nconst int MD = 998244353;\nusing ll = long long;\nint n, m, a, t;\nbitset<305> bt[305];\nll e(ll n){\n\tll res = 1;\n\tfor(ll b = 2; n; n/=2,(b*=b)%=MD) if(n%2) (res *= b) %= MD;\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\trep(i,n) rep(j,m){\n\t\tscanf(\"%d\", &a);\n\t\tbt[i][j] = a;\n\t}\n\trep(i,m){\n\t\tfor(int j = t+1; j < n; j++) if(bt[j][i]){\n\t\t\tif(bt[t][i]) bt[j] ^= bt[t];\n\t\t\telse swap(bt[t], bt[j]);\n\t\t}\n\t\tif(bt[t][i]) t++;\n\t}\n\tprintf(\"%lld\\n\", (e(m) - e(m-t) + MD) * e(n-1) % MD);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nbitset <20> dp[333];\nint a[333][333];\nint n, m;\nconst int mod = 998244353;\n\nlong long ans[333];\nlong long pw[333];\n\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%d %d\", &n, &m);\n\tpw[0] = 1;\n\tfor(int i = 1; i <= max(n, m); i++) {\n\t\tpw[i] = pw[i - 1] << 1;\n\t\tpw[i] %= mod;\n\t} \n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\tfor(int j = 0; j < m; j++) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdp[i].reset();\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int x = 0; x <= j; x++) {\n\t\t\t\tdp[i][x] = a[i][x];\n\t\t\t}\n\t\t}\n\t\tint ptr = 0;\n\t\tfor(int x = 0; x <= j; x++) {\n\t\t\tfor(int i = ptr; i < n; i++) {\n\t\t\t\tif(dp[i][x] == 1) {\n\t\t\t\t\tswap(dp[i], dp[ptr]);\n\t\t\t\t\tfor(int k = ptr + 1; k < n; k++) {\n\t\t\t\t\t\tif(dp[k][x] == 1) {\n\t\t\t\t\t\t\tdp[k] ^= dp[ptr];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++ptr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[j] = 1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(dp[i].count() == 0) {\n\t\t\t\tans[j] <<= 1;\n\t\t\t\tans[j] %= mod;\n\t\t\t}\n\t\t}\n\t\t// printf(\"%lld\\n\", ans[j]);\n\t}\n\tlong long res = pw[m-1] * (pw[n] - ans[0]);\n\tres %= mod;\n\tif(res < 0) res += mod;\n\tfor(int i = 1; i < n; i++) {\n\t\tres += pw[m-1] * (ans[i - 1] - ans[i]);\n\t\tres %= mod;\n\t\tif(res < 0) res += mod;\n\t}\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint H, W;\nlong long mod = 998244353;\nvector<int> A[309];\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tA[i].resize(W, 0);\n\t\tfor (int j = 0; j < W; j++) cin >> A[i][j];\n\t}\n\tsort(A, A + H);\n\n\tfor (int i = W - 1; i >= 0; i--) {\n\t\tint pos = 0;\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tint cnt = 0; for (int k = i + 1; k < W; k++) { if (A[j][k] == 1) cnt++; }\n\t\t\tif (cnt == 0) { pos = j; }\n\t\t}\n\t\tfor (int j = pos - 1; j >= 0; j--) {\n\t\t\tfor (int k = 0; k < W; k++) A[j][k] ^= A[pos][k];\n\t\t}\n\t\tsort(A, A + H);\n\t}\n\n\tvector<int> ZERO(W, 0);\n\tlong long v = 1;\n\tfor (int i = 0; i < H; i++) {\n\t\tif (A[i] == ZERO) { v *= 2; v %= mod; }\n\t}\n\tlong long p = 1; for (int i = 0; i < H; i++) { p *= 2; p %= mod; }\n\tlong long q = 1; for (int i = 0; i < W; i++) { q *= 2; q %= mod; }\n\tlong long r = (p - v + mod)*q%mod;\n\tif (r % 2 == 1) r += mod; r /= 2;\n\tcout << r << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nll modpow(ll x, ll n){\n    ll res = 1;\n    ll mul = x;\n    while(n){\n        if(n % 2) res = res * mul % MOD;\n        mul = mul * mul % MOD;\n        n /= 2;\n    }\n    return res;\n}\n\nstruct Combination\n{\n    int maxn;\n    vector<ll> fmemo;\n    vector<ll> imemo;\n    vector<ll> ifmemo;\n    \n    Combination(int maxn) : maxn(maxn){\n        fmemo.resize(maxn + 1);\n        imemo.resize(maxn + 1);\n        ifmemo.resize(maxn + 1);\n        for(ll i = 1; i <= maxn; i++){\n            imemo[i] = modpow(i, MOD - 2);\n        }\n    }\n\n    ll fact(ll n){\n        if(n == 0) return 1;\n        if(fmemo[n]) return fmemo[n];\n        return fmemo[n] = n * fact(n - 1) % MOD;\n    }\n\n    ll ifact(ll n){\n        if(n == 0) return 1;\n        if(ifmemo[n]) return ifmemo[n];\n        return ifmemo[n] = imemo[n] * ifact(n - 1) % MOD;\n    }\n\n    ll com(ll n, ll k){\n        if(k > n) return 0;\n        if(k == n || k == 0) return 1;\n        return (fact(n) * ifact(k) % MOD) * ifact(n - k) % MOD;\n    }\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int a[302][302];\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++) cin >> a[i][j];\n    }\n    bool b[302]{0};\n    for(int j = 0; j < m; j++){\n        for(int i = 0; i < n; i++){\n            if(b[i]) continue;\n            if(a[i][j]){\n                b[i] = true;\n                for(int k = i + 1; k < n; k++){\n                    if(!a[k][j]) continue;\n                    for(int l = j; l < m; l++) a[k][l] ^= a[i][l];\n                }\n                break;\n            }\n        }\n    }\n    int r = 0;\n    for(int i = 0; i < n; i++) r += b[i];\n    Combination com(n + m + 1);\n    ll ans = 0;\n    for(int j = 1; j <= r; j += 2){\n        ans = (ans + com.com(r, j) * modpow(3, r - j) % MOD * modpow(2, n + m - r * 2)) % MOD;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 305;\nconst int MOD = 998244353;\nbitset<N> a[N]; \nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile(k) {\n\t\tif(k&1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD; \n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = m-1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t) a[i].flip(j);\n\t\t}\n\t}\n\tcout << (a[0]^a[1]) << endl;\n \tfor (int i = 0; i < n; i++) {\n \t\tfor (bitset<N> b : base) {\n \t\t\tbitset<N> bb = b^a[i];\n \t\t\tfor (int j = m-1; j >= 0; j--) {\n \t\t\t\tif(bb[j] < a[i][j]) {\n \t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t }\n\t\t\t}\n\t\t }\t\n\t\t if(a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", ((q_pow(2, n+m-1) - q_pow(2, n+m-1-cnt)) % MDO+ MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\n\n\nusing BS=bitset<333>;\n\nBS a[333];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,m;\n\tcin>>n>>m;\n\trep(i,n){\n\t\ta[i].reset();\n\t\trep(j,m){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x) a[i]|=1<<j;\n\t\t}\n\t}\n\tint o=0;\n\trep(j,m){\n\t\tint tmp=-1;\n\t\treps(i,o,n)if(a[i][j]){\n\t\t\ttmp=i; break;\n\t\t}\n\t\tif(tmp<0) continue;\n\t\tif(o!=tmp) swap(a[o],a[tmp]);\n\t\trep(i,n)if(i!=o && a[i][j]) a[i]^=a[o];\n\t\t++o;\n\t}\n\t// rep(i,n){rep(j,m) cout<<a[i][j];cout<<endl;}\n\tmint ker=1;\n\trep(i,n)if(a[i].count()==0) ker+=ker;\n\tout(ker,1);\n\tmint re=modpow(2,m-1);\n\tcout<<re*(modpow(2,n)-ker)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbitset<305> a[305],b;\nint n,m,i,j,pw[305],mod=998244353,cnt;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tpw[0]=1;\n\tfor (i=1;i<=300;i++) pw[i]=pw[i-1]*2ll%mod;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tb.reset();\n\t\tfor (j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tb[j]=x;\n\t\t}\n\t\tfor (j=m;j>=1;j--)\n\t\t{\n\t\t\tif (b[j])\n\t\t\t{\n\t\t\t\tif (a[j].any())\n\t\t\t\t{\n\t\t\t\t\tb^=a[j];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[j]=b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (j<1) cnt++;\n\t}\n\tcout<<(((pw[n]-pw[cnt])*pw[m-1]%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 998244353;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M;\n    cin >> N >> M;\n    vvec<int> A(N,vec<int>(M));\n    for(int i=0;i<N;i++) for(int j=0;j<M;j++) cin >> A[i][j];\n    vec<mint> pow2(max(N,M)+1,1);\n    for(int i=1;i<=max(N,M);i++) pow2[i] = pow2[i-1]*2;\n    int rank = 0;\n    for(int j=0;j<M;j++){\n        bool update = false;\n        for(int i=rank;i<N;i++) if(A[i][j]){\n            swap(A[i],A[rank]);\n            update = true;\n            break;\n        }\n        if(update){\n            for(int i=0;i<N;i++) if(i!=rank && A[i][j]){\n                for(int k=j;k<M;k++) A[i][k] ^= A[rank][k];\n            }\n            rank++;\n        }\n    }\n//    cerr << rank << \"\\n\";\n//    for(int i=0;i<N;i++) for(int j=0;j<M;j++) cerr << A[i][j] << (j!=M-1? \" \":\"\\n\");\n    cout << pow2[N-1]*(pow2[M]-pow2[M-rank]) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst ll INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//ll MOD = 998244353;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A, ll x = 20){cout << fixed << setprecision(x) << A << endl;}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n\n//コンビネーション\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\n\nll Rank(ll N, ll M, vector<vector<ll>> A){\n  ll next = 0;\n  rep(i, M){\n    for(ll j = next; j < N; j++){\n      if(A[j][i]){\n        swap(A[next], A[j]);\n      }\n    }\n    if(!A[next][i]) continue;\n    rep(j, N)if(j != next){\n      if(A[j][i]){\n        rep(k, M) A[j][k] ^= A[next][k];\n      }\n    }\n    next++;\n  }\n  return next;\n}\n\nll N, M;\nvector<vector<ll>> A;\n\n\nvoid solve(){\n  COMinit();\n  cin >> N >> M;\n  A.resize(N);\n  rep(i, N) A[i].resize(M);\n  rep(i, N)rep(j, M) cin >> A[i][j];\n  ll r = Rank(N, M, A);\n  ll ans = 0;\n  rep(i, r+1){\n    ll add = comb(r, i) * pow_mod(2, r-i) % MOD;\n    for(ll j = 1; j <= i; j += 2){\n      ans += add * comb(i, j) % MOD;\n      ans %= MOD;\n    }\n  }\n  ans *= pow_mod(2, N + M - 2 * r);\n  ans %= MOD;\n  cout << ans << endl;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PII pair<int, int>\n#define LL long long\nusing namespace std;\nconst int MAXN = 305;\nconst int INF = (LL)1e9 + 5;\nconst int MOD = 998244353;\n\nint N, M, C[MAXN][MAXN], pw[MAXN];\nvector<bitset<MAXN>> a;\n\nvoid gaussian(vector<bitset<MAXN>> &a) {\n\tint pos = 0;\n\tfor (int j = 0; j < M && pos < N; j++) {\n\t\tbool go = false;\n\t\tfor (int i = pos; i < N; i++) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tswap(a[i], a[pos]);\n\t\t\t\tgo = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!go) continue;\n\t\tfor (int i = pos + 1; i < N; i++) {\n\t\t\tif (a[i][j]) {\n\t\t\t\ta[i] ^= a[pos];\n\t\t\t}\n\t\t}\n\t\tpos++;\n\t}\n}\n\nint qpow(int a, int pw) {\n\tint res = 1;\n\twhile (pw) {\n\t\tif (pw & 1) res = (LL) res * a % MOD;\n\t\tpw >>= 1;\n\t\ta = (LL) a * a % MOD;\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tfor (int n = 1; n < MAXN; n++) {\n\t\tC[n][0] = C[n][n] = 1;\n\t\tfor (int k = 1; k < n; k++) {\n\t\t\tC[n][k] = C[n - 1][k] + C[n - 1][k - 1];\n\t\t\tC[n][k] %= MOD;\n\t\t}\n\t}\n\n\tcin >> N >> M;\n\ta.resize(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\ta[i][j] = x;\n\t\t}\n \t}\n\n\tint r = 0;\n\tgaussian(a);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (a[i].any()) {\n\t\t\tr++;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tassert(r <= N && r <= M);\n\tfor (int i = 1; i <= r; i += 2) {\n\t\tint add = (LL) C[r][i] * qpow(3, r - i) % MOD * qpow(2, N + M - r - r) % MOD;\n\t\tans = (ans + add) % MOD;\n\t}\n\t\n\tcout << ans << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(0);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\ntemplate <int mod>\nclass ModInt {\npublic:\n    ModInt() : v(0) {}\n    ModInt(int x) : v((x+mod)%mod) {}\n    int value() const {return v;}\n    const ModInt operator+(const ModInt &r) const { return ModInt(this->v + r.v); }\n    const ModInt operator-(const ModInt &r) const { return ModInt(this->v + mod - r.v); }\n    const ModInt operator*(const ModInt &r) const { return ModInt(this->v * r.v); }\n    const ModInt operator/(const ModInt &r) const { return (*this * (~r)); }\n    const ModInt operator^(int k) const { return ModInt(bpow(this->v, k)); }\n    const ModInt operator~() const { return ModInt(bpow(this->v, mod-2)); }\n    bool operator==(const ModInt &r) const { return this->v == r.v; }\n    bool operator!=(const ModInt &r) const { return this->v != r.v; }\n    ModInt& operator+=(const ModInt &r) { return *this = *this + r; }\n    ModInt& operator-=(const ModInt &r) { return *this = *this - r; }\n    ModInt& operator*=(const ModInt &r) { return *this = *this * r; }\n    ModInt& operator/=(const ModInt &r) { return *this = *this * (~r); }\nprivate:\n    int v;\n    int bpow(int a, int b) const {\n        int ret = 1;\n        while (b > 0) {\n            if (b & 1) ret = (ret * a) % mod;\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return ret;\n    }\n};\nusing Mint = ModInt<1000000007>;\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    vector<valarray<int>> mat(N);\n    REP(i, N) {\n        valarray<int> row(M);\n        REP(j, M) {\n            cin >> row[j];\n        }\n        mat[i] = row;\n    }\n    int rank = 0;\n    REP(i, min(N, M)) {\n        int col = [&] {\n            REPF(j, i, N) {\n                REPF(k, i, M) {\n                    if (mat[j][k] == 1) {\n                        swap(mat[j], mat[i]);\n                        return k;\n                    }\n                }\n            }\n            return -1LL;\n        }();\n        if (col == -1) break;\n\n        dump(i, col);\n        \n        REP(j, N) swap(mat[j][i], mat[j][col]);\n        rank++;\n        REP(j, N) {\n            if (j == i) continue;\n            if (mat[j][i] == 1) mat[j] ^= mat[i];\n        }\n    }\n\n    dump(rank);\n    FORE(r, mat) {\n        FORE(x, r) {\n            cerr << x << \" \";\n        }\n        cerr << endl;\n    }\n   \n    Mint ans = (Mint(2) ^ (N + M - 1)) - (Mint(2) ^ (N + M - rank - 1));\n    cout << ans.value() << endl;\n    return (0^_^0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mo=998244353,N=305;\nint mi[N],n,m,i,j,k,a[N][N];\nbitset<N>b[N],x;\nint main(){\n\tfor(i=*mi=1;i<N;++i)mi[i]=2ll*mi[i-1]%mo;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i){\n\t\tx.reset();\n\t\tfor(j=0;j<m;++j)scanf(\"%d\",a[i]+j),x.set(j,a[i][j]);\n\t\tfor(j=0;j<m;++j)if(x[j]){\n\t\t\tif(b[j].any())x^=b[j];\n\t\t\t\telse{b[j]=x;break;}\n\t\t}\n\t\tif(j==m)++k;\n\t}\n\ti=(1ll*mi[m]*mi[k]+1ll*mi[m-1]*(mi[n]+mo-mi[k]))%mo;\n\ti=(1ll*mi[n]*mi[m]+mo-i)%mo;\n\tprintf(\"%d\\n\",i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and must not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int Int;\n\ttypedef unsigned int UInt;\n\ttypedef long long Long;\n\ttypedef unsigned long long ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](ULong exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(ULong exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic IntMod Permutation(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / IntMod::Fact(n - r);\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nusing MMK = IntMod<998244353>;\n\nint N, M;\nint A[300][300];\nMMK Naive() {\n\tMMK ret = 0;\n\tREP(s, 0, 1 << N) {\n\t\tREP(t, 0, 1 << M) {\n\t\t\tint cnt = 0;\n\t\t\tREP(i, 0, N) {\n\t\t\t\tREP(j, 0, M) {\n\t\t\t\t\tif (!((1 << i) & s)) continue;\n\t\t\t\t\tif (!((1 << j) & t)) continue;\n\t\t\t\t\tcnt += A[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt % 2 == 1) {\n\t\t\t\t++ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid Swap(int a, int b) {\n\tREP(j, 0, M) {\n\t\tswap(A[a][j], A[b][j]);\n\t}\n}\n\nvoid Xor(int a, int b) {\n\tREP(j, 0, M) {\n\t\tA[a][j] ^= A[b][j];\n\t}\n}\n\nint Rank() {\n\tint top_i = 0;\n\tREP(j, 0, M) {\n\t\tint nz_i = -1;\n\t\tREP(i, top_i, N) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tnz_i = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (nz_i == -1) continue;\n\n\t\tSwap(top_i, nz_i);\n\t\tREP(i, nz_i + 1, N) {\n\t\t\tif (!A[i][j]) continue;\n\t\t\tXor(i, top_i);\n\t\t}\n\t\t++top_i;\n\t}\n\treturn top_i;\n}\n\nint main() {\n\tcin >> N >> M;\n\tREP(i, 0, N) {\n\t\tREP(j, 0, M) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\t//MMK naive_ans = Naive();\n\n\tint r = Rank();\n\tMMK ans = r == 0 ? 0 : MMK(2)[r - 1] * (MMK(2)[r] - 1) * MMK(2)[N + M - 2 * r];\n\n\t//cout << naive_ans << endl;\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\nusing namespace std;\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define LL long long\n#define pb push_back\n\nconst int N = 305;\nconst int MOD = 998244353;\nbitset<N> a[N];\nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile (k) {\n\t\tif (k & 1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD;\n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = m - 1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t) a[i].flip(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (bitset<N> b : base) {\n\t\t\tbitset<N> bb = b ^ a[i];\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (bb[j] < a[i][j]) {\n\t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (bb[j] > a[i][j]) break;\n\t\t\t}\n\t\t}\n\t\tif (a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", ((q_pow(2, n + m - 1) - q_pow(2, n + m - 1 - cnt)) % MOD + MOD) % MOD);\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds;   \n#define ordered_set tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update> \n#define ld long double\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n#define sz(a) (ll)(a.size())\nconst int M = 302;\nconst ll mod = 998244353;\nint a[M][M];\nll power(ll a,ll b)\n{\n\tll val=1;\n\twhile(b)\n\t{\n\t\tif(b%2)\n\t\t\tval=(val*a)%mod;\n\t\tb/=2;\n\t\ta=(a*a)%mod;\n\t}\n\treturn val;\n}\nint findRank(int n,int m)\n{\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint id = i;\n\t\tfor(int j=i;j<n;j++)\n\t\t\tif(a[j][i] == 1)\n\t\t\t\tid = j;\n\t\tfor(int j=0;j<m;j++)\n\t\t\tswap(a[i][j], a[id][j]);\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tif(a[j][i]==0)\n\t\t\t\tcontinue;\n\t\t\tfor(int k=0;k<m;k++)\n\t\t\t\ta[j][k] ^= a[i][k];\n\t\t}\n\t}\n\tint rank = 0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbool flag = 0;\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(a[i][j])\n\t\t\t\tflag = 1;\n\t\tif(flag)\n\t\t\trank++;\n\t}\n\treturn rank;\n}\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\tcin>>a[i][j];\n\tint r = findRank(n,m);\n\tll v = power(2,m-1);\n\tll x = (power(2,n) - power(2,n-r)+mod)%mod;\n\tll ans = (v*x)%mod;\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vecll v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(vector<vec> v){for(auto e:v){for(auto ee:e)cout<<ee<<\" \";cout<<endl;}}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\nconst int INF=1e6;\nconst int MAX_ROW = 510; // to be set appropriately\nconst int MAX_COL = 510; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nostream& operator << (ostream& s, BitMatrix A) {\n    s << endl; \n    for (int i = 0; i < A.H; ++i) {\n        for (int j = 0; j < A.W; ++j) {\n            s << A[i][j] << \", \";\n        }\n        s << endl;\n    }\n    return s;\n}\n\ninline BitMatrix operator * (BitMatrix A, BitMatrix B) {\n    BitMatrix R(A.H, B.W);\n    BitMatrix tB(B.W, B.H);\n    for (int i = 0; i < tB.H; ++i) for (int j = 0; j < tB.W; ++j) tB[i][j] = B[j][i];\n    for (int i = 0; i < R.H; ++i) for (int j = 0; j < R.W; ++j) R[i][j] = ((A[i] & tB[j]).count() & 1);\n    return R;\n}\n\ninline BitMatrix pow(BitMatrix A, long long n) {\n    BitMatrix R(A.H, A.H);\n    for (int i = 0; i < A.H; ++i) R[i][i] = 1;\n    while (n > 0) {\n        if (n & 1) R = R * A;\n        A = A * A;\n        n >>= 1;\n    }\n    return R;\n}\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return rank;\n}\n\n\nconst int MOD = 998244353;\nlong long modpow(long long a, long long n, long long mod=MOD) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nmain(){\n    int n=in(),m=in();\n    BitMatrix bit(n,m);\n    rep(i,n)rep(j,m){\n        bit[i][j]=in();\n    }\n    ll rnk=GaussJordan(bit);\n    ll ans=modpow(2,rnk*2-1)-modpow(2,rnk-1)+MOD;\n    ans%=MOD;\n    ans=ans*modpow(2,n+m-rnk*2)%MOD;\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n// bit op\nint popcnt(uint x) { return __builtin_popcount(x); }\nint popcnt(ull x) { return __builtin_popcountll(x); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    uint v;\n    ModInt() : v(0) {}\n    ModInt(ll _v) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<998244353>;\n\nstruct BitVec {\n    static constexpr size_t B = 64;\n    size_t n;\n    V<ull> d;\n    explicit BitVec(size_t _n = 0) : n(_n), d((n + B - 1) / B) {}\n    void erase_last() {\n        if (n % B) d.back() &= ull(-1) >> (B - n % B);\n    }\n    size_t size() const { return n; }\n    bool operator[](size_t i) const { return (d[i / B] >> (i % B) & 1) != 0; }\n    void set(size_t i, bool f = true) {\n        if (f)\n            d[i / B] |= 1ULL << (i % B);\n        else\n            d[i / B] &= ~(1ULL << (i % B));\n    }\n    void reset() { fill(d.begin(), d.end(), 0); }\n    void reset(size_t i) { set(i, false); }\n    void push_back(bool f) {\n        if (n % B == 0) d.push_back(0);\n        set(n, f);\n        n++;\n    }\n    bool empty() const {\n        for (auto& x : d)\n            if (x) return false;\n        return true;\n    }\n\n    size_t bsf() const {\n        auto m = d.size();\n        for (size_t i = 0; i < m; i++) {\n            if (d[i]) return i * B + ::bsf(d[i]);\n        }\n        assert(false);\n    }\n\n    size_t count() const {\n        size_t sm = 0;\n        for (auto x : d) sm += popcnt(x);\n        return sm;\n    }\n\n    void swap_elms(size_t a, size_t b) {\n        bool f = (*this)[a];\n        set(a, (*this)[b]);\n        set(b, f);\n    }\n\n    template <class OP> BitVec& op1(OP op) {\n        for (auto& x : d) x = op(x);\n        return *this;\n    }\n\n    template <class OP> BitVec& op2(const BitVec& r, OP op) {\n        assert(n == r.n);\n        for (size_t i = 0; i < d.size(); i++) d[i] = op(d[i], r.d[i]);\n        return *this;\n    }\n\n    BitVec& flip() {\n        op1(bit_not<ull>());\n        if (n % B) d.back() &= ~(-1ULL << (n % B));\n        return *this;\n    }\n    BitVec& operator&=(const BitVec& r) { return op2(r, bit_and<ull>()); }\n    BitVec& operator|=(const BitVec& r) { return op2(r, bit_or<ull>()); }\n    BitVec& operator^=(const BitVec& r) { return op2(r, bit_xor<ull>()); }\n    BitVec& operator<<=(const size_t& s) {\n        auto block = s / B, rem = s % B;\n        if (d.size() <= block) {\n            reset();\n            return *this;\n        }\n        for (size_t i = d.size() - 1; i > block; i--) {\n            if (rem == 0)\n                d[i] = d[i - block];\n            else\n                d[i] = d[i - block] << rem | d[i - block - 1] >> (B - rem);\n        }\n        d[block] = d[0] << rem;\n        erase_last();\n        fill(d.begin(), d.begin() + block, 0ULL);\n        return *this;\n    }\n    BitVec& operator>>=(const size_t& s) {\n        auto block = s / B, rem = s % B;\n        if (d.size() <= block) {\n            reset();\n            return *this;\n        }\n        for (size_t i = 0; i < d.size() - block - 1; i++) {\n            if (rem == 0)\n                d[i] = d[i + block];\n            else\n                d[i] = d[i + block + 1] << (B - rem) | d[i + block] >> rem;\n        }\n        d[d.size() - block - 1] = d.back() >> rem;\n        fill(d.begin() + d.size() - block, d.end(), 0ULL);\n        return *this;\n    }\n    BitVec& operator~() const { return BitVec(*this).flip(); }\n    BitVec operator&(const BitVec& r) const { return BitVec(*this) &= r; }\n    BitVec operator|(const BitVec& r) const { return BitVec(*this) |= r; }\n    BitVec operator^(const BitVec& r) const { return BitVec(*this) ^= r; }\n    BitVec operator<<(const size_t& s) const { return BitVec(*this) <<= s; }\n    BitVec operator>>(const size_t& s) const { return BitVec(*this) >>= s; }\n\n    BitVec substr(size_t st, size_t le) const {\n        assert(st + le <= n);\n        BitVec res(le);\n        size_t i = 0;\n        while (i < le) {\n            res.d[i / B] |= d[(st + i) / B] >> ((st + i) % B) << (i % B);\n            i += min(B - i % B, B - (st + i) % B);\n        }\n        res.erase_last();\n        return res;\n    }\n    bool substr_match(size_t st, const BitVec& pat) const {\n        size_t le = pat.size();\n        assert(st + le <= n);\n        size_t i = 0;\n        while (i < le) {\n            size_t u = min({le - i, B - i % B, B - (st + i) % B});\n            ull z = pat.d[i / B] >> (i % B) ^ d[(st + i) / B] >> ((st + i) % B);\n            if (z << (B - u)) return false;\n            i += u;\n        }\n        return true;\n    }\n\n    bool operator==(const BitVec& r) const { return d == r.d; }\n};\n\n\nstruct Mat2 : V<BitVec> {\n    using V<BitVec>::V;\n    using V<BitVec>::size;\n    int h() const { return int(size()); }\n    int w() const { return int((*this)[0].size()); }\n    Mat2 operator*(const Mat2& r) const {\n        assert(w() == r.h());\n        Mat2 r_t = Mat2(r.h(), BitVec(r.w()));\n        for (int y = 0; y < r_t.h(); y++) {\n            for (int x = 0; x < r_t.w(); x++) {\n                r_t[y].set(x, r[x][y]);\n            }\n        }\n        Mat2 res(h(), BitVec(r_t.h()));\n        for (int i = 0; i < h(); i++) {\n            for (int j = 0; j < r_t.h(); j++) {\n                res[i].set(j, ((*this)[i] ^ r_t[j]).count() % 2 == 1);\n            }\n        }\n        return res;\n    }\n};\n\nint calc_rank(Mat2 a) {\n    int h = a.h(), w = a.w();\n    int r = 0;\n    V<int> idxs;\n    for (int x = 0; x < w; x++) {\n        int my = -1;\n        for (int y = r; y < h; y++) {\n            if (a[y][x]) {\n                my = y;\n                break;\n            }\n        }\n        if (my == -1) continue;\n        if (r != my) swap(a[r], a[my]);\n        for (int y = r + 1; y < h; y++) {\n            if (!a[y][x]) continue;\n            a[y] ^= a[r];\n        }\n        r++;\n        idxs.push_back(x);\n        if (r == h) break;\n    }\n    return r;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    Mat2 mt(n, BitVec(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int x;\n            cin >> x;\n            mt[i].set(j, x == 1);\n        }\n    }\n    auto u = calc_rank(mt);\n\n    cout << Mint(2).pow(m + n - 1) - Mint(2).pow(m + n - 1 - u) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=998244353;\nlong long n,m,a[333][333],pw[666],cnt,pos,cur,upper;\nvoid gauss()\n{\n\tupper=1;\n\tfor (long long i=1;i<=m;i++)\n\t{\n\t\tpos=-1;\n\t\tfor (long long j=upper;j<=n;j++)\n\t\t{\n\t\t\tif (a[j][i])\n\t\t\t{\n\t\t\t\tpos=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~pos)\n\t\t{\n\t\t\tcnt++;\n\t\t\tfor (long long j=1;j<=m;j++) swap(a[i][j],a[pos][j]);\n\t\t\tfor (long long j=upper+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif (a[j][i])\n\t\t\t\t{\n\t\t\t\t\tfor (long long k=i;k<=m;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][k]^=a[upper][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupper++;\n\t\t}\n\t}\n} \nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tfor (long long j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tpw[0]=1;\n\tfor (long long i=1;i<=600;i++) pw[i]=pw[i-1]*2%mod;\n\tgauss();\n\tcur=pw[m-cnt];\n\tprintf(\"%lld\\n\",((pw[n+m-1]-pw[n-1]*cur)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\n/*bool operator < (const vector<long long> &a,const vector<long long> &b){\n    bool ret=false;\n    DEBUG(\"called\");\n    for(long long i = 0; i < a.size(); i++){\n        if(a[i]>b[i]){\n            ret=false;\n            break;\n        }else if(a[i]<b[i]){\n            ret=true;\n            break;\n        }\n    }\n    return ret;\n}\n*/\nll cache_pow[600];\nll mpow(ll a){\n    static bool flag=false;\n    if(flag){\n        DEBUG(\"True\");\n        return cache_pow[a];\n    }else{\n        cache_pow[0]=1;\n        for(long long i = 1; i < 600; i++){\n            cache_pow[i]=(cache_pow[i-1]*2)%MOD;\n        }\n        flag=true;\n        return cache_pow[a];\n    }\n}\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    sort(a.begin(),a.end(),greater<vll>());\n    ll index=0;\n\n    vector<bitset<300>> A;\n    for(long long i = 0; i < a.size(); i++){\n        A.push_back(bitset<300>(0));\n        for(long long k = 0; k < a[i].size(); k++){\n            A[i][k]=a[i][k]==1;\n        }\n    }\n    ll rank=0;\n    for(long long i = 0; i < a.size(); i++){\n        DEBUG(i);\n        for(; index < a[i].size()&&A[i][index]==0; index++){\n            DEBUG(index);\n        }\n        if(index==a[i].size()){\n            break;\n        }\n        rank++;\n        for(long long j = i+1; j < a.size()&&A[j][index]==1; j++){\n            A[j]^=A[i];\n        }\n    }\n    DEBUG(rank);\n    cout<<mpow(M+N-1)-mpow(M+N-1-rank)<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nint n,m,a[310][310];\nint od[310],ev[310],bit[310];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j];\n\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n/*\tfor(int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tprintf(\"%d \",a[i][j]);\n*/\n\n\tod[0]=1;od[1]=1;ev[1]=3;\n\tfor(int i=2;i<=m;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i]) continue;\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=m;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=n;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cout<<v[i][j]<<\" \";}cout<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nvii rotate(vii a) {\n  int h = a.size(), w = a[0].size();\n  vii b(w, vi(h));\n  rep (i, h) {\n    rep (j, w) {\n      b[j][i] = a[i][j];\n    }\n  }\n  return b;\n}\n\n\nconst int MAXN = 3010;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n\tfact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n\tfor (ll i = 2; i <= n; i++) {\n\t\tfact[i] = i * fact[i - 1] % M;\n\t\trfact[i] = mod_inverse(fact[i], M);\n\t}\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  ll ret = fact[n];\n  ret = (ret*rfact[r]) % M;\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\n\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n  vii a(h, vi(w));\n  rep (i, h) {\n    rep (j, w) {\n      cin >> a[i][j];\n    }\n  }\n  if (h < w) {\n    swap(h, w);\n    a = rotate(a);\n  }\n  set_fact(h + 100);\n  int no = 0;\n  rep (j, w) {\n    if (a[j][j] == 0) {\n      for (int i = j + 1; i < h; i++) {\n        if (a[i][j] == 1) {\n          swap(a[i], a[j]);\n          break;\n        }\n      }\n    }\n    if (a[j][j] == 0) {\n      no++;\n      continue;\n    }\n    for (int i = 0; i < h; i++) {\n      if (i == j) continue;\n      rep (k, w) {\n        a[i][k] = (a[i][k] + a[j][k]) % 2;\n      }\n    }\n  }\n  ll ans = 0;\n  for (int x = 1; x <= w - no; x += 2) {\n    for (int y = 0; y <= w - no - x; y++) {\n      ans += mod_pow(2, h - w) * nCr(w - no, x) % MOD * mod_pow(2, 2 * no) % MOD * nCr(w - no - x, y) % MOD * mod_pow(2, w - no - x - y) % MOD;\n      ans %= MOD;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\nconst int N=305;\nconst int mod=998244353;\nint pow(int x, int k)\n{\n\tint ans=1;\n\tfor(;k;k>>=1,x=(ll)x*x%mod) if(k&1) ans=(ll)ans*x%mod;\n\treturn ans;\n}\nint inv(int x){ return pow(x,mod-2);}\nint a[N][N];\nint main()\n{\n\tint n,m,i,j,k;\n\tscanf(\"%i %i\",&n,&m);\n\tfor(i=1;i<=n;i++) for(j=1;j<=m;j++) scanf(\"%i\",&a[i][j]);\n\tint r=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tbool ok=0;\n\t\tfor(j=r+1;j<=n;j++)\n\t\t{\n\t\t\tif(a[j][i])\n\t\t\t{\n\t\t\t\tfor(k=i;k<=n;k++) swap(a[j][k],a[r+1][k]);\n\t\t\t\tok=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\t\tr++;\n\t\tfor(j=r+1;j<=n;j++) if(a[j][i])\n\t\t{\n\t\t\tint mul=(ll)a[j][i]*inv(mod-a[r][i])%mod;\n\t\t\tfor(k=i;k<=n;k++) a[j][k]=(a[j][k]+(ll)a[r][k]*mul%mod)%mod;\n\t\t}\n\t}\n\tint ans=1,sol=1;\n\tfor(i=1;i<=n+m-1;i++) ans=ans*2%mod;\n\tfor(i=1;i<=n+m-r-1;i++) sol=sol*2%mod;\n\tans-=sol;\n\tif(ans<0) ans+=mod;\n\tprintf(\"%i\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define mod(x) ((x % MOD) + MOD) % MOD\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define LB(c,x) (int)(lower_bound(ALL(c),x)-(c).begin())\n#define UB(c,x) (int)(upper_bound(ALL(c),x)-(c).begin())\n#define COUNT(c,x) (UB(c,x)-LB(c,x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DEL(v) decltype(v)().swap(v)\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\ntemplate<typename T1, typename T2> using P = pair<T1,T2>;\ntemplate<typename T> using V = vector<T>;\nstruct edge { int from, to; int cost; };\nbool operator< (const edge &edge1, const edge &edge2) { return edge1.cost < edge2.cost; };\nconst int INF = 1e18;\nconst int MOD = 1e9+7;\n\ntemplate<typename T> ostream& operator << (ostream& s, const V<T>& v) {\n   s << \"[\";\n   for (int i = 0; i < v.size(); i++) { s << v[i]; if (i < v.size() - 1) s << \" \"; }\n   s << \"]\";\n   return s;\n}\ntemplate<typename T1, typename T2> ostream& operator << (ostream& s, const P<T1,T2>& p) {\n   s << \"(\" << p.first << \",\" << p.second << \")\";\n   return s;\n}\n\nstruct GF2 {\n   int n;\n   GF2(int m=0) { n = m; }\n   const bool operator==(int m) const { return n == (m%2); }\n   const bool operator!=(int m) const { return n != (m%2); }\n   const bool operator>(const GF2 a) const { return n > a.n; }\n   const GF2 operator+(const GF2& a) const { return GF2{n ^ a.n}; }\n   const GF2 operator-(const GF2& a) const { return GF2{n ^ a.n}; }\n   const GF2 operator*(const GF2& a) const { return GF2{n * a.n}; }\n   const GF2 operator/(const GF2& a) const { if (a.n == 0) throw \"Can't devide by 0\"; return GF2{n / a.n}; }\n   GF2& operator+=(const GF2& a) { n ^= a.n; return *this; }\n   GF2& operator-=(const GF2& a) { n ^= a.n; return *this; }\n   GF2& operator*=(const GF2& a) { n *= a.n; return *this; }\n   GF2& operator/=(const GF2& a) { if (a.n == 0) throw \"Can't devide by 0\"; n /= a.n; return *this; }\n   GF2& operator=(int m) { n = m; return *this; }\n};\nconst GF2 abs(GF2 x) { return x; }\nostream& operator << (ostream& s, const GF2& a) { s << a.n; return s; }\n\ntemplate<typename T> class Matrix\n{\n   private:\n      vector<vector<T>> val;\n      int m, n;\n   public:\n      Matrix(int a=0, int b=0) : m(a), n(b) {\n         val.resize(m, vector<T>(n));\n      }\n      Matrix(const vector<vector<T>>& vec) : m(vec.size()), n(vec[0].size()) {\n         val.resize(m, vector<T>(n));\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] = vec[i][j];\n      }\n      ~Matrix() {\n         vector<vector<T>>().swap(val);\n      }\n      Matrix& operator=(const Matrix& mat) {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be substituted\"; }\n         catch (const char* e) { cerr << e << endl; }\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] = mat.val[i][j];\n         return *this;\n      }\n      T operator()(int i, int j) {\n         try { if (i < 0 || m <= i || j < 0 || n <= j) throw \"Bad access\"; }\n         catch (const char* e) { cerr << e << endl; }\n         return val[i][j];\n      }\n      const Matrix operator+(const Matrix& mat) const {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[i][j] = val[i][j] + mat.val[i][j];\n         return tmp;\n      }\n      const Matrix operator-(const Matrix& mat) const {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[i][j] = val[i][j] - mat.val[i][j];\n         return tmp;\n      }\n      const Matrix operator*(const Matrix& mat) const {\n         try { if (n != mat.m) throw \"Matrix can't be producted\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, mat.n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < mat.n; j++) for (int k = 0; k < n; k++) tmp.val[i][j] += val[i][k]*mat.val[k][j];\n         return tmp;\n      }\n      Matrix& operator+=(const Matrix& mat) {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] += mat.val[i][j];\n         return *this;\n      }\n      Matrix& operator-=(const Matrix& mat) {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] -= mat.val[i][j];\n         return *this;\n      }\n      Matrix operator*=(const Matrix& mat) {\n         try { if (n != mat.m) throw \"Matrix can't be producted\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, mat.n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < mat.n; j++) for (int k = 0; k < n; k++) tmp.val[i][j] += val[i][k]*mat.val[k][j];\n         n = mat.n;\n         val.resize(m, vector<T>(n));\n         *this = tmp;\n         return *this;\n      }\n      Matrix transpose() const {\n         Matrix tmp(n, m);\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[j][i] = val[i][j];\n         return tmp;\n      }\n      Matrix gaussElimination() const {\n         Matrix<T> A(val);\n         int col = 0;\n         for (int i = 0; i < m; i++) {\n            int pivot = i;\n            while (true) {\n               for (int j = i+1; j < m; j++) if (abs(A.val[j][col]) > abs(A.val[pivot][col])) pivot = j;\n               if (A.val[pivot][col] == 0) {\n                  col++;\n                  if (col == n) return A;\n               } else break;\n            }\n            swap(A.val[i], A.val[pivot]);\n            for (int j = i+1; j < m; j++) {\n               T ratio = A.val[j][col] / A.val[i][col];\n               for (int k = col; k < n; k++) A.val[j][k] -= A.val[i][k] * ratio;\n            }\n            col++;\n         }\n         return A;\n      }\n      int rank() const {\n         Matrix A = gaussElimination();\n         int j = 0;\n         for (int i = 0; i < m; i++) {\n            while (A.val[i][j] == 0) {\n               j++; if (j == n) return i;\n            }\n         }\n         return m;\n      }\n      ostream& info(ostream& s) const {\n         s << endl << \"[\";\n         for (int i = 0; i < m; i++) {\n            s << \"[\";\n            for (int j = 0; j < n; j++) {\n               s << val[i][j];\n               if (j < n-1) s << \" \";\n            }\n            s << \"]\"; if (i < m-1) s << endl;\n         }\n         s << \"]\";\n         return s;\n      }\n};\ntemplate<typename T> ostream& operator<<(ostream& s, const Matrix<T>& mat) {\n   mat.info(s);\n   return s;\n}\n\ntemplate<typename T> class SquareMatrix : public Matrix<T>\n{\n   private:\n      int num;\n   public:\n      SquareMatrix(int a=0) : Matrix<T>(a, a) { num = a; }\n      SquareMatrix(const vector<vector<T>>& vec) : num(vec.size()), Matrix<T>(vec) { \n         try { if (vec.size() != vec[0].size()) throw \"Matrix isn't square matrix\"; }\n         catch (const char* e) { cerr << e << endl; }\n      }\n      T determinant() {\n         Matrix<T> A = this->gaussElimination();\n         T det = 1;\n         for (int i = 0; i < num; i++) det *= A(i,i);\n         return det;\n      }\n};\n\n\nint powM(int x, int n) {\n   int res = 1;\n   while (n > 0) {\n      if ((n & 1) == 1) {\n         res = mod(res * x);\n      }\n      x = mod(x * x);\n      n >>= 1;\n   }\n   return res;\n}\n\nsigned main()\n{\n   int n, m; cin >> n >> m;\n   V<V<GF2>> a(n, V<GF2>(m));\n   REP(i, n) {\n      REP(j, m) {\n         int b; cin >> b;\n         a[i][j] = b;\n      }\n   }\n\n   Matrix<GF2> A(a);\n\n   int rank = A.rank();\n\n   int ans = powM(2,n+m-1) - powM(2,n+m-rank-1);\n   DUMP(ans)\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\n#define dump(x) cerr << #x \" = \" << x << endl\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class U> inline void chmax(T & a, U const & b) { a = max<T>(a, b); }\ntemplate <class T, class U> inline void chmin(T & a, U const & b) { a = min<T>(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> ostream & operator << (ostream & out, vector<T> const & xs) { REP (i, int(xs.size()) - 1) out << xs[i] << ' '; if (not xs.empty()) out << xs.back(); return out; }\n\nll solve(int h, int w, vector<vector<bool> > const & a) {\n    ll cnt = 0;\n    REP (yl, h) {\n        vector<int> acc(w + 1);\n        REP3 (yr, yl + 1, h + 1) {\n            int acc_y = 0;\n            REP (x, w) {\n                acc_y += a[yr - 1][x];\n                acc[x + 1] += acc_y;\n            }\n            int k[2] = {};\n            REP (x, w + 1) {\n                bool p = acc[x] & 1;\n                cnt += k[not p];\n                k[p] += 1;\n            }\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    int h, w; cin >> h >> w;\n    auto a = vectors(h, w, false);\n    REP (y, h) REP (x, w) {\n        int a_z; cin >> a_z;\n        a[y][x] = a_z;\n    }\n    cout << solve(h, w, a) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 998244353LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                // C[i][j] += A[i][k] * B[k][j]; // modなし\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// Matrix Library End\n\n// N * M 行列のランクを求める\n// 整数行列でも基本変形時に分数になるので double 型に限定しています\nint mat_rank(Matrix<double> A) {\n    int N = A.size(), M = A[0].size();\n\n    int res = 0;\n    for(int i=0; i<M; i++) {\n        // 絶対値が最も大きいものを探す\n        double max_elem = 0; int piv = -1;\n        for(int j=res; j<N; j++) {\n            if(abs(A[j][i]) > max_elem) {\n                max_elem = abs(A[j][i]);\n                piv = j;\n            }\n        }\n\n        // res 行目を piv 行目に変えて、行基本変形\n        if(piv < 0) continue;\n        swap(A[res], A[piv]);\n\n        // res 行目を正規化\n        {\n            double div = A[res][i];\n            for(int k=0; k<M; k++) {\n                A[res][k] = 1.0 * A[res][k] / div;\n            }\n        }\n        \n        for(int j=0; j<N; j++) {\n            if(j == res) continue;\n            assert(A[res][i] != 0);\n            double mul = A[j][i];\n            for(int k=0; k<M; k++) {\n                A[j][k] = A[j][k] - mul * A[res][k];\n            }\n        }\n        res++;\n    }\n    return res;\n}\n\nconst int MAXN = 610;\nint pow2[MAXN + 10];\nsigned main() {\n    pow2[0] = 1;\n    for(int i=1; i<=MAXN; i++) pow2[i] = (pow2[i-1] * 2) % MOD;\n    \n    int N, M; cin >> N >> M;\n    Matrix<double> mat;\n    init_mat(mat, N, M);\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            cin >> mat[i][j];\n        }\n    }\n\n    int rank = mat_rank(mat);\n    int ansA = pow2[N + M - 1];\n    int ansB = pow2[N + M - rank - 1];\n    fprintf(stderr, \"matrix rank = %lld\\n\", rank);\n    printf(\"%lld\\n\", (ansA - ansB + MOD) % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VVI a(n, VI(m));\n    REP(i,n) REP(j,m) a[i][j] = in();\n\n    int sum = 0;\n    REP(i,n) REP(j,m) sum ^= a[i][j];\n\n    VI si(n), sj(m);\n    REP(i,n) REP(j,m){\n        si[i] ^= a[i][j];\n        sj[j] ^= a[i][j];\n    }\n\n    VVI dpi(n + 1, VI(2)), dpj(m + 1, VI(2));\n    dpi[0][0] = dpj[0][0] = 1;\n    REP(i,n) REP(j,2){\n        dpi[i + 1][j] += dpi[i][j];\n        (dpi[i + 1][j ^ si[i]] += dpi[i][j]) %= mod;\n    }\n    REP(i,m) REP(j,2){\n        dpj[i + 1][j] += dpj[i][j];\n        (dpj[i + 1][j ^ sj[i]] += dpj[i][j]) %= mod;\n    }\n\n    ll ans = 0;\n    REP(i,2) REP(j,2){\n        if ((i ^ j ^ sum) == 1) ans = (ans + divll(dpi[n][i] * dpj[m][j], 2)) % mod;\n    }\n    if (sum == 0) ans += 2;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nint n,m,a[310][310];\nint od[310],ev[310],bit[310];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n/*\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n*/\n/*\tfor(int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tprintf(\"%d \",a[i][j]);\n*/\n\n\tint u=max(n,m);\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=m;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i]) continue;\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=m;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=u;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int Mx = 300;\nconst int mod = 998244353;\nll p2[Mx + 1];\n\ntypedef bitset<Mx> * It;\n\nbool bsLess(const bitset<Mx> &b1, const bitset<Mx> &b2) {\n\tfor (int i = Mx - 1; i >= 0; --i)\n\t\tif (b1[i] != b2[i])\n\t\t\treturn b1[i] < b2[i];\n\treturn false;\n}\n\nll f(It first, It last, const int pos) {\n\tif (pos < 0)\n\t\treturn p2[last - first];\n\tIt mid = find_if(first, last, [&pos](const bitset<Mx> &x) {\n\t\treturn x[pos];\n\t});\n\tconst ll temp = f(first, mid, pos - 1);\n\tif (mid == last)\n\t\treturn temp;\n\tfor (It it = next(mid); it != last; ++it)\n\t\t*it ^= *mid;\n\treturn (temp * f(mid + 1, last, pos - 1)) % mod;\n}\n\nbitset<Mx> a[300];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i <= Mx; ++i)\n\t\tp2[i] = (p2[i - 1] * 2) % mod;\n\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\ta[i][j] = x;\n\t\t}\n\n\tsort(a, a + n, bsLess);\n\tll res = f(a, a + n, m - 1);\n\tres = (p2[n] - res) * p2[m - 1];\n\tcout << (res % mod + mod) % mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nint n,m,a[310][310];\nint od[310],ev[310],bit[310];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n/*\tfor(int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tprintf(\"%d \",a[i][j]);\n*/\n\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=m;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i]) continue;\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=m;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=n;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nint n,m,a[310][310];\nint od[310],ev[310],bit[310],xxj[310];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n/*\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n*/\n/*\tfor(int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tprintf(\"%d \",a[i][j]);\n*/\n\n\tint u=max(n,m);\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tint cnt=0;\n/*\tfor(int i=1;i<=u;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i]) continue;\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=u;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n*/\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tif(xxj[j])\n\t\t\t\t\tfor(int k=j;k<=m;j++)\n\t\t\t\t\t\ta[i][k]^=a[xxj[j]][k];\n\t\t\t\telse {xxj[j]=i;cnt++;break;}\n\t\t\t}\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=u;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 998244353;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<LL>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\n\ntemplate<class T>struct matrix {\n\tint n = 0, m = 0;\n\tvector<vector<T>>mat;\n\tmatrix() {}\n\tmatrix(int _n) {\n\t\tmat.resize(_n);\n\t\tfor (int i = 0; i < _n; i++)\n\t\t\tmat[i].resize(_n);\n\t\tn = _n;\n\t\tm = _n;\n\t}\n\tmatrix(int _n, int _m) {\n\t\tmat.resize(_n);\n\t\tfor (int i = 0; i < _n; i++)\n\t\t\tmat[i].resize(_m);\n\t\tn = _n;\n\t\tm = _m;\n\t}\n\tint GetRank() {\n\t\tint h = mat.size(), w = mat[0].size();\n\t\tint res = 0, now = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tT ma = 0.0;\n\t\t\tint pivot;\n\t\t\tfor (int j = i; j < h; j++) {\n\t\t\t\tif (mat[j][now] > ma) {\n\t\t\t\t\tma = mat[j][now];\n\t\t\t\t\tpivot = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ma == 0.0) {\n\t\t\t\tnow++;\n\t\t\t\tif (now == w) break;\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pivot != i) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tswap(mat[i][j], mat[pivot][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tT tmp = 1.0 / mat[i][now];\n\t\t\tfor (int j = 0; j < w; j++) mat[i][j] *= tmp;\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tT tmp2 = mat[j][now];\n\t\t\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\t\t\tmat[j][k] -= mat[i][k] * tmp2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n\tbool Inv(matrix<T> &inv) {\n\t\tassert(mat.size() == mat[0].size() && inv.n == inv.m);\n\t\tint n = mat.size();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tinv.mat[i][j] = (i == j ? 1.0 : 0.0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tT ma = 0.0;\n\t\t\tint pivot;\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tif (mat[j][i] > ma) {\n\t\t\t\t\tma = mat[j][i];\n\t\t\t\t\tpivot = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ma == 0.0) return false;\n\t\t\tif (pivot != i) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tswap(mat[i][j], mat[pivot][j]);\n\t\t\t\t\tswap(inv.mat[i][j], inv.mat[pivot][j]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tT tmp = 1.0 / mat[i][i];\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tmat[i][j] *= tmp;\n\t\t\t\tinv.mat[i][j] *= tmp;\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tT tmp2 = mat[j][i];\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tmat[j][k] -= mat[i][k] * tmp2;\n\t\t\t\t\t\tinv.mat[j][k] -= inv.mat[i][k] * tmp2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tmatrix<T> operator+(const matrix<T> &b) {\n\t\tassert(mat.size() == b.n && mat[0].size() == b.m);\n\t\tint h = mat.size(), w = mat[0].size();\n\t\tmatrix<T> c(h, w);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tc.mat[i][j] = mat[i][j] + b.mat[i][j];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> operator-(const matrix<T> &b) {\n\t\tassert(mat.size() == b.n&& mat[0].size() == b.m);\n\t\tint h = mat.size(), w = mat[0].size();\n\t\tmatrix<T> c(h, w);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tc.mat[i][j] = mat[i][j] - b.mat[i][j];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> operator*(const matrix<T> b) {\n\t\tassert(mat[0].size() == b.n);\n\t\tmatrix<T> c(mat.size(), b.m);\n\t\tfor (int i = 0; i < mat.size(); i++) {\n\t\t\tfor (int k = 0; k < b.n; k++) {\n\t\t\t\tfor (int j = 0; j < b.m; j++) {\n\t\t\t\t\tc.mat[i][j] = (c.mat[i][j] + mat[i][k] * b.mat[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> operator*(T b) {\n\t\tmatrix<T> c(mat.size(), mat[0].size());\n\t\tfor (int i = 0; i < mat.size(); i++) {\n\t\t\tfor (int j = 0; j < mat[0].size(); j++) {\n\t\t\t\tc.mat[i][j] = mat[i][j] * b;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> Pow(long long n) {\n\t\tassert(mat.size() == mat[0].size());\n\t\tmatrix<T> b(mat.size()), c(mat.size());\n\t\tc = *this;\n\t\tfor (int i = 0; i < mat.size(); i++) {\n\t\t\tb.mat[i][i] = 1;\n\t\t}\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) b = b * c;\n\t\t\tc = c * c;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn b;\n\t}\n\tT det() {\n\t\tT det = 1.0, buf;\n\t\t//三角行列を作成\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tif (i<j) {\n\t\t\t\t\tbuf = mat[j][i] / mat[i][i];\n\t\t\t\t\tfor (int k = 0; k<n; k++) {\n\t\t\t\t\t\tmat[j][k] -= mat[i][k] * buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//対角部分の積\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tdet *= mat[i][i];\n\t\t}\n\t\treturn det;\n\t}\n\tmatrix<T> rev() {\n\t\tmatrix<T> inv_a(n, m), cp(n, m);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tinv_a.mat[i][j] = mat[i][j];\n\t\t\t\tcp.mat[i][j] = mat[i][j];\n\t\t\t}\n\t\tT buf;\n\t\t//単位行列を作る\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tinv_a.mat[i][j] = (i == j) ? 1.0 : 0.0;\n\t\t\t}\n\t\t}\n\t\t//掃き出し法\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tbuf = 1 / cp.mat[i][i];\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tcp.mat[i][j] *= buf;\n\t\t\t\tinv_a.mat[i][j] *= buf;\n\t\t\t}\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tbuf = cp.mat[j][i];\n\t\t\t\t\tfor (int k = 0; k<n; k++) {\n\t\t\t\t\t\tcp.mat[j][k] -= cp.mat[i][k] * buf;\n\t\t\t\t\t\tinv_a.mat[j][k] -= inv_a.mat[i][k] * buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn inv_a;\n\t}\n};\nLL n, m, s, t, h, w,mpow[810];\nint main() {\n\tcin >> n >> m;\n\tmpow[0] = 1;\n\trep(i, 800)mpow[i + 1] = mpow[i] * 2 % MOD;\n\tmatrix<LL>mat(n, m);\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tcin >> mat.mat[i][j];\n\t\t}\n\t}\n\tLL r = mat.GetRank();\n\tcout << (mpow[n + m - 1] - mpow[n + m - r - 1] + MOD) % MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 1e18;\nlong long int mod = 998244353;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1 , number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1 , number1);\n    }\n}\n\nll i,j,k,ii,jj,n,m,a,b,c,d,e,f,g,h,r,w,l,num,ans,ok,ng,mid;\nll x[500005],y[500005],z[500005];\nll dp[305][305];\nll sum[305];\nchar s[500005],t[500005],u[500005];\nbool dame,flag;\n//string s;\n\nint main(){\n\tcin >> n >> m;\n\tans = 1;\n\tfor(i=1;i<=n;i++){\n\t\tdame = true;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tcin >> x[j];\n\t\t\tif(x[j] == 1)dame = false;\n\t\t}\n\t\tif(dame){\n\t\t\ta++;\n\t\t\tans *= 2;\n\t\t\tans %= mod;\n\t\t}else{\n\t\t\tfor(j=1;j<=m;j++){\n\t\t\t\tdp[i-a][j] = x[j];\n\t\t\t}\n\t\t}\n\t}\n\tn -= a;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=m;j++){\n\t\t\tsum[i] += dp[i][j];\n\t\t\t//pe(dp[i][j]);\n\t\t}\n\t\t//el;\n\t}\n\t//sum[i] := i行目の総和\n\tdame = true;\n\tfor(i=1;i<=n;i++){\n\t\tif(sum[i] % 2 == 1){\n\t\t\tdame = false;\n\t\t}\n\t}\n\tif(!dame){\n\t\tans *= (rui(2,m-1)* (rui(2,n) - 1))%mod;\n\t\tans %= mod;\n\t}else{\n\t\tfor(j=1;j<=m;j++){\n\t\t\tsum[j] = 0;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tsum[j] += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tdame = true;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tif(sum[j] % 2 == 1)dame = false;\n\t\t}\n\t\tif(!dame){\n\t\t\tans *= (rui(2,n-1)* (rui(2,m) - 1))%mod;\n\t\t\tans %= mod;\n\t\t}else{\n\t\t\tans *= (rui(2,n-1)* (rui(2,m) - 2))%mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tp(ans);\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int MN = 305, P = 99824353;\n\ntypedef std::bitset<MN> bst;\n\nbst val[MN], vec[MN];\n\nint n, m, k;\n\ninline int fpw(int x, int k) {\n\tint res = 1;\n\tfor (; k; k >>= 1, x = (ll) x * x % P)\n\t\tif (k & 1) res = (ll) res * x % P;\n\treturn res;\n}\n\ninline int read() {\n\tint x; bool f; char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tval[i][j] = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = m; j--; )\n\t\t\tif (val[i][j]) {\n\t\t\t\tif (vec[j].count()) val[i] ^= vec[j];\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = j; ++k < m; )\n\t\t\t\t\t\tif (vec[j][k]) vec[j] ^= vec[k];\n\t\t\t\t\tfor (int k = j; k--; )\n\t\t\t\t\t\tif (vec[k][j]) vec[k] ^= vec[j];\n\t\t\t\t\t++k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%lld\\n\", (ll)fpw(2, m - 1) * (fpw(2, n) - fpw(2, n - k) + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\n#define BIT_N 333\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef bitset<BIT_N> Bit;\nvector<int> baseNum;\n\nll pow_two[BIT_N];\n\nvector<Bit> gauss(vector<Bit> &v, ll &ran){\n\tran = 0;\n\tREP(i,BIT_N) {\n\t\tint pla = -1;\n\t\tfor(int j = ran;j < v.size();j++){\n\t\t\tif(v[j][i] == 1){\n\t\t\t\tpla = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pla != -1){\n\t\t\tswap(v[ran], v[pla]);\n\t\t\tfor(int j = 0;j < v.size();j++){\n\t\t\t\tif(j != ran && v[j][i] == 1)v[j] ^= v[ran];\n\t\t\t}\n\t\t\tran++;\n\t\t}\n\t}\n\treturn v;\n}\n\nint main(){\n\t\n\tpow_two[0] = 1;\n\tREP(i,BIT_N - 1)pow_two[i+1] = pow_two[i] * 2 % MOD;\n\t\n\tvector<Bit> v;\n\tll n, m;cin >> n >> m;\n\tREP(i,n){\n\t\tBit now;\n\t\tREP(j,m){\n\t\t\tint a;cin >> a;\n\t\t\tif(a)now[j] = 1;\n\t\t}\n\t\tv.PB(now);\n\t}\n\t\n\tll ran = 0;\n\tll ans = 0;\n\tgauss(v, ran);\n\t\n\tcout << ((pow_two[n] - pow_two[n - ran] + MOD) % MOD) * pow_two[m-1] % MOD << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n\nstruct fast_io {\n    static constexpr int size_in = 1 << 26, size_out = 1 << 26;\n    char data_in[size_in], data_out[size_out], *p_in, *p_out, s[30];\n    fast_io() { fread(data_in, 1, size_in, stdin), p_in = data_in, p_out = data_out; }\n    ~fast_io() { fwrite(data_out, 1, p_out - data_out, stdout); }\n    void putchar(char x) { *p_out++ = x; }\n    template<typename T> void putint(T x) {\n        if (x < 0) { *p_out++ = '-', x = -x; }\n        int i = 0;\n        do { s[i++] = x % 10 + '0'; } while (x /= 10);\n        while (i--) { *p_out++ = s[i]; }\n    }\n    template<typename T=int> T getint() {\n        while (!isdigit(*p_in) && *p_in != '-') { p_in++; }\n        bool negative = *p_in == '-';\n        T ret = negative ? 0 : *p_in - '0';\n        while (isdigit(*++p_in)) { (ret *= 10) += *p_in - '0'; };\n        return negative ? -ret : ret;\n    }\n} io;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nint main() {\n    int N = io.getint(), M = io.getint();\n    using bset = bitset<300>;\n    vector<bset> src(N);\n    rep(i, N) {\n        rep(j, M) { src[i][j] = io.getint(); }\n    }\n    int rank = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = N - 1; j > i; j--) {\n            int x = src[j]._Find_first(), y = src[j - 1]._Find_first();\n            if (x < y) { src[j - 1] ^= src[j]; }\n            if (x <= y) { src[j] ^= src[j - 1]; }\n        }\n        if (src[i].none()) { break; }\n        rank++;\n    }\n    using mint = mod_int<998244353>;\n    io.putint((mint(2).pow(N + M - 1) - mint(2).pow(N + M - rank - 1)).val);\n}"
  },
  {
    "language": "C++",
    "code": "// by tmt514\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#define SZ(x) ((int)(x).size())\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 998244353;\nLL bigmod(LL a, LL n) {\n  if(n==0) return 1;\n  if(n==1) return a%MOD;\n  return bigmod(a*a%MOD, n/2) * (n%2? a:1)%MOD;\n}\nint main(void) {\n  int n, m;\n  int a[305][305] = {};\n  cin >> n >> m;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      cin >> a[i][j];\n  int rank=0, w=0;\n  for(int i=0;i<m;i++) {\n    int g=-1;\n    for(int j=w;j<n;j++)\n      if(a[j][i]==1) {\n        g=j;\n        break;\n      }\n    if(g>=0) {\n      for(int k=i;k<m;k++)\n        swap(a[w][k], a[g][k]);\n      for(int j=w+1;j<n;j++)\n        for(int k=i;k<m;k++)\n          a[j][k] ^= a[w][k];\n      ++rank;\n      ++w;\n    }\n  }\n  LL t = bigmod(2, m-1) * (bigmod(2, n) - bigmod(2, n-rank)) % MOD;\n  t=(t+MOD)%MOD;\n  cout << t << endl;\n  \n      \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nint p[310][310];\n\n\nint mat_N=310;\nint mat_M=310;\n// long long, including mod calculation\nstruct mat{\n\tlong long a[310][310];\n\tmat(){for(int i=0;i<mat_N;i++)for(int j=0;j<mat_M;j++)a[i][j]=0;}\n\tmat(int s){for(int i=0;i<mat_N;i++)for(int j=0;j<mat_M;j++)a[i][j]=(i==j)*s;}\n\tmat operator+(const mat &m)const{\n\t\tmat ret;\n\t\tfor(int i=0;i<mat_N;i++)for(int j=0;j<mat_M;j++)ret.a[i][j]=a[i][j]+m.a[i][j];\n\t\treturn ret;\n\t}\n\tmat operator-(const mat &m)const{\n\t\tmat ret;\n\t\tfor(int i=0;i<mat_N;i++)for(int j=0;j<mat_M;j++)ret.a[i][j]=a[i][j]+m.a[i][j];\n\t\treturn ret;\n\t}\n\tmat operator-()const{\n\t\tmat ret;\n\t\tfor(int i=0;i<mat_N;i++)for(int j=0;j<mat_M;j++)ret.a[i][j]=-a[i][j];\n\t\treturn ret;\n\t}\n\tmat operator*(const long long &k)const{\n\t\tmat ret;\n\t\tfor(int i=0;i<mat_N;i++)for(int j=0;j<mat_M;j++)ret.a[i][j]=a[i][j]*k%mod;\n\t\treturn ret;\n\t}\n\t// assuming mat_N = mat_M\n\t// by changing here, you can use for graph problems (ex. a[i][j]=min(a[i][k]+a[k][j]))\n\tmat operator*(const mat &m)const{\n\t\tmat ret;\n\t\tfor(int k=0;k<mat_N;k++)for(int i=0;i<mat_N;i++)for(int j=0;j<mat_N;j++){\n\t\t\tret.a[i][j]=(ret.a[i][j]+a[i][k]*m.a[k][j])%mod;\n\t\t}\n\t\treturn ret;\n\t}\n};\nmat I=mat(1);\nmat pw(mat a,long long t){\n\tmat ret=I;\n\twhile(t){\n\t\tif(t&1){\n\t\t\tret=ret*a;\n\t\t}\n\t\tt/=2;\n\t\ta=a*a;\n\t}\n\treturn ret;\n}\nlong long pw(long long a,long long b){\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\tb/=2;a=a*a%mod;\n\t}\n\treturn ret;\n}\nint rnk(mat a){\n\tint ret=0;\n\tfor(int i=0;i<mat_M;i++){\n\t\tint at=-1;\n\t\tfor(int j=ret;j<mat_N;j++){\n\t\t\tif(a.a[j][i]){\n\t\t\t\tat=j;break;\n\t\t\t}\n\t\t}\n\t\tif(!~at)continue;\n\t\tif(at!=ret){\n\t\t\tfor(int j=0;j<mat_M;j++)swap(a.a[at][j],a.a[ret][j]);\n\t\t}\n\t\tfor(int j=0;j<mat_N;j++){\n\t\t\tif(ret==j)continue;\n\t\t\tif(a.a[j][i]==0)continue;\n\t\t\tfor(int k=0;k<mat_M;k++){\n\t\t\t\ta.a[j][k]=(a.a[j][k]^a.a[ret][k]);\n\t\t\t}\n\t\t}\n\t\tret++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tmat_N=a;\n\tmat_M=b;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++)scanf(\"%d\",&p[i][j]);\n\t}\n\tmat A;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tA.a[i][j]=p[i][j];\n\t}\n\tint R=rnk(A);\n\tlong long ret=(pw(2,a)+mod-pw(2,a-R)%mod)%mod*pw(2,b)%mod*d2%mod;\n\tprintf(\"%lld\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n/* FastIO by rsk0315 (last update: 2018/02/21 00:36) */\n\nnamespace FastIn {\n    static constexpr size_t BUF_SIZE=1<<17, INT_LEN=24, FLT_LEN=400;\n    static char buf[BUF_SIZE|1]={}, *pos=buf, *endbuf=nullptr;\n    FILE *fin;\n\n    inline bool rebuffer() {\n        // returns true <=> there is at least one unread character\n        size_t rest=endbuf-pos;\n        if (buf+rest > pos) {\n            // buf[:pos] and buf[-pos:] are overlapping, which std::memcpy()\n            // causes undefined behavior.\n            return true;\n        }\n\n        std::memcpy(buf, pos, rest);\n        pos = buf;\n        size_t len=std::fread(pos+rest, 1, BUF_SIZE-rest, fin);\n        *(endbuf = buf + (rest+len)) = 0;\n\n        return *pos;\n    }\n\n    inline bool scan(char &in) {\n        if ((in = *pos)) {\n            ++pos;\n            return true;\n        }\n\n        return rebuffer() && (in = *pos++);\n    }\n\n    inline bool scan(char *in) {\n        if ((*in = *pos) == 0) {\n            if (rebuffer() && (*in = *pos) == 0) {\n                return false;\n            }\n        }\n        ++in;\n        while (true) {\n            if ((*in = *pos++) == 0) {\n                if (rebuffer() && (*in = *pos++) == 0) {\n                    return true;\n                }\n            }\n            ++in;\n        }\n    }\n\n    inline bool scan(double &in) {\n        if (pos + FLT_LEN >= endbuf && !rebuffer()) {\n            in = 0.0;\n            return false;\n        }\n\n        char *tmp;\n        in = std::strtod(pos, &tmp);\n        pos = tmp;\n        return true;\n    }\n\n    template <class Int>\n    inline bool scan(Int &in) {\n        in = 0;\n\n        // assume that no redundant whitespace appears\n        if (pos + INT_LEN >= endbuf && !rebuffer()) {\n            return false;\n        }\n\n        if (std::is_signed<Int>::value) {\n            if (*pos == '-') {\n                in = ~*++pos+'1';\n                while (*++pos >= '0') {\n                    in = in*10 + ~*pos+'1';\n                }\n                ++pos;\n                return true;\n            }\n        }\n\n        // assume that numbers are separated by the character whose value is\n        // less than '0' (e.g. whitespaces, newlines)\n        do {\n            in = in*10 + *pos-'0';\n        } while (*++pos >= '0');\n        ++pos;\n        return true;\n    }\n\n    inline bool eat() {\n        if (*pos > ' ') {\n            return true;\n        }\n\n        do {\n            if (*pos == 0 && !rebuffer()) {\n                return false;\n            }\n        } while (*++pos <= ' ');\n\n        return true;\n    }\n\n    inline bool eat(char ch) {\n        if (*pos == ch) {\n            return true;\n        }\n\n        do {\n            if (*pos == 0 && !rebuffer()) {\n                return false;\n            }\n        } while (*++pos != ch);\n\n        return true;\n    }\n\n    class Scanner {\n        bool rebuffer() {\n            return FastIn::rebuffer();\n        }\n\n    public:\n        Scanner(FILE *fin=stdin) {\n            FastIn::fin = fin;\n            endbuf = pos + std::fread(buf, 1, BUF_SIZE, fin);\n        }\n\n        template <class T>\n        inline bool scan(T &in) {\n            return FastIn::scan(in);\n        }\n\n        template <class First, class... Rest>\n        inline bool scan(First &in, Rest &...ins) {\n            return scan(in) && scan(ins...);\n        }\n    };\n}\n\ntemplate<size_t N>\nsize_t rankF2(vector<bitset<N>>& a, long n, long m){ // calculate rank of matrix in F_2\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)if(a[j][now])a[j] ^= a[i];\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n    \n    FastIn::Scanner in;\n\n    unsigned long N, M;\n    in.scan(N, M);\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<bitset<300>> a(N);\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0, k; j < N; ++j){\n        in.scan(k);\n        a[j][i] = k > 0;\n    }\n    else for(auto& i : a)for(int j = 0, k; j < M; ++j){\n        in.scan(k);\n        i[j] = k > 0;\n    }\n\n    auto r = rankF2(a, N, M);\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 306;\nconst ll mod = 998244353;\ntypedef bitset<N> bst;\n\nbst a[N],b[N],empty;\n\nint n,m;\n\nint cal() {\n    int ret = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = m; j >= 0; --j)\n            if (a[i][j]) {\n                if (b[j] != empty) a[i] ^= b[j];\n                else {\n                    ++ret;\n                    b[j] = a[i];\n                    for (int k = j - 1; k >= 0; --k) if (b[k] != empty && (b[j][k])) b[j] ^= b[k];\n                    for (int k = j + 1; k <= m; ++k) if (b[k][j]) b[k] ^= b[j];\n                    break;\n                }\n            }\n    return ret;\n}\n\nll ppow(ll a,ll n) {\n    ll ret=1,now=a;\n    while (n) {\n        if (n&1) {\n            ret *= now;\n            ret %= mod;\n        }\n        now *= now;\n        now %= mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nll rev(ll x) {\n    return ppow(x,mod-2);\n}\n\nint main () {\n    //int n,m;\n    cin >> n >> m;\n    for (int i=0;i<n;++i) {\n        for (int j=0;j<m;++j) {\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int x = cal();\n    //cout << \"x = \" << x << endl;\n    ll all_zero = ppow(2,n-x);\n    //cout << \"all_zero = \" << all_zero << endl;\n    ll ans = ppow(2,n+m);\n    //cout << \" ans = \" << ans << endl;\n    ans -= all_zero * ppow(2,m);\n    //cout << \"ans = \" << ans << endl;\n    ans = (ans%mod+mod)%mod;\n    cout << ans * rev(2) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(auto &it : (v))\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define sz(x) (int)(x).size()\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nll powerMod(ll a, ll x) {\n    ll ans = 1;\n    while(x--) {\n        ans *= a;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> a(N, vector<int>(M));\n    rep(i,0,N)\n        rep(j,0,M) {\n            cin >> a[i][j];\n        }\n    int pos = 0;\n    rep(j,0,M) {\n        bool ok = 0;\n        rep(i,pos,N) {\n            if (a[i][j]) {\n                swap(a[i], a[pos]);\n                ok = 1;\n                break;\n            }\n        }\n        if (ok) {\n            rep(i,pos+1,N) {\n                if (!a[i][j])\n                    continue;\n                rep(j2,0,M) {\n                    a[i][j2] ^= a[pos][j2];\n                }\n            }\n            ++pos;\n        }\n    }\n    int rank = pos;\n    ll ans = powerMod(2, N+M-1);\n    ans -= powerMod(2, N+M-1-rank);\n    ans %= MOD;\n    if (ans < 0)\n        ans += MOD;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)x.size()\n#define mem(a) memset(a, 0, sizeof(a))\n#define sqr(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int mn = 305;\nconst int mod = 998244353;\n#define P mod\n\nint n,m;\n\nint b[mn][mn];\n\nll powmod(ll a, ll b) {\n    ll t = 1;\n    for (; b; b >>= 1, a = a*a%P)\n        if (b & 1) t = t*a%P;\n    return t;\n}\n\nbitset<300> p[mn],a[mn];\n\nint r=0;\n\nvoid init() {\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!a[i][j]) continue;//对线性基的这一位没有贡献\n            if (!p[j].any()) {\n                p[j] = a[i];\n                r++;\n                break;\n            }//选入线性基中\n            a[i] ^= p[j];\n        }\n    }\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"../1.txt\", \"r\", stdin);\n#endif\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<m;j++){\n              scanf(\"%d\",&b[i][j]);\n              a[i][j]=b[i][j];\n        }\n    }\n    init();\n    printf(\"%lld\\n\",(powmod(2,n+m-1)-powmod(2,n+m-r-1)+mod)%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n/* FastIO by rsk0315 (last update: 2018/02/21 00:36) */\n\nnamespace FastIn {\n    static constexpr size_t BUF_SIZE=1<<17, INT_LEN=24, FLT_LEN=400;\n    static char buf[BUF_SIZE|1]={}, *pos=buf, *endbuf=nullptr;\n    FILE *fin;\n\n    inline bool rebuffer() {\n        // returns true <=> there is at least one unread character\n        size_t rest=endbuf-pos;\n        if (buf+rest > pos) {\n            // buf[:pos] and buf[-pos:] are overlapping, which std::memcpy()\n            // causes undefined behavior.\n            return true;\n        }\n\n        std::memcpy(buf, pos, rest);\n        pos = buf;\n        size_t len=std::fread(pos+rest, 1, BUF_SIZE-rest, fin);\n        *(endbuf = buf + (rest+len)) = 0;\n\n        return *pos;\n    }\n\n    inline bool scan(char &in) {\n        if ((in = *pos)) {\n            ++pos;\n            return true;\n        }\n\n        return rebuffer() && (in = *pos++);\n    }\n\n    inline bool scan(char *in) {\n        if ((*in = *pos) == 0) {\n            if (rebuffer() && (*in = *pos) == 0) {\n                return false;\n            }\n        }\n        ++in;\n        while (true) {\n            if ((*in = *pos++) == 0) {\n                if (rebuffer() && (*in = *pos++) == 0) {\n                    return true;\n                }\n            }\n            ++in;\n        }\n    }\n\n    inline bool scan(double &in) {\n        if (pos + FLT_LEN >= endbuf && !rebuffer()) {\n            in = 0.0;\n            return false;\n        }\n\n        char *tmp;\n        in = std::strtod(pos, &tmp);\n        pos = tmp;\n        return true;\n    }\n\n    template <class Int>\n    inline bool scan(Int &in) {\n        in = 0;\n\n        // assume that no redundant whitespace appears\n        if (pos + INT_LEN >= endbuf && !rebuffer()) {\n            return false;\n        }\n\n        if (std::is_signed<Int>::value) {\n            if (*pos == '-') {\n                in = ~*++pos+'1';\n                while (*++pos >= '0') {\n                    in = in*10 + ~*pos+'1';\n                }\n                ++pos;\n                return true;\n            }\n        }\n\n        // assume that numbers are separated by the character whose value is\n        // less than '0' (e.g. whitespaces, newlines)\n        do {\n            in = in*10 + *pos-'0';\n        } while (*++pos >= '0');\n        ++pos;\n        return true;\n    }\n\n    inline bool eat() {\n        if (*pos > ' ') {\n            return true;\n        }\n\n        do {\n            if (*pos == 0 && !rebuffer()) {\n                return false;\n            }\n        } while (*++pos <= ' ');\n\n        return true;\n    }\n\n    inline bool eat(char ch) {\n        if (*pos == ch) {\n            return true;\n        }\n\n        do {\n            if (*pos == 0 && !rebuffer()) {\n                return false;\n            }\n        } while (*++pos != ch);\n\n        return true;\n    }\n\n    class Scanner {\n        bool rebuffer() {\n            return FastIn::rebuffer();\n        }\n\n    public:\n        Scanner(FILE *fin=stdin) {\n            FastIn::fin = fin;\n            endbuf = pos + std::fread(buf, 1, BUF_SIZE, fin);\n        }\n\n        template <class T>\n        inline bool scan(T &in) {\n            return FastIn::scan(in);\n        }\n\n        template <class First, class... Rest>\n        inline bool scan(First &in, Rest &...ins) {\n            return scan(in) && scan(ins...);\n        }\n    };\n}\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    auto add = [&m](vector<long>& to, vector<long>& from){\n        for(int i = 0; i < m; ++i)to[i] ^= from[i];\n    };\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)if(a[j][now])add(a[j], a[i]);\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n    \n    FastIn::Scanner in;\n\n    long N, M;\n    in.scan(N, M);\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)in.scan(a[j][i]);\n    else for(auto& i : a)for(auto &j : i)in.scan(j);\n\n    auto r = rankF2(a);\n    printf(\"%ld\\n\", modpow(N + M - r - 1) * (modpow(r) - 1) % m);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 1000001;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a%b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) *b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\n\n///////////////////////////\n\nll p(ll n) {\n\tif (n == 0) { return 1; }\n\treturn p(n - 1) * 2 % MOD;\n}\n\n\n\nint main() {\n\tll N, M;\n\tcin >> N >> M;\n\n\tvector<vector<ll>> a(N + 1, vector<ll>(M + 1));\n\n\trepn(i, N)repn(j, M) cin >> a[i][j];\n\n\trepn(i, M) {\n\t\tll t = 0;\n\t\trepn(j, N) {\n\t\t\tif (a[j][i] == 1) { t = j; break; }\n\t\t}\n\n\t\tif (t == 0) { continue; }\n\n\t\tfor (ll j = t+1; j <= N; j++) {\n\t\t\tif (a[j][i] == 0) { continue; }\n\n\t\t\tfor (ll k = i; k <= M; k++) {\n\t\t\t\ta[j][k] = (a[j][k] + a[t][k]) % 2;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tll zero = 0;\n\t\n\trepn(i, N) {\n\t\tll b = 1;\n\t\trepn(j, M) { if (a[i][j] != 0) { b = 0; } }\n\t\tzero += b;\n\t}\n\n\t\n\tll X = p(N) - p(zero);\n\tX = (X%MOD + MOD) % MOD;\n\n\tll ans = X * p(M - 1) % MOD;\n\tcout << ans;\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cout<<v[i][j]<<\" \";}cout<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nvii rotate(vii a) {\n  int h = a.size(), w = a[0].size();\n  vii b(w, vi(h));\n  rep (i, h) {\n    rep (j, w) {\n      b[j][i] = a[i][j];\n    }\n  }\n  return b;\n}\n\n\nconst int MAXN = 3010;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n\tfact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n\tfor (ll i = 2; i <= n; i++) {\n\t\tfact[i] = i * fact[i - 1] % M;\n\t\trfact[i] = mod_inverse(fact[i], M);\n\t}\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  ll ret = fact[n];\n  ret = (ret*rfact[r]) % M;\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\n\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n  vii a(h, vi(w));\n  rep (i, h) {\n    rep (j, w) {\n      cin >> a[i][j];\n    }\n  }\n  if (h < w) {\n    swap(h, w);\n    a = rotate(a);\n  }\n  set_fact(h + 100);\n  int no = 0;\n  rep (j, w) {\n    if (a[j][j] == 0) {\n      for (int i = j + 1; i < h; i++) {\n        if (a[i][j] == 1) {\n          swap(a[i], a[j]);\n          break;\n        }\n      }\n    }\n    if (a[j][j] == 0) {\n      no++;\n      continue;\n    }\n    for (int i = 0; i < h; i++) {\n      if (i == j) continue;\n      a[i][j] = 0;\n    }\n  }\n  for (int i = 0; i < w; i++) {\n    for (int j = i + 1; j < w; j++) {\n      a[i][j] = 0;\n    }\n  }\n  int r = w - no;\n  ll ans = mod_pow(2, h + w - 1) - mod_pow(2, h + w - r - 1);\n  ans = (ans + MOD) % MOD;\n  cout << ans << endl;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t r = 0;\n    for (std::size_t c = 0; c < mat.C; c++) {\n        if (r == mat.R) { return r; }\n        std::size_t piv = r;\n        for (; piv < mat.R and mat[piv][c] == 0; piv++) {}\n        if (piv == mat.R) { continue; }\n        std::swap(mat[r], mat[piv]);\n        for (std::size_t j = c + 1; j < mat.C; j++) { mat[r][j] /= mat[r][c]; }\n        const T p = mat[r][c];\n        for (std::size_t i = r; i < mat.R; i++) { mat[i][c] /= p; }\n        for (std::size_t i = r + 1; i < mat.R; i++) {\n            for (std::size_t j = i + 1; j < mat.C; j++) { mat[i][j] -= mat[r][j] * mat[i][c]; }\n        }\n        r++;\n    }\n    return r;\n}\nconstexpr int MOD = 998244353;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<int> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<int> bp(600, 1);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2 % MOD; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD) % MOD << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,k,n) for(int i=k;i<=n;i++)\n#define rep2(i,k,n) for(int i=k;i>=n;i--)\n#define mod 998244353\nusing namespace std;\ninline void upd(int& x,int y){\n\tx+=y;\n\tx-= (x>=mod) ? mod : 0;\n}\nconst int N=305;\nint pw[N<<1],f[N],a[N][N],n,m;\nint main(){\n\tpw[0]=1;rep(i,1,600)pw[i]=pw[i-1],upd(pw[i],pw[i-1]);\n\trep(i,1,N-1)f[i]=pw[(i-1)<<1],upd(f[i],f[i-1]),upd(f[i],f[i-1]);\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n)rep(j,1,m)scanf(\"%d\",&a[i][j]);\n\tint r=0;\n\trep(i,1,n){\n\t\tint t=0;\n\t\trep(j,i,n)if(a[j][i]){t=j;break;}\n\t\tif(!t)continue;\n\t\tr++;\n\t\trep(j,1,m)swap(a[i][j],a[t][j]);\n\t\trep(j,i+1,n)if(a[j][i]){\n\t\t\trep(k,i,m)a[j][k]^=a[i][k];\n\t\t}\n\t}\n\tint ans=1ll*f[r]*pw[n-r]%mod*pw[m-r]%mod;\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\nconst int N=305;\nconst int mod=998244353;\nint a[N][N];\nint main()\n{\n\tint n,m,i,j,k;\n\tscanf(\"%i %i\",&n,&m);\n\tfor(i=1;i<=n;i++) for(j=1;j<=m;j++) scanf(\"%i\",&a[i][j]);\n\tint r=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tbool ok=0;\n\t\tfor(j=r+1;j<=n;j++)\n\t\t{\n\t\t\tif(a[j][i])\n\t\t\t{\n\t\t\t\tfor(k=i;k<=n;k++) swap(a[j][k],a[r+1][k]);\n\t\t\t\tok=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) continue;\n\t\tr++;\n\t\tfor(j=r+1;j<=n;j++) if(a[j][i])\n\t\t{\n\t\t\tfor(k=i;k<=n;k++) a[j][k]=(a[j][k]-a[r][k]+2)%2;\n\t\t}\n\t}\n\tint ans=1,sol=1;\n\tfor(i=1;i<=n+m-1;i++) ans=ans*2%mod;\n\tfor(i=1;i<=n+m-r-1;i++) sol=sol*2%mod;\n\tans-=sol;\n\tif(ans<0) ans+=mod;\n\tprintf(\"%i\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nbitset<301>AA[301];\nint main(){\n    MOD=998244353;\n    int n,m;\n    R(n,m);\n    REP(i,n){\n        REP(j,m){\n            int x; R(x);\n            if(x)AA[i][j]=1;\n        }\n    }\n    int now=0;\n    LL all=1,zero=1;\n    REP(i,n)all=all*2%MOD;\n    REP(i,m){\n        if(now>=n)break;\n        REPP(j,now,n){\n            if(AA[j][i]){\n                if(j!=now)swap(AA[j],AA[now]);\n                break;\n            }\n        }\n        if(!AA[now][i])continue;\n        REP(j,n){\n            if(j==now)continue;\n            if(AA[j][i])AA[j]^=AA[now];\n        }\n        now++;\n    }\n    REP(i,n-now)zero=zero*2%MOD;\n    ADD(all,-zero);\n    LL two=1;\n    REP(i,m-1)two=two*2%MOD;\n    W(all*two%MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n        mat<COL_SIZE> b(r);\n        for(int i = 0; i < r; i++) b[i] = a[i];\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n        return a[index];\n    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<305>a(m+5);\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = a.rank();\n    cerr << r << endl;\n    cout << (mod_pow(2,n+m-1) - mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nint n,m,a[310][310];\nint od[310],ev[310],bit[310];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n/*\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n*/\n/*\tfor(int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tprintf(\"%d \",a[i][j]);\n*/\n\n\tint u=max(n,m);\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=u;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i]) continue;\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=u;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=u;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set> \n#include<cmath>\n#include <numeric>\n#include <array>\n#include <complex>\nusing namespace std;\nlong long p = 998244353;\n//long long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nvel kai;\nvel inv_kai;\nint rui(int a, int n, int mod) {\n    if (n == 0) { return 1 % mod; }\n    int x = rui(a, n / 2, mod);\n    x *= x; x %= mod;\n    if (n % 2 == 1) { x *= a; x %= mod; }\n    return x;\n}\nint root(int x, vel& pa) {\n    if (pa[x] == -1) { return x; }\n    int ans = root(pa[x], pa); pa[x] = ans;\n    return ans;\n}\nbool mar(int x, int y, vel& pa) {\n    x = root(x, pa);\n    y = root(y, pa);\n    if (x != y) { pa[x] = y; }\n    return (x != y);\n}\nint gcd(int x, int y) {\n    if (x < y) { return gcd(y, x); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\nint lcm(int x, int y) {\n    x = abs(x); y = abs(y);\n    return x * y / gcd(x, y);\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nvoid make_kai(int max_kai) {\n    kai = vel(max_kai, 1);\n    inv_kai = kai;\n    rep(i, max_kai - 1) {\n        kai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n        inv_kai[i + 1] = modinv(kai[i + 1], p);\n    }\n}\nint com(int n, int r) {\n    if ((n < 0) || (r < 0) || (r > n)) { return 0; }\n    int ans = (kai[n] * inv_kai[r]) % p;\n    return (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n    if (x.size() == 0) { return x; }\n    sor(x);\n    int n = x.size();\n    vel ans(1, x[0]);\n    for (int j = 1; j < n; j++) {\n        if (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n    }\n    x = ans;\n    return x;\n}\nvoid pr(vel& v) {\n    int n = v.size();\n    if (n != 0) {\n        cout << v[0];\n        rep(i, n - 1) {\n            cout << \" \" << v[i + 1];\n        }\n        cout << endl;\n    }\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n    int n = way.size();\n    vel dist(n, inf); dist[st] = 0;\n    priority_queue<pin, vector<pin>, greater<pin>> pq;\n    pq.push(mkp(0, st));\n    veb is_checked(n, false);\n    while (!pq.empty()) {\n        pin x = pq.top(); pq.pop();\n        int pot = x.second;\n        if (!is_checked[pot]) {\n            is_checked[pot] = true;\n            for (auto y : way[pot]) {\n                int nex_dist = x.first + y.second;\n                int nex_pot = y.first;\n                if (dist[nex_pot] > nex_dist) {\n                    dist[nex_pot] = nex_dist;\n                    pq.push(mkp(nex_dist, y.first));\n                }\n            }\n        }\n    }\n    return dist;\n}\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\nvel mul(vel& a, vel& b) {\n    int n = a.size();\n    int m = b.size();\n    vel ans(n + m - 1, 0);\n    rep(i, n) {\n        rep(j, m) {\n            ans[i + j] += a[i] * b[j];\n            ans[i + j] %= p;\n        }\n    }\n    return ans;\n}\nvel rui_p(vel& a, int n) {\n    if (n == 0) { return { 1 }; }\n    vel qans = rui_p(a, n / 2);\n    qans = mul(qans, qans);\n    if (n % 2 == 1) {\n        qans = mul(qans, a);\n    }\n    return qans;\n}\nvvel disj_min(vel& v) {\n    int n = v.size();\n    vvel ret(22, vel(n));\n    ret[0] = v;\n    rep(i, 21) {\n        rep(j, n) {\n            int nex = j + (1 << i);\n            if (nex < n) {\n                ret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n            }\n            else {\n                ret[i + 1][j] = ret[i][j];\n            }\n        }\n    }\n    return ret;\n}\nvvel disj_max(vel& v) {\n    int n = v.size();\n    vvel ret(20, vel(n));\n    ret[0] = v;\n    rep(i, 19) {\n        rep(j, n) {\n            int nex = j + (1 << i);\n            if (nex < n) {\n                ret[i + 1][j] = max(ret[i][j], ret[i][nex]);\n            }\n            else {\n                ret[i + 1][j] = ret[i][j];\n            }\n        }\n    }\n    return ret;\n}\nint find_min(vvel& dv, int l, int r) {\n    int i = 19;\n    while (l + (1 << i) > r) {\n        i--;\n    }\n    return min(dv[i][l], dv[i][r - (1 << i)]);\n}\nint find_max(vvel& dv, int l, int r) {\n    int i = 19;\n    while (l + (1 << i) > r) {\n        i--;\n    }\n    return max(dv[i][l], dv[i][r - (1 << i)]);\n}\nbool is_prime(int n) {\n    if (n == 0 || n == 1) { return false; }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) { return false; }\n    }\n    return true;\n}\n#define double long double\n#define pd pair<double,double>\n#define bs bitset<300>\nvoid per(int& ans) {\n    ans %= p;\n    if (ans < 0) { ans += p; }\n}\nint count_zero(V<bs>& a) {\n    int n = a.size();\n    int now_st = 0;\n    rep(i, 300) {\n        int fir_ze = -1;\n        for (int j = now_st; j < n; j++) {\n            if (a[j][i]) { fir_ze = j; break; }\n        }\n        if (fir_ze >= 0) {\n            rep(j, n) {\n                if (j != fir_ze&&a[j][i]) {\n                    a[j] = a[fir_ze] xor a[i];\n                }\n            }\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        bool fl = true;\n        rep(j, 300) {\n            if (a[i][j]) { fl = false; break; }\n        }\n        if (fl) { ans++; }\n    }\n    return ans;\n}\nsigned main() {\n    int n, m; cin >> n >> m;\n    V<bs> a(n);\n    rep(i, n) {\n        rep(j, m) {\n            int x; cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int cz = count_zero(a);\n    int ans = rui(2, n,p) - rui(2, cz,p); per(ans);\n    ans*=rui(2, m - 1, p); per(ans);\n    cout << ans % p << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=998244353;\n\nint N;\nint M;\nint mat[314][314];\n\nLL mypow(LL base, LL exp) {\n  if (exp == 0) return 1;\n  LL res = mypow(base*base%MOD, exp/2);\n  if (exp%2) res = res*base%MOD;\n  return res;\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  rep(i, N) {\n    rep(j, M) {\n      scanf(\"%01d\", &mat[i][j]);\n    }\n  }\n\n  rep(k, M) {\n    reps(i, k, N) {\n      if (!mat[i][k]) continue;\n      rep(j, M) {\n        swap(mat[i][j], mat[k][j]);\n      }\n\n      rep(j, N) {\n        if (k == j) continue;\n        if (!mat[j][k]) continue;\n        rep(l, M) {\n          mat[j][l] += mat[k][l];\n          mat[j][l] %= 2;\n        }\n      }\n    }\n  }\n\n  int rank = 0;\n  rep(k, min(M, N)) {\n    if (mat[k][k]) rank++;\n  }\n\n  LL ans = mypow(2, N+M-1);\n  ans += MOD - mypow(2, N+M-1-rank);\n  ans %= MOD;\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<cctype>\n#include<set>\n#include<queue>\n#include<vector>\n#include<map>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n\tint x=0,f=1;char ch=getchar();for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';return x*f;\n}\n\nconst int N = 305, mod = 998244353;\nbitset<N>a[N], b[N];\n\nint ksm(int a,int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n = read(), m = read(), cnt = 0;\n\tfor (int i = 1; i <= n; ++i) \n\t\tfor (int j = 1; j <= m; ++j) a[i][j] = read();\n\tfor (int i = 1; i <= n; ++i) \n\t\tfor (int j = 1; j <= m; ++j) \n\t\t\tif (a[i][j]) {\n\t\t\t\tif (!b[j][j]) {\n\t\t\t\t\tb[j] = a[i];\n\t\t\t\t\tcnt ++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[i] ^= b[j];\n\t\t\t\t}\n\t\t\t}\n\tcout << 1ll * (ksm(2, n) - ksm(2, n - cnt) + mod) % mod * ksm(2, m - 1) % mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=998244353;\nlong long n,m,a[333][333],pw[666],cnt,pos,cur,upper;\n/*long long Guass(long long Row,long long Column)\n{\n    long long row=1,col=1,max_r;\n    for(row=1;row<=Row&&col<=Column;row++,col++)\n    { \n        max_r=row;\n        for(long long i=row+1;i<=Row;i++)\n            if(abs(a[i][col])>abs(a[max_r][col]))\n                max_r=i;\n        if(a[max_r][col]==0)\n        {\n            row--;\n            continue;\n        }\n        if(max_r!=row)\n            for(long long i=col;i<=Column;i++)\n                swap(a[row][i],a[max_r][i]);\n\n        for(long long i=row+1;i<=Row;i++)\n        {\n            if(a[i][col]!=0)\n            {\n\n                for(long long j=col;j<=Column;j++)\n                    a[i][j]^=a[row][j];\n            }\n        }\n    }\n\treturn Column-row+1;\n}*/\nvoid gauss()\n{\n\tupper=1;\n\tfor (long long i=1;i<=m;i++)\n\t{\n\t\tpos=-1;\n\t\tfor (long long j=upper;j<=n;j++)\n\t\t{\n\t\t\tif (a[j][i])\n\t\t\t{\n\t\t\t\tpos=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~pos)\n\t\t{\n\t\t\tfor (long long j=1;j<=m;j++) swap(a[upper][j],a[pos][j]);\n\t\t\tfor (long long j=upper+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif (a[j][i])\n\t\t\t\t{\n\t\t\t\t\tfor (long long k=i;k<=m;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][k]^=a[upper][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupper++;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tfor (long long j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tpw[0]=1;\n\tfor (long long i=1;i<=600;i++) pw[i]=pw[i-1]*2%mod;\n\tgauss();\n\tcur=pw[m-upper+1];\n\tprintf(\"%lld\\n\",((pw[n+m-1]-pw[n-1]*cur)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> //STLͨ���㷨\n#include <cmath> //������ѧ����\n#include <cstdio> //��������/�������\n#include <iostream> //����������/���\n#include <cstring> //�ַ�������\n#include <string> //�ַ�����\n#include <ctime> //�������ʱ��ĺ���\n#define itn int\n#define fro for\n#define ll long long\n#define reg register\n#define inf 1234567890\n#define rep(i,a,b,c) for (int i=a;i<=b;i+=c)\n/*#include <bitset> //STLλ������\n#include <cstype> //�ַ�����\n#include <cerrno> //���������\n#include <complex> //������\n#include <clocale> //���屾�ػ�����\n#include <cstdlib> //������������ڴ���亯��\n#include <deque> //STL˫�˶�������\n#include <exception> //�쳣������\n#include <fstream> //�ļ�����/���\n#include <functional> //STL�������㺯��(���������)\n#include <limits> //�����������������ֵ����\n#include <list> //STL�����б�����\n#include <map> //STLӳ������\n#include <iomanip> //����������/���\n#include <ios> //��������/���֧��\n#include <iosfwd> //����/���ϵͳʹ�õ�ǰ������\n#include <istream> //����������\n#include <ostream> //���������\n#include <queue> //STL��������\n#include <set> //STL��������\n#include <sstream> //�����ַ�������\n#include <stack> //STL��ջ����\n#include <stdexcept> //��׼�쳣��\n#include <streambuf> //�ײ�����/���֧��\n#include <utility> //STLͨ��ģ����\n#include <vector> //STL��̬��������\n#include <cwchar.h>//���ַ�����������/���\n#include <cwctype.h> //���ַ�����*/\n\nusing namespace std;\n\nint ans;\n\nint max(int x,int y){return x>y?x:y;}\n\nint min(int x,int y){return x<y?x:y;}\n\nint abs(int x){return x>0?x:-x;}\n\nint gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\n\nvoid exgcd(int a,int b,int &d,int &x,int &y){if (!b){d=a,x=1,y=0;}else{exgcd(b,a%b,d,y,x);y-=x*(a/b);}}\n\n\ninline char read() {\n\tstatic const int IN_LEN = 1000000;\n\tstatic char buf[IN_LEN], *s, *t;\n\treturn (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);\n}\ntemplate<class T>\ninline void read(T &x) {\n\tstatic bool iosig;\n\tstatic char c;\n\tfor (iosig = false, c = read(); !isdigit(c); c = read()) {\n\t\tif (c == '-') iosig = true;\n\t\tif (c == -1) return;\n\t}\n\tfor (x = 0; isdigit(c); c = read()) x = x * 10 + (c ^ '0');\n\tif (iosig) x = -x;\n}\n\nchar sr[10000000],z[20];int C=-1,Z=0;\nvoid Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(int x){\n\tif (x<0) sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\n//int find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}\n\n//void add(int x,int y,int z){to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;}\nconst int mod=998244353,N=512;\nint a[N][N],s[N][N];\n\nint quick_power(ll a,int b){ll r=1;for (;b;b>>=1,a=a*a%mod)if (b&1) r=r*a%mod;return r;}\n\nint main()\n{\n\tint n,m;\n\tread(n);read(m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++) read(a[i][j]);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tif (a[i][j])\n\t\t\t{\n\t\t\t\tif (!s[i][j])\n\t\t\t\t{\n\t\t\t\t\tfor (int k=j;k<=m;k++) s[i][k]=a[i][k];\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int k=j;k<=m;k++) s[i][k]^=a[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans=1ll*(quick_power(2,n)-quick_power(2,n-ans))*quick_power(2,m-1)%mod;\n\t(ans+=mod)%=mod;\n\tcout<<ans;\n\treturn 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 998244353;\n\ntemplate <int mod>\nstruct modint {\n    lint v;\n    modint() : v(0) {}\n    modint(signed v) : v(v) {}\n    modint(lint t) {\n        v = t % mod;\n        if (v < 0)\n            v += mod;\n    }\n\n    modint pow(lint k) {\n        modint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n    static modint add_identity() { return modint(0); }\n    static modint mul_identity() { return modint(1); }\n    modint inv() { return pow(mod - 2); }\n\n    modint &operator+=(modint a) {\n        v += a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator-=(modint a) {\n        v += mod - a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator*=(modint a) {\n        v = v * a.v % mod;\n        return *this;\n    }\n    modint &operator/=(modint a) { return (*this) *= a.inv(); }\n\n    modint operator+(modint a) const { return modint(v) += a; };\n    modint operator-(modint a) const { return modint(v) -= a; };\n    modint operator*(modint a) const { return modint(v) *= a; };\n    modint operator/(modint a) const { return modint(v) /= a; };\n\n    modint operator-() const { return v ? modint(mod - v) : modint(v); }\n\n    bool operator==(const modint a) const { return v == a.v; }\n    bool operator!=(const modint a) const { return v != a.v; }\n    bool operator<(const modint a) const { return v < a.v; }\n};\nusing mint = modint<mod>;\nostream &operator<<(ostream &os, mint m) { return os << m.v; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> a(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> a[i][j];\n        }\n    }\n    vector<bool> used(n, false);\n    int rank = 0;\n    for (int i = 0; i < m; ++i) {\n        int idx = -1;\n        for (int j = 0; j < n; ++j) {\n            if (!used[j] && a[j][i] == 1) {\n                idx     = j;\n                used[j] = true;\n                break;\n            }\n        }\n        if (idx == -1)\n            continue;\n        for (int j = 0; j < n; ++j) {\n            if (j != idx && a[j][i] == 1) {\n                for (int k = i; k < n; ++k) {\n                    a[j][k] ^= a[idx][k];\n                }\n            }\n        }\n        rank++;\n    }\n    mint ret = mint(2).pow(n + m - rank - 1) * (mint(2).pow(rank) - 1);\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void mmax(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void mmin(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nconstexpr lint MOD = 998244353;\n\n// Solve ax+by=gcd(a, b)\nlint extgcd(lint a, lint b, lint &x, lint &y)\n{\n    lint d = a;\n    if (b != 0) d = extgcd(b, a % b, y, x), y -= (a / b) * x;\n    else x = 1, y = 0;\n    return d;\n}\n// Calc a^(-1) (MOD m)\nlint mod_inverse(lint a, lint m)\n{\n    lint x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\nvector<vector<lint>> gauss_jordan(vector<vector<lint>> mtr, lint mod)\n{\n    // Gauss-Jordan elimination ガウスの消去法\n    // for (auto &vec : mtr) for (auto &val : vec) val = (val + mod) % mod;\n    int H = mtr.size(), W = mtr[0].size(), c = 0;\n    REP(h, H)\n    {\n        if (c == W) break;\n        if (mtr[h][c] == 0)\n        {\n            int piv = -1;\n            FOR(j, h + 1, H)\n            {\n                if (mtr[j][c] == 0) continue;\n                if (piv == -1 or abs(mtr[j][c]) > abs(mtr[piv][c])) piv = j;\n            }\n            if (piv == -1)\n            {\n                c++, h--;\n                continue;\n            }\n            swap(mtr[piv], mtr[h]);\n        }\n        lint pivinv = mod_inverse(mtr[h][c], mod);\n        FOR(hh, h + 1, H) IFOR(w, c, W)\n        {\n            mtr[hh][w] = (mtr[hh][w] - mtr[h][w] * mtr[hh][c] % mod * pivinv % mod + mod) % mod;\n        }\n        c++;\n    }\n    return mtr;\n}\n\nint rank_gauss_jordan(const vector<vector<lint>> &mtr)\n{\n    // gauss_jordanを実行した後の行列のランク計算\n    IREP(h, mtr.size()) for (auto v : mtr[h]) if (v) return h + 1;\n    return 0;\n}\n\nlint power(lint x, lint n, lint MOD)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= MOD;\n        (x *= x) %= MOD;\n       n >>= 1;\n    }\n   return ans;\n}\n\n\nint main()\n{\n    lint N;\n    cin >> N;\n    lint M;\n    cin >> M;\n    vector<vector<lint>> a(N, vector<lint>(M));\n    cin >> a;\n    int rnk = rank_gauss_jordan(gauss_jordan(a, 2));\n    cout << (power(2, N + M - 1, MOD) - power(2, N + M - rnk - 1, MOD) + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    auto add = [&m](vector<long>& to, vector<long>& from){\n        for(int i = 0; i < m; ++i)to[i] ^= from[i];\n    };\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)if(a[j][now])add(a[j], a[i]);\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 998244353;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M;\n    cin >> N >> M;\n    vvec<int> A(N,vec<int>(M));\n    for(int i=0;i<N;i++) for(int j=0;j<M;j++) cin >> A[i][j];\n    vec<mint> pow2(max(N,M)+1,1);\n    for(int i=1;i<=max(N,M);i++) pow2[i] = pow2[i-1]*2;\n    int rank = 0;\n    for(int j=0;j<M;j++){\n        bool update = false;\n        for(int i=0;i<N;i++) if(A[i][j]){\n            swap(A[i],A[rank]);\n            update = true;\n            break;\n        }\n        if(update){\n            for(int i=0;i<N;i++) if(i!=rank){\n                for(int k=j;k<M;k++) (A[i][k] += A[rank][k])%=2;\n            }\n            rank++;\n        }\n    }\n    cout << pow2[N-1]*(pow2[M]-pow2[M-rank]) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\ntypedef double DOUBLE;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst ll LL_INF = 1e17 + 10;\nconst int INF = 1e9 + 10;\nconst ll MOD = 998244353;\n\nconst int MAXN = 3e2 + 5;\n\nint v[MAXN][MAXN];\n\nvoid solve(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tREP(i, 0, n) {\n\t\tREP(j, 0, m) {\n\t\t\tscanf(\"%d\", &v[i][j]);\n\t\t}\n\t}\n\tint ind = 0;\n\tREP(k, 0, m) {\n\t\tREP(i, ind, n) {\n\t\t\tif (v[i][k] == 1) {\n\t\t\t\tREP(j, k, m) {\n\t\t\t\t\tswap(v[i][j], v[ind][j]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (v[ind][k] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tREP(i, ind + 1, n) {\n\t\t\tif (v[i][k]) {\n\t\t\t\tv[i][k] = 0;\n\t\t\t\tREP(j, k + 1, m) {\n\t\t\t\t\tv[i][j] ^= v[ind][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\tll v1 = 1ll, v2 = 1ll;\n\tREP(i, 0, n + m - 1) {\n\t\tv1 = (v1 * 2) % MOD;\n\t}\n\tREP(i, 0, n + m - ind - 1) {\n\t\tv2 = (v2 * 2) % MOD;\n\t}\n\tll ans = (v1 + MOD - v2) % MOD;\n\tcout << ans << endl;\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 305, M = 998244353;\n\nint n, m, c;\nbitset<N> b[N];\n\nint f(int x){\n    int r = 1;\n    for(; x--; ) r = r * 2 % M;\n    return r;\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 0; i < n; i++){\n        for(int j = 0, x; j < m; j++){\n            scanf(\"%d\", &x);\n            b[i][j] = x;\n        }\n    }\n    for(int i = 0; i < m; i++){\n        int k = -1;\n        for(int j = c; j < n; j++) if(b[j][i]){ k = j; break; }\n        if(k < 0) continue;\n        swap(b[c], b[k]);\n        for(int j = c + 1; j < n; j++) if(b[j][i]) b[j] ^= b[k];\n        c++;\n    }\n    printf(\"%lld\\n\", 1LL * f(n + m - 1 - c) * (f(c) + M - 1) % M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll N=3000+7;\nconst ll MOD=998244353;\n\nll add(ll a,ll b)\n{\n        ll s=a+b;\n        s%=MOD;\n        s+=MOD;\n        s%=MOD;\n        return s;\n}\n\nll mul(ll a,ll b)\n{\n        return a*(long long)b%MOD;\n}\n\nll expow(ll a,ll b)\n{\n        ll res=1;\n        while(b)\n        {\n                if(b&1)\n                {\n                        res=mul(res,a);\n                }\n                a=mul(a,a);\n                b>>=1;\n        }\n        return res;\n}\n\nll inv(ll n)\n{\n        return expow(n,MOD-2);\n}\n\nll fact[N];\n\nll comb(ll n,ll k)\n{\n        ll x=fact[n];\n        ll y=mul(fact[k],fact[n-k]);\n        y=expow(y,MOD-2);\n        return mul(x,y);\n}\n\nll n,m;\n\nll mll;\n\nmap<vector<ll>,ll>freq;\n\nint32_t main()\n{\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n        freopen(\"input\",\"r\",stdin);\n        freopen(\"output\",\"w\",stdout);\n        fact[0]=1;\n        for(ll i=1;i<N;i++)\n        {\n                fact[i]=mul(fact[i-1],i);\n        }\n        ll cnt0=0;\n        cin>>n>>m;\n        mll=expow(2,m);\n        for(ll i=1;i<=n;i++)\n        {\n                vector<ll>ugar;\n                bool g=0;\n                for(ll j=1;j<=m;j++)\n                {\n                        ll x;\n                        cin>>x;\n                        ugar.push_back(x);\n                        if(x)\n                        {\n                                g=1;\n                        }\n                }\n                if(g==0) cnt0++;\n                freq[ugar]++;\n        }\n        ll tot=expow(2,n);\n        ll sum=0;\n        for(auto &it:freq)\n        {\n                ll cnt=it.second;\n                sum+=cnt-1;\n        }\n       /// cout<<cnt0<<\"\\n\";\n        if(cnt0>0) sum++;\n        ll lft=add(tot,-expow(2,sum));\n      ///  cout<<\"=\"<<lft<<\"\\n\";\n        ll res=mul(lft,mll);\n       /// cout<<tot-lft<<\"\\n\";\n        res=mul(res,inv(2));\n        cout<<res<<\"\\n\";\n        return 0;\n        cout<<\"A: \"<<res<<\"\\n\";\n        return 0;\n}\n/**\n\n**/\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nint elementaryMatrix(vector<bitset<300> >& mat)\n{\n    const int n = mat.size();\n    const int m = mat[0].size();\n    int y = 0;\n    int x = 0;\n    while(y < n && x < m){\n        int tmp = y;\n        while(tmp < n && !mat[tmp][x])\n            ++ tmp;\n\n        if(tmp < n){\n            swap(mat[y], mat[tmp]);\n            for(int i=y+1; i<n; ++i){\n                if(mat[i][x])\n                    mat[i] ^= mat[y];\n            }\n            ++ y;\n        }\n        ++ x;\n    }\n    mat.resize(y);\n    return y;\n}\n\nconst int MOD = 998244353;\n\nlong long power(long long a, int b)\n{\n    long long ret = 1;\n    long long tmp = a;\n    while(b > 0){\n        if(b & 1){\n            ret *= tmp;\n            ret %= MOD;\n        }\n        tmp *= tmp;\n        tmp %= MOD;\n        b >>= 1;\n    }\n    return ret;\n}\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    vector<bitset<300> > v(h);\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            int a;\n            cin >> a;\n            v[i][j] = a;\n        }\n    }\n\n    int rank = elementaryMatrix(v);\n    long long ans = power(2, h+w-1) - power(2, h+w-1-rank);\n    ans += MOD;\n    ans %= MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nint n,m,a[N][N],now[N],in[N],p[N][N],r;\ninline int poww(int a,int b){\n  int res=1;\n  for(;b;b>>=1,a=1ll*a*a%mod)\n    if(b&1)res=1ll*res*a%mod;\n  return res;\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=m;j++) scanf(\"%d\",&a[i][j]);\n  for(int i=1;i<=n;i++){\n    memcpy(now,a[i],sizeof(now));\n    for(int j=1;j<=m;j++)\n      if(now[j]){\n    if(in[j])for(int k=j;k<=m;k++)now[k]^=p[j][k];\n    else{in[j]=1;memcpy(p[j],now,sizeof(p[j]));r++;break;}\n      }\n  }\n  printf(\"%lld\\n\",1ll*(poww(2,n)-poww(2,n-r)+mod)%mod*poww(2,m-1)%mod);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n#define endl '\\n'\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\n\ntypedef vector<unsigned int> Array;\ntypedef vector<Array> Matrix;\n\nMatrix mul(const Matrix &a,const Matrix &b){\n    Matrix res(a.size(),Array(b[0].size()));\n    REP(i,a.size())\n        REP(j,b[0].size())\n            REP(k,a[0].size())\n                res[i][j] ^= a[i][k] & b[k][j];\n    return res;\n}\n\nMatrix pow(const Matrix &a,int b){\n    if(b==0){\n        Matrix res(a.size(),Array(a.size()));\n        REP(i,a.size()) res[i][i]=-1;\n        return res;\n    }\n    Matrix res=pow(mul(a,a),b/2);\n    if(b&1)res=mul(res,a);\n    return res;\n}\n\nint rankk(Matrix M){\n    int N = M.size();\n    int W = M[0].size();\n    int ret = 0;\n    int j = 0;\n    for(int i=0;i<N;i++){\n        int ma=i;\n        for(int k=i;k<N;k++) if(M[ma] < M[k]) ma = k;\n        swap(M[i], M[ma]);\n        for(;!M[i][j]&&j<W;j++);\n        if(W<=j) return ret;\n        for(int k=i+1;k<N;k++)\n            if(M[k][j])\n                for(int l=j;l<W;l++) M[k][l] ^= M[i][l];\n        ret ++;\n    }\n    return ret;\n}\n\ntemplate<int N, int MOD>\nstruct Comb{\n    ll fact[N+1], inv[N+1];\n    Comb(){\n        fact[0] = inv[0] = inv[1] = 1;\n        for(int i=2;i<=N;i++) inv[i] = (MOD+((ll)-inv[MOD%i]*(MOD/i))%MOD)%MOD;\n        REPS(i, N){\n            fact[i] = fact[i-1]*i%MOD;\n            inv[i] = inv[i]*inv[i-1]%MOD;\n        }\n    }\n    ll operator()(int n, int r){\n        if(n < 0 || r < 0 || r > n) return 0;\n        ll res = inv[r]*inv[n-r];\n        if(res >= MOD) res%= MOD;\n        res *= fact[n];\n        if(res >= MOD) res%= MOD;\n        return res;\n    }\n};\nComb<300000, MOD> C;\n\nll modpow(ll x, ll y){\n    ll r = 1, a = x % MOD;\n    while(y > 0){\n        if((y&1) == 1) r = (r*a) % MOD;\n        a = (a*a) % MOD;\n        y /= 2;\n    }\n    return r;\n}\n\nint T, n, m;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    while(cin >> n >> m){\n        Matrix mat(n, Array(m));\n        REP(i, n) {\n            REP(j, m) {\n                cin >> mat[i][j];\n            }\n        }\n        int r = rankk(mat);\n        ll ans = 0;\n        REPS(i, r) {\n            ans += modpow(2, n - 1) * C(r, i) % MOD * modpow(2, m - r) % MOD;\n            ans %= MOD;\n        }\n        cout << ans % MOD << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 303,mo=998244353;\nbitset<N>a[N],s;bool vis[N];\nint n,m;\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nbool ins(bitset<N>s){\n\trep(i,1,m)if(s[i])\n\t\tif(!vis[i]){a[i]=s;vis[i]=1;return 1;}\n\t\telse s^=a[i];\n\treturn 0;\n}\nint main() {\n\tread(n);read(m);int tot=n;\n\trep(i,1,n){\n\t\ts.reset();\n\t\trep(j,1,m){int x;read(x);s[j]=x;}\n\t\ttot-=ins(s);\n\t}\n\tint res=(power(2,n+m-1)-power(2,m-1+tot)+mo)%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#define MOD 998244353\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline int hiku(int a, const int &b) {return (a -= b) < 0 ? a + MOD : a;}\n\ninline ll fastpow(ll bas, ll ex){\n\tregister ll res = 1; bas %= MOD;\n\tfor(; ex; ex >>= 1, bas = bas * bas % MOD) if(ex & 1) res = res * bas % MOD;\n\treturn res;\n}\n\nint N, M;\nbitset<300> a[300], b[300];\n\ninline int insert(bitset<300> val){\n\tfor(register int i = M - 1; ~i; i--) if(val[i]){\n\t\tif(!b[i][i]) return b[i] = val, 1;\n\t\tval ^= b[i];\n\t}\n\treturn 0;\n}\n\nint main(){\n\tgetint(N), getint(M); int r = 0;\n\tfor(register int i = 0; i < N; i++)\n\t\tfor(register int j = 0, v; j < M; j++) getint(v), a[i][j] = v;\n\tfor(register int i = 0; i < N; i++) r += insert(a[i]);\n\treturn printf(\"%d\\n\", hiku(fastpow(2, N + M - 1), fastpow(2, N + M - r - 1))), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst ll INF = 1 << 30;//10^9\n//ll MOD = 1000000007;\nll MOD = 998244353;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A, ll x = 20){cout << fixed << setprecision(x) << A << endl;}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n\n//コンビネーション\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\n\nll Rank(ll N, ll M, vector<vector<ll>> A){\n  ll next = 0;\n  rep(i, M){\n    for(ll j = next; j < N; j++){\n      if(A[j][i]){\n        swap(A[next], A[j]);\n      }\n    }\n    if(!A[next][i]) continue;\n    rep(j, N)if(j != next){\n      if(A[j][i]){\n        rep(k, M) A[j][k] ^= A[next][k];\n      }\n    }\n    next++;\n    if(next == N + 1) break;\n  }\n  return next;\n}\n\nll N, M;\nvector<vector<ll>> A;\n\n\nvoid solve(){\n  COMinit();\n  cin >> N >> M;\n  A.resize(N);\n  rep(i, N) A[i].resize(M);\n  rep(i, N)rep(j, M) cin >> A[i][j];\n  ll r = Rank(N, M, A);\n  ll ans = 0;\n  rep(i, r+1){\n    ll add = comb(r, i) * pow_mod(2, r-i) % MOD;\n    for(ll j = 1; j <= i; j += 2){\n      ans += add * comb(i, j) % MOD;\n      ans %= MOD;\n    }\n  }\n  ans *= pow_mod(2, N + M - 2 * r);\n  ans %= MOD;\n  cout << ans << endl;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#undef NDEBUG\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing li = long long;\nusing ld = long double;\n\nvoid solve(bool);\n\nint main() {\n#ifdef YA\n    auto s = clock();\n    assert(freopen(\"input.txt\", \"r\", stdin));\n#else\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    cout << fixed << setprecision(20);\n\n    solve(true);\n\n#ifdef YA1\n    while (true) solve(false);\n#endif\n\n#ifdef YA\n    cout << endl << endl << \"time = \" << (clock() - s) / (double)CLOCKS_PER_SEC << endl;\n#endif\n\n    return 0;\n}\n\nconst int mod = 998244353;\n\nli pw(li x, li y) {\n    return y ? ((y & 1) ? pw(x, y - 1) * x % mod : pw(x * x % mod, y / 2)) : 1;\n}\n\nint gauss (vector < vector<int> > a) {\n    int n = (int) a.size();\n    int m = (int) a[0].size();\n    int rank = 0;\n\n    for (int col=0, row=0; col<m && row<n; ++col) {\n        int sel = row;\n        for (int i=row; i<n; ++i)\n            if (a[i][col]) {\n                sel = i;\n                break;\n            }\n        if (!a[sel][col])\n            continue;\n        ++rank;\n        for (int i=col; i < m; ++i)\n            swap (a[sel][i], a[row][i]);\n \n        for (int i=0; i<n; ++i)\n            if (i != row && a[i][col]) {\n                for (int j = col; j < m; ++j)\n                    a[i][j] ^= a[row][j];\n            }\n        ++row;\n    }\n    return rank;\n}\n\nvoid solve(bool __attribute__((unused)) read) {\n    int n, m;\n\tcin >> n >> m;\n    vector <vector <int>> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i].resize(m);\n        for (int j = 0; j < m; ++j) {\n            cin >> a[i][j];\n        }\n    }\n    int rank = gauss(a);\n    // cout << rank << endl;\n    // cout << pw(2, n) << endl;\n    // cout << pw(2, n - rank) << endl;\n    li ans = (pw(2, n) - pw(2, n - rank) + mod) % mod * pw(2, m - 1) % mod;\n    ans = (ans % mod + mod) % mod;\n    cout << ans << \"\\n\";\n}\n\n// IDI OBRATNO KOD SMOTRET, RANO POKA SUBMITIT\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 998244353;\nll N, M;\nll a[302][302];\nll beki(ll a, ll b) {\n    if(b == 0) return 1;\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1) {\n        ans = ans * a % mod;\n    }\n    return ans;\n}\n\nll Rank(ll index) {\n    if(index > min(N, M)) return 0;\n    int nonzero_i = -1;\n    int nonzero_j = -1;\n    for(int i = index; i <= N; i++) {\n        for(int j = index; j <= M; j++) {\n            if(a[i][j] == 1) {\n                nonzero_i = i;\n                nonzero_j = j;\n            }\n        }\n    }\n    if(nonzero_i == -1) return 0;\n    for(int i = index; i <= N; i++) {\n        swap(a[i][nonzero_j], a[i][index]);\n    }\n    for(int j = index; j <= M; j++) {\n        swap(a[nonzero_i][j], a[index][j]);\n    }\n    for(int i = index + 1; i <= N; i++) {\n        if(a[i][index] == 0) continue;\n        for(int j = index; j <= M; j++) {\n            a[i][j] = (a[i][j] + a[index][j]) % 2;\n        }\n    }\n    for(int j = index + 1; j <= M; j++) {\n        a[index][j] = 0;\n    }\n    return Rank(index + 1) + 1;\n}\n\nint main() {\n    //cout.precision(10);\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= M; j++) {\n            cin >> a[i][j];\n        }\n    }\n    ll R = Rank(1);\n    ll ans = (beki(2, R) - 1) * (beki(2, R - 1)) % mod;\n    ans = ans * (beki(2, N - R)) % mod;\n    ans = ans * (beki(2, M - R)) % mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mo 998244353\n#define N 310\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nll a[N][N],p[N][N];\nll m,n,sum;\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nint main(){\n\tread(n);read(m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)read(a[i][j]);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=m;j>=1;j--){\n\t\t\tif (p[j][j]==0){\n\t\t\t\tif (a[i][j]==1){\n\t\t\t\t\tfor (int k=1;k<=j;k++) p[j][k]=a[i][k];\n\t\t\t\t\tsum++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor (int k=1;k<=j;k++) a[i][k]^=p[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<((po(2,m)-po(2,m-sum)+mo)%mo)*po(2,n-1)%mo<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T> LLI power(T n, T p, T m){if(p==0) return 1LL; if(p==1) return n; LLI k = power(n, p/2, m); return ((k*k)%m*(p%2?n:1))%m;}\n\nconst LLI mod = 998244353;\nconst double eps = 1e-9;\n\ntemplate <typename T> int rank_matrix(vector<vector<T>> mat){\n\n  int n = mat.size();\n  int m = mat[0].size();\n  int p = 0;\n\n  REP(i,n){\n    if(p>=m) break;    \n\n    bool b = true;\n    FOR(j,i,n) if(abs(mat[j][p]) > eps) b = false;\n\n    if(b){\n      ++p;\n      continue;\n    }\n\n    if(abs(mat[i][p]) <= eps ){\n      FOR(j,i+1,n){\n\tif(abs(mat[j][p]) > eps){\n\t  swap(mat[i], mat[j]);\n\t  break;\n\t}\n      }\n    }\n    \n    FOR(j,i+1,n){\n      double t = (double)mat[j][p] / mat[i][p];\n      REP(k,m) mat[j][k] -= mat[i][k] * t;\n    }\n  }\n\n  int r = 0;\n  REP(i,n){\n    REP(j,m){\n      if(mat[i][j] != 0){\n\t++r;\n\tbreak;\n      }\n    }\n  }\n\n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  while(cin >> N >> M){\n    vector<vector<double>> a(N, vector<double>(M)); cin >> a;\n    int r = rank_matrix(a);\n    dump(r);\n    \n    LLI ans = (power(2LL,(LLI)(M-1),mod) * ((power(2LL,(LLI)N,mod) - power(2LL,(LLI)(N-r),mod) + mod*mod) % mod)) % mod;\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 3e2 + 6, MOD = 998244353;\nint n, m;\nint Arr[N][N];\n\nvoid swap_row (int l, int r) {\n\tfor (int i = 0; i < m; i++)\n\t\tswap(Arr[l][i], Arr[r][i]);\n}\n\nvoid xor_row (int l, int r) {\n\tfor (int i = 0; i < m; i++)\n\t\tArr[r][i] ^= Arr[l][i];\n}\n\nint _sub (int a, int b) {\n\tint c = a - b;\n\tif (c < 0)\n\t\tc += MOD;\n\treturn c;\n}\n\nint _mul (int a, int b) {\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\n\nint _pow (int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1)\n\t\t\tres = _mul(res, a);\n\t\ta = _mul(a, a);\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tcin >> Arr[i][j];\n\n\tint pointer = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint ind = -1;\n\t\tfor (int j = pointer; j < n; j++)\n\t\t\tif (Arr[j][i])\n\t\t\t\tind = j;\n\n\t\tif (ind == -1)\n\t\t\tcontinue;\n\n\t\tswap_row(pointer, ind);\n\t\tfor (int j = pointer + 1; j < n; j++)\n\t\t\tif (Arr[j][i])\n\t\t\t\txor_row(pointer, j);\n\t\tpointer++;\n\t}\n\n\tint num = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (Arr[i][j]) {\n\t\t\t\tnum++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\tif (!num) {\n\t\tcout << \"0\\n\";\n\t\treturn 0;\n\t}\n\n\tint res = _mul(_sub(_pow(2, num), 1), _pow(2, n - num));\n\tcout << _mul(res, _pow(2, m - 1)) << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nint main()\n{\n\tint n, m; cin>>n>>m;\n\tint a[301][301];\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<m; j++) cin>>a[i][j];\n\t}\n\tint r=0;\n\tfor(int i=0; i<n; i++){\n\t\tint j1=-1;\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif(a[i][j]){\n\t\t\t\tj1=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j1==-1) continue;\n\t\tr++;\n\t\tfor(int k=i+1; k<n; k++){\n\t\t\tif(a[k][j1]){\n\t\t\t\tfor(int j=j1; j<m; j++){\n\t\t\t\t\ta[k][j]^=a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll p2[301];\n\tp2[0]=1;\n\tfor(int i=1; i<=max(n, m); i++) p2[i]=p2[i-1]*2%MOD;\n\tll ans=(p2[n]-p2[n-r]+MOD)*p2[m-1]%MOD;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define mod 998244353\nusing namespace std;\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') {\n        if (c == '-') f = -1;\n        c = getchar();\n    }\n    while (c >= '0' && c <= '9') {\n        x = x * 10 + c - '0';\n        c = getchar();\n    }\n    return x * f;\n}\n\nint base[302][302];\nint a[302];\nint sum, n, m;\n\nlong long fsp(int p) {\n    long long rt = 1, base = 2;\n    while (p) {\n        if (p & 1) (rt *= base) %= mod;\n        (base *= base) %= mod;\n        p >>= 1;\n    }\n    return rt;\n}\n\nvoid work() {\n    for (int i = m; i >= 1; --i) {\n        if (!a[i]) continue;\n        if (!base[i][i]) {\n            sum--;\n            for (int j = 1; j <= i; ++j) {\n                base[i][j] = a[j];\n            }\n            for (int j = 1; j < i; ++j) {\n                if (!base[i][j]) continue;\n                for (int k = 1; k <= j; ++k) {\n                    base[i][k] ^= base[j][k];\n                }\n            }\n            for (int j = i + 1; j <= m; ++j) {\n                if (!base[j][i]) continue;\n                for (int k = 1; k <= i; ++k) {\n                    base[j][k] ^= base[i][k];\n                }\n            }\n        } else {\n            for (int j = 1; j <= i; ++j) {\n                a[j] ^= base[i][j];\n            }\n        }\n    }\n    return ;\n}\n\nint main() {\n    n = sum = read(), m = read();\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            a[j] = read();\n        }\n        work();\n    }\n    printf(\"%lld\", fsp(m - 1) * (fsp(n) + mod - fsp(sum)) % mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\n// mod2 行列ライブラリ (bitset を使って高速化、横は SIZE 固定とする)\n// TODO: 乗算の verify\nstruct BinaryMatrix {\n    int H, W;\n    static const int SIZE = 2010;\n    vector< bitset<SIZE> > mat;\n    BinaryMatrix(int H_, int W_) : H(H_), W(W_), mat(H_) {}\n\n    // 乗算に使用 (これ微妙に転置じゃないけどなんていうんだ)\n    BinaryMatrix T(const BinaryMatrix& A) {\n        int h = A.H, w = A.W;\n        BinaryMatrix res(w, h);\n        for(int i=0; i<h; i++) {\n            for(int j=0; j<w; j++) {\n                res[j][i] = A[i][j];\n            }\n        }\n        return res;\n    }\n\n    BinaryMatrix& operator*=(const BinaryMatrix& rhs) {\n        assert(W == rhs.H);\n        BinaryMatrix res(H, rhs.W), trhs = T(rhs);\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<rhs.W; j++) {\n                res[i][j] = (mat[i] & trhs[j]).count() % 2;\n            }\n        }\n        return (*this = res);\n    }\n    BinaryMatrix& operator+=(const BinaryMatrix &rhs) {\n        assert(H == rhs.H and W == rhs.W);\n        for(int i=0; i<H; i++) mat[i] ^= rhs[i];\n        return *this;\n    }\n    BinaryMatrix& operator-=(const BinaryMatrix &rhs) {\n        return (*this += rhs);\n    }\n\n    BinaryMatrix operator*(const BinaryMatrix &rhs) {\n        return (BinaryMatrix(*this) *= rhs);\n    }\n    BinaryMatrix operator+(const BinaryMatrix &rhs) {\n        return (BinaryMatrix(*this) += rhs);\n    }\n    BinaryMatrix operator-(const BinaryMatrix &rhs) {\n        return (BinaryMatrix(*this) -= rhs);\n    }\n\n    bool operator==(const BinaryMatrix &rhs) const {\n        if(H != rhs.H or W != rhs.W) return false;\n        for(int i=0; i<H; i++) if(mat[i] != rhs[i]) return false;\n        return true;\n    }\n    bool operator!=(const BinaryMatrix &rhs) const {\n        return !(*this == rhs);\n    }\n\n    const bitset<SIZE>& operator[](int k) const { return mat[k]; }\n    bitset<SIZE>& operator[](int k) { return mat[k]; }\n};\n\nBinaryMatrix eigen(size_t N) {\n    BinaryMatrix res(N, N);\n    for(size_t i=0; i<N; i++) res[i][i] = 1;\n    return res;\n}\n\nBinaryMatrix pow(BinaryMatrix mat, long long int k) {\n    BinaryMatrix res = eigen(mat.H);\n    for(; k>0; k>>=1) {\n        if(k & 1) res *= mat;\n        mat *= mat;\n    }\n    return res;\n}\n\nint gaussianEliminationBinary(BinaryMatrix &mat, bool ext=false) {\n    int N = mat.H, M = mat.W, rank = 0;\n    for(int j=0; j+ext<M; j++) {\n        int piv = -1;\n        for(int i=rank; i<N; i++) {\n            if(mat[i][j] != 0) piv = i, i = N;\n        }\n        if(piv < 0) continue;\n        swap(mat[rank], mat[piv]);\n        for(int i=0; i<N; i++) {\n            if(i == rank or mat[i][j] == 0) continue;\n            mat[i] ^= mat[rank];\n        }\n        rank++;\n    }\n    return rank;\n}\n\nvector<int> linearEquationBinary(BinaryMatrix A, vector<int> b) {\n    int N = A.H, M = A.W;\n    BinaryMatrix mat(N, M+1);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            mat[i][j] = (j < M ? A[i][j] : b[i]);\n        }\n    }\n\n    int rank = gaussianEliminationBinary(mat, true);\n    vector<int> res(N);\n    for(int i=0; i<N; i++) {\n        res[i] = mat[i][M];\n        if(i >= rank and mat[i][M] != 0) return {};\n    }\n    return res;\n}\n\nint detBinary(BinaryMatrix A) {\n    int N = A.H;\n    for(int j=0; j<N; j++) {\n        int piv = -1;\n        for(int i=j; i<N; i++) {\n            if(A[i][j] != 0) piv = i, i = N;\n        }\n        if(piv < 0) return 0;\n        swap(A[piv], A[j]);\n        for(int i=j+1; i<N; i++) {\n            if(A[i][j]) A[i] ^= A[j];\n        }\n    }\n    int res = 1;\n    for(int i=0; i<N; i++) res *= A[i][i];\n    return res;\n}\n\nusing ll = long long int;\nconst ll MOD = 998244353;\nll mod_pow(ll n, ll k) {\n    ll res = 1;\n    for(; k>0; k>>=1) {\n        if(k & 1) (res *= n) %= MOD;\n        (n *= n) %= MOD;\n    }\n    return res;\n}\n\nint main() {\n    int N, M; cin >> N >> M;\n    BinaryMatrix mat(N, M);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            int val; cin >> val;\n            mat[i][j] = val;\n        }\n    }\n\n    int rank = gaussianEliminationBinary(mat);\n    int v1 = mod_pow(2, N + M - 1);\n    int v2 = mod_pow(2, N + M - rank - 1);\n    cout << (v1 - v2 + MOD) % MOD << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nauto no = [](){cout << \"NO\"; exit(0);};\nauto read = [](){int x; cin >> x; return x;};\n#define maxn 300\nconst LL mod = 998244353;\nint A[maxn][maxn];\nLL power(LL a, LL m){\n\tLL res = 1;\n\tfor(int i = 0; i < m; i += 1) res = res * a % mod;\n\treturn res;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tint N, M;\n\tcin >> N >> M;\n\tfor(int i = 0; i < N; i += 1)\n\t\tfor(int j = 0; j < M; j += 1) cin >> A[i][j];\n\tint X = min(N, M);\n\tfor(int i = 0; i < X; i += 1){\n\t\tint t = i;\n\t\tfor(int j = i; j < N; j += 1) if(A[j][i]) t = j;\n\t\tfor(int j = 0; j < M; j += 1) swap(A[i][j], A[t][j]);\n\t\tif(A[i][i] == 0) continue;\n\t\telse for(int j = i + 1; j < N; j += 1) if(A[j][i]){\n\t\t\tfor(int k = i; k < M; k += 1) A[j][k] ^= A[i][k];\n\t\t}\n\t}\n\tint O = 0;\n\tfor(int i = 0; i < N; i += 1){\n\t\tint ok = 1;\n\t\tfor(int j = 0; j < M; j += 1) if(A[i][j]) ok = 0;\n\t\tO += ok;\n\t}\n\t//cout << N << O << M;\n\tcout << (power(2, N) - power(2, O) + mod) * power(2, M - 1) % mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <complex>\n#include <numeric>\n#include <string.h>\n#include <random>\n#define rep(i,n) for (int i = 0; i < (int)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\ndouble PI = 3.141592653589793238462643383279;\nconst double EPS = 1e-9;\nconst ll MOD = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\n\nint calc_rank(vector<vector<int>> v) {\n    int n = v.size(), m = v[0].size();\n    int st = 0;\n    rep(j,m) {\n        int pv = -1;\n        for (int i = st; i < n; i++) {\n            if (v[i][j]) {\n                pv = i;\n                break;\n            }\n        }\n        if (pv == -1) continue;\n        if (pv != st) {\n            swap(v[st], v[pv]);\n        }\n        for (int i = st+1; i < n; i++) {\n            if (!v[i][j]) continue;\n            for (int k = j; k < m; k++) {\n                v[i][k] ^= v[st][k];\n            }\n        }\n        st++;\n    }\n    return st;\n}\n\nint n, m;\n\nint main() {\n    cin >> n >> m;\n    vector<vector<int>> a(n, vector<int>(m, 0));\n    rep(i,n) rep(j,m) cin >> a[i][j];\n    int r = calc_rank(a);\n    ll ans = 1;\n    rep(i,n+m-1) ans = ans * 2 % MOD;\n    ll tmp = 1;\n    rep(i,n+m-r-1) tmp = tmp * 2 % MOD;\n    cout << (ans-tmp+MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n\n#define cMOD 998244353ULL\n#define cINF ((1ull<<62)-1)\n#define cINFINT ((1<<30)-1)\n\n\ntemplate <typename T>\nvoid calcFactional_mod( size_t size, \n\tvector<T>& fac, vector<T>& inv, vector<T>& facInv, T mod )\n{\n\tfor( T i = 2; i < size; ++i )\n\t{\n\t\tfac[i] = fac[i - 1] * i % mod; // n! % mod\n\t\tinv[i] = mod - inv[mod % i] * ( mod / i ) % mod; // 逆元計算 (n)^-1 % mod\n\t\tfacInv[i] = facInv[i - 1] * inv[i] % mod; // (n!)^-1 % mod\n\t}\n}\ntemplate <typename T>\nT pow_mod(T x, T n, T mod)\n{\n\tT res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (res * x) % mod;\n\t\tx = (x * x) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\ntemplate< typename T >\nclass Matrix\n{\npublic:\n\texplicit Matrix( size_t row_size, size_t col_size )\n\t{\n\t\tassign( row_size, col_size );\n\t}\n\n\tvoid assign( size_t row_size, size_t col_size )\n\t{\n\t\tmElement.assign( row_size, vector<T>() );\n\t\tREP( i, row_size ) mElement[i].assign( col_size, T(0) );\n\t}\n\n\tconst vector<T>& operator[] ( size_t row ) const\n\t{ return mElement[row]; }\n\tvector<T>& operator[] ( size_t row )\n\t{ return mElement[row]; }\n\n\tconst size_t rowSize() const\n\t{ return mElement.size(); }\n\tconst size_t colSize() const\n\t{ return mElement[0].size(); }\n\n\t/*T get( size_t row, size_t col ) const\n\t{ return mElement[row][col]; }\n\tvoid set( size_t row, size_t col, T value )\n\t{ mElement[row][col] = value; }*/\n\n\tMatrix<T> operator* ( const Matrix& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.rowSize() );\n\t\tMatrix ret( this->rowSize(), rhs.colSize() );\n\t\tREP( i, ret.rowSize() )\n\t\tREP( k, k_ )\n\t\tREP( j, ret.colSize() )\n\t\t\tret[i][j] = ret[i][j] + (*this)[i][k] * rhs[k][j];\n\t\treturn ret;\n\t}\n\n\tvector<T> operator* ( const vector<T>& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.size() );\n\t\tvector<T> ret( this->rowSize(), T() );\n\t\tREP( i, ret.size() )\n\t\tREP( k, k_ )\n\t\t\tret[i] = ret[i] + (*this)[i][k] * rhs[k];\n\t\treturn ret;\n\t}\n\n\t// O( N^3 )\n\t// Ax = b を解く\n\t// T = double にしないと割り算で狂うので注意\n\tstruct GaussJordanData\n\t{\n\t\tint rank = 0;\n\t\tint result = 0; // -1:解なし 0:不定 1:解あり\n\t\tvector<T> solution;\n\t};\n\tGaussJordanData gaussJordan() const\n\t{\n\t\tvector<T> b( rowSize(), 0 );\n\t\treturn gaussJordan( b );\n\t}\n\tGaussJordanData gaussJordan( const vector<T>& b ) const\n\t{\n\t\tGaussJordanData data;\n\t\tdata.result = 1;\n\n\t\t// 1列余分に取って、そこにbを入れる\n\t\tMatrix<T> B( rowSize(), colSize() + 1 );\n\t\tREP( i, rowSize() ) REP( j, colSize() + 1 )\n\t\t{\n\t\t\tif( j < colSize() ) B[i][j] = (*this)[i][j];\n\t\t\telse B[i][j] = b[i];\n\t\t}\n\n\t\tfor( int i = 0, j = 0; i < rowSize() && j < colSize(); ++i, ++j )\n\t\t{\n\t\t\t// j列目の値の絶対値が大きい行をi行目に持ってくる\n\t\t\tsize_t pivot = i;\n\t\t\tfor( int k = i + 1; k < rowSize(); ++k )\n\t\t\t\tif( abs( B[k][j] )> abs( B[pivot][j] ) ) pivot = k;\n\t\t\tswap( B[i], B[pivot] );\n\t\t\t// 解が一意でない\n\t\t\tif( abs( B[i][j] ) <= numeric_limits<T>::epsilon() )\n\t\t\t{\n\t\t\t\t--i;\n\t\t\t\tdata.result = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Rankを1増やす\n\t\t\t++data.rank;\n\t\t\t// [i][j]を1にするようにi行目を割る\n\t\t\tfor( int l = j + 1; l <= colSize(); ++l )\n\t\t\t\tB[i][l] /= B[i][j];\n\t\t\tB[i][j] = 1;\n\t\t\t// k番目の行からi番目の行を引いて、j番目の列の数を消去\n\t\t\tREP( k, rowSize() ) if( k != i )\n\t\t\t{\n\t\t\t\tT coef = B[k][j];\n\t\t\t\tfor( int l = j; l <= colSize(); ++l )\n\t\t\t\t\tif( coef ^ B[i][l] == 1 )\n\t\t\t\t\t\tB[k][l] ^= 1;\n\t\t\t}\n\t\t}\n\n\t\t// 解xを作る\n\t\tdata.solution.assign( colSize(), T() );\n\t\tfor( int i = 0, j = 0; j < colSize(); ++i, ++j )\n\t\t{\n\t\t\tif( i >= rowSize() || B[i][j] == 0 )\n\t\t\t{\n\t\t\t\tdata.solution[j] = 0;\n\t\t\t\t--i; continue;\n\t\t\t}\n\t\t\telse data.solution[j] = *( B[i].rbegin() );\n\t\t}\n\n\t\t// 解なしかをチェック\n\t\tif( data.result == 0 || ( data.rank ) < b.size() )\n\t\t{\n\t\t\tauto m = ( *this ) * data.solution;\n\t\t\tREP( i, m.size() ) if( m[i] != b[i] )\n\t\t\t{ data.result = -1; break; }\n\t\t}\n\t\tif( data.result != -1 )\n\t\t{\n\t\t\t// 解が一意\n\t\t\tif( data.rank == colSize() ) data.result = 1;\n\t\t\t// 解が不定\n\t\t\telse data.result = 0;\n\t\t}\n\t\t\n\t\treturn data;\n\t}\n\nprotected:\n\tvector<vector<T>> mElement;\n};\n\n\nint main()\n{\n\tauto mod = cMOD;\n\tauto add = [mod]      ( ll a, ll b ) { return ( a + b ) % mod; };\n\tauto sub = [mod]      ( ll a, ll b ) { return ( a + mod -b ) % mod; };\n\tauto mul = [mod]      ( ll a, ll b ) { return a * b % mod; };\n\tauto pow = [mod]      ( ll a, ll b ) { return pow_mod<ll>( a, b, mod ); };\n\t\n\tll n, m; cin >> n >> m;\n\tMatrix<int> mtx( n, m );\n\tREP( i, n ) REP( j, m ) cin >> mtx[i][j];\n\t\n\tauto data = mtx.gaussJordan();\n\tauto ans = sub( pow( 2, n + m - 1 ), pow( 2, n + m - data.rank - 1 ) );\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int MOD=998244353;\nconst int N=305;\nint n,m;\nbitset<N> s[N];\nbitset<N> f[N];\nint cnt=0;\nvoid Ins ()\n{\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tbool tf=true;\n\t\tfor (int i=1;i<=m;i++)\n\t\tif (s[u][i])\n\t\t{\n\t\t\tif (!f[i][i]) \t{f[i]=s[u];tf=false;break;}\n\t\t\ts[u]^=f[i];\n\t\t}\n\t\tcnt=cnt+tf;\n\t}\n}\nint Pow[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tPow[0]=1;for (int u=1;u<=n;u++) Pow[u]=Pow[u-1]*2%MOD;\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\ts[u][i]=x;\n\t\t}\n\t}\n\tIns();\n\tint ans=0;\n\tint t=1;\tfor (int u=1;u<m;u++) t=t*2%MOD;\n\tint lalal=(Pow[n]-Pow[cnt]+MOD)%MOD;\n\t//printf(\"%d %d\\n\",lalal,Pow[cnt]);\n\tans=(LL)lalal*t%MOD;\n\tprintf(\"%d\\n\",ans%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cout<<v[i][j]<<\" \";}cout<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nvii rotate(vii a) {\n  int h = a.size(), w = a[0].size();\n  vii b(w, vi(h));\n  rep (i, h) {\n    rep (j, w) {\n      b[j][i] = a[i][j];\n    }\n  }\n  return b;\n}\n\n\nconst int MAXN = 3010;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n\tfact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n\tfor (ll i = 2; i <= n; i++) {\n\t\tfact[i] = i * fact[i - 1] % M;\n\t\trfact[i] = mod_inverse(fact[i], M);\n\t}\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  ll ret = fact[n];\n  ret = (ret*rfact[r]) % M;\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\n\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n  vii a(h, vi(w));\n  rep (i, h) {\n    rep (j, w) {\n      cin >> a[i][j];\n    }\n  }\n  if (h < w) {\n    swap(h, w);\n    a = rotate(a);\n  }\n  set_fact(h + 100);\n  int no = 0;\n  rep (j, w) {\n    if (a[j][j] == 0) {\n      for (int i = j + 1; i < h; i++) {\n        if (a[i][j] == 1) {\n          swap(a[i], a[j]);\n          break;\n        }\n      }\n    }\n    if (a[j][j] == 0) {\n      no++;\n      continue;\n    }\n    for (int i = 0; i < h; i++) {\n      if (i == j) continue;\n      if (a[i][j] == 1) {\n        rep (k, w) {\n          a[i][k] = (a[i][k] + a[j][k]) % 2;\n        }\n      }\n    }\n  }\n  ll ans = 0;\n  for (int x = 1; x <= w - no; x += 2) {\n    for (int y = 0; y <= w - no - x; y++) {\n      ans += mod_pow(2, h - w) * nCr(w - no, x) % MOD * mod_pow(2, 2 * no) % MOD * nCr(w - no - x, y) % MOD * mod_pow(2, w - no - x - y) % MOD;\n      ans %= MOD;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const {\n        long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u);\n    }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r;\n}\ntypedef ModInt<2> mint1;\ntypedef ModInt<998244353> mint2;\nint gauss(vector<vector<int>> A) {\n    int n = A.size(), m = A[0].size();\n    int r = 0;\n    for (int i = 0; r < n && i < m; ++i) {\n        int piv = r;\n        for (int j = r + 1; j < n; ++j)\n            if (abs(A[j][i]) > abs(A[piv][i])) piv = j;\n        A[r].swap(A[piv]);\n        if (abs(A[r][i]) == 0) continue;\n        for (int k = m - 1; k >= i; --k)\n            A[r][k] /= A[r][i];\n        for (int j = r + 1; j < n; ++j)\n            for (int k = m - 1; k >= i; --k)\n                A[j][k] ^= A[r][k] * A[j][i];\n        ++r;\n    }\n    return r;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nint N, M;\nint v[606];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n\n    vector<vector<int>> v(N, vector<int>(M));\n\n    rep(i, 0, N) rep(j, 0, M) {\n        int a; cin >> a;\n        v[i][j] = a;\n    }\n\n    int R = gauss(v);\n\n    mint2 ans = ((mint2(2) ^ N) - (mint2(2) ^ (N-R))) * (mint2(2) ^ (M - 1));\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\nint mat[301][301],cntj[2][302][302],cnti[2][302][302];\n\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    For(i,N)For(j,M){\n        mat[i+1][j+1]=(mat[i+1][j]+a[i][j])%2;\n    }\n    For(j,M)For(i,N){\n        mat[i+1][j+1]+=mat[i][j+1];\n        mat[i+1][j+1]%=2;\n    }\n    For(i,N)For(j,M){\n        int is_even=mat[i+1][j]%2==0?1:0;\n        cntj[0][i+1][j+1]=cntj[0][i+1][j]+is_even;\n        cntj[1][i+1][j+1]=cntj[1][i+1][j]+1-is_even;\n    }\n    For(j,M)For(i,N){\n        int is_even=mat[i][j+1]%2==0?1:0;\n        cnti[0][i+1][j+1]=cnti[0][i][j+1]+is_even;\n        cnti[1][i+1][j+1]=cnti[1][i][j+1]+1-is_even;\n    }\n    ll ans=0;\n    For(i,N)For(j,M){\n        if(mat[i+1][j+1]%2==0){\n            ans+=cnti[0][i+1][j+1]*cntj[1][i+1][j+1];\n            ans+=cnti[1][i+1][j+1]*cntj[0][i+1][j+1];\n        }else{\n            ans+=cnti[0][i+1][j+1]*cntj[0][i+1][j+1];\n            ans+=cnti[1][i+1][j+1]*cntj[1][i+1][j+1];\n        }\n    }\n    cout<<ans<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) {rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;}\n#define show2d(v) {rep(__,v.size())show1d(v[__]);}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\n#define yes cout<<\"Yes\\n\"\n#define no cout<<\"No\\n\"\n\n//ガウスの消去法\n#define BIT_N 333\ntypedef bitset<BIT_N> Bit;\n\tvector<Bit> gauss(vector<Bit> &v, ll &ran){\n\tran = 0;\n\trep(i,BIT_N) {\n\t\tint pla = -1;\n\t\tfor(int j = ran;j < v.size();j++){\n\t\t\tif(v[j][i] == 1){\n\t\t\t\tpla = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(pla != -1){\n\t\t\tswap(v[ran], v[pla]);\n\t\t\tfor(int j = 0;j < v.size();j++){\n\t\t\t\tif(j != ran && v[j][i] == 1)v[j] ^= v[ran];\n\t\t\t}\n\t\t\tran++;\n\t\t}\n\t}\n\treturn v;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n,m;\n\tcin>>n>>m;\n\tvector<Bit>in(n);\n\trep(i,n)rep(j,m){\n\t\tint a;cin>>a;\n\t\tif(a)in[i][j]=1;\n\t}\n\tint rank;\n\tvector<Bit>out=gauss(in,rank);\n\tint MOD=998244353;\n\tvi po(633,1);\n\tloop(i,1,633)po[i]=po[i-1]*2%MOD;\n\tcout<<(MOD+po[n+m-1]-po[n+m-rank-1])%MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n\n*/\n#include <cstdio>\n#include <cctype>\n#include <bitset>\n#include <algorithm>\n#define gc() getchar()\n#define mod 998244353\ntypedef long long LL;\nconst int N=305;\n\nstd::bitset<N> A[N],B[N];\n\ninline int read()\n{\n\tint now=0;register char c=gc();\n\tfor(;!isdigit(c);c=gc());\n\tfor(;isdigit(c);now=now*10+c-48,c=gc());\n\treturn now;\n}\ninline int FP(int x,int k)\n{\n\tint t=1;\n\tfor(; k; k>>=1,x=1ll*x*x%mod)\n\t\tif(k&1) t=1ll*t*x%mod;\n\treturn t;\n}\n\nint main()\n{\n\tint n=read(),m=read();\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=m; ++j) A[i][j]=read()==1;\n\tint r=0;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=m; ++j)\n\t\t\tif(A[i][j])//x>>j&1\n\t\t\t{\n\t\t\t\tif(B[j][j]) A[i]^=B[j];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tB[j]=A[i];\n\t\t\t\t\t++r; break;\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%d\\n\",(FP(2,n+m-1)+mod-FP(2,n-r+m-1))%mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst int mod = 998244353;\n\nint modpow(int x, int y, int m) {\n  int ret = 1 % m, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (lint)ret * x2p % m;\n    y /= 2;\n    x2p = (lint)x2p * x2p % m;\n  }\n  return ret;\n}\n\nint inv(int a, int p) { return modpow(a, p - 2, p); }\n\nvector<int> fact, inv_fact;\n\nvoid prepare_binom(int lim) {\n  fact.resize(lim + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= lim; ++i)\n    fact[i] = (lint)i * fact[i - 1] % mod;\n\n  inv_fact.resize(lim + 1);\n  inv_fact[lim] = inv(fact[lim], mod);\n  for (int i = lim - 1; i >= 0; --i)\n    inv_fact[i] = (lint)(i + 1) * inv_fact[i + 1] % mod;\n}\n\nint binom(int a, int b) {\n  if (!(0 <= b && b <= a)) return 0;\n  return (lint)fact[a] * inv_fact[b] % mod * inv_fact[a - b] % mod;\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n\n  prepare_binom(min(n, m));\n\n  vector<vector<int>> mat(n, vector<int>(m));\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      scanf(\"%d\", &mat[i][j]);\n      mat[i][j] %= 2;\n    }\n\n  int rank = 0;\n  for (int x = 0; x < m; ++x) {\n    int selected = -1;\n    for (int y = rank; y < n; ++y)\n      if (mat[y][x])\n        selected = y;\n    if (selected == -1) continue;\n    swap(mat[selected], mat[rank]);\n    for (int y = rank + 1; y < n; ++y) {\n      if (!mat[y][x]) continue;\n      for (int x2 = x; x2 < m; ++x2)\n        mat[y][x2] ^= mat[rank][x2];\n    }\n    ++rank;\n  }\n\n  int result = 0;\n  for (int i = 1; i <= rank; i += 2)\n    result = (result + (lint)binom(rank, i) * modpow(3, rank - i, mod) % mod * modpow(2, n + m - 2 * rank, mod)) % mod;\n  printf(\"%d\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n        mat<COL_SIZE> b(r);\n        for(int i = 0; i < r; i++) b[i] = a[i];\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n        return a[index];\n    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<305>a(m+5);\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = a.rank();\n    cerr << r << endl;\n    cout << (mod_pow(2,n+m-1) - mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// binary 行列 (行列累乗と、掃き出し法)\n//\n// verified:\n//   みんなのプロコン 2019 E - Odd Subrectangles\n//     https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n// \n\n\n#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n\nconst int MAX_ROW = 510; // to be set\nconst int MAX_COL = 510; // to be set\nstruct BitMatrix {\n    int n, m;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int n_ = 1, int m_ = 1) {n = n_; m = m_;}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n    inline friend ostream& operator << (ostream& s, BitMatrix M) {\n        s << endl; \n        for (int i = 0; i < M.n; ++i) {\n            for (int j = 0; j < M.m; ++j) s << M.val[i][j];\n            s << endl;\n        }\n        return s;\n    }\n};\n\ninline BitMatrix operator * (BitMatrix A, BitMatrix B) {\n    BitMatrix R(A.n, B.m);\n    BitMatrix tB(B.m, B.n);\n    for (int i = 0; i < tB.n; ++i) for (int j = 0; j < tB.m; ++j) tB[i][j] = B[j][i];\n    for (int i = 0; i < R.n; ++i) for (int j = 0; j < R.m; ++j) R[i][j] = (A[i] & tB[j]).any();\n    return R;\n}\n\ninline BitMatrix pow(BitMatrix A, long long n) {\n    BitMatrix R(A.n, A.n);\n    for (int i = 0; i < A.n; ++i) R[i][i] = 1;\n    while (n > 0) {\n        if (n & 1) R = R * A;\n        A = A * A;\n        n >>= 1;\n    }\n    return R;\n}\n\nint calc_rank(BitMatrix &A) {\n    int r = 0;\n\tfor (int i = 0; i < A.m; ++i) {\n\t\tint pivot = -1;\n\t\tfor (int j = r; j < A.n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot != -1) {\n\t\t\tswap(A[pivot], A[r]);\n\t\t\tfor (int j = 0; j < A.n; ++j) if (j != r && A[j][i]) A[j] ^= A[r];\n\t\t\t++r;\n\t\t}\n\t}\n    return r;\n}\n\nvector<vector<int> > linear_equation(BitMatrix A, vector<int> b) {\n\tint rank = 0;\n    for (int i = 0; i < A.n; ++i) { A[i][A.m] = b[i]; }\n    \n    vector<int> core, rem;\n\tfor (int i = 0; i < A.m; ++i) {\n\t\tint pivot = -1;\n\t\tfor (int j = rank; j < A.n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot != -1) {\n            core.push_back(i);\n\t\t\tswap(A[pivot], A[rank]);\n\t\t\tfor (int j = 0; j < A.n; ++j) if (j != rank && A[j][i]) A[j] ^= A[rank];\n\t\t\t++rank;\n\t\t}\n        else rem.push_back(i);\n\t}\n    \n    vector<vector<int> > res;\n    for (int i = rank; i < A.n; ++i) \n        if (A[i][A.m]) return res;     // return -1;\n    \n    vector<int> sol(A.m, 0);\n    for (int i = 0; i < core.size(); ++i) sol[core[i]] = A[i][A.m];\n    res.push_back(sol);\n    \n    for (int i = 0; i < rem.size(); ++i) {\n        vector<int> temp(A.m, 0);\n        temp[rem[i]] = 1;\n        for (int j = 0; j < core.size(); ++j) temp[core[j]] = A[j][rem[i]];\n        res.push_back(temp);\n    }\n    \n    return res;     // return A[0].size()-rank;\n};\n\n\nconst int MOD = 998244353;\nconst int MAX = 2100;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAX; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nlong long COM(int n, int k){\n    if(n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD;\n}\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    COMinit();  \n    int N, M; cin >> N >> M;\n    BitMatrix A(N, M);\n    for (int i = 0; i < N; ++i) for (int j = 0; j < M; ++j) {\n            int a; cin >> a;\n            if (a) A[i][j] = 1;\n        }\n    int r = calc_rank(A);\n    long long fact = modpow(2LL, N-r, MOD) * modpow(2LL, M-r, MOD) % MOD;\n    long long res = 0;\n    for (int i = 1; i <= r; ++i) {\n        long long tmp = COM(r, i) * modpow(2LL, i-1, MOD) % MOD * modpow(2LL, r-i, MOD) % MOD;\n        res = (res + tmp) % MOD;\n    }\n    res = (res * fact) % MOD;\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = (ll)998244353;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n//functions\n   ll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n   ll pow(ll a, ll b){if (b == 0) return 1; else if (b % 2 == 0) return pow(a * a, b / 2); else return pow(a * a, b / 2) * a;}\n   ll pow(ll a, ll b, ll m){if (b == 0) return 1; else if (a == 0) return 0; else if (b % 2 == 0) return (pow((a * a) % m, b / 2, m) % m); else return (pow((a * a) % m, b / 2, m) * a) % m;}\n   ll residue(ll a, ll m){return ((a % m) + m) % m;};\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\n\n//与えられたF2上の行列をAとして、(1 << (M * N - rank(A) - 1)) * ((1 << rank(A)) - 1 )が答え.\nconst ll MAX_M = 300, MAX_N = 300;\nll N, M;\nll a[MAX_N][MAX_M];\n\nll rnk(){\n   ll r = 0;\n   ll i = 0, j = 0;\n   while(i < N && j < M){\n      //a[i][j] = 0のときは、k = i + 1, ..., N - 1 からa[k][j] != 0なるkを探してきて, i行目とk行目を入れ替える\n      if(!a[i][j]){\n         FOR(k, i + 1, N){\n            if(a[k][j]){\n               REP(l, M){\n                  swap(a[i][l], a[k][l]);\n               }\n               break;\n            }\n         }\n      }\n      //入れ替えを行ってもa[i][j] = 0のとき（つまりj列目はすべて0のとき)はj列目をスキップ j+1列目にトライ\n      if(!a[i][j]){j++; continue;}\n      r++;\n      //k = i+1,...,N-1行目についてi行目を引く\n      FOR(k, i + 1, N){\n         ll c = a[k][j];\n         REP(l, M){\n            a[k][l] += c * a[i][l];\n            a[k][l] %= 2;\n         }\n      }\n      i++; j++;\n   }\n   return r;\n}\n\nint main(){\n   cin >> N >> M;\n   REP(i, N) REP(j, M) cin >> a[i][j];\n   ll r = rnk();\n/*\n   cout << endl;\n   REP(i, N){\n      REP(j, M){\n         if(j) {cout << \" \";}\n         cout << a[i][j];\n      }\n      cout << endl;\n   }\n   cout << \"rnk = \" << r << endl;\n*/\n   cout << residue(pow(2ll, N + M - 1, MOD) - pow(2ll, N + M - 1 - r, MOD), MOD) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n\nstruct fast_io {\n    static constexpr int size_in = 1 << 26, size_out = 1 << 26;\n    char data_in[size_in], data_out[size_out], *p_in, *p_out, s[30];\n    fast_io() { fread(data_in, 1, size_in, stdin), p_in = data_in, p_out = data_out; }\n    ~fast_io() { fwrite(data_out, 1, p_out - data_out, stdout); }\n    void putchar(char x) { *p_out++ = x; }\n    template<typename T> void putint(T x) {\n        if (x < 0) { *p_out++ = '-', x = -x; }\n        int i = 0;\n        do { s[i++] = x % 10 + '0'; } while (x /= 10);\n        while (i--) { *p_out++ = s[i]; }\n    }\n    template<typename T=int> T getint() {\n        while (!isdigit(*p_in) && *p_in != '-') { p_in++; }\n        T ret = *p_in - '0';\n        while (isdigit(*++p_in)) { (ret *= 10) += *p_in - '0'; };\n        return ret;\n    }\n} io;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nint main() {\n    int N = io.getint(), M = io.getint();\n    using bset = bitset<300>;\n    vector<bset> src(N);\n    rep(i, N) {\n        rep(j, M) { src[i][j] = io.getint(); }\n    }\n    int rank = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = N - 1; j > i; j--) {\n            int x = src[j]._Find_first(), y = src[j - 1]._Find_first();\n            if (x < y) { src[j - 1] ^= src[j]; }\n            if (x <= y) { src[j] ^= src[j - 1]; }\n        }\n        if (src[i].none()) { break; }\n        rank++;\n    }\n    using mint = mod_int<998244353>;\n    io.putint((mint(2).pow(N + M - 1) - mint(2).pow(N + M - rank - 1)).val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll N = 303, M = 998244353;\nll qpow(ll a,ll b)\n{\n    ll r = 1;\n    for (;b;b>>=1,a=a*a%M)\n        if (b & 1)\n            r = r * a % M;\n    return r;\n}\nbitset<N> a[N];\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    ll n,m;\n    cin >> n >> m;\n    for (ll i = 0; i < n; ++i)\n        for (ll j = 0; j < m; ++j) {\n            ll x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    ll r = 0;\n    for (ll i = 0; i < n; ++i) {\n        ll j = a[i]._Find_first();\n        if (j >= n)\n            continue;\n        ++r;\n        for (ll k = i + 1; k < n; ++k)\n            if (a[k][j])\n                a[k] ^= a[i];\n    }\n    cout << (qpow(2,n) + M - qpow(2,n-r)) * qpow(2,m-1) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YESNO OUT(three(solve(),\"YES\",\"NO\"))\n#define YesNo OUT(three(solve(),\"Yes\",\"No\"))\n#define WL(A,B) OUT(three(solve(),A,B))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(b);i>=(LL)(a);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n#define all ALL\n#define pb emplace_back\n#define eb pb\n#define int long long\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntemplate<class T> inline bool chmax(int a, int b, T c, T d) { return c > d ? a : b; }\ntemplate<class T> inline bool chmin(int a, int b, T c, T d) { return c > d ? a : b; }\ntypedef int LL;\ntypedef double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef tuple<int, int, int, int> tapu;\ntypedef vector<tapu> Vtapu;\ntypedef priority_queue<ut, VI, greater<LL> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 1e6 + 1000;\nconst int SIZE2 = 4010;\nconst int SIZE3 = 430;\nconst int SIZE = SIZE1;\nconst int MAPSIZE = 40;\nconst LL p =998244353;\nconst LL INF = 1LL << 30;\nconst long double EPS = 1e-7;\nconst LL inf = 1000000000;\ntypedef pair<ld, ut> pld;\nut N, M, K, L, Q,  H, W, R;\nVI edges[SIZE];\nLL vals[SIZE], answer = zero;\n//LL maps[SIZE2][SIZE2];\nLL A[SIZE3][SIZE3],B[SIZE],C[SIZE],D[SIZE],E[SIZE];\nLL def = 0;\nvoid rev(int a) {\n\tREP(i, W) {\n\t\tdef ^= A[a][i];\n\t\tA[a][i] ^= 1;\n\t}\n}\nvoid xors(int a, int b) {\n\tREP(i, W)\n\t\tA[a][i] ^= A[b][i];\n}\nvoid swaps(int a, int b) {\n\tREP(i, W)\n\t\tswap(A[a][i], A[b][i]);\n}\nLL power(LL x) {\n\tLL ans = 1;\n\tREP(i, x) ans = ans * 2 % p;\n\treturn ans;\n}\nLL solve() {\n\tcin >> H >> W;\n\tREP(i, H) REP(j, W) {\n\t\tcin >> A[i][j];\n\t}\n\tLL ans = 0,rank=0;\n\tREP(j, W) {\n\t\tFOR(i,rank,H) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tswaps(i, j);\n\t\t\t\tFOR(k, rank + 1, H) {\n\t\t\t\t\tif (A[k][j]) xors(k, j);\n\t\t\t\t}\n\t\t\t\trank++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (power( H + W - 1) % p - power(H+W-rank-1) % p + p) % p;\n\t//return ;\n}\n\n\n\n\n//!!!!!!!!!!!!!!!!!!!実装を詰める!!!!!!!!!!!!!!!!!!!!!!!!!\nsigned main() {\n\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(0);\n\tcout << solve() << endl;\n\t\n\t//cin >> N;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void read(T &x)\n{\n    x=0; char c=getchar();  int f=1;\n    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\n#include <bitset>\nconst int mod=998244353;\nll Pow(ll x,ll y){ll res=1; while(y){if(y&1) res=res*x%mod; x=x*x%mod,y>>=1;} return res;}\nbitset<310> f[310];\nint n,m;\nvoid print()\n{\n\tfor(int i=0;i<n;++i,puts(\"\"))\n\t{\n\t\tfor(int j=0;j<m;++j) printf(\"%d \",f[i][j]==1);\n\t}\n\tputs(\"\");\n}\nint main()\n{\n\tint x; read(n),read(m);\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j) read(x),f[i][j]=x;\n\tint ans=0;\n\tfor(int i=0;i<m;++i)\n\t{\n\t\tfor(int j=0;j<n;++j) if((!f[j][j]||j>=i)&&f[j][i]){if(j!=i)swap(f[i],f[j]); break;}//必须循环到n \n\t\tif(!f[i][i]){ans++; continue;}\n\t\tfor(int j=0;j<n;++j) if(j!=i&&f[j][i]) f[j]^=f[i];\n//\t\tprint(); \n\t}\n//\tcout<<ans<<endl;\n\tprintf(\"%lld\",((Pow(2,m+n-1)-Pow(2,ans+n-1))%mod+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass reverse_range {private:struct I {int x;int operator*() {return x-1;}bool operator!=(I& lhs) {return x>lhs.x;}void operator++() {--x;}};I i, n;public:reverse_range(int n) :i({ 0 }), n({ n }){}reverse_range(int i, int n) :i({ i }), n({ n }){}I& begin() {return n;}I& end() {return i;}};\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }reverse_range operator!(){return reverse_range(*i,*n);}};\n\nconstexpr int mod = 998244353;\nint R,C;\nint A[312][312];\nLL pow_mod(LL a,LL n,int M=mod){\n    LL res=1;\n    a%=M;\n    while(n){\n        if(n&1)\n            res=(res*a)%M;\n        a=(a*a)%M;\n        n>>=1;\n    }\n    return res;\n}\nint get_rank(){\n    int ret = 0;\n    for(int c:range(C)){\n        int id=-1;\n        for(int i:range(ret,R)){\n            if(A[i][c]==1){\n                id=i;\n            }\n        }\n        if(id==-1)continue;\n        for(int j:range(C)){\n            swap(A[ret][j],A[id][j]);\n        }\n        ret++;\n        for(int i:range(ret,R)){\n            if(A[i][c]==1)for(int j:range(C)){\n                A[i][j] = A[i][j] xor A[ret-1][j];\n            }\n        }\n    }\n    return ret;\n}\nint main(){\n    cin>>R>>C;\n    for(int i:range(R))for(int j:range(C)){\n        cin>>A[i][j];\n    }\n    LL ret=pow_mod(2,R+C-1)-pow_mod(2,R+C-1-get_rank())+mod;\n    cout<<ret%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REP1(i,n) for(int i=1;i<=n;++i)\n#define SZ(i) int(i.size())\n#ifdef tmd\n#define IOS()\n#define debug(...) fprintf(stderr,\"#%d: %s = \",__LINE__,#__VA_ARGS__),_do(__VA_ARGS__);\ntemplate<typename T> void _do(T &&x){cerr<<x<<endl;}\ntemplate<typename T, typename ...S> void _do(T &&x, S &&...y){cerr<<x<<\", \";_do(y...);}\ntemplate<typename It> ostream& _printRng(ostream &os,It bg,It ed)\n{\n    os<<\"{\";\n    for(It it=bg;it!=ed;it++) {\n        os<<(it==bg?\"\":\",\")<<*it;\n    }\n    os<<\"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator << (ostream &os,vector<T> &v){return _printRng(os,v.begin(), v.end());}\ntemplate<typename T> void pary(T bg, T ed){_printRng(cerr,bg,ed);cerr<<endl;}\n#else\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n#define debug(...)\n#define pary(...)\n#endif\n\nconst int MAXN = 302;\nconst ll MOD = 998244353;\n\nint n, m;\nll tw[MAXN];\nbitset<MAXN> rw[MAXN];\n\nbitset<MAXN> basis[MAXN];\nint sz;\n\nvoid inc (bitset<MAXN> vec) {\n    for (int i=MAXN-1; i>=0; i--) {\n        if (vec[i]) {\n            if (basis[i].count() == 0) {\n                basis[i] = vec;\n                sz++;\n                break;\n            } else {\n                vec ^= basis[i];\n            }\n        }\n    }\n}\n/*********************GoodLuck***********************/\nint main () {\n    IOS();\n\n    tw[0] = 1;\n    REP1 (i, MAXN-1) {\n        tw[i] = tw[i-1] * 2 % MOD;\n    }\n\n    cin >> n >> m;\n    REP (i, n) {\n        REP (j, m) {\n            bool d;\n            cin >> d;\n            rw[i][j] = d;\n        }\n\n        inc(rw[i]);\n    }\n\n    int free = n - sz;\n    ll rcob = tw[n] - tw[free];\n    if (rcob < 0) {\n        rcob += MOD;\n    }\n\n    cout << rcob * tw[m-1] % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <bitset>\n\ntypedef unsigned int ui;\nconst int MN = 2000;\nconst int Mod = 998244353;\n\nint N, M, Cnt;\nint A[MN][MN];\n\nint Sz; ui *B[MN], *tmp;\n#define set(b, i) (b[(i) >> 5] |= 1 << ((i) & 31))\n#define val(b, i) (b[(i) >> 5] >> ((i) & 31) & 1)\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tif (N > M) {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < M; ++j)\n\t\t\t\tscanf(\"%d\", &A[i][j]);\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < M; ++j)\n\t\t\t\tscanf(\"%d\", &A[j][i]);\n\t\tstd::swap(N, M);\n\t}\n\tSz = (M + 31) >> 5;\n\tfor (int j = 0; j < M; ++j) B[j] = new ui[Sz];\n\ttmp = new ui[Sz];\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) if (A[i][j]) set(tmp, j);\n\t\tfor (int j = M - 1; ~j; --j) if (val(tmp, j)) {\n\t\t\tif (val(B[j], j)) for (int k = 0; k < Sz; ++k) tmp[k] ^= B[j][k];\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < Sz; ++k) B[j][k] = tmp[k];\n\t\t\t\t++Cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlong long Ans = 0;\n\tfor (int i = 0, s = 1; i < N + M; ++i, s = (s << 1) % Mod) {\n\t\tif (i == N + M - Cnt - 1) Ans -= s;\n\t\tif (i == N + M - 1) Ans += s;\n\t}\n\tprintf(\"%lld\\n\", (Ans % Mod + Mod) % Mod);\n\tfor (int j = 0; j < M; ++j) delete [] B[j];\n\tdelete [] tmp;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst ll Mod=998244353;\nconst int maxn=310;\nint n,m;\nbitset<maxn> p[maxn],b;\nll pw(ll x,ll y)\n{\n\tll res=1;\n\twhile (y)\n\t{\n\t\tif (y&1)\n\t\t{\n\t\t\tres=res*x%Mod;\n\t\t}\n\t\tx=x*x%Mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint r=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tb.reset();\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif (x)\n\t\t\t{\n\t\t\t\tb.set(j);\n\t\t\t}\n\t\t}\n\t\tfor (int j=m;j;j--)\n\t\t{\n\t\t\tif (!b[j])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!p[j].any())\n\t\t\t{\n\t\t\t\tp[j]=b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tb^=p[j];\n\t\t}\n\t\tif (!b.any())\n\t\t{\n\t\t\tr++;\n\t\t}\n\t}\n\tcout<<(pw(2,n)-pw(2,r)+Mod)%Mod*pw(2,m-1)%Mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 998244353;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\nclass Solver2 {\n public:\n  int n, m;\n  vector<vector<int>> a;\n  Solver2(LL n, LL m) : n(n), m(m), a(n, vector<int>(m)){};\n\n  int sweep(vector<vector<int>> X) {\n    int rank = 0;\n    for (int col = 0; col < m; ++col) {\n      int nonzeroRow = -1;\n      for (int r = rank; r < n; ++r) {\n        if (X[r][col]) {\n          nonzeroRow = r;\n          break;\n        }\n      }\n      if (nonzeroRow == -1) continue;\n      if (nonzeroRow > rank) swap(a[rank], a[nonzeroRow]);\n      for (int r = rank + 1; r < n; ++r) {\n        if (X[r][col]) {\n          for (int c = col; c < m; ++c) {\n            X[r][c] ^= X[rank][c];\n          }\n        }\n      }\n      rank++;\n    }\n    return min({n,m,rank});\n  }\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        cin >> a[i][j];\n      }\n    }\n    int rank = sweep(a);\n    if (rank == 0)\n      cout << 0 << endl;\n    else\n      cout << (Modint<>(2).mpow(rank) - 1) * Modint<>(2).mpow(n - rank) * Modint<>(2).mpow(m - 1) << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n\nconst int ms = 303;\nconst int MOD = 998244353;\n\nstd::bitset<ms> mat[ms];\n\nstruct Gauss {\n\tGauss() {\n\t\trank = 0;\n\t\tfor(int i = 0; i < ms; i++) {\n\t\t\teq[i].reset();\n\t\t}\n\t}\n\tint rank;\n\tstd::bitset<ms> eq[ms];\n\n\tint add(std::bitset<ms> a) {\n\t\tfor(int i = 0; i < ms; i++) {\n\t\t\tif(!eq[i][i] && !a[i]) continue;\n\t\t\tif(eq[i][i]) {\n\t\t\t\tif(a[i]) {\n\t\t\t\t\ta ^= eq[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq[i] = a;\n\t\t\t\trank++;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstd::bitset<ms> reduce(std::bitset<ms> a) {\n\t\tfor(int i = 0; i < ms; i++) {\n\t\t\tif(eq[i][i] && a[i]) {\n\t\t\t\ta ^= eq[i];\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n};\n\nlong long pot[ms + ms];\n\nint main() {\n\tpot[0] = 1;\n\tfor(int i = 1; i < ms + ms; i++) {\n\t\tpot[i] = pot[i-1] * 2 % MOD;\n\t}\n\tint n, m;\n\tstd::cin >> n >> m;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tint v;\n\t\t\tstd::cin >> v;\n\t\t\tif(v) {\n\t\t\t\tmat[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\t// count isolated\n\tfor(int i = 0; i < n; i++) {\n\t\tlong long cur = 0;\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tif(mat[i][j]) cur = 1;\n\t\t}\n\t\tcur = cur * pot[m-1+n-1] % MOD;\n\t\tans = (ans + cur) % MOD;\n\t}\n\t// uncount with previous\n\tGauss tot;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(i) {\n\t\t\tmat[i-1][m] = 0;\n\t\t\ttot.add(mat[i-1]);\n\t\t}\n\t\tmat[i][m] = 1;\n\t\tint id = tot.add(mat[i]);\n\t\tif(id == m) {\n\t\t\ttot.eq[id].reset();\n\t\t\ttot.rank--;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tmat[j][m] = 1;\n\t\t\tauto b = tot.reduce(mat[j]);\n\t\t\tif(b[m] && b.count() == 1) {\n\t\t\t\t// contradiction\n\t\t\t} else {\n\t\t\t\tint rank = tot.rank;\n\t\t\t\tif(b.count()) rank++;\n\t\t\t\t//std::cout << \"on pair \" << i << \", \" << j << \" got rank \" << rank << \"\\n\";\n\t\t\t\tans = (ans - pot[n-1+m-rank] + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t\tif(id != -1) {\n\t\t\ttot.rank--;\n\t\t\ttot.eq[id].reset();\n\t\t}\n\t}\n\tstd::cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <functional>\n#include <unordered_set>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <bitset>\n\nusing namespace std;\n\nconst int N = 2e5 + 10;\nconst long long INF = 1LL << 60;\n\nvoid xorVector(vector<char>& a, const vector<char>& b) {\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\ta[i] ^= b[i];\n\t}\n}\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\treturn a - MOD;\n\treturn a;\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector <vector<char>> v(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tv[i].resize(m);\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> v[i][j];\n\t\t\tv[i][j] = (v[i][j] == '1');\n\t\t}\n\t}\n\tint r = 0;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint id = -1;\n\t\tfor (int j = r; j < n; ++j) {\n\t\t\tif (v[j][i] == 1) {\n\t\t\t\tid = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (id == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\t++r;\n\t\tv[r].swap(v[id]);\n\t\tfor (int j = r + 1; j < n; ++j) {\n\t\t\tif (v[j][i]) {\n\t\t\t\txorVector(v[j], v[r]);\n\t\t\t}\n\t\t}\n\t}\n\tint pw2 = 1;\n\tvector <int> pow2 = { 1 };\n\tfor (int i = 1; i <= n + m; ++i) {\n\t\tpw2 = add(pw2, pw2);\n\t\tpow2.push_back(pw2);\n\t}\n\tint ans = pow2[n + m - 1] - pow2[n + m - r - 1];\n\tif (ans < 0) {\n\t\tans += MOD;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n        mat<COL_SIZE> b(r);\n        for(int i = 0; i < r; i++) b[i] = a[i];\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n        return a[index];\n    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<305>a(m+5);\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n  return 0;\n    int r = a.rank();\n    cerr << r << endl;\n    cout << -1 << endl;\n//    cout << (mod_pow(2,n+m-1) - mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <bitset>\n#define mod 998244353\n\ntypedef std::bitset<301> BS;\n\nBS d[301];\nBS a[301];\n\nint qpow(int x, int p)\n{\n\tint ans = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) ans = 1ll * ans * x;\n\t\tx = 1ll * x * x; p >>= 1; \n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\ta[j][i] = x;\n\t\t}\n\tint cnt = 0;\n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = n; j >= 1; j--)\n\t\t{\n\t\t\tif(a[i][j] == 1)\n\t\t\t{\n\t\t\t\tif(!d[j][j]) d[j] = a[i], cnt++;\n\t\t\t\ta[i] ^= d[j];\n\t\t\t}\n\t\t}\n\tprintf(\"%lld\\n\", 1ll * qpow(2, n - 1) * (qpow(2, m) - qpow(2, m - cnt) + mod) % mod);\n}\n\n//对于一维的情况，如果有1，那么答案是2^(len-1)，否则为0\n//考虑选出某几列，如果把这几列中每一行的数字xor起来后有至少一行为1，那么就有2^(n-1)的贡献\n//把每一列看成一个数，题目转化成 问有多少个列的子集异或和不为0\n//考虑异或和为0的子集个数，构造线性基，那么对每个不在线性基中的数，都可以选或不选(加上几个在线性基中的数都能xor出0)\n//所以为2^(m-cnt)，cnt为在线性基中的数的个数\n//ans = 2 ^ (n-1) * (2 ^ m - 2 ^ (m-cnt) ) "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=998244353;\nlong long n,m,a[333][333],pw[666],cnt,pos,cur;\nvoid gauss()\n{\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tpos=-1;\n\t\tfor (long long j=i;j<=n;j++)\n\t\t{\n\t\t\tif (a[j][i])\n\t\t\t{\n\t\t\t\tpos=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~pos)\n\t\t{\n\t\t\tcnt++;\n\t\t\tfor (long long j=1;j<=m;j++) swap(a[i][j],a[pos][j]);\n\t\t\tfor (long long j=i+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif (a[j][i])\n\t\t\t\t{\n\t\t\t\t\tfor (long long k=i;k<=m;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][k]^=a[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} \nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tfor (long long j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tpw[0]=1;\n\tfor (long long i=1;i<=600;i++) pw[i]=pw[i-1]*2%mod;\n\tgauss();\n\tif (m<cnt) cur=0;\n\telse cur=pw[m-cnt];\n\tprintf(\"%lld\\n\",((pw[n+m-1]-pw[n-1]*cur)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=305;\nint n,m;\nll two[M];\nvvi a;\n\nint main(){\n\ttwo[0]++;\n\tfor(int i=1;i<M;i++) two[i]=two[i-1]*2%mod;\n\tcin>>n>>m;\n\ta=vvi(n,vi(m));\n\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) cin>>a[i][j];\n\tint I=0;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++) if(a[j][i]){\n\t\t\tswap(a[I],a[j]);\n\t\t\tbreak;\n\t\t}\n\t\tif(!a[I][i]) continue;\n\t\tfor(int j=0;j<n;j++) if(j!=I&&a[j][i]){\n\t\t\tfor(int k=0;k<m;k++) a[j][k]^=a[I][k];\n\t\t}\n\t\tI++;\n\t}\n\tcout<<(two[m]-two[m-I]+mod)*two[n-1]%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 333;\nconst int MOD = 998244353;\ntypedef bitset<N> row;\n\nint n,m,pot[N+N];\nrow a[N];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    pot[0] = 1; forsn(n,1,2*N) pot[n] = (pot[n-1]+pot[n-1])%MOD;\n\n    cin >> n >> m;\n    forn(i,n) forn(j,m) {\n        int x; cin >> x;\n        if (x&1) a[i].set(j);\n    }\n\n    int rank = 0;\n    forn(j,m) {\n        forsn(i,j,n) if (a[i][j]) {\n            swap(a[i], a[j]);\n            break;\n        }\n        if (a[j][j]) {\n            rank++;\n            forsn(i,j+1,n) if (a[i][j]) \n                a[i] ^= a[j];\n        }\n    }\n    auto ans = ll(pot[n] - pot[n-rank])*(pot[m-1])%MOD;\n    if (ans < 0) ans += MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 998244353;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % md);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nconst int N = 330;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  cin >> n >> m;\n  vector< vector<int> > a(n, vector<int>(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> a[i][j];\n    }\n  }\n\n  auto lowbit = [](vector<int> a) {\n    for (int i = 0; i < (int) a.size(); i++) {\n      if (a[i] == 1) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  auto Xor = [&](int i, int j) {\n    for (int k = 0; k < m; k++) {\n      a[i][k] ^= a[j][k];\n    }\n  };\n\n  vector<int> base;\n  for (int i = 0; i < n; i++) {\n    for (auto j : base) {\n      if (a[i][ lowbit(a[j]) ] == 1) {\n        Xor(i, j);\n      }\n    }\n    if (lowbit(a[i]) != -1) {\n      base.push_back(i);\n    }\n  }\n\n  int r = base.size();\n  // cerr << r << '\\n';\n  int res = 1;\n  res = mul(res, power(2, r - 1));\n  res = mul(res, power(2, r) - 1);\n  res = mul(res, power(2, (n - r) + (m - r)));\n  cout << res << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n\nstruct edge { int to, cost; };\n\nconst int INF = 1e18;\nconst int MOD = 1e9+7;\n\ntemplate<int mod=MOD>\nstruct ModRing {\n   int x;\n   ModRing() : x(0) {}\n   ModRing(int a) { x = ((a % mod) + mod) % mod; }\n\n   bool operator==(const ModRing& a) const {\n      return x == a.x;\n   }\n   bool operator!=(const ModRing& a) const {\n      return x != a.x;\n   }\n   bool operator==(int a) const {\n      return *this == ModRing(a);\n   }\n   bool operator!=(int a) const {\n      return *this != ModRing(a);\n   }\n   ModRing& operator=(int a) {\n      return *this = ModRing(a);\n   }\n   ModRing operator-() const {\n      return ModRing((-x + mod) % mod);\n   }\n   ModRing& operator+=(const ModRing& a) {\n      (x += a.x) %= mod;\n      return *this;\n   }\n   ModRing& operator-=(const ModRing& a) {\n      return *this += -a;\n   }\n   ModRing& operator*=(const ModRing& a) {\n      (x *= a.x) %= mod;\n      return *this;\n   }\n   const ModRing operator+(const ModRing& a) const {\n      return ModRing(x) += a;\n   }\n   const ModRing operator-(const ModRing& a) const {\n      return ModRing(x) -= a;\n   }\n   const ModRing operator*(const ModRing& a) const {\n      return ModRing(x) *= a;\n   }\n   ModRing& operator+=(int a) {\n      return *this += ModRing(a);\n   }\n   ModRing& operator-=(int a) {\n      return *this -= ModRing(a);\n   }\n   ModRing& operator*=(int a) {\n      return *this *= ModRing(a);\n   }\n   const ModRing operator+(int a) const {\n      return ModRing(x) += a;\n   }\n   const ModRing operator-(int a) const {\n      return ModRing(x) -= a;\n   }\n   const ModRing operator*(int a) const {\n      return ModRing(x) *= a;\n   }\n   ModRing power(int n) const {\n      ModRing tmp(x), res(1);\n      while (n > 0) {\n         if ((n & 1) == 1) res *= tmp;\n         tmp *= tmp;\n         n >>= 1;\n      }\n      return res;\n   }\n};\ntemplate<int mod>auto&operator<<(ostream&s,const ModRing<mod>&a){s<<a.x;return s;}\n\ntemplate<int mod=MOD>\nstruct FiniteField : ModRing<mod> {\n   FiniteField() : ModRing<mod>() {}\n   FiniteField(int a) : ModRing<mod>(a) {}\n   FiniteField(const ModRing<mod>& a) : ModRing<mod>(a) {}\n\n   FiniteField& operator=(int a) {\n      return *this = ModRing<mod>::operator=(a);\n   }\n   FiniteField& operator+=(const FiniteField& a) {\n      return *this = ModRing<mod>::operator+=(a);\n   }\n   FiniteField& operator-=(const FiniteField& a) {\n      return *this = ModRing<mod>::operator-=(a);\n   }\n   FiniteField& operator*=(const FiniteField& a) {\n      return *this = ModRing<mod>::operator*=(a);\n   }\n   FiniteField& operator+=(int a) {\n      return *this = ModRing<mod>::operator+=(a);\n   }\n   FiniteField& operator-=(int a) {\n      return *this = ModRing<mod>::operator-=(a);\n   }\n   FiniteField& operator*=(int a) {\n      return *this = ModRing<mod>::operator*=(a);\n   }\n\n   FiniteField inverse() const {\n      try { if (this->x == 0) throw \"0 have no inverse\"; }\n      catch (const char* e) { cerr << e << endl; }\n      return ModRing<mod>::power(mod-2);\n   }\n   FiniteField& operator/=(const FiniteField& a) {\n      return *this *= a.inverse();\n   }\n   const FiniteField operator/(const FiniteField& a) const {\n      return FiniteField(*this) /= a;\n   }\n   FiniteField& operator/=(int a) {\n      return *this /= FiniteField(a);\n   }\n   const FiniteField operator/(int a) const {\n      return FiniteField(*this) /= a;\n   }\n};\n\ntemplate<typename Field>\nstruct Frac {\n   V<Field> frac;\n   Frac(int n) {\n      frac.resize(n+1);\n      frac[0] = 1;\n      for (int i = 1; i <= n; i++) {\n         frac[i] = frac[i-1] * i;\n      }\n   }\n   Field operator[](int i) {\n      return frac[i];\n   }\n};\n\ntemplate<typename Field>\nstruct Comb {\n   Frac<Field> frac;\n   Comb(int n) : frac(n) {}\n   Field operator()(int n, int r) {\n      if (n < 0 || n-r < 0 || r < 0) {\n         return 0;\n      }\n      return frac[n] / (frac[n-r] * frac[r]);\n   }\n};\n\ntemplate<typename Field>\nstruct Matrix\n{\n   vector<vector<Field>> val;\n   int m, n;\n   Matrix(int a=0, int b=0) : m(a), n(b) {\n      val.resize(m, vector<Field>(n));\n   }\n   Matrix(const vector<vector<Field>>& vec) { init(vec); }\n   void init(const vector<vector<Field>>& vec) {\n      m = vec.size(); n = vec[0].size();\n      val.resize(m, vector<Field>(n));\n      for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\n         val[i][j] = vec[i][j];\n   }\n   Matrix& operator=(const Matrix& mat) {\n      try { if (m != mat.m || n != mat.n) throw \"Matrix can't be substituted\"; }\n      catch (const char* e) { cerr << e << endl; }\n      for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\n         val[i][j] = mat.val[i][j];\n      return *this;\n   }\n   Field operator()(int i, int j) const {\n      try { if (i < 0 || m <= i || j < 0 || n <= j) throw \"Bad access\"; }\n      catch (const char* e) { cerr << e << endl; }\n      return val[i][j];\n   }\n   Matrix& operator-() const {\n      Matrix tmp(m, n);\n      for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\n         tmp.val[i][j] = -val[i][j];\n      return tmp;\n   }\n\n   Matrix& operator+=(const Matrix& mat) {\n      try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n      catch (const char* e) { cerr << e << endl; }\n      for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\n         val[i][j] += mat.val[i][j];\n      return *this;\n   }\n   Matrix& operator-=(const Matrix& mat) {\n      try { if (m != mat.m || n != mat.n) throw \"Matrix can't be subtracted\"; }\n      catch (const char* e) { cerr << e << endl; }\n      return *this += -mat;\n   }\n   Matrix operator*=(const Matrix& mat) {\n      try { if (n != mat.m) throw \"Matrix can't be producted\"; }\n      catch (const char* e) { cerr << e << endl; }\n      Matrix tmp(m, mat.n);\n      for (int i = 0; i < m; i++) for (int j = 0; j < mat.n; j++) for (int k = 0; k < n; k++)\n         tmp.val[i][j] += val[i][k] * mat.val[k][j];\n      n = mat.n;\n      val.resize(m, vector<Field>(n));\n      return *this = tmp;\n   }\n   const Matrix operator+(const Matrix& mat) const {\n      return Matrix(val) += mat;\n   }\n   const Matrix operator-(const Matrix& mat) const {\n      return Matrix(val) -= mat;\n   }\n   const Matrix operator*(const Matrix& mat) const {\n      return Matrix(val) *= mat;\n   }\n   Matrix transpose() const {\n      Matrix tmp(n, m);\n      for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\n         tmp.val[j][i] = val[i][j];\n      return tmp;\n   }\n   int gaussElimination() {\n      int swap_num = 0;\n      int col = 0;\n      for (int i = 0; i < m; i++) {\n         int pivot;\n         bool updated = false;\n         while (col < n) {\n            for (int j = i; j < m; j++) if (val[j][col] != 0) {\n               pivot = j;\n               updated = true;\n               break;\n            }\n            if (updated) break;\n            col++;\n         }\n         if (!updated) return swap_num;\n\n         if (i != pivot) {\n            swap(val[i], val[pivot]);\n            swap_num++;\n         }\n         for (int j = i+1; j < m; j++) {\n            Field ratio = val[j][col] / val[i][col];\n            for (int k = col; k < n; k++) val[j][k] -= val[i][k] * ratio;\n         }\n         col++;\n      }\n      return swap_num;\n   }\n   int rank() const {\n      Matrix A(val);\n      A.gaussElimination();\n      int j = 0;\n      for (int i = 0; i < m; i++) {\n         while (A.val[i][j] == 0) {\n            j++; if (j == n) return i;\n         }\n      }\n      return m;\n   }\n};\ntemplate<typename Field>ostream&operator<<(ostream&s,const Matrix<Field>&mat){s<<endl<<\"[\";for(int i=0;i<mat.m;i++){s<<\"[\";for(int j=0;j<mat.n;j++){s<<mat(i,j);if(j<mat.n-1)s<<\" \";}s<<\"]\";if(i<mat.m-1)s<<endl;}s<<\"]\";return s;}\n\ntemplate<typename Field>\nstruct SquareMatrix : Matrix<Field>\n{\n   int num;\n   SquareMatrix(int a=0) : Matrix<Field>(a, a) { num = a; }\n   SquareMatrix(const vector<vector<Field>>& vec) : num(vec.size()), Matrix<Field>(vec) {\n      try { if (vec.size() != vec[0].size()) throw \"Matrix isn't square matrix\"; }\n      catch (const char* e) { cerr << e << endl; }\n   }\n   Field determinant() const {\n      SquareMatrix A(*this);\n      int swap_num = A.gaussElimination();\n      Field det = (swap_num % 2 ? -1 : 1);\n      for (int i = 0; i < num; i++) det *= A(i,i);\n      return det;\n   }\n   SquareMatrix power(int n) const {\n      SquareMatrix A(this->val);\n      V<V<Field>> E(num,V<Field>(num));\n      for (int i = 0; i < num; i++) E[i][i] = 1;\n      SquareMatrix res(E);\n      while (n > 0) {\n         if ((n & 1) == 1) { res *= A; }\n         A *= A;\n         n >>= 1;\n      }\n      return res;\n   }\n};\n\nsigned main()\n{\n   int n, m; cin >> n >> m;\n\n   using GF2 = FiniteField<2>;\n   V<V<GF2>> a(n, V<GF2>(m));\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         int v; cin >> v;\n         a[i][j] = v;\n      }\n   }\n\n   Matrix<GF2> A(a);\n\n   int rank = A.rank();\n\n   using GF = FiniteField<998244353>;\n   GF ans = GF(2).power(n+m-1) - GF(2).power(n+m-rank-1);\n   cout << ans << endl;\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nconst int N=3e2+10;\nconst int mod=998244353;\nint n,m,a[N][N],c[N][N],b[N],Max=N-5,cnt;\ninline int fas(int x,int p){int res=1;while(p){if(p&1)res=1ll*res*x%mod;p>>=1;x=1ll*x*x%mod;}return res;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(register int i=1;i<=n;i++)\n\t\tfor(register int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&a[i][j]);\n\tfor(register int i=1;i<=n;i++){\n\t\tfor(register int j=1;j<=m;j++)b[j]=a[i][j];\n\t\tfor(register int p=Max;p;p--){\n\t\t\tif(b[p]){\n\t\t\t\tif(!c[p][p]){\n\t\t\t\t\tfor(register int k=p;k;k--)c[p][k]=b[k];\n\t\t\t\t\tcnt++;break;\n\t\t\t\t}\n\t\t\t\telse for(register int k=p;k;k--)b[k]^=c[p][k];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",1ll*(fas(2,n)-fas(2,n-cnt)+mod)%mod*fas(2,m-1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD=998244353;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=5e5+10;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<MAX;++i){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\n// Be careful with the value of MAX and conducting COMinit()\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    COMinit();\n    int N,M; cin >> N >> M;\n    vector<vector<int>> a(N,vector<int>(M));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<M;++j){\n            cin >> a[i][j];\n        }\n    }\n    int rank=0;\n    for (int j=0;j<M;++j){\n        int pivot=-1;\n        for (int i=rank;i<N;++i){\n            if (a[i][j]) pivot=i;\n        }\n        if (pivot<0) continue;\n        swap(a[rank],a[pivot]);\n        for (int i=0;i<N;++i){\n            if (i!=rank&&a[i][j]){\n                for (int k=0;k<M;++k){\n                    a[i][k]^=a[rank][k];\n                }\n            }\n        }\n        ++rank;\n    }\n    mint ans=(pow((mint)2,rank)-1)*pow((mint)2,N+M-rank-1);;\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 3e2 + 6, MOD = 1e9 + 7;\nint n, m;\nint Arr[N][N];\n\nvoid swap_row (int l, int r) {\n\tfor (int i = 0; i < m; i++)\n\t\tswap(Arr[l][i], Arr[r][i]);\n}\n\nvoid xor_row (int l, int r) {\n\tfor (int i = 0; i < m; i++)\n\t\tArr[r][i] ^= Arr[l][i];\n}\n\nint _sub (int a, int b) {\n\tint c = a - b;\n\tif (c < 0)\n\t\tc += MOD;\n\treturn c;\n}\n\nint _mul (int a, int b) {\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\n\nint _pow (int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1)\n\t\t\tres = _mul(res, a);\n\t\ta = _mul(a, a);\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tcin >> Arr[i][j];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint ind = -1;\n\t\tfor (int j = i; j < n; j++)\n\t\t\tif (Arr[j][i])\n\t\t\t\tind = j;\n\n\t\tif (ind == -1)\n\t\t\tcontinue;\n\n\t\tswap_row(i, ind);\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (Arr[j][i])\n\t\t\t\txor_row(i, j);\n\t}\n\n\tint num = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (Arr[i][j]) {\n\t\t\t\tnum++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\tif (!num) {\n\t\tcout << \"0\\n\";\n\t\treturn 0;\n\t}\n\n\tint res = _mul(_sub(_pow(2, num), 1), _pow(2, n - num));\n\tcout << _mul(res, _pow(2, m - 1)) << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint a[305][305];\nbool check[305];\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) cin >> a[i][j];\n\t}\n\t\n\t// a[i][m + 1] = 0\n\tint rank = 0;\n\tfor (int col = 1; col <= m; ++col) {\n\t\tint row = 0;\n\t\tfor (int i = 1; i <= n; ++i) if (!check[i] && a[i][col]) row = i;\n\t\tif (!row) {\n\t\t\t++rank; continue;\n\t\t}\n\t\tcheck[row] = true;\n\t\tfor (int i = 1; i <= n; ++i) if (i != row && a[i][col]) {\n\t\t\tfor (int j = 1; j <= m; ++j) a[i][j] ^= a[row][j];\n\t\t}\n\t}\n\t\n\t// 2^(m + n - 1) - 2^(rank + n - 1)\n\tint tmp = 1, res = 1;\n\tstatic const int mod = 998244353;\n\tfor (int i = 1; i <= m + n - 1; ++i) res = 2LL * res % mod;\n\tfor (int i = 1; i <= rank + n - 1; ++i) tmp = 2LL * tmp % mod;\n\t\n\tres = (res - tmp) % mod;\n\tif (res < 0) res += mod;\n\t\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 300004\n#define LL long long\n#define ULL unsigned long long\n#define pp pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define ff first\n#define dd second\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define FWD(i,a,b) for (int i=(a); i<(b); ++i)\n#define BCK(i,a,b) for (int i=(a); i>(b); --i)\n#define SIZE(c) ((int)((c).size()))\n#define ALL(u) (u).begin(),(u).end()\n#define K 41\nLL fpw(LL a, ULL b, LL p){\n    LL r = 1; while(b){if(b&1) r=r*a%p; a=a*a%p; b/=2;} return (LL)r;\n}\n\nusing namespace std;\nint n, m,a,b,k;\n\nint mod = 998244353;\n\nbitset<301> tab[301];\n\nint potTwo[301];\n\nint newton[301][301];\n\nint potThree[301];\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> m;\n\n    for(int i = 0; i  < 301; ++i) for(int j = 0; j < 301; ++j) newton[i][j] = 0;\n    for(int i = 0; i < 301; ++i) newton[i][0] = 1;\n    for(int i = 1; i < 301; ++i) {\n        for(int j = 1; j <= i; ++j) {\n            newton[i][j] = (newton[i-1][j-1] + newton[i-1][j]) % mod;\n        }\n    }\n\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n           int temp; cin >> temp;\n            tab[i].set(j,temp);\n        }\n    }\n\n    int row = 0;\n    for(int col = 0; col < m; ++col) {\n        for(int i = row; i < n; ++i) {\n            if (tab[i][col]) {\n                swap(tab[i], tab[row]); break;\n            }\n        }\n        if (row < n && tab[row][col]) {\n            for(int i = row+1; i < n; ++i) {\n                if(tab[i][col]) tab[i] ^= tab[row];\n            }\n            row++;\n        }\n    }\n\n   /* cout << \"row \" << row << endl;\n\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            cout << tab[i][j] << \" \";\n        }\n        cout << endl;\n    }*/\n\n    potTwo[0] = potThree[0] = 1;\n    for(int i = 1; i < 301; ++i) potTwo[i] = potTwo[i-1]*2 % mod;\n    for(int i = 1; i < 301; ++i) potThree[i] = potThree[i-1]*3 % mod;\n\n    int ans = potTwo[n-row]*potTwo[m-row] % mod;\n    int ile = 0;\n    for(int i = 1; i <= row; i += 2) {\n        ile += potThree[row-i]*newton[row][i] % mod;\n        ile %= mod;\n    }\n    ans *= ile;\n    ans %= mod;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nvoid Gauss(vector<vector<int>> &mat) {\n    \n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        int fs = mat[i][i];\n\n        for(int j = i+1; j < n; j++) {\n            int r = mat[j][i] / fs;\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k] * r;\n            }\n        }\n    }\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    if(b == 1) return a;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    Gauss(rec);\n\n    int r = 0;\n    REP(i, n) {\n        bool ok = false;\n        REP(j, m) {\n            if(rec[i][j]) {\n                ok = true;\n                break;\n            }\n        }\n        if(ok) r++;\n    }\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n\nstruct fast_io {\n    static constexpr int size_in = 1 << 26, size_out = 1 << 26;\n    char data_in[size_in], data_out[size_out], *p_in, *p_out, s[30];\n    fast_io() { fread(data_in, 1, size_in, stdin), p_in = data_in, p_out = data_out; }\n    ~fast_io() { fwrite(data_out, 1, p_out - data_out, stdout); }\n    void putchar(char x) { *p_out++ = x; }\n    template<typename T> void putint(T x) {\n        if (x < 0) { *p_out++ = '-', x = -x; }\n        int i = 0;\n        do { s[i++] = x % 10 + '0'; } while (x /= 10);\n        while (i--) { *p_out++ = s[i]; }\n    }\n    template<typename T=int> T getint() {\n        while (!isdigit(*p_in)) { p_in++; }\n        T ret = *p_in - '0';\n        while (isdigit(*++p_in)) { (ret *= 10) += *p_in - '0'; };\n        return ret;\n    }\n} io;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nint main() {\n    int N = io.getint(), M = io.getint();\n    using bset = bitset<300>;\n    vector<bset> src(N);\n    rep(i, N) {\n        rep(j, M) { src[i][j] = io.getint(); }\n    }\n    int rank = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = N - 1; j > i; j--) {\n            int x = src[j]._Find_first(), y = src[j - 1]._Find_first();\n            if (x < y) { src[j - 1] ^= src[j]; }\n            if (x <= y) { src[j] ^= src[j - 1]; }\n        }\n        if (src[i].none()) { break; }\n        rank++;\n    }\n    using mint = mod_int<998244353>;\n    io.putint((mint(2).pow(N + M - 1) - mint(2).pow(N + M - rank - 1)).val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint a[333][333];\nconst ll mod=998244353;\nlong long fact[333], pr[333];\nvoid pre(){\n    fact[0]=1;\n    for(long long i=1; i<333; ++i){\n        fact[i]=(fact[i-1]*i)%mod;\n    }\n    pr[0]=1;\n    for(long long i=1; i<333; ++i){\n        pr[i]=(pr[i-1]*2)%mod;\n    }\n}\nlong long pwr(long long x, long long e){\n    if(e==0)\n        return 1;\n    long long tmp=pwr(x,e/2);\n    tmp=(tmp*tmp)%mod;\n    if(e%2)\n        tmp=(tmp*x)%mod;\n    return tmp;\n}\nlong long cmp(long long x, long long y){\n    long long res, tmp;\n    tmp=pwr(fact[x-y], mod-2);\n    res=(fact[x]*tmp)%mod;\n    tmp=pwr(fact[y],mod-2);\n    res=(res*tmp)%mod;\n    return res;\n}\nbool l[333];\nint n, m;\nll gauss(){\n    int tmp=0;\n    for(int i=0; i<m; ++i){\n        for(int j=0; j<n; ++j){\n            if(l[j]){\n                continue;\n            }\n            if(a[j][i]){\n                for(int k=j+1; k<n; ++k){\n                    if(l[k])\n                        continue;\n                    if(a[k][i]){\n                        for(int f=0; f<m; ++f){\n                            a[k][f]^=a[j][f];\n                        }\n                    }\n                }\n                ++tmp;\n                l[j]=1;\n                break;\n            }\n        }\n    }\n    return tmp;\n}\n\nint main(){\n    while(cin>>n>>m){\n        ll ans=0;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<m; ++j){\n                scanf(\"%d\",&a[i][j]);\n            }\n        }\n        pre();\n        ll tmp=gauss(), tmp1;\n        for(int i=1; i<=tmp; ++i){\n            tmp1=0;\n            for(int j=1; j<=i; j+=2){\n                tmp1+=cmp(i, j)*pr[tmp-i];\n                tmp1%=mod;\n            }\n            ans+=cmp(tmp, i)*tmp1;\n            ans%=mod;\n        }\n        ans*=pr[n-tmp];\n        ans%=mod;\n        ans*=pr[m-tmp];\n        ans%=mod;\n        cout<<ans<<endl;\n    }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nconst long long mod = 998244353;\n\nvector<int> A[330];\nint N, M;\n\nvoid input(){\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i = 0; i < N; ++i){\n\t\tfor(int j = 0; j < M; ++j){\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tA[i].push_back(x);\n\t\t}\n\t}\n}\n\nint get(vector<int> v){\n\tfor(int i = 0; i < v.size(); ++i) if(v[i] != 0) return i;\n\treturn -1;\n}\n\nvector<int> er(vector<int> v, vector<int> e){\n\tint i1 = get(v);\n\tint i2 = get(e);\n\tif(i1 != i2) return v;\n\tfor(int i = 0; i < v.size(); ++i){\n\t\tv[i] ^= e[i];\n\t}\n\treturn v;\n}\n\nset<vector<int> > se;\n\nlong long pw[330];\n\nlong long mul(long long a, long long b){\n\treturn (a * b) % mod;\n}\n\nlong long solve(){\n\tpw[0] = 1;\n\tfor(int i = 1; i < 330; ++i){\n\t\tpw[i] = (pw[i - 1] * 2) % mod;\n\t}\n\tfor(int i = 0; i < N; ++i){\n\t\tint id = get(A[i]);\n\t\tif(id == -1) continue;\n\t\tvector<int> v = A[i];\n\t\tfor(set<vector<int> >::reverse_iterator it = se.rbegin(); it != se.rend(); ++it){\n\t\t\tv = er(v, *it);\n\t\t}\n\t\tif(get(v) != -1){\n\t\t\tse.insert(v);\n\t\t}\n\t}\n\tlong long ans = pw[N - se.size()];\n\tans = mul(ans, pw[se.size()] - 1);\n\tans = mul(ans, pw[M - 1]);\n\tans += mod;\n\tans %= mod;\n\treturn ans;\n}\n\nint main(){\n\tinput();\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=998244353;\n\nint N;\nint M;\nint mat[314][314];\nint tmp[314][314];\n\nLL mypow(LL base, LL exp) {\n  if (exp == 0) return 1;\n  LL res = mypow(base*base%MOD, exp/2);\n  if (exp%2) res = res*base%MOD;\n  return res;\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  rep(i, N) {\n    rep(j, M) {\n      scanf(\"%01d\", &mat[i][j]);\n    }\n  }\n\n  if (N < M) {\n    rep(i, N) {\n      rep(j, M) {\n        tmp[i][j] = mat[i][j];\n      }\n    }\n\n    rep(i, N) {\n      rep(j, M) {\n        mat[j][i] = tmp[i][j];\n      }\n    }\n    swap(N, M);\n  }\n\n  rep(k, M) {\n    reps(i, k, N) {\n      if (!mat[i][k]) continue;\n      rep(j, M) {\n        swap(mat[i][j], mat[k][j]);\n      }\n\n      rep(j, N) {\n        if (k == j) continue;\n        if (!mat[j][k]) continue;\n        rep(l, M) {\n          mat[j][l] += mat[k][l];\n          mat[j][l] %= 2;\n        }\n      }\n    }\n  }\n\n  int rank = 0;\n  rep(k, min(M, N)) {\n    if (mat[k][k]) rank++;\n  }\n\n  LL ans = mypow(2, N+M-1);\n  ans += MOD - mypow(2, N+M-1-rank);\n  ans %= MOD;\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Mod 998244353\n#define N 305\nusing namespace std;\nint n,m,x,ans,bin[N],vis[N];bitset<N>a[N],tmp[N];\nint main(){\n\tbin[0]=1;\n\tfor (int i=1;i<N;i++) bin[i]=1ll*bin[i-1]*2%Mod;\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\ta[i][j]=x;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tif (a[i][j]){\n\t\t\t\tif (vis[j])\n\t\t\t\t\ta[i]^=tmp[j];\n\t\t\t\telse {\n\t\t\t\t\tvis[j]=1;\n\t\t\t\t\ttmp[j]=a[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=m;i++) ans+=vis[i];\n\tint tmpp=(bin[n]-bin[n-ans]+Mod)%Mod;\n\ttmpp=1ll*tmpp*bin[m-1]%Mod;\n\tprintf(\"%d\\n\",tmpp);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=200005,INF=1<<30;\n\ntypedef vector<vector<int>> mat;\nmat Gauss(mat &A){\n    int R=A.size(),C=A[0].size();\n    int end=0;//endより上はみた(rank?)\n    \n    for(int j=0;j<C;j++){\n        for(int i=end;i<R;i++){\n            if(A[i][j]==1){\n                swap(A[end],A[i]);\n                for(int k=0;k<R;k++){\n                    if(k==end||A[k][j]==0) continue;\n                    for(int l=0;l<C;l++){\n                        A[k][l]^=A[end][l];\n                    }\n                }\n                end++;\n                break;\n            }\n        }\n    }\n    \n    return A;\n}\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M;cin>>N>>M;\n    mat A(N,vector<int>(M));\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<M;j++){\n            cin>>A[i][j];\n        }\n    }\n    \n    A=Gauss(A);\n    \n    int cnt=0;\n    for(int i=0;i<N;i++){\n        bool ok=false;\n        for(int j=0;j<M;j++){\n            if(A[i][j]) ok=true;\n        }\n        if(ok) cnt++;\n    }\n    \n    cout<<(mod+rui(2,N+M-1)-rui(2,N-1+M-cnt))%mod<<endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    bool a[n][m];\n    int r = 0;\n    for (int i = 0;i < n;++i) for (int j = 0;j < m;++j) cin >> a[i][j];\n    for (int i = 0;i < min(n,m);++i) {\n        int p = i,q = i;\n        for (int j = i;j < n;++j) {\n            if (a[p][q]) break;\n            for (int k = i;k < m;++k) if (a[j][k]) {\n                p = j;q = k;\n                break;\n            }\n        }\n        if (!a[p][q]) break;\n        r = i+1;\n        for (int j = i;j < n;++j) swap(a[j][i],a[j][q]);\n        for (int j = i;j < m;++j) swap(a[i][j],a[p][j]);\n        for (int j = i+1;j < n;++j) if (a[j][i]) for (int k = i;k < m;++k) a[j][k] ^= a[i][k];\n        for (int j = i+1;j < m;++j) if (a[i][j]) for (int k = i;k < n;++k) a[k][j] ^= a[k][i];\n    }\n    int x = 1,y = 1;\n    for (int i = 0;i < n+m-1;++i) {\n        x <<= 1;\n        x %= mod;\n    }\n    for (int i = 0;i < n+m-r-1;++i) {\n        y <<= 1;\n        y %= mod;\n    }\n    cout << (x-y+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint main(){\n\tint N,M; cin >> N >> M;\n\tconst LL mod = 998244353;\n\tvector<bitset<300>> b(N,bitset<300>(0));\n\trepp(i,0,N) repp(j,0,M){\n\t\tint a; cin >> a;\n\t\tb[i][j] = a;\n\t}\n\tint k = 0;\n\trepp(j,0,M){\n\t\tint i = k;\n\t\twhile(i < N && !b[i][j]) ++i;\n\t\tif(i == N) continue;\n\t\tswap(b[k],b[i]);\n\t\trepp(p,k+1,N) if(b[p][j]) b[p] ^= b[k];\n\t\t++k;\n\t}\n\tLL z = 1;\n\trepp(i,k,N) z = z*2%mod;\n\tLL ans = 1;\n\trepp(i,0,N) ans = ans*2%mod;\n\tans = (ans+mod-z)%mod;\n\trepp(i,1,M) ans = ans*2%mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <bitset>\n\ntypedef unsigned int ui;\nconst int MN = 2000;\nconst int Mod = 998244353;\n\nint N, M, Cnt;\nint A[MN][MN];\n\nint Sz; ui *B[MN], *tmp;\n#define set(b, i) (b[(i) >> 5] |= 1 << ((i) & 31))\n#define val(b, i) (b[(i) >> 5] >> ((i) & 31) & 1)\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tif (N > M) {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < M; ++j)\n\t\t\t\tscanf(\"%d\", &A[i][j]);\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < M; ++j)\n\t\t\t\tscanf(\"%d\", &A[j][i]);\n\t\tstd::swap(N, M);\n\t}\n\tSz = (M + 31) >> 5;\n\tfor (int j = 0; j < M; ++j) B[j] = new ui[Sz];\n\ttmp = new ui[Sz];\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) if (A[i][j]) set(tmp, j);\n\t\tfor (int j = M - 1; ~j; --j) if (val(tmp, j)) {\n\t\t\tif (val(B[j], j)) for (int k = 0; k < Sz; ++k) tmp[k] ^= B[j][k];\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < Sz; ++k) B[j][k] = tmp[k];\n\t\t\t\t++Cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlong long Ans = 0;\n\tfor (int i = 0, s = 1; i < N + M; ++i, s = (s << 1) % Mod) {\n\t\tif (i == N + M - Cnt - 1) Ans -= s;\n\t\tif (i == N + M - 1) Ans += s;\n\t}\n\tprintf(\"%lld\\n\", (Ans % Mod + Mod) % Mod);\n\tfor (int j = 0; j < M; ++j) delete [] B[j];\n\tdelete [] tmp;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T> LLI power(T n, T p, T m){if(p==0) return 1LL; if(p==1) return n; LLI k = power(n, p/2, m); return ((k*k)%m*(p%2?n:1))%m;}\n\nconst LLI mod = 998244353;\nconst double eps = 1e-9;\n\ntemplate <typename T> vector<vector<T>> transpose(vector<vector<T>> mat){\n  int n = mat.size();\n  int m = mat[0].size();\n\n  vector<vector<T>> ret(m, vector<T>(n));\n\n  REP(i,n) REP(j,m) ret[j][i] = mat[i][j];\n  \n  return ret;\n}\n\ntemplate <typename T> int rank_matrix(vector<vector<T>> mat){\n\n  int n = mat.size();\n  int m = mat[0].size();\n  int p = 0;\n\n  if(n > m){\n    auto t = transpose(mat);\n    mat.swap(t);\n    swap(n,m);\n  }\n\n  REP(i,n){\n    if(p>=m) break;    \n\n    bool b = true;\n    FOR(j,i,n) if(abs(mat[j][p]) > eps) b = false;\n\n    if(b){\n      ++p;\n      continue;\n    }\n\n    if(abs(mat[i][p]) <= eps ){\n      FOR(j,i+1,n){\n\tif(abs(mat[j][p]) > eps){\n\t  swap(mat[i], mat[j]);\n\t  break;\n\t}\n      }\n    }\n    \n    FOR(j,i+1,n){\n      double t = (double)mat[j][p] / mat[i][p];\n      REP(k,m) mat[j][k] -= mat[i][k] * t;\n    }\n  }\n\n  int r = 0;\n  REP(i,n){\n    REP(j,m){\n      if(mat[i][j] != 0){\n\t++r;\n\tbreak;\n      }\n    }\n  }\n  \n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  while(cin >> N >> M){\n    vector<vector<double>> a(N, vector<double>(M)); cin >> a;\n    int r = rank_matrix(a);\n    dump(r);\n    \n    LLI ans = (power(2LL,(LLI)(M-1),mod) * ((power(2LL,(LLI)N,mod) - power(2LL,(LLI)(N-r),mod) + mod*mod) % mod)) % mod;\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#ifdef MY_DEBUG\n#include \"header/header.hpp\"\n#else\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n#ifdef MY_DEBUG\n#include\"print.hpp\"\n#include\"debug.hpp\"\n#endif\n// }}}\n\nconst long long MOD = 998244353;\n\n//{{{ modular algebra\ntemplate<int mod=MOD>\nstruct Num{\n\tint v;\n\tNum(int n):v(n){}\n\tNum():v(0){}\n\toperator int() const {return v;}\n\toperator long long() const {return v;}\n\ttemplate<class T>\n\tNum operator =(int n){v=n;return *this;}\n\n\ttemplate<class T>\n\tinline void operator *=(const T &a) {\n\t\tv = (v*(long long)a)%mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator *(const T &a) {\n\t\tNum n(*this);n*=a;\n\t\treturn n;\n\t}\n\ttemplate<class T>\n\tinline void operator+=(const T &a){\n\t\tv+=(int)a;\n\t\tif(v>=mod)v-=mod;\n\t\t//\tassert(0<=v and v<mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator+(const T &a){\n\t\tNum n(*this);n+=a;\n\t\treturn n;\n\t}\n\tinline Num operator -(){\n\t\tif(v==0)return 0;\n\t\telse return Num(mod-v);\n\t}\n\ttemplate<class T>\n\tinline void operator -=(const T &a){\n\t\tv-=(int)a;\n\t\tif(v<0)v+=mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator -(const T &a){\n\t\tNum n(*this);n-=a;\n\t\treturn n;\n\t}\n\n#ifdef __GCD_H\n\tinline Num inv(){\n\t\treturn Num(invMod(this->v,mod));\n\t}\n\ttemplate<class T>\n\tinline void operator /=(const T &a){\n\t\t(*this)*=invMod((int)a,mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator /(const T &a){\n\t\tNum n(*this);n/=a;\n\t\treturn n;\n\t}\n#endif\n};\n\ntemplate<int mod=MOD>\nint abs(Num<mod> &a){\n\treturn a.v;\n}\ntemplate<class T, int mod>\nT& operator <<(T &os, const Num<mod> &n){\n\tos<<(int)n.v;\n\treturn os;\n}\n\ntemplate<class T, int mod>\nT& operator >>(T &is, Num<mod> &n){\n\tis>>n.v;\n\treturn is;\n}\n//}}}\ntypedef Num<MOD> mod_int;\n\n//{{{ mod_pow(Num<mod> x,Int k)\n/* (x^k)%m */\ntemplate<int mod=MOD>\ninline Num<mod> mod_pow(Num<mod> x, Int k){\n\tif(k==0) return 1;\n\tNum<mod> res(mod_pow(x,k/2));\n\tres*=res;\n\tif(k%2)res*=x;\n\treturn res;\n}\n//}}}\n\nInt N;\nInt M;\nvector<vector<Int>> a;\n\n//{{{ rix library: MATRIX<T> A(n); MATRIX<T> A(n,m); VECTOR<T> v(n);\ntemplate<class T>\nstruct VECTOR:public vector<T>{\n\tconst int &n;\n\tVECTOR(const int &n):n(n){\n\t\tthis->assign(n,0);\n\t}\n};\n\n// O( n )\ntemplate<class T>\nT inner_product(const VECTOR<T> &a, const VECTOR<T> &b) {\n\tT ans = 0;\n\tfor (int i = 0; i < a.n; ++i)\n\t\tans += a[i]*b[i];\n\treturn ans;\n}\n\ntemplate<class T>\nstruct MATRIX:vector<vector<T> > {\n\tconst int n,m;\n\tMATRIX(int n):n(n),m(n){\n\t\tthis->assign(n,vector<T>(n,0));\n\t}\n\tMATRIX(const pair<int,int> &p):n(p.first),m(p.second){\n\t\tthis->assign(n,vector<T>(m,0));\n\t}\n\t// O( n )\n\tvoid operator+=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] += B[i][j];\n\t}\n\tvoid operator-=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] -= B[i][j];\n\t}\n};\n\ntemplate<class T>\nMATRIX<T> identity(int n) {\n\tMATRIX<T> A(n);\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> zero(int n) {\n\tMATRIX<T> A(n);\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> operator+(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC+=B;\n\treturn C;\n}\ntemplate<class T>\nMATRIX<T> operator-(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC-=B;\n\treturn C;\n}\n// O( n^2 )\ntemplate<class T>\nVECTOR<T> operator*(const MATRIX<T> &A, const VECTOR<T> &x) {\n\tVECTOR<T> y(A.n);\n\tfor (int i = 0; i < A.n; ++i)\n\t\tfor (int j = 0; j < A.m; ++j)\n\t\t\ty[i] += T(A[i][j])*x[j];\n\treturn y;\n}\n// O( n^3 )\ntemplate<class T>\nMATRIX<T> operator*(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C({A.n,B.m});\n\tfor (int i = 0; i < C.n; ++i)\n\t\tfor (int j = 0; j < C.m; ++j)\n\t\t\tfor (int k = 0; k < A.m; ++k)\n\t\t\t\tC[i][j] += T(A[i][k])*B[k][j];\n\treturn C;\n}\n// O( n^3 )\ntemplate<class T>\nvoid operator*=(MATRIX<T> &A, const MATRIX<T> &B){\n\tA = A*B;\n}\n\n// O( n^3 log e )\ntemplate<class T>\nMATRIX<T> pow(const MATRIX<T> &A, long long e) {\n\treturn e == 0 ? identity<T>(A.size())  :\n\te % 2 == 0 ? pow(A*A, e/2) : A*pow(A, e-1);\n}\n\ntypedef int Number;\ntypedef MATRIX<Number> Matrix;\ntypedef VECTOR<Number> Vector;\n\n//}}}\n\n//{{{ gauss\ntemplate<class T>\nint gauss(MATRIX<T> &A, VECTOR<T> &b) {\n\t//int gauss(& A) {//returns rank\n\tconst int n = A.size(), m = A[0].size();\n\tint pi = 0;\n\tfor(int pj = 0;pj < m;pj++){\n\t\tfor(int i = pi+1; i < n; i++) {\n\t\t\tif (abs(A[i][pj]) > abs(A[pi][pj])) {\n\t\t\t\tswap(A[i], A[pi]);\n\t\t\t\tswap(b[i], b[pi]);\n\t\t\t}\n\t\t}\n\t\tif (abs(A[pi][pj]) > 0) {\n\t\t\tT d = A[pi][pj];//1/A[pi][pj]\n\t\t\tREP(j, m)A[pi][j] *= d;\n\t\t\tb[pi] *= d;\n\t\t\tREP(i,n){\n\t\t\t\tif(i==pi)continue;\n\t\t\t\tT k = A[i][pj];\n\t\t\t\tREP(j, m) A[i][j] -= k * A[pi][j];\n\t\t\t\tb[i] -= k * b[pi];\n\t\t\t}\n\t\t\tpi++;\n\t\t}\n\t}\n\treturn pi;\n\t/*\n\t   for(int i = pi; i < n; i++)\n\t   if (abs(b[i]) > 0)\n\t   throw Inconsistent();\n\t   if (pi < m || pj < m)\n\t   throw Ambiguous();\n\t   for(int j = m-1; j >= 0; j--)\n\t   REP(i, j)\n\t   b[i] = modulo(b[i] - b[j] * A[i][j]);\n\t   */\n}\n//}}}\n\nvoid solve(){\n\tMATRIX<Num<2> > a2({N,M});\n\tVECTOR<Num<2> > b(N);\n\tREP(i,N)REP(j,M)a2[i][j] = a[i][j];\n//\tint t = gauss(a2,b);\n\tint t = 0;\n\t/*\n\tREP(i,a2.size()){\n\t\tREP(j,a2[0].size()){\n\t\t\tcout<<a2[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<t<<endl;\n\t*/\n\tmod_int ans = mod_pow((mod_int)2,N) - mod_pow((mod_int)2,N-t);\n\tans *= mod_pow((mod_int)2,M-1);\n\tcout<<ans<<endl;\n}\n\n//{{{ main fucnction\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> N;\n\tcin >> M;\n\ta.assign(N, vector<Int>(M));\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < M ; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tsolve();\n\treturn 0;\n}\n\n//}}}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\n\n#define int long long\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define REPS(i, n) for (int i = 1, i##_len = (n); i <= i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i <= i##_len; ++i)\n#define REV(i, a, b) for (int i = (a); i >= (b); --i)\n#define CLR(a, b) memset((a), (b), sizeof(a))\n#define DUMP(x) cout << #x << \" = \" << (x) << endl;\n#define INF 1001001001001001001ll\n#define fcout cout << fixed << setprecision(10)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nint N, M;\nint mod = 998244353;\n\nint Gauss(Mat& A) {\n    int rank = 0;\n\n    REP(j, M) {\n        int pivot = -1;\n        FOR(i, rank, N - 1) {\n            if (A[i][j] == 1) {\n                pivot = i;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[rank], A[pivot]);\n        REP(i, N) {\n            if (i == rank) continue;\n            if (A[i][j] == 0) continue;\n            A[i][j] ^= A[rank][j];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint binpow(int x, int p) {\n    if (p == 0) return 1;\n\n    if (p % 2 == 0)\n        return binpow((x * x) % mod, p / 2);\n    else\n        return (x * binpow(x, p - 1)) % mod;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cin >> N >> M;\n\n    Mat A(N, Vec(M));\n    REP(i, N) REP(j, M) cin >> A[i][j];\n\n    int rank = Gauss(A);\n    cout << (binpow(2, N + M - 1) - binpow(2, N + M - rank - 1) + mod) % mod << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int MN = 305, P = 99824353;\n\ntypedef std::bitset<MN> bst;\n\nbst val[MN], vec[MN];\n\nint n, m;\n\ninline int fpw(int x, int k) {\n\tint res = 1;\n\tfor (; k; k >>= 1, x = (ll) x * x % P)\n\t\tif (k & 1) res = (ll) res * x % P;\n\treturn res;\n}\n\ninline int read() {\n\tint x; bool f; char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tval[i][j] = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = m; j--; )\n\t\t\tif (val[i][j]) {\n\t\t\t\tvec[j] ^= val[i];\n\t\t\t\tif (vec[j] == val[i]) {\n\t\t\t\t\tfor (int k = j; ++k < m; )\n\t\t\t\t\t\tif (vec[k][j]) vec[j] ^= vec[k];\n\t\t\t\t\tfor (int k = j; k--; )\n\t\t\t\t\t\tif (vec[k][j]) vec[k] ^= vec[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\n\tint cnt = 0;\n\tfor (int i = 0; i < m; ++i)\n\t\tif (vec[i].count()) ++cnt;\n\tprintf(\"%lld\\n\", (ll)fpw(2, n - 1) * (fpw(2, m) - fpw(2, m - cnt) + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YESNO OUT(three(solve(),\"YES\",\"NO\"))\n#define YesNo OUT(three(solve(),\"Yes\",\"No\"))\n#define WL(A,B) OUT(three(solve(),A,B))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(b);i>=(LL)(a);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n#define all ALL\n#define pb emplace_back\n#define eb pb\n#define int long long\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntemplate<class T> inline bool chmax(int a, int b, T c, T d) { return c > d ? a : b; }\ntemplate<class T> inline bool chmin(int a, int b, T c, T d) { return c > d ? a : b; }\ntypedef int LL;\ntypedef double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef tuple<int, int, int, int> tapu;\ntypedef vector<tapu> Vtapu;\ntypedef priority_queue<ut, VI, greater<LL> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 1e6 + 1000;\nconst int SIZE2 = 4010;\nconst int SIZE3 = 430;\nconst int SIZE = SIZE1;\nconst int MAPSIZE = 40;\nconst LL p =998244353;\nconst LL INF = 1LL << 30;\nconst long double EPS = 1e-7;\nconst LL inf = 1000000000;\ntypedef pair<ld, ut> pld;\nut N, M, K, L, Q,  H, W, R;\nVI edges[SIZE];\nLL vals[SIZE], answer = zero;\n//LL maps[SIZE2][SIZE2];\nLL A[SIZE3][SIZE3],B[SIZE],C[SIZE],D[SIZE],E[SIZE];\nLL def = 0;\nvoid rev(int a) {\n\tREP(i, W) {\n\t\tdef ^= A[a][i];\n\t\tA[a][i] ^= 1;\n\t}\n}\nvoid xors(int a, int b) {\n\tREP(i, W)\n\t\tA[a][i] ^= A[b][i];\n}\nvoid swaps(int a, int b) {\n\tREP(i, W)\n\t\tswap(A[a][i], A[b][i]);\n}\nLL power(LL x) {\n\tLL ans = 1;\n\tREP(i, x) ans = ans * 2 % p;\n\treturn ans;\n}\nLL solve() {\n\tcin >> H >> W;\n\tREP(i, H) REP(j, W) {\n\t\tcin >> A[i][j];\n\t}\n\tLL ans = 0,rank=0;\n\tREP(j, W) {\n\t\tFOR(i,rank,H) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tswaps(i, rank);\n\t\t\t\tFOR(k, rank + 1, H) {\n\t\t\t\t\tif (A[k][j]) xors(k, rank);\n\t\t\t\t}\n\t\t\t\trank++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (power( H + W - 1) % p - power(H+W-rank-1) % p + p) % p;\n\t//return ;\n}\n\n\n\n\n//!!!!!!!!!!!!!!!!!!!実装を詰める!!!!!!!!!!!!!!!!!!!!!!!!!\nsigned main() {\n\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(0);\n\tcout << solve() << endl;\n\t\n\t//cin >> N;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nconst ll MOD=998244353;\nll n,m,a[310][310];\n\nll ad(ll x,ll y){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll rnk(ll n,ll m,ll M[][310]){\n  ll d=0;\n  fr(j,m){\n    bool f=0;\n    if(M[d][j]==0){\n      f=1;\n      for(ll i=d;i++<n-1;){\n        if(M[i][j]!=0){swap(M[d],M[i]);f=0;}\n      }\n    }\n    if(f && j<m-1) continue;\n    if(f) return d;\n    for(ll i=d;i++<n-1;){\n      if(M[i][j]==0) continue;\n      for(ll k=j;k<m;k++){\n        M[i][k]=(M[i][k]+M[d][k])%2;\n      }\n    }\n    d++;\n    if(d==n) return n;\n  }\n  return m;\n}\n\nint main(){\n  cin>>n>>m;\n  fr(i,n) fr(j,m) cin>>a[i][j];\n  cout<<ad(pwr(2,n+m-1),MOD-pwr(2,n+m-1-rnk(n,m,a)))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#include <random>\n#include <iomanip>\n#include <bitset>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 998244353;\nconstexpr long double eps = 1e-6;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << v[i];\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 1010101\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n \nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nusing ld = long double;\n\nint mat_rank(vector<vector<int>>& a) {\n    int n = (int)a.size(), m = (int)a[0].size();\n    int ret = 0;\n    REP(j, m) {\n        REP(i, n) {\n            if(a[i][j]) {\n                ret++;\n                REP(k, n) {\n                    if(i == k) continue;\n                    if(a[k][j] == 0) continue;\n                    REP(l, m) a[k][l] ^= a[i][l];\n                }\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> a(n, vector<int>(m));\n    REP(i, n) REP(j, m) cin >> a[i][j];\n    int r = mat_rank(a);\n    mi ans = (mod_pow(2, m) - mod_pow(2, m - r)) * mod_pow(2, n - 1);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 310, P = 998244353;\nint n, m, a[maxn][maxn], b[maxn][maxn];\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1)\n            z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = m; j; j--)\n            if (a[i][j]) {\n                if (b[j][j]) {\n                    for (int k = 1; k <= m; k++) {\n                        a[i][k] ^= b[j][k];\n                    }\n                } else {\n                    for (int k = 1; k <= m; k++) {\n                        b[j][k] = a[i][k];\n                    }\n                    break;\n                }\n            }\n    }\n    int cnt = 0;\n    for (int i = 1; i <= m; i++) {\n        if (b[i][i])\n            cnt++;\n    }\n    int ans = qp(2, n + m) - qp(2, n + m - cnt) + P;\n    printf(\"%lld\\n\", 1LL * ans * qp(2, P - 2) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\n\n\nll N,M;\nll a[333][333];\nll dp1[333][333][2],dp2[333][333][2],dp3[333][333][2];\nll i,j,k,l,ans;\ninline void addd(ll aa,ll bb){\n    if(aa==bb)\n        return;\n    ll i;\n    fornum(i,0,M){\n        a[aa][i] = (a[aa][i] + a[bb][i]) % 2;\n    }\n}\nint main(){\n    scanf(\"%lld%lld\", &N, &M);\n    fornum(i,0,N){\n        fornum(j,0,M){\n            scanf(\"%lld\", &a[i][j]);\n        }\n    }\n    k = 0;\n    fornum(i,0,M){\n        fornum(j,k,N){\n            if(a[j][i]){\n                addd(k, j);\n                break;\n            }\n        }\n        //printf(\"%lld,%lld,%lld\\n\", i, j, k);\n        if(j==N)\n            continue;\n        fornum(j,k+1,N){\n            if(a[j][i]){\n                addd(j, k);\n            }\n        }\n        k++;\n        \n    }\n    j = 1;\n    fornum(i,1,N+M-k){\n        j = (j * 2) % MOD;\n    }\n    //printf(\"%lld\\n\", j);\n    ans = 1;\n    fornum(i,1,N+M){\n        ans = (ans * 2) % MOD;\n    }\n    //printf(\"%lld\\n\", ans);\n    ans = (ans + MOD - j) % MOD;\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\n\nvoid norm(VV<int>& a) {\n\tint n = a.size(), m = a[0].size();\n\tint pre = 0;\n\tREP(j, m) {\n\t\tint pivot = -1;\n\t\tFOR(i, pre, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tpivot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) continue;\n\t\tstd::swap(a[pre], a[pivot]);\n\n\t\tREP(i, n) if (i != pre) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tREP(k, m) {\n\t\t\t\t\ta[i][k] ^= a[pre][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++pre;\n\t}\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tMAT(int, a, n, m);\n\n\tnorm(a);\n\n\tint one = 0;\n\tREP(i, n) {\n\t\tbool f = false;\n\t\tREP(j, m) if (a[i][j]) f = true;\n\t\tif (f) ++one;\n\t}\n\n\tint ans = powMod(2, n, MOD) - powMod(2, n - one, MOD);\n\t(ans *= powMod(2, m - 1, MOD)) %= MOD;\n\tif (ans < 0) ans += MOD;\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    int a[n][m];\n    int r = 0;\n    for (int i = 0;i < n;++i) for (int j = 0;j < m;++j) cin >> a[i][j];\n    for (int i = 0;i < n;++i) {\n        int p = i,q = i;\n        for (int j = i;j < n;++j) {\n            if (a[p][q]) break;\n            for (int k = i;k < m;++k) if (a[j][k]) {\n                p = j;q = k;\n                break;\n            }\n        }\n        if (!a[p][q]) break;\n        r = i+1;\n        for (int j = i;j < n;++j) swap(a[j][i],a[j][q]);\n        for (int j = i;j < m;++j) swap(a[i][j],a[p][j]);\n        for (int j = 0;j < n;++j) if (i != j && a[j][i]) for (int k = i;k < m;++k) a[j][k] ^= a[i][k];\n        for (int j = 0;j < m;++j) if (i != j && a[i][j]) for (int k = i;k < n;++k) a[k][j] ^= a[k][i];\n    }\n    int x = 1,y = 1;\n    for (int i = 0;i < n+m-1;++i) {\n        x <<= 1;\n        x %= mod;\n    }\n    for (int i = 0;i < n+m-r-1;++i) {\n        y <<= 1;\n        y %= mod;\n    }\n    cout << (x-y+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <tuple>\ntemplate <typename T> constexpr T my_abs(const T &x) { return x < 0 ? -x : x; }\nusing ll = long long;\nconstexpr int MOD = 998244353;\ninline int quick_pow(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (ll)res * a % MOD;\n\t\ta = (ll)a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint fact[305], inv[305], arr[305][305], dp[305];\ninline int C(int n, int m) { return (ll)fact[n] * inv[m] % MOD * inv[n - m] % MOD; }\nint main()\n{\n\t// freopen(\"yahoo2019-E.in\", \"r\", stdin);\n\t// freopen(\"yahoo2019-E.out\", \"wt\", stdout);\n\tint n, m, k = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tscanf(\"%d\", arr[i] + j);\n\t}\n\tfact[0] = inv[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD;\n\t\tinv[i] = quick_pow(fact[i], MOD - 2);\n\t}\n\tfor (int col = 0; col < m; col++)\n\t{\n\t\tint row = k;\n\t\twhile (row < n && !arr[row][col])\n\t\t\trow++;\n\t\tif (row >= n)\n\t\t\tcontinue;\n\t\tstd::swap(arr[row], arr[k]);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (!arr[i][col] || i == k)\n\t\t\t\tcontinue;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tarr[i][j] ^= arr[k][j];\n\t\t}\n\t\tk++;\n\t}\n\tint ans = (ll)quick_pow(2, m - 1) * quick_pow(2, n) % MOD;\n\tans = (ans - (ll)quick_pow(2, n - k) * quick_pow(2, m - 1)) % MOD;\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nint n,m,a[310][310];\nint od[310],ev[310],bit[310];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n/*\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n*/\n/*\tfor(int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tprintf(\"%d \",a[i][j]);\n*/\n\n\tint u=max(n,m);\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i]) continue;\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=m;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=u;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 998244353;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % md);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nconst int N = 330;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n\n  vector<int> fac(N), finv(N);\n  fac[0] = finv[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fac[i] = mul(fac[i - 1], i);\n    finv[i] = inv(fac[i]);\n  }\n\n  auto comb = [&](int n, int m) {\n    assert(n >= m);\n    int res = fac[n];\n    res = mul(res, finv[m]);\n    res = mul(res, finv[n - m]);\n    return res;\n  };\n\n  int n, m;\n  cin >> n >> m;\n  vector< vector<int> > a(n, vector<int>(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> a[i][j];\n    }\n  }\n\n  auto lowbit = [](vector<int> a) {\n    for (int i = 0; i < (int) a.size(); i++) {\n      if (a[i] == 1) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  auto Xor = [&](int i, int j) {\n    for (int k = 0; k < m; k++) {\n      a[i][k] ^= a[j][k];\n    }\n  };\n\n  vector<int> base;\n  for (int i = 0; i < n; i++) {\n    for (auto j : base) {\n      if (a[i][ lowbit(a[j]) ] == 1) {\n        Xor(i, j);\n      }\n    }\n    if (lowbit(a[i]) != -1) {\n      base.push_back(i);\n    }\n  }\n\n  int r = base.size();\n  // cerr << r << '\\n';\n  int res = 0;\n  for (int i = 1; i <= r; i += 2) {\n    add(res, mul(comb(r, i), power(3, r - i)));\n  }\n  res = mul(res, power(2, (n - r) + (m - r)));\n  cout << res << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 300;\nconst int MOD = 998244353;\nbitset<N> a[N]; \nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile(k) {\n\t\tif(k&1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD; \n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t) a[i].set(j);\n\t\t}\n\t}\n \tfor (int i = 0; i < n; i++) {\n \t\tfor (auto b : base) {\n \t\t\tauto bb = b^a[i];\n \t\t\tfor (int j = m-1; j >= 0; j--) {\n \t\t\t\tif(bb[j] < a[i][j]) {\n \t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t }\n\t\t\t}\n\t\t }\t\n\t\t if(a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", (q_pow(2, n+m-1) - q_pow(2, n+m-1-cnt) + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n\nconst int ms = 303;\nconst int MOD = 998244353;\n\nstd::bitset<ms> mat[ms];\n\nstruct Gauss {\n\tGauss() {\n\t\trank = 0;\n\t\tfor(int i = 0; i < ms; i++) {\n\t\t\teq[i].reset();\n\t\t}\n\t}\n\tint rank;\n\tstd::bitset<ms> eq[ms];\n\n\tint add(std::bitset<ms> a) {\n\t\tfor(int i = 0; i < ms; i++) {\n\t\t\tif(!eq[i][i] && !a[i]) continue;\n\t\t\tif(eq[i][i]) {\n\t\t\t\tif(a[i]) {\n\t\t\t\t\ta ^= eq[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teq[i] = a;\n\t\t\t\trank++;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstd::bitset<ms> reduce(std::bitset<ms> a) {\n\t\tfor(int i = 0; i < ms; i++) {\n\t\t\tif(eq[i][i] && a[i]) {\n\t\t\t\ta ^= eq[i];\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n};\n\nlong long pot[ms + ms];\n\nint main() {\n\tpot[0] = 1;\n\tfor(int i = 1; i < ms + ms; i++) {\n\t\tpot[i] = pot[i-1] * 2 % MOD;\n\t}\n\tint n, m;\n\tstd::cin >> n >> m;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tint v;\n\t\t\tstd::cin >> v;\n\t\t\tif(v) {\n\t\t\t\tmat[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\t// count isolated\n\tfor(int i = 0; i < n; i++) {\n\t\tlong long cur = 0;\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tif(mat[i][j]) cur = 1;\n\t\t}\n\t\tcur = cur * pot[m-1+n-1] % MOD;\n\t\tans = (ans + cur) % MOD;\n\t}\n\t// uncount with previous\n\tGauss tot;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(i) {\n\t\t\tmat[i-1][m] = 0;\n\t\t\ttot.add(mat[i-1]);\n\t\t}\n\t\tmat[i][m] = 1;\n\t\tint id = tot.add(mat[i]);\n\t\tif(id == m) {\n\t\t\ttot.eq[id].reset();\n\t\t\ttot.rank--;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tmat[j][m] = 1;\n\t\t\tauto b = tot.reduce(mat[j]);\n\t\t\tif(b[m] && b.count() == 1) {\n\t\t\t\t// contradiction\n\t\t\t} else {\n\t\t\t\tint rank = tot.rank;\n\t\t\t\tif(b.count()) rank++;\n\t\t\t\t//std::cout << \"on pair \" << i << \", \" << j << \" got rank \" << rank << \"\\n\";\n\t\t\t\tans = (ans - pot[n-1+m-rank] + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tstd::cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 310, P = 998244353;\nint n, m, c, a[maxn][maxn], b[maxn][maxn];\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1) z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = m; j; j--) if (a[i][j]) {\n            if (b[j][j]) {\n                for (int k = 1; k <= m; k++) {\n                    a[i][k] ^= b[j][k];\n                }\n            } else {\n                for (int k = 1; k <= m; k++) {\n                    b[j][k] = a[i][k];\n                }\n                break;\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        if (b[i][i]) c++;\n    }\n    int ans = qp(2, n + m) - qp(2, n + m - c) + P;\n    printf(\"%lld\\n\", 1LL * ans * qp(2, P - 2) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#include<bitset>\n\n#define N 305\n#define M 8000005\n\n#define ls (t<<1)\n#define rs ((t<<1)|1)\n#define mid ((l+r)>>1)\n\n#define mk make_pair\n#define pb push_back\n#define fi first\n#define se second\n\n#define Mo 998244353\n\nusing namespace std;\n\nbitset<305>A[305];\n\nint a[N][N],n,m,i,j;\n\nint power(int x,int y)\n{\n\t\tint s=1;\n\t\tfor(;y;y>>=1)\n\t\t{\n\t\t\t\tif(y&1) s=1ll*s*x%Mo;\n\t\t\t\tx=1ll*x*x%Mo; \n\t\t}\n\t\treturn s;\n}\n\nint Guass()\n{\n\t\tint i,j,k,cnt=0;\n\t\tfor (i=1;i<=n;++i)\n\t\t{\n\t\t\t\tfor (j=cnt+1;j<=m;++j) if (A[j][i]) break;\n\t\t\t\tif (j>m) continue;\n\t\t\t\t++cnt;\n\t\t\t\tswap(A[cnt],A[j]);\n\t\t\t\tfor (j=cnt+1;j<=m;++j)\n\t\t\t\t\tif (A[j][i]) A[j]^=A[cnt]; \n\t\t}\n\t\treturn power(2,n-cnt);\n}\n\nint main()\n{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor (i=1;i<=n;++i) \n\t\t\tfor (j=1;j<=m;++j) scanf(\"%d\",&a[i][j]);\n\t\tfor (i=1;i<=m;++i)\n\t\t\tfor (j=1;j<=n;++j) A[i][j]=a[j][i];\n\t\tprintf(\"%d\\n\",1ll*(power(2,n)-Guass()+Mo)%Mo*power(2,m-1)%Mo); \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Int = int;\n\ntemplate<Int MOD>\nstruct ModInt {\n    constexpr static Int mod = MOD;\n    Int v;\n\n    ModInt(long long _v = 0) : v(set(_v)) {}\n    ModInt(const ModInt &r) : v(set(r.v)) {}\n\n    inline static Int set(const Int x) { return x < 0 ? (x % mod) + mod : x % mod; }\n    inline void set() { v = set(v); }\n\n    bool operator<(ModInt r) const { return v < r.v; }\n    bool operator>(ModInt r) const { return r.v < v; }\n    bool operator==(ModInt r) const { return v == r.v; }\n    bool operator!= (ModInt r) const { return v != r.v; }\n\n    ModInt operator-() const { return ModInt(v ? mod - v : v); }\n    ModInt &operator=(const ModInt &r) { if (this != &r) v = set(r.v); return *this; }\n    ModInt &operator+=(ModInt r) { (v += r.v) %= mod; return *this; }\n    ModInt &operator-=(ModInt r) { (v -= r.v - mod) %= mod; return *this; }\n    // ModInt &operator*=(ModInt r) { v = (__uint128_t(v) * r.v) % mod; return *this; }\n    ModInt &operator*=(ModInt r) { v = 1ULL * v * r.v % mod; return *this; }\n    ModInt &operator/=(ModInt r) { *this *= r.inv(); return *this; }\n    ModInt operator+(ModInt r) const { return ModInt(*this) += r; }\n    ModInt operator-(ModInt r) const { return ModInt(*this) -= r; }\n    ModInt operator*(ModInt r) const { return ModInt(*this) *= r; }\n    ModInt operator/(ModInt r) const { return ModInt(*this) /= r; }\n\n    ModInt inv() const {\n        long long a = v, b = mod, u = 1, w = 0;\n        while (b) {\n            long long t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * w, w);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(Int e) {\n        ModInt a = *this, x(1);\n        for ( ; 0 < e; e >>= 1) { if (e & 1) x *= a; a *= a; }\n        return x;\n    }\n    inline ModInt pow(ModInt &e) { return pow(e.v); }\n};\n\nstd::ostream &operator<<(std::ostream &os, const auto &r) { return os << r.v; }\nstd::istream &operator>>(std::istream &is, auto &r) { is >> r.v; r.set();return is; }\n\nusing Mod2 = ModInt<2>;\nusing Type = ModInt<998244353>;\nusing Vector = vector<Mod2>;\nusing Matrix = vector<Vector>;\n\nint Rank(Matrix &A) {\n    const int N = A.size(), M = A[0].size();\n    int rank = 0;\n    vector<bool> used(N, false);\n\n    for (int c = 0; c < M; ++c) {\n        int pivot = 0;\n        while (pivot < N && (used[pivot] || A[pivot][c] == 0)) ++pivot;\n        if (pivot == N) continue;\n\n        ++rank;\n        Mod2 v = A[pivot][c];\n        for (int j = 0; j < N; ++j) A[pivot][j] /= v;\n        for (int r = 0; r < N; ++r) {\n            if (r == pivot) continue;\n            for (int j = c + 1; j < M; ++j)\n                A[r][j] -= A[r][c] * A[pivot][j];\n        }\n    }\n\n    return rank;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    Matrix A(n, Vector(m));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            cin >> A[i][j];\n\n    int rank = Rank(A);\n    Type res = Type(2).pow(m + n - 1) - Type(2).pow(m + n - rank - 1);\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 305, MOD = 1e9 + 7;\nbitset<N> b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int x;\n            cin >> x;\n            b[i][j] = x;\n        }\n    }\n\n    ll bad = 1;\n\n    for (int i = 0, j = 0; i < m; i++) {\n        int sel = -1;\n        for (int k = j; k < n; k++) {\n            if (b[k][i]) {\n                sel = k;\n                break;\n            }\n        }\n        if (sel == -1) {\n            bad = bad * 2 % MOD;\n        }\n        else {\n            swap(b[sel], b[j]);\n            for (int k = 0; k < n; k++) {\n                if (j != sel) {\n                    if (b[k][i]) {\n                        b[k] ^= b[j];\n                    }\n                }\n            }\n            j++;\n        }\n    }\n\n    ll ans = 1;\n    for (int i = 0; i < m; i++) {\n        ans = ans * 2 % MOD;\n    }\n\n    ans = (ans - bad + MOD) % MOD;\n\n    for (int i = 0; i < n - 1; i++) {\n        ans = ans * 2 % MOD;\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 998244353;\nconst int MOD = 1e9 + 7;\n\nint n, m;\nvector<int> a[500];\nvector<int> st[500];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            int x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n    int sz = 0;\n    for (int i = 0; i < n; i++)\n    {\n        int t = -1;\n        for (int j = 0; j < m; j++)\n        {\n            if (a[i][j] && st[j].size() == 0)\n            {\n                t = j;\n                break;\n            }\n            else\n            {\n                if (a[i][j])\n                {\n                    for (int k = 0; k < m; k++)\n                    {\n                        a[i][j] = a[i][j] ^ st[j][k];\n                    }\n                }\n            }\n        }\n        if (t > -1)\n        {\n            st[t] = a[i];\n            sz++;\n        }\n    }\n    cout << inq(2, m - 1) * (inq(2, n) - inq(2, n - sz) + MOD) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t r = 0;\n    for (std::size_t c = 0; c < mat.C; c++) {\n        if (r == mat.R) { return r; }\n        std::size_t piv = r;\n        for (; piv < mat.R and mat[piv][c] == 0; piv++) {}\n        if (piv == mat.R) { continue; }\n        std::swap(mat[piv], mat[r]);\n        for (std::size_t j = c + 1; j < mat.C; j++) { mat[r][j] /= mat[r][c]; }\n        for (std::size_t j = r + 1; j < mat.R; j++) {\n            for (std::size_t k = c + 1; k < mat.C; k++) { mat[j][k] -= mat[r][k] * mat[j][c]; }\n        }\n        r++;\n    }\n    return r;\n}\nusing ll = long long;\ntemplate <typename T, T mod>\nclass ModInt\n{\nprivate:\n    T value;\n    static T pow(const T p, const T n) { return p < 0 ? pow(mod + p, n) : n == 0 ? 1 : n % 2 == 1 ? pow(p, n - 1) * p % mod : pow(p * p % mod, n / 2); }\n    static T inv(const T p) { return pow(p, mod - 2); }\n\npublic:\n    ModInt() : value{0} {}\n    ModInt(const T val) : value{((val % mod) + mod) % mod} {}\n    ModInt(const ModInt<T, mod>& n) : value{n()} {}\n    ModInt<T, mod>& operator=(const ModInt<T, mod>& n) { return value = n(), (*this); }\n    ModInt<T, mod>& operator=(const T v) { return value = (mod + v % mod) % mod, (*this); }\n    ModInt<T, mod> operator+() const { return *this; }\n    ModInt<T, mod> operator-() const { return ModInt{mod - value}; }\n    ModInt<T, mod> operator+(const ModInt<T, mod>& val) const { return ModInt{value + val()}; }\n    ModInt<T, mod> operator-(const ModInt<T, mod>& val) const { return ModInt{value - val() + mod}; }\n    ModInt<T, mod> operator*(const ModInt<T, mod>& val) const { return ModInt{value * val()}; }\n    ModInt<T, mod> operator/(const ModInt<T, mod>& val) const { return ModInt{value * inv(val())}; }\n    ModInt<T, mod>& operator+=(const ModInt<T, mod>& val) { return (((value += val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const ModInt<T, mod>& val) { return (((value -= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const ModInt<T, mod>& val) { return (((value *= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const ModInt<T, mod>& val) { return (((value *= inv(val())) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod> operator+(const T val) const { return ModInt{value + val}; }\n    ModInt<T, mod> operator-(const T val) const { return ModInt{value - val}; }\n    ModInt<T, mod> operator*(const T val) const { return ModInt{value * val}; }\n    ModInt<T, mod> operator/(const T val) const { return ModInt{value * inv(val)}; }\n    ModInt<T, mod>& operator+=(const T val) { return (((value += val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const T val) { return (((value -= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const T val) { return (((value *= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const T val) { return (((value *= inv(val)) %= mod) += mod) %= mod, (*this); }\n    bool operator==(const ModInt<T, mod>& val) const { return value == val.value; }\n    bool operator!=(const ModInt<T, mod>& val) const { return not(*this == val); }\n    bool operator==(const T val) const { return value == (mod + val % mod) % mod; }\n    bool operator!=(const T val) const { return not(*this == val); }\n    T operator()() const { return value; }\n};\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator+(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator-(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{-n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator*(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() * val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator/(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>(val) / n; }\ntemplate <typename T, T mod>\ninline bool operator==(const T val, const ModInt<T, mod>& n) { return n == val; }\ntemplate <typename T, T mod>\ninline bool operator!=(const T val, const ModInt<T, mod>& n) { return not(val == n); }\ntemplate <typename T, T mod>\ninline std::istream& operator>>(std::istream& is, ModInt<T, mod>& n)\n{\n    T v;\n    return is >> v, n = v, is;\n}\ntemplate <typename T, T mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<T, mod>& n) { return (os << n()); }\ntemplate<int mod>\nusing mint = ModInt<int,mod>;\ntemplate <ll mod>\nusing mll = ModInt<ll, mod>;\nconstexpr int MOD = 998244353;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<mint<2>> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<mint<MOD>> bp(600, 1);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2; }\n    std::cout << bp[N + M - 1] - bp[N + M - R - 1] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YESNO OUT(three(solve(),\"YES\",\"NO\"))\n#define YesNo OUT(three(solve(),\"Yes\",\"No\"))\n#define WL(A,B) OUT(three(solve(),A,B))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(b);i>=(LL)(a);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n#define all ALL\n#define pb emplace_back\n#define eb pb\n#define int long long\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntemplate<class T> inline bool chmax(int a, int b, T c, T d) { return c > d ? a : b; }\ntemplate<class T> inline bool chmin(int a, int b, T c, T d) { return c > d ? a : b; }\ntypedef int LL;\ntypedef double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef tuple<int, int, int, int> tapu;\ntypedef vector<tapu> Vtapu;\ntypedef priority_queue<ut, VI, greater<LL> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 1e6 + 1000;\nconst int SIZE2 = 4010;\nconst int SIZE3 = 430;\nconst int SIZE = SIZE1;\nconst int MAPSIZE = 40;\nconst LL p =998244353;\nconst LL INF = 1LL << 30;\nconst long double EPS = 1e-7;\nconst LL inf = 1000000000;\ntypedef pair<ld, ut> pld;\nut N, M, K, L, Q,  H, W, R;\nVI edges[SIZE];\nLL vals[SIZE], answer = zero;\n//LL maps[SIZE2][SIZE2];\nLL A[SIZE3][SIZE3],B[SIZE],C[SIZE],D[SIZE],E[SIZE];\nLL def = 0;\nvoid rev(int a) {\n\tREP(i, W) {\n\t\tdef ^= A[a][i];\n\t\tA[a][i] ^= 1;\n\t}\n}\nvoid xors(int a, int b) {\n\tREP(i, W)\n\t\tA[a][i] ^= A[b][i];\n}\nvoid swaps(int a, int b) {\n\tREP(i, W)\n\t\tswap(A[a][i], A[b][i]);\n}\nLL power(LL x) {\n\tLL ans = 1;\n\tREP(i, x) ans = ans * 2 % p;\n\treturn ans;\n}\nLL solve() {\n\tcin >> H >> W;\n\tREP(i, H) REP(j, W) {\n\t\tcin >> A[i][j];\n\t}\n\tLL ans = 0,rank=0;\n\tREP(j, W) {\n\t\tFOR(i,rank,H) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tswaps(i, rank);\n\t\t\t\tFOR(k, rank + 1, H) {\n\t\t\t\t\tif (A[k][j]) xors(k, j);\n\t\t\t\t}\n\t\t\t\trank++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (power( H + W - 1) % p - power(H+W-rank-1) % p + p) % p;\n\t//return ;\n}\n\n\n\n\n//!!!!!!!!!!!!!!!!!!!実装を詰める!!!!!!!!!!!!!!!!!!!!!!!!!\nsigned main() {\n\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(0);\n\tcout << solve() << endl;\n\t\n\t//cin >> N;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define fs first\n#define se second\n\nusing namespace std;\ntypedef long long llong;\ntypedef pair<int, int> pii;\n\nconst int mod = 998244353;\n\nint n, m;\nint A[301][301];\nint nCr[301][301];\nint p2[601];\nint p3[301];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    nCr[0][0] = p2[0] = p3[0] = 1;\n    for (int i = 1; i <= 300; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            if (j > 0) nCr[i][j] += nCr[i - 1][j - 1];\n            if (j < i) nCr[i][j] += nCr[i - 1][j];\n            nCr[i][j] %= mod;\n        }\n    }\n    for (int i = 1; i <= 600; ++i) p2[i] = p2[i - 1] * 2ll % mod;\n    for (int i = 1; i <= 300; ++i) p3[i] = p3[i - 1] * 3ll % mod;\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            cin >> A[i][j];\n        }\n    }\n    int R = n;\n    for (int i = 1; i <= n; ++i) {\n        int mnv = m + 1, mni;\n        for (int j = i; j <= n; ++j) {\n            for (int k = 1; k < mnv; ++k) {\n                if (A[j][k]) {\n                    mnv = k;\n                    mni = j;\n                    break;\n                }\n            }\n        }\n        if (mnv > m) {\n            R = i - 1;\n            break;\n        }\n        for (int j = 1; j <= m; ++j) {\n            swap(A[i][j], A[mnv][j]);\n        }\n        for (int j = i + 1; j <= n; ++j) {\n            if (A[j][mnv] == 0) continue;\n            for (int k = 1; k <= m; ++k) {\n                A[j][k] ^= A[i][k];\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= R; i += 2) {\n        int v = 1;\n        ans += (llong)nCr[R][i] * p2[m + n - R - R] % mod * p3[R - i] % mod;\n        ans %= mod;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mod 998244353\n\nint main()\n{\n\tint n,m;\n\tcin >> n >> m;\n\tint a[n][m];\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor(int t = 0; t < (1 << n); t++){\n\t\tfor(int s = 0; s < (1 << m); s++){\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tif(((t >> i) & 1) & ((s >> j) & 1)){\n\t\t\t\t\t\tsum += a[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum % 2 == 1)\n\t\t\t\tans = (ans + 1) % mod;\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG  // gcc\n    #define _LIBCPP_DEBUG 0 // clang\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define _GLIBCXX_DEBUG\n    // #define _LIBCPP_DEBUG 0\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check() { char bufc; if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"\\n----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\npublic:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(), last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n/* dump definition start */\n#ifdef LOCAL\n    #define dump(...) debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\", dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\n/* dump definition end */\n\n/* function utility start */\ntemplate <class T, class... types> T read(types... args) noexcept { T obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = pair<i32, i32>; using pll = pair<i64, i64>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using rheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\n/* using alias end */\n\n/* library start */\n\n#ifndef Modint_hpp\n#define Modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    static constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    constexpr modint(bool x = false) noexcept : val{x} {}\n    constexpr modint(int x) noexcept : val(x & 1) {}\n    constexpr modint(long long x) noexcept : val(x & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val &= other.val, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { assert(other.val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator-(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator*(const modint &other) const noexcept { return val && other.val; }\n    constexpr modint operator/(const modint &other) const noexcept { assert(other.val); return *this; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { assert(y.val); return x & 1 ? y : modint<2>{0}; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // Modint_hpp\n#ifndef Matrix_hpp\n#define Matrix_hpp\n#include <iostream>\n#include <valarray>\n#include <vector>\n\ntemplate <class Field>\nclass matrix\n{\n    size_t h, w;\n    using row_type = std::valarray<Field>;\n    using data_type = std::valarray<std::valarray<Field>>;\n    data_type data;\n\n    friend std::istream &operator>>(std::istream &is, matrix &x)\n    {\n        for(size_t i = 0; i != x.h; ++i)\n        {\n            for(size_t j = 0; j != x.w; ++j) is >> x.data[i][j];\n        }\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const matrix &x)\n    {\n        for(size_t i = 0; i != x.h; ++i)\n        {\n            if(i) os << \"\\n\";\n            for(size_t j = 0; j != x.w; ++j) os << (j ? \" \" : \"\") << x.data[i][j];\n        }\n        return os;\n    }\n\n    friend matrix transpose(const matrix &x)\n    {\n        matrix res(x.w, x.h);\n        for(size_t i = 0; i != x.w; ++i)\n            for(size_t j = 0; j != x.h; ++j)\n                res[i][j] = x.data[j][i];\n        return res;\n    }\n\n    friend matrix pow(matrix x, long long n)\n    {\n        assert(x.is_square());\n        if(n < 0) x = inverse(x), n = -n;\n        matrix res{identity(x.h)};\n        while(n)\n        {\n            if(n & 1) res *= x;\n            x *= x, n >>= 1;\n        }\n        return res;\n    }\n\n    friend matrix inverse(const matrix &x)\n    {\n        assert(x.is_square());\n        matrix ext_x(x.h, x.h * 2), res(x.h);\n        for(size_t i = 0; i != x.h; ++i) ext_x.data[i][std::slice(0, x.h, 1)] = x.data[i], ext_x.data[i][i + x.h] = 1;\n        if(ext_x.row_canonicalize().size() != x.h) return matrix{0};\n        for(size_t i = 0; i != x.h; ++i) res[i] = ext_x.data[i][std::slice(x.h, x.h, 1)];\n        return res;\n    }\n\npublic:\n    explicit matrix(size_t _n = 0) : h(_n), w(_n) { resize(_n, _n);}\n    matrix(size_t _h, size_t _w) : h(_h), w(_w) { resize(_h, _w); }\n    matrix(const data_type &_data) : h(_data.size()), w(_data.size() ? _data[0].size() : 0), data(_data) {}\n    operator data_type() const { return data; }\n\n    size_t height() const noexcept { return h; }\n    size_t width() const noexcept { return w; }\n    bool is_square() const noexcept { return h == w; }\n    row_type &operator[](const size_t i) noexcept { assert(i < data.size()); return data[i]; }\n    void resize(size_t h, size_t w, const Field val = Field(0)) { data.resize(h, std::valarray<Field>(val, w)); }\n\n    static matrix identity(const size_t n) noexcept\n    {\n        data_type data(row_type(n), n);\n        for(size_t i = 0; i != n; ++i) data[i][i] = 1;\n        return data;\n    }\n\n    matrix operator-() const noexcept { return {-data}; }\n    matrix &operator+=(const matrix &other) noexcept { data += other.data; return *this; }\n    matrix &operator-=(const matrix &other) { data -= other.data; return *this; }\n    matrix &operator*=(matrix other) noexcept\n    {\n        other = transpose(other);\n        for(size_t i = 0; i != h; ++i)\n        {\n            const row_type copied{data[i]};\n            for(size_t j = 0; j != other.h; ++j) data[i][j] = (copied * other.data[j]).sum();\n        }\n        return *this;\n    }\n    matrix operator+(const matrix &x) const noexcept { return matrix(*this) += x; }\n    matrix operator-(const matrix &x) const noexcept { return matrix(*this) -= x; }\n    matrix operator*(const matrix &x) const noexcept { return matrix(*this) *= x; }\n\n    // return the list of pivot columns\n    std::vector<size_t> row_canonicalize()\n    {\n        std::vector<size_t> pivots;\n        for(size_t j = 0, rank = 0; j != w; ++j)\n        {\n            bool piv = false;\n            row_type *row_ptr = nullptr;\n            for(size_t i = rank; i != h; ++i)\n            {\n                if(data[i][j] != Field{0})\n                {\n                    const Field f = data[i][j];\n                    if(piv) data[i][std::slice(j, w - j, 1)] -= *row_ptr * f;\n                    else\n                    {\n                        swap(data[rank], data[i]);\n                        std::slice_array<Field> tmp{data[rank][std::slice(j, w - j, 1)]};\n                        tmp = *(row_ptr = new row_type{tmp}) /= f;\n                    }\n                }\n            }\n            if(row_ptr)\n            {\n                for(size_t k = 0; k != rank; ++k)\n                {\n                    const Field f = data[k][j];\n                    data[k][std::slice(j, w - j, 1)] -= *row_ptr * f;\n                }\n                ++rank;\n                pivots.emplace_back(j);\n                delete row_ptr;\n            }\n        }\n        return pivots;\n    }\n\n    Field determinant() const\n    {\n        assert(is_square());\n        data_type copied{data};\n        Field res{1};\n        for(size_t j = 0; j != w; ++j)\n        {\n            bool piv = false;\n            for(size_t i = j; i != h; ++i)\n            {\n                if(copied[i][j] != Field{0})\n                {\n                    const Field coef = copied[i][j];\n                    if(piv) copied[i] -= copied[j] * coef;\n                    else\n                    {\n                        swap(copied[i], copied[j]);\n                        if(i != j) res = -res;\n                        res *= coef;\n                        copied[j] /= coef;\n                        piv = true;\n                    }\n                }\n            }\n            if(!piv) return 0;\n        }\n        return res;\n    }\n};\n#endif\n\n/* library end */\n\n/* The main code follows. */\n\nusing mint=modint<998244353>;\n\nstruct solver\n{\n    solver()\n    {\n        input(int,h);\n        input(int,w);\n        input(matrix<modint<2>>,a,h,w);\n        int rank=a.row_canonicalize().size();\n        int kdim=w-rank;\n        cout << mint::pow(2,h)*(mint::pow(2,w-1)-mint::pow(2,kdim-1)) << \"\\n\";\n    }\n\n    void test()\n    {\n        matrix<int> a({{1,0},{0,-1}});\n        cout << a << \"\\n\";\n        a*=a;\n        cout << a << \"\\n\";\n        return;\n    }\n}; // struct solver\n\nint main(int argc, char *argv[])\n{\n    u32 t; // loop count\n#ifdef LOCAL\n    t = 1;\n#else\n    t = 1; // single test case\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--)\n    {\n        solver();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(0);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\ntemplate <int mod>\nclass ModInt {\npublic:\n    ModInt() : v(0) {}\n    ModInt(int x) : v((x+mod)%mod) {}\n    int value() const {return v;}\n    const ModInt operator+(const ModInt &r) const { return ModInt(this->v + r.v); }\n    const ModInt operator-(const ModInt &r) const { return ModInt(this->v + mod - r.v); }\n    const ModInt operator*(const ModInt &r) const { return ModInt(this->v * r.v); }\n    const ModInt operator/(const ModInt &r) const { return (*this * (~r)); }\n    const ModInt operator^(int k) const { return ModInt(bpow(this->v, k)); }\n    const ModInt operator~() const { return ModInt(bpow(this->v, mod-2)); }\n    bool operator==(const ModInt &r) const { return this->v == r.v; }\n    bool operator!=(const ModInt &r) const { return this->v != r.v; }\n    ModInt& operator+=(const ModInt &r) { return *this = *this + r; }\n    ModInt& operator-=(const ModInt &r) { return *this = *this - r; }\n    ModInt& operator*=(const ModInt &r) { return *this = *this * r; }\n    ModInt& operator/=(const ModInt &r) { return *this = *this * (~r); }\nprivate:\n    int v;\n    int bpow(int a, int b) const {\n        int ret = 1;\n        while (b > 0) {\n            if (b & 1) ret = (ret * a) % mod;\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return ret;\n    }\n};\nusing Mint = ModInt<1000000007>;\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    vector<valarray<int>> mat(N);\n    REP(i, N) {\n        valarray<int> row(M);\n        REP(j, M) {\n            cin >> row[j];\n        }\n        mat[i] = row;\n    }\n    int rank = 0;\n    REP(i, N) {\n        int col = [&] {\n            REPF(j, i, N) {\n                REPF(k, i, M) {\n                    if (mat[j][k] == 1) {\n                        swap(mat[j], mat[i]);\n                        return k;\n                    }\n                }\n            }\n            return -1LL;\n        }();\n        if (col == -1) break;\n        \n        REP(j, N) swap(mat[i][i], mat[i][col]);\n        rank++;\n        REP(j, N) {\n            if (j == i) continue;\n            if (mat[j][i] == 1) mat[j] ^= mat[i];\n        }\n    }\n\n    dump(rank);\n    Mint ans = (Mint(2) ^ (N + M - 1)) - (Mint(2) ^ (N + M - rank - 1));\n    cout << ans.value() << endl;\n    FORE(r, mat) {\n        FORE(x, r) {\n            cerr << x << \" \";\n        }\n        cerr << endl;\n    }\n    return (0^_^0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\n\nvoid norm(VV<int>& a) {\n\tint n = a.size(), m = a[0].size();\n\tint pivot = -1;\n\tint pre = 0;\n\tREP(j, m) {\n\t\tFOR(i, pre, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tpivot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) continue;\n\t\tstd::swap(a[pre], a[pivot]);\n\n\t\tREP(i, n) if (i != pre) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tREP(k, m) {\n\t\t\t\t\ta[i][k] ^= a[pre][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++pre;\n\t}\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tMAT(int, a, n, m);\n\n\tnorm(a);\n\n\tint one = 0;\n\tREP(i, n) {\n\t\tbool f = false;\n\t\tREP(j, m) if (a[i][j]) f = true;\n\t\tif (f) ++one;\n\t}\n\n\tint ans = powMod(2, n, MOD) - powMod(2, n - one, MOD);\n\t(ans *= powMod(2, m - 1, MOD)) %= MOD;\n\tif (ans < 0) ans += MOD;\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define rollcall cout << \"I'm Sucu.\" << endl;\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define fi first\n#define se second\n// debug\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p){\n  os << \"(\" << p.first << \",\" << p.second << \")\";return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v){\n  for (auto it = v.begin();it != v.end();++it){\n    if(it != v.begin())os << \" \";os << *it;\n      }return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp){\n  for(auto x: mp)os << \"(\" << x.first << \",\" << x.second << \")\" << endl;\n  return os;\n}\ntemplate<typename T, int SIZE>\nint array_length(const T (&)[SIZE]){return SIZE;}\ntemplate<typename T, int N>\nvoid PRINTF(const T (&a)[N], int s = N, int t = -1, bool f = true){\n\tif(t == -1){rep(i,s){if(i)cout << \" \";cout << a[i];}}\n\telse repi(i,s,t){if(i!=s)cout << \" \";cout << a[i];}\n\tif(f)cout << \"\\n\";\n}\ntemplate<typename T, int N1, int N2>\nvoid PRINTF(const T (&a)[N1][N2], int h = N1, int w = N2){\n\trep(i,h){rep(j,w){cout << a[i][j] << \" \\n\"[j==w-1];}}\n}\nstring substr(const string &str, int S1, int S2 = -1){\n  if(S2 == -1)return str.substr(S1);\n  return str.substr(S1, S2-S1);\n}\n// typedef\ntypedef complex<double> Point;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nconst int mod = 998244353;\n\nvector<int> mat[400];\nvoid XOR(vi &A, vi &B){\n  int n = A.size();\n  rep(i,n)A[i] ^= B[i];\n}\n\nint Pow(int x, int n){\n  if(n < 0)n += mod-1;\n  int ans = 1;\n  while(n > 0){\n    if(n & 1)ans = (ans*x)%mod;\n    x = (x*x)%mod;\n    n >>= 1;\n  }\n  return ans;\n}\n\nint calc_rank(int h, int w){\n  int r = 0;\n  rep(j,w){\n    int pivot = -1;\n    rep(i,h)if(mat[i][j]){\n      pivot = i;break;\n    }\n    if(pivot == -1)continue;\n    swap(mat[pivot], mat[r]);\n    rep(i,h)if(i != r){\n      if(mat[i][j])XOR(mat[i], mat[r]);\n    }\n    r++;\n    if(r >= h)break;\n  }\n  return r;\n}\n\nsigned main(){\n  int h, w;\n  scanf(\"%lld%lld\", &h, &w);\n  rep(i,h)rep(j,w){\n    int tmp;scanf(\"%lld\", &tmp);\n    mat[i].pb(tmp);\n  }\n  int r = calc_rank(h, w);\n  int ans = Pow(2, h)-Pow(2, h-r);\n  ans = (ans%mod)*Pow(2, w-1);\n  printf(\"%lld\\n\", ans%mod);\n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// by tmt514\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#define SZ(x) ((int)(x).size())\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 998244353;\nLL bigmod(LL a, LL n) {\n  if(n==0) return 1;\n  if(n==1) return a%MOD;\n  return bigmod(a*a%MOD, n/2) * (n%2? a:1)%MOD;\n}\nint a[1005][1005] = {};\nint main(void) {\n  int n, m;\n  cin >> n >> m;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      cin >> a[i][j];\n  int rank=0, w=0;\n  if(n>m) {\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n        swap(a[i][j], a[j][i]);\n    swap(n, m);\n  }\n  for(int i=0;i<m;i++) {\n    int g=-1;\n    for(int j=w;j<n;j++)\n      if(a[j][i]==1) {\n        g=j;\n        break;\n      }\n    if(g>=0) {\n      for(int k=0;k<m;k++)\n        swap(a[w][k], a[g][k]);\n      for(int j=w+1;j<n;j++)\n        for(int k=0;k<m;k++)\n          a[j][k] ^= a[w][k];\n      ++rank;\n      ++w;\n    }\n  }\n  LL t = bigmod(2, m-1) * (bigmod(2, n) - bigmod(2, n-rank)) % MOD;\n  t=(t%MOD+MOD)%MOD;\n  cout << t << endl;\n  \n      \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <bitset>\n\nconst int N = 300;\nconst int MOD = 998244353;\n\nusing Bitset = std::bitset<N>;\n\nint n, m, two[N + 1];\nBitset mat[N];\n\nint main()\n{\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++ i) {\n    for (int j = 0, a; j < m; ++ j) {\n      scanf(\"%d\", &a);\n      if (a == 1) {\n        mat[i].set(j);\n      }\n    }\n  }\n  int rank = 0;\n  for (int j = 0; j < m; ++ j) {\n    int pivot = rank;\n    while (pivot < n && !mat[pivot].test(j)) {\n      pivot ++;\n    }\n    if (pivot == n) {\n      continue;\n    }\n    std::swap(mat[rank], mat[pivot]);\n    for (int i = rank + 1; i < n; ++ i) {\n      if (mat[i].test(j)) {\n        mat[i] ^= mat[rank];\n      }\n    }\n    rank ++;\n  }\n  two[0] = 1;\n  for (int i = 1; i <= N; ++ i) {\n    two[i] = two[i - 1] * 2 % MOD;\n  }\n  int result = 1LL * (two[n] + MOD - two[n - rank]) * two[m - 1] % MOD;\n  printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <functional>\n#include <unordered_set>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <bitset>\n\nusing namespace std;\n\nconst int N = 2e5 + 10;\nconst long long INF = 1LL << 60;\n\nvoid xorVector(vector<char>& a, const vector<char>& b) {\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\ta[i] ^= b[i];\n\t}\n}\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\treturn a - MOD;\n\treturn a;\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector <vector<char>> v(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tv[i].resize(m);\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> v[i][j];\n\t\t\tv[i][j] = (v[i][j] == '1');\n\t\t}\n\t}\n\tint r = 0;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint id = -1;\n\t\tfor (int j = r; j < n; ++j) {\n\t\t\tif (v[j][i] == 1) {\n\t\t\t\tid = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (id == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tv[r].swap(v[id]);\n\t\tfor (int j = r + 1; j < n; ++j) {\n\t\t\tif (v[j][i]) {\n\t\t\t\txorVector(v[j], v[r]);\n\t\t\t}\n\t\t}\n\t\t++r;\n\t}\n\tint pw2 = 1;\n\tvector <int> pow2 = { 1 };\n\tfor (int i = 1; i <= n + m; ++i) {\n\t\tpw2 = add(pw2, pw2);\n\t\tpow2.push_back(pw2);\n\t}\n\tint ans = pow2[n + m - 1] - pow2[n + m - r - 1];\n\tif (ans < 0) {\n\t\tans += MOD;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\n\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\n\ntemplate <typename T> constexpr bool chmax(T &a, const T b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nconstexpr int MAX_ROW = 510;\nconstexpr int MAX_COL = 510;\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL> &operator[](const int &i) { return val[i]; }\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    rep(col, A.W) {\n        if(is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        FOR(row, rank, A.H) {\n            if(A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if(pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        rep(row, A.H) if(row != rank && A[row][col]) A[row] ^= A[rank];\n        rank++;\n    }\n    return rank;\n}\n\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt &p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt &p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt &p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt &p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt &p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt &p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt &p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(const int64_t &n) const {\n        ModInt ret(1), mul(x);\n        int64_t k = n % (M - 1);\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n, m;\n    cin >> n >> m;\n    BitMatrix A(n, m);\n    rep(i, n) rep(j, m) {\n        int a;\n        cin >> a;\n        if(a) A[i].set(j);\n    }\n    int r = GaussJordan(A);\n\n    using modint = ModInt<Mod>;\n    modint m2(2);\n    cout << m2.pow(n + m - 1) - m2.pow(n + m - r - 1) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nvoid Gauss(vector<vector<double>> &mat) {\n    \n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(fabs(mat[j][i]) > __gauss_template_EPS) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        double fs = mat[i][i];\n\n        for(int j = i+1; j < n; j++) {\n            double r = mat[j][i] / fs;\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] -= mat[i][k] * r;\n            }\n        }\n    }\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    if(b == 1) return a;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vector<vector<double>> rec(max(n, m),vector<double>(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%lf\", &rec[i][j]);\n        }\n    }\n    Gauss(rec);\n\n    int r = 0;\n    REP(i, n) {\n        bool ok = false;\n        REP(j, m) {\n            if(rec[i][j] > EPS) {\n                ok = true;\n                break;\n            }\n        }\n        if(ok) r++;\n    }\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 400005\n#define ll long long\nusing namespace std ;\n\nIL ll gi(){\n    ll data = 0 , m = 1; char ch = 0;\n    while(ch!='-' && (ch<'0'||ch>'9')) ch = getchar();\n    if(ch == '-'){m = 0 ; ch = getchar() ; }\n    while(ch >= '0' && ch <= '9'){data = (data<<1) + (data<<3) + (ch^48) ; ch = getchar(); }\n    return (m) ? data : -data ; \n}\n\nint n , m , N , A[305][305] , pw[100005] , ID[305] ;\n#define mod 998244353\n\nint main() {\n\tn = gi() ; m = gi() ;\n\tfor(int i = 1; i <= n; i ++) for(int j = 1; j <= m; j ++) A[i][j] = gi() ;\n\tN = n * m ;\n\tpw[0] = 1 ; for(int j = 1; j <= N; j ++) pw[j] = 2ll * pw[j - 1] % mod ;\n\tfor(int i = 1; i <= N; i ++)\n\t\tfor(int j = 1; j <= m; j ++) {\n\t\t\tif(A[i][j]) {\n\t\t\t\tif(!ID[j]) {ID[j] = i ; break ; }\n\t\t\t\telse for(int k = 1; k <= m; k ++) A[i][k] = A[i][k] ^ A[ID[j]][k] ;\n\t\t\t}\n\t\t}\n\tint _cnt = 0 ;\n\tfor(int j = 1; j <= m; j ++) if(ID[j] != 0) ++ _cnt ;\n\tcout << 1ll * pw[m - 1] * (pw[n] - pw[n - _cnt] + mod) % mod << endl ;\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nconst int MX = 307;\n\nusing bs = bitset<MX>;\n\nbs a[MX];\nint pw[2 * MX];\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n, m;\n    cin >> n >> m;\n    pw[0] = 1;\n    for (int i = 1; i < 2 * MX; i++) {\n        pw[i] = (pw[i - 1] + pw[i - 1]) % MOD;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            int x;\n            cin >> x;\n            if (x == 1) {\n                a[i][j] = true;\n            }\n        }\n    }\n\n    int basis = 0;\n    int ptr = 1;\n    for (int i = 1; i <= n; i++) {\n        int pos = ptr;\n        while (pos <= n && a[pos][i] == false) {\n            pos++;\n        }\n        if (pos == n + 1) {\n            continue;\n        }\n        basis++;\n        swap(a[pos], a[ptr]);\n        for (int j = ptr + 1; j <= n; j++) {\n            if (a[j][i]) {\n                a[j] ^= a[ptr];\n            }\n        }\n        ptr++;\n    }\n\n    int nz = (pw[n] - pw[n - basis] + MOD) % MOD;\n    int ans = (1ll * nz * pw[m - 1]) % MOD;\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stdio.h>\n#include <cstdio>\n#include <math.h>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <random>\n#include <iomanip>\n#include <bitset>\n\nusing namespace std;\n\ntemplate<typename T> void uin(T &a, T b) {\n    if (b < a) {\n        a = b;\n    }\n}\n\ntemplate<typename T> void uax(T &a, T b) {\n    if (b > a) {\n        a = b;\n    }\n}\n\n#define int long long\n#define left left228\n#define right right228\n// #define prev prev228\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define forn(i, n) for (int i = 0; i < (int)n; ++i)\n#define firn(i, n) for (int i = 1; i < (int)n; ++i)\n#define x first\n#define y second\n\nconst int N = 303;\nconst int MOD = 998244353;\n\nint mod(int x) {\n    x %= MOD;\n    if (x < 0) x += MOD;\n    return x;\n}\nint fp(int a, int b) {\n    int res = 1;\n    for (; b; b >>= 1, a = mod(a * a)) {\n        if (b & 1) res = mod(res * a);\n    }\n    return res;\n}\n\nint n, m;\nbitset<N> a[N];\nbitset<N> b[N];\nvector< bitset<N> > basis;\n\nvoid add(bitset<N> x) {\n    for (int i = m; i >= 1; --i) {\n        if (x[i] == 0) continue;\n        if (x[i] && b[i] != 0) {\n            x ^= b[i];\n        } else {\n            b[i] = x; basis.emplace_back(x); break;\n        }\n    }\n    if (x.count() == 0) return;\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            int y;\n            cin >> y;\n            a[i][j] = y;\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        add(a[i]);\n    }\n    int xor0 = fp(2, n - (int)basis.size());\n    int xor1 = mod(fp(2, n) - xor0);\n    int answer = mod(xor1 * fp(2, m - 1));\n    cout << answer << '\\n';\n    return 0;\n\n}\n\n/*\n3\n1 1 2\n2 2 2\n3 3 2\n2 1 1\n3 2 1\n\n\n2 2\n1 1 2\n2 2 2\n1 2 3\n2 1 1\n\n2\n2 1 2 2 3\n2 2 2 1 1\n\n5\n1 2\n2 3\n3 4\n3 5\n1\n2 3\n1 2\n4 3\n2 3 5\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nint main()\n{\n\tint n, m; cin>>n>>m;\n\tint a[301][301];\n\tfor(int i=0; i<n; i++){\n\t\tstring s; cin>>s;\n\t\tfor(int j=0; j<m; j++) a[i][j]=(int)(s[j]-'0');\n\t}\n\tint r=0;\n\tfor(int i=0; i<n; i++){\n\t\tint j1=-1;\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif(a[i][j]){\n\t\t\t\tj1=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j1==-1) continue;\n\t\tr++;\n\t\tfor(int k=i+1; k<n; k++){\n\t\t\tif(a[k][j1]){\n\t\t\t\tfor(int j=j1; j<m; j++){\n\t\t\t\t\ta[k][j]^=a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll p2[301];\n\tp2[0]=1;\n\tfor(int i=1; i<=max(n, m); i++) p2[i]=p2[i-1]*2%MOD;\n\tll ans=(p2[n]-p2[n-r]+MOD)%MOD;\n\tans*=p2[m-1]; ans%=MOD;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = (ll)998244353;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n   ll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n   ll pow(ll a, ll b){if (b == 0) return 1; else if (b % 2 == 0) return pow(a * a, b / 2); else return pow(a * a, b / 2) * a;}\n   ll pow(ll a, ll b, ll m){if (a == 0) return 0; else if (b == 0) return 1; else if (b % 2 == 0) return (pow((a * a) % m, b / 2, m) % m); else return (pow((a * a) % m, b / 2) * a) % m;}\n   ll residue(ll a, ll m){return ((a % m) + m) % m;};\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\n\n//与えられたF2上の行列をAとして、(1 << (M * N - rank(A) - 1)) * ((1 << rank(A)) - 1 )が答え.\nll const MAX_M = 300, MAX_N = 300;\nll N, M;\nll a[MAX_N][MAX_M];\n\nll rnk(){\n   ll r = 0;\n   ll i = 0, j = 0;\n   while(i < N && j < M){\n      if(a[i][j]){\n         r++;\n         for(ll k = i + 1; k < N; k++){\n            if(a[k][j] == 0) continue;\n            for(ll l = j; l < M; l++){\n               a[k][l] = (a[k][l] + a[i][l]) % 2;\n            }\n         }\n         i++; j++;\n      }\n      else{\n         for(ll k = i + 1; k < N; k++){\n            if(a[k][j]){\n               for(ll l = j; l < M; l++){\n                  swap(a[i][l], a[k][l]);\n               }\n               break;\n            }\n         }\n         if(a[i][j]){\n            r++;\n            for(ll k = i + 1; k < N; k++){\n               if(a[k][j] == 0) continue;\n               for(ll l = j; l < M; l++){\n                  a[k][l] = (a[k][l] + a[i][l]) % 2;\n               }\n            }\n            i++; j++;\n         }\n         else{\n            j++;\n         }\n      }\n   }\n   return r;\n}\n\nint main(){\n   cin >> N >> M;\n   REP(i, N) REP(j, M) cin >> a[i][j];\n   ll r = rnk();\n/*\n   REP(i, N){\n      REP(j, M){\n         if(j) {cout << \" \";}\n         cout << a[i][j];\n      }\n      cout << endl;\n   }\n   cout << \"rnk = \" << r << endl;\n*/\n   cout << residue(pow(2ll, N + M - 1, MOD) - pow(2ll, N + M - 1 - r, MOD), MOD) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//行・列基本変形しても答えが変わらないというギャグ。\n//ランクrとすると、本質は(1, 1)をi箇所、{(0,0),(0,1),(1,0)}をr-i箇所作る問題。これは算数。\n#include <iostream>\n#include <vector>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef vector<int> Array;\ntypedef vector<Array> Mat;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn a * powmod(a, n - 1, mod) % mod;\n}\n\nint mod = 998244353;\nint fact[301];\nint finv[301];\n\nint comb(int n, int k) {\n\treturn fact[n] * finv[k] % mod * finv[n - k] % mod;\n}\n\nvoid henkei(Mat &a) {\n\tint h = a.size();\n\tint w = a[0].size();\n\t\n\tint i, j, k;\n\tint cor = 0;\n\t\n\trep(i, w) {\n\t\tfor (j = cor; j < h; j++) {\n\t\t\tif (a[j][i] == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == h) continue;\n\t\t\n\t\tint pos = j;\n\t\trep(j, w) {\n\t\t\tswap(a[cor][j], a[pos][j]);\n\t\t}\n\t\t\n\t\tfor (j = cor + 1; j < h; j++) {\n\t\t\tif (a[j][i] == 0) continue;\n\t\t\trep(k, w) {\n\t\t\t\ta[j][k] ^= a[cor][k];\n\t\t\t}\n\t\t}\n\t\tcor++;\n\t}\n}\n\nvoid tenti(Mat &a) {\n\tint h = a.size();\n\tint w = a[0].size();\n\tMat b(w, Array(h));\n\t\n\tint i, j;\n\trep(i, h) rep(j, w) b[j][i] = a[i][j];\n\ta = b;\n}\n\nint _rank(Mat &a) {\n\tint i;\n\trep(i, a.size()) {\n\t\tif (i >= a[0].size() || a[i][i] == 0) break;\n\t}\n\treturn i;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tfact[0] = finv[0] = 1;\n\tfor (i = 1; i <= 300; i++) {\n\t\tfact[i] = i * fact[i - 1] % mod;\n\t\tfinv[i] = powmod(fact[i], mod - 2, mod);\n\t}\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tMat a(n, Array(m));\n\trep(i, n) rep(j, m) cin >> a[i][j];\n\thenkei(a);\n\ttenti(a);\n\thenkei(a);\n\tint r = _rank(a);\n\tint ans = 0;\n\tfor (int i = 1; i <= r; i += 2) {\n\t\tans += comb(r, i) * powmod(3, r - i, mod);\n\t}\n\tans *= powmod(2, n + m - 2 * r, mod);\n\tans %= mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int p=998244353;\nint a[305][305],b[305][305];\nint read() {\n\tchar c=getchar(); int x=0,f=1;\n\twhile (c<'0' || c>'9') {\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint fpow(int x,int k) {\n\tint ans=1;\n\twhile (k) {\n\t\tif (k&1) ans=1LL*ans*x%p;\n\t\tx=1LL*x*x%p;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n=read(),m=read();\n\tfor (int i=1; i<=n; i++) {\n\t\tfor (int j=1; j<=m; j++) {\n\t\t\ta[i][j]=read();\n\t\t}\n\t}\n\tfor (int i=1; i<=m; i++) {\n\t\tfor (int j=1; j<=n; j++) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tif (b[j][j]) for (int k=1; k<=n; k++) a[i][k]^=b[j][k];\n\t\t\t\telse {\n\t\t\t\t\tfor (int k=1; k<=n; k++) b[j][k]=a[i][k];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tfor (int j=1; j<=n; j++) if (b[j][j]) ++cnt;\n\tprintf(\"%d\\n\", ((fpow(2,n+m-1)-fpow(2,n+m-cnt-1))%p+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    bool a[n][m];\n    int r = 0;\n    for (int i = 0;i < n;++i) for (int j = 0;j < m;++j) cin >> a[i][j];\n    for (int i = 0;i < n;++i) {\n        int p = i,q = i;\n        for (int j = i;j < n;++j) {\n            if (a[p][q]) break;\n            for (int k = i;k < m;++k) if (a[j][k]) {\n                p = j;q = k;\n                break;\n            }\n        }\n        if (!a[p][q]) break;\n        r = i+1;\n        for (int j = i;j < n;++j) swap(a[j][i],a[j][q]);\n        for (int j = i;j < m;++j) swap(a[i][j],a[p][j]);\n        for (int j = i+1;j < n;++j) if (a[j][i]) for (int k = i;k < m;++k) a[j][k] ^= a[i][k];\n        for (int j = i+1;j < m;++j) if (a[i][j]) for (int k = i;k < n;++k) a[k][j] ^= a[k][i];\n    }\n    ll x = 1,y = 1;\n    for (int i = 0;i < n+m-1;++i) {\n        x <<= 1;\n        x %= mod;\n    }\n    for (int i = 0;i < n+m-r-1;++i) {\n        y <<= 1;\n        y %= mod;\n    }\n    cout << (x-y+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\n#include <ctime>\n#include <complex>\n//#include <atcoder/all>\nusing namespace std;\n//using namespace atcoder;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    for(auto itr = a.begin(); itr != a.end(); itr++){\n\t\tcout << *itr << \" \";\n\t}\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){\n\tcout << \"debug: \" << a << \" \" << b << \"\\n\";\n}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << \"debug: \" << a << \" \" << b << \" \" << c << \"\\n\";\n}\nvoid mark() {cout << \"#\" << \"\\n\";}\nll pcount(ll x) {return __builtin_popcountll(x);}\n//const int mod = 1e9 + 7;\nconst int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nconst int MAX_ROW = 510; // to be set appropriately\nconst int MAX_COL = 510; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nll modpow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nvector<ll> fac(MAX), finv(MAX), inv(MAX);\n\nvoid comInit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(ll i=2; i<MAX; i++){\n        fac[i] = fac[i-1]*i % mod;\n        inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n        finv[i] = finv[i-1] * inv[i] % mod;\n    }\n}\n\n\nll com(ll n, ll k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nint main(){\n    int n,m; cin >> n >> m;\n    vvl a(n,vl(m));\n    rep(i,n) rep(j,m) cin >> a[i][j];\n    comInit();\n    BitMatrix mat(n,m);\n    rep(i,n) rep(j,m) mat[i][j] = a[i][j];\n    int res = GaussJordan(mat);\n    mint ans = 0;\n    mint mul = modpow(2,n-res,mod) * modpow(2,m-res,mod) % mod;\n    for(int i=1; i<=res; i+=2){\n        ans += mul * com(res,i) * modpow(3,res-i,mod);\n    }\n    cout << ans.value() << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 305;\nconst int MOD = 998244353;\nbitset<N> a[N]; \nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile(k) {\n\t\tif(k&1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD; \n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = m-1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t) a[i].flip(j);\n\t\t}\n\t}\n \tfor (int i = 0; i < n; i++) {\n \t\tfor (bitset<N> b : base) {\n \t\t\tbitset<N> bb = b^a[i];\n \t\t\tfor (int j = m-1; j >= 0; j--) {\n \t\t\t\tif(bb[j] < a[i][j]) {\n \t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(bb[j] > a[i][j]) break;\n\t\t\t}\n\t\t }\t\n\t\t if(a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", ((q_pow(2, n+m-1) - q_pow(2, n+m-1-cnt)) % MOD+ MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 998244353 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 410\n\nvector<ll> factmemo, factmemoInv;\nll factmemoMod = -1;\n\nll factorial(int n, int M){\n  if(factmemoMod == M) return factmemo[n];\n  if(n <= 1) return 1;\n\n  ll res = 1;\n  for(int i=1; i<=n; i++) res = res * i % M;\n  return res;\n}\n\nll power(int k, int n, int M){\n  if(n == 0) return 1;\n  if(n == 1) return (ll)k;\n\n  ll res = power(k, n/2, M);\n\n  res = res * res % M;\n  return n%2 == 1 ? res * k % M : res;\n}\n\nvoid initFactorial(int n, int M){\n  factmemo.assign(n+1, 0);\n  factmemoInv.assign(n+1, 0);\n  factmemoMod = M;\n  factmemo[0] = 1;\n  for(int i=1;i<=n;i++) factmemo[i] = factmemo[i-1] * i % M;\n  factmemoInv[n] = power(factmemo[n], M-2, M);\n  for(int i=n;i>0;i--) factmemoInv[i-1] = factmemoInv[i] * i % M;\n}\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nll C(int n, int m, int M){\n  if(n < m) return 0;\n  if(m == 0 || n == m) return 1;\n\n  if(factmemoMod == M)\n    return factmemo[n] * factmemoInv[m] % M * factmemoInv[n-m] % M;\n\n  ll numer = factorial(n, M);\n  ll denom = factorial(m, M) * factorial(n-m, M) % M;\n\n  denom = power((int)denom, M-2, M);\n\n  return numer * denom % M;\n}\n/*Permutation*/\nll P(int n, int m, int M){\n  if(n < m) return 0;\n  if(m == 0) return 1;\n\n  if(factmemoMod == M)\n    return factmemo[n] * factmemoInv[n-m] % M;\n\n  ll numer = factorial(n, M);\n  ll denom = factorial(n-m, M);\n\n  denom = power((int)denom, M-2, M);\n\n  return numer * denom % M;\n}\n/*Combination with Repetitions*/\nll H(int n, int m, int M){\n  if(n == 0 && m == 0) return 1;\n  return C(n+m-1, m, M);\n}\n\n\n\nint a[SIZE][SIZE], t[SIZE], s[SIZE];\nint p, q;\n\nint main(){\n  int h, w;\n\n  scanf(\"%d%d\", &h, &w);\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      scanf(\"%d\", a[i]+j);\n      t[i] += a[i][j];\n      s[j] += a[i][j];\n    }\n  }\n\n  for(int i=0;i<h;i++) p += t[i]%2;\n  for(int i=0;i<w;i++) q += s[i]%2;\n\n  debug(p); debug(q);\n\n  ll u = 1, u2 = 1;\n  ll v = 1, v2 = 1;\n\n  for(int i=0;i<=p;i++) {\n    ll r = 0;\n    for(int j=0;j<=h-p;j++){\n      r += (ll)C(p, i, mod) * C(h-p, j, mod) % mod;\n      r %= mod;\n    }\n    if(i%2 == 1) v = (v * r) % mod;\n    if(i%2 == 0) v2 = (v2 * r) % mod;\n  }\n  v2--;\n\n  for(int i=0;i<=q;i++) {\n    ll r = 0;\n    for(int j=0;j<=w-q;j++){\n      r += (ll)C(q, i, mod) * C(w-q, j, mod) % mod;\n      r %= mod;\n    }\n    if(i%2 == 1) u = (u * r) % mod;\n    if(i%2 == 0) u2 = (u2 * r) % mod;\n  }\n  u2--;\n\n  debug(u);\n  debug(v);\n  debug(u2);\n  debug(v2);\n\n  cout << u * v % mod << endl;\n  //cout << (u * v2 + v * u2) % mod << endl;;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = (ll)998244353;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n   ll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n   ll pow(ll a, ll b){if (b == 0) return 1; else if (b % 2 == 0) return pow(a * a, b / 2); else return pow(a * a, b / 2) * a;}\n   ll pow(ll a, ll b, ll m){if (a == 0) return 0; else if (b == 0) return 1; else if (b % 2 == 0) return (pow((a * a) % m, b / 2, m) % m); else return (pow((a * a) % m, b / 2) * a) % m;}\n   ll residue(ll a, ll m){return ((a % m) + m) % m;};\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\n\n//与えられたF2上の行列をAとして、(1 << (M * N - rank(A) - 1)) * ((1 << rank(A)) - 1 )が答え.\nconst ll MAX_M = 300, MAX_N = 300;\nll N, M;\nll a[MAX_N][MAX_M];\n\nll rnk(){\n   ll r = 0;\n   ll i = 0, j = 0;\n   while(i < N && j < M){\n      //a[i][j] = 0のときは、k = i + 1, ..., N - 1 からa[k][j] != 0なるkを探してきて, i行目とk行目を入れ替える\n      if(!a[i][j]){\n         FOR(k, i + 1, N){\n            if(a[k][j]){\n               REP(l, M){\n                  swap(a[i][l], a[k][l]);\n               }\n               break;\n            }\n         }\n      }\n      //入れ替えを行ってもa[i][j] = 0のとき（つまりj列目はすべて0のとき)はj列目をスキップ j+1列目にトライ\n      if(!a[i][j]){j++; continue;}\n      r++;\n      //k = i+1,...,N-1行目についてi行目を引く\n      FOR(k, i + 1, N){\n         ll c = a[k][j];\n         REP(l, M){\n            a[k][l] += c * a[i][l];\n            a[k][l] %= 2;\n         }\n      }\n      i++; j++;\n   }\n   return r;\n}\n\nint main(){\n   cin >> N >> M;\n   REP(i, N) REP(j, M) cin >> a[i][j];\n   ll r = rnk();\n/*\n   cout << endl;\n   REP(i, N){\n      REP(j, M){\n         if(j) {cout << \" \";}\n         cout << a[i][j];\n      }\n      cout << endl;\n   }\n   cout << \"rnk = \" << r << endl;\n*/\n   cout << residue(pow(2ll, N + M - 1, MOD) - pow(2ll, N + M - 1 - r, MOD), MOD) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(int i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(int i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const int x) { return 31-__builtin_clz(x); } // floor(log2(x))\ninline int fLog2(const ll x) { return 63-__builtin_clzll(x); }\ninline int cLog2(const int x) { return (x == 1) ? 0 : 32-__builtin_clz(x-1); } // ceil(log2(x))\ninline int cLog2(const ll x) { return (x == 1) ? 0 : 64-__builtin_clzll(x-1); }\ninline int popcount(const int x) { return __builtin_popcount(x); }\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\n// const int MOD  = int(1e9)+7;\nconst int MOD  = 998244353;\n\n\n\nconst int MAX_ROW = 310; // to be set appropriately\nconst int MAX_COL = 310; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nostream& operator << (ostream& s, BitMatrix A) {\n    s << endl; \n    for (int i = 0; i < A.H; ++i) {\n        for (int j = 0; j < A.W; ++j) {\n            s << A[i][j] << \", \";\n        }\n        s << endl;\n    }\n    return s;\n}\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\n\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this; }\n  mint operator+(const mint a) const { return mint(*this) += a; }\n  mint operator-(const mint a) const { return mint(*this) -= a; }\n  mint operator*(const mint a) const { return mint(*this) *= a; }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a; }\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\nint main() {\n  ll n, m; cin >> n >> m;\n  BitMatrix a(n, m);\n  rep(i, n) rep(j, m) {\n    int x; cin >> x;\n    a[i][j] = x;\n  }\n\n  int r = GaussJordan(a);\n  mint ans = 1;\n  ans *= mint(2).pow(n-1);\n  ans *= mint(2).pow(m) - mint(2).pow(m-r);\n\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 1e18;\nlong long int mod = 998244353;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1 , number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1 , number1);\n    }\n}\n\nll i,j,k,ii,jj,n,m,a,b,c,d,e,f,g,h,r,w,l,num,ans,ok,ng,mid;\nll x[500005],y[500005],z[500005];\nll dp[305][305];\nll sum[305];\nchar s[500005],t[500005],u[500005];\nbool dame,flag;\n//string s;\n\nint main(){\n\tcin >> n >> m;\n\tans = 1;\n\tfor(i=1;i<=n;i++){\n\t\tdame = true;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tcin >> x[j];\n\t\t\tif(x[j] == 1)dame = false;\n\t\t}\n\t\tif(dame){\n\t\t\ta++;\n\t\t\tans *= 2;\n\t\t\tans %= mod;\n\t\t}else{\n\t\t\tfor(j=1;j<=m;j++){\n\t\t\t\tdp[i-a][j] = x[j];\n\t\t\t}\n\t\t}\n\t}\n\tn -= a;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=m;j++){\n\t\t\tsum[i] += dp[i][j];\n\t\t\t//pe(dp[i][j]);\n\t\t}\n\t\t//el;\n\t}\n\t//sum[i] := i行目の総和\n\tdame = true;\n\tfor(i=1;i<=n;i++){\n\t\tif(sum[i] % 2 == 1){\n\t\t\tdame = false;\n\t\t}\n\t}\n\tif(!dame){\n\t\tans *= (rui(2,m-1)* (rui(2,n) - 1));\n\t}else{\n\t\tfor(j=1;j<=m;j++){\n\t\t\tsum[j] = 0;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tsum[j] += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tdame = true;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tif(sum[j] % 2 == 1)dame = false;\n\t\t}\n\t\tif(!dame){\n\t\t\tans *= (rui(2,n-1)* (rui(2,m) - 1));\n\t\t}else{\n\t\t\tans = 0;\n\t\t}\n\t}\n\tp(ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 305;\nconst int mod = 998244353;\n\nint pw2[Maxn];\nint n, m;\nint M[Maxn][Maxn];\n\nvoid Swap(int r1, int r2)\n{\n    for (int j = 0; j < m; j++)\n        swap(M[r1][j], M[r2][j]);\n}\n\nvoid Add(int r1, int r2)\n{\n    for (int j = 0; j < m; j++)\n        M[r2][j] ^= M[r1][j];\n}\n\nint main()\n{\n    pw2[0] = 1;\n    for (int i = 1; i < Maxn; i++)\n        pw2[i] = 2ll * pw2[i - 1] % mod;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            scanf(\"%d\", &M[i][j]);\n    int r = 0;\n    for (int j = 0; j < m; j++) {\n        int i = r;\n        while (i < n && M[i][j] == 0) i++;\n        if (i == n) continue;\n        Swap(i, r);\n        for (int l = r + 1; l < n; l++) if (M[l][j])\n            Add(r, l);\n        r++;\n    }\n    int res = (pw2[n] - pw2[n - r] + mod) % mod;\n    res = ll(res) * pw2[m - 1] % mod;\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int a[320][320], n, m, ans=0, sum=0;\n    cin >> n >> m;\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=m; j++){\n            cin >> a[i][j];\n        }\n    }\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=m; j++){\n            for(int h=1; h<=n-i+1; h++){\n                for(int w=1; w<=m-j+1; w++){\n                    for(int y=h; y<=h+i-1; y++){\n                        for(int x=w; x<=w+j-1; x++){\n                            sum += a[y][x];\n                        }\n                    }\n                    if(sum%2==1){\n                        ans++;\n                        if(ans==998244353){\n                            ans=0;\n                        }\n                    }\n                    sum=0;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<bitset> \n#include<map>\nusing namespace std;\nconst int maxd=998244353,N=100000;\nconst double pi=acos(-1.0);\ntypedef long long ll;\nint n,m,cnt=0;\nll bin[320];\nbitset<320> a[320],p[320];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n\twhile ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n\treturn x*f;\n}\n\nint main()\n{\n\tn=read();m=read();\n\tint i,j;\n\tbin[0]=1;\n\tfor (i=1;i<=300;i++) bin[i]=(bin[i-1]*2)%maxd;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tfor (j=1;j<=m;j++) \n\t\t{\n\t\t\tint tmp=read();\n\t\t\tif (tmp) a[i][j]=1;\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tfor (j=1;j<=m;j++)\n\t\t{\n\t\t\tif (a[i][j])\n\t\t\t{\n\t\t\t\tif (p[j][j]) a[i]^=p[j];\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tp[j]=a[i];\n\t\t\t\t\tcnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=(((bin[n]-bin[n-cnt])*bin[m-1])%maxd+maxd)%maxd;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\nusing namespace std;\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define LL long long\n#define pb push_back\n\nconst int N = 305;\nconst int MOD = 998244353;\nbitset<N> a[N];\nvector<bitset<N>> base;\nLL q_pow(LL n, LL k)\n{\n\treturn k ? (k & 1 ? n : 1)*q_pow((n*n)%MOD, k >> 1)%MOD : 1;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t) a[i].flip(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (bitset<N> b : base) {\n\t\t\tbitset<N> bb = b ^ a[i];\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (bb[j] < a[i][j]) {\n\t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (bb[j] > a[i][j]) break;\n\t\t\t}\n\t\t}\n\t\tif (a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", ((q_pow(2, n + m - 1) - q_pow(2, n + m - 1 - cnt)) % MOD + MOD) % MOD);\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 310, P = 998244353;\nint n, m, c, a[maxn][maxn], b[maxn][maxn];\n\nint qp(int x, int y) {\n\tint z = 1;\n\tfor (; y; y >>= 1, x = 1LL * x * x % P) {\n\t\tif (y & 1) z = 1LL * z * x % P;\n\t}\n\treturn z;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = m; j; j--) if (a[i][j]) {\n\t\t\tif (b[j][j]) {\n\t\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\t\ta[i][k] ^= b[j][k];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\t\tb[j][k] = a[i][k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (b[i][j]) c++;\n\t\t}\n\t}\n\tint ans = qp(2, n + m) - qp(2, n + m - c) + P;\n\tprintf(\"%d\\n\", 1LL * ans * qp(2, P - 2) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YESNO OUT(three(solve(),\"YES\",\"NO\"))\n#define YesNo OUT(three(solve(),\"Yes\",\"No\"))\n#define WL(A,B) OUT(three(solve(),A,B))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(b);i>=(LL)(a);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n#define all ALL\n#define pb emplace_back\n#define eb pb\n#define int long long\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntemplate<class T> inline bool chmax(int a, int b, T c, T d) { return c > d ? a : b; }\ntemplate<class T> inline bool chmin(int a, int b, T c, T d) { return c > d ? a : b; }\ntypedef int LL;\ntypedef double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef tuple<int, int, int, int> tapu;\ntypedef vector<tapu> Vtapu;\ntypedef priority_queue<ut, VI, greater<LL> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 1e6 + 1000;\nconst int SIZE2 = 4010;\nconst int SIZE3 = 430;\nconst int SIZE = SIZE1;\nconst int MAPSIZE = 40;\nconst LL p =998244353;\nconst LL INF = 1LL << 30;\nconst long double EPS = 1e-7;\nconst LL inf = 1000000000;\ntypedef pair<ld, ut> pld;\nut N, M, K, L, Q,  H, W, R;\nVI edges[SIZE];\nLL vals[SIZE], answer = zero;\n//LL maps[SIZE2][SIZE2];\nLL A[SIZE3][SIZE3],B[SIZE],C[SIZE],D[SIZE],E[SIZE];\nLL def = 0;\nvoid rev(int a) {\n\tREP(i, W) {\n\t\tdef ^= A[a][i];\n\t\tA[a][i] ^= 1;\n\t}\n}\nvoid xors(int a, int b) {\n\tREP(i, W)\n\t\tA[a][i] ^= A[b][i];\n}\nvoid swaps(int a, int b) {\n\tREP(i, W)\n\t\tswap(A[a][i], A[b][i]);\n}\nLL power(LL x) {\n\tLL ans = 1;\n\tREP(i, x) ans = ans * 2 % p;\n\treturn ans;\n}\nLL solve() {\n\tcin >> H >> W;\n\tREP(i, H) REP(j, W) {\n\t\tcin >> A[i][j];\n\t}\n\tLL ans = 0,rank=0;\n\tREP(j, W) {\n\t\tFOR(i,rank,H) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tswaps(i, j);\n\t\t\t\tFOR(k, j + 1, H) {\n\t\t\t\t\tif (A[k][j]) xors(k, j);\n\t\t\t\t}\n\t\t\t\trank++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (power( H + W - 1) % p - power(H+W-rank-1) % p + p) % p;\n\t//return ;\n}\n\n\n\n\n//!!!!!!!!!!!!!!!!!!!実装を詰める!!!!!!!!!!!!!!!!!!!!!!!!!\nsigned main() {\n\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(0);\n\tcout << solve() << endl;\n\t\n\t//cin >> N;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n \n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if(a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if(a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = INT_MAX / 2; const ll INF = LLONG_MAX / 2;\n//template end\n\nint mod = 998244353;\nstruct Mint {\n  int val;\n  Mint inv() const {\n    int tmp, a = val, b = mod, x = 1, y = 0;\n    while(b) tmp = a / b, a -= tmp * b, swap(a, b), x -= tmp * y, swap(x, y);\n    return Mint(x);\n  }\npublic:\n  Mint() :val(0) {}\n  Mint(ll x) :val(x >= 0 ? x % mod : x % mod + mod) {}\n  int mtoi() { return this->val; }\n  Mint pow(ll t) { Mint res = 1,b = *this; while(t){if(t&1)res *= b;b *= b;t >>= 1;}return res; }\n  Mint& operator+=(const Mint& x) { if ((val += x.val) >= mod) val -= mod; return *this; }\n  Mint& operator-=(const Mint& x) { if ((val += mod - x.val) >= mod) val -= mod; return *this; }\n  Mint& operator*=(const Mint& x) { val = (ll)val * x.val % mod; return *this; }\n  Mint& operator/=(const Mint& x) { return *this *= x.inv(); }\n  bool operator==(const Mint& x) const { return val == x.val; }\n  bool operator!=(const Mint& x) const { return val != x.val; }\n  bool operator<(const Mint& x) const { return val < x.val; }\n  bool operator<=(const Mint& x) const { return val <= x.val; }\n  bool operator>(const Mint& x) const { return val > x.val; }\n  bool operator>=(const Mint& x) const { return val >= x.val; }\n  Mint operator+(const Mint& x) const { return Mint(*this) += x; }\n  Mint operator-(const Mint& x) const { return Mint(*this) -= x; }\n  Mint operator*(const Mint& x) const { return Mint(*this) *= x; }\n  Mint operator/(const Mint& x) const { return Mint(*this) /= x; }\n};\nstruct factorial {\n  vector<Mint> Fact, Finv;\npublic:\n  factorial(int maxx) {\n    Fact.resize(maxx+1,Mint(1)),Finv.resize(maxx+1); rep(i,0,maxx)Fact[i+1]=Fact[i]*Mint(i+1);\n    Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*Mint(i);\n  }\n  Mint fact(int n,bool inv) { if(inv) return Finv[n]; else return Fact[n]; }\n  Mint nPr(int n,int r) { if(n<0||n<r||r<0) return Mint(0); else return Fact[n]*Finv[n-r]; }\n  Mint nCr(int n,int r) { if(n<0||n<r||r<0) return Mint(0); else return Fact[n]*Finv[r]*Finv[n-r]; }\n};\n\ntypedef vector<vector<Mint>> mat;\nmat matmul(mat a, mat b) {\n\tmat ans(a.size(), vector<Mint>(b[0].size(), 0));\n\trep(i, 0, a.size())rep(j, 0, b[0].size())rep(k,0,b.size())ans[i][j] += a[i][k]*b[k][j];\n\treturn ans;\n}\nmat matpow(mat a, ll t) {\n\tmat ans(a.size());\n\trep(i, 0, a.size()) { ans[i].resize(a.size(), 0);ans[i][i] = 1;}\n\twhile (t) {if (t % 2) ans = matmul(ans, a); a = matmul(a, a); t >>= 1;}\n\treturn ans;\n}\nint gauss(mat& a,bool flag){//flag?linear:rank\n  int m=a.size(),n=a[0].size(),rank=0;\n  rep(j,0,n){\n    if(flag&&j==n-1)break;\n    int piv=-1;\n    rep(i,rank,m)if(a[i][j].mtoi()){piv=i; break;}\n    if(piv==-1)continue;\n    swap(a[piv],a[rank]);\n    rep(k,0,n)a[rank][k]/=a[rank][j];\n    rep(i,0,m){\n      if(i!=rank&&a[i][j].mtoi()){\n        rep(k,0,n) a[i][k]-=a[rank][k]*a[i][j];\n      }\n    } rank++;\n  }\n  return rank;\n}\n\nint main(){\n  int h,w; scanf(\"%d%d\",&h,&w);\n  mat a(h);\n  rep(i,0,h){\n    a[i].resize(w);\n    rep(j,0,w)scanf(\"%d\",&a[i][j]);\n  }\n  int r=gauss(a,false);\n  Mint base=2;\n  Mint ans=base.pow(h+w-1)-base.pow(h+w-r-1);\n  printf(\"%d\\n\",ans.mtoi());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nint main()\n{\n\tint n, m; cin>>n>>m;\n\tbool a[301][301];\n\tfor(int i=0; i<n; i++){\n\t\tstring s; cin>>s;\n\t\tfor(int j=0; j<m; j++) a[i][j]=(bool)(s[j]-'0');\n\t}\n\tint r=0;\n\tfor(int i=0; i<n; i++){\n\t\tint j1=-1;\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif(a[i][j]){\n\t\t\t\tj1=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j1==-1) continue;\n\t\tr++;\n\t\tfor(int k=i+1; k<n; k++){\n\t\t\tif(a[k][j1]){\n\t\t\t\tfor(int j=j1; j<m; j++){\n\t\t\t\t\ta[k][j]^=a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll p2[301];\n\tp2[0]=1;\n\tfor(int i=1; i<=max(n, m); i++) p2[i]=p2[i-1]*2%MOD;\n\tll ans=(p2[n]-p2[n-r]+MOD)%MOD;\n\tans*=p2[m-1]; ans%=MOD;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst ll INF = 1 << 30;//10^9\n//ll MOD = 1000000007;\nll MOD = 998244353;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A, ll x = 20){cout << fixed << setprecision(x) << A << endl;}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n\n//コンビネーション\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\n\nll Rank(ll N, ll M, vector<vector<ll>> A){\n  ll next = 0;\n  rep(i, M){\n    for(ll j = next; j < N; j++){\n      if(A[j][i]){\n        swap(A[next], A[j]);\n      }\n    }\n    if(!A[next][i]) continue;\n    rep(j, N)if(j != next){\n      if(A[j][i]){\n        rep(k, M) A[j][k] ^= A[next][k];\n      }\n    }\n    next++;\n  }\n  return next;\n}\n\nll N, M;\nvector<vector<ll>> A;\n\n\nvoid solve(){\n  COMinit();\n  cin >> N >> M;\n  A.resize(N);\n  rep(i, N) A[i].resize(M);\n  rep(i, N)rep(j, M) cin >> A[i][j];\n  ll r = Rank(N, M, A);\n  ll ans = 0;\n  rep(i, r+1){\n    ll add = comb(r, i) * pow_mod(2, r-i) % MOD;\n    for(ll j = 1; j <= i; j += 2){\n      ans += add * comb(i, j) % MOD;\n      ans %= MOD;\n    }\n  }\n  ans *= pow_mod(2, N + M - 2 * r);\n  ans %= MOD;\n  cout << ans << endl;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\n#define BIT_N 333\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef bitset<BIT_N> Bit;\nvector<int> baseNum;\n\nll pow_two[2 * BIT_N];\n\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 333333\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nvector<Bit> gauss(vector<Bit> v, ll &ran){\n\tran = 0;\n\tREP(i,BIT_N) {\n\t\tint pla = -1;\n\t\tfor(int j = ran;j < v.size();j++){\n\t\t\tif(v[j][i] == 1){\n\t\t\t\tpla = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pla != -1){\n\t\t\tswap(v[ran], v[pla]);\n\t\t\tfor(int j = 0;j < v.size();j++){\n\t\t\t\tif(j != ran && v[j][i] == 1)v[j] ^= v[ran];\n\t\t\t}\n\t\t\tran++;\n\t\t}\n\t}\n\treturn v;\n}\n\nint main(){\n\t\n\tpow_two[0] = 1;\n\tREP(i,2 * BIT_N - 1)pow_two[i+1] = pow_two[i] * 2 % MOD;\n\t\n\tvector<Bit> v;\n\tll n, m;cin >> n >> m;\n\tREP(i,n){\n\t\tBit now;\n\t\tREP(j,m){\n\t\t\tint a;cin >> a;\n\t\t\tif(a)now[j] = 1;\n\t\t}\n\t\tv.PB(now);\n\t}\n\t\n\tll ran = 0;\n\tll ans = 0;\n\tgauss(v, ran);\n\tll kake = pow_two[n-ran] * pow_two[m-ran] % MOD;\n\t//cout << \"kake \" << kake << endl;\n\tfor(int i = 1;i <= ran;i+=2){\n\t\tll now = combination(ran, i) * (pow_two[ran - i] * 2 - 1 + MOD) % MOD;\n\t\tans = (ans + now * kake % MOD) % MOD;\n\t\t//cout << \"now \" << now << endl;\n\t}\n\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    vector<vector<ll>> a(n,vector<ll>(m));\n    for(auto &I:a){\n        for(auto &T:I){cin>>T;}\n    }\n    vector<vector<ll>> b;\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        b=a;\n        for(int h=i;h<n;h++){\n            for(int w=1;w<m;w++){\n                b[h][w]+=b[h][w-1];\n                b[h][w]&=1;\n            }\n        }\n        for(int h=i+1;h<n;h++){\n            for(int w=0;w<m;w++){\n                b[h][w]+=b[h-1][w];\n                b[h][w]&=1;\n            }\n        }\n        for(int h=i;h<n;h++){\n            ll cnt0=1,cnt1=0;\n            for(int w=0;w<m;w++){\n                if(b[h][w]){ans+=cnt0; cnt1++; ans%=MOD; cnt1%=MOD;}\n                else{ans+=cnt1; cnt0++; ans%=MOD; cnt0%=MOD;}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 333, mod = 998244353;\nbitset<maxn> e[maxn];\nint power(int x){\n\tint v = 1;\n\tfor(int i = 0; i < x; i++){\n\t\tv *= 2;\n\t\tif(v >= mod) v -= mod;\n\t}\n\treturn v;\n}\nint main(){\n\tint n, m; cin >> n >> m; int rnk = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tbitset<maxn> now;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tint v; cin >> v;\n\t\t\tnow[j] = v == 1;\n\t\t}\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(e[j][j] && now[j]){\n\t\t\t\tnow ^= e[j];\n\t\t\t} else if(now[j]){\n\t\t\t\te[j] = now;\n\t\t\t\trnk++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = power(n + m - 1);\n\tans += mod - power(n + m - 1 - rnk);\n\tif(ans >= mod) ans -= mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> //STLͨ���㷨\n#include <cmath> //������ѧ����\n#include <cstdio> //��������/�������\n#include <iostream> //����������/���\n#include <cstring> //�ַ�������\n#include <string> //�ַ�����\n#include <ctime> //�������ʱ��ĺ���\n#define itn int\n#define fro for\n#define ll long long\n#define reg register\n#define inf 1234567890\n#define rep(i,a,b,c) for (int i=a;i<=b;i+=c)\n/*#include <bitset> //STLλ������\n#include <cstype> //�ַ�����\n#include <cerrno> //���������\n#include <complex> //������\n#include <clocale> //���屾�ػ�����\n#include <cstdlib> //������������ڴ���亯��\n#include <deque> //STL˫�˶�������\n#include <exception> //�쳣������\n#include <fstream> //�ļ�����/���\n#include <functional> //STL�������㺯��(���������)\n#include <limits> //�����������������ֵ����\n#include <list> //STL�����б�����\n#include <map> //STLӳ������\n#include <iomanip> //����������/���\n#include <ios> //��������/���֧��\n#include <iosfwd> //����/���ϵͳʹ�õ�ǰ������\n#include <istream> //����������\n#include <ostream> //���������\n#include <queue> //STL��������\n#include <set> //STL��������\n#include <sstream> //�����ַ�������\n#include <stack> //STL��ջ����\n#include <stdexcept> //��׼�쳣��\n#include <streambuf> //�ײ�����/���֧��\n#include <utility> //STLͨ��ģ����\n#include <vector> //STL��̬��������\n#include <cwchar.h>//���ַ�����������/���\n#include <cwctype.h> //���ַ�����*/\n\nusing namespace std;\n\nint ans;\n\nint max(int x,int y){return x>y?x:y;}\n\nint min(int x,int y){return x<y?x:y;}\n\nint abs(int x){return x>0?x:-x;}\n\nint gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\n\nvoid exgcd(int a,int b,int &d,int &x,int &y){if (!b){d=a,x=1,y=0;}else{exgcd(b,a%b,d,y,x);y-=x*(a/b);}}\n\nint quick_power(ll a,int b){ll r=1;for (;b;b>>=1,a=a*a)if (b&1) r=r*a;return r;}\n\ninline char read() {\n\tstatic const int IN_LEN = 1000000;\n\tstatic char buf[IN_LEN], *s, *t;\n\treturn (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);\n}\ntemplate<class T>\ninline void read(T &x) {\n\tstatic bool iosig;\n\tstatic char c;\n\tfor (iosig = false, c = read(); !isdigit(c); c = read()) {\n\t\tif (c == '-') iosig = true;\n\t\tif (c == -1) return;\n\t}\n\tfor (x = 0; isdigit(c); c = read()) x = x * 10 + (c ^ '0');\n\tif (iosig) x = -x;\n}\n\nchar sr[10000000],z[20];int C=-1,Z=0;\nvoid Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(int x){\n\tif (x<0) sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\n//int find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}\n\n//void add(int x,int y,int z){to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;}\nconst int mod=998244353,N=512;\nint a[N][N],s[N][N];\nint main()\n{\n\tint n,m;\n\tread(n);read(m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++) read(a[i][j]);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tif (a[i][j])\n\t\t\t{\n\t\t\t\tif (!s[i][j])\n\t\t\t\t{\n\t\t\t\t\tfor (int k=j;k<=m;k++) s[i][k]=a[i][k];\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int k=j;k<=m;k++) s[i][k]^=a[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans=1ll*(quick_power(2,n)-quick_power(2,n-ans))*quick_power(2,m-1)%mod;\n\t(ans+=mod)%=mod;\n\tcout<<ans;\n\treturn 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 305;\nconst int MOD = 998244353;\nbitset<N> a[N]; \nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile(k) {\n\t\tif(k&1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD; \n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = m-1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t) a[i].set(j);\n\t\t}\n\t}\n \tfor (int i = 0; i < n; i++) {\n \t\tfor (bitset<N> b : base) {\n \t\t\tbitset<N> bb = b^a[i];\n \t\t\tfor (int j = m-1; j >= 0; j--) {\n \t\t\t\tif(bb[j] < a[i][j]) {\n \t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t }\n\t\t\t}\n\t\t }\t\n\t\t if(a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", (q_pow(2, n+m-1) - q_pow(2, n+m-1-cnt) + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000000;\nconstexpr ll INF = 1000000000000000000;\nconstexpr ld EPS = 1e-12;\nconstexpr ld PI = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nconstexpr ll mod = 998244353;\nconstexpr ll modsize = 0;\nvector<ll> fac(modsize);\nvector<ll> inv(modsize);\nvector<ll> facinv(modsize);\n\nvoid modcalc() {\n\tif (modsize == 0) abort();\n\tfac[0] = 1; fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = 1; facinv[1] = 1;\n\tfor (ll i = 2; i < modsize; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modinv(ll a) {\n\tif (a == 0) abort();\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0 || n == 0 && k > 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn fac[n + k - 1] * facinv[k] % mod * facinv[n - 1] % mod;\n}\n\nint mat_rank(vector<vector<int>> mat) {\n\tint n = mat.size();\n\tint m = mat[0].size();\n\tint st = 0;\n\trep(j, m) {\n\t\tint idx = -1;\n\t\tfor (int i = st; i < n; i++) {\n\t\t\tif (mat[i][j]) {\n\t\t\t\tif (idx == -1) {\n\t\t\t\t\tidx = i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k, m) {\n\t\t\t\t\tmat[i][k] ^= mat[idx][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = st - 1; i >= 0; i--) {\n\t\t\tif (mat[i][j]) {\n\t\t\t\tif (idx == -1) continue;\n\t\t\t\trep(k, m) {\n\t\t\t\t\tmat[i][k] ^= mat[idx][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx != -1) {\n\t\t\trep(k, m) {\n\t\t\t\tswap(mat[idx][k], mat[st][k]);\n\t\t\t}\n\t\t\tst++;\n\t\t}\n\t}\n\treturn st;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> a(n, vector<int>(m));\n\trep(i, n) rep(j, m) cin >> a[i][j];\n\tint r = mat_rank(a);\n\tcout << modpow(2, n + m - r - 1)*(modpow(2, r) - 1) % mod << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <sstream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define SZ(x) (int)(x.size())\n#define F0(i,n) for(int i=0;i<n;i++)\n#define F1(i,n) for(int i=1;i<=n;i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define P(x) cerr << #x << \"=\" << x << endl\n\nconst int MOD = 998244353;\nconst double pi = atan(1.0)*4.0;\nconst double eps = 1e-8;\nll gcd(ll x, ll y) { return y ? gcd(y, x%y) : x; }\nint bc(int n) { return n ? bc((n-1)&n)+1 : 0; }\n\nconst int N = 301;\nint i, j, k, m, n, rn, bn;\nstring s;\nint a[N][N], used[N];\n\nvoid add(int& x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvoid solve() {\n    F0(i, m) F0(j, n) cin >> a[i][j];\n\n    int ind = 0;\n    CL(0, used);\n    F0(j, n) {\n        F0(i, m) if (a[i][j] && !used[i]) {\n            for (int k = i + 1; k < m; k++) if (a[k][j] && !used[k]) {\n                F0(l, n) a[k][l] ^= 1;\n            }\n            ind++;\n            used[i] = 1;\n            break;\n        }\n    }\n    ll ans = 0;\n    F0(i, ind) {\n        ans = (ans * 2 + 1) % MOD;\n    }\n    F0(i, m - ind + n - 1) ans = (ans * 2) % MOD;\n    cout << ans << endl;\n}\n\nint main() {\n    //freopen(\"x.in\", \"r\", stdin);\n    while (cin >> m >> n) {\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    vvint a(N, vint(M));\n    rep(i, N) rep(j, M) { cin >> a[i][j]; }\n    using mint = mod_int<998244353>;\n    //1つ目の次元が線の本数、2つ目の次元が総和が奇数となる集合の数\n    auto solve = [](auto &&solve, vvint a) -> vector<vector<mint>> {\n        if (a.size() == 0) { return {{1, 0}, {0, 0}}; }\n        if (a[0].size() == 0) {\n            mint p = mint(2).pow(a.size() - 1);\n            return {{p, 0}, {p, 0}};\n        }\n        vvint E, O;\n        rep(i, a.size()) {\n            int b = a[i].back();\n            a[i].pop_back();\n            if (b == 0) { E.emplace_back(a[i]); }\n            else { O.emplace_back(a[i]); }\n        }\n        vector ret(2, vector<mint>(2));\n        vector rE = solve(solve, E), rO = solve(solve, O);\n        rep(iE, 2) {\n            rep(jE, 2) {\n                rep(iO, 2) {\n                    rep(jO, 2) {\n                        ret[iE ^ iO][jE ^ jO] += rE[iE][jE] * rO[iO][jO];\n                        ret[iE ^ iO][iO ^ jE ^ jO] += rE[iE][jE] * rO[iO][jO];\n                    }\n                }\n            }\n        }\n        dump(ret);\n        return ret;\n    };\n    auto res = solve(solve, a);\n    cout << (res[0][1] + res[1][1]) / 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=300,MAX_M=300;\nconst  ll MOD=998244353;\nint N,M;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nmat mt;\nll mpw(ll n,ll m){\n\tll ret=1;\n\twhile(m){\n\t\tif(m&1){\n\t\t\tret*=n;\n\t\t\tret%=MOD;\n\t\t}\n\t\tn*=n;\n\t\tn%=MOD;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>N>>M;\n\tmt.resize(N);\n\tREP(i,N){\n\t\tmt[i].resize(M);\n\t}\n\tREP(i,N){\n\t\tREP(j,M){\n\t\t\tcin>>mt[i][j];\n\t\t}\n\t}\n\tint c=0,i=0;\n\twhile(i<N && c<M){\n\t\tint pvt=i;\n\t\tFOR(j,i+1,N){\n\t\t\tif(mt[j][c]>mt[pvt][c])pvt=j;\n\t\t}\n\t\tswap(mt[i],mt[pvt]);\n\t\tif(mt[i][c]==0){\n\t\t\tc++;\n\t\t\tcontinue;\n\t\t}\n\t\tFOR(j,i+1,N){\n\t\t\tif(mt[j][c]==1){\n\t\t\t\tFOR(k,c,M){\n\t\t\t\t\tmt[j][k]-=mt[i][k];\n\t\t\t\t\tmt[j][k]+=2;\n\t\t\t\t\tmt[j][k]%=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tint r=-1;\n\tREP(i,N)REP(j,M){\n\t\tif(mt[i][j]==1)\n\t\t\tr=i;\n\t}\n\tr++;\n\tcout<<mpw(2,N-r)*(mpw(2,r)+MOD-1)%MOD*mpw(2,M-1)%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define fs first\n#define se second\n\nusing namespace std;\ntypedef long long llong;\ntypedef pair<int, int> pii;\n\nconst int mod = 998244353;\n\nint n, m;\nint A[301][301];\nint nCr[301][301];\nint p2[601];\nint p3[301];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    nCr[0][0] = p2[0] = p3[0] = 1;\n    for (int i = 1; i <= 300; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            if (j > 0) nCr[i][j] += nCr[i - 1][j - 1];\n            if (j < i) nCr[i][j] += nCr[i - 1][j];\n            nCr[i][j] %= mod;\n        }\n    }\n    for (int i = 1; i <= 600; ++i) p2[i] = p2[i - 1] * 2ll % mod;\n    for (int i = 1; i <= 300; ++i) p3[i] = p3[i - 1] * 3ll % mod;\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            cin >> A[i][j];\n        }\n    }\n    int R = n;\n    for (int i = 1; i <= n; ++i) {\n        int mnv = m + 1, mni;\n        for (int j = i; j <= n; ++j) {\n            for (int k = 1; k < mnv; ++k) {\n                if (A[j][k]) {\n                    mnv = k;\n                    mni = j;\n                    break;\n                }\n            }\n        }\n        if (mnv > m) {\n            R = i - 1;\n            break;\n        }\n        for (int j = 1; j <= m; ++j) {\n            swap(A[i][j], A[mni][j]);\n        }\n        for (int j = i + 1; j <= n; ++j) {\n            if (A[j][mnv] == 0) continue;\n            for (int k = 1; k <= m; ++k) {\n                A[j][k] ^= A[i][k];\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= R; i += 2) {\n        int v = 1;\n        ans += (llong)nCr[R][i] * p2[m + n - R - R] % mod * p3[R - i] % mod;\n        ans %= mod;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    using mint = mod_int<998244353>;\n    vector a(N, vint(M));\n    rep(i, N) rep(j, M) { cin >> a[i][j]; }\n    int r = 0;\n    rep(i, min(N, M)) {\n        sort(a.begin() + r, a.begin() + N), reverse(a.begin() + r, a.begin() + N);\n        if (a[r][i]) { r++; }\n        for (int j = r + 1; j < N; j++) {\n            if (a[r][i] == a[j][i]) {\n                for (int k = i; k < M; k++) { a[j][k] ^= a[r][k]; }\n            }\n        }\n    }\n    cout << mint(2).pow(N + M - 1) - mint(2).pow(N + M - r - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"out2.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n#define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \n// void bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid amax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid amin(T& x, T y) {\n    x = min(x, y);\n}\n\n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-12;\nconst int maxn = 5e4 + 3, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst int base2 = 998244353;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % base2;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % base2;\n    }\n}\n\nconst int N = 305;\n\nint gauss (vector < bitset<N> > a, int n, int m) {    \n    int rank = m;\n    vector<char> line_used (n);\n    for (int i=0; i<m; ++i) {\n        int j;\n        for (j=0; j<n; ++j)\n            if (!line_used[j] && a[j][i])\n                break;\n        if (j == n)\n            --rank;\n        else {\n            line_used[j] = true;\n            for (int k=0; k<n; ++k)\n                if (k != j && a[k][i])\n                    a[k] ^= a[j];\n        }\n    }\n    return rank;\n}\n\nint main() {\n    // files1;\n\n    int n, m;\n    cin >> n >> m;\n    vector<bitset<N> > a(n);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            bool x;\n            cin >> x;\n            a[i][j] = x;\n        }\n\n    int r = gauss(a, n, m);\n    cout << ((binpow(2, n + m - 1) - binpow(2, n + m - r - 1)) % base2 + base2) % base2;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbitset<305> a[305],b;\nint n,m,i,j,pw[305],mod=998244353,cnt;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tpw[0]=1;\n\tfor (i=1;i<=300;i++) pw[i]=pw[i-1]*2ll%mod;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tb.reset();\n\t\tfor (j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tb[j]=x;\n\t\t}\n\t\tfor (j=m;j>=1;j--)\n\t\t{\n\t\t\tif (b[j])\n\t\t\t{\n\t\t\t\tif (a[j].any())\n\t\t\t\t{\n\t\t\t\t\tb^=a[j];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[j]=b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (j<1) cnt++;\n\t}\n\tcout<<((1ll*(pw[n]-pw[cnt])*pw[m-1]%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\ntypedef unsigned int uint;\nusing namespace std;\n\nconst ll mod = 998244353LL;\n\nll power_mod(ll num, ll power) {\n    ll prod = 1;\n    num %= mod;\n    while (power > 0) {\n        if (power & 1) {\n            prod = prod * num % mod;\n        }\n        num = num * num % mod;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint main() {\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m, A[300][300];\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> A[i][j];\n        }\n    }\n\n    int rank = 0;\n    for (int j = 0; j < m; j++) {\n        int pivot = -1;\n\n        for (int i = rank; i < n; i++) {\n            if (A[i][j]) {\n                pivot = i;\n                break;\n            }\n        }\n\n        if (pivot >= 0) {\n            if (pivot != rank) {\n                for (int k = 0; k < m; k++) {\n                    swap(A[pivot][k], A[rank][k]);\n                }\n            }\n\n            for (int i = rank + 1; i < n; i++) {\n                if (A[i][j]) {\n                    for (int k = 0; k < m; k++) {\n                        A[i][k] ^= A[rank][k];\n                    }\n                }\n            }\n\n            rank++;\n        }\n    }\n\n    cout << (power_mod(2LL, (ll)(n+m-1)) - power_mod(2LL, (ll)(n+m-rank-1)) + mod) % mod << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define MOD 998244353\n\nconst int N = 300;\nint n, m;\nint A[N + 7][N + 7];\n\nll power(int a, int k){\n\tll ans = 1;\n\twhile(k > 0){\n\t\tif(k&1)\n\t\t\tans = ans * a % MOD;\n\t\ta = a * a % MOD;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcin >> A[i][j];\n\n\tint myi = 0;\n\tfor(int j = 0; j < m && myi < n; j++){\n\t\tfor(int i = myi; i < n; i++)\n\t\t\tif(A[i][j]){\n\t\t\t\tswap(A[i], A[myi]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(!A[myi][j])\n\t\t\tcontinue;\n\t\tfor(int i = myi; i < n; i++)\n\t\t\tfor(int jj = j; jj < m; jj++)\n\t\t\t\tA[i][jj] = A[i][jj] ^ (A[myi][jj] * A[i][j]);\n\t\tmyi++; \n\t}\n\n\tll ans = power(2, n + m - 1);\n\tll ans2 = power(2, n + m - 1 - myi);\n\tans -= ans2;\n\tif(ans < 0)\n\t\tans += MOD;\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define rollcall cout << \"I'm Sucu.\" << endl;\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define fi first\n#define se second\n// debug\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p){\n  os << \"(\" << p.first << \",\" << p.second << \")\";return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v){\n  for (auto it = v.begin();it != v.end();++it){\n    if(it != v.begin())os << \" \";os << *it;\n      }return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp){\n  for(auto x: mp)os << \"(\" << x.first << \",\" << x.second << \")\" << endl;\n  return os;\n}\ntemplate<typename T, int SIZE>\nint array_length(const T (&)[SIZE]){return SIZE;}\ntemplate<typename T, int N>\nvoid PRINTF(const T (&a)[N], int s = N, int t = -1, bool f = true){\n\tif(t == -1){rep(i,s){if(i)cout << \" \";cout << a[i];}}\n\telse repi(i,s,t){if(i!=s)cout << \" \";cout << a[i];}\n\tif(f)cout << \"\\n\";\n}\ntemplate<typename T, int N1, int N2>\nvoid PRINTF(const T (&a)[N1][N2], int h = N1, int w = N2){\n\trep(i,h){rep(j,w){cout << a[i][j] << \" \\n\"[j==w-1];}}\n}\nstring substr(const string &str, int S1, int S2 = -1){\n  if(S2 == -1)return str.substr(S1);\n  return str.substr(S1, S2-S1);\n}\n// typedef\ntypedef complex<double> Point;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nconst int mod = 998244353;\n\nvector<int> mat[400];\nvoid XOR(vi &A, vi &B){\n  int n = A.size();\n  rep(i,n)A[i] ^= B[i];\n}\n\nint Pow(int x, int n){\n  if(n < 0)n += mod-1;\n  int ans = 1;\n  while(n > 0){\n    if(n & 1)ans = (ans*x)%mod;\n    x = (x*x)%mod;\n    n >>= 1;\n  }\n  return ans;\n}\n\nint calc_rank(int h, int w){\n  int r = 0;\n  rep(j,w){\n    int pivot = -1;\n    repi(i,r,h)if(mat[i][j]){\n      pivot = i;break;\n    }\n    if(pivot == -1)continue;\n    swap(mat[pivot], mat[r]);\n    rep(i,h)if(i != r){\n      if(mat[i][j])XOR(mat[i], mat[r]);\n    }\n    r++;\n    if(r >= h)break;\n  }\n  return r;\n}\n\nsigned main(){\n  int h, w;\n  scanf(\"%lld%lld\", &h, &w);\n  rep(i,h)rep(j,w){\n    int tmp;scanf(\"%lld\", &tmp);\n    mat[i].pb(tmp);\n  }\n  int r = calc_rank(h, w);\n  int ans = mod+Pow(2, h)-Pow(2, h-r);\n  ans = (ans%mod)*Pow(2, w-1);\n  printf(\"%lld\\n\", ans%mod);\n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n[yahoo-procon2019-qual] E - Odd Subrectangles\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n\ntypedef int Number;\ntypedef vector<Number> Array;\ntypedef vector<Array> Matrix;\nconst Number eps = 0;\n\nint mat_rank(Matrix A) {\n    const int n = A.size(), m = A[0].size();\n    int r = 0;\n    for (int i = 0; r < n && i < m; ++i) {\n        int pivot = r;\n        for (int j = r + 1; j < n; ++j) {\n            if (fabs(A[j][i]) > fabs(A[pivot][i])) {\n                pivot = j;\n            }\n        }\n        swap(A[pivot], A[r]);\n        if (fabs(A[r][i]) <= eps) {\n            continue;\n        }\n        for (int k = m - 1; k >= i; --k) {\n            A[r][k] /= A[r][i];\n        }\n        for (int j = r + 1; j < n; ++j) {\n            for (int k = i; k < m; ++k) {\n                A[j][k] -= A[r][k] * A[j][i];\n            }\n        }\n        ++r;\n    }\n    return r;\n}\n\nconst ll MOD = 998244353;\n\nint N, M;\nMatrix a;\n\nll pow2(int n) {\n    ll ret = 1;\n    for (int i = 0; i < n; i++) {\n        ret = (ret << 1) % MOD;\n    }\n    return ret;\n}\n\nll solve() {\n    int r = mat_rank(a);\n    return (pow2(N + M - 1) + MOD - pow2(N + M - r - 1)) % MOD;\n}\n\nint main() {\n    cin >> N >> M;\n\n    a.resize(N);\n    for (int i = 0; i < N; i++) {\n        a[i].resize(M);\n        for (int j = 0; j < M; j++) {\n            cin >> a[i][j];\n        }\n    }\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG  // gcc\n    #define _LIBCPP_DEBUG 0 // clang\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define _GLIBCXX_DEBUG\n    // #define _LIBCPP_DEBUG 0\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check() { char bufc; if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"\\n----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\npublic:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(), last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n/* dump definition start */\n#ifdef LOCAL\n    #define dump(...) debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\", dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\n/* dump definition end */\n\n/* function utility start */\ntemplate <class T, class... types> T read(types... args) noexcept { T obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = pair<i32, i32>; using pll = pair<i64, i64>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using rheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\n/* using alias end */\n\n/* library start */\n\n#ifndef Modint_hpp\n#define Modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    static constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    constexpr modint(bool x = false) noexcept : val{x} {}\n    constexpr modint(int x) noexcept : val(x & 1) {}\n    constexpr modint(long long x) noexcept : val(x & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val &= other.val, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { assert(other.val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator-(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator*(const modint &other) const noexcept { return val && other.val; }\n    constexpr modint operator/(const modint &other) const noexcept { assert(other.val); return *this; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { assert(y.val); return x & 1 ? y : modint<2>{0}; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // Modint_hpp\n\n#ifndef Matrix_hpp\n#define Matrix_hpp\n#include <iostream>\n#include <valarray>\n#include <vector>\n\n// Field must be a field.\ntemplate <class Field>\nclass matrix\n{\n    size_t h, w;\n    using row_type = std::valarray<Field>;\n    using data_type = std::valarray<std::valarray<Field>>;\n    data_type data;\n    friend std::istream &operator>>(std::istream &is, matrix &x)\n    {\n        for(size_t i = 0; i != x.h; ++i)\n        {\n            for(size_t j = 0; j != x.w; ++j) is >> x[i][j];\n        }\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const matrix &x)\n    {\n        for(size_t i = 0; i != x.h; ++i)\n        {\n            if(i) os << \"\\n\";\n            for(size_t j = 0; j != x.w; ++j) os << (j ? \" \" : \"\") << x.data[i][j];\n        }\n        return os;\n    }\n    friend matrix transpose(const matrix &x)\n    {\n        matrix res(x.w, x.h);\n        for(size_t i = 0; i != x.w; ++i)\n            for(size_t j = 0; j != x.h; ++j)\n                res[i][j] = x.data[j][i];\n        return res;\n    }\n    friend matrix pow(matrix x, long long n)\n    {\n        assert(x.is_square());\n        matrix res{identity(x.h)};\n        while(n)\n        {\n            if(n & 1) res *= x;\n            x *= x, n >>= 1;\n        }\n        return res;\n    }\n    friend matrix inverse(const matrix &x)\n    {\n        assert(x.is_square());\n        matrix ext_x(x), e(identity(x.h)), res(x.h);\n        for(size_t i = 0; i != x.h; ++i) ext_x[i].insert(end(ext_x[i]), begin(e[i]), end(e[i]));\n        const size_t rank = ext_x.row_canonical_form().size();\n        if(rank < x.h) return {};\n        for(size_t i = 0; i != rank; ++i)\n        {\n            res[i] = std::valarray<Field>(begin(ext_x[i]) + rank, end(ext_x[i]));\n        }\n        return res;\n    }\npublic:\n    explicit matrix(size_t _n = 0) : h(_n), w(_n) { resize(_n, _n);}\n    matrix(size_t _h, size_t _w) : h(_h), w(_w) { resize(_h, _w); }\n    matrix(const data_type &_data) : h(_data.size()), w(_data.size() ? _data[0].size() : 0), data(_data) {}\n    operator data_type() const { return data; }\n    size_t height() const { return h; }\n    size_t width() const { return w; }\n    bool is_square() const { return h == w; }\n    void resize(size_t h, size_t w, const Field val = Field(0)) { data.resize(h, std::valarray<Field>(val, w)); }\n    row_type &operator[](const size_t i) { assert(i < data.size()); return data[i]; }\n    static matrix identity(const size_t n)\n    {\n        data_type data(row_type(n), n);\n        for(size_t i = 0; i != n; ++i) data[i][i] = 1;\n        return data;\n    }\n    matrix operator-() const { return {-data}; }\n    matrix &operator+=(const matrix &other) { data += other.data; return *this; }\n    matrix &operator-=(const matrix &other) { data -= other.data; return *this; }\n    matrix &operator*=(matrix other)\n    {\n        matrix res(h, other.w);\n        other = transpose(other);\n        for(size_t i = 0; i != res.h; ++i)\n            for(size_t j = 0; j != other.h; ++j)\n                res[i][j] = (data[i] * other.data[j]).sum();\n        return *this = res;\n    }\n    matrix operator+(const matrix &x) const { return matrix(*this) += x; }\n    matrix operator-(const matrix &x) const { return matrix(*this) -= x; }\n    matrix operator*(const matrix &x) const { return matrix(*this) *= x; }\n    std::vector<size_t> row_canonicalize()\n    {\n        std::vector<size_t> pivots;\n        for(size_t j = 0, rank = 0; j != w; ++j)\n        {\n            bool piv = false;\n            for(size_t i = rank; i != h; ++i)\n            {\n                if(data[i][j] != Field{0})\n                {\n                    if(piv)\n                    {\n                        const Field r = data[i][j];\n                        data[i] -= data[rank] * r;\n                        // for(size_t k = j; k != w; ++k) data[i][k] -= data[rank][k] * r;\n                    }\n                    else\n                    {\n                        swap(data[rank], data[i]);\n                        Field r = data[rank][j];\n                        data[rank] /= r;\n                        // for(size_t k = j; k != w; ++k) data[rank][k] /= r;\n                        for(size_t k = 0; k != rank; ++k)\n                        {\n                            r = data[k][j];\n                            data[k] -= data[rank] * r;\n                            // for(size_t l = j; l != w; ++l) data[k][l] -= data[rank][l] * r;\n                        }\n                        piv = true;\n                    }\n                }\n            }\n            if(piv)\n            {\n                ++rank;\n                pivots.emplace_back(j);\n            }\n        }\n        return pivots;\n    }\n    Field determinant() const\n    {\n        matrix<Field> x(*this);\n        assert(is_square());\n        size_t n = height();\n        Field res(1);\n        for(size_t j = 0; j < n; ++j)\n        {\n            bool piv = false;\n            for(size_t i = j; i < n; ++i)\n            {\n                if(x[i][j] != Field{})\n                {\n                    if(piv)\n                    {\n                        const Field r = -x[i][j];\n                        for(size_t k = j; k < n; ++k) x[i][k] += x[j][k] * r;\n                    }\n                    else\n                    {\n                        swap(x[i], x[j]);\n                        if(i != j) res = -res;\n                        const Field r = x[j][j];\n                        res *= r;\n                        for(size_t k = j; k < n; ++k) x[j][k] /= r;\n                        piv = true;\n                    }\n                }\n            }\n            if(!piv) return Field(0);\n        }\n        return res;\n    }\n};\n#endif\n\n/* library end */\n\n/* The main code follows. */\n\nusing mint=modint<998244353>;\n\nstruct solver\n{\n    solver()\n    {\n        input(int,h);\n        input(int,w);\n        input(matrix<modint<2>>,a,h,w);\n        int rank=a.row_canonicalize().size();\n        int kdim=w-rank;\n        cout << mint::pow(2,h)*(mint::pow(2,w-1)-mint::pow(2,kdim-1)) << \"\\n\";\n    }\n\n    void test()\n    {\n        matrix<int> a({{1,0},{0,-1}});\n        cout << a << \"\\n\";\n        a*=a;\n        cout << a << \"\\n\";\n        return;\n    }\n}; // struct solver\n\nint main(int argc, char *argv[])\n{\n    u32 t; // loop count\n#ifdef LOCAL\n    t = 1;\n#else\n    t = 1; // single test case\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--)\n    {\n        solver();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 305, M = 998244353;\n\nint n, m, c;\nbitset<N> b[N];\n\nint f(int x){\n    int r = 1;\n    for(; x--; ) r = r * 2 % M;\n    return r;\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 0; i < n; i++){\n        for(int j = 0, x; j < m; j++){\n            scanf(\"%d\", &x);\n            b[i][j] = x;\n        }\n    }\n    for(int i = 0; i < m; i++){\n        int k = -1;\n        for(int j = c; j < n; j++) if(b[j][i]){ k = j; break; }\n        if(k < 0) continue;\n        swap(b[c], b[k]);\n        for(int j = c + 1; j < n; j++) if(b[j][i]) b[j] ^= b[c];\n        c++;\n    }\n    printf(\"%lld\\n\", 1LL * f(n + m - 1 - c) * (f(c) + M - 1) % M);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int64_t i=0;i < (int64_t)(n);i++)\n\n#define FILE_IN \"post.in\"\n#define FILE_OUT \"post.out\"\n#define ofile freopen(FILE_IN,\"r\",stdin);freopen(FILE_OUT,\"w\",stdout)\n#define fio ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define nfio cin.tie(0);cout.tie(0)\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define ord(a,b,c) ((a>=b)and(b>=c))\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define pow2(x) (ll(1)<<x)\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pii;\ntypedef pair<ll,pii> piii;\n#define endl \"\\n\"\n#define finish(s) {cout<<s;return 0;}\n\n\nll n,m,a[310][310];\nll od[310],ev[310],bit[310],xxj[310];\nint main()\n{\n\tfio;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n \n\tint u=max(n,m);\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tll cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tif(xxj[j])\n\t\t\t\t\tfor(int k=j;k<=m;k++)\n\t\t\t\t\t\ta[i][k]^=a[xxj[j]][k];\n\t\t\t\telse {xxj[j]=i;cnt++;break;}\n\t\t\t}\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=u;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tcout<<1ll*od[cnt]*bs%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint bs[305][305];\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tint a,b,c;\n\tlong long int s=0;\n\tcin>>n>>m;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<m;j++){\n\t\t\tcin>>a;\n\t\t\ta+=bs[i+1][j]+bs[i][j+1]-bs[i][j];\n\t\t\tbs[i+1][j+1]=a%2;\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\ta=0,b=0;\n\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\tif(bs[i][k]==bs[j][k])a++;\n\t\t\t\telse b++;\n\t\t\t}\n\t\t\ts+=a*b;\n\t\t}\n\t}\n\tcout<<s<<endl;\n\treturn 0;\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 998244353;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M;\n    cin >> N >> M;\n    vvec<int> A(N,vec<int>(M));\n    for(int i=0;i<N;i++) for(int j=0;j<M;j++) cin >> A[i][j];\n    vec<mint> pow2(max(N,M)+1,1);\n    for(int i=1;i<=max(N,M);i++) pow2[i] = pow2[i-1]*2;\n    int rank = 0;\n    for(int j=0;j<M;j++){\n        bool update = false;\n        for(int i=rank;i<N;i++) if(A[i][j]){\n            swap(A[i],A[rank]);\n            update = true;\n            break;\n        }\n        if(update){\n            for(int i=0;i<N;i++) if(i!=rank && A[i][j]){\n                for(int k=j;k<M;k++) A[i][k] ^= A[rank][k];\n            }\n            rank++;\n        }\n    }\n    cout << pow2[N-1]*(pow2[M]-pow2[M-rank]) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 301;\n\nint n, m, pow2[N], mod = 998244353;\nvector <bitset <N> > b;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    pow2[0] = 1;\n    for(int i = 1 ; i < N ; i++){\n        pow2[i] = 2 * pow2[i - 1] % mod;\n    }\n    cin >> n >> m;\n    b.resize(n);\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            int x;\n            cin >> x;\n            if(x) b[i].set(j);\n        }\n    }\n    vector <int> vis(n);\n    int h = n;\n    for(int j = 0 ; j < m ; j++){\n        int idx = -1;\n        for(int i = 0 ; i < n ; i++){\n            if(vis[i]) continue;\n            if(b[i][j]) idx = i;\n        }\n        if(idx == -1) continue;\n        vis[idx] = 1;\n        h--;\n        for(int i = 0 ; i < n ; i++){\n            if(vis[i]) continue;\n            if(b[i][j]) b[i] ^= b[idx];\n        }\n    }\n    cout << 1LL * pow2[m - 1] * (pow2[n] - pow2[h] + mod) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VVI a(n, VI(m));\n    REP(i,n) REP(j,m) a[i][j] = in();\n\n    int r = 0;\n    REP(i,min(n, m)){\n        int j = -1;\n        FOR(k,i,n-1){\n            if (a[k][i]){\n                j = k;\n                break;\n            }\n        }\n        if (j == -1) break;\n        r = i + 1;\n        swap(a[i], a[j]);\n        FOR(j,i+1,n-1){\n            if (!a[j][i]) continue;\n            FOR(k,i,m-1) a[j][k] ^= a[i][k];\n        }\n    }\n\n    ll ans = powll(2, m - 1) * (powll(2, n) - powll(2, n - r) + mod) % mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <iostream>\nusing namespace std;\n\nlong long modexp(int x, long long e, int m) {\n    long long ans = 1, p = x % m;\n    while (e > 0) {\n        if (e % 2 != 0) ans = (ans * p) % m;\n        p = (p * p) % m;\n        e >>= 1;\n    }\n    return ans;\n}\n\nclass ModComb {\n    long long *fact, *facti;\n    const int mod;\npublic:\n    explicit ModComb(int n, int m) : mod(m) {\n        fact = new long long[n+1];\n        facti = new long long[n+1];\n        fact[0] = 1; facti[0] = 1;\n        for (int i = 1; i <= n; i++) fact[i] = (fact[i-1] * i) % m;\n        // calc 1/n!\n        long long &inv = facti[n], pw = fact[n];\n        inv = 1;\n        for (int e = mod-2; e > 0; e /= 2) {\n            if (e&1) inv = inv * pw % mod;\n            pw = pw * pw % mod;\n        }\n        for (int i = n-1; i > 0; i--) facti[i] = (facti[i+1] * (i+1)) % m;\n    }\n\n    ~ModComb() {\n        if (fact) delete[] fact;\n        if (facti) delete[] facti;\n    }\n\n    long long getFact(int n) const {\n        return n < 0 ? 0 : fact[n];\n    }\n\n    long long getFactInv(int n) const {\n        return n < 0 ? 0 : facti[n];\n    }\n\n    long long getComb(int n, int k) const {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return fact[n] * facti[k] % mod * facti[n-k] % mod;\n    }\n\n    long long getPerm(int n, int k) const {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return fact[n] * facti[n-k] % mod;\n    }\n};\n\n\nint main() {\n    int n, m; cin >> n >> m;\n    bitset<300> a[n];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            int x; cin >> x;\n            if (x == 1) a[i][j] = true;\n        }\n\n    // int expect = 0;\n    // for (int s = 0; s < 1<<n; s++)\n    //     for (int t = 0; t < 1<<m; t++) {\n    //         int sum = 0;\n    //         for (int i = 0; i < n; i++)\n    //             for (int j = 0; j < m; j++)\n    //                 if (((s >> i) & 1) && ((t >> j) & 1) && a[i][j])\n    //                     sum++;\n    //         if (sum % 2) expect++;\n    //     }\n\n    int r = 0;\n    for (int j = 0; j < m; j++) {\n        for (int i = r; i < n; i++)\n            if (a[i][j]) {\n                for (int ii = i+1; ii < n; ii++)\n                    if (a[ii][j]) a[ii] ^= a[i];\n                swap(a[i], a[r]);\n                r++;\n                break;\n            }\n    }\n\n    long long ans = 0;\n    const int M = 998244353;\n    ModComb mc(300, M);\n    for (int k = 1; k <= r; k += 2)\n        ans += mc.getComb(r, k) * modexp(3, r-k, M) % M;\n    ans = ans % M * modexp(2, (n - r) + (m - r), M) % M;\n    cout << ans << endl;\n\n    // if (ans == expect) cerr << \"OK\\n\";\n    // else cerr << \"WA; expect \" << expect << \", got \" << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nint Gauss(vector<vector<int>> &mat) {\n    int n = mat.size(), m = mat.size();\n  \tint r = 0, c = 0;\n\tfor(; r < n && c < m; r ++, c ++){\n\t\tint p = -1;\n\t\tREPP(i, r, n-1) if(mat[i][c]){ p = i; break; }\n\t\tif(p == -1){ r --; continue; }\n\t\tif(p != r) swap(mat[r], mat[p]);\n\t\tREPP(i, r + 1, n-1) if(mat[i][c])\n\t\t\tfor(int j = m-1 ; j >= c ; j--)  mat[i][j] ^= mat[r][j];\n\t}\n\treturn r;\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int32_t M=998244353;\nint32_t rev(int32_t x,int32_t m){\n    if(x==1)return 1;\n    return (1-(ll)rev(m%x,x)*m)/x+m;\n}\nstruct mint{\n    int32_t x;\n    mint():x(0){}\n    mint(int32_t xx):x(xx%M){if(x<0)x+=M;}\n    mint(ll xx):x(xx%M){if(x<0)x+=M;}\n    mint& operator+=(mint b){if((x+=b.x)>=M)x-=M;return *this;}\n    mint operator+(mint b){mint res=*this;res+=b;return res;}\n    mint& operator-=(mint b){if((x-=b.x)<0)x+=M;return *this;}\n    mint operator-(mint b){mint res=*this;res-=b;return res;}\n    mint& operator*=(mint b){x=(ll)x*b.x%M;return *this;}\n    mint operator*(mint b){mint res=*this;res*=b;return res;}\n    mint inverse(){return rev(x,M);}\n    mint& operator/=(mint b){x=(ll)x*rev(b.x,M)%M;return *this;}\n    mint operator/(mint b){mint res=*this;res/=b;return res;}\n    mint operator^(ll w) {mint r=1,a=*this;while(w){if(w&1)r*=a;a*=a;w/=2;}return r;}\n    mint operator^=(ll w){return *this=(*this)^w;}\n    mint operator^(mint w){return *this^w.x;}\n    mint operator^=(mint w){return *this=(*this)^w;}\n    mint operator-()const{return mint()-*this;}\n    explicit operator bool()const{return x;}\n};\nistream&operator>>(istream&is,mint&p){istream&res=is>>p.x;p.x%=M;return res;}\nostream&operator<<(ostream&os,mint p){return os<<p.x;}\ntemplate<typename T>mint operator+(T x,mint y){return mint(x)+y;}\ntemplate<typename T>mint operator-(T x,mint y){return mint(x)-y;}\ntemplate<typename T>mint operator*(T x,mint y){return mint(x)*y;}\ntemplate<typename T>mint operator/(T x,mint y){return mint(x)/y;}\ntemplate<typename T>mint operator^(T x,mint y){return mint(x)^y;}\nmint abs(mint x){return x;}\nconst int N=303;\nbitset<N> a[N];\nbitset<N> bas[N];\nbool u[N];\nint ad(bitset<N> x){\n    for(int i=N-1;i>=0;--i){\n        if(x.test(i)){\n            if(u[i]){\n                x^=bas[i];\n            }else{\n                bas[i]=x;\n                u[i]=1;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\nint32_t main(){\n    int n,m;\n    cin>>n>>m;\n    forn(i,n){\n        forn(j,m){\n            int x;\n            cin>>x;\n            if(x)a[i].set(j);\n        }\n    }\n    int rk=0;\n    forn(i,n){\n        rk+=ad(a[i]);\n    }\n    mint cnt=mint(2)^(n-rk);\n    mint all=mint(2)^n;\n    mint p1=all-cnt;\n    mint p2=mint(2)^(m-1);\n    cout<<p1*p2<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nint a[305][305];\n\nvoid GaussianElimination(int mat[305][305], int w, int h)\n{\n\tint r = 0;\n\tfor(int i = 0; i < w && r < h; i++){\n\t\tif(mat[i][r] == 0){\n\t\t\tint max_val = 0, max_j;\n\t\t\tfor(int j = r+1; j < h; j++){\n\t\t\t\tif(mat[j][i] > max_val){\n\t\t\t\t\tmax_val = mat[j][i];\n\t\t\t\t\tmax_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max_val == 0) goto end;\n\t\t\tswap(r, max_j);\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < h; j++){\n\t\t\tif(j == r) continue;\n\t\t\tif(mat[j][i] == 0) continue;\n\t\t\tfor(int k = 0; k <= w; k++){\n\t\t\t\tmat[j][k] ^= mat[r][k];\n\t\t\t}\n\t\t}\n\t\tr++;\n\t\tend:;\n\t}\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\t\n\tGaussianElimination(a, w, h);\n\t\n\tllint rank = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tbool flag = false;\n\t\tfor(int j = 0; j < w; j++) if(a[i][j]) flag = true;\n\t\tif(flag) rank++;\n\t}\n\t\n\tllint tmp = 1, tmp2 = 1;\n\tfor(int i = 0; i < h-rank; i++) tmp *= 2, tmp %= mod;\n\tfor(int i = 0; i < h; i++) tmp2 *= 2, tmp2 %= mod;\n\tllint ans = (tmp2 - tmp + mod) % mod;\n\tfor(int i = 0; i < w-1; i++) ans *= 2, ans %= mod;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\nconst int N = 300, MOD = 998244353;\n\nint m, n, u;\nlong long ans = 1;\nvector<bitset<N>> eli;\n\nlong long pw(int p)\n{\n    long long ret = 1;\n    for (int i = 0; i < p; i++)\n        (ret *= 2) %= MOD;\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &m, &n);\n    for (int i = 0; i < m; i++)\n    {\n        bitset<N> cur;\n        for (int j = 0; j < n; j++)\n        {\n            scanf(\"%d\", &u);\n            cur.set(j, u);\n        }\n        for (bitset<N> &v : eli)\n            if (cur.test(v._Find_first()))\n                cur ^= v;\n        if (cur._Find_first() < N)\n        {\n            eli.push_back(cur);\n            for (int j = cur.size() - 1; j > 0; j--)\n                if (eli[j]._Find_first() < eli[j - 1]._Find_first())\n                    swap(eli[j], eli[j - 1]);\n                else\n                    break;                \n        }\n    }\n    printf(\"%lld\", 1LL * (pw(m) - pw(m - eli.size()) + MOD) * pw(n - 1) % MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 998244353;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<LL>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\n\ntemplate<class T>struct matrix {\n\tint n = 0, m = 0;\n\tvector<vector<T>>mat;\n\tmatrix() {}\n\tmatrix(int _n) {\n\t\tmat.resize(_n);\n\t\tfor (int i = 0; i < _n; i++)\n\t\t\tmat[i].resize(_n);\n\t\tn = _n;\n\t\tm = _n;\n\t}\n\tmatrix(int _n, int _m) {\n\t\tmat.resize(_n);\n\t\tfor (int i = 0; i < _n; i++)\n\t\t\tmat[i].resize(_m);\n\t\tn = _n;\n\t\tm = _m;\n\t}\n\tint GetRank() {\n\t\tint h = mat.size(), w = mat[0].size();\n\t\tint res = 0, now = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tT ma = 0.0;\n\t\t\tint pivot;\n\t\t\tfor (int j = i; j < h; j++) {\n\t\t\t\tif (mat[j][now] > ma) {\n\t\t\t\t\tma = mat[j][now];\n\t\t\t\t\tpivot = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ma == 0.0) {\n\t\t\t\tnow++;\n\t\t\t\tif (now == w) break;\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pivot != i) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tswap(mat[i][j], mat[pivot][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tT tmp = 1.0 / mat[i][now];\n\t\t\tfor (int j = 0; j < w; j++) mat[i][j] *= tmp;\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tT tmp2 = mat[j][now];\n\t\t\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\t\t\tmat[j][k] -= mat[i][k] * tmp2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n\tbool Inv(matrix<T> &inv) {\n\t\tassert(mat.size() == mat[0].size() && inv.n == inv.m);\n\t\tint n = mat.size();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tinv.mat[i][j] = (i == j ? 1.0 : 0.0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tT ma = 0.0;\n\t\t\tint pivot;\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tif (mat[j][i] > ma) {\n\t\t\t\t\tma = mat[j][i];\n\t\t\t\t\tpivot = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ma == 0.0) return false;\n\t\t\tif (pivot != i) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tswap(mat[i][j], mat[pivot][j]);\n\t\t\t\t\tswap(inv.mat[i][j], inv.mat[pivot][j]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tT tmp = 1.0 / mat[i][i];\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tmat[i][j] *= tmp;\n\t\t\t\tinv.mat[i][j] *= tmp;\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tT tmp2 = mat[j][i];\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tmat[j][k] -= mat[i][k] * tmp2;\n\t\t\t\t\t\tinv.mat[j][k] -= inv.mat[i][k] * tmp2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tmatrix<T> operator+(const matrix<T> &b) {\n\t\tassert(mat.size() == b.n && mat[0].size() == b.m);\n\t\tint h = mat.size(), w = mat[0].size();\n\t\tmatrix<T> c(h, w);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tc.mat[i][j] = mat[i][j] + b.mat[i][j];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> operator-(const matrix<T> &b) {\n\t\tassert(mat.size() == b.n&& mat[0].size() == b.m);\n\t\tint h = mat.size(), w = mat[0].size();\n\t\tmatrix<T> c(h, w);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tc.mat[i][j] = mat[i][j] - b.mat[i][j];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> operator*(const matrix<T> b) {\n\t\tassert(mat[0].size() == b.n);\n\t\tmatrix<T> c(mat.size(), b.m);\n\t\tfor (int i = 0; i < mat.size(); i++) {\n\t\t\tfor (int k = 0; k < b.n; k++) {\n\t\t\t\tfor (int j = 0; j < b.m; j++) {\n\t\t\t\t\tc.mat[i][j] = (c.mat[i][j] + mat[i][k] * b.mat[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> operator*(T b) {\n\t\tmatrix<T> c(mat.size(), mat[0].size());\n\t\tfor (int i = 0; i < mat.size(); i++) {\n\t\t\tfor (int j = 0; j < mat[0].size(); j++) {\n\t\t\t\tc.mat[i][j] = mat[i][j] * b;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> Pow(long long n) {\n\t\tassert(mat.size() == mat[0].size());\n\t\tmatrix<T> b(mat.size()), c(mat.size());\n\t\tc = *this;\n\t\tfor (int i = 0; i < mat.size(); i++) {\n\t\t\tb.mat[i][i] = 1;\n\t\t}\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) b = b * c;\n\t\t\tc = c * c;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn b;\n\t}\n\tT det() {\n\t\tT det = 1.0, buf;\n\t\t//三角行列を作成\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tif (i<j) {\n\t\t\t\t\tbuf = mat[j][i] / mat[i][i];\n\t\t\t\t\tfor (int k = 0; k<n; k++) {\n\t\t\t\t\t\tmat[j][k] -= mat[i][k] * buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//対角部分の積\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tdet *= mat[i][i];\n\t\t}\n\t\treturn det;\n\t}\n\tmatrix<T> rev() {\n\t\tmatrix<T> inv_a(n, m), cp(n, m);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tinv_a.mat[i][j] = mat[i][j];\n\t\t\t\tcp.mat[i][j] = mat[i][j];\n\t\t\t}\n\t\tT buf;\n\t\t//単位行列を作る\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tinv_a.mat[i][j] = (i == j) ? 1.0 : 0.0;\n\t\t\t}\n\t\t}\n\t\t//掃き出し法\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tbuf = 1 / cp.mat[i][i];\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tcp.mat[i][j] *= buf;\n\t\t\t\tinv_a.mat[i][j] *= buf;\n\t\t\t}\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tbuf = cp.mat[j][i];\n\t\t\t\t\tfor (int k = 0; k<n; k++) {\n\t\t\t\t\t\tcp.mat[j][k] -= cp.mat[i][k] * buf;\n\t\t\t\t\t\tinv_a.mat[j][k] -= inv_a.mat[i][k] * buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn inv_a;\n\t}\n};\nint calc_rank(matrix<LL> &A) {\n\tint r = 0;\n\tfor (int i = 0; i < A.m; ++i) {\n\t\tint pivot = -1;\n\t\tfor (int j = r; j < A.n; ++j) {\n\t\t\tif (A.mat[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot != -1) {\n\t\t\tswap(A.mat[pivot], A.mat[r]);\n\t\t\tfor (int j = 0; j < A.n; ++j)\n\t\t\t\tif (j != r && A.mat[j][i])\n\t\t\t\tfor(int k=0;k<A.m;k++)  A.mat[j][k] ^= A.mat[r][k];\n\t\t\t++r;\n\t\t}\n\t}\n\treturn r;\n}\nLL n, m, s, t, h, w,mpow[810];\nint main() {\n\tcin >> n >> m;\n\tmpow[0] = 1;\n\trep(i, 800)mpow[i + 1] = mpow[i] * 2 % MOD;\n\tmatrix<LL>mat(n, m);\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tcin >> mat.mat[i][j];\n\t\t}\n\t}\n\tLL r = calc_rank(mat);\n\tcout << (mpow[n + m - 1] - mpow[n + m - r - 1] + MOD) % MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 998244353;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\nclass Solver2 {\n public:\n  int n, m;\n  vector<vector<int>> a;\n  Solver2(LL n, LL m) : n(n), m(m), a(n, vector<int>(m)){};\n\n  int sweep(vector<vector<int>> X) {\n    int rank = 0;\n    for (int col = 0; col < m; ++col) {\n      int nonzeroRow = -1;\n      for (int r = rank; r < n; ++r) {\n        if (X[r][col]) {\n          nonzeroRow = r;\n          break;\n        }\n      }\n      if (nonzeroRow == -1) continue;\n      swap(a[rank], a[nonzeroRow]);\n      for (int r = rank + 1; r < n; ++r) {\n        if (X[r][col]) {\n          for (int c = col; c < m; ++c) {\n            X[r][c] ^= X[rank][c];\n          }\n        }\n      }\n      rank++;\n    }\n    return rank;\n  }\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        cin >> a[i][j];\n      }\n    }\n    int rank = sweep(a);\n    if (rank == 0)\n      cout << 0 << endl;\n    else\n      cout << (Modint<>(2).mpow(rank) - 1) * Modint<>(2).mpow(n - rank) * Modint<>(2).mpow(m - 1) << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mo 998244353\n#define N 310\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nint a[N][N],p[N][N];\nint m,n,sum;\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nint main(){\n\tread(n);read(m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)read(a[i][j]);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=m;j>=1;j--){\n\t\t\tif (p[j][j]==0){\n\t\t\t\tif (a[i][j]==1){\n\t\t\t\t\tfor (int k=1;k<=m;k++) p[j][k]=a[i][k];\n\t\t\t\t\tsum++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor (int k=1;k<=m;k++) a[i][k]^=p[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<((po(2,m)-po(2,m-sum)+mo)%mo)*po(2,n-1)%mo<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\n\nint compute_rank(vector< vector< ll > > A) {\n    int n = A.size();\n    int m = A[0].size();\n    // cout << n << \" \" << m << endl;\n    int rank = n;\n    vector<bool> row_selected(n, false);\n    for (int i = 0; i < m; ++i) {\n        int j;\n        for (j = 0; j < n; ++j) {\n            if (!row_selected[j] && A[j][i])\n                break;\n        }\n\n        if(j != n){\n            row_selected[j] = true;\n            for (int p = i + 1; p < m; ++p)\n                A[j][p] /= A[j][i];\n            \n            A[j][i] = 1;\n\n            for (int k = 0; k < n; ++k) {\n                if (k != j && A[k][i]) {\n                    for (int p = i + 1; p < m; ++p)\n                        A[k][p] -= A[j][p] * A[k][i];\n\n                    A[k][i] = 0;\n                }\n            }\n        }\n    }\n\n    for(int i = 0 ; i < n ; i++){\n        bool has_one = false;\n\n        for(int j = 0 ; j < m ; j++){\n            if(A[i][j]){\n                has_one = true;\n                break;\n            }\n        }\n\n        if(!has_one){\n            rank--;\n        }\n    }\n\n    return rank;\n}\n\nvector< vector< ll > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            ll x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = compute_rank(a);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n);\n    ll nr = fast_pow(2LL, n - rank);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD((nn - nr) * mm) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 998244353;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\nclass Solver2 {\n public:\n  int n, m;\n  vector<vector<int>> a;\n  Solver2(LL n, LL m) : n(n), m(m), a(n, vector<int>(m)){};\n\n  int sweep(vector<vector<int>> X) {\n    int rank = 0;\n    for (int col = 0; col < m; ++col) {\n      int nonzeroRow = -1;\n      for (int r = rank; r < n; ++r) {\n        if (X[r][col]) {\n          nonzeroRow = r;\n          break;\n        }\n      }\n      if (nonzeroRow == -1) continue;\n      if (nonzeroRow > rank) swap(a[rank], a[nonzeroRow]);\n      for (int r = rank + 1; r < n; ++r) {\n        if (X[r][col]) {\n          for (int c = col; c < m; ++c) {\n            X[r][c] ^= X[rank][c];\n          }\n        }\n      }\n      rank++;\n    }\n    return rank;\n  }\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        cin >> a[i][j];\n      }\n    }\n    int rank = sweep(a);\n    if (rank == 0)\n      exit(0);\n    //cout << 0 << endl;\n    else\n      cout << (Modint<>(2).mpow(rank) - 1) * Modint<>(2).mpow(n - rank) * Modint<>(2).mpow(m - 1) << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define MOD 998244353\ntypedef long long ll;\nusing namespace std;\n\nint N,M;\nint A[303][303];\n\nint Gauss(){\n    int rank=0;\n    for(int j=0;j<M;j++){\n        int pivot=-1;\n        for(int i=rank;i<N;i++){\n            if(A[i][j]){\n                pivot=i;\n                break;\n            }\n        }\n\n        if(pivot>=0){\n            if(pivot!=rank){\n                for(int k=0;k<M;k++) swap(A[pivot][k],A[rank][k]);\n            }\n            for(int i=rank+1;i<N;i++){\n                if(A[i][j]){\n                    for(int k=0;k<M;k++) A[i][k]^=A[rank][k];\n                }\n            }\n            rank++;\n        }\n    }\n    return rank;\n}\n\nll my_pow(ll x,ll n){\n    ll res=1;\n    while(n>0){\n        if(n&1) res=res*x%MOD;\n        x=x*x%MOD;\n        n/=2;\n    }\n    return res;\n}\n\nint main(){\n  cin>>N>>M;\n  for(int i=0;i<N;i++) for(int j=0;j<M;++j) cin>>A[i][j];\n\n  int rank=Gauss();\n\n  cout<<my_pow(2ll,N-1+M)-my_pow(2ll,N-1+M-rank)<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// by tmt514\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#define SZ(x) ((int)(x).size())\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 998244353;\nLL bigmod(LL a, LL n) {\n  if(n==0) return 1;\n  if(n==1) return a%MOD;\n  return bigmod(a*a%MOD, n/2) * (n%2? a:1)%MOD;\n}\nint main(void) {\n  int n, m;\n  int a[305][305] = {};\n  cin >> n >> m;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      cin >> a[i][j];\n  int rank=0;\n  for(int i=0;i<n && i<m;i++) {\n    int g=-1;\n    for(int j=i;j<n;j++)\n      if(a[j][i]==1) {\n        g=j;\n        break;\n      }\n    if(g>=0) {\n      for(int k=i;k<m;k++)\n        swap(a[i][k], a[g][k]);\n      for(int j=i+1;j<n;j++)\n        for(int k=i;k<m;k++)\n          a[j][k] ^= a[i][k];\n      ++rank;\n    }\n  }\n  LL t = bigmod(2, m-1) * (bigmod(2, n) - bigmod(2, n-rank)) % MOD;\n  t=(t+MOD)%MOD;\n  cout << t << endl;\n  \n      \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int Mx = 300;\nconst int mod = 998244353;\nll p2[Mx + 1];\n\ntypedef bitset<Mx> * It;\n\nbool bsLess(const bitset<Mx> &b1, const bitset<Mx> &b2) {\n\tfor (int i = Mx - 1; i >= 0; --i)\n\t\tif (b1[i] != b2[i])\n\t\t\treturn b1[i] < b2[i];\n\treturn false;\n}\n\nll f(It first, It last, const int pos) {\n\tif (pos < 0 || first == last)\n\t\treturn p2[last - first];\n\n\tIt pLast = prev(last);\n\tif ((*pLast)[pos] == 0)\n\t\treturn f(first, last, pos - 1);\n\tfor (It it = first; it < pLast; ++it)\n\t\tif ((*it)[pos])\n\t\t\t*it ^= *pLast;\n\treturn f(first, pLast, pos - 1);\n}\n\nbitset<Mx> a[300];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i <= Mx; ++i)\n\t\tp2[i] = (p2[i - 1] * 2) % mod;\n\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\ta[i][j] = x;\n\t\t}\n\n\tsort(a, a + n, bsLess);\n\tll res = f(a, a + n, m - 1);\n\tcerr << res << endl;\n\tres = (p2[n] - res) * p2[m - 1];\n\tcout << (res % mod + mod) % mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 300;\nconst int MOD = 998244353;\nbitset<N> a[N]; \nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile(k) {\n\t\tif(k&1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD; \n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = m-1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t) a[i].set(j);\n\t\t}\n\t}\n \tfor (int i = 0; i < n; i++) {\n \t\tfor (auto b : base) {\n \t\t\tauto bb = b^a[i];\n \t\t\tfor (int j = m-1; j >= 0; j--) {\n \t\t\t\tif(bb[j] < a[i][j]) {\n \t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t }\n\t\t\t}\n\t\t }\t\n\t\t if(a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", (q_pow(2, n+m-1) - q_pow(2, n+m-1-cnt) + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define bp __builtin_popcountll\n#define pb push_back\n#define in(s) freopen(s, \"r\", stdin);\n#define out(s) freopen(s, \"w\", stdout);\n#define inout(s, end1, end2) freopen((string(s) + \".\" + end1).c_str(), \"r\", stdin),\\\n\t\tfreopen((string(s) + \".\" + end2).c_str(), \"w\", stdout);\n#define fi first\n#define se second\n#define bw(i, r, l) for (int i = r - 1; i >= l; i--)\n#define fw(i, l, r) for (int i = l; i < r; i++)\n#define fa(i, x) for (auto i: x)\nusing namespace std;\nconst int mod = 998244353, inf = 1061109567;\nconst long long infll = 4557430888798830399;\nconst int N = 305;\nint n, m, a[N][N], cnt[N], pw[N], equation[N][N], ans[N];\nvoid add(int &x, int y) {\n\tx += y; if (x >= mod) x -= mod;\n}\nvoid rem(int &x, int y) {\n\tx -= y;\n\tif (x < 0) x += mod;\n}\nint mul(int x, int y) {\n\treturn 1ll * x * y % mod;\n}\nsigned main() {\n\t#ifdef BLU\n\tin(\"blu.inp\");\n\t#endif\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tpw[0] = 1;\n\tfw (i, 1, N) pw[i] = mul(pw[i - 1], 2);\n\tcin >> n >> m;\n\tfw (i, 0, n) {\n\t\tfw (j, 0, m) cin >> a[i][j];\n\t}\n\t//Fix subset of rows, if there is at least 1 odd column answer is 2 ^ (m - 1), else 0.\n\t//Count subset of rows that there are no odd columns. Use Gauss.\n\tfw (j, 0, m) ans[j] = 0;\n\tfw (j, 0, m) {\n\t\tfw (i, 0, n) equation[j][i] = a[i][j];\n\t}\n\tint cnt = 1, ptr = 0;\n//\tfw (lol, 0, m) {\n//\t\tcout << \"Equation \" << lol << \": \";\n//\t\tfw (lol2, 0, n) cout << equation[lol][lol2] << \" \";\n//\t\tcout << \"\\n\";\n//\t}\n\tfw (i, 0, n) {\n//\t\tcout << \"Variable \" << i << \"\\n\";\n\t\tbool have1 = 0;\n\t\tfw (j, ptr, m) if (equation[j][i]) have1 = 1;\n\t\tif (have1) {\n\t\t\tfw (j, ptr, m) if (equation[j][i]) {\n\t\t\t\tfw (k, 0, n) swap(equation[j][k], equation[ptr][k]);\n\t\t\t\tswap(ans[j], ans[ptr]);\n//\t\t\t\tcout << \"swap equation \" << j << \" with \" << ptr << \"\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfw (j, ptr + 1, m) if (equation[j][i]) {\n\t\t\t\tfw (k, 0, n) equation[j][k] ^= equation[ptr][k];\n\t\t\t\tans[j] ^= ans[ptr];\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n//\t\tfw (lol, 0, m) {\n//\t\t\tcout << \"Equation \" << lol << \": \";\n//\t\t\tfw (lol2, 0, n) cout << equation[lol][lol2] << \" \";\n//\t\t\tcout << \"\\n\";\n//\t\t}\n\t}\n\tcnt = pw[n - ptr];\n\tcnt = pw[n] - cnt;\n\tcnt = mul(cnt, pw[m - 1]);\n\tcout << cnt;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MOD = 998244353;\nconst int kN = 300 + 5;\nint n, m;\nint a[kN][kN];\n\nint power(int a, int b) {\n  int ret = 1;\n  while (b) {\n    if (b & 1) ret = ret * 1LL * a % MOD;\n    a = a * 1LL * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nint gauss() {\n  int ret = 0;\n  for (int i = 0, p = 0; i < n; ++ i) {\n    int k = -1;\n    while (k == -1 && p != n) {\n      for (int j = i; j < n; ++ j) {\n        if (a[j][p]) {\n          k = j;\n          break;\n        }\n      }\n      if (k == -1) {\n        ++ p;\n      }\n    }\n    if (k == -1) break;\n    ret ++;\n    for (int r = 0; r < n; ++ r)\n      std::swap(a[i][r], a[k][r]);\n    for (int w = i + 1; w < n; ++ w) {\n      if (a[w][p]) {\n        for (int r = 0; r < n; ++ r)\n          a[w][r] ^= a[i][r];\n      }\n    }\n    ++ p;\n  }\n  return ret;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++ i) {\n    for (int j = 0; j < m; ++ j) {\n      scanf(\"%d\", &a[i][j]);\n    }\n  }\n  int rank = gauss();\n  int result = (power(2, n) - power(2, n - rank) + MOD) % MOD * 1LL * power(2, m - 1) % MOD;\n  printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\ntypedef long long ll;\nusing namespace std;\n\nint a[310][310];\nll mod=998244353, beki[310];\n\nint main(void){\n    int N, M;\n    cin >> N >> M;\n    for(int i=0; i<N; ++i){\n        for(int j=0; j<M; ++j){\n            cin >> a[i][j];\n        }\n    }\n    beki[0]=1;\n    for(int i=1; i<310; ++i){\n        beki[i]=(beki[i-1]*2)%mod;\n    }\n    int cnt=0;\n    for(int i=0; i<N; ++i){\n        int piv=cnt;\n        while(piv<M){\n            if(a[i][piv]==1) break;\n            ++piv;\n        }\n        if(piv<M){\n            for(int j=0; j<N; ++j){\n                swap(a[j][cnt], a[j][piv]);\n            }\n            for(int j=cnt+1; j<M; ++j){\n                if(a[i][j]==1){\n                    for(int k=0; k<N; ++k){\n                        a[k][j] ^= a[k][cnt];\n                    }\n                }\n            }\n            ++cnt;\n        }\n    }\n    ll ans=(beki[M]+mod-beki[M-cnt])%mod;\n    (ans *= beki[N-1]) %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <functional>\n#include <set>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int N = 310, P = 998244353;\n\nint n, m;\nbitset<N> bas[N];\nbool vis[N];\n\nint mpow(int x, int k, int p = P) {\n  int ret = 1;\n  while (k) {\n    if (k & 1)\n      ret = ret * (ll)x % p;\n    x = x * (ll)x % p;\n    k >>= 1;\n  }\n  return ret;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n\n  scanf(\"%d%d\", &n, &m);\n  int dim = 0;\n  for (int i = 1; i <= n; ++i) {\n    bitset<N> cur;\n    for (int j = 1; j <= m; ++j) {\n      int x;\n      scanf(\"%d\", &x);\n      cur[j] = x;\n    }\n    for (int j = 1; j <= m; ++j)\n      if (cur[j])\n        if (!vis[j]) {\n          bas[j] = cur;\n          vis[j] = true;\n          ++dim;\n          break;\n        } else\n          cur ^= bas[j];\n  }\n  int ans = mpow(2, n + m - 1) - mpow(2, n - dim + m - 1);\n  if (ans < 0)\n    ans += P;\n  printf(\"%d\\n\", ans);\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void read(T &x)\n{\n    x=0; char c=getchar();  int f=1;\n    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\n#include <bitset>\nconst int mod=998244353;\nll Pow(ll x,ll y){ll res=1; while(y){if(y&1) res=res*x%mod; x=x*x%mod,y>>=1;} return res;}\nbitset<310> f[310];\nint n,m;\nint main()\n{\n\tint x; read(n),read(m);\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j) read(x),f[i][j]=x;\n\tint ans=0;\n\tfor(int i=0;i<m;++i)\n\t{\n\t\tfor(int j=i;j<m;++j) if(f[j][i]){if(j!=i)swap(f[i],f[j]); break;}\n\t\tif(!f[i][i]){ans++; continue;}\n\t\tfor(int j=i+1;j<m;++j) if(f[j][i]) f[j]^=f[i];\n\t}\n\tprintf(\"%lld\",((Pow(2,m+n-1)-Pow(2,ans+n-1))%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// binary 行列 (行列累乗と、掃き出し法)\n//\n// verified:\n//   みんなのプロコン 2019 E - Odd Subrectangles\n//     https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n// \n\n\n#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n\nconst int MAX_ROW = 510; // to be set appropriately\nconst int MAX_COL = 510; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nostream& operator << (ostream& s, BitMatrix A) {\n    s << endl; \n    for (int i = 0; i < A.H; ++i) {\n        for (int j = 0; j < A.W; ++j) {\n            s << A[i][j] << \", \";\n        }\n        s << endl;\n    }\n    return s;\n}\n\ninline BitMatrix operator * (BitMatrix A, BitMatrix B) {\n    BitMatrix R(A.H, B.W);\n    BitMatrix tB(B.W, B.H);\n    for (int i = 0; i < tB.H; ++i) for (int j = 0; j < tB.W; ++j) tB[i][j] = B[j][i];\n    for (int i = 0; i < R.H; ++i) for (int j = 0; j < R.W; ++j) R[i][j] = (A[i] & tB[j]).any();\n    return R;\n}\n\ninline BitMatrix pow(BitMatrix A, long long n) {\n    BitMatrix R(A.H, A.H);\n    for (int i = 0; i < A.H; ++i) R[i][i] = 1;\n    while (n > 0) {\n        if (n & 1) R = R * A;\n        A = A * A;\n        n >>= 1;\n    }\n    return R;\n}\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return rank;\n};\n\n\nconst int MOD = 998244353;\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() { \n    int N, M; cin >> N >> M;\n    BitMatrix A(N, M);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            int a; cin >> a;\n            if (a) A[i][j] = 1;\n        }\n    }\n    vector<int> res;\n    int r = GaussJordan(A);  \n    cout << (modpow(2LL, N+M-1, MOD) - modpow(2LL, N+M-r-1, MOD) + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nll power_mod(ll a,ll b,ll mod) {\n    if (b == 1) return a;\n    ll c = power_mod(a,b/2,mod);\n    if (b%2) return c*c%mod*a%mod;\n    else return c*c%mod;\n}\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    bool a[n][m];\n    int r = 0;\n    for (int i = 0;i < n;++i) for (int j = 0;j < m;++j) cin >> a[i][j];\n    for (int i = 0;i < min(n,m);++i) {\n        int p = i,q = i;\n        for (int j = i;j < n;++j) {\n            if (a[p][q]) break;\n            for (int k = i;k < m;++k) if (a[j][k]) {\n                p = j;q = k;\n                break;\n            }\n        }\n        if (!a[p][q]) break;\n        r = i+1;\n        for (int j = i;j < n;++j) swap(a[j][i],a[j][q]);\n        for (int j = i;j < m;++j) swap(a[i][j],a[p][j]);\n        for (int j = i+1;j < n;++j) if (a[j][i]) for (int k = i;k < m;++k) a[j][k] ^= a[i][k];\n        for (int j = i+1;j < m;++j) if (a[i][j]) for (int k = i;k < n;++k) a[k][j] ^= a[k][i];\n    }\n    cout << (power_mod(2,n+m-1,mod)-power_mod(2,n+m-r-1,mod)+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=998244353;\nlong long n,m,a[333][333],pw[666],cnt,pos,cur,upper;\nlong long Guass(long long Row,long long Column)\n{\n    long long row=1,col=1,max_r;\n    for(row=1;row<=Row&&col<=Column;row++,col++)\n    { \n        max_r=row;\n        for(long long i=row+1;i<=Row;i++)\n            if(abs(a[i][col])>abs(a[max_r][col]))\n                max_r=i;\n        if(a[max_r][col]==0)\n        {\n            row--;\n            continue;\n        }\n        if(max_r!=row)\n            for(long long i=col;i<=Column;i++)\n                swap(a[row][i],a[max_r][i]);\n\n        for(long long i=row+1;i<=Row;i++)\n        {\n            if(a[i][col]!=0)\n            {\n\n                for(long long j=col;j<=Column;j++)\n                    a[i][j]^=a[row][j];\n            }\n        }\n    }\n\treturn Column-row+1;\n}\n/*void gauss()\n{\n\tupper=1;\n\tfor (long long i=1;i<=m;i++)\n\t{\n\t\tpos=-1;\n\t\tfor (long long j=upper;j<=n;j++)\n\t\t{\n\t\t\tif (a[j][i])\n\t\t\t{\n\t\t\t\tpos=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~pos)\n\t\t{\n\t\t\tcnt++;\n\t\t\tfor (long long j=1;j<=m;j++) swap(a[i][j],a[pos][j]);\n\t\t\tfor (long long j=upper+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif (a[j][i])\n\t\t\t\t{\n\t\t\t\t\tfor (long long k=i;k<=m;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][k]^=a[upper][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupper++;\n\t\t}\n\t}\n} */ \nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tfor (long long j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tpw[0]=1;\n\tfor (long long i=1;i<=600;i++) pw[i]=pw[i-1]*2%mod;\n\tcur=pw[Guass(n,m)];\n\tprintf(\"%lld\\n\",((pw[n+m-1]-pw[n-1]*cur)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<bitset>\n\ntypedef long long LL;\n\nconst int N=305;\nconst int MOD=998244353;\n\nint n,m,tot;\nbool vis[N];\nstd::bitset<N> bit[N],bas[N];\n\nint ksm(int x,int y)\n{\n\tint ans=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ans=(LL)ans*x%MOD;\n\t\tx=(LL)x*x%MOD;y>>=1;\n\t}\n\treturn ans;\n}\n\nvoid gauss()\n{\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tif (bit[i][j])\n\t\t\t{\n\t\t\t\tif (vis[j]) bit[i]^=bas[j];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbas[j]=bit[i];\n\t\t\t\t\ttot++;\n\t\t\t\t\tvis[j]=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tbit[i][j]=x;\n\t\t}\n\tgauss();\n\tint ans=(LL)ksm(2,n-1)*(ksm(2,m)-ksm(2,m-tot))%MOD;\n\tans+=ans<0?MOD:0;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"out2.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n#define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \n// void bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid amax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid amin(T& x, T y) {\n    x = min(x, y);\n}\n\n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-12;\nconst int maxn = 5e4 + 3, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst int base2 = 998244353;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % base2;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % base2;\n    }\n}\n\nconst int N = 305;\n\nint gauss (vector < bitset<N> > a, int n, int m) {    \n    vector<int> where (m, -1);\n    \n    int rank = m;\n    for (int col=0, row=0; col<m && row<n; ++col) {\n        for (int i=row; i<n; ++i)\n            if (a[i][col]) {\n                swap (a[i], a[row]);\n                break;\n            }\n        if (!a[row][col]) {\n            rank--;\n            continue;\n        }\n        where[col] = row;\n\n        for (int i=0; i<n; ++i)\n            if (i != row && a[i][col])\n                a[i] ^= a[row];\n        ++row;\n    }\n\n    return rank;\n}\n\nint main() {\n  //  files1;\n\n    int n, m;\n    cin >> n >> m;\n    vector<bitset<N> > a(n);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            bool x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    int r = gauss(a, n, m);\n    cout << (binpow(2, n + m - 1) - binpow(2, n + m - r - 1) + base) % base;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 301;\n\nint n, m, pow2[N], mod = 998244353;\nvector <bitset <N> > b;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    pow2[0] = 1;\n    for(int i = 1 ; i < N ; i++){\n        pow2[i] = 2 * pow2[i - 1] % mod;\n    }\n    cin >> n >> m;\n    b.resize(n);\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            int x;\n            cin >> x;\n            if(x) b[i].set(j);\n        }\n    }\n    vector <int> vis(n);\n    int h = n;\n    for(int j = 0 ; j < m ; j++){\n        int idx = -1;\n        for(int i = 0 ; i < n ; i++){\n            if(b[i][j]) idx = i;\n        }\n        if(idx == -1) continue;\n        vis[idx] = 1;\n        h--;\n        for(int i = 0 ; i < n ; i++){\n            if(vis[i]) continue;\n            if(b[i][j]) b[i] ^= b[idx];\n        }\n    }\n    cout << 1LL * pow2[m - 1] * (pow2[n] - pow2[h] + mod) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int p=998244353;\nint a[305][305],b[305][305];\nint read() {\n\tchar c=getchar(); int x=0,f=1;\n\twhile (c<'0' || c>'9') {\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint fpow(int x,int k) {\n\tint ans=1;\n\twhile (k) {\n\t\tif (k&1) ans=1LL*ans*x%p;\n\t\tx=1LL*x*x%p;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n=read(),m=read();\n\tfor (int i=1; i<=n; i++) {\n\t\tfor (int j=1; j<=m; j++) {\n\t\t\ta[i][j]=read();\n\t\t}\n\t}\n\tmemset(b,0,sizeof(b));\n\tfor (int i=1; i<=m; i++) {\n\t\tfor (int j=n; j>=1; j--) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tif (b[j][j]) for (int k=1; k<=n; k++) a[i][k]^=b[j][k];\n\t\t\t\telse {\n\t\t\t\t\tfor (int k=1; k<=n; k++) b[j][k]=a[i][k];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tfor (int j=1; j<=n; j++) if (b[j][j]) ++cnt;\n\tprintf(\"%d\\n\", ((fpow(2,n+m-1)-fpow(2,n+m-cnt-1))%p+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n//x,yがax+by=gcd(a,b)の解になる\nll extgcd(ll a, ll b, ll& x, ll& y) {\n\tll d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n//aのmod mでの逆元を求める\nll mod_inverse(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\nconst int N_MAX = 1 << 18;\nll p[N_MAX];\nvoid init() {\n\tp[0] = 1;\n\trep1(i, N_MAX - 1) {\n\t\tp[i] = p[i - 1] * i%mod;\n\t}\n}\n//xCyを求める\nll comb(ll x, ll y, ll m) {\n\tif (x < y)return 0;\n\tll res = p[x];\n\t(res *= mod_inverse(p[y], m)) %= mod;\n\t(res *= mod_inverse(p[x - y], m)) %= mod;\n\treturn res;\n}\nll mod_pow(ll x, int n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nint n, m;\nint a[300][300];\nint calcrank() {\n\tint res = 0;\n\tint le = 0;\n\trep(i, m) {\n\t\tbool ansed = false;\n\t\tRep(j,le, n) {\n\t\t\tif (a[j][i]) {\n\t\t\t\tswap(a[j], a[le]);\n\t\t\t\tansed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ansed) {\n\t\t\tRep(j, le + 1, n) {\n\t\t\t\tif (a[j][i]) {\n\t\t\t\t\trep(l, m) {\n\t\t\t\t\t\ta[j][l] ^= a[le][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++; le++;\n\t\t}\n\t}\n\treturn res;\n}\nll inv2 = (1 + mod) / 2;\nll inv4 = inv2 * inv2%mod;\nll inv34 = 3 * inv4%mod;\nint main() {\n\tinit();\n\tcin >> n >> m;\n\tint num = 0;\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tint r = calcrank();\n\tll ans = 0;\n\tfor (int j = 1; j <= r; j += 2) {\n\t\tll csum = mod_pow(2, (n - r)+(m - r));\n\t\tcsum = csum * comb(r, j, mod) %mod*mod_pow(3, r - j) % mod;\n\t\t(ans += csum) %= mod;\n\t}\n\tcout << ans << endl;\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 305, MOD = 998244353;\nbitset<N> b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int x;\n            cin >> x;\n            b[i][j] = x;\n        }\n    }\n\n    ll bad = 1;\n\n    for (int i = 0, j = 0; i < m; i++) {\n        int sel = -1;\n        for (int k = j; k < n; k++) {\n            if (b[k][i] == 1) {\n                sel = k;\n                break;\n            }\n        }\n        if (sel == -1) {\n            bad = bad * 2 % MOD;\n        }\n        else {\n            swap(b[sel], b[j]);\n            for (int k = 0; k < n; k++) {\n                if (k != sel && b[k][i] == 1) {\n                    b[k] ^= b[j];\n                }\n            }\n            j++;\n        }\n\n        // for (int x = 0; x < n; x++) {\n        //     for (int y = 0; y < m; y++) {\n        //         cout << b[x][y] << \" \";\n        //     }\n        //     cout << \"\\n\";\n        // }\n    }\n\n    // cout << bad << \"\\n\";\n\n    ll ans = 1;\n    for (int i = 0; i < m; i++) {\n        ans = ans * 2 % MOD;\n    }\n\n    ans = (ans - bad + MOD) % MOD;\n\n    for (int i = 0; i < n - 1; i++) {\n        ans = ans * 2 % MOD;\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst ll INF = 1 << 30;//10^9\n//ll MOD = 1000000007;\nll MOD = 998244353;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A, ll x = 20){cout << fixed << setprecision(x) << A << endl;}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n\n//コンビネーション\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\n\nll Rank(ll N, ll M, vector<vector<ll>> A){\n  ll next = 0;\n  rep(i, M){\n    for(ll j = next; j < N; j++){\n      if(A[j][i]){\n        swap(A[next], A[j]);\n      }\n    }\n    if(!A[next][i]) continue;\n    rep(j, N)if(j != next){\n      if(A[j][i]){\n        rep(k, M) A[j][k] ^= A[next][k];\n      }\n    }\n    next++;\n    if(next == N) break;\n  }\n  return next;\n}\n\nll N, M;\nvector<vector<ll>> A;\n\n\nvoid solve(){\n  COMinit();\n  cin >> N >> M;\n  A.resize(N);\n  rep(i, N) A[i].resize(M);\n  rep(i, N)rep(j, M) cin >> A[i][j];\n  ll r = Rank(N, M, A);\n  ll ans = 0;\n  rep(i, r+1){\n    ll add = comb(r, i) * pow_mod(2, r-i) % MOD;\n    for(ll j = 1; j <= i; j += 2){\n      ans += add * comb(i, j) % MOD;\n      ans %= MOD;\n    }\n  }\n  ans *= pow_mod(2, N + M - 2 * r);\n  ans %= MOD;\n  cout << ans << endl;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int Mx = 300;\nconst int mod = 998244353;\nll p2[Mx + 1];\n\ntypedef bitset<Mx> * It;\n\nll f(It first, It last, const int pos) {\n\n\tif (pos < 0 || first == last) {\n\t\tassert(all_of(first, last, [](const bitset<Mx> &x) {\n\t\t\treturn x == 0;\n\t\t}));\n\t\treturn p2[last - first];\n\t}\n\n\tpartition(first, last, [&pos](const bitset<Mx> &x) {\n\t\treturn x[pos] == 0;\n\t});\n\n\tIt pLast = prev(last);\n\tif ((*pLast)[pos] == 0)\n\t\treturn f(first, last, pos - 1);\n\tfor (It it = first; it < pLast; ++it)\n\t\tif ((*it)[pos])\n\t\t\t*it ^= *pLast;\n\treturn f(first, pLast, pos - 1);\n}\n\nbitset<Mx> a[300];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i <= Mx; ++i)\n\t\tp2[i] = (p2[i - 1] * 2) % mod;\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = 0;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\ta[i][j] = x;\n\t\t}\n\t}\n\n\tll res = f(a, a + n, m - 1);\n\tres = (p2[n] - res) * p2[m - 1];\n\tcout << (res % mod + mod) % mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int MOD=998244353;\nconst int N=305;\nint n,m;\nbitset<N> s[N];\nbitset<N> f[N];\nint cnt=0;\nvoid Ins ()\n{\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tbool tf=true;\n\t\tfor (int i=1;i<=m;i++)\n\t\tif (s[u][i])\n\t\t{\n\t\t\tif (!f[i][i]) \t{f[i]=s[u];tf=false;break;}\n\t\t\ts[u]^=f[i];\n\t\t}\n\t\tcnt=cnt+tf;\n\t}\n}\nint Pow[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tPow[0]=1;for (int u=1;u<=n;u++) Pow[u]=Pow[u-1]*2%MOD;\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\ts[u][i]=x;\n\t\t}\n\t}\n\tIns();\n\tint ans=0;\n\tint t=1;\tfor (int u=1;u<m;u++) t=t*2%MOD;\n\tint lalal=(Pow[n]-Pow[cnt]+MOD)%MOD;\n\t//printf(\"%d %d\\n\",lalal,Pow[cnt]);\n\tans=(LL)lalal*t;\n\tprintf(\"%d\\n\",ans%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\n\nvoid norm(VV<int>& a) {\n\tint n = a.size(), m = a[0].size();\n\tint pivot = -1;\n\tint pre = 0;\n\tREP(j, m) {\n\t\tFOR(i, pre, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tpivot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) continue;\n\t\tpre = pivot + 1;\n\n\t\tREP(i, n) if (i != pivot) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tREP(k, m) {\n\t\t\t\t\ta[i][k] ^= a[pivot][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tMAT(int, a, n, m);\n\n\tnorm(a);\n\n\tint one = 0;\n\tREP(i, n) {\n\t\tbool f = false;\n\t\tREP(j, m) if (a[i][j]) f = true;\n\t\tif (f) ++one;\n\t}\n\n\tint ans = powMod(2, n, MOD) - powMod(2, n - one, MOD);\n\t(ans *= powMod(2, m - 1, MOD)) %= MOD;\n\tif (ans < 0) ans += MOD;\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\nint n,m,cnt;\nlong long pw[305];\nbitset<305> bas[305];\nbool add(bitset<305> b)\n{\n\tfor (int i=m-1;i>=0;i--)\n\t{\n\t\tif (b[i])\n\t\tb^=bas[i];\n\t}\n\tfor (int i=m-1;i>=0;i--)\n\t{\n\t\tif (b[i])\n\t\t{\n\t\t\tbas[i]=b;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tpw[0]=1;\n\tfor (int i=1;i<=300;i++)\n\tpw[i]=(2*pw[i-1])%mod;\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tbitset<305> cur;\n\t\tfor (int j=0;j<m;j++)\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tcur[j]=a;\n\t\t}\n\t\tcnt+=add(cur);\n\t}\n\tprintf(\"%lld\",(pw[n]-pw[n-cnt]+mod)%mod*pw[m-1]%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nconst int mo=998244353;\n\nint n,m,a[301][301],r=0,b[301][301];\nbool f[301];\n\nint mi(int o,int p)\n{\n\tint u=1;\n\twhile(p>0)\n\t{\n\t\tif(p&1) u=1ll*u*o%mo;\n\t\to=1ll*o*o%mo;\n\t\tp>>=1;\n\t}\n\treturn u;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++) scanf(\"%d\",&a[i][j]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=m;j>=1;j--)\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tif(!f[j]) \n\t\t\t\t{\n\t\t\t\t\tfor(int k=1;k<=m;k++) b[j][k]=a[i][k];\n\t\t\t\t\tf[j]=1;r++;\n\t\t\t\t\tbreak;\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tfor(int k=1;k<=m;k++) a[i][k]^=b[j][k];\n\t\t\t\t}\n\t\t\t}\n\tcout<<((mi(2,n+m-1)-mi(2,n+m-1-r)+mo)%mo)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\ntypedef long double ld;\ntypedef long long ll;\n\nconst int M = 303;\n\nconst int mod = 998244353;\n\nint add(int x) {  \n  return x;\n}\n\ntemplate<typename... T>\nint add(int x, T... y) {  \n  x += add(y...);\n  if (x >= mod)\n        x -= mod;\n  return x;\n}\n\ntemplate<typename... T>\nint udd(int &x, T... y) { \n  return x = add(x, y...);\n}\n\ntemplate<typename... T>\nint sub(int x, T... y) { \n  return add(x, mod - add(y...));\n}\n\nint mul(int x) { \n  return x;\n}\n\ntemplate<typename... T>\nint mul(int x, T... y) { \n  return 1ll * x * mul(y...) % mod;\n}\n\nint bin(int x, int to) { \n  int y = 1;\n  while (to) { \n        if (to & 1)\n                  y = mul(x, y);\n            x = mul(x, x);\n                to >>= 1;\n  }\n  return y;\n}\n\nint inv(int x) { \n  assert(x != 0);\n  return bin(x, mod - 2);\n}\n\nbool a[M][M];\nint n, m;\n\nvoid sbt(int from, int what) {\n  for (int i = 0; i < m; ++i)\n    a[from][i] ^= a[what][i];\n}\n\nvoid swp(int x, int y) {\n  for (int i = 0; i < m; ++i)\n    swap(a[x][i], a[y][i]);\n}\n\nvoid read() {\n  cin >> n >> m;\n\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      int x;\n      cin >> x;\n      a[i][j] = x == 1;\n    }\n}\n\nvoid kill() {\n  int rank = 0;\n  for (int i = 0; i < m; ++i) {\n    int x = -1;\n    for (int j = rank; j < n; ++j)\n      if (a[j][i])\n        x = j;\n    if (x != -1) {\n      swp(x, rank);\n      ++rank;\n      for (int j = rank; j < n; ++j)\n        if (a[j][i])\n          sbt(j, rank - 1);\n    }\n  }\n\n  int ans = sub(bin(2, n), bin(2, n - rank));\n  ans = mul(ans, bin(2, m - 1));\n\n  cout << ans << \"\\n\";\n}\n\nint main() {\n#ifdef LOCAL\n  assert(freopen(\"e.in\", \"r\", stdin));\n#endif\n\n  ios_base::sync_with_stdio(false);\n\n  read();\n  kill();\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type alias\ntypedef long long LL;\ntypedef pair<int,int> II;\ntypedef tuple<int,int,int> III;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef unordered_map<int,int> MAPII;\ntypedef unordered_set<int> SETI;\ntemplate<class T> using VV=vector<vector<T>>;\n// minmax\ntemplate<class T> inline T SMIN(T& a, const T b) { return a=(a>b)?b:a; }\ntemplate<class T> inline T SMAX(T& a, const T b) { return a=(a<b)?b:a; }\n// repetition\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define REPE(i,n)  for(int i=0;i<=(n);++i)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define FORR(x,arr) for(auto& x:arr)\n#define SZ(a) int((a).size())\n// collection\n#define ALL(c) (c).begin(),(c).end()\n// DP\n#define MINUS(dp) memset(dp, -1, sizeof(dp))\n#define ZERO(dp) memset(dp, 0, sizeof(dp))\n// stdout\n#define println(args...) fprintf(stdout, ##args),putchar('\\n');\n// debug cerr\ntemplate<class Iter> void __kumaerrc(Iter begin, Iter end) { for(; begin!=end; ++begin) { cerr<<*begin<<','; } cerr<<endl; }\nvoid __kumaerr(istream_iterator<string> it) { (void)it; cerr<<endl; }\ntemplate<typename T, typename... Args> void __kumaerr(istream_iterator<string> it, T a, Args... args) { cerr<<*it<<\"=\"<<a<<\", \",__kumaerr(++it, args...); }\ntemplate<typename S, typename T> std::ostream& operator<<(std::ostream& _os, const std::pair<S,T>& _p) { return _os<<\"{\"<<_p.first<<','<<_p.second<<\"}\"; }\n#define __KUMATRACE__ true\n#ifdef __KUMATRACE__\n#define dump(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); __kumaerr(_it, args); }\n#define dumpc(ar) { cerr<<#ar<<\": \"; FORR(x,(ar)) { cerr << x << ','; } cerr << endl; }\n#define dumpC(beg,end) { cerr<<\"~\"<<#end<<\": \"; __kumaerrc(beg,end); }\n#else\n#define dump(args...)\n#define dumpc(ar)\n#define dumpC(beg,end)\n#endif\n\n// $ cp-batch OddSubrectangles | diff OddSubrectangles.out -\n// $ g++ -std=c++14 -Wall -O2 -D_GLIBCXX_DEBUG -fsanitize=address OddSubrectangles.cpp && ./a.out\n\n/*\n \n 3/4/2019\n \n 10:59-11:43 give up\n \n I had no idea what I should do.\n - dp(i,j)\n  - recurrence relationd is not found\n - 2d cumulative sum\n  - cannot connect to # of ways\n - fix row or colum\n  - cannot connect to subset of rows or columns\n \n 3/7/2019\n \n 15:45-17:20 read editorials\n \n 3/8/2019\n \n 15:18-17:00 read editorials\n \n 3/9/2019\n \n 18:10-\n \n http://drken1215.hatenablog.com/entry/2019/02/10/024200\n https://betrue12.hateblo.jp/entry/2019/02/10/014031\n https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n \n https://twitter.com/satanic0258/status/1094264168809562112\n \n */\ntemplate <typename T> struct MX {\n  int N,M;\n  MX(int N, int M) : N(N), M(M) {\n    assert(N>0&&M>0);\n    dat=vector<vector<T>>(N, vector<T>(M, 0));\n  }\n  MX(vector<vector<T>> &d) : dat(d) {\n    assert(dat.size()>0&&dat[0].size()>0);\n    N=dat.size(),M=dat[0].size();\n  }\n  inline vector<T>& operator [] (int i) {return dat[i]; }\n  MX<T> &operator+=(MX<T> that) { dat=add(dat,that.dat); return *this; }\n  MX<T> &operator-=(MX<T> that) { that*=-1,dat=add(dat,that.dat); return *this; }\n  MX<T> &operator*=(MX<T> that) { dat=mult(dat,that.dat); return *this; }\n  MX<T> &operator*=(T k) { dat=mult(dat,k); return *this; }\n  MX<T> operator + (const MX<T> &that) const { return MX<T>(*this)+=that; }\n  MX<T> operator - (const MX<T> &that) const { return MX<T>(*this)-=that; }\n  MX<T> operator * (const MX<T> &that) const { return MX<T>(*this)*=that; }\n  MX<T> operator * (const T &k) const { return MX<T>(*this)*=k; }\n  bool operator==(MX<T> that) const { return dat==that.dat; }\n  bool operator!=(MX<T> that) const { return dat!=that.dat; }\n  // res = A^n, O(N^3*lg n) time\n  MX<T> pow (long long n) const {\n    assert(N==M);\n    MX<T> res(N,N); for(int i=0; i<N; ++i) res.dat[i][i]=1;\n    MX<T> a=MX<T>(*this);\n    while(n>0) {\n      if(n%2) res*=a;\n      a*=a,n>>=1;\n    }\n    return res;\n  }\n  friend ostream& operator<<(ostream& os, const MX<T>& that) {\n    for(int i=0; i<that.N; ++i) for(int j=0; j<that.M; ++j) os<<that.dat[i][j]<<\",\\n\"[j==that.M-1];\n    return os;\n  }\nprivate:\n  vector<vector<T>> dat;\n  // O(N^2) time\n  vector<vector<T>> add(vector<vector<T>> &A, vector<vector<T>> &B) {\n    assert(A.size()==B.size()&&A[0].size()==B[0].size());\n    int N=A.size(),M=A[0].size();\n    vector<vector<T>> res=vector<vector<T>>(N,vector<T>(M));\n    for(int i=0; i<N; ++i) for(int j=0; j<M; ++j) res[i][j]=A[i][j]+B[i][j];\n    return res;\n  }\n  // O(N^3) time\n  vector<vector<T>> mult(vector<vector<T>> &A, vector<vector<T>> &B) {\n    assert(A[0].size()==B.size());\n    int NN=A.size(),MM=B[0].size(),L=A[0].size();\n    vector<vector<T>> res=vector<vector<T>>(NN,vector<T>(MM));\n    for(int i=0; i<NN; ++i) for(int j=0; j<MM; ++j) for(int k=0; k<L; ++k) res[i][j]+=A[i][k]*B[k][j];\n    return res;\n  }\n  vector<vector<T>> mult(vector<vector<T>> &A, T k) {\n    int N=A.size(),M=A[0].size();\n    vector<vector<T>> res=vector<vector<T>>(N,vector<T>(M));\n    for(int i=0; i<N; ++i) for(int j=0; j<M; ++j) res[i][j]=k*A[i][j];\n    return res;\n  }\n};\nint gf2_rank(MX<int> mx) {\n  int res=0;\n  for(int j=0; j<mx.M; j++) {\n    int pivot=-1;\n    for(int i=res; i<mx.N; i++) if(mx[i][j]) {\n      pivot=i;\n      break;\n    }\n    if(pivot>=0) {\n      if(pivot!=res) for(int k=0; k<mx.M; k++) swap(mx[pivot][k], mx[res][k]);\n      for(int i=res+1; i<mx.N; i++) if(mx[i][j]) for(int k=0; k<mx.M; k++) mx[i][k]^=mx[res][k];\n      res++;\n    }\n  }\n  return res;\n}\nconst int MOD=998244353;\nstruct ModInt {\n  unsigned int val;\n  ModInt(): val(0) {}\n  ModInt(int v) { norm(v%MOD); }\n  ModInt(long long v) { norm(v%MOD); }\n  ModInt& norm(long long v) {\n    v=v<0?v%MOD+MOD:v; // negative\n    v=v>=MOD?v-MOD:v; // mod\n    val=(unsigned int)v;\n    return *this;\n  }\n  explicit operator bool() const { return val!=0; }\n  ModInt operator-() const { return ModInt(0)-*this; }\n  ModInt &operator+=(ModInt that) { return norm((long long)val+that.val); }\n  ModInt &operator-=(ModInt that) { return norm((long long)val-that.val); }\n  ModInt &operator*=(ModInt that) { val=(unsigned long long)val*that.val%MOD; return *this; }\n  ModInt &operator/=(ModInt that) { return *this*=that.inv(); }\n  ModInt operator+(ModInt that) const { return ModInt(*this)+=that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this)-=that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this)*=that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this)/=that; }\n  ModInt pow(long long n) const {\n    ModInt x=*this, res=1;\n    while(n>0) {\n      if(n&1) res*=x;\n      x*=x,n>>=1;\n    }\n    return res;\n  }\n  ModInt inv() const { return (*this).pow(MOD-2); }\n  bool operator==(ModInt that) const { return val==that.val; }\n  bool operator!=(ModInt that) const { return val!=that.val; }\n  friend ostream& operator<<(ostream& os, const ModInt& that) { return os<<that.val; }\n};\n\n//const int MAX_N=300+1;\nVV<int> A;\nint N,M;\n\nvoid solve() {\n  MX<int> mx(A);\n  int r=gf2_rank(mx);\n  ModInt res=ModInt(2).pow(N+M-1)-ModInt(2).pow(N+M-r-1);\n  cout<<res<<endl;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout<<setprecision(12)<<fixed;\n  \n  cin>>N>>M;\n  A=VV<int>(N,VI(M));\n  REP(i,N)REP(j,M) cin>>A[i][j];\n  solve();\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\ntypedef long long ll;\nusing namespace std;\n\nint a[310][310];\nll mod=998244353, beki[310];\n\nint main(void){\n    int N, M;\n    cin >> N >> M;\n    for(int i=0; i<N; ++i){\n        for(int j=0; j<M; ++j){\n            cin >> a[i][j];\n        }\n    }\n    beki[0]=1;\n    for(int i=1; i<310; ++i){\n        beki[i]=(beki[i-1]*2)%mod;\n    }\n    int cnt=0;\n    for(int i=0; i<N; ++i){\n        int piv=cnt;\n        while(piv<M){\n            if(a[i][piv]==1) break;\n            ++piv;\n        }\n        if(piv<M){\n            for(int j=0; j<N; ++j){\n                swap(a[j][cnt], a[j][piv]);\n            }\n            for(int j=cnt+1; j<M; ++j){\n                if(a[cnt][j]==1){\n                    for(int k=0; k<N; ++k){\n                        a[k][j] ^= a[k][cnt];\n                    }\n                }\n            }\n            ++cnt;\n        }\n    }\n    ll ans=(beki[M]+mod-beki[M-cnt])%mod;\n    (ans *= beki[N-1]) %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const {\n        long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u);\n    }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r;\n}\ntypedef ModInt<998244353> mint;\nint gaussianEliminationXOR(vector<vector<int>> A) {\n    int n = A.size(), m = A[0].size(), r = 0;\n    for (int i = 0; r < n && i < m; ++i) {\n        int to = r;\n        rep(j, r + 1, n) if (A[j][i] > A[to][i]) to = j;\n        A[r].swap(A[to]);\n        if (A[r][i] == 0) continue;\n        rep(j, r + 1, n) rrep(k, m - 1, i) A[j][k] ^= A[r][k] & A[j][i];\n        r++;\n    }\n    return r;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nint N, M;\nint v[606];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n\n    vector<vector<int>> v(N, vector<int>(M));\n\n    rep(i, 0, N) rep(j, 0, M) {\n        int a; cin >> a;\n        v[i][j] = a;\n    }\n\n    int R = gaussianEliminationXOR(v);\n\n    mint ans = ((mint(2) ^ N) - (mint(2) ^ (N-R))) * (mint(2) ^ (M - 1));\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\n\nint main() {\n  int N, M;\n  bitset< 300 > X[300];\n  cin >> N >> M;\n  int rank = 0;\n  for(int i = 0; i < N; i++) {\n    bitset< 300 > tap;\n    for(int j = 0; j < M; j++) {\n      int p;\n      cin >> p;\n      tap[j] = p;\n    }\n    for(int j = 0; j < M; j++) {\n      if(tap[j]) {\n        tap ^= X[j];\n        if(tap[j]) {\n          X[j] = tap;\n          ++rank;\n          break;\n        }\n      }\n    }\n  }\n  int64 all = 1, sub = 1;\n  for(int i = 0; i < N + M - 1; i++) (all *= 2) %= mod;\n  for(int i = 0; i < N + M - rank - 1; i++) (sub *= 2) %= mod;\n  cout << (all + mod - sub) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _DEBUG\ntemplate <typename ... Args>\nvoid debugPrintf(const char *format, Args const & ... args) {\n\tfprintf(stdout, format, args ...);\n\tfflush(stdout);\n}\n#else\n#define debugPrintf(...)\n#endif\n\nconst int MOD = 998244353;\n\nint main() {\n\tint n, m; reader(n, m);\n\tusing bs = bitset<300>;\n\tvector<bs> v(n);\n\tFOR(i, n) {\n\t\tFOR(j, m) {\n\t\t\tint x; reader(x);\n\t\t\tif (x == 1) v[i].set(j);\n\t\t}\n\t}\n\n\tint freeColRows = 0;\n\t{\n\t\tint removed = 0;\n\t\tFOR(j, m) {\n\t\t\tint found = -1;\n\t\t\tfor (int i = removed; i < n; i++) {\n\t\t\t\tif (v[i][j]) {\n\t\t\t\t\tfound = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found == -1) continue;\n\t\t\tswap(v[removed], v[found]);\n\t\t\tFOR(i, n) {\n\t\t\t\tif (i != removed && v[i][j]) {\n\t\t\t\t\tv[i] ^= v[removed];\n\t\t\t\t}\n\t\t\t}\n\t\t\tremoved++;\n\t\t}\n\n\t\tfreeColRows = m - removed;\n\t}\n\tvector<Pll> vp;\n\tFOR(i, n) {\n\t\tint cnt = 0;\n\t\tFOR(j, m) if (v[i][j])cnt++;\n\t\tif (cnt == 0) {\n\t\t\tfreeColRows++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tll one = mod_pow(2, cnt - 1, MOD);\n\t\tll zero = one * 3 % MOD;\n\t\tvp.emplace_back(zero, one);\n\t}\n\n\tPll ans = { 1,0 };\n\tfor (auto& kv : vp) {\n\t\tPll nxt;\n\t\tnxt.first = (ans.first * kv.first + ans.second * kv.second) % MOD;\n\t\tnxt.second = (ans.first * kv.second + ans.second * kv.first) % MOD;\n\t\tans = nxt;\n\t}\n\tll ml = mod_pow(2, freeColRows, MOD);\n\n\twriterLn(ans.second * ml % MOD);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 998244353\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main(){\n\tint n, m, x, z, y;\n\tvector<int> a[400];\n\tlong long ans = 1;\n\tlong long s = 1;\n\tscanf(\"%d %d\", &n, &m);\n\tf(i, n){\n\t\tf(j, m){\nscanf(\"%d\", &x);\n\t\ta[i].push_back(x);\n        }\n\t}\n\tf(i, n + m - 1){\n\t\tans *= 2;\n\t\tans %= MOD;\n\t}\n\tz = 0;\n\tf(j, m){\n\t\ty = -1;\n\t\tf(i, n){\n\t\t\tif (a[i][j] == 1)y = i;\n\t\t}\n\t\tif (y >= 0){\n\t\t\tz++;\n\t\t\tf(i, n){\n\t\t\t\tif (a[i][j] == 1){\n\t\t\t\t\tf(jj, m){\n\t\t\t\t\t\ta[i][jj] = a[i][jj] ^ a[y][jj];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(jj, m){\n\t\t\t\ta[y][jj] = 0;\n\t\t\t}\n\t\t}\n\t}\n\ts = 1;\n\tf(i, (n + m-z-1)){\n\t\ts *= 2;\n\t\ts %= MOD;\n\t}\n\tans = (ans + MOD - s) % MOD;\n\tprintf(\"%lld\\n\", ans);\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 302;\nconst int MOD = 998244353;\n\nbitset<N>a[N];\nint32_t main() {\n   // ifstream cin(\"data.in\");\n    int n, m;\n    cin >> n >> m;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            int x;\n            cin >> x;\n            a[j][i] = x;\n        }\n    }\n    swap(n, m);\n\n    // n ecuatii cu m necunoscute, rezultatul e 0\n    for(int i = 0; i < n; ++i) {\n        a[i][m] = 0;\n    }\n    int l = 0, c = 0, var_free = 0;\n    while(l < n && c < m) {\n        int poz = -1;\n        for(int i = l; i < n && poz == -1; i++)\n            if(a[i][c] == 1)\n                poz = i;\n        if(poz == -1) {\n            // n-am putut gasi, e deja 0\n            c++;\n            var_free++; // este variabila libea\n            continue;\n        }\n        swap(a[l], a[poz]);\n        for(int i = l + 1; i < n; ++i)\n            if(a[i][c] == 1)\n                a[i] ^= a[l];\n        l++;\n        c++;\n    }\n\n    bool zero_sub = 1;\n\n    for(int i = 0; i < n; ++i) {\n        if(a[i][m] == 1) {\n            bool any = 1;\n            for(int j = 0; j < m && !any; j++)\n                any |= a[i][j];\n            if(!any)\n                zero_sub = 0;\n        }\n    }\n\n\n    vector<long long>p2(n + m + 1);\n    p2[0] = 1;\n    for(int i = 1; i <= n + m; ++i)\n        p2[i] = 2 * p2[i - 1] % MOD;\n    int aux1, aux2;\n\n    aux1 = (p2[n] - 1 + MOD) % MOD, aux2 = p2[m - 1];\n    int answer = (1LL * aux1 * aux2) % MOD;\n\n    if(zero_sub) {\n        aux1 = (p2[var_free] - 1 + MOD) % MOD, aux2 = p2[m - 1];\n        int bad = (1LL * aux1 * aux2) % MOD;\n        answer = (answer - bad + MOD) % MOD;\n    }\n    cout << answer;\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\n\nvoid norm(VV<int>& a) {\n\tint n = a.size(), m = a[0].size();\n\tREP(j, m) {\n\t\tint pivot = -1;\n\t\tREP(i, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tpivot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) continue;\n\n\t\tFOR(i, pivot + 1, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tREP(k, m) {\n\t\t\t\t\ta[i][k] ^= a[pivot][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tMAT(int, a, n, m);\n\n\tREP(_, 2) {\n\t\tnorm(a);\n\t\tVV<int> b(m, V<int>(n));\n\t\tREP(i, n) REP(j, m) {\n\t\t\tb[j][i] = a[i][j];\n\t\t}\n\t\tstd::swap(n, m);\n\t\tstd::swap(a, b);\n\t}\n\n\tint one = 0;\n\tint zero = 0;\n\tREP(i, n) {\n\t\tbool f = false;\n\t\tREP(j, m) if (a[i][j]) f = true;\n\t\tif (f) ++one;\n\t\telse ++zero;\n\t}\n\tREP(j, m) {\n\t\tbool f = false;\n\t\tREP(i, n) if (a[i][j]) f = true;\n\t\tif (f) /*++one*/;\n\t\telse ++zero;\n\t}\n\n\tint ans = powMod(2, n, MOD) - powMod(2, n - one, MOD);\n\t(ans *= powMod(2, m - 1, MOD)) %= MOD;\n\tif (ans < 0) ans += MOD;\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cout<<v[i][j]<<\" \";}cout<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nvii rotate(vii a) {\n  int h = a.size(), w = a[0].size();\n  vii b(w, vi(h));\n  rep (i, h) {\n    rep (j, w) {\n      b[j][i] = a[i][j];\n    }\n  }\n  return b;\n}\n\n\nconst int MAXN = 3010;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n\tfact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n\tfor (ll i = 2; i <= n; i++) {\n\t\tfact[i] = i * fact[i - 1] % M;\n\t\trfact[i] = mod_inverse(fact[i], M);\n\t}\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  ll ret = fact[n];\n  ret = (ret*rfact[r]) % M;\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\n\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n  vii a(h, vi(w));\n  rep (i, h) {\n    rep (j, w) {\n      cin >> a[i][j];\n    }\n  }\n  if (h < w) {\n    swap(h, w);\n    a = rotate(a);\n  }\n  set_fact(h + 100);\n  int no = 0;\n  rep (j, w) {\n    if (a[j][j] == 0) {\n      for (int i = j + 1; i < h; i++) {\n        if (a[i][j] == 1) {\n          swap(a[i], a[j]);\n          break;\n        }\n      }\n    }\n    if (a[j][j] == 0) {\n      no++;\n      continue;\n    }\n    for (int i = 0; i < h; i++) {\n      if (i == j) continue;\n      rep (k, w) {\n        a[i][k] = (a[i][k] + a[i][j]) % 2;\n      }\n    }\n  }\n  ll ans = 0;\n  for (int x = 1; x <= w - no; x += 2) {\n    for (int y = 0; y <= w - no - x; y++) {\n      ans += mod_pow(2, h - w) * nCr(w - no, x) % MOD * mod_pow(2, 2 * no) % MOD * nCr(w - no - x, y) % MOD * mod_pow(2, w - no - x - y) % MOD;\n      ans %= MOD;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n        mat<COL_SIZE> b(r);\n        for(int i = 0; i < r; i++) b[i] = a[i];\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n        return a[index];\n    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<301>a(m);\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = a.rank();\n//    cerr << r << endl;\n    cout << (mod_pow(2,n+m-1) - mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 998244353;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<LL>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\n\ntemplate<class T>struct matrix {\n\tint n = 0, m = 0;\n\tvector<vector<T>>mat;\n\tmatrix() {}\n\tmatrix(int _n) {\n\t\tmat.resize(_n);\n\t\tfor (int i = 0; i < _n; i++)\n\t\t\tmat[i].resize(_n);\n\t\tn = _n;\n\t\tm = _n;\n\t}\n\tmatrix(int _n, int _m) {\n\t\tmat.resize(_n);\n\t\tfor (int i = 0; i < _n; i++)\n\t\t\tmat[i].resize(_m);\n\t\tn = _n;\n\t\tm = _m;\n\t}\n\tint GetRank() {\n\t\tint h = mat.size(), w = mat[0].size();\n\t\tint res = 0, now = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tT ma = 0.0;\n\t\t\tint pivot;\n\t\t\tfor (int j = i; j < h; j++) {\n\t\t\t\tif (mat[j][now] > ma) {\n\t\t\t\t\tma = mat[j][now];\n\t\t\t\t\tpivot = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ma == 0.0) {\n\t\t\t\tnow++;\n\t\t\t\tif (now == w) break;\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pivot != i) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tswap(mat[i][j], mat[pivot][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tT tmp = 1.0 / mat[i][now];\n\t\t\tfor (int j = 0; j < w; j++) mat[i][j] *= tmp;\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tT tmp2 = mat[j][now];\n\t\t\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\t\t\tmat[j][k] -= mat[i][k] * tmp2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n\tbool Inv(matrix<T> &inv) {\n\t\tassert(mat.size() == mat[0].size() && inv.n == inv.m);\n\t\tint n = mat.size();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tinv.mat[i][j] = (i == j ? 1.0 : 0.0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tT ma = 0.0;\n\t\t\tint pivot;\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tif (mat[j][i] > ma) {\n\t\t\t\t\tma = mat[j][i];\n\t\t\t\t\tpivot = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ma == 0.0) return false;\n\t\t\tif (pivot != i) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tswap(mat[i][j], mat[pivot][j]);\n\t\t\t\t\tswap(inv.mat[i][j], inv.mat[pivot][j]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tT tmp = 1.0 / mat[i][i];\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tmat[i][j] *= tmp;\n\t\t\t\tinv.mat[i][j] *= tmp;\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tT tmp2 = mat[j][i];\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tmat[j][k] -= mat[i][k] * tmp2;\n\t\t\t\t\t\tinv.mat[j][k] -= inv.mat[i][k] * tmp2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tmatrix<T> operator+(const matrix<T> &b) {\n\t\tassert(mat.size() == b.n && mat[0].size() == b.m);\n\t\tint h = mat.size(), w = mat[0].size();\n\t\tmatrix<T> c(h, w);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tc.mat[i][j] = mat[i][j] + b.mat[i][j];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> operator-(const matrix<T> &b) {\n\t\tassert(mat.size() == b.n&& mat[0].size() == b.m);\n\t\tint h = mat.size(), w = mat[0].size();\n\t\tmatrix<T> c(h, w);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tc.mat[i][j] = mat[i][j] - b.mat[i][j];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> operator*(const matrix<T> b) {\n\t\tassert(mat[0].size() == b.n);\n\t\tmatrix<T> c(mat.size(), b.m);\n\t\tfor (int i = 0; i < mat.size(); i++) {\n\t\t\tfor (int k = 0; k < b.n; k++) {\n\t\t\t\tfor (int j = 0; j < b.m; j++) {\n\t\t\t\t\tc.mat[i][j] = (c.mat[i][j] + mat[i][k] * b.mat[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> operator*(T b) {\n\t\tmatrix<T> c(mat.size(), mat[0].size());\n\t\tfor (int i = 0; i < mat.size(); i++) {\n\t\t\tfor (int j = 0; j < mat[0].size(); j++) {\n\t\t\t\tc.mat[i][j] = mat[i][j] * b;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tmatrix<T> Pow(long long n) {\n\t\tassert(mat.size() == mat[0].size());\n\t\tmatrix<T> b(mat.size()), c(mat.size());\n\t\tc = *this;\n\t\tfor (int i = 0; i < mat.size(); i++) {\n\t\t\tb.mat[i][i] = 1;\n\t\t}\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) b = b * c;\n\t\t\tc = c * c;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn b;\n\t}\n\tT det() {\n\t\tT det = 1.0, buf;\n\t\t//三角行列を作成\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tif (i<j) {\n\t\t\t\t\tbuf = mat[j][i] / mat[i][i];\n\t\t\t\t\tfor (int k = 0; k<n; k++) {\n\t\t\t\t\t\tmat[j][k] -= mat[i][k] * buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//対角部分の積\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tdet *= mat[i][i];\n\t\t}\n\t\treturn det;\n\t}\n\tmatrix<T> rev() {\n\t\tmatrix<T> inv_a(n, m), cp(n, m);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tinv_a.mat[i][j] = mat[i][j];\n\t\t\t\tcp.mat[i][j] = mat[i][j];\n\t\t\t}\n\t\tT buf;\n\t\t//単位行列を作る\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tinv_a.mat[i][j] = (i == j) ? 1.0 : 0.0;\n\t\t\t}\n\t\t}\n\t\t//掃き出し法\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tbuf = 1 / cp.mat[i][i];\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tcp.mat[i][j] *= buf;\n\t\t\t\tinv_a.mat[i][j] *= buf;\n\t\t\t}\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tbuf = cp.mat[j][i];\n\t\t\t\t\tfor (int k = 0; k<n; k++) {\n\t\t\t\t\t\tcp.mat[j][k] -= cp.mat[i][k] * buf;\n\t\t\t\t\t\tinv_a.mat[j][k] -= inv_a.mat[i][k] * buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn inv_a;\n\t}\n};\nint calc_rank(matrix<LL> &A) {\n\tint r = 0;\n\tfor (int i = 0; i < A.m; ++i) {\n\t\tint pivot = -1;\n\t\tfor (int j = r; j < A.n; ++j) {\n\t\t\tif (A.mat[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot != -1) {\n\t\t\tswap(A.mat[pivot], A.mat[r]);\n\t\t\tfor (int j = 0; j < A.n; ++j)for(int k=0;k<A.m;k++) if (j != r && A.mat[j][i]) A.mat[j][k] ^= A.mat[r][k];\n\t\t\t++r;\n\t\t}\n\t}\n\treturn r;\n}\nLL n, m, s, t, h, w,mpow[810];\nint main() {\n\tcin >> n >> m;\n\tmpow[0] = 1;\n\trep(i, 800)mpow[i + 1] = mpow[i] * 2 % MOD;\n\tmatrix<LL>mat(n, m);\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tcin >> mat.mat[i][j];\n\t\t}\n\t}\n\tLL r = calc_rank(mat);\n\tcout << (mpow[n + m - 1] - mpow[n + m - r - 1] + MOD) % MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void read(T &x)\n{\n    x=0; char c=getchar();  int f=1;\n    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\n#include <bitset>\nconst int mod=998244353;\nll Pow(ll x,ll y){ll res=1; while(y){if(y&1) res=res*x%mod; x=x*x%mod,y>>=1;} return res;}\nbitset<300> f[300];\nint n,m;\nint main()\n{\n\tint x; read(n),read(m);\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j) read(x),f[i][j]=x;\n\tint ans=0;\n\tfor(int i=0;i<m;++i)\n\t{\n\t\tfor(int j=i;j<m;++j) if(f[j][i]){if(j!=i)swap(f[i],f[j]); break;}\n\t\tif(!f[i][i]){ans++; continue;}\n\t\tfor(int j=i+1;j<m;++j) if(f[j][i]) f[j]^=f[i];\n\t}\n\tprintf(\"%lld\",((Pow(2,m+n-1)-Pow(2,ans+n-1))%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n    long N, M;\n    cin >> N >> M;\n    vector<vector<long>> a(N, vector<long>(M));\n    long s(0);\n    for(auto& i : a)\n        for(auto &j : i){\n            scanf(\"%ld\", &j);\n            s += j;\n        }\n    if(s & 1){\n        cout << modpow(N + M - 2) << endl;\n    }else{\n        assert(1 != 1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nll ans = 0;\nconst ll mo = 998244353;\nll mypow(ll a, ll b)\n{\n  ll res = 1;\n  a %= mo;\n  while (b)\n  {\n    if (b & 1)\n      res = res * a % mo;\n    a = a * a % mo;\n    b >>= 1;\n  }\n  return res;\n}\nint main()\n{\nll n , m ;\ncin >> n >> m ;\nvector<vector<ll>> v(n, vector<ll>(m,0) );\nrep(i,n)rep(j,m)cin >> v[i][j];\nrep(j,m){\n  bool a=0;\n  ll ind=0;\n  rep(i,n){\n    if(v[i][j]&&a==0){a=1;ind=i;}\n    else if(v[i][j]&&a){\n      rep(k,m){\n        v[i][k]=(v[i][k]+v[ind][k])%2;\n      }\n    }\n  }\n}\nll c=0;\nrep(i,n){\n  ll t=0;\n  rep(j,m)t+=v[i][j];\n  if(t==0)c++;\n}\nauto modmul = [](auto... modx) {\n  ll res = 1;\n  for (auto modx_ : {modx...})\n  {\n    res *= modx_;\n    res %= mo;\n  }\n  return res;\n};\nans=modmul(mypow(2,m-1),mypow(2,n)-mypow(2,c)+mo);\ncout << ans << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=998244353;\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\nconst double EPS=1E-8;//小さい数\nint ran=0;\nvec gauss_jordan(const mat& A, const vec& b){\n    int n=A.size();\n    mat B(n, vec(n+1));\n    rep(i,0,n){\n        rep(j,0,n){\n            B[i][j]=A[i][j];\n        }\n    }\n    //行列Aの後ろにbを並べ同時に処理する\n    rep(i,0,n) B[i][n]=b[i];\n    rep(i,0,n){\n        //注目している変数の係数の絶対値が大きい式をi番目に持ってくる\n        int pivot=i;\n        rep(j,i,n){\n            if(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n        }\n        swap(B[i], B[pivot]);\n        \n        //解がないか、一意でない\n        //ここの実装難しい\n        if(abs(B[i][i])<EPS) return vec();\n        //注目している変数の係数を1にする\n        rep(j,i+1,n+1) B[i][j]/=B[i][i];\n        rep(j,0,n){\n            if(i!=j){\n                //j番目の式からi番目の変数を消去\n                rep(k,i+1,n+1) B[j][k]-=B[j][i]*B[i][k];\n            }\n        }\n    }\n    vec x(n);\n    rep(i,0,n) x[i]=B[i][n];\n    return x;\n}\nll mod_pow(ll x, ll n, ll mod){\n    if (n==0) return 1;\n    ll res=mod_pow(x*x%mod, n/2, mod);\n    if (n%2==1) res=res*x%mod;\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N,M;\n    cin>>N>>M;\n    mat a(N,vec(M,0));\n    rep(i,0,N){\n        rep(j,0,M){\n            cin>>a[i][j];\n        }\n    }\n    vec b(1,0);\n    gauss_jordan(a, b);\n    rep(i,0,N){\n        bool t=false;;\n        rep(j,0,M){\n            if(a[i][j]==1) t=true;\n        }\n        if(t) ran++;\n    }\n    cout <<(mod_pow(2, N+M-1, MOD)-mod_pow(2, N+M-1-ran, MOD)+MOD)%MOD<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\nint gauss (vector < vector< ll > > a) {\n    int n = (int) a.size();\n    int m = (int) a[0].size();\n\n    vector<int> where (m, -1);\n    for (int col=0, row=0; col<m && row<n; ++col) {\n        int sel = row;\n        for (int i=row; i<n; ++i)\n            if (abs (a[i][col]) > abs (a[sel][col]))\n                sel = i;\n        if (a[sel][col] == 0)\n            continue;\n        for (int i=col; i<m; ++i)\n            swap (a[sel][i], a[row][i]);\n        where[col] = row;\n\n        for (int i=0; i<n; ++i)\n            if (i != row) {\n                ll c = a[i][col] / a[row][col];\n\n                assert(a[i][col] % a[row][col] == 0LL);\n                for (int j=col; j<m; ++j)\n                    a[i][j] -= a[row][j] * c;\n            }\n        ++row;\n    }\n\n    int rank = n;\n    // cout << \"m = \" << m << endl;\n    for(int i = 0 ; i < n ; i++){\n        bool has_one = false;\n\n        for(int j = 0 ; j < m ; j++){\n            if(a[i][j]){\n                has_one = true;\n                break;\n            }\n        }\n\n        if(!has_one){\n            // cout << \"Linha \" << i << \" nao tem! \" << endl;\n            rank--;\n        }\n    }\n\n    return rank;\n}\n\nvector< vector< ll > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    // cout << mod * mod << endl;\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            ll x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = gauss(a);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n + m - 1);\n    ll nr = fast_pow(2LL, n + m - rank - 1);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD(nn - nr) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <bitset>\n\ntypedef unsigned int ui;\nconst int MN = 2000;\nconst int Mod = 998244353;\n\nint N, M, Cnt;\nint A[MN][MN];\n\nint Sz; ui *B[MN], *tmp;\n#define set(b, i, x) ((x) ? (b[(i) >> 5] |= 1 << ((i) & 31)) : (b[(i) >> 5] &= ~(1 << ((i) & 31))))\n#define val(b, i) (b[(i) >> 5] >> ((i) & 31) & 1)\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tif (N > M) {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < M; ++j)\n\t\t\t\tscanf(\"%d\", &A[i][j]);\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < M; ++j)\n\t\t\t\tscanf(\"%d\", &A[j][i]);\n\t\tstd::swap(N, M);\n\t}\n\tSz = (M + 31) >> 5;\n\tfor (int j = 0; j < M; ++j) B[j] = new ui[Sz];\n\ttmp = new ui[Sz];\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < M; ++j) set(tmp, j, A[i][j]);\n\t\tfor (int j = M - 1; ~j; --j) if (val(tmp, j)) {\n\t\t\tif (val(B[j], j)) for (int k = 0; k < Sz; ++k) tmp[k] ^= B[j][k];\n\t\t\telse {\n\t\t\t\tfor (int k = 0; k < Sz; ++k) B[j][k] = tmp[k];\n\t\t\t\t++Cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlong long Ans = 0;\n\tfor (int i = 0, s = 1; i < N + M; ++i, s = (s << 1) % Mod) {\n\t\tif (i == N + M - Cnt - 1) Ans -= s;\n\t\tif (i == N + M - 1) Ans += s;\n\t}\n\tprintf(\"%lld\\n\", (Ans % Mod + Mod) % Mod);\n\tfor (int j = 0; j < M; ++j) delete [] B[j];\n\tdelete [] tmp;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <limits.h>\nusing namespace std;\ntypedef long long LL;\ntypedef bitset<305> BS;\nconst int B=305;\nconst int N=400;\nconst BS one=BS().set(0);\nconst BS zero=BS();\nconst LL M=998244353;\n\nstruct LB {\n\tint sz;\n\tBS b[B];\n\n\tvoid build(BS *a,int n) {\n\t\tsz=0;\n\t\tfor(int i=0;i<B;i++) {\n\t\t\tb[i].reset();\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tBS x=a[i];\n\t\t\tfor(int j=B-1;j>=0;j--) {\n\t\t\t\tif(((x>>j)&one)==one) {\n\t\t\t\t\tif(b[j]!=zero) x^=b[j];\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[j]=x;\n\t\t\t\t\t\tsz++;\n\t\t\t\t\t\tfor(int k=j-1;k>=0;k--) {\n\t\t\t\t\t\t\tif(b[k]!=zero && ((b[j]>>k)&one)==one) b[j]^=b[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=j+1;k<B;k++) {\n\t\t\t\t\t\t\tif(((b[k]>>j)&one)==one) b[k]^=b[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}lb;\n\nint n,m,b;\nBS a[N];\nLL dp[N],P[N],inv_P[N],pw[N];\n\nLL exgcd(LL a,LL b,LL &x,LL &y) {\n\tLL d=a;\n\tif(b!=0) {\n\t\td=exgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}\n\telse {\n\t\tx=1;y=0;\n\t}\n\treturn d;\n}\n\nLL mod_inv(LL a,LL m) {\n\tLL x,y;\n\texgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nvoid init() {\n\tP[0]=1;\n\tinv_P[0]=1;\n\tpw[0]=1;\n\tfor(int i=1;i<N;i++) {\n\t\tP[i]=P[i-1]*i%M;\n\t\tinv_P[i]=mod_inv(P[i],M);\n\t\tpw[i]=pw[i-1]*2%M;\n\t}\n}\n\nLL C(int n,int m) {\n\treturn P[n]*inv_P[m]%M*inv_P[n-m]%M;\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++) {\n\t\ta[i].reset();\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tscanf(\"%d\",&b);\n\t\t\tif(b) a[i].set(j);\n\t\t}\n\t}\n\tlb.build(a,n);\n\n\tdp[0]=1;\n\tfor(int i=0;i<B;i++) {\n\t\tint l=lb.b[i].count();\n\t\tif(l==0) continue;\n\t\tfor(int j=m;j>=0;j--) {\n\t\t\tif(j+l<=m) dp[j+l]+=dp[j],dp[j+l]%=M;\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=m;i++) {\n\t\tfor(int j=1;j<=i;j+=2) {\n\t\t\tans+=C(i,j)*dp[i]%M*pw[m-i]%M;\n\t\t\tans%=M;\n\t\t}\n\t}\n\tans*=pw[n-lb.sz],ans%=M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int DVD = 998244353;\nlong long pow2(int x){\n\tint a = 1; long long ans = 1;\n\twhile(x){\n\t\ta = (2*a)%DVD;\n\t\tif(x%2) ans = (ans*a)%DVD;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint main(void){\n\tint n,m; scanf(\"%d %d\",&n,&m);\n\tint kk = 0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tif(x==1) kk++;\n\t\t}\n\t}\n\tlong long ans=0;\n\tint k = n+m-2; int tmp = kk;\n\tbool flg = true;\n\twhile(k>=0 && tmp--){\n\t\tif(flg){\n\t\t\tans = (ans+pow2(k))%DVD;\n\t\t}\n\t\telse{\n\t\t\tans = (ans+DVD-pow2(k))%DVD;\n\t\t}\n\t\tflg=!flg; k-=2;\n\t\t\n\t}\n\tans = (kk*ans)%DVD;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n\nstruct fast_io {\n    static constexpr int size_in = 1 << 26, size_out = 1 << 26;\n    char data_in[size_in], data_out[size_out], *p_in, *p_out, s[30];\n    fast_io() { fread(data_in, 1, size_in, stdin), p_in = data_in, p_out = data_out; }\n    ~fast_io() { fwrite(data_out, 1, p_out - data_out, stdout); }\n    void putchar(char x) { *p_out++ = x; }\n    template<typename T> void putint(T x) {\n        if (x < 0) { *p_out++ = '-', x = -x; }\n        int i = 0;\n        do { s[i++] = x % 10 + '0'; } while (x /= 10);\n        while (i--) { *p_out++ = s[i]; }\n    }\n    template<typename T=int> T getint() {\n        while (!isdigit(*p_in) && *p_in != '-') { p_in++; }\n        bool negative = *p_in == '-';\n        T ret = negative ? 0 : *p_in - '0';\n        while (isdigit(*++p_in)) { (ret *= 10) += *p_in - '0'; };\n        return negative ? -ret : ret;\n    }\n} io;\n\nint main() {\n    int N = io.getint(), M = io.getint();\n    using bset = bitset<300>;\n    vector<bset> src(N);\n    rep(i, N) {\n        rep(j, M) {\n            int a = io.getint();\n            src[i][j] = a;\n        }\n    }\n    int rank = 0;\n    for (int i = 0; i < src.size(); i++) {\n        for (int j = src.size() - 1; j > i; j--) {\n            int x = src[j]._Find_first(), y = src[j - 1]._Find_first();\n            if (x < y) { src[j - 1] ^= src[j]; }\n            if (x <= y) { src[j] ^= src[j - 1]; }\n        }\n        if (src[i].none()) { break; }\n        rank++;\n    }\n    constexpr int MOD = 998244353;\n    auto mpow = [&](int n) {\n        long long ret = 1, mul = 2;\n        while (n) {\n            if (n & 1) { (ret *= mul) %= MOD; }\n            (mul *= mul) %= MOD;\n            n >>= 1;\n        }\n        return ret;\n    };\n    io.putint((mpow(N + M - 1) - mpow(N + M - rank - 1) + MOD) % MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353\n\nusing namespace std;\n\nint pow(int x, int pow) {\n\tint res = 1, t = x;\n\twhile (pow) {\n\t\tif (pow & 1) {\n\t\t\tres = 1LL * res * t % MOD;\n\t\t}\n\t\tt = 1LL * t * t % MOD;\n\t\tpow >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tint** mat = new int*[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tmat[i] = new int[m];\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> mat[i][j];\n\t\t}\n\t}\n\tint cur = 0;\n\tfor (int c = 0; c < m; c++) {\n\t\tfor (int r = cur; r < n; r++) {\n\t\t\tif (mat[r][c]) {\n\t\t\t\tswap(mat[cur], mat[r]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!mat[cur][c]) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int r = 0; r < n; r++) {\n\t\t\tif (r != cur && mat[r][c]) {\n\t\t\t\tfor (int k = c; k < m; k++) {\n\t\t\t\t\tmat[r][k] ^= mat[cur][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcur++;\n\t}\n\n\tint tot = pow(2, n + m - 1);\n\ttot -= pow(2, n + m - cur - 1);\n\tif (tot < 0) {\n\t\ttot += MOD;\n\t}\n\tcout << tot << endl;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdelete mat[i];\n\t}\n\tdelete mat;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-9;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll matrixrank(vector< vector<ll> > mat) {\n    ll h = mat.size();\n    ll w = mat[0].size();\n    ll now = 0;\n    for (ll i = 0; i < w; i++) {\n        ll pivot = -1;\n        for (ll j = now; j < h; j++) {\n            if (mat[j][i] != 0) {\n                pivot = j;\n                break;\n            }\n        }\n        if (pivot == -1) {\n            continue;\n        }\n        if (pivot != now) {\n            swap(mat[now], mat[pivot]);\n        }\n        // for (ll j = i + 1; j < w; j++) {\n        //     mat[now][j] /= mat[now][i];\n        // }\n        for (ll j = now + 1; j < h; j++) {\n            if (mat[j][i]) {\n                for (ll k = i + 1; k < w; k++) {\n                    mat[j][k] ^= mat[now][k];\n                }\n            }\n        }\n        now++;\n        if (now == h) {\n            break;\n        }\n    }\n    return now;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n    ll a[N][M];\n    REP(i, 0, N) {\n        REP(j, 0, M) {\n            cin >> a[i][j];\n        }\n    }\n    vector< vector<ll> > mat(N);\n    REP(i, 0, N) {\n        mat[i].resize(M);\n        REP(j, 0, M) {\n            mat[i][j] = a[i][j];\n        }\n    }\n    ll rank = matrixrank(mat);\n    // cout << rank << endl;\n    ll ans = modminus(modpower(2, N + M - 1), modpower(2, N + M - rank - 1));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int Maxn=310;\nconst int inf=2147483647;\nconst int mod=998244353;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn x*f;\n}\nint n,m,a[Maxn][Maxn],b[Maxn][Maxn],c[Maxn],cnt=0;\nint Pow(int x,int y)\n{\n\tif(!y)return 1;\n\tint t=Pow(x,y>>1),re=(LL)t*t%mod;\n\tif(y&1)re=(LL)re*x%mod;\n\treturn re;\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=m;j++)\n\ta[i][j]=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)c[j]=a[i][j];\n\t\tfor(int j=1;j<=m;j++)\n\t\tif(c[j])\n\t\t{\n\t\t\tif(!b[j][j])\n\t\t\t{\n\t\t\t\tfor(int k=j;k<=m;k++)b[j][k]=c[k];\n\t\t\t\tcnt++;break;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int k=j;k<=m;k++)c[k]^=b[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",(LL)(Pow(2,n)-Pow(2,n-cnt)+mod)%mod*Pow(2,m-1)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = (ll)998244353;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n//functions\ninline ll gcd(ll a, ll b){\n   return b ? gcd(b, a % b) : a;\n}\ninline ll pow(ll a, ll b){\n   if(b == 0) return 1;\n   else if(b % 2 == 0) return pow(a * a, b / 2);\n   else return pow(a * a, b / 2) * a;\n}\ninline ll pow(ll a, ll b, ll m){\n   if (b == 0) return 1;\n   else if (b % 2 == 0) return pow(a * a, b / 2, m) % m;\n   else return (pow(a * a, b / 2, m) * a) % m;\n}\ninline ll residue(ll a, ll m){\n   return ((a % m) + m) % m;\n}\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\n\n//与えられたF2上の行列をAとして、(1 << (M * N - rank(A) - 1)) * ((1 << rank(A)) - 1 )が答え.\nconst ll MAX_M = 300, MAX_N = 300;\nll N, M;\nll a[MAX_N][MAX_M];\n\nll rnk(){\n   ll r = 0;\n   ll i = 0, j = 0;\n   while(i < N && j < M){\n      //a[i][j] = 0のときは、k = i + 1, ..., N - 1 からa[k][j] != 0なるkを探してきて, i行目とk行目を入れ替える\n      if(!a[i][j]){\n         FOR(k, i + 1, N){\n            if(a[k][j]){\n               REP(l, M){\n                  swap(a[i][l], a[k][l]);\n               }\n               break;\n            }\n         }\n      }\n      //入れ替えを行ってもa[i][j] = 0のとき（つまりj列目はすべて0のとき)はj列目をスキップ j+1列目にトライ\n      if(!a[i][j]){j++; continue;}\n      r++;\n      //k = i+1,...,N-1行目についてi行目を引く\n      FOR(k, i + 1, N){\n         ll c = a[k][j];\n         REP(l, M){\n            a[k][l] += c * a[i][l];\n            a[k][l] %= 2;\n         }\n      }\n      i++; j++;\n   }\n   return r;\n}\n\nint main(){\n   cin >> N >> M;\n   REP(i, N) REP(j, M) cin >> a[i][j];\n   ll r = rnk();\n/*\n   cout << endl;\n   REP(i, N){\n      REP(j, M){\n         if(j) {cout << \" \";}\n         cout << a[i][j];\n      }\n      cout << endl;\n   }\n   cout << \"rnk = \" << r << endl;\n*/\n   cout << residue(pow(2ll, N + M - 1, MOD) - pow(2ll, N + M - 1 - r, MOD), MOD) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const {\n        long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u);\n    }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r;\n}\ntypedef ModInt<2> mint1;\ntypedef ModInt<998244353> mint2;\nint gauss(vector<vector<int>> A) {\n    int n = A.size(), m = A[0].size();\n    int r = 0;\n    for (int i = 0; r < n && i < m; ++i) {\n        int piv = r;\n        rep(j, r + 1, n) if (abs(A[j][i]) > abs(A[piv][i])) piv = j;\n        A[r].swap(A[piv]);\n        if (abs(A[r][i]) == 0) continue;\n        rrep(k, m - 1, i) A[r][k] /= A[r][i];\n        rep(j, r + 1, n) rrep(k, m - 1, i) A[j][k] ^= A[r][k] * A[j][i];\n        ++r;\n    }\n    return r;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nint N, M;\nint v[606];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n\n    vector<vector<int>> v(N, vector<int>(M));\n\n    rep(i, 0, N) rep(j, 0, M) {\n        int a; cin >> a;\n        v[i][j] = a;\n    }\n\n    int R = gauss(v);\n\n    mint2 ans = ((mint2(2) ^ N) - (mint2(2) ^ (N-R))) * (mint2(2) ^ (M - 1));\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n  int N, M, i, j, k, l, m, n;\n  cin >> N >> M;\n  int a[N][M], count=0;\n  long long int ans=0;\n  for(i=0; i<N; i++){\n    for(j=0; j<M; j++){\n      cin >> a[i][j];\n    }\n  }\n  for(i=0; i<N; i++){\n    for(j=0; j<M; j++){\n      for(k=i; k<N; k++){\n        for(l=j; l<M; l++){\n\n          for(m=i; m<=k; m++){\n            for(n=j; n<=l; n++){\n              if(a[m][n] == 1) count++;\n            }\n          }\n          if(count % 2 == 1) ans = (ans+1)%998244353;\n          count=0;\n        }\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <functional>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\n#define range(i, l, r) for (int i = (l); i <= (r); i++)\n\nusing i64 = int64_t;\n\nusing namespace std;\n\nconst int N = 500;\n\nconst i64 modp = 998244353;\n\nint n, m, a[N][N];\n\nvoid swap_row(int x, int y) {\n\tstatic int t[N];\n\tmemcpy(t, a[x], sizeof(int) * m);\n\tmemcpy(a[x], a[y], sizeof(int) * m);\n\tmemcpy(a[y], t, sizeof(int) * m);\n}\n\nvoid xor_row(int x, int y) {\n\trange(i, 0, m - 1) a[x][i] ^= a[y][i];\n}\n\n// return rank\nint gaussian(int x, int y) {\n\tif (x >= n) return n;\n\tif (y >= m) {\n\t\treturn x;\n\t}\n\tint p = n;\n\trange(i, x, n - 1) if (a[i][y] == 1) { p = i; break; }\n\tif (p >= n) {\n\t\treturn gaussian(x, y + 1);\n\t} else {\n\t\tif (x != p) swap_row(x, p);\n\t\trange(i, x + 1, n - 1) {\n\t\t\tif (a[i][y] == 0) continue;\n\t\t\txor_row(i, x);\n\t\t}\n\t\treturn gaussian(x + 1, y + 1);\n\t}\n}\n\ni64 qpow(i64 a, i64 b) {\n\tif (b == 0) return 1;\n\ti64 t = qpow(a, b >> 1ll);\n\tt = t * t % modp;\n\tif (b & 1) t = t * a % modp;\n\treturn t;\n}\n\nint main() {\n\tcin >> n >> m;\n\trange(i, 0, n - 1) range(j, 0, m - 1) scanf(\"%d\", &a[i][j]);\n\tint r = gaussian(0, 0);\n\ti64 ans = qpow(2, m - 1) * ((qpow(2, n) - qpow(2, n - r)) % modp) % modp;\n\tans = (ans + modp) % modp;\n\tcout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n        mat<COL_SIZE> b(r);\n        for(int i = 0; i < r; i++) b[i] = a[i];\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n//    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n//        return a[index];\n//    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<305>a(m+5);\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = a.rank();\n    cerr << r << endl;\n    cout << (mod_pow(2,n+m-1) - mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\n\nint compute_rank(vector< vector< ll > > A) {\n    int n = A.size();\n    int m = A[0].size();\n    // cout << n << \" \" << m << endl;\n    int rank = n;\n    vector<bool> row_selected(n, false);\n    for (int i = 0; i < m; ++i) {\n        int j;\n        for (j = 0; j < n; ++j) {\n            if (!row_selected[j] && A[j][i])\n                break;\n        }\n\n        if(j != n){\n            row_selected[j] = true;\n            for (int p = i + 1; p < m; ++p)\n                A[j][p] /= A[j][i];\n            \n            A[j][i] = 1;\n\n            for (int k = 0; k < n; ++k) {\n                if (k != j && A[k][i]) {\n                    for (int p = i + 1; p < m; ++p)\n                        A[k][p] -= A[j][p] * A[k][i];\n\n                    A[k][i] = 0;\n                }\n            }\n        }\n    }\n\n    for(int i = 0 ; i < n ; i++){\n        bool has_one = false;\n\n        for(int j = 0 ; j < m ; j++){\n            if(A[i][j]){\n                has_one = true;\n                break;\n            }\n        }\n\n        if(!has_one){\n            rank--;\n        }\n    }\n\n    return rank;\n}\n\nvector< vector< ll > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    // cout << mod * mod << endl;\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            ll x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = compute_rank(a);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n + m - 1);\n    ll nr = fast_pow(2LL, n + m - rank - 1);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD(nn - nr) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\n/*bool operator < (const vector<long long> &a,const vector<long long> &b){\n    bool ret=false;\n    DEBUG(\"called\");\n    for(long long i = 0; i < a.size(); i++){\n        if(a[i]>b[i]){\n            ret=false;\n            break;\n        }else if(a[i]<b[i]){\n            ret=true;\n            break;\n        }\n    }\n    return ret;\n}\n*/\nll cache_pow[600];\nll mpow(ll a){\n    static bool flag=false;\n    if(flag){\n        DEBUG(\"True\");\n        return cache_pow[a];\n    }else{\n        cache_pow[0]=1;\n        for(long long i = 1; i < 600; i++){\n            cache_pow[i]=(cache_pow[i-1]*2)%MOD;\n        }\n        flag=true;\n        return cache_pow[a];\n    }\n}\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    sort(a.begin(),a.end(),greater<vll>());\n    ll index=0;\n\n    vector<bitset<300>> A;\n    for(long long i = 0; i < a.size(); i++){\n        A.push_back(bitset<300>(0));\n        for(long long k = 0; k < a[i].size(); k++){\n            A[i][k]=a[i][k]==1;\n        }\n    }\n    ll rank=0;\n    for(long long i = 0; i < a.size(); i++){\n        DEBUG(i);\n        for(; index < a[i].size(); index++){\n            for(long long j = 0; j < a.size(); j++){\n                if(A[j][index]==1){\n                    swap(A[j],A[i]);\n                    break;\n                }\n            }\n        }\n        if(index==a[i].size()){\n            break;\n        }\n        rank++;\n        for(long long j = i+1; j < a.size()&&A[j][index]==1; j++){\n            A[j]^=A[i];\n        }\n    }\n    DEBUG(rank);\n    cout<<mpow(M+N-1)-mpow(M+N-1-rank)<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VVI a(n, VI(m));\n    REP(i,n) REP(j,m) a[i][j] = in();\n\n    int r = 0, p = 0;\n    REP(i,n){\n        while (p < m){\n            int j = -1;\n            FOR(k,i,n-1){\n                if (a[k][p]){\n                    j = k;\n                    break;\n                }\n            }\n            if (j == -1){\n                p++;\n                continue;\n            }\n            r = i + 1;\n            swap(a[i], a[j]);\n            FOR(j,i+1,n-1){\n                if (!a[j][p]) continue;\n                FOR(k,p,m-1) a[j][k] ^= a[i][k];\n            }\n            p++;\n            break;\n        }\n    }\n\n    ll ans = powll(2, m - 1) * (powll(2, n) - powll(2, n - r) + mod) % mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nint N, M, A[300][300];\nbitset< 300 > X[301], Y[301];\n\n\nint main() {\n  cin >> N >> M;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < M; j++) {\n      cin >> A[i][j];\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    bitset< 300 > tap;\n    for(int j = 0; j < M; j++) {\n      tap[j] = A[i][j];\n    }\n    for(int j = 0; j <= M; j++) {\n      if(tap[j]) {\n        if(X[j][j]) {\n          tap ^= X[j];\n        } else {\n          X[j] = tap;\n          ++ret;\n          break;\n        }\n      }\n    }\n  }\n  int64 all = 1, sub = 1;\n  for(int i = 0; i < N + M - 1; i++) (all *= 2) %= mod;\n  for(int i = 0; i < N + M - ret - 1; i++) (sub *= 2) %= mod;\n  cout << (all + mod - sub) % mod << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n//x,yがax+by=gcd(a,b)の解になる\nll extgcd(ll a, ll b, ll& x, ll& y) {\n\tll d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n//aのmod mでの逆元を求める\nll mod_inverse(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\nconst int N_MAX = 1 << 18;\nll p[N_MAX];\nvoid init() {\n\tp[0] = 1;\n\trep1(i, N_MAX - 1) {\n\t\tp[i] = p[i - 1] * i%mod;\n\t}\n}\n//xCyを求める\nll comb(ll x, ll y, ll m) {\n\tif (x < y)return 0;\n\tll res = p[x];\n\t(res *= mod_inverse(p[y], m)) %= mod;\n\t(res *= mod_inverse(p[x - y], m)) %= mod;\n\treturn res;\n}\nint n, m;\nint a[300][300];\nll odd[300][2];\nll mod_pow(ll x, int n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nll dp[2];\nll cop[2];\nint main() {\n\tinit();\n\tcin >> n >> m;\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\trep(i, n) {\n\t\tint num = 0;\n\t\trep(j, m) {\n\t\t\tif (a[i][j])num++;\n\t\t}\n\t\tfor (int j = 1; j <= num; j += 2) {\n\t\t\todd[i][1] += comb(num, j,mod);\n\t\t}\n\t\todd[i][0] = (mod_pow(2, m) - odd[i][1] + mod) % mod;\n\t}\n\tdp[0] = 1; dp[1] = 0;\n\trep(i, n) {\n\t\trep(j, 2) {\n\t\t\tcop[j] = 0;\n\t\t}\n\t\trep(j, 2) {\n\t\t\trep(k, 2) {\n\t\t\t\t(cop[j^k] += dp[j] * odd[i][k] % mod) %= mod;\n\t\t\t}\n\t\t}\n\t\trep(j, 2) {\n\t\t\tdp[j] = cop[j];\n\t\t}\n\t}\n\tcout << dp[1] << endl;\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=305;\nconst int mod=998244353;\nint n,m,bin[MAXN];\nbitset<MAXN> bi[MAXN];\nint main()\n{\n\tbin[0]=1;for(int i=1;i<MAXN;i++)bin[i]=(bin[i-1]<<1)%mod;\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=m;j++)bi[i][j]=read();\n\tfor(int i=1,p=1;i<=n&&p<=m;i++,p++)\n\t{\n\t\tint u=i;for(int j=i+1;j<=n;j++)if(bi[j][p]){u=j;break;}\n\t\tswap(bi[i],bi[u]);if(!bi[i][p]){--i;continue;}\n\t\tfor(int j=i+1;j<=n;j++)if(bi[j][p])bi[j]^=bi[i];\n\t}int cnt=0;\n\tfor(int i=1;i<=n;i++)if(bi[i].any())++cnt;\n\tcnt=n-cnt;\n\tint val=(bin[n]-bin[cnt]+mod)%mod;\n\tpr2(1LL*val*bin[m-1]%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 998244353;\n\ntemplate <int mod>\nstruct modint {\n    lint v;\n    modint() : v(0) {}\n    modint(signed v) : v(v) {}\n    modint(lint t) {\n        v = t % mod;\n        if (v < 0)\n            v += mod;\n    }\n\n    modint pow(lint k) {\n        modint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n    static modint add_identity() { return modint(0); }\n    static modint mul_identity() { return modint(1); }\n    modint inv() { return pow(mod - 2); }\n\n    modint &operator+=(modint a) {\n        v += a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator-=(modint a) {\n        v += mod - a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator*=(modint a) {\n        v = v * a.v % mod;\n        return *this;\n    }\n    modint &operator/=(modint a) { return (*this) *= a.inv(); }\n\n    modint operator+(modint a) const { return modint(v) += a; };\n    modint operator-(modint a) const { return modint(v) -= a; };\n    modint operator*(modint a) const { return modint(v) *= a; };\n    modint operator/(modint a) const { return modint(v) /= a; };\n\n    modint operator-() const { return v ? modint(mod - v) : modint(v); }\n\n    bool operator==(const modint a) const { return v == a.v; }\n    bool operator!=(const modint a) const { return v != a.v; }\n    bool operator<(const modint a) const { return v < a.v; }\n};\nusing mint = modint<mod>;\nostream &operator<<(ostream &os, mint m) { return os << m.v; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> a(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> a[i][j];\n        }\n    }\n    vector<bool> used(n, false);\n    int rank = 0;\n    for (int i = 0; i < m; ++i) {\n        int idx = -1;\n        for (int j = 0; j < n; ++j) {\n            if (!used[j] && a[j][i] == 1) {\n                idx = j;\n                break;\n            }\n        }\n        if (idx == -1)\n            continue;\n        for (int j = 0; j < n; ++j) {\n            if (j != idx && a[i][j] == 1) {\n                for (int k = i; k < n; ++k) {\n                    a[j][k] ^= a[idx][k];\n                }\n            }\n        }\n        rank++;\n    }\n    mint ret = mint(2).pow(n + m - rank - 1) * (mint(2).pow(rank) - 1);\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<typename T> std::vector<T> xor_eliminate(std::vector<T> src) {\n    std::vector<T> ret;\n    for (int i = src.size() - 1; i >= 0; i--) {\n        for (int j = 0; j < i; j++) {\n            int x = src[j]._Find_first(), y = src[j + 1]._Find_first();\n            if (x < y) { src[j + 1] ^= src[j]; }\n            if (x <= y) { src[j] ^= src[j + 1]; }\n        }\n        if (src[i].none()) { break; }\n        ret.emplace_back(src[i]), src.pop_back();\n    }\n    for (int i = ret.size() - 1; i > 0; i--) {\n        for (int j = i - 1; j >= 0; j--) {\n            if (ret[j][ret[i]._Find_first()]) { ret[j] ^= ret[i]; }\n        }\n    }\n    return ret;\n}\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    using bset = bitset<300>;\n    vector<bset> b(N);\n    rep(i, N) {\n        rep(j, M) {\n            int a;\n            cin >> a;\n            b[i][j] = a;\n        }\n    }\n    using mint = mod_int<998244353>;\n    cout << mint(2).pow(N + M - 1) - mint(2).pow(N + M - xor_eliminate(b).size() - 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds;   \n#define ordered_set tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update> \n#define ld long double\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n#define sz(a) (ll)(a.size())\nconst int M = 302;\nconst ll mod = 998244353;\nint a[M][M];\nll power(ll a,ll b)\n{\n\tll val=1;\n\twhile(b)\n\t{\n\t\tif(b%2)\n\t\t\tval=(val*a)%mod;\n\t\tb/=2;\n\t\ta=(a*a)%mod;\n\t}\n\treturn val;\n}\nint findRank(int n,int m)\n{\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint id = i;\n\t\tfor(int j=i;j<n;j++)\n\t\t\tif(a[j][i] == 1)\n\t\t\t\tid = j;\n\t\tfor(int j=0;j<m;j++)\n\t\t\tswap(a[i][j], a[id][j]);\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(a[j][i]==0 || i == j)\n\t\t\t\tcontinue;\n\t\t\tfor(int k=0;k<m;k++)\n\t\t\t\ta[j][k] ^= a[i][k];\n\t\t}\n\t}\n\tint rank = 0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbool flag = 0;\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(a[i][j])\n\t\t\t\tflag = 1;\n\t\tif(flag)\n\t\t\trank++;\n\t}\n\treturn rank;\n}\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\tcin>>a[i][j];\n\tint r = findRank(n,m);\n\tll v = power(2,m-1);\n\tll x = (power(2,n) - power(2,n-r)+mod)%mod;\n\tll ans = (v*x)%mod;\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG  // gcc\n    #define _LIBCPP_DEBUG 0 // clang\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define _GLIBCXX_DEBUG\n    // #define _LIBCPP_DEBUG 0\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check() { char bufc; if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"\\n----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\npublic:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(), last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n/* dump definition start */\n#ifdef LOCAL\n    #define dump(...) debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\", dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\n/* dump definition end */\n\n/* function utility start */\ntemplate <class T, class... types> T read(types... args) noexcept { T obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = pair<i32, i32>; using pll = pair<i64, i64>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using rheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\n/* using alias end */\n\n/* library start */\n\n#ifndef Modint_hpp\n#define Modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    friend constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    friend constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    constexpr modint(bool x = false) noexcept : val{x} {}\n    constexpr modint(int x) noexcept : val(x & 1) {}\n    constexpr modint(long long x) noexcept : val(x & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val &= other.val, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { assert(other.val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator-(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator*(const modint &other) const noexcept { return val && other.val; }\n    constexpr modint operator/(const modint &other) const noexcept { assert(other.val); return *this; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { assert(y.val); return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint inverse(const modint &other) noexcept { assert(other.val); return other; }\n    friend constexpr modint pow(const modint &other, long long exp) noexcept { return other; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // Modint_hpp\n\n#ifndef MATRIX_HPP\n#define MATRIX_HPP\n// #include <iostream>\n// K must be a field.\ntemplate <class K>\nclass matrix\n{\n    std::vector<std::vector<K>> mat;\n    friend std::istream &operator>>(std::istream &is, matrix &x)\n    {\n        size_t h = x.height(), w = x.width();\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j) is >> x[i][j];\n        }\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const matrix &x)\n    {\n        size_t h = x.height(), w = x.width();\n        for(size_t i = 0; i < h; ++i)\n        {\n            if(i) os << \"\\n\";\n            for(size_t j = 0; j < w; ++j) os << (j ? \" \" : \"\") << x.mat[i][j];\n        }\n        return os;\n    }\n    friend matrix pow(matrix x, long long n)\n    {\n        assert(x.is_square());\n        matrix res = identity(x.height());\n        while(n)\n        {\n            if(n & 1) res *= x;\n            x *= x, n >>= 1;\n        }\n        return res;\n    }\n    friend matrix inverse(const matrix &x)\n    {\n        assert(x.is_square());\n        size_t n = x.height();\n        matrix ext_x(x), e(identity(n)), res(n);\n        for(size_t i = 0; i < n; ++i) ext_x[i].insert(end(ext_x[i]), begin(e[i]), end(e[i]));\n        ext_x = ext_x.row_canonical_form();\n        for(size_t i = 0; i < n; ++i)\n        {\n            if(std::vector<K>(begin(ext_x[i]), begin(ext_x[i]) + n) != e[i]) return matrix();\n            res[i] = std::vector<K>(begin(ext_x[i]) + n, end(ext_x[i]));\n        }\n        return res;\n    }\npublic:\n    matrix() {}\n    matrix(size_t n) { assign(n, n);}\n    matrix(size_t h, size_t w) { assign(h, w); }\n    matrix(const matrix &x) : mat(x.mat) {}\n    matrix(const std::vector<std::vector<K>> _mat) : mat(_mat) {}\n    size_t height() const { return mat.size(); }\n    size_t width() const { return mat.empty() ? 0 : mat[0].size(); }\n    bool is_square() const { return height() == width(); }\n    void resize(size_t h, size_t w, const K v = K(0)) { mat.resize(h, std::vector<K>(w, v)); }\n    void assign(size_t h, size_t w, const K v = K()) { mat.assign(h, std::vector<K>(w, v)); }\n    std::vector<K> &operator[](const size_t i) { return mat[i]; }\n    static matrix identity(size_t n)\n    {\n        matrix ret(n, n);\n        for(size_t i = 0; i < n; ++i) ret[i][i] = K(1);\n        return ret;\n    }\n    matrix operator-() const\n    {\n        size_t h = height(), w = width();\n        matrix res(*this);\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                res[i][j] = -mat[i][j];\n            }\n        }\n        return res;\n    }\n    matrix operator&(const matrix &x) const { return matrix(*this) &= x; }\n    matrix operator|(const matrix &x) const { return matrix(*this) |= x; }\n    matrix operator^(const matrix &x) const { return matrix(*this) ^= x; }\n    matrix operator+(const matrix &x) const { return matrix(*this) += x; }\n    matrix operator-(const matrix &x) const { return matrix(*this) -= x; }\n    matrix operator*(const matrix &x) const { return matrix(*this) *= x; }\n    matrix &operator&=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                mat[i][j] &= x.mat[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator|=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                mat[i][j] |= x.mat[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator^=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                mat[i][j] ^= x.mat[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator+=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                mat[i][j] += x.mat[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator-=(const matrix &x)\n    {\n        size_t h = height(), w = width();\n        assert(h == x.height() and w == x.width());\n        for(size_t i = 0; i < h; ++i)\n        {\n            for(size_t j = 0; j < w; ++j)\n            {\n                mat[i][j] -= x.mat[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix &operator*=(const matrix &x)\n    {\n        size_t l = height(), m = width(), n = x.width();\n        assert(m == x.height());\n        matrix res(l, n);\n        for(size_t i = 0; i < l; ++i)\n        {\n            for(size_t j = 0; j < m; ++j)\n            {\n                for(size_t k = 0; k < n; ++k)\n                {\n                    res[i][k] += mat[i][j] * x.mat[j][k];\n                }\n            }\n        }\n        return *this = res;\n    }\n    std::vector<size_t> row_canonicalize()\n    {\n        std::vector<size_t> pivots;\n        const size_t h = height(), w = width();\n        for(size_t j = 0, rank = 0; j != w; ++j)\n        {\n            bool ispiv = false;\n            for(size_t i = rank; i != h; ++i)\n            {\n                if(mat[i][j] != K{})\n                {\n                    if(ispiv)\n                    {\n                        const K r = -mat[i][j];\n                        for(size_t k = j; k != w; ++k) mat[i][k] += mat[rank][k] * r;\n                    }\n                    else\n                    {\n                        swap(mat[rank], mat[i]);\n                        K r = mat[rank][j];\n                        for(size_t k = j; k != w; ++k) mat[rank][k] /= r;\n                        for(size_t k = 0; k != rank; ++k)\n                        {\n                            r = -mat[k][j];\n                            for(size_t l = j; l != w; ++l) mat[k][l] += mat[rank][l] * r;\n                        }\n                        ispiv = true;\n                    }\n                }\n            }\n            if(ispiv)\n            {\n                ++rank;\n                pivots.emplace_back(j);\n            }\n        }\n        return pivots;\n    }\n    K determinant() const\n    {\n        matrix<K> x(*this);\n        assert(is_square());\n        size_t n = height();\n        K res(1);\n        for(size_t j = 0; j < n; ++j)\n        {\n            bool ispiv = false;\n            for(size_t i = j; i < n; ++i)\n            {\n                if(x[i][j] != K{})\n                {\n                    if(ispiv)\n                    {\n                        const K r = -x[i][j];\n                        for(size_t k = j; k < n; ++k) x[i][k] += x[j][k] * r;\n                    }\n                    else\n                    {\n                        swap(x[i], x[j]);\n                        if(i != j) res = -res;\n                        const K r = x[j][j];\n                        res *= r;\n                        for(size_t k = j; k < n; ++k) x[j][k] /= r;\n                        ispiv = true;\n                    }\n                }\n            }\n            if(!ispiv) return K(0);\n        }\n        return res;\n    }\n};\n#endif\n\n/* library end */\n\n/* The main code follows. */\n\nusing mint=modint<998244353>;\n\nstruct solver\n{\n    solver()\n    {\n        input(int,h);\n        input(int,w);\n        input(matrix<modint<2>>,a,h,w);\n        int rank=a.row_canonicalize().size();\n        int kdim=w-rank;\n        mint _2{2};\n        cout << pow(_2,h+w)-pow(_2,kdim+h)-(pow(_2,w)-pow(_2,kdim))*pow(_2,h-1) << \"\\n\";\n    }\n}; // struct solver\n\nint main(int argc, char *argv[])\n{\n    u32 t; // loop count\n#ifdef LOCAL\n    t = 1;\n#else\n    t = 1; // single test case\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--)\n    {\n        solver();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n\n#define cMOD 998244353ULL\n#define cINF ((1ull<<62)-1)\n#define cINFINT ((1<<30)-1)\n\n\ntemplate <typename T>\nvoid calcFactional_mod( size_t size, \n\tvector<T>& fac, vector<T>& inv, vector<T>& facInv, T mod )\n{\n\tfor( T i = 2; i < size; ++i )\n\t{\n\t\tfac[i] = fac[i - 1] * i % mod; // n! % mod\n\t\tinv[i] = mod - inv[mod % i] * ( mod / i ) % mod; // 逆元計算 (n)^-1 % mod\n\t\tfacInv[i] = facInv[i - 1] * inv[i] % mod; // (n!)^-1 % mod\n\t}\n}\ntemplate <typename T>\nT pow_mod(T x, T n, T mod)\n{\n\tT res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (res * x) % mod;\n\t\tx = (x * x) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\ntemplate< typename T >\nclass Matrix\n{\npublic:\n\texplicit Matrix( size_t row_size, size_t col_size )\n\t{\n\t\tassign( row_size, col_size );\n\t}\n\n\tvoid assign( size_t row_size, size_t col_size )\n\t{\n\t\tmElement.assign( row_size, vector<T>() );\n\t\tREP( i, row_size ) mElement[i].assign( col_size, T(0) );\n\t}\n\n\tconst vector<T>& operator[] ( size_t row ) const\n\t{ return mElement[row]; }\n\tvector<T>& operator[] ( size_t row )\n\t{ return mElement[row]; }\n\n\tconst size_t rowSize() const\n\t{ return mElement.size(); }\n\tconst size_t colSize() const\n\t{ return mElement[0].size(); }\n\n\t/*T get( size_t row, size_t col ) const\n\t{ return mElement[row][col]; }\n\tvoid set( size_t row, size_t col, T value )\n\t{ mElement[row][col] = value; }*/\n\n\tMatrix<T> operator* ( const Matrix& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.rowSize() );\n\t\tMatrix ret( this->rowSize(), rhs.colSize() );\n\t\tREP( i, ret.rowSize() )\n\t\tREP( k, k_ )\n\t\tREP( j, ret.colSize() )\n\t\t\tret[i][j] = ret[i][j] + (*this)[i][k] * rhs[k][j];\n\t\treturn ret;\n\t}\n\n\tvector<T> operator* ( const vector<T>& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.size() );\n\t\tvector<T> ret( this->rowSize(), T() );\n\t\tREP( i, ret.size() )\n\t\tREP( k, k_ )\n\t\t\tret[i] = ret[i] + (*this)[i][k] * rhs[k];\n\t\treturn ret;\n\t}\n\n\t// O( N^3 )\n\t// Ax = b を解く\n\t// T = double にしないと割り算で狂うので注意\n\tstruct GaussJordanData\n\t{\n\t\tint rank = 0;\n\t\tint result = 0; // -1:解なし 0:不定 1:解あり\n\t\tvector<T> solution;\n\t};\n\tGaussJordanData gaussJordan() const\n\t{\n\t\tvector<T> b( rowSize(), 0 );\n\t\treturn gaussJordan( b );\n\t}\n\tGaussJordanData gaussJordan( const vector<T>& b ) const\n\t{\n\t\tGaussJordanData data;\n\t\tdata.result = 1;\n\n\t\t// 1列余分に取って、そこにbを入れる\n\t\tMatrix<T> B( rowSize(), colSize() + 1 );\n\t\tREP( i, rowSize() ) REP( j, colSize() + 1 )\n\t\t{\n\t\t\tif( j < colSize() ) B[i][j] = (*this)[i][j];\n\t\t\telse B[i][j] = b[i];\n\t\t}\n\n\t\tfor( int i = 0, j = 0; i < rowSize() && j < colSize(); ++i, ++j )\n\t\t{\n\t\t\t// j列目の値の絶対値が大きい行をi行目に持ってくる\n\t\t\tsize_t pivot = i;\n\t\t\tfor( int k = i + 1; k < rowSize(); ++k )\n\t\t\t\tif( abs( B[k][j] )> abs( B[pivot][j] ) ) pivot = k;\n\t\t\tswap( B[i], B[pivot] );\n\t\t\t// 解が一意でない\n\t\t\tif( abs( B[i][j] ) <= numeric_limits<T>::epsilon() )\n\t\t\t{\n\t\t\t\t--i;\n\t\t\t\tdata.result = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Rankを1増やす\n\t\t\t++data.rank;\n\t\t\t// [i][j]を1にするようにi行目を割る\n\t\t\tfor( int l = j + 1; l <= colSize(); ++l )\n\t\t\t\tB[i][l] /= B[i][j];\n\t\t\tB[i][j] = 1;\n\t\t\t// k番目の行からi番目の行を引いて、j番目の列の数を消去\n\t\t\tREP( k, rowSize() ) if( k != i )\n\t\t\t{\n\t\t\t\tT coef = B[k][j];\n\t\t\t\tfor( int l = j; l <= colSize(); ++l )\n\t\t\t\t\tif( coef & B[i][l] == 1 )\n\t\t\t\t\t\tB[k][l] ^= 1;\n\t\t\t}\n\t\t}\n\n\t\t// 解xを作る\n\t\tdata.solution.assign( colSize(), T() );\n\t\tfor( int i = 0, j = 0; j < colSize(); ++i, ++j )\n\t\t{\n\t\t\tif( i >= rowSize() || B[i][j] == 0 )\n\t\t\t{\n\t\t\t\tdata.solution[j] = 0;\n\t\t\t\t--i; continue;\n\t\t\t}\n\t\t\telse data.solution[j] = *( B[i].rbegin() );\n\t\t}\n\n\t\t// 解なしかをチェック\n\t\tif( data.result == 0 || ( data.rank ) < b.size() )\n\t\t{\n\t\t\tauto m = ( *this ) * data.solution;\n\t\t\tREP( i, m.size() ) if( m[i] != b[i] )\n\t\t\t{ data.result = -1; break; }\n\t\t}\n\t\tif( data.result != -1 )\n\t\t{\n\t\t\t// 解が一意\n\t\t\tif( data.rank == colSize() ) data.result = 1;\n\t\t\t// 解が不定\n\t\t\telse data.result = 0;\n\t\t}\n\t\t\n\t\treturn data;\n\t}\n\nprotected:\n\tvector<vector<T>> mElement;\n};\n\n\nint main()\n{\n\tauto mod = cMOD;\n\tauto add = [mod]      ( ll a, ll b ) { return ( a + b ) % mod; };\n\tauto sub = [mod]      ( ll a, ll b ) { return ( a + mod -b ) % mod; };\n\tauto mul = [mod]      ( ll a, ll b ) { return a * b % mod; };\n\tauto pow = [mod]      ( ll a, ll b ) { return pow_mod<ll>( a, b, mod ); };\n\t\n\tll n, m; cin >> n >> m;\n\tMatrix<int> mtx( n, m );\n\tREP( i, n ) REP( j, m ) cin >> mtx[i][j];\n\t\n\tauto data = mtx.gaussJordan();\n\tauto ans = sub( pow( 2, n + m - 1 ), pow( 2, n + m - data.rank - 1 ) );\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cassert>\n#define SIZE 305\n#define MOD 998244353\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct Rank\n{\n\tstruct P\n\t{\n\t\tvector <int> vec;\n\t\tint val;\n\t\tP(){}\n\t\tP(vector <int> vec,int val=0):vec(vec),val(val){}\n\t};\n\tvector <P> express[SIZE];\n\tbool use[SIZE];\n\t\n\tvoid add(vector <int> vec,int n,int v)\n\t{\n\t\tmemset(use,false,sizeof(use));\n\t\tfor(int i=0;i<vec.size();i++)\n\t\t{\n\t\t\tuse[vec[i]]=true;\n\t\t}\n\t\tvector <int> ad;\n\t\tint c=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(use[i])\n\t\t\t{\n\t\t\t\tif(c==-1) c=i;\n\t\t\t\tad.push_back(1);\n\t\t\t}\n\t\t\telse ad.push_back(0);\n\t\t}\n\t\tif(c!=-1) express[c].push_back(P(ad,v));\n\t}\n\tll calc(int n)\n\t{\n\t\tll ret=1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(express[i].empty())\n\t\t\t{\n\t\t\t\tret*=2;\n\t\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tP p=express[i][0];\n\t\t\t\tfor(int j=1;j<express[i].size();j++)\n\t\t\t\t{\n\t\t\t\t\tP q=express[i][j];\n\t\t\t\t\tif(q.vec==p.vec)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(p.val!=q.val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint c=-1;\n\t\t\t\t\tfor(int j=i;j<n;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tq.vec[j]^=p.vec[j];\n\t\t\t\t\t\tif(c==-1&&q.vec[j]==1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq.val^=p.val;\n\t\t\t\t\texpress[c].push_back(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}rnk;\nint A[SIZE][SIZE];\nll rt[SIZE*2];\n\nvoid make()\n{\n\trt[0]=1;\n\tfor(int i=1;i<SIZE*2;i++) rt[i]=rt[i-1]*2LL%MOD;\n}\nint main()\n{\n\tmake();\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvector <int> vec;\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&A[i][j]);\n\t\t\tif(A[i][j]==1) vec.push_back(j);\n\t\t}\n\t\trnk.add(vec,m,0);\n\t}\n\tll rk=rnk.calc(m);\n\tll all=rt[n+m];\n\tall-=rk*rt[n]%MOD;\n\tif(all<0) all+=MOD;\n\tif(all%2==1) all+=MOD;\n\tall/=2;\n\tprintf(\"%lld\\n\",all);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#ifdef MY_DEBUG\n#include \"header/header.hpp\"\n#else\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n#ifdef MY_DEBUG\n#include\"print.hpp\"\n#include\"debug.hpp\"\n#endif\n// }}}\n\nconst long long MOD = 998244353;\n\n//{{{ modular algebra\ntemplate<int mod=MOD>\nstruct Num{\n\tint v;\n\tNum(int n):v(n){}\n\tNum():v(0){}\n\toperator int() const {return v;}\n\toperator long long() const {return v;}\n\ttemplate<class T>\n\tNum operator =(int n){v=n;return *this;}\n\n\ttemplate<class T>\n\tinline void operator *=(const T &a) {\n\t\tv = (v*(long long)a)%mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator *(const T &a) {\n\t\tNum n(*this);n*=a;\n\t\treturn n;\n\t}\n\ttemplate<class T>\n\tinline void operator+=(const T &a){\n\t\tv+=(int)a;\n\t\tif(v>=mod)v-=mod;\n\t\t//\tassert(0<=v and v<mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator+(const T &a){\n\t\tNum n(*this);n+=a;\n\t\treturn n;\n\t}\n\tinline Num operator -(){\n\t\tif(v==0)return 0;\n\t\telse return Num(mod-v);\n\t}\n\ttemplate<class T>\n\tinline void operator -=(const T &a){\n\t\tv-=(int)a;\n\t\tif(v<0)v+=mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator -(const T &a){\n\t\tNum n(*this);n-=a;\n\t\treturn n;\n\t}\n\n#ifdef __GCD_H\n\tinline Num inv(){\n\t\treturn Num(invMod(this->v,mod));\n\t}\n\ttemplate<class T>\n\tinline void operator /=(const T &a){\n\t\t(*this)*=invMod((int)a,mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator /(const T &a){\n\t\tNum n(*this);n/=a;\n\t\treturn n;\n\t}\n#endif\n};\n\ntemplate<int mod=MOD>\nint abs(Num<mod> &a){\n\treturn a.v;\n}\ntemplate<class T, int mod>\nT& operator <<(T &os, const Num<mod> &n){\n\tos<<(int)n.v;\n\treturn os;\n}\n\ntemplate<class T, int mod>\nT& operator >>(T &is, Num<mod> &n){\n\tis>>n.v;\n\treturn is;\n}\n//}}}\ntypedef Num<MOD> mod_int;\n\n//{{{ mod_pow(Num<mod> x,Int k)\n/* (x^k)%m */\ntemplate<int mod=MOD>\ninline Num<mod> mod_pow(Num<mod> x, Int k){\n\tif(k==0) return 1;\n\tNum<mod> res(mod_pow(x,k/2));\n\tres*=res;\n\tif(k%2)res*=x;\n\treturn res;\n}\n//}}}\n\nInt N;\nInt M;\nvector<vector<Int>> a;\nvector<vector<Int>> a2;\n\n//{{{ rix library: MATRIX<T> A(n); MATRIX<T> A(n,m); VECTOR<T> v(n);\ntemplate<class T>\nstruct VECTOR:public vector<T>{\n\tconst int &n;\n\tVECTOR(const int &n):n(n){\n\t\tthis->assign(n,0);\n\t}\n};\n\n// O( n )\ntemplate<class T>\nT inner_product(const VECTOR<T> &a, const VECTOR<T> &b) {\n\tT ans = 0;\n\tfor (int i = 0; i < a.n; ++i)\n\t\tans += a[i]*b[i];\n\treturn ans;\n}\n\ntemplate<class T>\nstruct MATRIX:vector<vector<T> > {\n\tconst int n,m;\n\tMATRIX(int n):n(n),m(n){\n\t\tthis->assign(n,vector<T>(n,0));\n\t}\n\tMATRIX(const pair<int,int> &p):n(p.first),m(p.second){\n\t\tthis->assign(n,vector<T>(m,0));\n\t}\n\t// O( n )\n\tvoid operator+=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] += B[i][j];\n\t}\n\tvoid operator-=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] -= B[i][j];\n\t}\n};\n\ntemplate<class T>\nMATRIX<T> identity(int n) {\n\tMATRIX<T> A(n);\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> zero(int n) {\n\tMATRIX<T> A(n);\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> operator+(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC+=B;\n\treturn C;\n}\ntemplate<class T>\nMATRIX<T> operator-(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC-=B;\n\treturn C;\n}\n// O( n^2 )\ntemplate<class T>\nVECTOR<T> operator*(const MATRIX<T> &A, const VECTOR<T> &x) {\n\tVECTOR<T> y(A.n);\n\tfor (int i = 0; i < A.n; ++i)\n\t\tfor (int j = 0; j < A.m; ++j)\n\t\t\ty[i] += T(A[i][j])*x[j];\n\treturn y;\n}\n// O( n^3 )\ntemplate<class T>\nMATRIX<T> operator*(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C({A.n,B.m});\n\tfor (int i = 0; i < C.n; ++i)\n\t\tfor (int j = 0; j < C.m; ++j)\n\t\t\tfor (int k = 0; k < A.m; ++k)\n\t\t\t\tC[i][j] += T(A[i][k])*B[k][j];\n\treturn C;\n}\n// O( n^3 )\ntemplate<class T>\nvoid operator*=(MATRIX<T> &A, const MATRIX<T> &B){\n\tA = A*B;\n}\n\n// O( n^3 log e )\ntemplate<class T>\nMATRIX<T> pow(const MATRIX<T> &A, long long e) {\n\treturn e == 0 ? identity<T>(A.size())  :\n\te % 2 == 0 ? pow(A*A, e/2) : A*pow(A, e-1);\n}\n\ntypedef int Number;\ntypedef MATRIX<Number> Matrix;\ntypedef VECTOR<Number> Vector;\n\n//}}}\n\n//{{{ gauss\ntemplate<class T>\nint gauss(MATRIX<T> &A, VECTOR<T> &b) {\n\t//int gauss(& A) {//returns rank\n\tconst int n = A.size(),m = A[0].size();\n\tint pi = 0;\n\tfor(int pj = 0;pj < m;pj++){\n\t\tfor(int i = pi+1; i < n; i++) {\n\t\t\tif (abs(A[i][pj]) > abs(A[pi][pj])) {\n\t\t\t\tswap(A[i], A[pi]);\n\t\t\t\tswap(b[i], b[pi]);\n\t\t\t}\n\t\t}\n\t\tif (abs(A[pi][pj]) > 0) {\n\t\t\tT d = A[pi][pj];//1/A[pi][pj]\n\t\t\tREP(j, m)A[pi][j] *= d;\n\t\t\tb[pi] *= d;\n\t\t\tREP(i,n){\n\t\t\t\tif(i==pi)continue;\n\t\t\t\tT k = A[i][pj];\n\t\t\t\tREP(j, m) A[i][j] -= k * A[pi][j];\n\t\t\t\tb[i] -= k * b[pi];\n\t\t\t}\n\t\t\tpi++;\n\t\t}\n\t}\n\treturn pi;\n\t/*\n\t   for(int i = pi; i < n; i++)\n\t   if (abs(b[i]) > 0)\n\t   throw Inconsistent();\n\t   if (pi < m || pj < m)\n\t   throw Ambiguous();\n\t   for(int j = m-1; j >= 0; j--)\n\t   REP(i, j)\n\t   b[i] = modulo(b[i] - b[j] * A[i][j]);\n\t   */\n}\n//}}}\n\nvoid solve(){\n\tMATRIX<Num<2> > a2({N,M});\n\tVECTOR<Num<2> > b(N);\n\tREP(i,N)REP(j,M)a2[i][j] = a[i][j];\n\tint t = gauss(a2,b);\n\t/*\n\tREP(i,a2.size()){\n\t\tREP(j,a2[0].size()){\n\t\t\tcout<<a2[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<t<<endl;\n\t*/\n\tmod_int ans = mod_pow((mod_int)2,N) - mod_pow((mod_int)2,t-N);\n\tans *= mod_pow((mod_int)2,M-1);\n\tcout<<ans<<endl;\n}\n\n//{{{ main fucnction\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> N;\n\tcin >> M;\n\ta.assign(N, vector<Int>(M));\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < M ; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tsolve();\n\treturn 0;\n}\n\n//}}}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t r = 0;\n    for (std::size_t c = 0; c < mat.C; c++) {\n        if (r == mat.R) { return r; }\n        std::size_t piv = r;\n        for (; piv < mat.R and mat[piv][c] == 0; piv++) {}\n        if (piv == mat.R) { continue; }\n        std::swap(mat[r], mat[piv]);\n        for (std::size_t j = c + 1; j < mat.C; j++) { mat[r][j] /= mat[r][c]; }\n        const T p = mat[r][c];\n        for (std::size_t i = r; i < mat.R; i++) { mat[i][c] /= p; }\n        for (std::size_t i = r + 1; i < mat.R; i++) {\n            for (std::size_t j = i + 1; j < mat.C; j++) { mat[i][j] -= mat[r][j] * mat[i][c]; }\n        }\n        r++;\n    }\n    return r;\n}\nusing ll = long long;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T MOD() { return 1000000007; }\ntemplate <typename T, T mod = MOD<T>()>\nclass ModInt\n{\nprivate:\n    T value;\n    static T pow(const T p, const T n) { return p < 0 ? pow(mod + p, n) : n == 0 ? 1 : n % 2 == 1 ? pow(p, n - 1) * p % mod : pow(p * p % mod, n / 2); }\n    static T inv(const T p) { return pow(p, mod - 2); }\n\npublic:\n    ModInt() : value{0} {}\n    ModInt(const T val) : value{((val % mod) + mod) % mod} {}\n    ModInt(const ModInt<T, mod>& n) : value{n()} {}\n    ModInt<T, mod>& operator=(const ModInt<T, mod>& n) { return value = n(), (*this); }\n    ModInt<T, mod>& operator=(const T v) { return value = (mod + v % mod) % mod, (*this); }\n    ModInt<T, mod> operator+() const { return *this; }\n    ModInt<T, mod> operator-() const { return ModInt{mod - value}; }\n    ModInt<T, mod> operator+(const ModInt<T, mod>& val) const { return ModInt{value + val()}; }\n    ModInt<T, mod> operator-(const ModInt<T, mod>& val) const { return ModInt{value - val() + mod}; }\n    ModInt<T, mod> operator*(const ModInt<T, mod>& val) const { return ModInt{value * val()}; }\n    ModInt<T, mod> operator/(const ModInt<T, mod>& val) const { return ModInt{value * inv(val())}; }\n    ModInt<T, mod>& operator+=(const ModInt<T, mod>& val) { return (((value += val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const ModInt<T, mod>& val) { return (((value -= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const ModInt<T, mod>& val) { return (((value *= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const ModInt<T, mod>& val) { return (((value *= inv(val())) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod> operator+(const T val) const { return ModInt{value + val}; }\n    ModInt<T, mod> operator-(const T val) const { return ModInt{value - val}; }\n    ModInt<T, mod> operator*(const T val) const { return ModInt{value * val}; }\n    ModInt<T, mod> operator/(const T val) const { return ModInt{value * inv(val)}; }\n    ModInt<T, mod>& operator+=(const T val) { return (((value += val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const T val) { return (((value -= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const T val) { return (((value *= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const T val) { return (((value *= inv(val)) %= mod) += mod) %= mod, (*this); }\n    bool operator==(const ModInt<T, mod>& val) const { return value == val.value; }\n    bool operator!=(const ModInt<T, mod>& val) const { return not(*this == val); }\n    bool operator==(const T val) const { return value == (mod + val % mod) % mod; }\n    bool operator!=(const T val) const { return not(*this == val); }\n    T operator()() const { return value; }\n};\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator+(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator-(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{-n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator*(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() * val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator/(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>(val) / n; }\ntemplate <typename T, T mod>\ninline bool operator==(const T val, const ModInt<T, mod>& n) { return n == val; }\ntemplate <typename T, T mod>\ninline bool operator!=(const T val, const ModInt<T, mod>& n) { return not(val == n); }\ntemplate <typename T, T mod>\ninline std::istream& operator>>(std::istream& is, ModInt<T, mod>& n)\n{\n    T v;\n    return is >> v, n = v, is;\n}\ntemplate <typename T, T mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<T, mod>& n) { return (os << n()); }\nusing mint = ModInt<int, MOD<int>()>;\nusing mll = ModInt<ll, MOD<ll>()>;\nconstexpr int MOD2 = 998244353;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<ModInt<int, 2>> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<int> bp(600, 1);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2 % MOD2; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD2) % MOD2 << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,a) for(int i=start[(a)];i;i=e[i].next)\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\ninline int read()\n{\n\tint sum=0,p=1;char ch=getchar();\n\twhile(!(('0'<=ch && ch<='9') || ch=='-'))ch=getchar();\n\tif(ch=='-')p=-1,ch=getchar();\n\twhile('0'<=ch && ch<='9')sum=sum*10+ch-48,ch=getchar();\n\treturn sum*p;\n}\n\nconst int mod=998244353;\nconst int maxn=320;\n\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(ll)ans*a%mod;\n\t\tb>>=1;\n\t\ta=(ll)a*a%mod;\n\t}\n\treturn ans;\n}\n\nint a[maxn][maxn],n,m;\nbitset<300>b[maxn];\nbitset<300>s[maxn];int vis[maxn];\n\ninline void insert(bitset<300> x)\n{\n\tDREP(i,m,1)if(x[i])\n\t{\n\t\tif(!vis[i]){ s[i]=x;vis[i]=1; break;}\n\t\telse x^=s[i];\n\t}\n}\n\ninline void init()\n{\n\tn=read();m=read();\n\tREP(i,1,n)REP(j,1,m)a[i][j]=read();\n\tREP(j,1,m)\n\t{\n\t\tint s=0;\n\t\tREP(i,1,n)s+=a[i][j];\n\t\tif(s&1)REP(i,1,n)a[i][j]^=1;\n\t}\n\tREP(i,1,n)REP(j,1,m)if(a[i][j])b[i].set(j);\n\tREP(i,1,n)\n\t{\n\t\tinsert(b[i]);\n\t}\n}\n\ninline void doing()\n{\n\tint ss=0; REP(i,1,m)ss+=vis[i];\n\tint ans=(ll)(power(2,n)-power(2,n-ss)+mod)*power(2,m-1)%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\nusing VVI=vector<vector<int>>;\n\n\nint rank_f2(VVI vec){\n\tint n=vec.size();\n\tif(n==0) return 0;\n\tint m=vec[0].size();\n\t\n\t// n*m行列\n\tint sumi=0;\n\tfor(int j=0;j<m;j++){\n\t\tint it=-1;\n\t\tfor(int i=sumi;i<n;i++)if(vec[i][j]){\n\t\t\tbool bo=0;\n\t\t\tit=i;\n\t\t\tbreak;\n\t\t}\n\t\tif(it>=0){\n\t\t\tif(it!=sumi)swap(vec[it],vec[sumi]);\n\t\t\tsumi++;\n\t\t\tfor(int i=sumi;i<n;i++)if(vec[i][j]){\n\t\t\t\tfor(int h=j;h<m;h++) vec[i][h]^=vec[sumi-1][h];\n\t\t\t}\n\t\t}\n\t}\n\treturn sumi;\n}\n\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n\tint n,m;\n\tcin>>n>>m;\n \tVVI V;\n \tfor(int i=0;i<n;i++){\n \t\tvector<int> ve;\n \t\tfor(int j=0;j<m;j++){\n \t\t\tint y;\n \t\t\tcin>>y;\n \t\t\tve.pb(y);\n \t\t}\n \t\tV.pb(ve);\n \t}\n \tint wa=rank_f2(V);\n\t\n \twa=n-wa;\n\tmod=998244353;\n\t\n\tint dame=beki(2,wa,mod);\n\tint ok=(beki(2,n,mod)+mod-dame)%mod;\n\t\n\tint ans1=dame*beki(2,m,mod)%mod;\n\tint ans2=ok*beki(2,m-1,mod)%mod;\n\t\n\tint ans=(ans1+ans2)%mod;\n\t\n\tint zen=beki(2,m+n,mod);\n\tcout<<(zen+mod-ans)%mod<<endl;\n \t\n \treturn 0;\n  }"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) {rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;}\n#define show2d(v) {rep(__,v.size())show1d(v[__]);}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\n#define yes cout<<\"Yes\\n\"\n#define no cout<<\"No\\n\"\n\n//ガウスの消去法\n#define BIT_N 333\ntypedef bitset<BIT_N> Bit;\nvector<Bit> gauss(vector<Bit> &v, ll &ran){\n\tran = 0;\n\trep(i,BIT_N) {\n\t\tint pla = -1;\n\t\tfor(int j = ran;j < v.size();j++){\n\t\t\tif(v[j][i] == 1){\n\t\t\t\tpla = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(pla != -1){\n\t\t\tswap(v[ran], v[pla]);\n\t\t\tfor(int j = 0;j < v.size();j++){\n\t\t\t\tif(j != ran && v[j][i] == 1)v[j] ^= v[ran];\n\t\t\t}\n\t\t\tran++;\n\t\t}\n\t}\n\treturn v;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n,m;\n\tcin>>n>>m;\n\tvector<Bit>in(n);\n\trep(i,n)rep(j,m){\n\t\tint a;cin>>a;\n\t\tif(a)in[i][j]=1;\n\t}\n\tint rank;\n\tvector<Bit>out=gauss(in,rank);\n\tint MOD=998244353;\n\tvi po(333,1);\n\tloop(i,1,333)po[i]=po[i-1]*2%MOD;\n\tcout<<(MOD+po[n+m-1]-po[n+m-rank-1])%MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void read(T &x)\n{\n    x=0; char c=getchar();  int f=1;\n    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\n#include <bitset>\nconst int mod=998244353;\nll Pow(ll x,ll y){ll res=1; while(y){if(y&1) res=res*x%mod; x=x*x%mod,y>>=1;} return res;}\nbitset<310> f[310];\nint n,m;\nint main()\n{\n\tint x; read(n),read(m);\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j) read(x),f[i][j]=x;\n\tint ans=0;\n\tfor(int i=0;i<m;++i)\n\t{\n\t\tfor(int j=i;j<n;++j) if(f[j][i]){if(j!=i)swap(f[i],f[j]); break;}//必须循环到n \n\t\tif(!f[i][i]){ans++; continue;}\n\t\tfor(int j=i+1;j<m;++j) if(f[j][i]) f[j]^=f[i];\n\t}\n//\tcout<<ans<<endl;\n\tprintf(\"%lld\",((Pow(2,m+n-1)-Pow(2,ans+n-1))%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint main(){\n\tint N,M; cin >> N >> M;\n\tconst LL mod = 998244353;\n\tvector<bitset<300>> b(N,bitset<300>(0));\n\trepp(i,0,N) repp(j,0,M){\n\t\tint a; cin >> a;\n\t\tb[i][j] = a;\n\t}\n\tint k = 0;\n\trepp(j,0,M){\n\t\tint i = k;\n\t\twhile(i < N && !b[i][j]) ++i;\n\t\tif(i == N) continue;\n\t\tswap(b[k],b[i]);\n\t\trepp(p,k+1,N) b[p] ^= b[k];\n\t\t++k;\n\t}\n\tLL z = 1;\n\trepp(i,k,N) z = z*2%mod;\n\tLL ans = 1;\n\trepp(i,0,N) ans = ans*2%mod;\n\tans = (ans+mod-z)%mod;\n\trepp(i,1,M) ans = ans*2%mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define maxn 330\nusing namespace std;\ninline int getint(){\n    char c=getchar();int x=0;bool p=0;\n    while((c>'9'||c<'0')&&c!='-')c=getchar();\n    if(c=='-')p=1,c=getchar();\n    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();\n    if(p)x=-x;return x;\n}\ninline int qpower(int x,int k){\n\tint ans=1;\n\tfor(;k;k>>=1,x=1ll*x*x%mod)if(k&1)ans=1ll*ans*x%mod;\n\treturn ans;\n}\nint n,m,cnt,a[maxn][maxn],b[maxn][maxn];\nint main(){\n\tmemset(b,0,sizeof(b));\n\tn=getint(),m=getint();\n\tfor(int i=1;i<=n;++i)\n\tfor(int j=1;j<=m;++j)\n\ta[i][j]=getint();\n\tcnt=0;\n\tfor(int i=1;i<=n;++i)\n\tfor(int j=1;j<=m;++j)\n\tif(a[i][j]){\n\t\tif(!b[j][j]){\n\t\t\t++cnt;\n\t\t\tfor(int k=j;k<=m;++k)b[j][k]=a[i][k];\n\t\t\tbreak;\n\t\t}\n\t\telse for(int k=j;k<=m;++k)a[i][k]^=b[j][k];\n\t}\n\tint ans=qpower(2,n)-qpower(2,n-cnt);\n\tif(ans<0)ans+=mod;\n\tans=1ll*ans*qpower(2,m-1)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <complex>\n#include <cassert>\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define case(i) cout<<\"Case #\"<<i<<\": \"\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, ll> pr;\ntypedef complex<double> com;\nconst int mod = 1e9 + 7;\nconst int MOD = 998244353;\nconst ll INF = 1e18;\n\nll rank1(vector< vector<ll> >& mat) {\n\tll h = mat.size();\n\tll w = mat[0].size();\n\tll now = 0;\n\tfor (ll i = 0; i < w; i++) {\n\t\tll pivot = -1;\n\t\tfor (ll j = now; j < h; j++) {\n\t\t\tif (mat[j][i] != 0) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pivot != now) {\n\t\t\tswap(mat[now], mat[pivot]);\n\t\t}\n\t\t// for (ll j = i + 1; j < w; j++) {\n\t\t//     mat[now][j] /= mat[now][i];\n\t\t// }\n\t\tfor (ll j = now + 1; j < h; j++) {\n\t\t\tif (mat[j][i]) {\n\t\t\t\tfor (ll k = i + 1; k < w; k++) {\n\t\t\t\t\tmat[j][k] ^= mat[now][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnow++;\n\t\tif (now == h) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn now;\n}\n\nll mpow(int n, int k, int p) {\n\tif (k == 0)return 1;\n\tif (k % 2)return 1LL * n * mpow(n, k - 1, p) % p;\n\telse {\n\t\tll sub = mpow(n, k / 2, p);\n\t\treturn 1LL * sub * sub% p;\n\t}\n}\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<vector<ll>> a(n);\n\trep(i, 0, n) {\n\t\ta[i].resize(m);\n\t\trep(j, 0, m) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tint r = rank1(a);\n\n\tll ans = (mpow(2, n + m - 1, MOD) - mpow(2, n + m - r - 1, MOD) + MOD) % MOD;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<cctype>\n#include<set>\n#include<queue>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n\tint x=0,f=1;char ch=getchar();for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';return x*f;\n}\n\nconst int N = 305, mod = 998244353;\nint a[N][N], b[N][N];\n\nint ksm(int a,int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n//\tfreopen(\"a.in\", \"r\", stdin);\n\tint n = read(), m = read(), cnt = 0;\n\tfor (int i = 1; i <= n; ++i) \n\t\tfor (int j = 1; j <= m; ++j) a[i][j] = read();\n\tfor (int i = 1; i <= n; ++i) \n\t\tfor (int j = 1; j <= m; ++j) \n\t\t\tif (a[i][j]) {\n\t\t\t\tif (!b[j][j]) {\n\t\t\t\t\tfor (int k = j; k <= m; ++k) b[j][k] = a[i][k];\n\t\t\t\t\tcnt ++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = j; k <= m; ++k) a[i][k] ^= b[j][k];\n\t\t\t\t}\n\t\t\t}\n\tcout << 1ll * (ksm(2, n) - ksm(2, n - cnt) + mod) % mod * ksm(2, m - 1) % mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 998244353\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nclass MTwo{\npublic:\n    using t = bool;\n    static t id() {\n        return false;\n    }\n\tstatic t e() {\n        return true;\n    }\n\t// * \n    static t op1(const t& l, const t& r){\n        return l && r;\n    }\n\t// + \n\tstatic t op2(const t& l, const t& r){\n        return l ^ r;\n    }\n\t// - \n\tstatic t op3(const t& x){\n        return x;\n    }\n\t// /\n\tstatic t op4(const t& x) {\n        return x;\n    }\n};\ntemplate< typename M >\nstruct Matrix{\n\tusing T = typename M::t;\n\tint H;\n\tint W;\n\tvector<T> data;\n    Matrix(int n_)\n        : H(n_), W(n_), data(n_ * n_, M::id()) {}\n    Matrix(int h_, int w_)\n        : H(h_), W(w_), data(h_ * w_, M::id()) {}\n\tMatrix(int n_,vector<T> d_)\n        : H(n_), W(n_) {data = d_;}\n    Matrix(int h_, int w_, vector<T> d_)\n        : H(h_), W(w_) {data = d_;}\n  \tvoid Update(int h,int w,T x){\n    \tdata[h*W+w] = x;\n  \t}\n  \tconst T Get(int h,int w){\n    \treturn data[h*W+w];\n  \t}\n\tint Rank(){\n\t\tint ans = 0;\n\t\tvector<T> A(H*W);\n\t\tfor(int i=0;i<H*W;i++){\n\t\t\tA[i] = data[i];\n\t\t}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tint nonzero = -1;\n\t\t\tfor(int j=i;j<W;j++){\n\t\t\t\tif(A[i*W+j] != M::id()){\n\t\t\t\t\tnonzero = j;\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nonzero != -1){\n\t\t\t\tfor(int j=i;j<W;j++){\n\t\t\t\t\tT temp = A[nonzero*W+j];\n\t\t\t\t\tA[nonzero*W+j] = A[i*W+j];\n\t\t\t\t\tA[i*W+j] = temp;\n\t\t\t\t}\n\t\t\t\tfor(int j=i+1;j<H;j++){\n\t\t\t\t\tT d = M::op3(M::op1(M::op4(A[i*W+i]),A[j*W+i])); \n\t\t\t\t\tfor(int k=i;k<W;k++){\n\t\t\t\t\t\tA[j*W+k] = M::op2(A[j*W+k],M::op1(A[i*W+k],d));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn ans;\n\t}\n\tstatic Matrix I(int N){\n\t\tMatrix ans(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans.Update(i,i,M::e());\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Plus(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op2(A.Get(i,j),B.Get(i,j)));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Minus(Matrix& A){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op3(A.Get(i,j)));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Minus(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op2(A.Get(i,j),M::op3(B.Get(i,j))));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Prod(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = B.W;\n\t\tint K = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tT c = M::id();\n\t\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\t\tc = M::op2(c,M::op1(A.Get(i,k),B.Get(k,j)));\n\t\t\t\t}\n\t\t\t\tans.Update(i,j,c);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Pow(Matrix A,long r){\n\t\tint n = A.H;\n\t\tMatrix ans = I(n);\n\t\twhile(r){\n\t\t\tif(r % 2 == 1){\n\t\t\t\tans = Prod(ans,A);\n\t\t\t}\n\t\t\tA = Prod(A,A);\n\t\t\tr /= 2;\n\t\t}\n\t\treturn ans;\n\t}\n};\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tvector<bool> A(N*M);\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\tint x = rei();\n\t\t\tA[i*M+j] = x % 2 == 1;\n\t\t}\n\t}\n\tMatrix<MTwo> mat(N,M,A);\n\tint r = mat.Rank();\n\tlong ans1 = 1;\n\tlong ans2 = 1;\n\tfor(int i=0;i<N+M-1;i++){\n\t\tans1 *= 2;\n\t\tans1 %= mod;\n\t}\n\tfor(int i=0;i<N+M-r-1;i++){\n\t\tans2 *= 2;\n\t\tans2 %= mod;\n\t}\n\tcout << (ans1 - ans2 + mod) % mod << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n \n\nconst double __gauss_template_EPS = 1e-8;\n\nint Gauss(vector<vector<int>> &mat) {\n    // return rank\n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = rank; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[rank]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n        rank++;\n\n        int fs = mat[rank][i];\n\n        for(int j = rank+1; j < n; j++) {\n            int r = mat[j][i] / fs;\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[rank][k] * r;\n            }\n        }\n    }\n\n    return rank;\n}\n\n \nconst long long __exp_template_MOD = MOD;\nconst long long mod = MOD;\nint qpow(int x, int n){ int y = 1; while(n){ if(n & 1) y = (ll) y * x % mod; x = (ll) x * x % mod; n >>= 1; } return y; }\n \nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n \nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n \n    printf(\"%lld\\n\", ((qpow(2, n+m-1) - qpow(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n \nvoid init() {\n    \n \n \n}\n \nint main () {\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 333;\nconst int MOD = 998244353;\ntypedef bitset<N> row;\n\nint n,m,pot[N+N];\nrow a[N];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    pot[0] = 1; forsn(n,1,2*N) pot[n] = (pot[n-1]+pot[n-1])%MOD;\n\n    cin >> n >> m;\n    forn(i,n) forn(j,m) {\n        int x; cin >> x;\n        if (x&1) a[i].set(j);\n    }\n\n    int rank = 0;\n    forn(j,m) {\n        forsn(i,j,n) if (a[i][j]) {\n            swap(a[i], a[j]);\n            break;\n        }\n        if (a[j][j]) {\n            rank++;\n            forsn(i,j+1,n) if (a[i][j]) \n                a[i] ^= a[j];\n        }\n    }\n    auto ans = ll(pot[n] + MOD - pot[n-rank])*(pot[m-1])%MOD;\n    while (ans < 0) ans += MOD;\n    while (ans >= MOD) ans -= MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nint gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n\n#define ll long long\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=310;\nconst ll mod=998244353;\n\nbitset<maxn> bi[maxn];\nll tav[maxn];\n\nbitset<maxn> f[maxn];\nll cnt=1;\nll koj[maxn];\n\nbool add(bitset<maxn> bi,ll m){\n\tfor(ll i=m-1;i>=0;i--){\n\t\tif(bi[i]){\n\t\t\tif(koj[i]==-1){\n\t\t\t\tf[cnt]=bi;\n\t\t\t\tkoj[i]=cnt;\n\t\t\t\tcnt++;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tbi^=f[koj[i]];\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\t\n\ttav[0]=1;\n\tfor(ll i=1;i<maxn;i++){\n\t\ttav[i]=(tav[i-1]*2)%mod;\n\t}\n\tfill(koj,koj+maxn,-1);\n\n\tll n,m;\n\tcin>>n>>m;\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<m;j++){\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\tbi[i][j]=a;\n\t\t}\t\t\n\t}\n\tll sefr=0;\n\tfor(ll i=0;i<n;i++){\n\t\tsefr+=add(bi[i],m);\n\t}\n\tcout<<((tav[m-1]*(tav[n]-tav[sefr]))%mod+mod)%mod;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define mod(x) ((x % MOD) + MOD) % MOD\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define LB(c,x) (int)(lower_bound(ALL(c),x)-(c).begin())\n#define UB(c,x) (int)(upper_bound(ALL(c),x)-(c).begin())\n#define COUNT(c,x) (UB(c,x)-LB(c,x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DEL(v) decltype(v)().swap(v)\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\ntemplate<typename T1, typename T2> using P = pair<T1,T2>;\ntemplate<typename T> using V = vector<T>;\nstruct edge { int from, to; int cost; };\nbool operator< (const edge &edge1, const edge &edge2) { return edge1.cost < edge2.cost; };\nconst int INF = 1e18;\nconst int MOD = 998244353;\n\ntemplate<typename T> ostream& operator << (ostream& s, const V<T>& v) {\n   s << \"[\";\n   for (int i = 0; i < v.size(); i++) { s << v[i]; if (i < v.size() - 1) s << \" \"; }\n   s << \"]\";\n   return s;\n}\ntemplate<typename T1, typename T2> ostream& operator << (ostream& s, const P<T1,T2>& p) {\n   s << \"(\" << p.first << \",\" << p.second << \")\";\n   return s;\n}\n\nstruct GF2 {\n   int n;\n   GF2(int m=0) { n = m; }\n   const bool operator==(int m) const { return n == (m%2); }\n   const bool operator!=(int m) const { return n != (m%2); }\n   const bool operator>(const GF2 a) const { return n > a.n; }\n   const GF2 operator+(const GF2& a) const { return GF2{n ^ a.n}; }\n   const GF2 operator-(const GF2& a) const { return GF2{n ^ a.n}; }\n   const GF2 operator*(const GF2& a) const { return GF2{n * a.n}; }\n   const GF2 operator/(const GF2& a) const { if (a.n == 0) throw \"Can't devide by 0\"; return GF2{n / a.n}; }\n   GF2& operator+=(const GF2& a) { n ^= a.n; return *this; }\n   GF2& operator-=(const GF2& a) { n ^= a.n; return *this; }\n   GF2& operator*=(const GF2& a) { n *= a.n; return *this; }\n   GF2& operator/=(const GF2& a) { if (a.n == 0) throw \"Can't devide by 0\"; n /= a.n; return *this; }\n   GF2& operator=(int m) { n = m; return *this; }\n};\nconst GF2 abs(GF2 x) { return x; }\nostream& operator << (ostream& s, const GF2& a) { s << a.n; return s; }\n\ntemplate<typename T> class Matrix\n{\n   private:\n      vector<vector<T>> val;\n      int m, n;\n   public:\n      Matrix(int a=0, int b=0) : m(a), n(b) {\n         val.resize(m, vector<T>(n));\n      }\n      Matrix(const vector<vector<T>>& vec) : m(vec.size()), n(vec[0].size()) {\n         val.resize(m, vector<T>(n));\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] = vec[i][j];\n      }\n      ~Matrix() {\n         vector<vector<T>>().swap(val);\n      }\n      Matrix& operator=(const Matrix& mat) {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be substituted\"; }\n         catch (const char* e) { cerr << e << endl; }\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] = mat.val[i][j];\n         return *this;\n      }\n      T operator()(int i, int j) {\n         try { if (i < 0 || m <= i || j < 0 || n <= j) throw \"Bad access\"; }\n         catch (const char* e) { cerr << e << endl; }\n         return val[i][j];\n      }\n      const Matrix operator+(const Matrix& mat) const {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[i][j] = val[i][j] + mat.val[i][j];\n         return tmp;\n      }\n      const Matrix operator-(const Matrix& mat) const {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[i][j] = val[i][j] - mat.val[i][j];\n         return tmp;\n      }\n      const Matrix operator*(const Matrix& mat) const {\n         try { if (n != mat.m) throw \"Matrix can't be producted\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, mat.n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < mat.n; j++) for (int k = 0; k < n; k++) tmp.val[i][j] += val[i][k]*mat.val[k][j];\n         return tmp;\n      }\n      Matrix& operator+=(const Matrix& mat) {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] += mat.val[i][j];\n         return *this;\n      }\n      Matrix& operator-=(const Matrix& mat) {\n         try { if (m != mat.m || n != mat.n) throw \"Matrix can't be added\"; }\n         catch (const char* e) { cerr << e << endl; }\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] -= mat.val[i][j];\n         return *this;\n      }\n      Matrix operator*=(const Matrix& mat) {\n         try { if (n != mat.m) throw \"Matrix can't be producted\"; }\n         catch (const char* e) { cerr << e << endl; }\n         Matrix tmp(m, mat.n);\n         for (int i = 0; i < m; i++) for (int j = 0; j < mat.n; j++) for (int k = 0; k < n; k++) tmp.val[i][j] += val[i][k]*mat.val[k][j];\n         n = mat.n;\n         val.resize(m, vector<T>(n));\n         *this = tmp;\n         return *this;\n      }\n      Matrix transpose() const {\n         Matrix tmp(n, m);\n         for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[j][i] = val[i][j];\n         return tmp;\n      }\n      Matrix gaussElimination() const {\n         Matrix<T> A(val);\n         int col = 0;\n         for (int i = 0; i < m; i++) {\n            int pivot = i;\n            while (true) {\n               for (int j = i+1; j < m; j++) if (abs(A.val[j][col]) > abs(A.val[pivot][col])) pivot = j;\n               if (A.val[pivot][col] == 0) {\n                  col++;\n                  if (col == n) return A;\n               } else break;\n            }\n            swap(A.val[i], A.val[pivot]);\n            for (int j = i+1; j < m; j++) {\n               T ratio = A.val[j][col] / A.val[i][col];\n               for (int k = col; k < n; k++) A.val[j][k] -= A.val[i][k] * ratio;\n            }\n            col++;\n         }\n         return A;\n      }\n      int rank() const {\n         Matrix A = gaussElimination();\n         int j = 0;\n         for (int i = 0; i < m; i++) {\n            while (A.val[i][j] == 0) {\n               j++; if (j == n) return i;\n            }\n         }\n         return m;\n      }\n      ostream& info(ostream& s) const {\n         s << endl << \"[\";\n         for (int i = 0; i < m; i++) {\n            s << \"[\";\n            for (int j = 0; j < n; j++) {\n               s << val[i][j];\n               if (j < n-1) s << \" \";\n            }\n            s << \"]\"; if (i < m-1) s << endl;\n         }\n         s << \"]\";\n         return s;\n      }\n};\ntemplate<typename T> ostream& operator<<(ostream& s, const Matrix<T>& mat) {\n   mat.info(s);\n   return s;\n}\n\ntemplate<typename T> class SquareMatrix : public Matrix<T>\n{\n   private:\n      int num;\n   public:\n      SquareMatrix(int a=0) : Matrix<T>(a, a) { num = a; }\n      SquareMatrix(const vector<vector<T>>& vec) : num(vec.size()), Matrix<T>(vec) { \n         try { if (vec.size() != vec[0].size()) throw \"Matrix isn't square matrix\"; }\n         catch (const char* e) { cerr << e << endl; }\n      }\n      T determinant() {\n         Matrix<T> A = this->gaussElimination();\n         T det = 1;\n         for (int i = 0; i < num; i++) det *= A(i,i);\n         return det;\n      }\n};\n\n\nint powM(int x, int n) {\n   int res = 1;\n   while (n > 0) {\n      if ((n & 1) == 1) {\n         res = mod(res * x);\n      }\n      x = mod(x * x);\n      n >>= 1;\n   }\n   return res;\n}\n\nsigned main()\n{\n   int n, m; cin >> n >> m;\n   V<V<GF2>> a(n, V<GF2>(m));\n   REP(i, n) {\n      REP(j, m) {\n         int b; cin >> b;\n         a[i][j] = b;\n      }\n   }\n\n   Matrix<GF2> A(a);\n\n   int rank = A.rank();\n\n   int ans = mod(powM(2,n+m-1) - powM(2,n+m-rank-1));\n   DUMP(ans)\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#define inf 20021225\n#define ll long long\n#define mdn 998244353\nusing namespace std;\n\nbitset<310> r[310]; int n,m;\nint gauss()\n{\n\tint w = 0;\n\tfor(int i=1,j;i<=min(n,m);i++)\n\t{\n\t\tif(!r[i][i])\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t\tif(r[j][i])\tbreak;\n\t\t\tif(j>n)\tcontinue;\n\t\t\tswap(r[i],r[j]);\n\t\t}\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tif(r[j][i])\tr[j]^=r[i];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(r[i].count())\tw++;\n\treturn w;\n}\nint ksm(int bs,int mi)\n{\n\tint ans = 1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=(ll)ans*bs%mdn;\n\t\tbs=(ll)bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tr[i][j] = x;\n\t\t}\n\tint ans = ksm(2,n+m-1)-ksm(2,n+m-1-gauss());\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;++i)\n#define repd(i,a,b) for(int i=a;i>=b;--i)\n#define rvc(i,S) for(int i=0;i<(int)S.size();++i)\n#define fore(i,x) for(int i = head[x] ; i ; i = e[i].next)\n#define mp make_pair\n#define pb push_back\n#define int long long\n#define PII pair<int,int>\n#define maxn 1000005\n#define ll long long \n#define fi first\n#define int ll\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std; \nint n,m;\nconst int mo=998244353;\nint a[305][305];\nvoid SWAP(int x,int y)\n{ rep(i,1,m) swap(a[x][i],a[y][i]);}\nvoid solve(int x,int y)\n{rep(i,1,m) a[x][i]^=a[y][i];\n}\nsigned main()\n{ cin>>n>>m;\n  rep(i,1,n)rep(j,1,m) cin>>a[i][j];\n  int r=0;\n  rep(i,1,m)\n  {int k=0; \n   rep(j,r+1,n) if(a[j][i]){k=j;break;}\n   if(k) {r++;}\n   else continue;\n   SWAP(r,k);\n   rep(p,1,n)\n   {if(p!=i)\n     solve(p,i);\n   }\n  }\n  int add=1;\n  rep(i,1,n+m-1) add=(add*2)%mo;\n  int del=1;\n  rep(i,1,n+m-r-1) del=(del*2)%mo;\n  cout<<(add-del+mo)%mo<<endl; \n\t\n\t\n\t\nreturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\nll nextLong() { ll x; scanf(\"%lld\", &x); return x;}\n\nconst ll MOD = 998244353;\n\n\n// 01ベクトルのランクを求める\nint binary_matrix_rank(vector<vector<int>> A) {\n  const int N = A.size();\n  const int M = A[0].size();\n\n  auto at = [](const vector<int> Ai, int j) -> int {\n    return Ai[j];\n  };\n\n  int s = 0;\n  REP(j, M) {\n    int p = -1;\n    for (int i = s; i < N; i++) if (at(A[i], j)) { p = i; break; }\n    if (p >= 0) {\n      swap(A[s], A[p]);\n      for (int i = s+1; i < N; i++) if (at(A[i], j)) {\n        REP(k, M)\n        A[i][k] ^= A[s][k];\n      }\n      s++;\n    }\n  }\n  return s;\n}\n\n\nint main2() {\n  int N = nextLong();\n  int M = nextLong();\n\n  vector< vector<int> > A(N, vector<int>(M, 0));\n  REP(i, N) REP(j, M) A[i][j] = nextLong();\n\n  int R = binary_matrix_rank(A);\n\n  ll ans = 1;\n  REP(i, R) ans = (ans * 2) % MOD;\n  ans = (ans - 1 + MOD) % MOD;\n\n  REP(i, N-R) ans = (ans * 2) % MOD;\n  REP(i, M-1) ans = (ans * 2) % MOD;\n\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst long long maxn = 310;\nconst long long mod = 998244353;\nlong long n , m;\nlong long a[maxn][maxn];\nlong long s[maxn][maxn];\nlong long r;\nlong long pow ( long long x ) {\n\tlong long s = 1 , f = 2;\n\twhile ( x ) {\n\t\tif ( x % 2 ) s = ( s * f ) % mod;\n\t\tf = ( f * f ) % mod; x = x / 2;\n\t}\n\treturn s;\n}\nvoid work () {\n\tlong long i , j , k;\n\tscanf ( \"%lld%lld\" , &n , &m );\n\tfor ( i = 1 ; i <= n ; i++ )\n\t\tfor ( j = 1 ; j <= m ; j++ )\n\t\t\tscanf ( \"%lld\" , &a[i][j] );\n\tfor ( i = 1 ; i <= n ; i++ ) {\n\t\tfor ( j = 1 ; j <= m ; j++ ) {\n\t\t\tif ( s[j][j] == 0 && a[i][j] == 1 ) {\n\t\t\t\tfor ( k = 1 ; k <= m ; k++ ) {\n\t\t\t\t\ts[j][k] = a[i][k];\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( a[i][j] == 1 )\n\t\t\t\tfor ( k = 1 ; k <= m ; k++ ) {\n\t\t\t\t\ta[i][k] ^= s[j][k];\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf ( \"%lld\\n\" , ( pow ( n + m - 1 ) - pow ( n + m - r - 1 ) + mod ) % mod );\n}\nint main () {\n\twork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(0);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)if(a[j][now])for(int k = 0; k < m; ++k)a[j][k] ^= a[i][k];\n        ++ret;\n        ++now;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// binary 行列 (行列累乗と、掃き出し法)\n//\n// verified:\n//   みんなのプロコン 2019 E - Odd Subrectangles\n//     https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n// \n\n\n#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n\nconst int MAX_ROW = 510; // to be set\nconst int MAX_COL = 510; // to be set\nstruct BitMatrix {\n    int n, m;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int n_ = 1, int m_ = 1) {n = n_; m = m_;}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n    inline friend ostream& operator << (ostream& s, BitMatrix M) {\n        s << endl; \n        for (int i = 0; i < M.n; ++i) {\n            for (int j = 0; j < M.m; ++j) s << M.val[i][j];\n            s << endl;\n        }\n        return s;\n    }\n};\n\ninline BitMatrix operator * (BitMatrix A, BitMatrix B) {\n    BitMatrix R(A.n, B.m);\n    BitMatrix tB(B.m, B.n);\n    for (int i = 0; i < tB.n; ++i) for (int j = 0; j < tB.m; ++j) tB[i][j] = B[j][i];\n    for (int i = 0; i < R.n; ++i) for (int j = 0; j < R.m; ++j) R[i][j] = (A[i] & tB[j]).any();\n    return R;\n}\n\ninline BitMatrix pow(BitMatrix A, long long n) {\n    BitMatrix R(A.n, A.n);\n    for (int i = 0; i < A.n; ++i) R[i][i] = 1;\n    while (n > 0) {\n        if (n & 1) R = R * A;\n        A = A * A;\n        n >>= 1;\n    }\n    return R;\n}\n\nint calc_rank(BitMatrix &A) {\n    int r = 0;\n\tfor (int i = 0; i < A.m; ++i) {\n\t\tint pivot = -1;\n\t\tfor (int j = r; j < A.n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot != -1) {\n\t\t\tswap(A[pivot], A[r]);\n\t\t\tfor (int j = 0; j < A.n; ++j) if (j != r && A[j][i]) A[j] ^= A[r];\n\t\t\t++r;\n\t\t}\n\t}\n    return r;\n}\n\nvector<vector<int> > linear_equation(BitMatrix A, vector<int> b) {\n\tint rank = 0;\n    for (int i = 0; i < A.n; ++i) { A[i][A.m] = b[i]; }\n    \n    vector<int> core, rem;\n\tfor (int i = 0; i < A.m; ++i) {\n\t\tint pivot = -1;\n\t\tfor (int j = rank; j < A.n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot != -1) {\n            core.push_back(i);\n\t\t\tswap(A[pivot], A[rank]);\n\t\t\tfor (int j = 0; j < A.n; ++j) if (j != rank && A[j][i]) A[j] ^= A[rank];\n\t\t\t++rank;\n\t\t}\n        else rem.push_back(i);\n\t}\n    \n    vector<vector<int> > res;\n    for (int i = rank; i < A.n; ++i) \n        if (A[i][A.m]) return res;     // return -1;\n    \n    vector<int> sol(A.m, 0);\n    for (int i = 0; i < core.size(); ++i) sol[core[i]] = A[i][A.m];\n    res.push_back(sol);\n    \n    for (int i = 0; i < rem.size(); ++i) {\n        vector<int> temp(A.m, 0);\n        temp[rem[i]] = 1;\n        for (int j = 0; j < core.size(); ++j) temp[core[j]] = A[j][rem[i]];\n        res.push_back(temp);\n    }\n    \n    return res;     // return A[0].size()-rank;\n};\n\n\nconst int MOD = 998244353;\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() { \n    int N, M; cin >> N >> M;\n    BitMatrix A(N, M);\n    for (int i = 0; i < N; ++i) for (int j = 0; j < M; ++j) {\n            int a; cin >> a;\n            if (a) A[i][j] = 1;\n        }\n    int r = calc_rank(A);  \n    cout << (modpow(2LL, N+M-1, MOD) - modpow(2LL, N+M-r-1, MOD) + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate<Int MOD>\nstruct ModInt {\n    constexpr static Int mod = MOD;\n    Int v;\n\n    ModInt(long long _v = 0) : v(set(_v)) {}\n    ModInt(const ModInt &r) : v(set(r.v)) {}\n\n    inline static Int set(const Int x) { return x < 0 ? (x % mod) + mod : x % mod; }\n    inline void set() { v = set(v); }\n\n    bool operator<(ModInt r) const { return v < r.v; }\n    bool operator>(ModInt r) const { return r.v < v; }\n    bool operator==(ModInt r) const { return v == r.v; }\n    bool operator!= (ModInt r) const { return v != r.v; }\n\n    ModInt operator-() const { return ModInt(v ? mod - v : v); }\n    ModInt &operator=(const ModInt &r) { if (this != &r) v = set(r.v); return *this; }\n    ModInt &operator+=(ModInt r) { (v += r.v) %= mod; return *this; }\n    ModInt &operator-=(ModInt r) { (v -= r.v - mod) %= mod; return *this; }\n    // ModInt &operator*=(ModInt r) { v = (__uint128_t(v) * r.v) % mod; return *this; }\n    ModInt &operator*=(ModInt r) { v = 1ULL * v * r.v % mod; return *this; }\n    ModInt &operator/=(ModInt r) { *this *= r.inv(); return *this; }\n    ModInt operator+(ModInt r) const { return ModInt(*this) += r; }\n    ModInt operator-(ModInt r) const { return ModInt(*this) -= r; }\n    ModInt operator*(ModInt r) const { return ModInt(*this) *= r; }\n    ModInt operator/(ModInt r) const { return ModInt(*this) /= r; }\n\n    ModInt inv() const {\n        long long a = v, b = mod, u = 1, w = 0;\n        while (b) {\n            long long t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * w, w);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(Int e) {\n        ModInt a = *this, x(1);\n        for ( ; 0 < e; e >>= 1) { if (e & 1) x *= a; a *= a; }\n        return x;\n    }\n    inline ModInt pow(ModInt &e) { return pow(e.v); }\n};\n\nstd::ostream &operator<<(std::ostream &os, const auto &r) { return os << r.v; }\nstd::istream &operator>>(std::istream &is, auto &r) { is >> r.v; r.set();return is; }\n\nusing Mod2 = ModInt<2>;\nusing Type = ModInt<998244353>;\nusing Vector = vector<Mod2>;\nusing Matrix = vector<Vector>;\n\nint Rank(Matrix &A) {\n    const int N = A.size(), M = A[0].size();\n    int rank = 0;\n    vector<bool> used(N, false);\n\n    for (int c = 0; c < M; ++c) {\n        int pivot = 0;\n        while (pivot < N && (used[pivot] || A[pivot][c] == 0)) ++pivot;\n        if (pivot == N) continue;\n\n        ++rank;\n        used[pivot] = true;\n        Mod2 v = A[pivot][c];\n        for (int j = 0; j < M; ++j) A[pivot][j] /= v;\n        for (int r = 0; r < N; ++r) {\n            if (r == pivot) continue;\n            for (int j = c + 1; j < M; ++j)\n                A[r][j] -= A[r][c] * A[pivot][j];\n        }\n    }\n\n    return rank;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    Matrix A(n, Vector(m));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            cin >> A[i][j];\n\n    int rank = Rank(A);\n    Type res = Type(2).pow(m + n - 1) - Type(2).pow(m + n - rank - 1);\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = rank; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        rank++;\n\n        for(int j = rank; j < n; j++) if(mat[j][i]) {\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k];\n            }\n        }\n    }\n\n    return rank;\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds;   \n#define ordered_set tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update> \n#define ld long double\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n#define sz(a) (ll)(a.size())\nconst int M = 302;\nconst ll mod = 998244353;\nint a[M][M];\nll power(ll a,ll b)\n{\n\tll val=1;\n\twhile(b)\n\t{\n\t\tif(b%2)\n\t\t\tval=(val*a)%mod;\n\t\tb/=2;\n\t\ta=(a*a)%mod;\n\t}\n\treturn val;\n}\nint findRank(int n,int m)\n{\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint id = i;\n\t\tfor(int j=i;j<n;j++)\n\t\t\tif(a[j][i] == 1)\n\t\t\t\tid = j;\n\t\tfor(int j=0;j<m;j++)\n\t\t\tswap(a[i][j], a[id][j]);\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<m;k++)\n\t\t\t\ta[j][k] ^= a[i][k];\n\t\t}\n\t}\n\tint rank = 0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbool flag = 0;\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(a[i][j])\n\t\t\t\tflag = 1;\n\t\tif(flag)\n\t\t\trank++;\n\t}\n\treturn rank;\n}\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\tcin>>a[i][j];\n\tint r = findRank(n,m);\n\tll v = power(2,m-1);\n\tll x = (power(2,n) - power(2,n-r)+mod)%mod;\n\tll ans = (v*x)%mod;\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nll mo=998244353;\n\nconst int MAT=402;\nint A[402][402];\n\nint gf2_rank(int A[MAT][MAT]) { /* input */\n\tint i,j,k;\n\tFOR(i,H) {\n\t\tint be=i,mi=H+1;\n\t\tfor(j=i;j<H;j++) {\n\t\t\tFOR(k,W) if(A[j][k]) break;\n\t\t\tif(k<mi) be=j,mi=k;\n\t\t}\n\t\tif(mi>=H) break;\n\t\tFOR(j,W) swap(A[i][j],A[be][j]);\n\t\t\n\t\tFOR(j,H) if(i!=j&&A[j][mi]) {\n\t\t\tFOR(k,W) A[j][k] ^= A[i][k];\n\t\t}\n\t}\n\treturn i;\n}\n\nll dp[303][303];\nll p2[3030];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) FOR(x,W) cin>>A[y][x];\n\tif(H<W) {\n\t\tFOR(y,400) FOR(x,400) if(y<x) swap(A[y][x],A[x][y]);\n\t\tswap(H,W);\n\t}\n\tgf2_rank(A);\n\t\n\tp2[0]=1;\n\tFOR(i,305) p2[i+1]=p2[i]*2%mo;\n\t\n\tdp[0][0]=1;\n\t\n\tFOR(y,H) {\n\t\tint num=0;\n\t\tFOR(x,W) num+=A[y][x];\n\t\t\n\t\tFOR(x,W+1) if(dp[y][x]) {\n\t\t\t(dp[y+1][x]+=dp[y][x])%=mo;\n\t\t\t(dp[y+1][x+num]+=dp[y][x])%=mo;\n\t\t}\n\t}\n\t\n\t\n\tll ret=0;\n\tfor(i=1;i<=W;i++) {\n\t\tret+=dp[H][i]*p2[W-1]%mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint N, M;\nint mod = 998244353;\n\nint power(int a, int n){\n    if (n == 0) {\n        return 1;\n    } else if (n % 2 == 0) {\n        int b = power(a, n / 2);\n        return 1ll * b * b % mod;\n    } else {\n        return 1ll * a * power(a, n - 1) % mod;\n    }\n}\n\nint main() {\n    cin >> N >> M;\n    vector<vector<int>> A(N, vector<int>(M));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> A[i][j];\n        }\n    }\n    \n//    rank計算\n    int rank = 0;\n    for (int j = 0; j < M; j++) {\n        int pivot = -1;\n        for (int i = rank; i < N; i++) {\n            if (A[i][j]) {\n                pivot = i;\n                break;\n            }\n        }\n        if (pivot != -1) {\n            swap(A[rank], A[pivot]);\n            for (int i = rank + 1; i < N; i++) {\n                if (A[i][j]) {\n                    for (int k = j; k < M; k++) {\n                        A[i][k] ^= A[rank][k];\n                    }\n                }\n            }\n            rank++;\n        }\n    }\n    int a = power(2, N + M - 1), b = power(2, N + M - rank - 1);\n    cout << (a - b + mod) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\n#define LL long long\n\n#define MOD 998244353\n#define FACT_MAX 1000000\n\nLL fact[FACT_MAX];\n\nclass Combinatrics{\nprivate:\n  long long mod = MOD;\n  int fact_max = FACT_MAX;\npublic:\n  Combinatrics(){\n    fact[0]=1;\n    for(int i=1;i<fact_max;i++)\n      fact[i] = (fact[i-1]*i)%mod;\n  }\n  \n  long long power(long long n, long long e){\n    long long ret = 1;\n    long long b = n;\n    while(e){\n      if(e%2!=0)\n\tret*=b;\n      ret%=mod;\n      b*=b;\n      b%=mod;\n      e/=2;\n    }\n    return ret;\n  }\n\n  long long inv(long long n){\n    return power(n,mod-2);\n  }\n\n  long long div(long long n1,long long n2){\n    return n1*power(n2,mod-2)%mod;\n  }\n  \n  long long nck(int n,int k){\n    if(k>n || k<0) return 0;\n    if(k==n || k==0) return 1;\n    return (fact[n]*inv(fact[n-k])%mod)*inv(fact[k])%mod;\n  }\n};\n\n#define BITN 300\nint Rank(std::vector<std::bitset<BITN>> &a){\n  int rnk=0;\n  int n=a.size();\n  int m=BITN;\n  vector<int> where (m, -1);\n  for (int col=0, row=0; col<m && row<n; ++col) {\n    for (int i=row; i<n; ++i)\n      if (a[i][col]) {\n\tswap (a[i], a[row]);\n\tbreak;\n      }\n    if (! a[row][col])\n      continue;\n    where[col] = row;\n\n    for (int i=0; i<n; ++i)\n      if (i != row && a[i][col])\n\ta[i] ^= a[row];\n    ++row;\n    rnk=row;\n  }\n  return rnk;\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  vector<bitset<300>> a(n);\n  int tmp;\n  REP(i,n){\n    REP(j,m){\n      cin>>tmp;\n      a[i][j]=(tmp==1);\n    }\n  }\n  int rnk = Rank(a);\n  Combinatrics c;\n  cout<<(MOD+c.power(2LL,(LL)(n+m-1))-c.power(2LL,(LL)(n+m-rnk-1)))%MOD<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll const mod = 998244353;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    int a[n][m];\n    int r = 0;\n    for (int i = 0;i < n;++i) for (int j = 0;j < m;++j) cin >> a[i][j];\n    for (int i = 0;i < n;++i) {\n        int p = i,q = i;\n        for (int j = i;j < n;++j) {\n            if (a[p][q]) break;\n            for (int k = i;k < m;++k) if (a[j][k] == 1) {\n                p = j;q = k;\n                break;\n            }\n        }\n        if (a[p][q] == 0) break;\n        r = i+1;\n        if (q != i) for (int j = i;j < n;++j) a[j][i] ^= a[j][q];\n        if (p != i) for (int j = i;j < m;++j) a[i][j] ^= a[p][j];\n        for (int j = i+1;j < n;++j) if (a[j][i] == 1) for (int k = i;k < m;++k) a[j][k] ^= a[i][k];\n        for (int j = i+1;j < m;++j) if (a[i][j] == 1) for (int k = i;k < n;++k) a[k][j] ^= a[k][i];\n    }\n    int x = 1,y = 1;\n    for (int i = 0;i < n+m-1;++i) {\n        x <<= 1;\n        x %= mod;\n    }\n    for (int i = 0;i < n+m-r-1;++i) {\n        y <<= 1;\n        y %= mod;\n    }\n    cout << (x-y+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 998244353;\n\ntemplate <int mod>\nstruct modint {\n    lint v;\n    modint() : v(0) {}\n    modint(signed v) : v(v) {}\n    modint(lint t) {\n        v = t % mod;\n        if (v < 0)\n            v += mod;\n    }\n\n    modint pow(lint k) {\n        modint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n    static modint add_identity() { return modint(0); }\n    static modint mul_identity() { return modint(1); }\n    modint inv() { return pow(mod - 2); }\n\n    modint &operator+=(modint a) {\n        v += a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator-=(modint a) {\n        v += mod - a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator*=(modint a) {\n        v = v * a.v % mod;\n        return *this;\n    }\n    modint &operator/=(modint a) { return (*this) *= a.inv(); }\n\n    modint operator+(modint a) const { return modint(v) += a; };\n    modint operator-(modint a) const { return modint(v) -= a; };\n    modint operator*(modint a) const { return modint(v) *= a; };\n    modint operator/(modint a) const { return modint(v) /= a; };\n\n    modint operator-() const { return v ? modint(mod - v) : modint(v); }\n\n    bool operator==(const modint a) const { return v == a.v; }\n    bool operator!=(const modint a) const { return v != a.v; }\n    bool operator<(const modint a) const { return v < a.v; }\n};\nusing mint = modint<mod>;\nostream &operator<<(ostream &os, mint m) { return os << m.v; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> a(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> a[i][j];\n        }\n    }\n    vector<bool> used(n, false);\n    int rank = 0;\n    for (int i = 0; i < m; ++i) {\n        int idx = -1;\n        for (int j = 0; j < n; ++j) {\n            if (!used[j] && a[j][i] == 1) {\n                idx     = j;\n                used[j] = true;\n                break;\n            }\n        }\n        if (idx == -1)\n            continue;\n        for (int j = 0; j < n; ++j) {\n            if (j != idx && a[i][j] == 1) {\n                for (int k = i; k < n; ++k) {\n                    a[j][k] ^= a[idx][k];\n                }\n            }\n        }\n        rank++;\n    }\n    mint ret = mint(2).pow(n + m - rank - 1) * (mint(2).pow(rank) - 1);\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 302;\nconst int MOD = 998244353;\n\nstruct equation {\n\n\tvector<int> coeff;\n\tint val;\n\n\tvoid init(int n) {\n\t\tcoeff.resize(n);\n\t\tval = 0;\n\t}\n\n};\n\nint n, m, a[MAX_N][MAX_N];\nequation e[MAX_N];\n\nvoid readInput() {\n\tcin >> n >> m;\n\n\tfor (int i=0; i<n; ++i) {\n\t\tfor (int j=0; j<m; ++j)\n\t\t\tcin >> a[i][j];\n\t}\n}\n\nvoid initEquationSystem() {\n\tfor (int i=0; i<n; ++i) {\n\t\te[i].init(m);\n\t\tfor (int j=0; j<m; ++j)\n\t\t\te[i].coeff[j] = a[i][j];\n\t\te[i].val = 0;\n\t}\n\t// PR0(e[1].coeff, m);\n}\n\nint64_t pw(int n, int k) {\n\tif (k==0)\n\t\treturn 1;\n\n\tint64_t tmp = pw(n, k/2);\n\n\tif (k%2)\n\t\treturn tmp * tmp % MOD * n % MOD;\n\treturn tmp * tmp % MOD;\n}\n\nvoid solve() {\n\tfor (int i=0; i<m; ++i) {\n\t\tfor (int j=i; j<n; ++j)\n\t\t\tif (e[j].coeff[i])\n\t\t\t\tswap(e[i], e[j]);\n\n\t\tfor (int j=i+1; j<n; ++j) {\n\t\t\tif (e[j].coeff[i]==0)\n\t\t\t\tcontinue;\n\t\t\tfor (int k=0; k<m; ++k)\n\t\t\t\te[i].coeff[k] ^= e[i].coeff[k];\n\t\t\te[j].val ^= e[i].val;\n\t\t}\n\t}\n\t// PR0(e[1].coeff, m);\n\n\tint64_t tmp = 1;\n\n\tfor (int i=0; i<m; ++i) {\n\t\tbool ok = true;\n\t\tfor (int j=0; j<n; ++j) {\n\t\t\tint tmp = accumulate(e[j].coeff.begin(), e[j].coeff.end(), 0);\n\t\t\tif (e[j].coeff[i] && tmp==1) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok)\n\t\t\ttmp = tmp * 2 % MOD;\n\t}\n\n\tcout << pw(2, n-1) * (pw(2, m) - tmp + MOD) % MOD;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\treadInput();\n\tinitEquationSystem();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n  Int_ inv(){\n    return Int_(mpow(x,mod-2));\n  }\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<998244353> Int;\n\nInt mpow(Int a,lint k){\n  Int res=1;\n  while(k){\n    if(k&1) res=res*a;\n    a=a*a;\n    k>>=1;\n  }\n  return res;\n}\nconst int INF=5e8;\nint h,w;\nint ar[305][305];\n\nint calc_rank(){\n  int res=0;\n  int row=0;\n  REP(i,w){\n    int idx=-1;\n    REPN(j,h,row) if(ar[j][i]){\n      idx=j;\n      break;\n    }\n    if(idx==-1){\n      continue;\n    }\n    if(idx!=row) REP(j,w) swap(ar[idx][j],ar[row][j]);\n    REPN(j,h,row+1) if(ar[j][i]){\n      REP(k,w) ar[j][k]^=ar[row][k];\n    }\n    ++res;\n    ++row;\n  }\n  return res;\n}\nint main(){\n  cin>>h>>w;\n  REP(i,h) REP(j,w) cin>>ar[i][j];\n  int R=calc_rank();\n\n  Int res=(mpow(2,h)-mpow(2,h-R))*mpow(2,w-1);\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef CLASS_MODINT\n#define CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::int64_t n_) : n((n_ >= 0 ? n_ : mod - (-n_) % mod) % mod) {};\n\tstatic constexpr std::uint32_t get_mod() { return mod; }\n\tstd::uint32_t get() const { return n; }\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint inv() const { return (*this).pow(mod - 2); }\n\tmodint pow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n#endif // CLASS_MODINT\n\n#include <vector>\n#include <iostream>\nusing namespace std;\nusing modulo = modint<998244353>;\nvector<modulo> recur(int pos, vector<int> sub, vector<vector<int> > &A) {\n\tif (sub.size() == 0) return { modulo(2).pow(pos + 1), modulo(0), modulo(0), modulo(0) };\n\tif (pos == -1) return { modulo(2).pow(sub.size() - 1), modulo(0), modulo(2).pow(sub.size() - 1), modulo(0) };\n\tvector<int> sub0, sub1;\n\tfor (int i : sub) {\n\t\tif (A[pos][i] == 0) sub0.push_back(i);\n\t\telse sub1.push_back(i);\n\t}\n\tvector<modulo> res1 = recur(pos - 1, sub0, A);\n\tvector<modulo> res2 = recur(pos - 1, sub1, A);\n\tvector<modulo> mult(4);\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\tmult[i ^ j] += res1[i] * (k == 0 || j < 2 ? res2[j] : res2[j ^ 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn mult;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int> > A(H, vector<int>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tvector<int> all;\n\tfor (int i = 0; i < W; ++i) all.push_back(i);\n\tvector<modulo> ans = recur(H - 1, all, A);\n\tmodulo final_ans = ans[1] + ans[3];\n\tfinal_ans *= modulo(2).pow(H * (H - 1) / 2).inv();\n\tcout << final_ans.get() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nconst ll MOD=998244353;\nll n,m,a[310][310];\n\nll ad(ll x,ll y){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll rnk(ll n,ll m,ll M[][310]){\n  ll d=0;\n  fr(j,m){\n    bool f=0;\n    if(M[d][j]==0){\n      f=1;\n      for(ll i=d;i++<n-1;){\n        if(M[i][j]!=0){swap(M[d],M[i]);f=0;}\n      }\n    }\n    if(f && j<m-1) continue;\n    if(f) return d;\n    for(ll i=d;i++<n-1;){\n      if(M[i][j]==0) continue;\n      for(ll k=j;d<m;k++){\n        M[i][k]=(M[i][k]+M[d][k])%2;\n      }\n    }\n    d++;\n    if(d==n) return n;\n  }\n}\n\nint main(){\n  cin>>n>>m;\n  fr(i,n) fr(j,m) cin>>a[i][j];\n  cout<<ad(pwr(2,n+m-1),MOD-pwr(2,n+m-1-rnk(n,m,a)))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = (ll)998244353;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n   ll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n   ll pow(ll a, ll b){if (b == 0) return 1; else if (b % 2 == 0) return pow(a * a, b / 2); else return pow(a * a, b / 2) * a;}\n   ll pow(ll a, ll b, ll m){if (a == 0) return 0; else if (b == 0) return 1; else if (b % 2 == 0) return (pow((a * a) % m, b / 2, m) % m); else return (pow((a * a) % m, b / 2, m) * a) % m;}\n   ll residue(ll a, ll m){return ((a % m) + m) % m;};\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\n\n//与えられたF2上の行列をAとして、(1 << (M * N - rank(A) - 1)) * ((1 << rank(A)) - 1 )が答え.\nconst ll MAX_M = 300, MAX_N = 300;\nll N, M;\nll a[MAX_N][MAX_M];\n\nll rnk(){\n   ll r = 0;\n   ll i = 0, j = 0;\n   while(i < N && j < M){\n      //a[i][j] = 0のときは、k = i + 1, ..., N - 1 からa[k][j] != 0なるkを探してきて, i行目とk行目を入れ替える\n      if(!a[i][j]){\n         FOR(k, i + 1, N){\n            if(a[k][j]){\n               REP(l, M){\n                  swap(a[i][l], a[k][l]);\n               }\n               break;\n            }\n         }\n      }\n      //入れ替えを行ってもa[i][j] = 0のとき（つまりj列目はすべて0のとき)はj列目をスキップ j+1列目にトライ\n      if(!a[i][j]){j++; continue;}\n      r++;\n      //k = i+1,...,N-1行目についてi行目を引く\n      FOR(k, i + 1, N){\n         ll c = a[k][j];\n         REP(l, M){\n            a[k][l] += c * a[i][l];\n            a[k][l] %= 2;\n         }\n      }\n      i++; j++;\n   }\n   return r;\n}\n\nint main(){\n   cin >> N >> M;\n   REP(i, N) REP(j, M) cin >> a[i][j];\n   ll r = rnk();\n/*\n   cout << endl;\n   REP(i, N){\n      REP(j, M){\n         if(j) {cout << \" \";}\n         cout << a[i][j];\n      }\n      cout << endl;\n   }\n   cout << \"rnk = \" << r << endl;\n*/\n   cout << residue(pow(2ll, N + M - 1, MOD) - pow(2ll, N + M - 1 - r, MOD), MOD) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n    bool R[300] = {};\n    bool C[300] = {};\n\n    static const ULL M = 998244353;\n\n    void Solve() {\n        UL H, W; scanf(\"%d%d\", &H, &W);\n        rep(y, H) rep(x, W) {\n            char c; scanf(\" %c\", &c);\n            if (c == '1') R[y] = C[x] = true;\n        }\n        ULL ans = 0;\n        ULL inv2 = 998244353 / 2 + 1;\n        ULL sub = 1;\n        ULL T = 1;\n        rep(y, H) {\n            T = T * 2 % M;\n            if (!R[y]) sub = sub * 2 % M;\n        }\n        T += M - sub; T %= M;\n        ans = T;\n\n        T = 1;\n        rep(x, W) T = T * 2 % M;\n        ans = ans * T % M * inv2 % M;\n        cout << ans << endl;\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    //cout << fixed << setprecision(10);\n    p->Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=200005,INF=1<<30;\n\ntypedef vector<vector<int>> mat;\nmat Gauss(mat &A){\n    int R=A.size(),C=A[0].size();\n    int end=0;//endより上はみた(rank?)\n    \n    for(int j=0;j<C;j++){\n        for(int i=end;i<R;i++){\n            if(A[i][j]==1){\n                swap(A[end],A[i]);\n                for(int k=0;k<R;k++){\n                    if(k==end||A[k][j]==0) continue;\n                    for(int l=0;l<C;l++){\n                        A[k][l]^=A[end][l];\n                    }\n                }\n                end++;\n                break;\n            }\n        }\n    }\n    \n    return A;\n}\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M;cin>>N>>M;\n    mat A(N,vector<int>(M));\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<M;j++){\n            cin>>A[i][j];\n        }\n    }\n    \n    A=Gauss(A);\n    \n    if(N<=M){\n        int cnt=0;\n        for(int i=0;i<N;i++){\n            bool ok=false;\n            for(int j=0;j<M;j++){\n                if(A[i][j]) ok=true;\n            }\n            if(ok) cnt++;\n        }\n        \n        cout<<(mod+rui(2,N+M-1)-rui(2,N-1+M-cnt))%mod<<endl;\n    }else{\n        int cnt=0;\n        for(int j=0;j<M;j++){\n            bool ok=false;\n            for(int i=0;i<N;i++){\n                if(A[i][j]) ok=true;\n            }\n            if(ok) cnt++;\n        }\n        \n        cout<<(mod+rui(2,N+M-1)-rui(2,M-1+N-cnt))%mod<<endl;\n    }\n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    auto add = [&m](vector<long>& to, vector<long>& from){\n        for(int i = 0; i < m; ++i)to[i] ^= from[i];\n    };\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)add(a[j], a[i]);\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    auto add = [&m](vector<long>& to, vector<long>& from){\n        for(int i = 0; i < m; ++i)to[i] ^= from[i];\n    };\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)add(a[j], a[i]);\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n    vector<vector<long>> a(N, vector<long>(M));\n    long s(0);\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * ((modpow(r) + m - 1) % m) % m << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)if(a[j][now])for(int k = 0; k < m; ++k)a[j][k] ^= a[i][k];\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#define inf 20021225\n#define ll long long\n#define mdn 998244353\nusing namespace std;\n\nbitset<310> r[310],a[310]; int n,m;\nint gauss()\n{\n\tint w = 0;\n\tfor(int i=1,j;i<=min(n,m);i++)\n\t{\n\t\tif(!r[i][i])\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t\tif(r[j][i])\tbreak;\n\t\t\tif(j>n)\tcontinue;\n\t\t\tswap(r[i],r[j]);\n\t\t}\n\t\tfor(j=i+1;j<=n;j++)\tif(r[j][i])\n\t\t\tfor(int k=i;k<=m;k++)\tr[j][k] = r[j][k]^r[i][k];\n\t\tif(r[i].any())\tw++;\n\t}\n\t/**for(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=m;j;j--)\n\t\t{\n\t\t\tif(!r[i][j])\tcontinue;\n\t\t\tif(!a[j].any())\n\t\t\t{\n\t\t\t\ta[j]^=r[i],w++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\tr[i]^=a[j];\n\t\t}\n\t}*/\n\treturn w;\n}\nint ksm(int bs,int mi)\n{\n\tint ans = 1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=(ll)ans*bs%mdn;\n\t\tbs=(ll)bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tr[i][j] = x;\n\t\t}\n\tint ans = ksm(2,n+m-1)-ksm(2,n+m-1-gauss());\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\nconst int N = 310;\n\nconst ll M = 998244353;\n\nll pw(ll a, ll n) {\n    ll ret = 1;\n    while (n) {\n        if (n & 1) ret = ret * a % M;\n        a = a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nll nCr[N][N];\n\nvoid init() {\n    nCr[0][0] = 1;\n    for (int i = 1; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            nCr[i][j] = nCr[i - 1][j];\n            if (j) nCr[i][j] = (nCr[i][j] + nCr[i - 1][j - 1]) % M;\n        }\n    }\n}\n\nint n, m;\n\nint gauss(vector<bitset<N>> &a) {\n\n    int kek = 0;\n    fori (i, m) {\n        bool ok = false;\n        for (int j = kek; j < n; ++j) {\n            if (a[j][i]) {\n                swap(a[kek], a[j]);\n                ok = true;\n                break;\n            }\n        }\n        if (ok) {\n            for (int j = 0; j < n; ++j) if (j != kek) {\n                if (a[j][i]) {\n                    a[j] ^= a[kek];\n                }\n            }\n            kek++;\n        }\n    }\n    return kek;\n}\n\nvoid smain() {\n\n    init();\n\n\n    cin >> n >> m;\n    vector<bitset<N>> a(n);\n    fori (i, n) {\n        fori (j, m) {\n            bool cur;\n            cin >> cur;\n            if (cur) a[i].set(j);\n        }\n    }\n\n    int r = gauss(a);\n    ll ans = 0;\n    for (int i = 0; i <= r; i += 2) {\n        ll cur = nCr[r][i] * pw(3, r - i) % M;\n        ans = (ans + cur) % M;\n    }\n    ans = ans * pw(2, n + m - 2 * r) % M;\n    ans = (pw(2, n + m) - ans   + M) % M;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nint n,m,cnt;\nlong long pw[305];\nbitset<305> bas[305];\nbool add(bitset<305> b)\n{\n\tfor (int i=m-1;i>=0;i--)\n\t{\n\t\tif (b[i])\n\t\tb^=bas[i];\n\t}\n\tfor (int i=m-1;i>=0;i--)\n\t{\n\t\tif (b[i])\n\t\t{\n\t\t\tbas[i]=b;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tpw[0]=1;\n\tfor (int i=1;i<=300;i++)\n\tpw[i]=(2*pw[i-1])%mod;\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tbitset<305> cur;\n\t\tfor (int j=0;j<m;j++)\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tcur[j]=a;\n\t\t}\n\t\tcnt+=add(cur);\n\t}\n\tprintf(\"%lld\",(pw[n]-pw[n-cnt]+mod)%mod*pw[m-1]%mod);\n}"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG  // gcc\n    #define _LIBCPP_DEBUG 0 // clang\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define _GLIBCXX_DEBUG\n    // #define _LIBCPP_DEBUG 0\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check() { char bufc; if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"\\n----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\npublic:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(), last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n/* dump definition start */\n#ifdef LOCAL\n    #define dump(...) debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\", dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\n/* dump definition end */\n\n/* function utility start */\ntemplate <class T, class... types> T read(types... args) noexcept { T obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = pair<i32, i32>; using pll = pair<i64, i64>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using rheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\n/* using alias end */\n\n/* library start */\n\n#ifndef Modint_hpp\n#define Modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    static constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    constexpr modint(bool x = false) noexcept : val{x} {}\n    constexpr modint(int x) noexcept : val(x & 1) {}\n    constexpr modint(long long x) noexcept : val(x & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val &= other.val, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { assert(other.val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator-(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator*(const modint &other) const noexcept { return val && other.val; }\n    constexpr modint operator/(const modint &other) const noexcept { assert(other.val); return *this; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { assert(y.val); return x & 1 ? y : modint<2>{0}; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // Modint_hpp\n#ifndef Matrix_hpp\n#define Matrix_hpp\n#include <iostream>\n#include <valarray>\n#include <vector>\n\ntemplate <class Field>\nclass matrix\n{\n    size_t h, w;\n    using row_type = std::valarray<Field>;\n    using data_type = std::valarray<std::valarray<Field>>;\n    data_type data;\n\n    friend std::istream &operator>>(std::istream &is, matrix &x)\n    {\n        for(size_t i = 0; i != x.h; ++i)\n        {\n            for(size_t j = 0; j != x.w; ++j) is >> x.data[i][j];\n        }\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const matrix &x)\n    {\n        for(size_t i = 0; i != x.h; ++i)\n        {\n            if(i) os << \"\\n\";\n            for(size_t j = 0; j != x.w; ++j) os << (j ? \" \" : \"\") << x.data[i][j];\n        }\n        return os;\n    }\n\n    friend matrix transpose(const matrix &x)\n    {\n        matrix res(x.w, x.h);\n        for(size_t i = 0; i != x.w; ++i)\n            for(size_t j = 0; j != x.h; ++j)\n                res[i][j] = x.data[j][i];\n        return res;\n    }\n\n    friend matrix pow(matrix x, long long n)\n    {\n        assert(x.is_square());\n        if(n < 0) x = inverse(x), n = -n;\n        matrix res{identity(x.h)};\n        while(n)\n        {\n            if(n & 1) res *= x;\n            x *= x, n >>= 1;\n        }\n        return res;\n    }\n\n    friend matrix inverse(const matrix &x)\n    {\n        assert(x.is_square());\n        matrix ext_x(x.h, x.h * 2), res(x.h);\n        for(size_t i = 0; i != x.h; ++i) ext_x.data[i][std::slice(0, x.h, 1)] = x.data[i], ext_x.data[i][i + x.h] = 1;\n        if(ext_x.row_canonicalize().size() != x.h) return matrix{0};\n        for(size_t i = 0; i != x.h; ++i) res[i] = ext_x.data[i][std::slice(x.h, x.h, 1)];\n        return res;\n    }\n\npublic:\n    explicit matrix(size_t _n = 0) : h(_n), w(_n) { resize(_n, _n);}\n    matrix(size_t _h, size_t _w) : h(_h), w(_w) { resize(_h, _w); }\n    matrix(const data_type &_data) : h(_data.size()), w(_data.size() ? _data[0].size() : 0), data(_data) {}\n    operator data_type() const { return data; }\n\n    size_t height() const noexcept { return h; }\n    size_t width() const noexcept { return w; }\n    bool is_square() const noexcept { return h == w; }\n    row_type &operator[](const size_t i) noexcept { assert(i < data.size()); return data[i]; }\n    void resize(size_t h, size_t w, const Field val = Field(0)) { data.resize(h, std::valarray<Field>(val, w)); }\n\n    static matrix identity(const size_t n) noexcept\n    {\n        data_type data(row_type(n), n);\n        for(size_t i = 0; i != n; ++i) data[i][i] = 1;\n        return data;\n    }\n\n    matrix operator-() const noexcept { return {-data}; }\n    matrix &operator+=(const matrix &other) noexcept { data += other.data; return *this; }\n    matrix &operator-=(const matrix &other) { data -= other.data; return *this; }\n    matrix &operator*=(matrix other) noexcept\n    {\n        other = transpose(other);\n        for(size_t i = 0; i != h; ++i)\n        {\n            const row_type copied{data[i]};\n            for(size_t j = 0; j != other.h; ++j) data[i][j] = (copied * other.data[j]).sum();\n        }\n        return *this;\n    }\n    matrix operator+(const matrix &x) const noexcept { return matrix(*this) += x; }\n    matrix operator-(const matrix &x) const noexcept { return matrix(*this) -= x; }\n    matrix operator*(const matrix &x) const noexcept { return matrix(*this) *= x; }\n\n    // return the list of pivot columns\n    std::vector<size_t> row_canonicalize()\n    {\n        std::vector<size_t> pivots;\n        for(size_t j = 0, rank = 0; j != w; ++j)\n        {\n            row_type *row_ptr = nullptr;\n            for(size_t i = rank; i != h; ++i)\n            {\n                if(data[i][j] != Field{0})\n                {\n                    const Field f = data[i][j];\n                    if(row_ptr) data[i][std::slice(j, w - j, 1)] -= *row_ptr * f;\n                    else\n                    {\n                        swap(data[rank], data[i]);\n                        std::slice_array<Field> tmp{data[rank][std::slice(j, w - j, 1)]};\n                        tmp = *(row_ptr = new row_type{tmp}) /= f;\n                    }\n                }\n            }\n            if(row_ptr)\n            {\n                for(size_t k = 0; k != rank; ++k)\n                {\n                    const Field f = data[k][j];\n                    data[k][std::slice(j, w - j, 1)] -= *row_ptr * f;\n                }\n                ++rank;\n                pivots.emplace_back(j);\n                delete row_ptr;\n            }\n        }\n        return pivots;\n    }\n\n    Field determinant() const\n    {\n        assert(is_square());\n        data_type copied{data};\n        Field res{1};\n        for(size_t j = 0; j != w; ++j)\n        {\n            bool piv = false;\n            for(size_t i = j; i != h; ++i)\n            {\n                if(copied[i][j] != Field{0})\n                {\n                    const Field coef = copied[i][j];\n                    if(piv) copied[i] -= copied[j] * coef;\n                    else\n                    {\n                        swap(copied[i], copied[j]);\n                        if(i != j) res = -res;\n                        res *= coef;\n                        copied[j] /= coef;\n                        piv = true;\n                    }\n                }\n            }\n            if(!piv) return 0;\n        }\n        return res;\n    }\n};\n#endif\n\n/* library end */\n\n/* The main code follows. */\n\nusing mint=modint<998244353>;\n\nstruct solver\n{\n    solver()\n    {\n        input(int,h);\n        input(int,w);\n        input(matrix<modint<2>>,a,h,w);\n        int rank=a.row_canonicalize().size();\n        int kdim=w-rank;\n        cout << mint::pow(2,h)*(mint::pow(2,w-1)-mint::pow(2,kdim-1)) << \"\\n\";\n    }\n\n    void test()\n    {\n        matrix<int> a({{1,0},{0,-1}});\n        cout << a << \"\\n\";\n        a*=a;\n        cout << a << \"\\n\";\n        return;\n    }\n}; // struct solver\n\nint main(int argc, char *argv[])\n{\n    u32 t; // loop count\n#ifdef LOCAL\n    t = 1;\n#else\n    t = 1; // single test case\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--)\n    {\n        solver();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int MN = 305, P = 99824353;\n\ntypedef std::bitset<MN> bst;\n\nbst val[MN], vec[MN];\n\nint n, m, k;\n\ninline int fpw(int x, int k) {\n\tint res = 1;\n\tfor (; k; k >>= 1, x = (ll) x * x % P)\n\t\tif (k & 1) res = (ll) res * x % P;\n\treturn res;\n}\n\ninline int read() {\n\tint x; bool f; char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tval[i][j] = read();\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = m; j--; )\n\t\t\tif (val[i][j]) {\n\t\t\t\tif (vec[j].count()) val[i] ^= vec[j];\n\t\t\t\telse {\n\t\t\t\t\tvec[j] = val[i];\n\t\t\t\t\tfor (int k = j; k--; )\n\t\t\t\t\t\tif (vec[j][k]) vec[j] ^= vec[k];\n\t\t\t\t\tfor (int k = j; ++k < m; )\n\t\t\t\t\t\tif (vec[k][j]) vec[k] ^= vec[j];\n\t\t\t\t\t++k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\tprintf(\"%lld\\n\", (ll)fpw(2, m - 1) * (fpw(2, n) - fpw(2, n - k) + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 998244353;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> void UNIQUE(vector<T> &a){ a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; scanf(\"%lld\", &x); return x;}\nld fin(){double x; scanf(\"%lf\", &x); return x;}\nchar yuyushiki[1000010]; string stin(){scanf( \"%s\", yuyushiki ); return yuyushiki;}\n\n// head\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\nll gauss(vector<vector<ll>> A){\n  int n = A.size();\n  int p = 0;\n  REP(j, n){\n    int piv = p;\n    FOR(i, p, n){\n      if(A[piv][j] < A[i][j]){\n        piv = i;\n      }\n    }\n    swap(A[p], A[piv]);\n    if(A[p][j] == 0){\n      continue;\n    }\n    assert(A[p][j] == 1);\n    REP(i, n){\n      if(p != i){\n        if(A[i][j] == 1){\n          FOR(k, j, n){\n            A[i][k] = A[i][k] ^ A[p][k];\n          }\n        }\n      }\n    }\n    p++;\n  }\n  return p;\n}\n\nint main(){\n\n  ll n = in();\n  ll m = in();\n  vector<vector<ll>> a(n, vector<ll>(m, 0));  \n  REP(i, n){\n    REP(j, m){\n      a[i][j] = in();\n    }\n  }\n\n  ll r = gauss(a);\n\n  Mod base = modpow(2, r-1) * (modpow(2, r) - 1);\n  Mod ans = base * modpow(2, n + m - 2 * r);\n\n  cout << ans.n << endl;\n  \n  /*\n  ll ans = 0;\n  REP(i, PW(n)){\n    REP(j, PW(m)){\n      ll s = 0;\n      REP(k, n){\n        if(i & PW(k)){\n          REP(l, m){\n            if(j & PW(l)){\n              s += a[k][l];\n            }\n          }\n        }\n      }\n      if(s % 2 == 1){\n        ans++;\n      }\n    }\n  }\n  cout << ans << endl;\n  */\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 310;\nconst int mod = 998244353;\n\nint n, m;\nstd::bitset<MAXN> bs[MAXN];\nint pow2[MAXN];\n\nint main() {\n    pow2[0] = 1;\n    for (int i = 1; i < MAXN; ++i) {\n        pow2[i] = 2 * pow2[i - 1] % mod;\n    }\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0, x; j < m; ++j) {\n            scanf(\"%d\", &x);\n            if (x) {\n                bs[i].set(j);\n            }\n        }\n    }\n    int k = 0;\n    for (int i = 0; i < m; ++i) {\n        int j = k;\n        for (; j < n && !bs[j][i]; ++j);\n        if (j == n) {\n            continue;\n        }\n        std::swap(bs[j], bs[k]);\n        for (j = k + 1; j < n; ++j) {\n            if (bs[j][i]) {\n                bs[j] ^= bs[k];\n            }\n        }\n        ++k;\n    }\n    int ans = ((pow2[n] - pow2[n - k]) % mod + mod) % mod;\n    ans = 1ll * ans * pow2[m - 1] % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\n\n#define int long long\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define REPS(i, n) for (int i = 1, i##_len = (n); i <= i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i <= i##_len; ++i)\n#define REV(i, a, b) for (int i = (a); i >= (b); --i)\n#define CLR(a, b) memset((a), (b), sizeof(a))\n#define DUMP(x) cout << #x << \" = \" << (x) << endl;\n#define INF 1001001001001001001ll\n#define fcout cout << fixed << setprecision(10)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nint N, M;\nint mod = 998244353;\n\nint Gauss(Mat& A) {\n    int rank = 0;\n\n    REP(j, M) {\n        int pivot = -1;\n        FOR(i, rank, N - 1) {\n            if (A[i][j] == 1) {\n                pivot = i;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[rank], A[pivot]);\n        REP(i, N) {\n            if (i == rank) continue;\n            if (A[i][j] == 0) continue;\n            REP(k, M) {\n                A[i][k] ^= A[rank][k];\n            }\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint binpow(int x, int p) {\n    if (p == 0) return 1;\n\n    if (p % 2 == 0)\n        return binpow((x * x) % mod, p / 2);\n    else\n        return (x * binpow(x, p - 1)) % mod;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cin >> N >> M;\n\n    Mat A(N, Vec(M));\n    REP(i, N) REP(j, M) cin >> A[i][j];\n\n    int rank = Gauss(A);\n    cout << (binpow(2, N + M - 1) - binpow(2, N + M - rank - 1) + mod) % mod << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=998244353;\nconst long double eps=1e-60;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\n\nint main(){\n    ll n,m;cin>>n>>m;\n    vector<bitset<300>> v(n);\n    rep(i,n){\n        rep(j,m){\n            int a;cin>>a;\n            if(a)v[i].set(j);\n        }\n    }\n    ll cnt=n;\n    vb used(n,false);\n    rep(i,300){\n        ll k=-1;\n        rep(j,n)if(!used[j]&&v[j].test(i)){\n            if(k==-1){\n                k=j;used[j]=true;\n            }\n            else v[j]^=v[k];\n        }\n        if(k!=-1)cnt--;\n    }\n    out((modpow(2,n)-modpow(2,cnt)+mod)*modpow(2,m-1)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n    long N, M;\n    cin >> N >> M;\n    vector<vector<long>> a(N, vector<long>(M));\n    long s(0);\n    for(auto& i : a)\n        for(auto &j : i){\n            scanf(\"%ld\", &j);\n            s += j;\n        }\n    if(s & 1){\n        cout << modpow(N + M - 2) << endl;\n    }else{\n        puts(\"sorry\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int Mod=998244353;\nint n,m;\n#define Maxn 305\nint num[Maxn][Maxn];\nbool vis[Maxn];\nint val[Maxn][Maxn];\ninline int Fast_Pow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*a%Mod;\n\t\ta=1ll*a*a%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\ninline void rd(int &x){\n\tx=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')ch=getchar();\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t}\n}\n\nint main(){\n\trd(n);rd(m);\n\tfor(register int i=1;i<=n;++i)\n\t    for(register int j=1;j<=m;++j)rd(num[i][j]);\n\tint res=Fast_Pow(2,n);\n\tint T=0;\n\tfor(register int i=1;i<=n;++i)\n\t    for(register int j=m;j>=1;--j)\n\t        if(num[i][j]){\n\t\t\t\tif(!vis[j]){\n\t\t\t\t\tfor(register int k=1;k<=m;++k)val[j][k]=num[i][k];\n\t\t\t\t\tvis[j]=true;\n\t\t\t\t\tT++;\n\t\t\t\t}else{\n\t\t\t\t\tfor(register int k=1;k<=m;++k)num[i][k]^=val[j][k];\n\t\t\t\t}\n\t        }\n\tres=(res-Fast_Pow(2,n-T)+Mod)%Mod;\n\tprintf(\"%d\\n\",1ll*res*Fast_Pow(2,m-1)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\nconstexpr long long mod = 1000000007;\ntypedef pair<int, int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint kj[100005], kji[100005];\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nvoid setkj(int n) {\n\tkj[0] = 1;\n\trep(i, n)kj[i + 1] = kj[i] * (i + 1) % mod;\n\trep(i, n + 1)kji[i] = modpow(kj[i], mod - 2);\n}\nint comb(int r, int c) {\n\tif (c<0 || r<c)return 0;\n\treturn kj[r] * kji[c] % mod*kji[r - c] % mod;\n}\nint GJ(mat &A) {\n\tint N = A.size(), M = A[0].size();\n\tint rnk = 0;\n\trep(i, M) {\n\t\tif (i == M - 1)break;\n\t\tint pivot = -1;\n\t\tfor (int j = rnk; j < N; j++) {\n\t\t\tif (A[i][j]) {\n\t\t\t\tpivot = j; break;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1)continue;\n\t\tswap(A[pivot], A[rnk]);\n\n\t\trep(j, N) {\n\t\t\tif (j != rnk&&A[j][i]) {\n\t\t\t\trep(k, M) {\n\t\t\t\t\tA[j][k] ^= A[rnk][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trnk++;\n\t}\n\n\tint res = 0;\n\trep(i, N)rep(j, M)res += A[i][j];\n\t\n\treturn res;\n}\n\nsigned main() {\n\tsetkj(305);\n\tint n, m; cin >> n >> m;\n\tmat A(n);\n\trep(i, n) {\n\t\tA[i].resize(m);\n\t\trep(j, m)cin >> A[i][j];\n\t}\n\tint r = GJ(A);\n\n\tint ans = modpow(2, n - r)*modpow(2, m - r) % mod;\n\tint d = 0;\n\tfor (int i = 1; i <= r; i += 2) {\n\t\td += modpow(3, r - i)*comb(r, i) % mod;\n\t\td %= mod;\n\t}\n\tcout << d*ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, S default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\nint _main();\nint main()\n{\n    cout << setprecision(12);\n    return _main();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD   998244353LL\n\nbool swap_row(ll a[303][303], ll rows, ll cols, ll pos_row, ll pos_col)\n{\n    ll dpos_row = pos_row;\n    while (!a[dpos_row][pos_col] && dpos_row < rows) dpos_row++;\n    if (dpos_row == rows) return false;\n    if (dpos_row == pos_row) return true;\n\n    rep (i, cols) {\n        ll tmp = a[pos_row][i];\n        a[pos_row][i] = a[dpos_row][i];\n        a[dpos_row][i] = tmp;\n    }\n\n    return true;\n}\n\nll calc_rank(ll a[303][303], ll rows, ll cols)\n{\n    ll pos_row = 0LL;\n\n    rep (pos_col, cols) {\n        bool found = swap_row(a, rows, cols, pos_row, pos_col);\n        if (!found) continue;\n\n        srep (row, pos_row+1LL, rows) {\n            if (!a[row][pos_col]) continue;\n            rep (col, cols) {\n                a[row][col] -= a[pos_row][col];\n                a[row][col] &= 1LL;\n            }\n        }\n\n        pos_row++;\n        if (pos_row >= rows) break;\n\n        debug_printf(\"---- pos_row=%lld\\n\", pos_row);\n        rep (i, rows) {\n            rep (j, cols) debug_printf(\"%lld \", a[i][j]);\n            debug_printf(\"\\n\");\n        }\n\n    }\n\n    debug_printf(\"---- gauss a\\n\");\n    rep (i, rows) {\n        rep (j, cols) debug_printf(\"%lld \", a[i][j]);\n        debug_printf(\"\\n\");\n    }\n\n    ll rank = 0LL;\n\n    rep (row, rows) {\n        rep (col, cols) {\n            if (a[row][col]) {\n                rank = row + 1LL;\n                break;\n            }\n        }\n    }\n\n    debug_printf(\"---- rank = %lld\\n\", rank);\n    return rank;\n}\n\nint _main()\n{\n    ll rows; llin(rows);\n    ll cols; llin(cols);\n    static ll a[303][303];\n    rep (i, rows) rep (j, cols) llin(a[i][j]);\n\n    ll colcnt_all = mod_pow(2LL, cols, MOD);\n    debug_printf(\"colcnt_all = %lld\\n\", colcnt_all);\n\n    ll rank = calc_rank(a, rows, cols);\n\n    // rank + dim(kernel_set) == cols\n    ll dim_kernel_set = cols - rank;\n\n    ll colcnt_invalid = mod_pow(2LL, dim_kernel_set, MOD);\n    ll colcnt_valid = colcnt_all - colcnt_invalid;\n    while (colcnt_valid < 0LL) colcnt_valid += MOD;\n    debug_printf(\"---- colcnt_valid = %lld\\n\", colcnt_valid);\n\n    ll ans = colcnt_valid * mod_pow(2LL, rows, MOD);\n    ans %= MOD;\n    ans *= mod_inv(2LL, MOD);\n    ans %= MOD;\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nint n,m,ans,A[305][305],pw[605];\nint guass(int m,int n)\n{\n\tint i=0,j=0,r;\n\twhile(i<m&&j<n)\n\t{\n\t\tr=i;\n\t\tfor(int k=i;k<m;k++)if(A[k][j]){r=k;break;}\n\t\tif(A[r][j])\n\t\t{\n\t\t\tif(r!=i)for(int k=0;k<=n;k++)swap(A[r][k],A[i][k]);\n\t\t\tfor(int u=i+1;u<m;u++)\n\t\t\tif(A[u][j])for(int k=i;k<=n;k++)A[u][k]^=A[i][k];\n\t\t\ti++;\n\t\t}\n\t\tj++;\n\t}\n\treturn i;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<m;j++)\n\tscanf(\"%d\",&A[j][i]);\n\tpw[0]=1;\n\tfor(int i=1;i<=n+m;i++)pw[i]=2ll*pw[i-1]%mod;\n\tans=(pw[n+m-1]-pw[n+m-1-guass(m,n)]+mod)%mod; \n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#define inf 20021225\n#define ll long long\n#define mdn 998244353\nusing namespace std;\n\nbitset<310> r[310]; int n,m;\nint gauss()\n{\n\tint w = 0;\n\tfor(int i=1,j;i<=min(n,m);i++)\n\t{\n\t\tif(!r[i][i])\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t\tif(r[j][i])\tbreak;\n\t\t\tif(j>n)\tcontinue;\n\t\t\tswap(r[i],r[j]);\n\t\t}\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tif(r[j][i])\tr[j]^=r[i];\n\t\tif(r[i].count())\tw++;\n\t}\n\treturn w;\n}\nint ksm(int bs,int mi)\n{\n\tint ans = 1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=(ll)ans*bs%mdn;\n\t\tbs=(ll)bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tr[i][j] = x;\n\t\t}\n\tint ans = ksm(2,n+m-1)-ksm(2,n+m-1-gauss());\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 305, MOD = 998244353;\nbitset<N> b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int x;\n            cin >> x;\n            b[i][j] = x;\n        }\n    }\n\n    ll bad = 1;\n\n    for (int i = 0, j = 0; i < m; i++) {\n        int sel = -1;\n        for (int k = j; k < n; k++) {\n            if (b[k][i] == 1) {\n                sel = k;\n                break;\n            }\n        }\n        if (sel == -1) {\n            bad = bad * 2 % MOD;\n        }\n        else {\n            swap(b[sel], b[j]);\n            for (int k = 0; k < n; k++) {\n                if (k != j && b[k][i] == 1) {\n                    b[k] ^= b[j];\n                }\n            }\n            j++;\n        }\n    }\n\n    ll ans = 1;\n    for (int i = 0; i < m; i++) {\n        ans = ans * 2 % MOD;\n    }\n\n    ans = (ans - bad + MOD) % MOD;\n\n    for (int i = 0; i < n - 1; i++) {\n        ans = ans * 2 % MOD;\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int N=300+7;\nconst int MOD=998244353;\n\nint add(int a,int b)\n{\n        a+=b;\n        if(a>=MOD)\n        {\n                a-=MOD;\n        }\n        if(a<0)\n        {\n                a+=MOD;\n        }\n        return a;\n}\n\nint mul(int a,int b)\n{\n        return a*(long long)b%MOD;\n}\n\nint expow(int a,int b)\n{\n        int res=1;\n        while(b)\n        {\n                if(b&1)\n                {\n                        res=mul(res,a);\n                }\n                a=mul(a,a);\n                b>>=1;\n        }\n        return res;\n}\n\nint inv(int n)\n{\n        return expow(n,MOD-2);\n}\n\nint fact[N];\n\nint comb(int n,int k)\n{\n        int x=fact[n];\n        int y=mul(fact[k],fact[n-k]);\n        y=expow(y,MOD-2);\n        return mul(x,y);\n}\n\nint n,m;\n\nint mll;\n\nint main()\n{\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n       // freopen(\"input\",\"r\",stdin);\n       // freopen(\"output\",\"w\",stdout);\n        fact[0]=1;\n        for(int i=1;i<N;i++)\n        {\n                fact[i]=mul(fact[i-1],i);\n        }\n        cin>>n>>m;\n        int cnt0=0;\n        mll=expow(2,m);\n        for(int i=1;i<=n;i++)\n        {\n                bool is=0;\n                for(int j=1;j<=m;j++)\n                {\n                        int x;\n                        cin>>x;\n                        if(x==1)\n                        {\n                                is=1;\n                        }\n                }\n                if(is==0)\n                {\n                        cnt0++;\n                }\n        }\n        int scd=expow(2,cnt0);\n        int tot=expow(2,n);\n        int lft=add(tot,-scd);\n        int res=mul(lft,mll);\n        res=mul(res,inv(2));\n        cout<<res<<\"\\n\";\n        return 0;\n}\n/**\n\n**/\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _DEBUG\ntemplate <typename ... Args>\nvoid debugPrintf(const char *format, Args const & ... args) {\n\tfprintf(stdout, format, args ...);\n\tfflush(stdout);\n}\n#else\n#define debugPrintf(...)\n#endif\n\nconst int MOD = 998244353;\n\nint main() {\n\tint n, m; reader(n, m);\n\tusing bs = bitset<300>;\n\tvector<bs> v(n);\n\tFOR(i, n) {\n\t\tFOR(j, m) {\n\t\t\tint x; reader(x);\n\t\t\tif (x == 1) v[i].set(j);\n\t\t}\n\t}\n\n\t{\n\t\tint removed = 0;\n\t\tFOR(j, m) {\n\t\t\tint found = -1;\n\t\t\tfor (int i = removed; i < n; i++) {\n\t\t\t\tif (v[i][j]) {\n\t\t\t\t\tfound = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found == -1) continue;\n\t\t\tswap(v[removed], v[found]);\n\t\t\tFOR(i, n) {\n\t\t\t\tif (i != removed && v[i][j]) {\n\t\t\t\t\tv[i] ^= v[removed];\n\t\t\t\t}\n\t\t\t}\n\t\t\tremoved++;\n\t\t}\n\t}\n\tint freeColRows = 0;\n\tFOR(i, n) {\n\t\tint cnt = 0;\n\t\tFOR(j, m) if (v[i][j])cnt++;\n\t\tif (cnt == 0) {\n\t\t\tfreeColRows++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tFOR(j, m) {\n\t\tint cnt = 0;\n\t\tFOR(i, n) if (v[i][j])cnt++;\n\t\tif (cnt == 0) {\n\t\t\tfreeColRows++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tvector<Pll> vp;\n\tFOR(i, n) {\n\t\tint cnt = 0;\n\t\tFOR(j, m) if (v[i][j])cnt++;\n\t\tif (cnt == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tll one = mod_pow(2, cnt - 1, MOD);\n\t\tll zero = one * 3 % MOD;\n\t\tvp.emplace_back(zero, one);\n\t}\n\n\tPll ans = { 1,0 };\n\tfor (auto& kv : vp) {\n\t\tPll nxt;\n\t\tnxt.first = (ans.first * kv.first + ans.second * kv.second) % MOD;\n\t\tnxt.second = (ans.first * kv.second + ans.second * kv.first) % MOD;\n\t\tans = nxt;\n\t}\n\tll ml = mod_pow(2, freeColRows, MOD);\n\n\twriterLn(ans.second * ml % MOD);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===== 2019/02/09 21:53:05 =====\n\n// includes.hpp\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n// cin.cpp\n\ntemplate <typename T, int M, int N> struct tuple_getter {\n  static void get(std::istream &is, T &x) {\n    is >> std::get<M>(x);\n    tuple_getter<T, M + 1, N>::get(is, x);\n  }\n};\n\ntemplate <typename T, int N> struct tuple_getter<T, N, N> {\n  static void get(std::istream &is, T &x) { is >> std::get<N>(x); }\n};\n\ntemplate <typename... Args>\nstd::istream &operator>>(std::istream &is, std::tuple<Args...> &t) {\n  tuple_getter<std::tuple<Args...>, 0, sizeof...(Args) - 1>::get(is, t);\n  return is;\n}\n\ntemplate <typename T, typename U>\nstd::istream &operator>>(std::istream &is, std::pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate <typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &v) {\n  for (T &x : v) is >> x;\n  return is;\n}\n\n// const_value.hpp\n\nnamespace sub {\ntemplate <typename T>\nconstexpr typename std::enable_if<std::is_integral<T>::value, T>::type\ninf_sub() {\n  return std::numeric_limits<T>::max() / 2 - 1000;\n}\n\ntemplate <typename T>\nconstexpr typename std::enable_if<std::is_floating_point<T>::value, T>::type\ninf_sub() {\n  return std::min(std::numeric_limits<T>::max() / 2 - 1000, T(1e50));\n}\n}  // namespace sub\n\ntemplate <typename T> constexpr T inf() {\n  static_assert(std::is_arithmetic<T>::value, \"T must be arithmetic value\");\n  return sub::inf_sub<T>();\n}\n\ntemplate <typename T> constexpr T zero() {\n  static_assert(std::is_arithmetic<T>::value, \"T must be arithmetic value\");\n  return T(0);\n}\n\nconst long double pi = acos(-1.0);\n\n// cout.cpp\n\ntemplate <typename T, int M, int N> struct tuple_printer {\n  static void print(std::ostream &os, const T &x) {\n    os << std::get<M>(x) << \" \";\n    tuple_printer<T, M + 1, N>::print(os, x);\n  }\n};\n\ntemplate <typename T, int N> struct tuple_printer<T, N, N> {\n  static void print(std::ostream &os, const T &x) { os << std::get<N>(x); }\n};\n\ntemplate <typename... Args>\nstd::ostream &operator<<(std::ostream &os, const std::tuple<Args...> &t) {\n  tuple_printer<std::tuple<Args...>, 0, sizeof...(Args) - 1>::print(os, t);\n  return os;\n}\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \" \";\n    os << *it;\n  }\n  return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::set<T> &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \" \";\n    os << *it;\n  }\n  return os;\n}\n\n// macros.hpp\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\n// misc.hpp\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\n\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\n// range.hpp\n\nclass range {\n  class index_type {\n    int x;\n\n  public:\n    index_type(int x_) : x(x_) {}\n    int operator*() const { return x; }\n    bool operator!=(index_type &r) { return x < r.x; }\n    void operator++() { ++x; }\n  };\n  index_type i, n;\n\npublic:\n  range(int n_) : i(0), n(n_) {}\n  range(int i_, int n_) : i(i_), n(n_) {}\n  index_type &begin() { return i; }\n  index_type &end() { return n; }\n};\n\n// typedef.hpp\n\nusing ll = long long;\nusing ld = long double;\n\n// template.cpp\n\nusing namespace std;\n\n// mod.cpp\n\ntemplate <int M, bool IsPrime = false> class Modulo {\n  int n;\n  static typename std::enable_if<IsPrime, ll>::type inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n  }\n\npublic:\n  Modulo() : n(0) { ; }\n  Modulo(int m) : n(m) {\n    if (n >= M)\n      n %= M;\n    else if (n < 0)\n      n = (n % M + M) % M;\n  }\n  Modulo(ll m) {\n    if (m >= M)\n      m %= M;\n    else if (m < 0)\n      m = (m % M + M) % M;\n    n = m;\n  }\n  explicit operator int() const { return n; }\n  explicit operator ll() const { return n; }\n  bool operator==(const Modulo &a) const { return n == a.n; }\n  Modulo &operator+=(const Modulo &a) {\n    n += a.n;\n    if (n >= M) n -= M;\n    return *this;\n  }\n  Modulo &operator-=(const Modulo &a) {\n    n -= a.n;\n    if (n < 0) n += M;\n    return *this;\n  }\n  Modulo &operator*=(const Modulo &a) {\n    n = (ll(n) * a.n) % M;\n    return *this;\n  }\n  Modulo operator+(const Modulo &a) const {\n    Modulo res = *this;\n    return res += a;\n  }\n  Modulo operator-(const Modulo &a) const {\n    Modulo res = *this;\n    return res -= a;\n  }\n  Modulo operator-() const { return Modulo(0) - *this; }\n  Modulo operator*(const Modulo &a) const {\n    Modulo res = *this;\n    return res *= a;\n  }\n\n  Modulo operator^(ll m) const {\n    if (m == 0) return Modulo(1);\n    const Modulo a = *this;\n    Modulo res = (a * a) ^ (m / 2);\n    return m % 2 ? res * a : res;\n  }\n  typename std::enable_if<IsPrime, Modulo>::type\n  operator/(const Modulo &a) const {\n    return *this * inv(ll(a), M);\n  }\n  typename std::enable_if<IsPrime, Modulo>::type operator/=(const Modulo &a) {\n    return *this *= inv(ll(a), M);\n  }\n\n  friend bool is_zero(const Modulo &x) { return int(x) == 0; }\n  friend int abs(const Modulo &x) { return int(x); }\n\n  static Modulo fact(int n, bool sw = true) {\n    static std::vector<Modulo> v1 = { 1 }, v2 = { 1 };\n    if (n >= (int)v1.size()) {\n      const int from = v1.size(), to = n + 1024;\n      v1.reserve(to);\n      v2.reserve(to);\n      for (int i = from; i < to; ++i) {\n        v1.push_back(v1.back() * Modulo<M, true>(i));\n        v2.push_back(v2.back() / Modulo<M, true>(i));\n      }\n    }\n    return sw ? v1[n] : v2[n];\n  }\n  static Modulo comb(int a, int b) {\n    if (b < 0 || b > a) return 0;\n    return Modulo::fact(a, true) * Modulo::fact(b, false) *\n           Modulo::fact(a - b, false);\n  }\n};\n\n// main.cpp\n\ntemplate <typename T> vector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args> auto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nusing Data = int;\nusing Array = vector<Data>;\nusing Matrix = vector<Array>;\n\nint rankMat(Matrix A) {\n  const int n = A.size(), m = A[0].size();\n  int r = 0;\n  for (int i = 0; r < n && i < m; ++i) {\n    int pivot = r;\n    for (int j = r+1; j < n; ++j)\n      if (A[j][i] > A[pivot][i]) pivot = j;\n    swap(A[pivot], A[r]);\n    if (A[r][i] == 0) continue;\n    for (int k = m-1; k >= i; --k)\n      A[r][k] = A[r][k];\n    for(int j = r+1; j < n; ++j)\n      for(int k = m-1; k >= i; --k)\n        A[j][k] = (A[r][k] & A[j][i]) ^ A[j][k];\n    ++r;\n  }\n  return r;\n}\n\nusing Mod = Modulo<998244353, true>;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  Matrix mat(n, Array(m));\n  REP(i,n) REP(j,m) cin >> mat[i][j];\n  int r = rankMat(mat);\n  cout << int((Mod(2) ^ (n + m - 1)) - (Mod(2) ^ (n + m - 1 - r))) << endl;\n  // cout << r << endl;\n}\n\n// ===== 2019/02/09 21:53:05 =====\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr double eps = 1e-10;\n\nnamespace detail {\n    bool is_zero(double x) {\n        return std::fabs(x) < eps;\n    }\n    bool is_zero(long double x) {\n        return std::fabs(x) < eps;\n    }\n}\n\ntemplate <typename T>\nclass matrix {\npublic:\n    matrix() : matrix(0, 0) {}\n    matrix(int r, int c, T init = T())\n        : a(r, std::vector<T>(c, init)), row_sz(r), col_sz(c)\n    {}\n\n    void init(int r, int c) {\n        *this = matrix(r, c);\n    }\n\n    matrix& operator+=(matrix const& that) {\n        assert(row_sz == that.row_size() && col_sz == that.col_size());\n        for(int i = 0; i < row_sz; ++i) {\n            for(int j = 0; j < col_sz; ++j) {\n                a[i][j] += that[i][j];\n            }\n        }\n    }\n    matrix& operator-=(matrix const& that) {\n        assert(row_sz == that.row_size() && col_sz == that.col_size());\n        for(int i = 0; i < row_sz; ++i) {\n            for(int j = 0; j < col_sz; ++j) {\n                a[i][j] -= that[i][j];\n            }\n        }\n    }\n    matrix& operator*=(matrix const& that) {\n        assert(col_sz == that.row_size());\n        matrix res(row_sz, that.col_size());\n        for(int i = 0; i < row_sz; ++i) {\n            for(int k = 0; k < that.col_size(); ++k) {\n                for(int j = 0; j < col_sz; ++j) {\n                    res[i][j] += a[i][k] * that[k][j];\n                }\n            }\n        }\n        return res;\n    }\n    std::vector<T> operator*(std::vector<T> const& that) {\n        assert(col_sz == (int)that.size());\n        std::vector<T> res(row_sz);\n        for(int i = 0; i < row_sz; ++i) {\n            for(int j = 0; j < col_sz; ++j) {\n                res[i] += a[i][j] * that[j];\n            }\n        }\n        return res;\n    }\n    matrix operator+(matrix const& that) const { return matrix(*this) += that; }\n    matrix operator-(matrix const& that) const { return matrix(*this) -= that; }\n    matrix operator*(matrix const& that) const { return matrix(*this) *= that; }\n\n    bool operator==(matrix const& that) const { return a == that.a; }\n    bool operator!=(matrix const& that) const { return !(*this == that); }\n\n    std::vector<T>& operator[](size_t i)             { return a[i]; }\n    std::vector<T> const& operator[](size_t i) const { return a[i]; }\n\n    int row_size() const { return row_sz; }\n    int col_size() const { return col_sz; }\n\nprivate:\n    std::vector<std::vector<T>> a;\n    int row_sz, col_sz;\n};\n\ntemplate <typename T>\nmatrix<T> eye(int n) {\n    matrix<T> res(n, n);\n    for(int i = 0; i < n; ++i) {\n        res[i][i] = 1;\n    }\n    return res;\n}\n\nint rank_matrix(matrix<int> a) {\n    const int R = a.row_size(), C = a.col_size();\n    int r = 0;\n    for(int i = 0; i < C && r < R; ++i) {\n        int pivot = r;\n        for(int j = r + 1; j < R; ++j) {\n            if(std::abs(a[j][i]) > std::abs(a[pivot][i])) {\n                pivot = j;\n            }\n        }\n        std::swap(a[pivot], a[r]);\n        if(a[r][i] == 0) continue;\n        //for(int k = C - 1; k >= i; --k) {\n        //    a[r][k] = a[r][k] / a[r][i];\n        //}\n        for(int j = r + 1; j < R; ++j) {\n            for(int k = C - 1; k >= i; --k) {\n                (a[j][k] += a[r][k] * a[j][i]) %= 2;\n            }\n        }\n        ++r;\n    }\n    return r;\n}\n\nconstexpr ll mod = 998244353;\n\nll modpow(ll x, ll n) {\n    ll res = 1;\n    while(n > 0) {\n        if(n & 1) (res *= x) %= mod;\n        (x *= x) %= mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    matrix<int> A(n, m);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            cin >> A[i][j];\n        }\n    }\n\n    const int r = rank_matrix(A);\n    cout << (mod + modpow(2, n + m - 1) - modpow(2, n + m - r - 1)) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing type = double;\nusing Vec = vector<type>;\nusing Mat = vector<Vec>;\n\nconst double EPS = 1e-10;\nbool isZero(type x) { return abs(x) <= EPS; }\n\n// sweep mat[i][j] 0<=i<m && 0<=j<c(default c=n)\n// return Vec{j| i,j s.t. minj mat[i][j]!=0}\nvector<int> sweep(Mat& mat, int c = -1) {\n  if (c == -1) c = mat[0].size();\n  int m = mat.size(), n = mat[0].size();\n  int row = 0;\n  vector<int> res;\n  for (int j = 0; j < c; j++) {\n    if (row == m) break;\n    int tar = -1;\n    type v = 0;\n    for (int i = row; i < m; i++) {\n      if (!isZero(mat[i][j]) && abs(v) < abs(mat[i][j])) {\n        tar = i;\n        v = mat[i][j];\n      }\n    }\n    if (tar == -1) continue;\n    if (row != tar) swap(mat[row], mat[tar]);\n    for (int i = 0; i < m; i++) {\n      if (i == row) continue;\n      if (!isZero(mat[i][j])) {\n        type r = mat[i][j] / mat[row][j];\n        for (int k = j; k < n; k++) {\n          mat[i][k] -= r * mat[row][k];\n        }\n      }\n    }\n    res.push_back(j);\n    row++;\n  }\n  return res;\n}\n\ntype det(Mat mat) {\n  sweep(mat);\n  type res = 1;\n  int sz = mat.size();\n  for (int i = 0; i < sz; i++) {\n    if (isZero(mat[i][i])) return type(0);\n    res *= mat[i][i];\n  }\n  return res;\n}\n\nint myrank(Mat mat) { return sweep(mat).size(); }\n\nusing ll = long long;\nconstexpr ll mod = 998244353;\n\ntemplate <typename T>\nT mypow(T a, T b) {\n  if (b == 0) return 1;\n  T tmp = mypow(a, b / 2);\n  if (b % 2)\n    return (((tmp * tmp) % mod) * a) % mod;\n  else\n    return (tmp * tmp) % mod;\n}\n\nint main() {\n    ll n,m;cin>>n>>m;\n    Mat a(n, Vec(m));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            cin >> a[i][j];\n        }\n    }\n    int r = myrank(a);\n    ll ret = mypow(2LL, n+m-1) + mod - mypow(2LL, n+m-r-1);\n    cout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\nconst ll MOD = 998244353;\n\ntypedef vector<vi> mat;\n\nint get_rank(mat A) //mod 2\n{\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r+1; j < n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswap(A[pivot], A[r]);\n\t\tif (A[r][i] == 0) continue;\n\t\tfor (int j = r+1; j < n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tfor (int k = i; k < m; ++k) {\n\t\t\t\t\tA[j][k] ^= A[r][k];\n\t\t\t\t}       \n\t\t\t}\n\t\t}\n\t\t++r;\n\t}\n\treturn r;\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tmat A(N, vi(M));\n\n\trep(i, N) {\n\t\trep(j, M) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\tint r = get_rank(A);\n\n\tll all = 1, dec = 1;\n\trep(i, N+M-1) all = all * 2 % MOD;\n\trep(i, N+M-r-1) dec = dec * 2 % MOD;\n\tcout << (all - dec + MOD) % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n\nconst int mod = 998244353;\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< mod >;\nvoid comb(modint *c, ll n){\n  c[0] = 1;\n  rep1(i,n){\n    c[i] = c[i-1]*((modint) n+1-i)/((modint) i);\n  }\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  vector<vector<modint> > dp(n+1,vector<modint>(4*n+1,0));\n  rep(i,n){\n    rep(j,4*n){\n      int red = (j - n*2 + i);\n      int blue = (-(j-2*n)+i);\n      if(red>=0 && blue>=0){        \n        red/=2;blue/=2;\n        if(red+blue!=i) continue;\n        // cout << \"i red blue \" << i << \" \" << red << \" \"<< blue << endl;\n        int nred,nblue;\n        if(s[i]=='0'){\n          if(i!=0) {\n            dp[i][red+1-blue+2*n] += dp[i-1][j];\n            if(blue>0){\n              dp[i][red+2-(blue-1)+2*n] += dp[i-1][j];\n            }\n          }\n          else dp[i][j+1] += 1;\n        }\n        else if(s[i]=='1'){\n          if(i!=0){\n            dp[i][j+1] += dp[i-1][j];\n            dp[i][j-1] += dp[i-1][j];\n          }\n          else{\n            dp[i][j+1] += 1;\n            dp[i][j-1] += 1;\n          }\n        }\n        else if(s[i]=='2'){\n          if(i!=0){\n            dp[i][j-1] += dp[i-1][j];\n            if(red>0) dp[i][red-1-(blue+2)+2*n] += dp[i-1][j];\n          }\n          else dp[i][j-1] += 1;\n        }\n      }\n    }\n  }\n  // vector<modint> fact(n+1,1);\n  // vector<modint> inv(n+1,1);\n  // fact[0]=1;\n  // rep1(i,n) fact[i] = fact[i-1]*i;\n  // rep(i,n+1) inv[i] = ((modint) 1)/fact[i];\n  // vector<modint> comb(n+1);\n  // rep(i,n+1) comb[i] = fact[n]*inv[i]*inv[n-i];\n\n  modint C[n + 1];\n  comb(C, n);\n\n  modint ans =0;\n  rep(i,4*n){\n    // if(dp[n-1][i]!=0) cout << i <<\" \"<< dp[n-1][i] << endl;\n    int red = (i-n*2+n)/2;\n    int blue = (-(i-2*n)+n)/2;\n    ans += C[red]*dp[n-1][i];\n  }\n  cout << ans << endl;\n  \n  return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, j, k) for (int i = j; i < (int)k; i++)\n#define pb push_back\n#define mt make_tuple\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef complex<ld> point;\ntypedef vector<int> vi;\n\ninline void fileIO(string s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\n\ntemplate <class T, class S>\ninline bool smin(T &a, S b) {\n  return (T)b < a ? a = b, 1 : 0;\n}\ntemplate <class T, class S>\ninline bool smax(T &a, S b) {\n  return a < (T)b ? a = b, 1 : 0;\n}\n\nconstexpr int MOD = 998244353;\nconstexpr int N = 302;\n\ntemplate <typename T>\ninline T mod(T &v) {\n  return v = (v % MOD + MOD) % MOD;\n}\ntemplate <typename S, typename T>\ninline S add(S &l, T r) {\n  return mod(l += r);\n}\nll po(ll v, ll u) {\n  return u ? po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD : 1;\n}\n\nint n, m, id[N], sz;\nbitset<N> tmp, paye[N];\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifndef LOCAL\n  // fileIO(\"superposition\");\n#endif\n  memset(id, -1, sizeof(id));\n  cin >> n >> m;\n  rep(i, 0, n) {\n    rep(j, 0, m) {\n      bool local;\n      cin >> local;\n      tmp[j] = local;\n    }\n    rep(j, 0, m) if (~id[j] && tmp[j]) tmp ^= paye[id[j]];\n    if (tmp.count()) {\n      id[tmp._Find_first()] = sz;\n      rep(j, 0, sz) paye[j] ^= tmp;\n      paye[sz++] = tmp;\n    }\n  }\n\n  ll res = po(2, n) - po(2, n - sz) + MOD;\n  mod(res *= po(2, m - 1));\n  cout << res << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 310;\nconst long long mod = 998244353;\nlong long power(long long x, long long k)\n{\n\tlong long ans = 1;\n\twhile(k)\n\t{\n\t\tif(k & 1)\n\t\t\t(ans *= x) %= mod;\n\t\tk >>= 1;\n\t\t(x *= x) %= mod;\n\t}\n\treturn ans;\n}\nint n, m;\nbool v[maxn][maxn];\nbool base[maxn][maxn] = {0};\nint cnt = 0;\nvoid out()\n{\n\tcout << cnt << endl;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= m; j ++)\n\t\t\tcout << base[i][j] << \" \";\n\t\tcout << endl;\n\t}\n}\nvoid insert(int x)\n{\n\tfor(int i = 1; i <= m; i ++)\n\t{\n\t\tif(v[x][i])\n\t\t{\n\t\t\tif(!base[i][i])\n\t\t\t{\n\t\t\t\tfor(int j = i; j <= m; j ++)\n\t\t\t\t\tbase[i][j] = v[x][j];\n\t\t\t\tcnt ++;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int j = i; j <= m; j ++)\n\t\t\t\t\tv[x][j] ^= base[i][j];\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= m; j ++)\n\t\t\tcin >> v[i][j];\n\t\tinsert(i);\n\t}\n\t\n\tcout << (power(2, n) - power(2, n - cnt) + mod) * power(2, m - 1) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    auto add = [&m](vector<long>& to, vector<long>& from){\n        for(int i = 0; i < m; ++i)to[i] ^= from[i];\n    };\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)add(a[j], a[i]);\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n    long N, M;\n    cin >> N >> M;\n    vector<vector<long>> a(N, vector<long>(M));\n    long s(0);\n    for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * ((modpow(r) + m - 1) % m) % m << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Take me to church\n    I'll worship like a dog at the shrine of your lies\n    I'll tell you my sins and you can sharpen your knife\n    Offer me that deathless death\n    Good God, let me give you my life\n*/\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 303, Mod = 998244353;\nint n, m;\nbitset < N > A[N];\ninline int Power(int a, int b)\n{\n    int ret = 1;\n    for (; b; b >>= 1, a = 1LL * a * a % Mod)\n        if (b & 1) ret = 1LL * ret * a % Mod;\n    return (ret);\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; i ++)\n        for (int j = 0, a; j < m; j ++)\n            scanf(\"%d\", &a), A[i][j] = a;\n    int r = 0;\n    for (int i = 0; i < m; i ++)\n    {\n        for (int j = r; j < n && A[r][i] == 0; j ++)\n            if (A[j][i]) swap(A[r], A[j]);\n        if (r < n && A[r][i])\n        {\n            for (int j = 0; j < n; j ++)\n                if (r != j && A[j][i])\n                    A[j] ^= A[r];\n            r ++;\n        }\n    }\n    return !printf(\"%d\\n\", (Power(2, n + m - 1) - Power(2, n - 1 + m - r) + Mod) % Mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nbool p[302][302];\n\nint _pow(int x){\n  int v = 1, w = 2;\n\n  while(x > 0){\n    if(x & 1) v = 1LL * v * w % MOD;\n    w = 1LL * w * w % MOD; x >>= 1;\n  }\n\n  return v;\n}\n\nint main(){\n  int N, M; scanf(\"%d%d\", &N, &M);\n\n  for(int i = 1; i <= N; i++){\n    for(int j = 1; j <= M; j++){\n      int x; scanf(\"%d\", &x); p[i][j] = x == 1;\n    }\n  }\n\n  int f = 0;\n\n  for(int i = 1; i <= M; i++){\n    int z = 0;\n\n    for(int j = f + 1; j <= N; j++){\n      if(p[j][i]){ z = j; break; }\n    }\n\n    if(z == 0) continue;\n\n    f++;\n    for(int j = 1; j <= M; j++) swap(p[f][j], p[z][j]);\n\n    for(int j = 1; j <= N; j++){\n      if(j == f) continue;\n\n      if(p[j][i]){\n        for(int k = 1; k <= M; k++) p[j][k] ^= p[f][k];\n      }\n    }\n  }\n\n  int a = _pow(N), b = _pow(N - f), c = _pow(M - 1);\n  int ans = 1LL * (a - b < 0 ? a - b + MOD : a - b) * c % MOD;\n\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\n/*bool operator < (const vector<long long> &a,const vector<long long> &b){\n    bool ret=false;\n    DEBUG(\"called\");\n    for(long long i = 0; i < a.size(); i++){\n        if(a[i]>b[i]){\n            ret=false;\n            break;\n        }else if(a[i]<b[i]){\n            ret=true;\n            break;\n        }\n    }\n    return ret;\n}\n*/\nll cache_pow[600];\nll mpow(ll a){\n    static bool flag=false;\n    if(flag){\n        DEBUG(\"True\");\n        return cache_pow[a];\n    }else{\n        cache_pow[0]=1;\n        for(long long i = 1; i < 600; i++){\n            cache_pow[i]=(cache_pow[i-1]*2)%MOD;\n        }\n        flag=true;\n        return cache_pow[a];\n    }\n}\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    sort(a.begin(),a.end(),greater<vll>());\n    ll index=0;\n\n    vector<bitset<300>> A;\n    for(long long i = 0; i < a.size(); i++){\n        A.push_back(bitset<300>(0));\n        for(long long k = 0; k < a[i].size(); k++){\n            A[i][k]=a[i][k]==1;\n        }\n    }\n    ll rank=0;\n    for(long long i = 0; i < a.size(); i++){\n        DEBUG(i);\n        for(; index < a[i].size(); index++){\n            DEBUG(index);\n            for(long long j = i; j < a.size(); j++){\n                if(A[j][index]==1){\n                    swap(A[j],A[i]);\n                    goto OUT;\n                }\n            }\n        }\n        OUT:\n        if(index==a[i].size()){\n            break;\n        }\n        rank++;\n        for(long long j = i+1; j < a.size(); j++){\n            if(A[j][index]==1){\n                A[j]^=A[i];\n            }\n        }\n    }\n    DEBUG(rank);\n    cout<<mpow(M+N-1)-mpow(M+N-1-rank)<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main(){\n    int N, M;\n    while(cin >> N >> M){\n        vector<vector<int>> A(N, vector<int>(M, 0));\n        for(auto& v : A){\n            for(auto& t : v) cin >> t;\n        }\n        int c = 0;\n        int r = 0;\n        for(int i=0;i<min(N, M);i++){\n            int pivot = i;\n            while(c < M){\n                pivot = i;\n                for(int j=i+1;j<N;j++){\n                    if(A[pivot][c] < A[j][c]){\n                        pivot = j;\n                    }\n                }\n                if(A[pivot][c] == 0){ c++; continue; }\n                break;\n            }\n            if(c == M) break;\n            r++;\n            if(pivot != i){\n                for(int j=0;j<M;j++) swap(A[i][j], A[pivot][j]);\n            }\n            for(int j=i+1;j<N;j++){\n                if(A[j][c] != A[i][c]) continue;\n                for(int k=c;k<M;k++){\n                    A[j][k] = (A[j][k] + A[i][k])%2;\n                }\n            }\n        }\n        long long powM = 1, powN = 1;\n        for(int i=0;i<M-1;i++) powM = (2*powM) % MOD;\n        for(int i=0;i<N;i++) powN = (2*powN) % MOD;\n        powN = (powN + MOD - 1) % MOD;\n        long long sub = 1;\n        for(int i=N-1;i>=r;i--){\n            powN = (powN + MOD - sub) % MOD;\n            sub = (2*sub) % MOD;\n        }\n        cout << (powN*powM) % MOD << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Take me to church\n    I'll worship like a dog at the shrine of your lies\n    I'll tell you my sins and you can sharpen your knife\n    Offer me that deathless death\n    Good God, let me give you my life\n*/\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 303, Mod = 998244353;\nint n, m;\nbitset < N > A[N];\ninline int Power(int a, int b)\n{\n    int ret = 1;\n    for (; b; b >>= 1, a = 1LL * a * a % Mod)\n        if (b & 1) ret = 1LL * ret * a % Mod;\n    return (ret);\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; i ++)\n        for (int j = 0, a; j < m; j ++)\n            scanf(\"%d\", &a), A[i][j] = a & 1;\n    int r = 0;\n    for (int i = 0; i < m; i ++)\n    {\n        for (int j = r; j < n && A[r][i] == 0; j ++)\n            if (A[j][i]) swap(A[r], A[j]);\n        if (r < n && A[r][i])\n        {\n            for (int j = 0; j < n; j ++)\n                if (r != j)\n                    A[j] ^= A[r];\n            r ++;\n        }\n    }\n    return !printf(\"%d\\n\", (Power(2, n + m - 1) - Power(2, n - 1 + m - r) + Mod) % Mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 333333;\nconst int MOD = 998244353;\n\nint n, m;\nvector<int> a[500];\nvector<int> st[500];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            int x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n    int sz = 0;\n    for (int i = 0; i < n; i++)\n    {\n        int t = -1;\n        for (int j = 0; j < m; j++)\n        {\n            if (a[i][j] && st[j].size() == 0)\n            {\n                t = j;\n                break;\n            }\n            else\n            {\n                if (a[i][j])\n                {\n                    for (int k = 0; k < m; k++)\n                    {\n                        a[i][k] = a[i][k] ^ st[j][k];\n                    }\n                }\n            }\n        }\n        if (t > -1)\n        {\n            st[t] = a[i];\n            sz++;\n        }\n    }\n    //cout << sz << \"\\n\";\n    cout << inq(2, m - 1) * (inq(2, n) - inq(2, n - sz) + MOD) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 333;\nconst int MOD = 998244353;\ntypedef bitset<N> row;\n\nint n,m,pot[N];\nrow a[N];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    pot[0] = 1; forsn(n,1,2*N) pot[n] = (pot[n-1]+pot[n-1])%MOD;\n\n    cin >> n >> m;\n    forn(i,n) forn(j,m) {\n        int x; cin >> x;\n        if (x&1) a[i].set(j);\n    }\n\n    int rank = 0;\n    forn(j,m) {\n        forsn(i,j,n) if (a[i][j]) {\n            swap(a[i], a[j]);\n            break;\n        }\n        if (a[j][j]) {\n            rank++;\n            forsn(i,j+1,n) if (a[i][j]) \n                a[i] ^= a[j];\n        }\n    }\n    assert(rank <= n);\n\n    auto ans = ll(pot[n] + MOD - pot[n-rank])*(pot[m-1])%MOD;\n    while (ans < 0) ans += MOD;\n    while (ans >= MOD) ans -= MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    using mint = mod_int<998244353>;\n    vector a(N, vint(M));\n    rep(i, N) rep(j, M) { cin >> a[i][j]; }\n    int r = 0;\n    rep(i, M) {\n        sort(a.begin() + r, a.begin() + N), reverse(a.begin() + r, a.begin() + N);\n        for (int j = r + 1; j < N; j++) {\n            if (a[r][i] == a[j][i]) {\n                for (int k = i; k < M; k++) { a[j][k] ^= a[r][k]; }\n            }\n        }\n        if (a[r][i]) { r++; }\n        if (r == min(N, M)) { break; }\n    }\n    cout << mint(2).pow(N + M - 1) - mint(2).pow(N + M - r - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nusing V = bitset<300>;\nint n,m;\nint calc_rank(vector<V>& a) {\n    int r = 0;\n    for (int j = 0; j < m; j++) {\n        for (int i = r+1; i < n; i++) {\n            if (a[i][j]) {\n                if (a[r][j]) a[i] ^= a[r];\n                else swap(a[r], a[i]);\n            }\n        }\n        if (a[r][j]) r++;\n    }\n    return r;\n}\n\nvoid solve() {\n    cin >> n >> m;\n    vector<V> a(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int x; cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = calc_rank(a);\n    mint res = mint(2).exp(n+m-1) - mint(2).exp(n+m-r-1);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nstruct fast_io {\n    static constexpr int size_in = 1 << 26, size_out = 1 << 26;\n    char data_in[size_in], data_out[size_out], *p_in, *p_out, s[30];\n    fast_io() { fread(data_in, 1, size_in, stdin), p_in = data_in, p_out = data_out; }\n    ~fast_io() { fwrite(data_out, 1, p_out - data_out, stdout); }\n    void putchar(char x) { *p_out++ = x; }\n    template<typename T> void putint(T x) {\n        if (x < 0) { *p_out++ = '-', x = -x; }\n        int i = 0;\n        do { s[i++] = x % 10 + '0'; } while (x /= 10);\n        while (i--) { *p_out++ = s[i]; }\n    }\n    template<typename T=int> T getint() {\n        while (!isdigit(*p_in) && *p_in != '-') { p_in++; }\n        bool negative = *p_in == '-';\n        T ret = negative ? 0 : *p_in - '0';\n        while (isdigit(*++p_in)) { (ret *= 10) += *p_in - '0'; };\n        return negative ? -ret : ret;\n    }\n} io;\n\ntemplate<typename T> std::vector<T> xor_eliminate(std::vector<T> src) {\n    std::vector<T> ret;\n    for (int i = 0; i < src.size(); i++) {\n        for (int j = src.size() - 1; j > i; j--) {\n            int x = src[j]._Find_first(), y = src[j - 1]._Find_first();\n            if (x < y) { src[j - 1] ^= src[j]; }\n            if (x <= y) { src[j] ^= src[j - 1]; }\n        }\n        if (src[i].none()) { break; }\n        ret.emplace_back(src[i]);\n    }\n    for (int i = ret.size() - 1; i > 0; i--) {\n        for (int j = 0; j < i; j++) {\n            if (ret[j][ret[i]._Find_first()]) { ret[j] ^= ret[i]; }\n        }\n    }\n    return ret;\n}\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nsigned main() {\n    int N = io.getint(), M = io.getint();\n    using bset = bitset<300>;\n    vector<bset> b(N);\n    rep(i, N) {\n        rep(j, M) {\n            int a = io.getint();\n            b[i][j] = a;\n        }\n    }\n    using mint = mod_int<998244353>;\n    io.putint(mint(2).pow(N + M - 1) - mint(2).pow(N + M - xor_eliminate(b).size() - 1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n        mat<COL_SIZE> b(r);\n        for(int i = 0; i < r; i++) b[i] = a[i];\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n        return a[index];\n    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<300>a(m);\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = a.rank();\n//    cerr << r << endl;\n    cout << (mod_pow(2,n+m-1) -mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <int MOD> struct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tModInt(signed long long sig) {\n\t\tint sigt = sig % MOD;\n\t\tif (sigt < 0)\n\t\t\tsigt += MOD;\n\t\tx = sigt;\n\t}\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = (unsigned long long)x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\tif (u < 0)\n\t\t\tu += MOD;\n\t\tModInt res;\n\t\tres.x = (unsigned)u;\n\t\treturn res;\n\t}\n};\ntemplate <int MOD> ostream &operator<<(ostream &os, const ModInt<MOD> &m) {\n\treturn os << m.x;\n}\ntemplate <int MOD> istream &operator>>(istream &is, ModInt<MOD> &m) {\n\tsigned long long s;\n\tis >> s;\n\tm = ModInt<MOD>(s);\n\treturn is;\n};\n// pow(mint(2), 1000) のように\ntemplate <int MOD> ModInt<MOD> pow(ModInt<MOD> a, unsigned long long k) {\n\tModInt<MOD> r = 1;\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tr *= a;\n\t\ta *= a;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\n\n//#define int long long を使っても大丈夫\nusing mint = ModInt<998244353>;\n\n// nCrで用いる\nvector<mint> fact, factinv;\n// nCrで用いる 予め計算しておく\nvoid nCr_compute_factinv(int N) {\n\tN = min(N, mint::Mod - 1);\n\tfact.resize(N + 1);\n\tfactinv.resize(N + 1);\n\tfact[0] = 1;\n\trep(i, 1, N + 1) fact[i] = fact[i - 1] * i;\n\tfactinv[N] = fact[N].inverse();\n\tfor (int i = N; i >= 1; i--)\n\t\tfactinv[i - 1] = factinv[i] * i;\n}\nmint nCr(int n, int r) {\n\tif (n >= mint::Mod)\n\t\treturn nCr(n % mint::Mod, r % mint::Mod) *\n\t\tnCr(n / mint::Mod, r / mint::Mod);\n\treturn r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];\n}\n\nmint nHr(int n, int r) { return r == 0 ? 1 : nCr(n + r - 1, r); }\ntemplate<int T>\nint abs(ModInt<T> x) { return x.x; }\ntemplate <typename T> class mat : public vector<vector<T>> {\nprivate:\n\tint r, c; //行,列\npublic:\n\tint row() const { return r; }\n\tint column() const { return c; }\n\tmat(int n, int m, T val = 0) {\n\t\tr = n, c = m;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tthis->push_back(vector<T>(m, val));\n\t\t}\n\t}\n\tmat operator+(const mat &another) {\n\t\tif (r != another.r && c != another.c) {\n\t\t\tcout << \"足し算失敗(サイズ不一致)\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tmat<T> X(r, c);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tX[i][j] = (*this)[i][j] + another[i][j];\n\t\t\t}\n\t\t}\n\t\treturn X;\n\t}\n\tmat operator+(const T val) {\n\t\tmat<T> X(r, c);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tX[i][j] = (*this)[i][j] + val;\n\t\t\t}\n\t\t}\n\t\treturn X;\n\t}\n\tmat operator-(const mat &another) {\n\t\tif (r != another.r && c != another.c) {\n\t\t\tcout << \"引き算失敗(サイズ不一致)\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tmat<T> X(r, c);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tX[i][j] = (*this)[i][j] - another[i][j];\n\t\t\t}\n\t\t}\n\t\treturn X;\n\t}\n\tmat operator-(const T val) {\n\t\tmat<T> X(r, c);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tX[i][j] = (*this)[i][j] - val;\n\t\t\t}\n\t\t}\n\t\treturn X;\n\t}\n\tvector<T> operator*(const vector<T> &another) {\n\t\tif (c != (int)another.size()) {\n\t\t\tcout << \"掛け算失敗(サイズ不一致)\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tvector<T> vec(r, 0);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tvec[i] += (*this)[i][j] * another[j];\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n\tmat operator*(const mat &another) {\n\t\tif (c != another.r) {\n\t\t\tcout << \"掛け算失敗(サイズ不一致)\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tmat<T> X(r, another.c);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int k = 0; k < c; k++) {\n\t\t\t\tfor (int j = 0; j < (another.c); j++) {\n\t\t\t\t\tX[i][j] += (*this)[i][k] * another[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn X;\n\t}\n\tmat operator-() {\n\t\tmat<T> X(r, c);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tX[i][j] = -(*this)[i][j];\n\t\t\t}\n\t\t}\n\t\treturn X;\n\t}\n\tint rank() {\n\t\tint res = 0;\n\t\tmat B(r, c);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tB[i][j] = (*this)[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tif (res == r)\n\t\t\t\treturn res;\n\t\t\tint pivot = res;\n\t\t\tfor (int j = res + 1; j < r; j++) {\n\t\t\t\tif (abs(B[j][i]) > abs(B[pivot][i])) {\n\t\t\t\t\tpivot = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (abs(B[pivot][i]) < EPS)\n\t\t\t\tcontinue;\n\t\t\tswap(B[pivot], B[res]);\n\t\t\tfor (int j = i + 1; j < c; j++) {\n\t\t\t\tB[res][j] /= B[res][i];\n\t\t\t}\n\t\t\tfor (int j = res + 1; j < r; j++) {\n\t\t\t\tfor (int k = i + 1; k < c; k++) {\n\t\t\t\t\tB[j][k] -= B[res][k] * B[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n\tT det() {\n\t\tif (r != c) {\n\t\t\tcout << \"正方行列でない(行列式定義不可)\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tT ans = 1;\n\t\tmat B(r, r);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tB[i][j] = (*this)[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = i + 1; j < r; j++) {\n\t\t\t\t// 行i,jをgcdしている!\n\t\t\t\tfor (; B[j][i] != 0; ans = -ans) {\n\t\t\t\t\t// 行をswapしているので(-1)倍する\n\t\t\t\t\tT tm = B[i][i] / B[j][i];\n\t\t\t\t\tfor (int k = i; k < r; k++) {\n\t\t\t\t\t\tT t = B[i][k] - tm * B[j][k];\n\t\t\t\t\t\tB[i][k] = B[j][k];\n\t\t\t\t\t\tB[j][k] = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans *= B[i][i];\n\t\t}\n\t\treturn ans;\n\t}\n\tmat inverse() {\n\t\tif (r != c) {\n\t\t\tcout << \"正方行列でない(逆行列定義不可)\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tmat B(r, 2 * r);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tB[i][j] = (*this)[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tB[i][r + i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tint pivot = i;\n\t\t\tfor (int j = i; j < r; j++) {\n\t\t\t\tif (abs(B[j][i]) > abs(B[pivot][i])) {\n\t\t\t\t\tpivot = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (abs(B[pivot][i]) < EPS) {\n\t\t\t\tcout << \"解なしor不定\" << endl;\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tswap(B[i], B[pivot]);\n\t\t\tfor (int j = i + 1; j <= 2 * r; j++) {\n\t\t\t\tB[i][j] /= B[i][i];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tfor (int k = i + 1; k <= 2 * r; k++) {\n\t\t\t\t\t\tB[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmat res(r, r);\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tres[i][j] = B[i][r + j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvoid print() {\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < (c - 1); j++) {\n\t\t\t\tcout << (*this)[i][j] << \",\";\n\t\t\t}\n\t\t\tcout << (*this)[i][c - 1] << endl;\n\t\t}\n\t}\n};\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N, M; cin >> N >> M;\n\tmat<ModInt<2>>A(N, M);\n\trep(i, 0, N)rep(j, 0, M)cin >> A[i][j];\n\tint r = A.rank();\n\tcout << pow(mint(2), M - 1)*(pow(mint(2), N) - pow(mint(2), N - r)) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\nint N, M;\nint A[311][311];\n\nMint dp[311][2];\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &M);\n    REP (i, N) REP (j, M) scanf(\"%d\", &A[i][j]);\n\n    dp[0][0] = 1;\n    REP (i, N) {\n\tint c = count(A[i], A[i]+M, 1);\n\tREP (a, 2) {\n\t    if (c) {\n\t\tdp[i+1][a] += dp[i][a];\n\t\tdp[i+1][1] += dp[i][a];\n\t    } else {\n\t\tdp[i+1][a] += dp[i][a] * 2;\n\t    }\n\t}\n    }\n\n    Mint ans = dp[N][1] * Mint(2).pow(M-1);\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n/* FastIO by rsk0315 (last update: 2018/02/21 00:36) */\n\nnamespace FastIn {\n    static constexpr size_t BUF_SIZE=1<<17, INT_LEN=24, FLT_LEN=400;\n    static char buf[BUF_SIZE|1]={}, *pos=buf, *endbuf=nullptr;\n    FILE *fin;\n\n    inline bool rebuffer() {\n        // returns true <=> there is at least one unread character\n        size_t rest=endbuf-pos;\n        if (buf+rest > pos) {\n            // buf[:pos] and buf[-pos:] are overlapping, which std::memcpy()\n            // causes undefined behavior.\n            return true;\n        }\n\n        std::memcpy(buf, pos, rest);\n        pos = buf;\n        size_t len=std::fread(pos+rest, 1, BUF_SIZE-rest, fin);\n        *(endbuf = buf + (rest+len)) = 0;\n\n        return *pos;\n    }\n\n    inline bool scan(char &in) {\n        if ((in = *pos)) {\n            ++pos;\n            return true;\n        }\n\n        return rebuffer() && (in = *pos++);\n    }\n\n    inline bool scan(char *in) {\n        if ((*in = *pos) == 0) {\n            if (rebuffer() && (*in = *pos) == 0) {\n                return false;\n            }\n        }\n        ++in;\n        while (true) {\n            if ((*in = *pos++) == 0) {\n                if (rebuffer() && (*in = *pos++) == 0) {\n                    return true;\n                }\n            }\n            ++in;\n        }\n    }\n\n    inline bool scan(double &in) {\n        if (pos + FLT_LEN >= endbuf && !rebuffer()) {\n            in = 0.0;\n            return false;\n        }\n\n        char *tmp;\n        in = std::strtod(pos, &tmp);\n        pos = tmp;\n        return true;\n    }\n\n    template <class Int>\n    inline bool scan(Int &in) {\n        in = 0;\n\n        // assume that no redundant whitespace appears\n        if (pos + INT_LEN >= endbuf && !rebuffer()) {\n            return false;\n        }\n\n        if (std::is_signed<Int>::value) {\n            if (*pos == '-') {\n                in = ~*++pos+'1';\n                while (*++pos >= '0') {\n                    in = in*10 + ~*pos+'1';\n                }\n                ++pos;\n                return true;\n            }\n        }\n\n        // assume that numbers are separated by the character whose value is\n        // less than '0' (e.g. whitespaces, newlines)\n        do {\n            in = in*10 + *pos-'0';\n        } while (*++pos >= '0');\n        ++pos;\n        return true;\n    }\n\n    inline bool eat() {\n        if (*pos > ' ') {\n            return true;\n        }\n\n        do {\n            if (*pos == 0 && !rebuffer()) {\n                return false;\n            }\n        } while (*++pos <= ' ');\n\n        return true;\n    }\n\n    inline bool eat(char ch) {\n        if (*pos == ch) {\n            return true;\n        }\n\n        do {\n            if (*pos == 0 && !rebuffer()) {\n                return false;\n            }\n        } while (*++pos != ch);\n\n        return true;\n    }\n\n    class Scanner {\n        bool rebuffer() {\n            return FastIn::rebuffer();\n        }\n\n    public:\n        Scanner(FILE *fin=stdin) {\n            FastIn::fin = fin;\n            endbuf = pos + std::fread(buf, 1, BUF_SIZE, fin);\n        }\n\n        template <class T>\n        inline bool scan(T &in) {\n            return FastIn::scan(in);\n        }\n\n        template <class First, class... Rest>\n        inline bool scan(First &in, Rest &...ins) {\n            return scan(in) && scan(ins...);\n        }\n    };\n}\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    auto add = [&m](vector<long>& to, vector<long>& from){\n        for(int i = 0; i < m; ++i)to[i] ^= from[i];\n    };\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)if(a[j][now])add(a[j], a[i]);\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n    \n    FastIn::Scanner in;\n\n    long N, M;\n    in.scan(N, M);\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)in.scan(a[j][i]);\n    else for(auto& i : a)for(auto &j : i)in.scan(j);\n\n    auto r = rankF2(a);\n    printf(\"%ld\\n\", modpow(N + M - r - 1) * (modpow(r) - 1) % m);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> //STLͨ���㷨\n#include <cmath> //������ѧ����\n#include <cstdio> //��������/�������\n#include <iostream> //����������/���\n#include <cstring> //�ַ�������\n#include <string> //�ַ�����\n#include <ctime> //�������ʱ��ĺ���\n#define itn int\n#define fro for\n#define ll long long\n#define reg register\n#define inf 1234567890\n#define rep(i,a,b,c) for (int i=a;i<=b;i+=c)\n/*#include <bitset> //STLλ������\n#include <cstype> //�ַ�����\n#include <cerrno> //���������\n#include <complex> //������\n#include <clocale> //���屾�ػ�����\n#include <cstdlib> //������������ڴ���亯��\n#include <deque> //STL˫�˶�������\n#include <exception> //�쳣������\n#include <fstream> //�ļ�����/���\n#include <functional> //STL�������㺯��(���������)\n#include <limits> //�����������������ֵ����\n#include <list> //STL�����б�����\n#include <map> //STLӳ������\n#include <iomanip> //����������/���\n#include <ios> //��������/���֧��\n#include <iosfwd> //����/���ϵͳʹ�õ�ǰ������\n#include <istream> //����������\n#include <ostream> //���������\n#include <queue> //STL��������\n#include <set> //STL��������\n#include <sstream> //�����ַ�������\n#include <stack> //STL��ջ����\n#include <stdexcept> //��׼�쳣��\n#include <streambuf> //�ײ�����/���֧��\n#include <utility> //STLͨ��ģ����\n#include <vector> //STL��̬��������\n#include <cwchar.h>//���ַ�����������/���\n#include <cwctype.h> //���ַ�����*/\n\nusing namespace std;\n\nint ans;\n\nint max(int x,int y){return x>y?x:y;}\n\nint min(int x,int y){return x<y?x:y;}\n\nint abs(int x){return x>0?x:-x;}\n\nint gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\n\nvoid exgcd(int a,int b,int &d,int &x,int &y){if (!b){d=a,x=1,y=0;}else{exgcd(b,a%b,d,y,x);y-=x*(a/b);}}\n\n\ninline char read() {\n\tstatic const int IN_LEN = 1000000;\n\tstatic char buf[IN_LEN], *s, *t;\n\treturn (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);\n}\ntemplate<class T>\ninline void read(T &x) {\n\tstatic bool iosig;\n\tstatic char c;\n\tfor (iosig = false, c = read(); !isdigit(c); c = read()) {\n\t\tif (c == '-') iosig = true;\n\t\tif (c == -1) return;\n\t}\n\tfor (x = 0; isdigit(c); c = read()) x = x * 10 + (c ^ '0');\n\tif (iosig) x = -x;\n}\n\nchar sr[10000000],z[20];int C=-1,Z=0;\nvoid Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(int x){\n\tif (x<0) sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\n//int find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}\n\n//void add(int x,int y,int z){to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;}\nconst int mod=998244353,N=512;\nint a[N][N],s[N][N];\n\nint quick_power(ll a,int b){ll r=1;for (;b;b>>=1,a=a*a%mod)if (b&1) r=r*a%mod;return r;}\n\nint main()\n{\n\tint n,m;\n\tread(n);read(m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++) read(a[i][j]);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tif (a[i][j])\n\t\t\t{\n\t\t\t\tif (!s[j][j])\n\t\t\t\t{\n\t\t\t\t\tfor (int k=j;k<=m;k++) s[j][k]=a[i][k];\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int k=j;k<=m;k++) a[i][k]^=s[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans=1ll*(quick_power(2,n)-quick_power(2,n-ans))*quick_power(2,m-1)%mod;\n\t(ans+=mod)%=mod;\n\tcout<<ans;\n\treturn 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int MN = 305, P = 998244353;\n\ntypedef std::bitset<MN> bst;\n\nbst val[MN], vec[MN];\n\nint n, m, cnt;\n\ninline int fpw(int x, int k) {\n\tint res = 1;\n\tfor (; k; k >>= 1, x = (ll) x * x % P)\n\t\tif (k & 1) res = (ll) res * x % P;\n\treturn res;\n}\n\ninline int read() {\n\tint x; bool f; char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tval[i][j] = read();\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = m; j--; )\n\t\t\tif (val[i][j]) {\n\t\t\t\tif (vec[j].count()) val[i] ^= vec[j];\n\t\t\t\telse {\n\t\t\t\t\t++cnt;\n\t\t\t\t\tvec[j] = val[i];\n\t\t\t\t/*\tfor (int k = j; k--; )\n\t\t\t\t\t\tif (vec[j][k]) vec[j] ^= vec[k];\n\t\t\t\t\tfor (int k = j; ++k < m; )\n\t\t\t\t\t\tif (vec[k][j]) vec[k] ^= vec[j];*/\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\tprintf(\"%lld\\n\", (ll)fpw(2, m - 1) * (fpw(2, n) - fpw(2, n - cnt) + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 998244353;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\treturn (modpow(x,k-1)*x)%M;\n}\n\nint main(){\n\tstatic int n,m;\n\tstatic int a[302][302];\n\tscanf(\"%d%d\",&n,&m);\n\trep1(i,n)rep1(j,m)scanf(\"%d\",&a[i][j]);\n\t\n\tint k = 1;\n\tint r = n;\n\trep1(i,n){\n\t\twhile(1){\n\t\t\tif(k == m+1)break;\n\t\t\tbool con = true;\n\t\t\tfor(int i_ = i ; i_ <= n ; i_ ++){\n\t\t\t\tif(a[i_][k]){\n\t\t\t\t\tif(i != i_){\n\t\t\t\t\t\tfor(int j = k ; j <= m ; j ++)swap(a[i][j],a[i_][j]);\n\t\t\t\t\t}\n\t\t\t\t\tcon = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!con)break;\n\t\t\tk ++;\n\t\t}\n\t\tif(k == m+1){\n\t\t\tr = i-1;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i_ = i+1 ; i_ <= n ; i_ ++){\n\t\t\tif(a[i_][k]){\n\t\t\t\tfor(int j = k ; j <= m ; j ++){\n\t\t\t\t\ta[i_][j] ^= a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk ++;\n\t}\n\t\n\tll ret = modpow(2,n)-modpow(2,n-r)+M; ret %= M;\n\tret *= modpow(2,m-1); ret %= M;\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint bs[305][305];\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tlong long int a,b,c;\n\tlong long int s=0;\n\tconst long long int MAX=998244353;\n\tcin>>n>>m;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<m;j++){\n\t\t\tcin>>a;\n\t\t\ta+=bs[i+1][j]+bs[i][j+1]-bs[i][j];\n\t\t\tbs[i+1][j+1]=a%2;\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\ta=0,b=0;\n\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\tif(bs[i][k]==bs[j][k])a++;\n\t\t\t\telse b++;\n\t\t\t}\n\t\t\ts+=a*b;\n\t\t\tif(s>MAX)s%=MAX;\n\t\t}\n\t}\n\tif(s>MAX)s%=MAX;\n\tcout<<s<<endl;\n\treturn 0;\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n    using namespace std;\n    #define ll long long\n    #define pb push_back\n    #define mp make_pair\n    const int N=305;\n    const int mod=998244353;\n    int a[N][N];\n    int main()\n    {\n    \tint n,m,i,j,k;\n    \tscanf(\"%i %i\",&n,&m);\n    \tfor(i=1;i<=n;i++) for(j=1;j<=m;j++) scanf(\"%i\",&a[i][j]);\n    \tint r=0;\n    \tfor(i=1;i<=m;i++)\n    \t{\n    \t\tbool ok=0;\n    \t\tfor(j=r+1;j<=n;j++)\n    \t\t{\n    \t\t\tif(a[j][i])\n    \t\t\t{\n    \t\t\t\tfor(k=i;k<=m;k++) swap(a[j][k],a[r+1][k]);\n    \t\t\t\tok=1;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tif(!ok) continue;\n    \t\tr++;\n    \t\tfor(j=r+1;j<=n;j++) if(a[j][i])\n    \t\t{\n    \t\t\tfor(k=i;k<=m;k++) a[j][k]=(a[j][k]-a[r][k]+2)%2;\n    \t\t}\n    \t}\n    \tint ans=1,sol=1;\n    \tfor(i=1;i<=n+m-1;i++) ans=ans*2%mod;\n    \tfor(i=1;i<=n+m-r-1;i++) sol=sol*2%mod;\n    \tans-=sol;\n    \tif(ans<0) ans+=mod;\n    \tprintf(\"%i\\n\",ans);\n    \treturn 0;\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nbool p[302][302];\n\nint _pow(int x){\n  int v = 1, w = 2;\n\n  while(x > 0){\n    if(x & 1) v = 1LL * v * w % MOD;\n    w = 1LL * w * w % MOD; x >>= 1;\n  }\n\n  return v;\n}\n\nint main(){\n  int N, M; scanf(\"%d%d\", &N, &M);\n\n  for(int i = 1; i <= N; i++){\n    for(int j = 1; j <= M; j++){\n      int x; scanf(\"%d\", &x); p[i][j] = x == 1;\n    }\n  }\n\n  int f = 0;\n\n  for(int i = 1; i <= M; i++){\n    int z = 0;\n\n    for(int j = f + 1; j <= N; j++){\n      if(p[j][i]){ z = j; break; }\n    }\n\n    if(z == 0) continue;\n\n    f++;\n    for(int j = 1; j <= M; j++) swap(p[f][j], p[z][j]);\n\n    for(int j = 1; j <= N; j++){\n      if(j == f) continue;\n\n      if(p[j][i]){\n        for(int k = 1; i <= M; k++) p[j][k] ^= p[f][k];\n      }\n    }\n  }\n\n  int a = _pow(N), b = _pow(N - f), c = _pow(M - 1);\n  int ans = 1LL * (a - b < 0 ? a - b + MOD : a - b) * c % MOD;\n\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n \n\nconst double __gauss_template_EPS = 1e-8;\n\nint Gauss(vector<vector<int>> &mat) {\n    // return rank\n    int rank = 0;\n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n        rank++;\n\n        int fs = mat[i][i];\n\n        for(int j = i+1; j < n; j++) {\n            int r = mat[j][i] / fs;\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k] * r;\n            }\n        }\n    }\n\n    return rank;\n}\n\n \n \nconst long long __exp_template_MOD = MOD;\nconst long long mod = MOD;\nint qpow(int x, int n){ int y = 1; while(n){ if(n & 1) y = (ll) y * x % mod; x = (ll) x * x % mod; n >>= 1; } return y; }\n \nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n \nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n \n    printf(\"%lld\\n\", ((qpow(2, n+m-1) - qpow(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n \nvoid init() {\n    \n \n \n}\n \nint main () {\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst ll mod=998244353;\nconst int maxn=310;\nint n,m,cnt;\nll mi[maxn],ans;\nbitset<maxn> a,p[maxn];\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m); mi[0]=1; int x;\n\tfor (int i=1;i<=max(n,m);i++) mi[i]=mi[i-1]*2%mod;\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=0;j<m;j++) read(x),a.set(j,x);\n\t\tfor (int j=m-1;j>=0;j--) {\n\t\t\tif (a[j]==0) continue;\n\t\t\tif (p[j].none()) { p[j]=a; cnt++; break; }\n\t\t\ta^=p[j];\n\t\t}\n\t}\n\tans=(mi[n]-mi[n-cnt])*mi[m-1]%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main () {\n  int temp, odd, even;\n  int m, n;\n  cin >> m >> n;\n  vector<vector<int>> scount;\n  scount.push_back(vector<int> (n + 1, 0));\n  for (int i = 0; i < m; i++) {\n    vector<int> sc(1, 0);\n    for (int j = 0; j < n; j++) {\n      cin >> temp;\n      sc.push_back(scount[i][j + 1] - scount[i][j]  + sc[j] + temp);\n      // cout << scount[i][j] - scount[i][j - 1]  + sc[j] + temp;\n    }\n    scount.push_back(sc);\n  }\n  odd = even = 0;\n  \n  for (int i = 1; i < scount.size(); i++)\n    for (int j = 1; j < scount[i].size(); j++) {\n      if (scount[i][j] % 2 == 0)\n        even++;\n  \t  else\n        odd++;\n    }\n  // cout << endl << even << odd;\n  int result = ((even % 998244353) * (odd % 998244353)) % 998244353;\n  for (int i = 2; i < scount.size(); i++)\n    result += scount[i][1] - scount[i-1][1];\n  for (int i = 2; i < scount[0].size(); i++)\n    result += scount[1][i] - scount[1][i - 1];\n  result += scount[1][1];\n  cout << result % 998244353;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 998244353;\n\ntemplate <int mod>\nstruct modint {\n    lint v;\n    modint() : v(0) {}\n    modint(signed v) : v(v) {}\n    modint(lint t) {\n        v = t % mod;\n        if (v < 0)\n            v += mod;\n    }\n\n    modint pow(lint k) {\n        modint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n    static modint add_identity() { return modint(0); }\n    static modint mul_identity() { return modint(1); }\n    modint inv() { return pow(mod - 2); }\n\n    modint &operator+=(modint a) {\n        v += a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator-=(modint a) {\n        v += mod - a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator*=(modint a) {\n        v = v * a.v % mod;\n        return *this;\n    }\n    modint &operator/=(modint a) { return (*this) *= a.inv(); }\n\n    modint operator+(modint a) const { return modint(v) += a; };\n    modint operator-(modint a) const { return modint(v) -= a; };\n    modint operator*(modint a) const { return modint(v) *= a; };\n    modint operator/(modint a) const { return modint(v) /= a; };\n\n    modint operator-() const { return v ? modint(mod - v) : modint(v); }\n\n    bool operator==(const modint a) const { return v == a.v; }\n    bool operator!=(const modint a) const { return v != a.v; }\n    bool operator<(const modint a) const { return v < a.v; }\n};\nusing mint = modint<mod>;\nostream &operator<<(ostream &os, mint m) { return os << m.v; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<bitset<300>> a(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int b;\n            cin >> b;\n            a[i][j] = b;\n        }\n    }\n    vector<bool> used(n, false);\n    int rank = 0;\n    for (int i = 0; i < m; ++i) {\n        int idx = -1;\n        for (int j = 0; j < n; ++j) {\n            if (!used[j] && a[j][i] == 1) {\n                idx     = j;\n                used[j] = true;\n                break;\n            }\n        }\n        if (idx == -1)\n            continue;\n        for (int j = 0; j < n; ++j) {\n            if (j != idx && a[j][i] == 1) {\n                a[j] ^= a[idx];\n            }\n        }\n        rank++;\n    }\n    mint ret = mint(2).pow(n + m - rank - 1) * (mint(2).pow(rank) - 1);\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<algorithm>\n#define gt getchar()\n#define ll long long\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ninline int in()\n{\n\tint k=0;char ch=gt;\n\twhile(ch<'-')ch=gt;\n\twhile(ch>'-')k=k*10+ch-'0',ch=gt;\n\treturn k;\n}\nconst int N=2e5+5,YL=998244353;\ninline int ksm(int a,int k){int r=1;while(k){if(k&1)r=1ll*r*a%YL;a=1ll*a*a%YL,k>>=1;}return r;}\nstd::bitset<305>a[305],now;\nint n,m;\ninline void insert(std::bitset<305> x)\n{\n\tfor(int i=m;i>=1;--i)\n\t\tif(x[i])\n\t\t{\n\t\t\tif(a[i][i])x^=a[i];\n\t\t\telse {a[i]=x;break;}\n\t\t}\n}\nint main()\n{\n\tn=in(),m=in();int r=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tnow.reset();\n\t\tfor(int j=1;j<=m;++j)now[j]=in();\n\t\tinsert(now);\n\t}\n\tfor(int i=1;i<=m;++i)r+=(a[i].count()!=0);\n\tint ans=ksm(2,n)-ksm(2,n-r);if(ans<0)ans+=YL;\n\tans=1ll*ans*ksm(2,m-1)%YL;printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=998244353;\nint n,m,ans,A[305][305],two[605];\nvoid up(int &x){if (x>=P) x-=P;}\n\nint xor_guass(int m, int n) //A是异或方程组系数矩阵 返回秩\n{\n    int i = 0, j = 0, k, r, u;\n    while(i < m && j < n){//当前正在处理第i个方程,第j个变量\n        r = i;\n        for(int k = i; k < m; k++) if(A[k][j]){r = k; break;}\n        if(A[r][j]){\n             if(r != i) for(k = 0; k <= n; k++) swap(A[r][k], A[i][k]);\n             //消元完成之后第i行的第一个非0列是第j列,且第u>i行的第j列全是0\n            for(u = i + 1; u < m; u++) if(A[u][j])\n                for(k = i; k <= n; k++) A[u][k] ^= A[i][k];\n            i++;\n        }\n        j++;\n    }\n    return i;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tA[j-1][i-1]=x;\n\t\t}\n\t \n\ttwo[0]=1;\n\tfor (int i=1;i<=n+m;i++)\n\t\ttwo[i]=two[i-1]*2%P;\n\tans=1ll*(two[n]-two[n-xor_guass(m,n)]+P)*two[m-1]%P; \n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=998244353;\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\nconst double EPS=1E-8;//小さい数\nint ran=0;\nvec gauss_jordan(const mat& A, const vec& b){\n    int n=A.size();\n    mat B(n, vec(n+1));\n    rep(i,0,n){\n        rep(j,0,n){\n            B[i][j]=A[i][j];\n        }\n    }\n    //行列Aの後ろにbを並べ同時に処理する\n    rep(i,0,n) B[i][n]=b[i];\n    rep(i,0,n){\n        //注目している変数の係数の絶対値が大きい式をi番目に持ってくる\n        int pivot=i;\n        rep(j,i,n){\n            if(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n        }\n        swap(B[i], B[pivot]);\n        \n        //解がないか、一意でない\n        //ここの実装難しい\n        if(abs(B[i][i])<EPS) return vec();\n        //注目している変数の係数を1にする\n        rep(j,i+1,n+1) B[i][j]/=B[i][i];\n        rep(j,0,n){\n            if(i!=j){\n                //j番目の式からi番目の変数を消去\n                rep(k,i+1,n+1) B[j][k]-=B[j][i]*B[i][k];\n            }\n        }\n    }\n    vec x(n);\n    rep(i,0,n) x[i]=B[i][n];\n    return x;\n}\nll mod_pow(ll x, ll n, ll mod){\n    if (n==0) return 1;\n    ll res=mod_pow(x*x%mod, n/2, mod);\n    if (n%2==1) res=res*x%mod;\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N,M;\n    cin>>N>>M;\n    mat a(N,vec(M,0));\n    rep(i,0,N){\n        rep(j,0,M){\n            cin>>a[i][j];\n        }\n    }\n    vec b(1,0);\n    gauss_jordan(a, b);\n    rep(i,0,N){\n        bool t=false;;\n        rep(j,0,M){\n            if(abs(a[i][j]-1)<EPS) t=true;\n        }\n        if(t) ran++;\n    }\n    cout <<(mod_pow(2, N+M-1, MOD)-mod_pow(2, N+M-1-ran, MOD)+MOD)%MOD<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353; //1000000007;\n\n\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    vector<vector<ll>> a(n,vector<ll>(m));\n    for(auto &I:a){\n        for(auto &T:I){cin>>T;}\n    }\n    vector<vector<ll>> b;\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        b=a;\n        for(int h=i;h<n;h++){\n            for(int w=1;w<m;w++){\n                b[h][w]+=b[h][w-1];\n                b[h][w]&=1;\n            }\n        }\n        for(int h=i+1;h<n;h++){\n            for(int w=0;w<m;w++){\n                b[h][w]+=b[h-1][w];\n                b[h][w]&=1;\n            }\n        }\n        for(int h=i;h<n;h++){\n            ll cnt0=1,cnt1=0;\n            for(int w=0;w<m;w++){\n                if(b[h][w]){ans+=cnt0; cnt1++; ans%=MOD; cnt1%=MOD;}\n                else{ans+=cnt1; cnt0++; ans%=MOD; cnt0%=MOD;}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\nint mat[301][301],cntj[2][302][302],cnti[2][302][302];\n\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    For(i,N)For(j,M){\n        mat[i+1][j+1]=(mat[i+1][j]+a[i][j])%2;\n    }\n    For(j,M)For(i,N){\n        mat[i+1][j+1]+=mat[i][j+1];\n        mat[i+1][j+1]%=2;\n    }\n    For(i,N)For(j,M){\n        int is_even=mat[i+1][j]%2==0?1:0;\n        cntj[0][i+1][j+1]=cntj[0][i+1][j]+is_even;\n        cntj[1][i+1][j+1]=cntj[1][i+1][j]+1-is_even;\n    }\n    For(j,M)For(i,N){\n        int is_even=mat[i][j+1]%2==0?1:0;\n        cnti[0][i+1][j+1]=cnti[0][i][j+1]+is_even;\n        cnti[1][i+1][j+1]=cnti[1][i][j+1]+1-is_even;\n    }\n    ll ans=0;\n    For(i,N)For(j,M){\n        if(mat[i+1][j+1]%2==0){\n            ans+=cnti[0][i+1][j+1]*cntj[1][i+1][j+1]%MOD;\n            ans%=MOD;\n            ans+=cnti[1][i+1][j+1]*cntj[0][i+1][j+1]%MOD;\n            ans%=MOD;\n        }else{\n            ans+=cnti[0][i+1][j+1]*cntj[0][i+1][j+1]%MOD;\n            ans%=MOD;\n            ans+=cnti[1][i+1][j+1]*cntj[1][i+1][j+1]%MOD;\n            ans%=MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\nusing namespace std;\n\nconst int N=310,mod=998244353;\nint n,m,r,sum,all,vis[N]; bitset<N> b[N];\n\nint insert(bitset<N> x){\n\trep (i,0,m-1)\n\t\tif (x.test(i))\n\t\t\tif (!vis[i]){vis[i]=1,b[i]=x; return 1;}\n\t\t\telse x^=b[i];\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep (i,1,n){\n\t\tbitset<N> a;\n\t\trep (j,1,m){\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tif (x) a.set(j-1);\n\t\t}\n\t\tr+=insert(a);\n\t}\n\tall=1;\n\trep (i,1,n) all=(all+all)%mod;\n\tsum=1;\n\trep (i,1,n-r) sum=(sum+sum)%mod;\n\tall=(all+mod-sum)%mod;\n\trep (i,1,m-1) all=(all+all)%mod;\n\tprintf(\"%d\\n\",all);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconstexpr double eps = 1e-9;\nusing matrix = vector<vector<int>>;\n\nint myrank(matrix A) {\n  const int n = A.size(), m = A[0].size();\n  int r = 0;\n  for (int i = 0; r < n && i < m; ++i) {\n    int pivot = r;\n    for (int j = r + 1; j < n; ++j)\n      if (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[r]);\n    if (abs(A[r][i]) < eps) continue;\n    for (int k = m - 1; k >= i; --k) A[r][k] /= A[r][i];\n    for (int j = r + 1; j < n; ++j)\n      for (int k = i; k < m; ++k) A[j][k] -= A[r][k] * A[j][i];\n    ++r;\n  }\n  return r;\n}\n\nusing ll = long long;\nconstexpr ll mod = 998244353;\n\ntemplate <typename T>\nT mypow(T a, T b) {\n  if (b == 0) return 1;\n  T tmp = mypow(a, b / 2);\n  if (b % 2)\n    return (((tmp * tmp) % mod) * a) % mod;\n  else\n    return (tmp * tmp) % mod;\n}\n\nint main() {\n  ll n, m;\n  cin >> n >> m;\n  matrix a(n, vector<int>(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> a[i][j];\n    }\n  }\n  int r = myrank(a);\n  ll ret = mypow(2LL, n + m - 1) + mod - mypow(2LL, n + m - r - 1);\n  cout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#include<bitset>\n\n#define N 305\n#define M 8000005\n\n#define ls (t<<1)\n#define rs ((t<<1)|1)\n#define mid ((l+r)>>1)\n\n#define mk make_pair\n#define pb push_back\n#define fi first\n#define se second\n\n#define Mo 998244353\n\nusing namespace std;\n\nbitset<305>A[305];\n\nint a[N][N],n,m,i,j;\n\nint power(int x,int y)\n{\n\t\tint s=1;\n\t\tfor(;y;y>>=1)\n\t\t{\n\t\t\t\tif(y&1) s=1ll*s*x%Mo;\n\t\t\t\tx=1ll*x*x%Mo; \n\t\t}\n\t\treturn s;\n}\n\nint Guass()\n{\n\t\tint i,j,k,cnt=0;\n\t\tfor (i=1;i<=n;++i)\n\t\t{\n\t\t\t\tfor (j=1;j<=m;++j) if (A[j][i]) break;\n\t\t\t\tif (j>m) continue;\n\t\t\t\t++cnt;\n\t\t\t\tswap(A[cnt],A[j]);\n\t\t\t\tfor (j=cnt+1;j<=m;++j)\n\t\t\t\t\tif (A[j][i]) A[j]^=A[cnt]; \n\t\t}\n\t\treturn power(2,n-cnt);\n}\n\nint main()\n{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor (i=1;i<=n;++i) \n\t\t\tfor (j=1;j<=m;++j) scanf(\"%d\",&a[i][j]);\n\t\tfor (i=1;i<=m;++i)\n\t\t\tfor (j=1;j<=n;++j) A[i][j]=a[j][i];\n\t\tprintf(\"%d\\n\",1ll*(power(2,n)-Guass()+Mo)%Mo*power(2,m-1)%Mo); \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=305;\nint n,m;\nll two[M];\nvvi a;\n\nint main(){\n\ttwo[0]++;\n\tfor(int i=1;i<M;i++) two[i]=two[i-1]*2%mod;\n\tcin>>n>>m;\n\ta=vvi(n,vi(m));\n\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) cin>>a[i][j];\n\tint I=0;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=I;j<n;j++) if(a[j][i]){\n\t\t\tswap(a[I],a[j]);\n\t\t\tbreak;\n\t\t}\n\t\tif(I==n||!a[I][i]) continue;\n\t\tfor(int j=0;j<n;j++) if(j!=I&&a[j][i]){\n\t\t\tfor(int k=0;k<m;k++) a[j][k]^=a[I][k];\n\t\t}\n\t\tI++;\n\t}\n\tcout<<(two[m]-two[m-I]+mod)*two[n-1]%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n        mat<COL_SIZE> b(r);\n        for(int i = 0; i < r; i++) b[i] = a[i];\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n        return a[index];\n    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<305>a(m+5);\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = a.rank();\n    cerr << r << endl;\n    cout << -1 << endl;\n//    cout << (mod_pow(2,n+m-1) - mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> a[333];\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i].resize(m);\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t}\n\tint p = 998244353;\n\tint r = [](vector<int> *m, int R, int C) {\n\t\tint i = 0;\n\t\tfor (int j = 0; j < C; j++) {\n\t\t\tint k;\n\t\t\tfor (k = i; k < R; k++)\n\t\t\t\tif (m[k][j]) goto p;\n\t\t\tcontinue;\n\t\tp:\n\t\t\tswap(m[k], m[i]);\n\t\t\tfor (k = 0; k < R; k++)\n\t\t\t\tif (k != i && m[k][j])\n\t\t\t\t\tfor (int l = j; l < C; l++)\n\t\t\t\t\t\tm[k][l] ^= m[i][l];\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}(a, n, m);\n\tint x = 0;\n\tfor (int i = 0; i < 2; i++) {\n\t\tint y = 1;\n\t\tfor (int j = 0; j < n + m - 1 - i * r; j++)\n\t\t\t(y += y) %= p;\n\t\t(x += i ? p - y : y) %= p;\n\t}\n\tcout << x << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\n#define BIT_N 333\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef bitset<BIT_N> Bit;\nvector<int> baseNum;\n\nll pow_two[2 * BIT_N];\n\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 333333\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nvector<Bit> gauss(vector<Bit> v, ll &ran){\n\tran = 0;\n\tREP(i,BIT_N) {\n\t\tint pla = -1;\n\t\tfor(int j = ran;j < v.size();j++){\n\t\t\tif(v[j][i] == 1){\n\t\t\t\tpla = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pla != -1){\n\t\t\tswap(v[ran], v[pla]);\n\t\t\tfor(int j = 0;j < v.size();j++){\n\t\t\t\tif(j != ran && v[j][i] == 1)v[j] ^= v[ran];\n\t\t\t}\n\t\t\tran++;\n\t\t}\n\t}\n\treturn v;\n}\n\nint main(){\n\t\n\tpow_two[0] = 1;\n\tREP(i,2 * BIT_N - 1)pow_two[i+1] = pow_two[i] * 2 % MOD;\n\t\n\tvector<Bit> v;\n\tll n, m;cin >> n >> m;\n\tREP(i,n){\n\t\tBit now;\n\t\tREP(j,m){\n\t\t\tint a;cin >> a;\n\t\t\tif(a)now[j] = 1;\n\t\t}\n\t\tv.PB(now);\n\t}\n\t\n\tll ran = 0;\n\tll ans = 0;\n\tgauss(v, ran);\n\tll kake = pow_two[n-ran] * pow_two[m-ran] % MOD;\n\t//cout << \"kake \" << kake << endl;\n\tfor(int i = 1;i <= ran;i+=2){\n\t\tll now = combination(ran, i) * (pow_two[ran - i] * 2 - 1 + MOD) % MOD;\n\t\tans = (ans + now * kake % MOD) % MOD;\n\t\t//cout << \"now \" << now << endl;\n\t}\n\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 998244353;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M;\n    cin >> N >> M;\n    vvec<int> A(N,vec<int>(M));\n    for(int i=0;i<N;i++) for(int j=0;j<M;j++) cin >> A[i][j];\n    vec<mint> pow2(max(N,M)+1,1);\n    for(int i=1;i<=max(N,M);i++) pow2[i] = pow2[i-1]*2;\n    int rank = 0;\n    for(int j=0;j<M;j++){\n        bool update = false;\n        for(int i=rank;i<N;i++) if(A[i][j]){\n            swap(A[i],A[rank]);\n            update = true;\n            break;\n        }\n        if(update){\n            for(int i=0;i<N;i++) if(i!=rank){\n                for(int k=j;k<M;k++) A[i][k] ^= A[rank][k];\n            }\n            rank++;\n        }\n    }\n    cout << pow2[N-1]*(pow2[M]-pow2[M-rank]) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\n\nint compute_rank(vector< vector< int > > A) {\n    int n = A.size();\n    int m = A[0].size();\n    // cout << n << \" \" << m << endl;\n    int rank = max(n, m);\n    vector<bool> row_selected(n, false);\n    for (int i = 0; i < m; ++i) {\n        int j;\n        for (j = 0; j < n; ++j) {\n            if (!row_selected[j] && abs(A[j][i]) > EPS)\n                break;\n        }\n\n        if (j == n) {\n            --rank;\n        } else {\n            row_selected[j] = true;\n            for (int p = i + 1; p < m; ++p)\n                A[j][p] /= A[j][i];\n            for (int k = 0; k < n; ++k) {\n                if (k != j && abs(A[k][i]) > EPS) {\n                    for (int p = i + 1; p < m; ++p)\n                        A[k][p] -= A[j][p] * A[k][i];\n                }\n            }\n        }\n    }\n    return rank;\n}\n\nvector< vector< int > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1LL){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            int x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = compute_rank(a);\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n);\n    ll nr = fast_pow(2LL, n - rank);   \n    ll mm = fast_pow(2LL, m - 1LL);\n\n    cout << MOD((nn - nr) * mm) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll N=300+7;\n\nll n;\nll m;\nll v[N][N];\n\nbool r[N];\nbool c[N];\n\nll res=0;\nll res2=0;\n\nll expow(ll a,ll b)\n{\n        ll res=1;\n        while(b)\n        {\n                if(b&1)\n                {\n                        res=res*a;\n                }\n                a=a*a;\n                b>>=1;\n        }\n        return res;\n}\n\nvoid fixc(ll now)\n{\n        if(now==m+1)\n        {\n                ll s=0;\n                for(ll i=1;i<=n;i++)\n                {\n                        for(ll j=1;j<=m;j++)\n                        {\n                                if(r[i] && c[j])\n                                {\n                                      //  cout<<i<<\" , \"<<j<<\"\\n\";\n                                        s+=v[i][j];\n                                }\n                        }\n                }\n                if(s%2==1)\n                {\n                        res++;\n                        return;\n                        cout<<\"rows: \";\n                        for(ll i=1;i<=n;i++)\n                        {\n                                if(r[i])\n                                {\n                                        cout<<i<<\" \";\n                                }\n                        }\n                        cout<<\"\\n\";\n                        cout<<\"cols: \";\n                        for(ll i=1;i<=m;i++)\n                        {\n                                if(c[i])\n                                {\n                                        cout<<i<<\" \";\n                                }\n                        }\n                        cout<<\"\\n\\n\";\n                        res++;\n                }\n        }\n        else\n        {\n                c[now]=0; fixc(now+1);\n                c[now]=1; fixc(now+1);\n        }\n}\n\nll tot[N];\n\nll ga=0;\n\nvoid fixr(ll now)\n{\n        if(now==n+1)\n        {\n                fixc(1);\n        }\n        else\n        {\n                r[now]=0; fixr(now+1);\n                r[now]=1; fixr(now+1);\n        }\n}\n\nll fact(ll n)\n{\n        ll ans=1;\n        for(ll i=1;i<=n;i++)\n        {\n                ans*=i;\n        }\n        return ans;\n}\n\nll comb(ll n,ll k)\n{\n        return fact(n)/(fact(k)*fact(n-k));\n}\n\nll func(ll i)\n{\n        ll res=0;\n        for(ll a=1;a<=i;a+=2)\n        {\n                res+=comb(i,a);\n        }\n        return res;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n       // freopen(\"input\",\"r\",stdin);\n       // freopen(\"output\",\"w\",stdout);\n        for(ll i=1;i<=10;i++)\n        {\n                ll a=func(i);\n         //       cout<<i<<\" : \"<<a<<\"\\n\";\n        }\n        //cout<<\"\\n\\n\";\n        ///return 0;\n        cin>>n>>m;\n        for(ll i=1;i<=n;i++)\n        {\n                for(ll j=1;j<=m;j++)\n                {\n                        cin>>v[i][j];\n                        tot[i]+=v[i][j];\n                }\n        }\n        fixr(1);\n      //  cout<<ga<<\"\\n\";\n      //  cout<<(expow(2,n)-ga)*expow(2,m-1)<<\"\\n\";\n        cout<<res%998244353<<\"\\n\";\n      ///  cout<<\"B: \"<<res2<<\"\\n\";\n     ///   cout<<\"KEKE\\n\";\n        return 0;\n}\n/**\n\n**/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MOD = 998244353;\nconst int kN = 300 + 5;\nint n, m;\nint a[kN][kN];\n\nint power(int a, int b) {\n  int ret = 1;\n  while (b) {\n    if (b & 1) ret = ret * 1LL * a % MOD;\n    a = a * 1LL * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nint gauss() {\n  int ret = 0;\n  for (int i = 0, p = 0; i < n; ++ i) {\n    int k = -1;\n    while (k == -1 && p != m) {\n      for (int j = i; j < n; ++ j) {\n        if (a[j][p]) {\n          k = j;\n          break;\n        }\n      }\n      if (k == -1) {\n        ++ p;\n      }\n    }\n    if (k == -1) break;\n    ret ++;\n    for (int r = 0; r < m; ++ r)\n      std::swap(a[i][r], a[k][r]);\n    for (int w = i + 1; w < n; ++ w) {\n      if (a[w][p]) {\n        for (int r = 0; r < m; ++ r)\n          a[w][r] ^= a[i][r];\n      }\n    }\n    ++ p;\n  }\n  return ret;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++ i) {\n    for (int j = 0; j < m; ++ j) {\n      scanf(\"%d\", &a[i][j]);\n    }\n  }\n  int rank = gauss();\n  int result = (power(2, n) - power(2, n - rank) + MOD) % MOD * 1LL * power(2, m - 1) % MOD;\n  printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LL long long\n#define _rep(i,j,N) for(int i = (j);i <=(N);i++)\n#define _for(i,j,N) for(int i = (j);i <(N);i++)\n#define ALL(x) x.begin(),x.end()\n\nconst LL mod = 998244353;\nconst int maxn = 305;\nint N,M;\nstring G[maxn];\n\nvoid xors(string &a,string &b){\n    _for(i,0,M){\n        if(a[i] == b[i]) b[i] = '0';\n        else b[i] = 1;\n    }\n}\n\nint pow_mod(int a,int n,int m){\n    if(n == 0) return 1;\n    int x = pow_mod(a,n/2,m);\n    LL ans = ((LL)x * x) % m;\n    if(n & 1) ans = ans * a % m;\n    return (int) ans;\n\n}\n\nint main()\n{\n    cin >> N >> M;\n    _for(i,0,N){\n        _for(j,0,M){\n            string s;\n            cin >> s;\n            G[i].push_back(s[0]);\n        }\n    }\n\n    int r = -1;\n    _for(i,0,N){\n        sort(G+i,G+N,greater<string>());\n        int index = -1;\n        _for(j,0,M) if(G[i][j] == '1'){index = j;break;}\n        if(index == -1){r = i;break;}\n        _for(j,i+1,N){\n            if(G[j][index] == '1'){\n                xors(G[i],G[j]);\n            }\n        }\n    }\n    if(r == -1) r = N;\n    int a = pow_mod(2,M+N-1,mod);\n    int b = pow_mod(2,M+N-r-1,mod);\n    int ans = ((LL)a - b + mod)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int MN = 305, P = 998244353;\n\ntypedef std::bitset<MN> bst;\n\nchar buf[1 << 15], *S, *T;\n\ninline char gc() {\n\tif (S == T) {\n\t\tT = (S = buf) + fread(buf, 1, 1 << 15, stdin);\n\t\tif (S == T) return EOF;\n\t}\n\treturn *S++;\n}\n\nbst val[MN], vec[MN];\n\nint n, m, cnt;\n\ninline int fpw(int x, int k) {\n\tint res = 1;\n\tfor (; k; k >>= 1, x = (ll) x * x % P)\n\t\tif (k & 1) res = (ll) res * x % P;\n\treturn res;\n}\n\ninline int read() {\n\tint x; bool f; char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tval[i][j] = read();\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = m; j--; )\n\t\t\tif (val[i][j]) {\n\t\t\t\tif (vec[j].count()) val[i] ^= vec[j];\n\t\t\t\telse {\n\t\t\t\t\t++cnt;\n\t\t\t\t\tvec[j] = val[i];\n\t\t\t\t/*\tfor (int k = j; k--; )\n\t\t\t\t\t\tif (vec[j][k]) vec[j] ^= vec[k];\n\t\t\t\t\tfor (int k = j; ++k < m; )\n\t\t\t\t\t\tif (vec[k][j]) vec[k] ^= vec[j];*/\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\tprintf(\"%lld\\n\", (ll)fpw(2, m - 1) * (fpw(2, n) - fpw(2, n - cnt) + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int MN = 305, P = 99824353;\n\ntypedef std::bitset<MN> bst;\n\nbst val[MN], vec[MN];\n\nint n, m, k;\n\ninline int fpw(int x, int k) {\n\tint res = 1;\n\tfor (; k; k >>= 1, x = (ll) x * x % P)\n\t\tif (k & 1) res = (ll) res * x % P;\n\treturn res;\n}\n\ninline int read() {\n\tint x; bool f; char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tval[i][j] = read();\n\t\t\t\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = m; j--; )\n\t\t\tif (val[i][j]) {\n\t\t\t\tif (vec[j].count()) val[i] ^= vec[j];\n\t\t\t\telse {\n\t\t\t\t\tvec[j] = val[i];\n\t\t\t\t\tfor (int k = j; ++k < m; )\n\t\t\t\t\t\tif (vec[j][k]) vec[j] ^= vec[k];\n\t\t\t\t\tfor (int k = j; k--; )\n\t\t\t\t\t\tif (vec[k][j]) vec[k] ^= vec[j];\n\t\t\t\t\t++k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\tprintf(\"%lld\\n\", (ll)fpw(2, m - 1) * (fpw(2, n) - fpw(2, n - k) + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nint n,m,a[N][N],now[N],in[N],p[N][N],r;\ninline int poww(int a,int b){\n  int res=1;\n  for(;b;b>>=1,a=1ll*a*a%mod)\n    if(b&1)res=1ll*res*a%mod;\n  return res;\n}\nint main()\n{\n  n=read();m=read();\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=m;j++)a[i][j]=read();\n  for(int i=1;i<=n;i++){\n    memcpy(now,a[i],sizeof(now));\n    for(int j=1;j<=m;j++)\n      if(now[j]){\n    if(in[j])for(int k=j;k<=m;k++)now[k]^=p[j][k];\n    else{in[j]=1;memcpy(p[j],now,sizeof(p[j]));r++;break;}\n      }\n  }\n  printf(\"%lld\\n\",1ll*(poww(2,n)-poww(2,n-r)+mod)%mod*poww(2,m-1)%mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\n\nvoid norm(VV<int>& a) {\n\tint n = a.size(), m = a[0].size();\n\tREP(j, m) {\n\t\tint pivot = -1;\n\t\tREP(i, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tpivot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) continue;\n\n\t\tFOR(i, pivot + 1, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tREP(k, m) {\n\t\t\t\t\ta[i][k] ^= a[pivot][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tMAT(int, a, n, m);\n\n\tREP(_, 2) {\n\t\tnorm(a);\n\t\tVV<int> b(m, V<int>(n));\n\t\tREP(i, n) REP(j, m) {\n\t\t\tb[j][i] = a[i][j];\n\t\t}\n\t\tstd::swap(n, m);\n\t\tstd::swap(a, b);\n\t}\n\n\tint one = 0;\n\tint zero = 0;\n\tREP(i, n) {\n\t\tbool f = false;\n\t\tREP(j, m) if (a[i][j]) f = true;\n\t\tif (f) ++one;\n\t\telse ++zero;\n\t}\n\tREP(j, m) {\n\t\tbool f = false;\n\t\tREP(i, n) if (a[i][j]) f = true;\n\t\tif (f) /*++one*/;\n\t\telse ++zero;\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= one; i += 2) {\n\t\tint sum = Combination(one, i);\n\t\t(sum *= powMod(3, one - i, MOD)) %= MOD;\n\t\t(sum *= powMod(2, zero, MOD)) %= MOD;\n\t\t(ans += sum) %= MOD;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <iostream>\n#include <bitset>\nusing namespace std;\n#define N 305\n#define ll long long\n#define mod 998244353\nint n,m,b[N],ans=1;\nbitset<N>a[N],t[N];\nvoid insert(bitset<N> now)\n{\n\tfor(int i=m;i;i--)if(now[i])\n\t\tif(t[i][i])now^=t[i];\n\t\telse {t[i]=now;return ;}\n\tans=ans<<1;ans%=mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int tt=1,pp=1;\n\tfor(int i=1;i<m;i++)pp=(pp<<1)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ttt<<=1;tt%=mod;\n\t\tfor(int j=1,x;j<=m;j++)\n\t\t\tscanf(\"%d\",&x),a[i][j]=(x==1);\n\t\tinsert(a[i]);\n\t}\n\tprintf(\"%d\\n\",(ll)(tt-ans+mod)*pp%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n    UL G[300][300];\n\n    static const ULL M = 998244353;\n\n    void Solve() {\n        UL H, W; scanf(\"%d%d\", &H, &W);\n        rep(y, H) rep(x, W) {\n            char c; scanf(\" %c\", &c);\n            G[x][y] = c - '0';\n        }\n        UL Ker = 0;\n        UL K = 0;\n        rep(y, H) {\n            UL Y = 0;\n            while (true) {\n                if (K == W) break;\n                for (Y = y; Y < H; Y++) if (G[K][Y]) break;\n                if (Y < H) break;\n                K++;\n            }\n            if (K == W) { Ker = H - y; break; }\n            rep(x, W) swap(G[x][y], G[x][Y]);\n            for (UL yy = y + 1; yy < H; yy++) {\n                if (G[K][yy]) {\n                    for (UL x = K; x < W; x++)\n                        G[x][yy] = G[x][yy] ^ G[x][y];\n                }\n            }\n        }\n        ULL ans = 1; rep(i, H + W - 1) ans = ans * 2 % M;\n        ULL sub = 1; rep(i, Ker + W - 1) sub = sub * 2 % M;\n        ans = (ans + M - sub) % M;\n        cout << ans << endl;\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    //cout << fixed << setprecision(10);\n    p->Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 998244353;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\nclass Solver2 {\n public:\n  int n, m;\n  vector<vector<int>> a;\n  Solver2(LL n, LL m) : n(n), m(m), a(n, vector<int>(m)){};\n\n  int sweep(vector<vector<int>> X) {\n    int rank = 0;\n    for (int col = 0; col < m; ++col) {\n      int nonzeroRow = -1;\n      for (int r = 0; r < n; ++r) {\n        if (X[r][col]) {\n          nonzeroRow = r;\n          break;\n        }\n      }\n      if (nonzeroRow == -1) continue;\n      swap(a[rank], a[nonzeroRow]);\n      for (int r = rank + 1; r < n; ++r) {\n        if (X[r][col]) {\n          for (int c = col; c < m; ++c) {\n            X[r][c] ^= X[rank][c];\n          }\n        }\n      }\n      rank++;\n    }\n    return rank;\n  }\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        cin >> a[i][j];\n      }\n    }\n    int rank = sweep(a);\n    if (rank == 0)\n      cout << 0 << endl;\n    else\n      cout << (Modint<>(2).mpow(rank) - 1) * Modint<>(2).mpow(n - rank) * Modint<>(2).mpow(m - 1) << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 998244353;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\nclass Solver2 {\n public:\n  int n, m;\n  vector<vector<int>> a;\n  Solver2(LL n, LL m) : n(n), m(m), a(n, vector<int>(m)){};\n\n  int sweep(vector<vector<int>> X) {\n    int rank = 0;\n    for (int col = 0; col < m; ++col) {\n      int nonzeroRow = -1;\n      for (int r = rank; r < n; ++r) {\n        if (X[r][col]) {\n          nonzeroRow = r;\n          break;\n        }\n      }\n      if (nonzeroRow == -1) continue;\n      if (nonzeroRow > rank) swap(X[rank], X[nonzeroRow]);\n      for (int r = rank + 1; r < n; ++r) {\n        if (X[r][col]) {\n          for (int c = col; c < m; ++c) {\n            X[r][c] ^= X[rank][c];\n          }\n        }\n      }\n      rank++;\n    }\n    return rank;\n  }\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        cin >> a[i][j];\n      }\n    }\n    int rank = sweep(a);\n    if (rank == 0)\n      cout << 0 << endl;\n    else\n      cout << (Modint<>(2).mpow(rank) - 1) * Modint<>(2).mpow(n - rank) * Modint<>(2).mpow(m - 1) << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=305;\nint n,m;\nll two[M];\nvvi a;\n\nint main(){\n\ttwo[0]++;\n\tfor(int i=1;i<M;i++) two[i]=two[i-1]*2%mod;\n\tcin>>n>>m;\n\ta=vvi(n,vi(m));\n\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) cin>>a[i][j];\n\tint I=0;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=I;j<n;j++) if(a[j][i]){\n\t\t\tswap(a[I],a[j]);\n\t\t\tbreak;\n\t\t}\n\t\tif(I==n||!a[I][i]) continue;\n\t\tfor(int j=0;j<n;j++) if(j!=I&&a[j][i]){\n\t\t\tfor(int k=0;k<m;k++) a[j][k]^=a[I][k];\n\t\t}\n\t\tI++;\n\t}\n\tcout<<(two[m]-two[m-I]+mod)*two[n-1]%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct mint{\n  static unsigned R, RR, Rinv, W, md, mdninv;\n  unsigned val;\n  mint(){\n  }\n  mint(int a){\n    val = mulR(a);\n  }\n  mint(unsigned a){\n    val = mulR(a);\n  }\n  mint(long long a){\n    val = mulR(a);\n  }\n  mint(unsigned long long a){\n    val = mulR(a);\n  }\n  int get_inv(long long a, int md){\n    long long e, s=md, t=a, u=1, v=0;\n    while(s){\n      e=t/s;\n      t-=e*s;\n      u-=e*v;\n      swap(t,s);\n      swap(u,v);\n    }\n    if(u<0){\n      u+=md;\n    }\n    return u;\n  }\n  void setmod(unsigned m){\n    int i;\n    unsigned t;\n    W = 32;\n    md = m;\n    R = (1ULL << W) % md;\n    RR = (unsigned long long)R*R % md;\n    switch(m){\n      case 104857601:\n      Rinv = 2560000;\n      mdninv = 104857599;\n      break;\n      case 998244353:\n      Rinv = 232013824;\n      mdninv = 998244351;\n      break;\n      case 1000000007:\n      Rinv = 518424770;\n      mdninv = 2226617417U;\n      break;\n      case 1000000009:\n      Rinv = 171601999;\n      mdninv = 737024967;\n      break;\n      case 1004535809:\n      Rinv = 234947584;\n      mdninv = 1004535807;\n      break;\n      case 1007681537:\n      Rinv = 236421376;\n      mdninv = 1007681535;\n      break;\n      case 1012924417:\n      Rinv = 238887936;\n      mdninv = 1012924415;\n      break;\n      case 1045430273:\n      Rinv = 254466304;\n      mdninv = 1045430271;\n      break;\n      case 1051721729:\n      Rinv = 257538304;\n      mdninv = 1051721727;\n      break;\n      default:\n      Rinv = get_inv(R, md);\n      mdninv = 0;\n      t = 0;\n      for(i=0;i<(int)W;i++){\n        if(t%2==0){\n          t+=md;\n          mdninv |= (1U<<i);\n        }\n        t /= 2;\n      }\n    }\n  }\n  unsigned mulR(unsigned a){\n    return (unsigned long long)a*R%md;\n  }\n  unsigned mulR(int a){\n    if(a < 0){\n      a = a%md+md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned mulR(unsigned long long a){\n    return mulR((unsigned)(a%md));\n  }\n  unsigned mulR(long long a){\n    a %= md;\n    if(a < 0){\n      a += md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned reduce(unsigned T){\n    unsigned m=T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned reduce(unsigned long long T){\n    unsigned m=(unsigned)T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned get(){\n    return reduce(val);\n  }\n  mint &operator+=(mint a){\n    val += a.val;\n    if(val >= md){\n      val -= md;\n    }\n    return *this;\n  }\n  mint &operator-=(mint a){\n    if(val < a.val){\n      val = val + md - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  mint &operator*=(mint a){\n    val = reduce((unsigned long long)val*a.val);\n    return *this;\n  }\n  mint &operator/=(mint a){\n    return *this *= a.inverse();\n  }\n  mint operator+(mint a){\n    return mint(*this)+=a;\n  }\n  mint operator-(mint a){\n    return mint(*this)-=a;\n  }\n  mint operator*(mint a){\n    return mint(*this)*=a;\n  }\n  mint operator/(mint a){\n    return mint(*this)/=a;\n  }\n  mint operator+(int a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(int a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(int a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(int a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator+(long long a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(long long a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(long long a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(long long a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator-(void){\n    mint res;\n    if(val){\n      res.val=md-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  operator bool(void){\n    return val!=0;\n  }\n  operator int(void){\n    return get();\n  }\n  operator long long(void){\n    return get();\n  }\n\n  mint inverse(){\n    int a = val, b = md, u = 1, v = 0, t;\n    mint res;\n    while(b){\n      t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    if(u < 0) u += md;\n    res.val = (unsigned long long)u*RR % md;\n    return res;\n  }\n\n  mint pw(unsigned long long b){\n    mint a(*this), res;\n    res.val = R;\n    while(b){\n      if(b&1) res *= a;\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n\n  bool operator==(int a){return mulR(a)==val;}\n  bool operator!=(int a){return mulR(a)!=val;}\n};\nunsigned mint::md, mint::W, mint::R, mint::Rinv, mint::mdninv, mint::RR;\nmint operator+(int a, mint b){return mint(a)+=b;\n}\nmint operator-(int a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(int a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(int a, mint b){\n  return mint(a)/=b;\n}\nmint operator+(long long a, mint b){\n  return mint(a)+=b;\n}\nmint operator-(long long a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(long long a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(long long a, mint b){\n  return mint(a)/=b;\n}\nvoid rd(int &x){\n  int k, m=0;\n  x=0;\n  for(;;){\n    k = getchar_unlocked();\n    if(k=='-'){\n      m=1;\n      break;\n    }\n    if('0'<=k&&k<='9'){\n      x=k-'0';\n      break;\n    }\n  }\n  for(;;){\n    k = getchar_unlocked();\n    if(k<'0'||k>'9'){\n      break;\n    }\n    x=x*10+k-'0';\n  }\n  if(m){\n    x=-x;\n  }\n}\nvoid wt_L(int x){\n  char f[10];\n  int m=0, s=0;\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    putchar_unlocked('-');\n  }\n  while(s--){\n    putchar_unlocked(f[s]+'0');\n  }\n}\nvoid wt_L(mint x){\n  int i;\n  i = (int)x;\n  wt_L(i);\n}\nint A[301][301], X, Y;\n#define MD 998244353\nmint solve(void){\n  int i, j, k, m, rank;\n  mint res, tmp;\n  j = 0;\n  for(i=0;i<Y;i++){\n    for(k=j;k<X;k++){\n      if(A[k][i]){\n        break;\n      }\n    }\n    if(k==X){\n      continue;\n    }\n    for(m=0;m<Y;m++){\n      swap(A[j][m], A[k][m]);\n    }\n    for(k=j+1;k<X;k++){\n      if(A[k][i]){\n        for(m=0;m<Y;m++){\n          A[k][m] ^= A[j][m];\n        }\n      }\n    }\n    j++;\n  }\n  rank = 0;\n  for(i=0;i<X;i++){\n    for(j=0;j<Y;j++){\n      if(A[i][j]){\n        break;\n      }\n    }\n    if(j<Y){\n      rank++;\n    }\n  }\n  res = 0;\n  if(rank==0){\n    return res;\n  }\n  tmp = 1;\n  for(i=0;i<X+Y-2;i++){\n    tmp *= 2;\n  }\n  for(i=0;i<rank;i++){\n    res += tmp;\n    tmp /= 2;\n  }\n  return res;\n}\nint main(){\n  int i, j, k;\n  mint res;\n  {\n    mint x;\n    x.setmod(MD);\n  }\n  rd(X);\n  rd(Y);\n  for(i=0;i<X;i++){\n    for(j=0;j<Y;j++){\n      rd(A[i][j]);\n    }\n  }\n  res = solve();\n  wt_L(res);\n  putchar_unlocked('\\n');\n  return 0;\n}\n// cLay varsion 20180730-1\n\n// --- original code ---\n// #define MD 998244353\n// \n// int X, Y;\n// int A[301][301];\n// \n// mint solve(void){\n//   int i, j, k, m;\n//   int rank;\n//   mint res, tmp;\n// \n//   j = 0;\n//   rep(i,Y){\n//     rep(k,j,X) if(A[k][i]) break;\n//     if(k==X) continue;\n// \n//     rep(m,Y) swap(A[j][m], A[k][m]);\n//     rep(k,j+1,X) if(A[k][i]){\n//       rep(m,Y) A[k][m] ^= A[j][m];\n//     }\n//     j++;\n//   }\n// \n//   rank = 0;\n//   rep(i,X){\n//     rep(j,Y) if(A[i][j]) break;\n//     if(j<Y) rank++;\n//   }\n// \n//   res = 0;\n//   if(rank==0) return res;\n// \n//   tmp = 1;\n//   rep(i,X+Y-2) tmp *= 2;\n// \n//   rep(i,rank){\n//     res += tmp;\n//     tmp /= 2;\n//   }\n// \n//   return res;\n//   \n// }\n// \n// {\n//   int i, j, k;\n//   mint res;\n//   \n//   rd(X,Y);\n//   rep(i,X) rep(j,Y) rd(A[i][j]);\n// \n//   res = solve();\n//   wt(res);\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nint n,m,a[310][310];\nint od[310],ev[310],bit[310],xxj[310];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n/*\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n*/\n/*\tfor(int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tprintf(\"%d \",a[i][j]);\n*/\n\n\tint u=max(n,m);\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tint cnt=0;\n/*\tfor(int i=1;i<=u;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i]) continue;\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=u;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n*/\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tif(xxj[j])\n\t\t\t\t\tfor(int k=j;k<=m;k++)\n\t\t\t\t\t\ta[i][k]^=a[xxj[j]][k];\n\t\t\t\telse {xxj[j]=i;cnt++;break;}\n\t\t\t}\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=u;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst long long mod = 998244353;\nint a[301][301];\nint b[301][301];\nint c[301];\n\nlong long power(long long a,long long b){\n    long long res = 1;\n    while(b){\n        if(b&1) res = res*a%mod;\n        a = a*a%mod;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid swapRow(int i,int j,int m){\n    int t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n    for(int k = 1; k <= m; k++){\n        int t = b[i][k];\n        b[i][k] = b[j][k];\n        b[j][k] = t;\n    }\n}\n\nlong long gauss(int n,int m){\n    long long ans = 0;\n    for(int i = 1; i <= n; i++){\n        int find = -1, findBit = -1;\n        for(int j = i; j <= n; j++){\n            int bit = -1;\n            for(int k = m; k >= 1; k--) if(b[j][k]) bit = k;\n            if(bit!=-1 && (find==-1 || bit<findBit)){\n                find = j;\n                findBit = bit;\n            }\n        }\n        //printf(\"i = %d, find = %d, findBit = %d\\n\",i,find,findBit);\n        if(find==-1){\n            //printf(\"i = %d\\n\",i);\n            int ok = 1;\n            for(int j = i; j <= n; j++) if(c[j]==1) ok = 0;\n            if(ok) ans = power(2,m-(i-1)); \n            else ans = 0;\n            break; \n        }\n        else{\n            swapRow(i,find,m);\n            for(int j = 1; j <= n; j++){\n                if(j!=i && b[j][findBit]!=0){\n                    for(int k = 1; k <= m; k++) b[j][k] ^= b[i][k];\n                    c[j] ^= c[i]; \n                }\n            }\n        }\n        if(i==n) ans = power(2,m-n);\n    }\n    return ans;\n}\n\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= m; j++){\n            scanf(\"%d\",&a[i][j]);\n            b[j][i] = a[i][j];\n        }\n    }\n    long long count0 = gauss(m,n);\n    //printf(\"count0 = %lld\\n\",count0);\n    long long count1 = power(2,n)-count0;\n    if(count1<0) count1 += mod;\n    long long ans = count1*power(2,m-1)%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T, T MOD>\nstruct ModType {\n    using Int = T;\n    static constexpr Int mod = MOD;\n    Int v;\n\n    ModType(long long _v = 0) : v(set(_v)) {}\n    ModType(const ModType &r) : v(set(r.v)) {}\n\n    inline static Int set(const Int x) { return x < 0 ? (x % mod) + mod : x % mod; }\n    inline void set() { v = set(v); }\n\n    bool operator<(ModType r) const { return v < r.v; }\n    bool operator>(ModType r) const { return r.v < v; }\n    bool operator==(ModType r) const { return v == r.v; }\n    bool operator!= (ModType r) const { return v != r.v; }\n\n    ModType operator-() const { return ModInt(v ? mod - v : v); }\n    ModType &operator=(const ModType &r) { if (this != &r) v = set(r.v); return *this; }\n    ModType &operator+=(ModType r) { (v += r.v) %= mod; return *this; }\n    ModType &operator-=(ModType r) { (v -= r.v - mod) %= mod; return *this; }\n    // ModType &operator*=(ModType r) { v = (__uint128_t(v) * r.v) % mod; return *this; }\n    ModType &operator*=(ModType r) { v = 1ULL * v * r.v % mod; return *this; }\n    ModType &operator/=(ModType r) { *this *= r.inv(); return *this; }\n    ModType operator+(ModType r) const { return ModType(*this) += r; }\n    ModType operator-(ModType r) const { return ModType(*this) -= r; }\n    ModType operator*(ModType r) const { return ModType(*this) *= r; }\n    ModType operator/(ModType r) const { return ModType(*this) /= r; }\n\n    ModType inv() const {\n        long long a = v, b = mod, u = 1, w = 0;\n        while (b) {\n            long long t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * w, w);\n        }\n        return ModType(u);\n    }\n\n    ModType pow(Int e) {\n        ModType a = *this, x(1);\n        for ( ; 0 < e; e >>= 1) { if (e & 1) x *= a; a *= a; }\n        return x;\n    }\n    inline ModType pow(ModType &e) { return pow(e.v); }\n\n    friend std::ostream &operator<<(std::ostream &os, const ModType &r) { return os << r.v; }\n    friend std::istream &operator>>(std::istream &is, ModType &r) {\n        is >> r.v; r.set();return is;\n    }\n\n    static std::vector<ModType> Inverse(const Int n = mod - 1) {\n        std::vector<ModType> inv(n + 1);\n        inv[1].v = 1;\n        for (Int a = 2; a <= n; ++a)\n            inv[a] = inv[mod % a] * T(mod - mod / a);\n        return inv;\n    }\n};\n\nusing ModInt = ModType<int, 1000000007>;\n\nusing Mod2 = ModType<int, 2>;\nusing Type = ModType<long long, 998244353>;\nusing Vector = vector<Mod2>;\nusing Matrix = vector<Vector>;\n\nint Rank(Matrix &A) {\n    const int N = A.size(), M = A[0].size();\n    int rank = 0;\n    vector<bool> used(N, false);\n\n    for (int c = 0; c < M; ++c) {\n        int pivot = 0;\n        while (pivot < N && (used[pivot] || A[pivot][c] == 0)) ++pivot;\n        if (pivot == N) continue;\n\n        ++rank;\n        used[pivot] = true;\n        Mod2 v = A[pivot][c];\n        for (int j = 0; j < M; ++j) A[pivot][j] /= v;\n        for (int r = 0; r < N; ++r) {\n            if (r == pivot) continue;\n            for (int j = c + 1; j < M; ++j)\n                A[r][j] -= A[r][c] * A[pivot][j];\n        }\n    }\n\n    return rank;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    Matrix A(n, Vector(m));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            cin >> A[i][j];\n\n    int rank = Rank(A);\n    Type res = Type(2).pow(m + n - 1) - Type(2).pow(m + n - rank - 1);\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(0);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(0);\n        for(; j < n; ++j)if(a[j][now])for(int k = 0; k < m; ++k)a[j][k] ^= a[i][k];\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int MAX=300; //max of width\nusing BS=bitset<MAX>;\nvector<BS> Gauss_Jordan(const vector<BS> &v){\n    int n=v.size();\n    vector<BS> ret=v;\n    int d=0;\n    for(int k=0; k<MAX; k++){\n        int p=-1;\n        for(int i=d; i<n; i++){\n            if(ret[i][k]){\n                p=i;\n                break;\n            }\n        }\n        if(p==-1) continue;\n        swap(ret[d], ret[p]);\n        for(int i=0; i<n; i++){\n            if(i==d) continue;\n            if(ret[i][k]) ret[i]^=ret[d];\n        }\n        d++;\n    }\n    return ret;\n}\nint matrix_rank(const vector<BS> &v){\n    int n=v.size();\n    vector<BS> ret=v;\n    int d=0;\n    for(int k=0; k<MAX; k++){\n        int p=-1;\n        for(int i=d; i<n; i++){\n            if(ret[i][k]){\n                p=i;\n                break;\n            }\n        }\n        if(p==-1) continue;\n        swap(ret[d], ret[p]);\n        for(int i=d+1; i<n; i++){\n            if(ret[i][k]) ret[i]^=ret[d];\n        }\n        d++;\n    }\n    return d;\n}\nconst ll MOD=998244353;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nint main()\n{\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    vector<BS> v(n, BS(0));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            int a; scanf(\"%d\", &a);\n            v[i][j]=a;\n        }\n    }\n    int r=matrix_rank(v);\n    printf(\"%lld\\n\", (powmod(2, m+n-1)-powmod(2, m+n-r-1)+MOD)%MOD);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ri register int\nconst int N=500005,M=998244353;\nint n,m,i,j,ans,vis[305];\nbitset<305> p[305],a[305];\nlong long qpow(long long a,long long b)\n{\n\tlong long s=a,ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*s%M;\n\t\ts=s*s%M;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\",&t);\n\t\t\ta[i][j-1]=t;\n\t\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=m-1;j>=0;--j)\n\t\t\tif(a[i][j])\n\t\t\t\tif(vis[j]==0)\n\t\t\t\t{\n\t\t\t\t\tp[j]=a[i];\n\t\t\t\t\tvis[j]=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ta[i]^=p[j];\n\t\tif(j<0)\n\t\t\tans++;\n\t}\n\tcout<<((qpow(2,n)-qpow(2,ans))*qpow(2,m-1)%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int p=998244353;\nint a[305][305],b[305][305];\nint read() {\n\tchar c=getchar(); int x=0,f=1;\n\twhile (c<'0' || c>'9') {\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint fpow(int x,int k) {\n\tint ans=1;\n\twhile (k) {\n\t\tif (k&1) ans=1LL*ans*x%p;\n\t\tx=1LL*x*x%p;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n=read(),m=read();\n\tfor (int i=1; i<=n; i++) {\n\t\tfor (int j=1; j<=m; j++) {\n\t\t\ta[i][j]=read();\n\t\t}\n\t}\n\tmemset(b,0,sizeof(b));\n\tfor (int i=1; i<=n; i++) {\n\t\tfor (int j=m; j>=1; j--) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tif (b[j][j]) for (int k=1; k<=m; k++) a[i][k]^=b[j][k];\n\t\t\t\telse {\n\t\t\t\t\tfor (int k=1; k<=m; k++) b[j][k]=a[i][k];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tfor (int j=1; j<=m; j++) if (b[j][j]) ++cnt;\n\tprintf(\"%d\\n\", ((fpow(2,n+m-1)-fpow(2,n+m-cnt-1))%p+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\n/*bool operator < (const vector<long long> &a,const vector<long long> &b){\n    bool ret=false;\n    DEBUG(\"called\");\n    for(long long i = 0; i < a.size(); i++){\n        if(a[i]>b[i]){\n            ret=false;\n            break;\n        }else if(a[i]<b[i]){\n            ret=true;\n            break;\n        }\n    }\n    return ret;\n}\n*/\nll cache_pow[600];\nll mpow(ll a){\n    static bool flag=false;\n    if(flag){\n        DEBUG(\"True\");\n        return cache_pow[a];\n    }else{\n        cache_pow[0]=1;\n        for(long long i = 1; i < 600; i++){\n            cache_pow[i]=(cache_pow[i-1]*2)%MOD;\n        }\n        flag=true;\n        return cache_pow[a];\n    }\n}\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    ll index=0;\n\n    vector<bitset<300>> A;\n    for(long long i = 0; i < a.size(); i++){\n        A.push_back(bitset<300>(0));\n        for(long long k = 0; k < a[i].size(); k++){\n            A[i][k]=(a[i][k]==1);\n        }\n    }\n    ll rank=0;\n    for(long long i = 0; i < N; i++){\n        DEBUG(i);\n        for(; index < M; index++){\n            DEBUG(index);\n            for(long long j = i; j < N; j++){\n                if(A[j][index]==1){\n                    if(j!=i)\n                        swap(A[j],A[i]);\n                    goto OUT;\n                }\n            }\n        }\n        OUT:\n        if(index==M){\n            break;\n        }\n        rank++;\n        for(long long j = i+1; j < N; j++){\n            if(A[j][index]==1){\n                A[j]^=A[i];\n            }\n        }\n    }\n    DEBUG(rank);\n    cout<<(mpow(M+N-1)-mpow(M+N-1-rank)+MOD)%MOD<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n,m,a[N][N],b[N][N];\nll qpow(ll a,ll n)\n{\n    ll ans=1;\n    while(n)\n    {\n        if(n&1) ans=ans*a%mod;\n        a=a*a%mod;\n        n>>=1;\n    }\n    return ans;\n}\nint guass(int n)\n{\n    int ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        int p=i;\n        while(p<=n&&!a[i][p]) p++;\n        if(p==n+1) {ans++;continue;}\n        swap(a[i],a[p]);\n        for(int j=i+1;j<=n;j++)\n            if(a[j][i])\n            for(int k=i;k<=n;k++)\n            a[j][k]^=a[i][k];\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        scanf(\"%d\",&a[i][j]);\n    int r=0;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        if(a[i][j])\n        {\n            if(b[j][j]) for(int k=j;k<=m;k++) a[i][k]^=b[j][k];\n            else\n            {\n                for(int k=j;k<=m;k++) b[j][k]=a[i][k];\n                r++;break;\n            }\n        }\n    printf(\"%lld\\n\",qpow(2,n-1)*(qpow(2,m)+mod-qpow(2,m-r))%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cout<<v[i][j]<<\" \";}cout<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nvii rotate(vii a) {\n  int h = a.size(), w = a[0].size();\n  vii b(w, vi(h));\n  rep (i, h) {\n    rep (j, w) {\n      b[j][i] = a[i][j];\n    }\n  }\n  return b;\n}\n\n\nconst int MAXN = 3010;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n\tfact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n\tfor (ll i = 2; i <= n; i++) {\n\t\tfact[i] = i * fact[i - 1] % M;\n\t\trfact[i] = mod_inverse(fact[i], M);\n\t}\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  ll ret = fact[n];\n  ret = (ret*rfact[r]) % M;\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\n\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n  vii a(h, vi(w));\n  rep (i, h) {\n    rep (j, w) {\n      cin >> a[i][j];\n    }\n  }\n  if (h < w) {\n    swap(h, w);\n    a = rotate(a);\n  }\n  set_fact(h + 100);\n  int no = 0;\n  rep (j, w) {\n    if (a[j][j] == 0) {\n      for (int i = j + 1; i < h; i++) {\n        if (a[i][j] == 1) {\n          swap(a[i], a[j]);\n          break;\n        }\n      }\n    }\n    if (a[j][j] == 0) {\n      no++;\n      continue;\n    }\n    for (int i = 0; i < h; i++) {\n      if (i == j) continue;\n      a[i][j] = 0;\n    }\n  }\n  for (int i = 0; i < w; i++) {\n    for (int j = i + 1; j < w; j++) {\n      a[i][j] = 0;\n    }\n  }\n  //DEBUG_MAT(a);\n  ll ans = 0;\n  //DEBUG(no);\n  int r = w - no;\n  for (int x = 1; x <= w - no; x += 2) {\n    ans += mod_pow(2, h + w - 2 * r) * nCr(r, x) % MOD * mod_pow(3, r - x) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod998 = 998244353;\nconst ll intmax = 2147483647;\nconst ll llmax = 9223372036854775807;\nconst char sp = ' ';\n\nint N, M;\nbitset<300>b[300];\nbool f[300];\n\nll pw(ll x, int y) {\n\tll a = 1;\n\twhile (y) {\n\t\tif (y & 1)a = a*x%mod998;\n\t\tx = x*x%mod998;\n\t\ty /= 2;\n\t}\n\treturn a;\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tb[i][j] = (c == '1' ? 1 : 0);\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (f[j])continue;\n\t\t\tif (b[j][i]) {\n\t\t\t\tf[j] = true;\n\t\t\t\tfor (int k = 0; k < M; k++) {\n\t\t\t\t\tif (!f[k] && b[k][i]) {\n\t\t\t\t\t\tb[k] ^= b[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!f[i])c++;\n\t}\n\tcout << (pw(2, N + M - 1) + mod998 - pw(2, c + M - 1)) % mod998 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\nll P = 998244353;\nll mpow(ll a, ll b, ll p = -1){\n  ll ret = 1, num = a;\n  if(p==-1){\n    while(b>0){\n      if(b%2) ret *= num;\n      num = num * num;\n      b /= 2;\n    }\n  }else{\n    while(b>0){\n      if(b%2) ret = (ret*num)%p;\n      num = (num*num)%p;\n      b /= 2;\n    }\n  }\n  return ret;\n}\n\nint main(int argc, char const *argv[]) {\n  // 2^n+m-1(全体の半分)\n  // 自由度xに対し\n  // ans = 2^(n-1+m) - 2^(n-1 + x)\n  ll n, m;std::cin >> n >> m;\n  ll x = 0;\n  vvl dat = VV(n, m, 0, ll);\n\n  for(int i=0;i<n;i++) for(int j=0;j<m;j++) scanf(\"%lld\", &dat[i][j]);\n\n  ll ok = -1;\n  for(int i=0;i<min(n, m);i++){\n    //i列目が1の行を探す\n    ll idx = -1;\n    for(int j=ok+1;j<n;j++){\n      if(dat[j][i]){\n        idx = j;\n        break;\n      }\n    }\n    if(idx==-1) continue;\n    swap(dat[ok+1], dat[idx]);\n    //ok+1が今、ok+2行目以降掃き出し\n    for(int j=ok+2;j<n;j++){\n      if(!dat[j][i]) continue;\n      for(int k=i;k<n;k++) dat[j][k] ^= dat[ok+1][k];\n    }\n    ok++;\n  }\n  for(int i=0;i<n;i++){\n    bool f = true;\n    for(int j=0;j<m;j++){\n      if(dat[i][j]) {\n        f = false;\n        break;\n      }\n    }\n    if(!f) x++;\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      std::cout << dat[i][j] << \" \";\n    }\n    std::cout << '\\n';\n  }\n  */\n  ll ans = (mpow(2, n-1+m, P) - mpow(2, n-1+m - x) +P)%P;\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <functional>\n#include <unordered_set>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <bitset>\n\nusing namespace std;\n\nconst int N = 2e5 + 10;\nconst long long INF = 1LL << 60;\n\nvoid xorVector(vector<char>& a, const vector<char>& b) {\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\ta[i] ^= b[i];\n\t}\n}\n\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\treturn a - MOD;\n\treturn a;\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector <vector<char>> v(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tv[i].resize(m);\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> v[i][j];\n\t\t\tv[i][j] = (v[i][j] == '1');\n\t\t}\n\t}\n\tint r = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint id = -1;\n\t\tfor (int j = r; j < n; ++j) {\n\t\t\tif (v[j][i] == 1) {\n\t\t\t\tid = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (id == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\t++r;\n\t\tv[i].swap(v[id]);\n\t\tfor (int j = r + 1; j < n; ++j) {\n\t\t\tif (v[j][i]) {\n\t\t\t\txorVector(v[j], v[r]);\n\t\t\t}\n\t\t}\n\t}\n\tint pw2 = 1;\n\tvector <int> pow2 = { 1 };\n\tfor (int i = 1; i <= n + m; ++i) {\n\t\tpw2 = add(pw2, pw2);\n\t\tpow2.push_back(pw2);\n\t}\n\tint ans = pow2[n + m - 1] - pow2[n + m - r - 1];\n\tif (ans < 0) {\n\t\tans += MOD;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 333, mod = 998244353;\nbitset<maxn> e[maxn];\nint power(int x){\n\tint v = 1;\n\tfor(int i = 0; i < x; i++){\n\t\tv *= 2;\n\t\tif(v >= mod) v -= mod;\n\t}\n\treturn v;\n}\nint main(){\n\tint n, m; cin >> n >> m; int rnk = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tbitset<maxn> now;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tint v; cin >> v;\n\t\t\tnow[j] = v == 1;\n\t\t}\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(e[j][j] && now[j]){\n\t\t\t\tnow ^= e[j];\n\t\t\t} else if(now[j]){\n\t\t\t\te[j] = now;\n\t\t\t\trnk++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = power(n + m - 1);\n\tans += mod - power(n + m - 1 - rnk);\n\tif(ans >= mod) ans -= mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst long long mod = 998244353;\nint a[301][301];\nint b[301][301];\nint c[301];\n\nlong long power(long long a,long long b){\n    long long res = 1;\n    while(b){\n        if(b&1) res = res*a%mod;\n        a = a*a%mod;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid swapRow(int i,int j,int m){\n    int t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n    for(int k = 1; k <= m; k++){\n        int t = b[i][k];\n        b[i][k] = b[j][k];\n        b[j][k] = t;\n    }\n}\n\nlong long gauss(int n,int m){\n    long long ans = 0;\n    for(int i = 1; i <= n; i++){\n        int find = -1, findBit = -1;\n        for(int j = i; j <= n; j++){\n            int bit = -1;\n            for(int k = m; k >= 1; k--) if(b[j][k]) bit = k;\n            if(bit!=-1 && (find==-1 || bit<findBit)){\n                find = j;\n                findBit = bit;\n            }\n        }\n        //printf(\"i = %d, find = %d, findBit = %d\\n\",i,find,findBit);\n        if(find==-1){\n            //printf(\"i = %d\\n\",i);\n            int ok = 1;\n            for(int j = i; j <= n; j++) if(c[j]==1) ok = 0;\n            if(ok) ans = power(2,m-(i-1)); \n            else ans = 0;\n            break; \n        }\n        else{\n            swapRow(i,find,m);\n            for(int j = 1; j <= n; j++){\n                if(j!=i && b[j][findBit]!=0){\n                    for(int k = 1; k <= m; k++) b[j][k] ^= b[i][k];\n                    c[j] ^= c[i]; \n                }\n            }\n        }\n        if(i==n) ans = 1;\n    }\n    return ans;\n}\n\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= m; j++){\n            scanf(\"%d\",&a[i][j]);\n            b[j][i] = a[i][j];\n        }\n    }\n    long long count0 = gauss(m,n);\n    //printf(\"count0 = %lld\\n\",count0);\n    long long count1 = power(2,n)-count0;\n    if(count1<0) count1 += mod;\n    long long ans = count1*power(2,m-1)%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define rollcall cout << \"I'm Sucu.\" << endl;\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define fi first\n#define se second\n// debug\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p){\n  os << \"(\" << p.first << \",\" << p.second << \")\";return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v){\n  for (auto it = v.begin();it != v.end();++it){\n    if(it != v.begin())os << \" \";os << *it;\n      }return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp){\n  for(auto x: mp)os << \"(\" << x.first << \",\" << x.second << \")\" << endl;\n  return os;\n}\ntemplate<typename T, int SIZE>\nint array_length(const T (&)[SIZE]){return SIZE;}\ntemplate<typename T, int N>\nvoid PRINTF(const T (&a)[N], int s = N, int t = -1, bool f = true){\n\tif(t == -1){rep(i,s){if(i)cout << \" \";cout << a[i];}}\n\telse repi(i,s,t){if(i!=s)cout << \" \";cout << a[i];}\n\tif(f)cout << \"\\n\";\n}\ntemplate<typename T, int N1, int N2>\nvoid PRINTF(const T (&a)[N1][N2], int h = N1, int w = N2){\n\trep(i,h){rep(j,w){cout << a[i][j] << \" \\n\"[j==w-1];}}\n}\nstring substr(const string &str, int S1, int S2 = -1){\n  if(S2 == -1)return str.substr(S1);\n  return str.substr(S1, S2-S1);\n}\n// typedef\ntypedef complex<double> Point;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nconst int mod = 998244353;\n\nvector<int> mat[400];\nvoid XOR(vi &A, vi &B){\n  int n = A.size();\n  rep(i,n)A[i] ^= B[i];\n}\n\nint Pow(int x, int n){\n  if(n < 0)n += mod-1;\n  int ans = 1;\n  while(n > 0){\n    if(n & 1)ans = (ans*x)%mod;\n    x = (x*x)%mod;\n    n >>= 1;\n  }\n  return ans;\n}\n\nint calc_rank(int h, int w){\n  int r = 0;\n  rep(j,w){\n    int pivot = -1;\n    rep(i,h)if(mat[i][j]){\n      pivot = i;break;\n    }\n    if(pivot == -1)continue;\n    swap(mat[pivot], mat[r]);\n    rep(i,h)if(i != r){\n      if(mat[i][j])XOR(mat[i], mat[r]);\n    }\n    r++;\n    if(r >= h)break;\n  }\n  return r;\n}\n\nsigned main(){\n  int h, w;\n  scanf(\"%lld%lld\", &h, &w);\n  rep(i,h)rep(j,w){\n    int tmp;scanf(\"%lld\", &tmp);\n    mat[i].pb(tmp);\n  }\n  int r = calc_rank(h, w);\n  int ans = mod+Pow(2, h)-Pow(2, h-r);\n  ans = (ans%mod)*Pow(2, w-1);\n  printf(\"%lld\\n\", ans%mod);\n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n\n#define cMOD 998244353ULL\n#define cINF ((1ull<<62)-1)\n#define cINFINT ((1<<30)-1)\n\n\ntemplate <typename T>\nvoid calcFactional_mod( size_t size, \n\tvector<T>& fac, vector<T>& inv, vector<T>& facInv, T mod )\n{\n\tfor( T i = 2; i < size; ++i )\n\t{\n\t\tfac[i] = fac[i - 1] * i % mod; // n! % mod\n\t\tinv[i] = mod - inv[mod % i] * ( mod / i ) % mod; // 逆元計算 (n)^-1 % mod\n\t\tfacInv[i] = facInv[i - 1] * inv[i] % mod; // (n!)^-1 % mod\n\t}\n}\ntemplate <typename T>\nT pow_mod(T x, T n, T mod)\n{\n\tT res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (res * x) % mod;\n\t\tx = (x * x) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\ntemplate< typename T >\nclass Matrix\n{\npublic:\n\texplicit Matrix( size_t row_size, size_t col_size )\n\t{\n\t\tassign( row_size, col_size );\n\t}\n\n\tvoid assign( size_t row_size, size_t col_size )\n\t{\n\t\tmElement.assign( row_size, vector<T>() );\n\t\tREP( i, row_size ) mElement[i].assign( col_size, T(0) );\n\t}\n\n\tconst vector<T>& operator[] ( size_t row ) const\n\t{ return mElement[row]; }\n\tvector<T>& operator[] ( size_t row )\n\t{ return mElement[row]; }\n\n\tconst size_t rowSize() const\n\t{ return mElement.size(); }\n\tconst size_t colSize() const\n\t{ return mElement[0].size(); }\n\n\t/*T get( size_t row, size_t col ) const\n\t{ return mElement[row][col]; }\n\tvoid set( size_t row, size_t col, T value )\n\t{ mElement[row][col] = value; }*/\n\n\tMatrix<T> operator* ( const Matrix& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.rowSize() );\n\t\tMatrix ret( this->rowSize(), rhs.colSize() );\n\t\tREP( i, ret.rowSize() )\n\t\tREP( k, k_ )\n\t\tREP( j, ret.colSize() )\n\t\t\tret[i][j] = ret[i][j] + (*this)[i][k] * rhs[k][j];\n\t\treturn ret;\n\t}\n\n\tvector<T> operator* ( const vector<T>& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.size() );\n\t\tvector<T> ret( this->rowSize(), T() );\n\t\tREP( i, ret.size() )\n\t\tREP( k, k_ )\n\t\t\tret[i] = ret[i] + (*this)[i][k] * rhs[k];\n\t\treturn ret;\n\t}\n\n\t// O( N^3 )\n\t// Ax = b を解く\n\t// T = double にしないと割り算で狂うので注意\n\tstruct GaussJordanData\n\t{\n\t\tint rank = 0;\n\t\tint result = 0; // -1:解なし 0:不定 1:解あり\n\t\tvector<T> solution;\n\t};\n\tGaussJordanData gaussJordan() const\n\t{\n\t\tvector<T> b( rowSize(), 0 );\n\t\treturn gaussJordan( b );\n\t}\n\tGaussJordanData gaussJordan( const vector<T>& b ) const\n\t{\n\t\tGaussJordanData data;\n\t\tdata.result = 1;\n\n\t\t// 1列余分に取って、そこにbを入れる\n\t\tMatrix<T> B( rowSize(), colSize() + 1 );\n\t\tREP( i, rowSize() ) REP( j, colSize() + 1 )\n\t\t{\n\t\t\tif( j < colSize() ) B[i][j] = (*this)[i][j];\n\t\t\telse B[i][j] = b[i];\n\t\t}\n\n\t\tfor( int i = 0, j = 0; i < rowSize() && j < colSize(); ++i, ++j )\n\t\t{\n\t\t\t// j列目の値の絶対値が大きい行をi行目に持ってくる\n\t\t\tsize_t pivot = i;\n\t\t\tfor( int k = i + 1; k < rowSize(); ++k )\n\t\t\t\tif( abs( B[k][j] )> abs( B[pivot][j] ) ) pivot = k;\n\t\t\tswap( B[i], B[pivot] );\n\t\t\t// 解が一意でない\n\t\t\tif( abs( B[i][j] ) <= numeric_limits<T>::epsilon() )\n\t\t\t{\n\t\t\t\t--i;\n\t\t\t\tdata.result = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Rankを1増やす\n\t\t\t++data.rank;\n\t\t\t// [i][j]を1にするようにi行目を割る\n\t\t\tfor( int l = j + 1; l <= colSize(); ++l )\n\t\t\t\tB[i][l] /= B[i][j];\n\t\t\tB[i][j] = 1;\n\t\t\t// k番目の行からi番目の行を引いて、j番目の列の数を消去\n\t\t\tREP( k, rowSize() ) if( k != i )\n\t\t\t{\n\t\t\t\tT coef = B[k][j];\n\t\t\t\tfor( int l = j; l <= colSize(); ++l )\n\t\t\t\t\tB[k][l] -= coef * B[i][l];\n\t\t\t}\n\t\t}\n\n\t\t// 解xを作る\n\t\tdata.solution.assign( colSize(), T() );\n\t\tfor( int i = 0, j = 0; j < colSize(); ++i, ++j )\n\t\t{\n\t\t\tif( i >= rowSize() || B[i][j] == 0 )\n\t\t\t{\n\t\t\t\tdata.solution[j] = 0;\n\t\t\t\t--i; continue;\n\t\t\t}\n\t\t\telse data.solution[j] = *( B[i].rbegin() );\n\t\t}\n\n\t\t// 解なしかをチェック\n\t\tif( data.result == 0 || ( data.rank ) < b.size() )\n\t\t{\n\t\t\tauto m = ( *this ) * data.solution;\n\t\t\tREP( i, m.size() ) if( m[i] != b[i] )\n\t\t\t{ data.result = -1; break; }\n\t\t}\n\t\tif( data.result != -1 )\n\t\t{\n\t\t\t// 解が一意\n\t\t\tif( data.rank == colSize() ) data.result = 1;\n\t\t\t// 解が不定\n\t\t\telse data.result = 0;\n\t\t}\n\t\t\n\t\treturn data;\n\t}\n\nprotected:\n\tvector<vector<T>> mElement;\n};\n\n\nint main()\n{\n\tauto mod = cMOD;\n\tauto add = [mod]      ( ll a, ll b ) { return ( a + b ) % mod; };\n\tauto sub = [mod]      ( ll a, ll b ) { return ( a + mod -b ) % mod; };\n\tauto mul = [mod]      ( ll a, ll b ) { return a * b % mod; };\n\tauto pow = [mod]      ( ll a, ll b ) { return pow_mod<ll>( a, b, mod ); };\n\t\n\tll n, m; cin >> n >> m;\n\tMatrix<double> mtx( n, m );\n\tREP( i, n ) REP( j, m ) cin >> mtx[i][j];\n\t\n\tauto data = mtx.gaussJordan();\n\tauto ans = sub( pow( 2, n + m - 1 ), pow( 2, n + m - data.rank - 1 ) );\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000000\n#define infll 1000000000000000000ll\n#define vi vector<int>\n#define vll vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define mpr make_pair\n#define fi first\n#define se second\n#define pq priority_queue<int>\n#define pqll priority_queue<ll>\n#define up(x,y) (x<(y)?x=(y):0)\n#define dn(x,y) (x>(y)?x=(y):0)\n#define ad(x,y) (x=(x+(y))%mod)\n#define mod 998244353\n#define N 309\nusing namespace std;\n\nint m,n,b[N]; bitset<N> a[N];\nint read(){\n\tint x=0; char ch=getchar(); bool flag=0;\n\twhile (ch<'0' || ch>'9'){ if (ch=='-') flag=1; ch=getchar(); }\n\twhile (ch>='0' && ch<='9'){ x=x*10+ch-'0'; ch=getchar(); }\n\treturn flag?-x:x;\n}\nll readll(){\n\tll x=0; char ch=getchar(); bool flag=0;\n\twhile (ch<'0' || ch>'9'){ if (ch=='-') flag=1; ch=getchar(); }\n\twhile (ch>='0' && ch<='9'){ x=x*10+ch-'0'; ch=getchar(); }\n\treturn flag?-x:x;\n}\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (; y; y>>=1,x=(ll)x*x%mod) if (y&1) ans=(ll)ans*x%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\tint i,j,cnt=0;\n\tfor (i=1; i<=m; i++)\n\t\tfor (j=0; j<n; j++) a[i][j]=(read()>0);\n\tfor (i=1; i<=m; i++){\n\t\tfor (j=0; j<n; j++) if (a[i][j])\n\t\t\tif (b[j]) a[i]^=a[b[j]]; else{\n\t\t\t\tb[j]=i; cnt++; break;\n\t\t\t}\n\t}\n\tint t=(ksm(2,m)-ksm(2,m-cnt)+mod)%mod;\n\tprintf(\"%lld\\n\",(ll)t*ksm(2,n-1)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 998244353;\n\ntemplate <int mod>\nstruct modint {\n    lint v;\n    modint() : v(0) {}\n    modint(signed v) : v(v) {}\n    modint(lint t) {\n        v = t % mod;\n        if (v < 0)\n            v += mod;\n    }\n\n    modint pow(lint k) {\n        modint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n    static modint add_identity() { return modint(0); }\n    static modint mul_identity() { return modint(1); }\n    modint inv() { return pow(mod - 2); }\n\n    modint &operator+=(modint a) {\n        v += a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator-=(modint a) {\n        v += mod - a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator*=(modint a) {\n        v = v * a.v % mod;\n        return *this;\n    }\n    modint &operator/=(modint a) { return (*this) *= a.inv(); }\n\n    modint operator+(modint a) const { return modint(v) += a; };\n    modint operator-(modint a) const { return modint(v) -= a; };\n    modint operator*(modint a) const { return modint(v) *= a; };\n    modint operator/(modint a) const { return modint(v) /= a; };\n\n    modint operator-() const { return v ? modint(mod - v) : modint(v); }\n\n    bool operator==(const modint a) const { return v == a.v; }\n    bool operator!=(const modint a) const { return v != a.v; }\n    bool operator<(const modint a) const { return v < a.v; }\n};\nusing mint = modint<mod>;\nostream &operator<<(ostream &os, mint m) { return os << m.v; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> a(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> a[i][j];\n        }\n    }\n    vector<bool> used(n, false);\n    int rank = 0;\n    for (int i = 0; i < m; ++i) {\n        int idx = -1;\n        for (int j = 0; j < n; ++j) {\n            if (!used[j] && a[j][i] == 1) {\n                idx     = j;\n                used[j] = true;\n                break;\n            }\n        }\n        if (idx == -1)\n            continue;\n        for (int j = 0; j < n; ++j) {\n            if (j != idx && a[j][i] == 1) {\n                for (int k = i; k < m; ++k) {\n                    a[j][k] ^= a[idx][k];\n                }\n            }\n        }\n        rank++;\n    }\n    mint ret = mint(2).pow(n + m - rank - 1) * (mint(2).pow(rank) - 1);\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *    \n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)((x).size()))\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(abs(x))\n#define y0 y2342\n#define y1 y2343\n#define mset(a,v) memset(a, v, sizeof(a))\n#define mcpy(a,b) memcpy(a, b, sizeof(a))\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\n\ntemplate<class T> T abs(T x) { return x > 0 ? x : -x; }\n\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nconst ll mod = 998244353;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\nconst int md = (int)998244353;\nint N,M;\nconst int maxn = 305;\nbitset<maxn> a[maxn],basis[maxn];\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % md);\n}\ninline int power(int a, long long b) { // a^b mod md\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\nint main(void){\n    \n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> N >> M;\n    int x;\n    for(int i=1;i<=N;i++){\n    \tfor(int j=1;j<=M;j++){\n    \t\tcin >> x;\n    \t\ta[i][j] = x;\n    \t}\n    }\n    int r = 0;\n    for(int i=1;i<=N;i++){\n    \tbitset<maxn> v = a[i];\n    \tfor(int j=1;j<=M;j++){\n    \t\tif (v[j]){\n    \t\t\tif(basis[j]==0){\n\t    \t\t\tbasis[j] = v;\n\t    \t\t\tr++;\n\t    \t\t\tbreak;\n\t    \t\t}\n\t    \t\tv ^= basis[j];\n    \t\t}\n    \t\t\n    \t}\n    }\n    int ans = power(2,N+M-1);\n    sub(ans,power(2,N+M-1-r));\n    cout << ans << endl;\n    //cerr << \"time = \" << clock()*1.0/CLOCKS_PER_SEC << \" s\" << endl;\n    return 0;\n}\n\n/*\ng++ -W -O2 -std=c++14\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\n// template <typename T>\n// std::size_t Rank(Matrix<T> mat)\n// {\n//     std::size_t r = 0;\n//     for (std::size_t c = 0; c < mat.C; c++) {\n//         if (r == mat.R) { return r; }\n//         std::size_t piv = r;\n//         for (; piv < mat.R and mat[piv][c] == 0; piv++) {}\n//         if (piv == mat.R) { continue; }\n//         std::swap(mat[r], mat[piv]);\n//         const T p = mat[r][c];\n//         for (std::size_t i = r; i < mat.R; i++) { mat[i][c] /= p; }\n//         for (std::size_t j = 0; j < mat.C; j++) {\n//             if (j == c) { continue; }\n//             const T p = mat[r][j];\n//             for (std::size_t i = 0; i < mat.R; i++) { mat[i][j] -= p * mat[i][c]; }\n//         }\n//         r++;\n//     }\n//     return r;\n// }\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t r = 0;\n    for (std::size_t c = 0; c < mat.C; c++) {\n        if (r == mat.R) { return r; }\n        std::size_t piv = r;\n        for (; piv < mat.R and mat[piv][c] == 0; piv++) {}\n        if (piv == mat.R) { continue; }\n        std::swap(mat[piv], mat[r]);\n        for (std::size_t j = c + 1; j < mat.C; j++) { mat[r][j] /= mat[r][c]; }\n        for (std::size_t j = r + 1; j < mat.R; j++) {\n            for (std::size_t k = c + 1; k < mat.C; k++) { mat[j][k] -= mat[r][k] * mat[j][c]; }\n        }\n        r++;\n    }\n    return r;\n}\nusing ll = long long;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T MOD() { return 1000000007; }\ntemplate <typename T, T mod = MOD<T>()>\nclass ModInt\n{\nprivate:\n    T value;\n    static T pow(const T p, const T n) { return p < 0 ? pow(mod + p, n) : n == 0 ? 1 : n % 2 == 1 ? pow(p, n - 1) * p % mod : pow(p * p % mod, n / 2); }\n    static T inv(const T p) { return pow(p, mod - 2); }\n\npublic:\n    ModInt() : value{0} {}\n    ModInt(const T val) : value{((val % mod) + mod) % mod} {}\n    ModInt(const ModInt<T, mod>& n) : value{n()} {}\n    ModInt<T, mod>& operator=(const ModInt<T, mod>& n) { return value = n(), (*this); }\n    ModInt<T, mod>& operator=(const T v) { return value = (mod + v % mod) % mod, (*this); }\n    ModInt<T, mod> operator+() const { return *this; }\n    ModInt<T, mod> operator-() const { return ModInt{mod - value}; }\n    ModInt<T, mod> operator+(const ModInt<T, mod>& val) const { return ModInt{value + val()}; }\n    ModInt<T, mod> operator-(const ModInt<T, mod>& val) const { return ModInt{value - val() + mod}; }\n    ModInt<T, mod> operator*(const ModInt<T, mod>& val) const { return ModInt{value * val()}; }\n    ModInt<T, mod> operator/(const ModInt<T, mod>& val) const { return ModInt{value * inv(val())}; }\n    ModInt<T, mod>& operator+=(const ModInt<T, mod>& val) { return (((value += val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const ModInt<T, mod>& val) { return (((value -= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const ModInt<T, mod>& val) { return (((value *= val()) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const ModInt<T, mod>& val) { return (((value *= inv(val())) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod> operator+(const T val) const { return ModInt{value + val}; }\n    ModInt<T, mod> operator-(const T val) const { return ModInt{value - val}; }\n    ModInt<T, mod> operator*(const T val) const { return ModInt{value * val}; }\n    ModInt<T, mod> operator/(const T val) const { return ModInt{value * inv(val)}; }\n    ModInt<T, mod>& operator+=(const T val) { return (((value += val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator-=(const T val) { return (((value -= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator*=(const T val) { return (((value *= val) %= mod) += mod) %= mod, (*this); }\n    ModInt<T, mod>& operator/=(const T val) { return (((value *= inv(val)) %= mod) += mod) %= mod, (*this); }\n    bool operator==(const ModInt<T, mod>& val) const { return value == val.value; }\n    bool operator!=(const ModInt<T, mod>& val) const { return not(*this == val); }\n    bool operator==(const T val) const { return value == (mod + val % mod) % mod; }\n    bool operator!=(const T val) const { return not(*this == val); }\n    T operator()() const { return value; }\n};\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator+(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator-(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{-n() + val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator*(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>{n() * val}; }\ntemplate <typename T, T mod>\ninline ModInt<T, mod> operator/(const T val, const ModInt<T, mod>& n) { return ModInt<T, mod>(val) / n; }\ntemplate <typename T, T mod>\ninline bool operator==(const T val, const ModInt<T, mod>& n) { return n == val; }\ntemplate <typename T, T mod>\ninline bool operator!=(const T val, const ModInt<T, mod>& n) { return not(val == n); }\ntemplate <typename T, T mod>\ninline std::istream& operator>>(std::istream& is, ModInt<T, mod>& n)\n{\n    T v;\n    return is >> v, n = v, is;\n}\ntemplate <typename T, T mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<T, mod>& n) { return (os << n()); }\nusing mint = ModInt<int, MOD<int>()>;\nusing mll = ModInt<ll, MOD<ll>()>;\nconstexpr int MOD2 = 998244353;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<ModInt<int, 2>> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<int> bp(600, 1);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2 % MOD2; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD2) % MOD2 << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//const ll mod = 1000000007;\nconst ll mod998 = 998244353;\nconst ll intmax = 2147483647;\nconst ll llmax = 9223372036854775807;\nconst char sp = ' ';\n\nint N, M;\nbitset<300>b[300];\nbool f[300];\n\nll pw(ll x, int y) {\n\tll a = 1;\n\twhile (y) {\n\t\tif (y & 1)a = a*x%mod998;\n\t\tx = x*x%mod998;\n\t\ty /= 2;\n\t}\n\treturn a;\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tbool a;\n\t\t\tcin >> a;\n\t\t\tb[i][j] = a;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (f[j])continue;\n\t\t\tif (b[j][i]) {\n\t\t\t\tf[j] = true;\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (!f[k] && b[k][i]) {\n\t\t\t\t\t\tb[k] ^= b[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!f[i])c++;\n\t}\n\tcout << (pw(2, N + M - 1) + mod998 - pw(2, c + M - 1)) % mod998 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconstexpr double eps = 1e-9;\nusing matrix = vector<vector<int>>;\n\nusing ll = long long;\nconstexpr ll mod = 998244353;\n\ntemplate <typename T>\nT mypow(T a, T b) {\n  if (b == 0) return 1;\n  T tmp = mypow(a, b / 2);\n  if (b % 2)\n    return (((tmp * tmp) % mod) * a) % mod;\n  else\n    return (tmp * tmp) % mod;\n}\n\nint main() {\n  ll n, m;\n  cin >> n >> m;\n  matrix a(n, vector<int>(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> a[i][j];\n    }\n  }\n\n  int rank = 0;\n  for (int j = 0; j < m; j++) {\n    int pivot = -1;\n    for (int i = rank; i < n; i++) {\n      if (a[i][j]) {\n        pivot = i;\n        break;\n      }\n    }\n    if (pivot >= 0) {\n      if (pivot != rank)\n        for (int k = 0; k < m; k++) swap(a[pivot][k], a[rank][k]);\n      for (int i = rank + 1; i < n; i++) {\n        if (a[i][j])\n          for (int k = 0; k < m; k++) a[i][k] ^= a[rank][k];\n      }\n      rank++;\n    }\n  }\n\n  ll ret = mypow(2LL, n + m - 1) + mod - mypow(2LL, n + m - rank - 1);\n  cout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 305;\nconst int MOD = 998244353;\nbitset<N> a[N]; \nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile(k) {\n\t\tif(k&1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD; \n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = m-1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t) a[i].flip(j);\n\t\t}\n\t}\n\t//cout << (a[0]^a[1]) << endl;\n \tfor (int i = 0; i < n; i++) {\n \t\tfor (bitset<N> b : base) {\n \t\t\tbitset<N> bb = b^a[i];\n \t\t\tfor (int j = m-1; j >= 0; j--) {\n \t\t\t\tif(bb[j] < a[i][j]) {\n \t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t }\n\t\t\t}\n\t\t }\t\n\t\t if(a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", ((q_pow(2, n+m-1) - q_pow(2, n+m-1-cnt)) % MOD+ MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass F2{\n\tbool x;\npublic:\n\tF2():x(false){}\n\tF2(long long n){ assert(n==0||n==1); x=(n==1); }\n\tF2& operator+=(const F2& a){ x=(x!=a.x); return *this; }\n\tF2& operator-=(const F2& a){ return (*this)+=a; }\n\tF2& operator*=(const F2& a){ x=(x&&a.x); return *this; }\n\tF2& operator/=(const F2& a){ assert(a.x); return *this; }\n\tF2 operator+(const F2& a)const{ return F2(*this)+=a; }\n\tF2 operator-(const F2& a)const{ return F2(*this)-=a; }\n\tF2 operator*(const F2& a)const{ return F2(*this)*=a; }\n\tF2 operator/(const F2& a)const{ return F2(*this)/=a; }\n\tbool operator==(const F2& a)const{ return x==a.x; }\n\tbool operator!=(const F2& a)const{ return !((*this)==a); }\n\tint to_int()const{ return x; }\n};\n\ntemplate<class R>\nclass matrix{\n\tvector<vector<R>> a;\npublic:\n\tmatrix(int n):a(n,vector<R>(n)){}\n\tmatrix(int m,int n):a(m,vector<R>(n)){}\n\n\tmatrix& operator+=(const matrix& A){\n\t\tassert(h()==A.h() && w()==A.w());\n\t\tint m=h(),n=w();\n\t\trep(i,m) rep(j,n) (*this)[i][j]+=A[i][j];\n\t\treturn *this;\n\t}\n\tmatrix& operator-=(const matrix& A){\n\t\tassert(h()==A.h() && w()==A.w());\n\t\tint m=h(),n=w();\n\t\trep(i,m) rep(j,n) (*this)[i][j]-=A[i][j];\n\t\treturn *this;\n\t}\n\tmatrix& operator*=(const matrix& A){\n\t\tassert(w()==A.h());\n\t\tint m=h(),n=w(),l=A.w();\n\t\tmatrix B(m,l);\n\t\trep(i,m) rep(j,l) rep(k,n) B[i][j]+=(*this)[i][k]*A[k][j];\n\t\tswap(*this,B);\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix& A)const{ return matrix(*this)+=A; }\n\tmatrix operator-(const matrix& A)const{ return matrix(*this)-=A; }\n\tmatrix operator*(const matrix& A)const{ return matrix(*this)*=A; }\n\tconst vector<R>& operator[](int i)const{ return a[i]; }\n\tvector<R>& operator[](int i){ return a[i]; }\n\n\tvector<R> operator*(const vector<R>& v)const{\n\t\tassert(w()==v.size());\n\t\tint m=h(),n=w();\n\t\tvector<R> res(m);\n\t\trep(i,m) rep(j,n) res[i]+=(*this)[i][j]*v[j];\n\t\treturn res;\n\t}\n\n\tint h()const{ return a.size(); }\n\tint w()const{ return a.empty()?0:a[0].size(); }\n\n\tstatic matrix identity(int n){\n\t\tmatrix I(n);\n\t\trep(i,n) I[i][i]=R{1};\n\t\treturn I;\n\t}\n};\n\nint matrix_rank(matrix<F2> A){\n\tint m=A.h(),n=A.w(),r=0;\n\trep(j,n){\n\t\tint piv;\n\t\tfor(piv=r;piv<m;piv++) if(A[piv][j]==1) break;\n\t\tif(piv==m) continue;\n\t\tif(piv!=r){\n\t\t\trep(k,n) swap(A[piv][k],A[r][k]);\n\t\t}\n\t\tfor(int i=r+1;i<m;i++) if(A[i][j]==1) {\n\t\t\tfor(int k=j;k<n;k++) A[i][k]-=A[r][k];\n\t\t}\n\t\tr++;\n\t}\n\treturn r;\n}\n\nclass mint{\n\tstatic const int MOD=998244353;\n\tint x;\npublic:\n\tmint():x(0){}\n\tmint(long long y){ x=y%MOD; if(x<0) x+=MOD; }\n\n\tmint& operator+=(const mint& m){ x+=m.x; if(x>=MOD) x-=MOD; return *this; }\n\tmint& operator-=(const mint& m){ x-=m.x; if(x<   0) x+=MOD; return *this; }\n\tmint& operator*=(const mint& m){ x=1LL*x*m.x%MOD; return *this; }\n\tmint& operator/=(const mint& m){ return *this*=inverse(m); }\n\tmint operator+(const mint& m)const{ return mint(*this)+=m; }\n\tmint operator-(const mint& m)const{ return mint(*this)-=m; }\n\tmint operator*(const mint& m)const{ return mint(*this)*=m; }\n\tmint operator/(const mint& m)const{ return mint(*this)/=m; }\n\tmint operator-()const{ return mint(-x); }\n\n\tfriend mint inverse(const mint& m){\n\t\tint a=m.x,b=MOD,u=1,v=0;\n\t\twhile(b>0){ int t=a/b; a-=t*b; swap(a,b); u-=t*v; swap(u,v); }\n\t\treturn u;\n\t}\n\n\tfriend istream& operator>>(istream& is,mint& m){ long long t; is>>t; m=mint(t); return is; }\n\tfriend ostream& operator<<(ostream& os,const mint& m){ return os<<m.x; }\n\tint to_int()const{ return x; }\n};\n\nmint operator+(long long y,const mint& m){ return m+y; }\nmint operator*(long long y,const mint& m){ return m*y; }\n\nmint pow(mint m,long long k){\n\tmint res=1;\n\tfor(;k>0;k>>=1,m*=m) if(k&1) res*=m;\n\treturn res;\n}\n\nint main(){\n\tint m,n; scanf(\"%d%d\",&m,&n);\n\tmatrix<F2> A(m,n);\n\trep(i,m) rep(j,n) { int a; scanf(\"%d\",&a); A[i][j]=a; }\n\n\tcout<<pow(mint(2),m+n-1)-pow(mint(2),m+n-matrix_rank(A)-1)<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#define MAXN 305\n#define P 998244353\n#define INF 0x3f3f3f3f\n#define rint register int\n#define LL long long\n#define LD long double\nusing namespace std;\n\nint n, m, siz, a[MAXN][MAXN], bas[MAXN][MAXN], temp[MAXN], vis[MAXN];\n\nint ksm(int x, int y)\n{\n    int ans=1;\n    while(y)\n    {\n        if(y&1) ans=1LL*ans*x%P;\n        x=1LL*x*x%P; y>>=1;\n    }\n    return ans;\n}\n\nvoid insert(int a[])\n{\n    memcpy(temp, a, sizeof(temp));\n    for(rint i=1; i<=m; ++i)\n        if(temp[i])\n        {\n            if(!vis[i])\n            {\n                for(rint j=1; j<=n; ++j) bas[i][j]=temp[j];\n                vis[i]=1;\n                siz++;\n                break;\n            }\n            for(rint j=1; j<=n; ++j) temp[j]^=bas[i][j];\n        }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for(rint i=1; i<=n; ++i)\n        for(rint j=1; j<=m; ++j) scanf(\"%d\", &a[i][j]);\n    for(rint i=1; i<=n; ++i) insert(a[i]);\n    printf(\"%d\\n\", 1LL*(ksm(2, n)-ksm(2, n-siz))*ksm(2, m-1)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=310;\nconst int mod=998244353;\nbitset<MAXN>a[MAXN],b[MAXN];\nint n,m,x,ans;\nlong long poww(long long x,long long y)\n{\n\tlong long ans=1;\n\tfor (;y;y>>=1,x=(x*x)%mod) if (y&1) ans=(ans*x)%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\tfor (int j=1;j<=m;j++) \n\t{\n\t\tscanf(\"%d\",&x);\n\t\tif (x==1) a[i].set(j);\n\t}\n\t}\n    for (int i=1;i<=n;i++)\n    {\n    \tfor (int j=1;j<=m;j++) \n    \t\tif (!b[j].any()) {\n    \t\t\tb[j]=a[i]; break;\n    \t\t}\n    \t\telse a[i]^=b[j];\n    }\n    for (int i=1;i<=max(n,m);i++) if (b[i].any()) ans++;\n    cout << (poww(2,n)-poww(2,n-ans)+mod)%mod*poww(2,m-1)%mod << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\ntypedef long long LL;\ntemplate <typename F, typename S> std::ostream& operator<<(ostream& os, const pair<F,S>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\"; for(const T& a: v){ os << a << \", \"; } os << \"]\"; return os; }\ntemplate <typename K, typename V> ostream& operator<<(ostream& os, const map<K,V>& m) {\n    os << \"{\"; for(const auto& p: m){ os << p.first <<\":\"<< p.second << \", \"; } os << \"]\"; return os; }\n\nconst LL MOD=998244353;\nLL pow2(LL base, LL cnt){\n    for(LL i = 0; i < cnt; ++i){\n        base = (base*2) % MOD;\n    }\n    return base;\n}\n\nint main(){\n    LL n, m;\n    cin >> n >> m;\n    vector<vector<LL>> a(n, vector<LL>(m, 0));\n    for(LL i = 0; i < n; ++i){\n        for(LL j = 0; j < m; ++j){\n            cin >> a[i][j];\n        }\n    }\n    sort(a.begin(), a.end(), greater<vector<LL>>());\n    LL cnt = 0;\n    for(LL i = 0; i < n; ++i){\n        if(accumulate(a[i].begin(), a[i].end(), 0) == 0){\n            cnt += 1;\n        }else{\n            LL one_pos = 0;\n            for(LL k = 0; k < m; ++k){\n                if(a[i][k] == 1){\n                    one_pos = k;\n                    break;\n                }\n            }\n            for(LL j = i+1; j < n; ++j){\n                if(a[j][one_pos] == 0) continue;\n                for(LL k = 0; k < m; ++k){\n                    a[j][k] = (a[j][k] + a[i][k]) % 2;\n                }\n            }\n        }\n    }\n\n    cerr << \"cnt=\" << cnt << endl;\n    LL base = pow2(1, m+n-1);\n    LL part = pow2(1, m+cnt-1);\n    LL ans = (base + MOD - part) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#define MAXN 305\n#define P 998244353\n#define INF 0x3f3f3f3f\n#define rint register int\n#define LL long long\n#define LD long double\nusing namespace std;\n\nint n, m, siz, a[MAXN][MAXN], bas[MAXN][MAXN], temp[MAXN], vis[MAXN];\n\nint ksm(int x, int y)\n{\n    int ans=1;\n    while(y)\n    {\n        if(y&1) ans=1LL*ans*x%P;\n        x=1LL*x*x%P; y>>=1;\n    }\n    return ans;\n}\n\nvoid insert(int a[])\n{\n    memcpy(temp, a, sizeof(temp));\n    for(rint i=1; i<=m; ++i)\n        if(temp[i])\n        {\n            if(!vis[i])\n            {\n                for(rint j=1; j<=n; ++j) bas[i][j]=temp[j];\n                vis[i]=1;\n                siz++;\n                break;\n            }\n            for(rint j=1; j<=n; ++j) temp[j]^=bas[i][j];\n        }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for(rint i=1; i<=n; ++i)\n        for(rint j=1; j<=m; ++j) scanf(\"%d\", &a[i][j]);\n    for(rint i=1; i<=n; ++i) insert(a[i]);\n    printf(\"%d\\n\", 1LL*(ksm(2, n)-ksm(2, n-siz)+P)*ksm(2, m-1)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 300;\nconst int MOD = 998244353;\nbitset<N> a[N]; \nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile(k) {\n\t\tif(k&1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD; \n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = m-1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t) a[i].set(j);\n\t\t}\n\t}\n \tfor (int i = 0; i < n; i++) {\n \t\tfor (auto b : base) {\n \t\t\tauto bb = b^a[i];\n \t\t\tfor (int j = m-1; j >= 0; j--) {\n \t\t\t\tif(bb[j] < a[i][j]) {\n \t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t }\n\t\t\t}\n\t\t }\t\n\t\t if(a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", (q_pow(2, n+m-1) - q_pow(2, n+m-1-cnt) + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = (ll)998244353;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n//functions\n   ll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n   ll pow(ll a, ll b){if (b == 0) return 1; else if (b % 2 == 0) return pow(a * a, b / 2); else return pow(a * a, b / 2) * a;}\n   ll pow(ll a, ll b, ll m){if (b == 0) return 1; else if (b % 2 == 0) return (pow(a * a, b / 2, m) % m); else return (pow(a * a, b / 2, m) * a) % m;}\n   ll residue(ll a, ll m){return ((a % m) + m) % m;};\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\n\n//与えられたF2上の行列をAとして、(1 << (M * N - rank(A) - 1)) * ((1 << rank(A)) - 1 )が答え.\nconst ll MAX_M = 300, MAX_N = 300;\nll N, M;\nll a[MAX_N][MAX_M];\n\nll rnk(){\n   ll r = 0;\n   ll i = 0, j = 0;\n   while(i < N && j < M){\n      //a[i][j] = 0のときは、k = i + 1, ..., N - 1 からa[k][j] != 0なるkを探してきて, i行目とk行目を入れ替える\n      if(!a[i][j]){\n         FOR(k, i + 1, N){\n            if(a[k][j]){\n               REP(l, M){\n                  swap(a[i][l], a[k][l]);\n               }\n               break;\n            }\n         }\n      }\n      //入れ替えを行ってもa[i][j] = 0のとき（つまりj列目はすべて0のとき)はj列目をスキップ j+1列目にトライ\n      if(!a[i][j]){j++; continue;}\n      r++;\n      //k = i+1,...,N-1行目についてi行目を引く\n      FOR(k, i + 1, N){\n         ll c = a[k][j];\n         REP(l, M){\n            a[k][l] += c * a[i][l];\n            a[k][l] %= 2;\n         }\n      }\n      i++; j++;\n   }\n   return r;\n}\n\nint main(){\n   cin >> N >> M;\n   REP(i, N) REP(j, M) cin >> a[i][j];\n   ll r = rnk();\n/*\n   cout << endl;\n   REP(i, N){\n      REP(j, M){\n         if(j) {cout << \" \";}\n         cout << a[i][j];\n      }\n      cout << endl;\n   }\n   cout << \"rnk = \" << r << endl;\n*/\n   cout << residue(pow(2ll, N + M - 1, MOD) - pow(2ll, N + M - 1 - r, MOD), MOD) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint main(){\n    int N, M, A[300][300];\n    cin >> N >> M;\n    for(int i=0; i<N; i++) for(int j=0; j<M; j++) cin >> A[i][j];\n\n    int rank = 0;\n    for(int j=0; j<M; j++){\n        int pivot = -1;\n        for(int i=rank; i<N; i++){\n            if(A[i][j]){\n                pivot = i;\n                break;\n            }\n        }\n        if(pivot >= 0){\n            if(pivot != rank) for(int k=0; k<M; k++) swap(A[pivot][k], A[rank][k]);\n            for(int i=rank+1; i<N; i++){\n                if(A[i][j]) for(int k=i; k<M; k++) A[j][k] ^ A[rank][k];\n            }\n            rank++;\n        }\n    }\n\n    int64_t ans = (MOD + power_mod(2, N+M-1) - power_mod(2, N+M-rank-1)) % MOD;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 400005\n#define ll long long\nusing namespace std ;\n\nIL int gi(){\n    int data = 0 , m = 1; char ch = 0;\n    while(ch!='-' && (ch<'0'||ch>'9')) ch = getchar();\n    if(ch == '-'){m = 0 ; ch = getchar() ; }\n    while(ch >= '0' && ch <= '9'){data = (data<<1) + (data<<3) + (ch^48) ; ch = getchar(); }\n    return (m) ? data : -data ; \n}\n\nint n , m , N , A[305][305] , pw[100005] , ID[305] ;\n#define mod 998244353\n\nint main() {\n\tn = gi() ; m = gi() ;\n\tfor(int i = 1; i <= n; i ++) for(int j = 1; j <= m; j ++) A[i][j] = gi() ;\n\tN = n * m ;\n\tpw[0] = 1 ; for(int j = 1; j <= N; j ++) pw[j] = 2ll * pw[j - 1] % mod ;\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= m; j ++) {\n\t\t\tif(A[i][j]) {\n\t\t\t\tif(!ID[j]) {ID[j] = i ; break ; }\n\t\t\t\telse for(int k = 1; k <= m; k ++) A[i][k] = A[i][k] ^ A[ID[j]][k] ;\n\t\t\t}\n\t\t}\n\tint _cnt = 0 ;\n\tfor(int j = 1; j <= m; j ++) if(ID[j] != 0) ++ _cnt ;\n\tcout << 1ll * pw[m - 1] * (pw[n] - pw[n - _cnt] + mod) % mod << endl ;\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdlib>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef long double ld;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\nconst int mod = 998244353;\n\nll mpow(ll x, ll n) {\n  ll res = 1;\n  while (n) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n /= 2;\n  }\n  return res;\n}\n\nint main() {\n  //mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<bitset<301>> v(n);\n  for (int i = 0; i < n; ++i) {\n    v[i].reset();\n    for (int j = 0; j < m; ++j) {\n      int t;\n      cin >> t;\n      v[i][j] = t;\n    }\n  }\n  int r = 0;\n  for (int j = 0; j < m; ++j) {\n    for (int i = r + 1; i < n; ++i) if (v[i][j]) {\n      swap(v[r], v[i]);\n      break;\n    }\n    if (!v[r][j]) continue;\n    for (int i = r + 1; i < n; ++i) if (v[i][j]) v[i] ^= v[r];\n    ++r;\n  }\n  cerr << r << endl;\n  ll res = mpow(2, m + n - 1) - mpow(2, n + m - r - 1);\n  cout << (res % mod + mod) % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n\nstruct fast_io {\n    static constexpr int size_in = 1 << 26, size_out = 1 << 26;\n    char data_in[size_in], data_out[size_out], *p_in, *p_out, s[30];\n    fast_io() { fread(data_in, 1, size_in, stdin), p_in = data_in, p_out = data_out; }\n    ~fast_io() { fwrite(data_out, 1, p_out - data_out, stdout); }\n    void putchar(char x) { *p_out++ = x; }\n    template<typename T> void putint(T x) {\n        if (x < 0) { *p_out++ = '-', x = -x; }\n        int i = 0;\n        do { s[i++] = x % 10 + '0'; } while (x /= 10);\n        while (i--) { *p_out++ = s[i]; }\n    }\n    template<typename T=int> T getint() {\n        while (!isdigit(*p_in) && *p_in != '-') { p_in++; }\n        bool negative = *p_in == '-';\n        T ret = negative ? 0 : *p_in - '0';\n        while (isdigit(*++p_in)) { (ret *= 10) += *p_in - '0'; };\n        return negative ? -ret : ret;\n    }\n} io;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nint main() {\n    int N = io.getint(), M = io.getint();\n    using bset = bitset<300>;\n    vector<bset> src(N);\n    rep(i, N) {\n        rep(j, M) {\n            int a = io.getint();\n            src[i][j] = a;\n        }\n    }\n    int rank = 0;\n    for (int i = 0; i < src.size(); i++) {\n        for (int j = src.size() - 1; j > i; j--) {\n            int x = src[j]._Find_first(), y = src[j - 1]._Find_first();\n            if (x < y) { src[j - 1] ^= src[j]; }\n            if (x <= y) { src[j] ^= src[j - 1]; }\n        }\n        if (src[i].none()) { break; }\n        rank++;\n    }\n    using mint = mod_int<998244353>;\n    io.putint((mint(2).pow(N + M - 1) - mint(2).pow(N + M - rank - 1)).val);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nint gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n\n#define ll long long\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=210;\nconst ll mod=998244353;\n\nbitset<maxn> bi[maxn];\nll tav[maxn];\n\nbitset<maxn> f[maxn];\nll cnt=1;\nll koj[maxn];\n\nbool add(bitset<maxn> bi,ll m){\n\tfor(ll i=m-1;i>=0;i--){\n\t\tif(bi[i]){\n\t\t\tif(koj[i]==-1){\n\t\t\t\tf[cnt]=bi;\n\t\t\t\tkoj[i]=cnt;\n\t\t\t\tcnt++;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\tbi^=f[koj[i]];\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\t\n\ttav[0]=1;\n\tfor(ll i=1;i<maxn;i++){\n\t\ttav[i]=(tav[i-1]*2)%mod;\n\t}\n\tfill(koj,koj+maxn,-1);\n\n\tll n,m;\n\tcin>>n>>m;\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<m;j++){\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\tbi[i][j]=a;\n\t\t}\t\t\n\t}\n\tll sefr=0;\n\tfor(ll i=0;i<n;i++){\n\t\tsefr+=add(bi[i],m);\n\t}\n\tcout<<((tav[m-1]*(tav[n]-tav[sefr]))%mod+mod)%mod;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\n/*bool operator < (const vector<long long> &a,const vector<long long> &b){\n    bool ret=false;\n    DEBUG(\"called\");\n    for(long long i = 0; i < a.size(); i++){\n        if(a[i]>b[i]){\n            ret=false;\n            break;\n        }else if(a[i]<b[i]){\n            ret=true;\n            break;\n        }\n    }\n    return ret;\n}\n*/\nll cache_pow[600];\nll mpow(ll a){\n    static bool flag=false;\n    if(flag){\n        DEBUG(\"True\");\n        return cache_pow[a];\n    }else{\n        cache_pow[0]=1;\n        for(long long i = 1; i < 600; i++){\n            cache_pow[i]=(cache_pow[i-1]*2)%MOD;\n        }\n        flag=true;\n        return cache_pow[a];\n    }\n}\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    sort(a.begin(),a.end(),greater<vll>());\n    ll index=0;\n\n    vector<bitset<300>> A;\n    for(long long i = 0; i < a.size(); i++){\n        A.push_back(bitset<300>(0));\n        for(long long k = 0; k < a[i].size(); k++){\n            A[i][k]=a[i][k]==1;\n        }\n    }\n    ll rank=0;\n    for(long long i = 0; i < a.size(); i++){\n        DEBUG(i);\n        for(; index < A[i].size()&&A[i][index]==0; index++){\n            DEBUG(index);\n        }\n        if(index==A[i].size()){\n            break;\n        }\n        rank++;\n        for(long long j = i+1; j < A.size()&&A[j][index]==1; j++){\n            A[j]^=A[i];\n        }\n    }\n    DEBUG(rank);\n    cout<<mpow(M+N-1)-mpow(M+N-1-rank)<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 302;\nconst int MOD = 998244353;\n\nbitset<N>a[N];\nint32_t main() {\n    //ifstream cin(\"data.in\");\n    int n, m;\n    cin >> n >> m;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n\n\n    // n ecuatii cu m necunoscute, rezultatul e 0\n    for(int i = 0; i < n; ++i) {\n        a[i][m] = 0;\n    }\n    int l = 0, c = 0, var_free = 0;\n    while(l < n && c < m) {\n        int poz = -1;\n        for(int i = l; i < n && poz == -1; i++)\n            if(a[i][c] == 1)\n                poz = i;\n        if(poz == -1) {\n            // n-am putut gasi, e deja 0\n            c++;\n            var_free++; // este variabila libea\n            continue;\n        }\n        swap(a[l], a[poz]);\n        for(int i = l + 1; i < n; ++i)\n            if(a[i][c] == 1)\n                a[i] ^= a[l];\n        l++;\n        c++;\n    }\n\n    bool zero_sub = 1;\n\n    for(int i = 0; i < n; ++i) {\n        if(a[i][m] == 1) {\n            bool any = 1;\n            for(int j = 0; j < m && !any; j++)\n                any |= a[i][j];\n            if(!any)\n                zero_sub = 0;\n        }\n    }\n\n\n    vector<long long>p2(n + m + 1);\n    p2[0] = 1;\n    for(int i = 1; i <= n + m; ++i)\n        p2[i] = 2 * p2[i - 1] % MOD;\n    int aux1, aux2;\n\n    aux1 = (p2[n] - 1 + MOD) % MOD, aux2 = p2[m - 1];\n    int answer = (1LL * aux1 * aux2) % MOD;\n\n    if(zero_sub) {\n        aux1 = (p2[var_free] - 1 + MOD) % MOD, aux2 = p2[m - 1];\n        int bad = (1LL * aux1 * aux2) % MOD;\n        answer = (answer - bad + MOD) % MOD;\n    }\n    cout << answer;\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#define MAXN 305\n#define P 998244353\n#define INF 0x3f3f3f3f\n#define rint register int\n#define LL long long\n#define LD long double\nusing namespace std;\n\nint n, m, siz, a[MAXN][MAXN], bas[MAXN][MAXN], temp[MAXN], vis[MAXN];\n\nint ksm(int x, int y)\n{\n    int ans=1;\n    while(y)\n    {\n        if(y&1) ans=1LL*ans*x%P;\n        x=1LL*x*x%P; y>>=1;\n    }\n    return ans;\n}\n\nvoid insert(int a[])\n{\n    memcpy(temp, a, sizeof(temp));\n    for(rint i=1; i<=m; ++i)\n        if(temp[i])\n        {\n            if(!vis[i])\n            {\n                for(rint j=1; j<=m; ++j) bas[i][j]=temp[j];\n                vis[i]=1;\n                siz++;\n                break;\n            }\n            for(rint j=1; j<=m; ++j) temp[j]^=bas[i][j];\n        }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for(rint i=1; i<=n; ++i)\n        for(rint j=1; j<=m; ++j) scanf(\"%d\", &a[i][j]);\n    for(rint i=1; i<=n; ++i) insert(a[i]);\n    printf(\"%d\\n\", 1LL*(ksm(2, n)-ksm(2, n-siz)+P)*ksm(2, m-1)%P);\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=305;\nconst int mod=998244353;\nint n,m;\nint a[maxn][maxn],pw[maxn*2];\n\nint gauss(){\n\tint r=1,res=0;\n\tREP(i,m){\n\t\tint j=r;\n\t\twhile(j<=n&&!a[j][i])j++;\n\t\tif(j>n){\n\t\t\tres++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(j!=r){\n\t\t\tREP(k,m)swap(a[j][k],a[r][k]);\n\t\t}\n\t\tfor(int j=r+1;j<=n;j++)if(a[j][i]){\n\t\t\tfor(int k=i;k<=m;k++)a[j][k]^=a[r][k];\n\t\t}\n\t\tr++;\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d\",&n,&m);\n\tpw[0]=1;\n\tREP(i,n+m)pw[i]=2LL*pw[i-1]%mod;\n\tREP(i,n)REP(j,m)scanf(\"%d\",&a[i][j]);\n\tint ans=(pw[n+m-1]-pw[n+gauss()-1]+mod)%mod;\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n};\n\nunsigned ModInt::MOD = 998244353;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nint a[310][310];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\trep(i, n) rep(j, m) cin >> a[i][j];\n\n\tint c = 0, rnk = 0;\n\trep(i, n){\n\t\tint pivot = i;\n\t\tfor(; c < m; ++c){\n\t\t\tint cmax = 0;\n\t\t\trep(k, i, n) if(chmax(cmax, a[k][c])) pivot = k;\n\t\t\tif(cmax > 0) break;\n\t\t}\n\t\tif(c == m) break;\n\n\t\trnk++;\n\t\tif(i != pivot) rep(j, m) swap(a[i][j], a[pivot][j]);\n\t\trep(k, i + 1, n){\n\t\t\tif(a[k][c]){\n\t\t\t\trep(j, m) a[k][j] ^= a[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tmint coef = TWO.power(n) - TWO.power(n - rnk);\n\tmint ans = coef * TWO.power(m - 1);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;++i)\n#define repd(i,a,b) for(int i=a;i>=b;--i)\n#define rvc(i,S) for(int i=0;i<(int)S.size();++i)\n#define fore(i,x) for(int i = head[x] ; i ; i = e[i].next)\n#define mp make_pair\n#define pb push_back\n#define int long long\n#define PII pair<int,int>\n#define maxn 1000005\n#define ll long long \n#define fi first\n#define int ll\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std; \nint n,m;\nconst int mo=998244353;\nint a[305][305];\nvoid SWAP(int x,int y)\n{ rep(i,1,m) swap(a[x][i],a[y][i]);}\nvoid solve(int x,int y)\n{rep(i,1,m) a[x][i]^=a[y][i];\n}\nsigned main()\n{ cin>>n>>m;\n  rep(i,1,n)rep(j,1,m) cin>>a[i][j];\n  int r=0;\n  rep(i,1,m)\n  {int k=0; \n   rep(j,r+1,n) if(a[j][i]){k=j;break;}\n   if(k) {r++;}\n   else continue;\n   SWAP(r,k);\n   rep(p,1,n)\n   {if((p!=r)&&a[p][i])\n     solve(p,r);\n   }\n  }\n  int add=1;\n  rep(i,1,n+m-1) add=(add*2)%mo;\n  int del=1;\n  rep(i,1,n+m-r-1) del=(del*2)%mo;\n  cout<<(add-del+mo)%mo<<endl; \n\t\n\t\n\t\nreturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG  // gcc\n    #define _LIBCPP_DEBUG 0 // clang\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define _GLIBCXX_DEBUG\n    // #define _LIBCPP_DEBUG 0\n    // #define NDEBUG\n#endif\n// #define __buffer_check__\n#define __precision__ 10\n#define iostream_untie true\n#define debug_stream std::cerr\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define odd(n) ((n) & 1)\n#define even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace setting\n{\n    using namespace std::chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { debug_stream << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\"; }\n    void buffer_check() { char bufc; if(std::cin >> bufc) debug_stream << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n            std::cout << std::fixed << std::setprecision(__precision__);\n    #ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n    #endif\n    #ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdout file.\\n\";\n            }\n            std::cout << \"\";\n    #endif\n    #ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                debug_stream << \"\\n\\033[1;35mwarning\\033[0m: failed to open stdin file.\\n\";\n            }\n    #endif\n    #ifdef LOCAL\n            debug_stream << \"\\n----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n    #if defined(__clock__) || defined(LOCAL)\n            start_time = system_clock::now();\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#ifdef __clock__\nclass\n{\n    std::chrono::system_clock::time_point built_pt, last_pt; int built_ln, last_ln;\n    std::string built_func, last_func; bool is_built = false;\npublic:\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true, last_pt = built_pt = std::chrono::system_clock::now(), last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built) last_pt = std::chrono::system_clock::now(), last_ln = crt_ln, last_func = crt_func;\n        else debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built!)\\n\";\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            long long diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n} myclock; // unnamed class\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\n/* dump definition start */\n#ifdef LOCAL\n    #define dump(...) debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\", dump_func(#__VA_ARGS__, __VA_ARGS__)\n    template <class T> void dump_func(const char *ptr, const T &x)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != '\\0'; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << '\\n';\n    }\n    template <class T, class... rest_t> void dump_func(const char *ptr, const T &x, rest_t... rest)\n    {\n        debug_stream << '\\t';\n        for(char c = *ptr; c != ','; c = *++ptr) if(c != ' ' && c != '\\t') debug_stream << c;\n        debug_stream << \" : \" << x << \",\\n\"; dump_func(++ptr, rest...);\n    }\n#else\n    #define dump(...) ((void)0)\n#endif\n/* dump definition end */\n\n/* function utility start */\ntemplate <class T, class... types> T read(types... args) noexcept { T obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// reset all bits.\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing pii = pair<i32, i32>; using pll = pair<i64, i64>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using rheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\n/* using alias end */\n\n/* library start */\n\n#ifndef Modint_hpp\n#define Modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    static constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    constexpr modint(bool x = false) noexcept : val{x} {}\n    constexpr modint(int x) noexcept : val(x & 1) {}\n    constexpr modint(long long x) noexcept : val(x & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return val ^= other.val, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val &= other.val, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { assert(other.val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator-(const modint &other) const noexcept { return val != other.val; }\n    constexpr modint operator*(const modint &other) const noexcept { return val && other.val; }\n    constexpr modint operator/(const modint &other) const noexcept { assert(other.val); return *this; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return x & 1 ? !y : y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return x & 1 ? y : modint<2>{0}; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { assert(y.val); return x & 1 ? y : modint<2>{0}; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // Modint_hpp\n\n#ifndef Matrix_hpp\n#define Matrix_hpp\n#include <iostream>\n#include <valarray>\n#include <vector>\n\ntemplate <class Field>\nclass matrix\n{\n    size_t h, w;\n    using row_type = std::valarray<Field>;\n    using data_type = std::valarray<std::valarray<Field>>;\n    data_type data;\n\n    friend std::istream &operator>>(std::istream &is, matrix &x)\n    {\n        for(size_t i = 0; i != x.h; ++i)\n        {\n            for(size_t j = 0; j != x.w; ++j) is >> x[i][j];\n        }\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const matrix &x)\n    {\n        for(size_t i = 0; i != x.h; ++i)\n        {\n            if(i) os << \"\\n\";\n            for(size_t j = 0; j != x.w; ++j) os << (j ? \" \" : \"\") << x.data[i][j];\n            os << \" x.w: \" << x.w;\n        }\n        return os;\n    }\n\n    friend matrix transpose(const matrix &x)\n    {\n        matrix res(x.w, x.h);\n        for(size_t i = 0; i != x.w; ++i)\n            for(size_t j = 0; j != x.h; ++j)\n                res[i][j] = x.data[j][i];\n        return res;\n    }\n\n    friend matrix pow(matrix x, long long n)\n    {\n        assert(x.is_square());\n        if(n < 0) x = inverse(x), n = -n;\n        matrix res{identity(x.h)};\n        while(n)\n        {\n            if(n & 1) res *= x;\n            x *= x, n >>= 1;\n        }\n        return res;\n    }\n\n    friend matrix inverse(const matrix &x)\n    {\n        assert(x.is_square());\n        matrix ext_x(x.h, x.h * 2), res(x.h);\n        for(size_t i = 0; i != x.h; ++i) ext_x.data[i][std::slice(0, x.h, 1)] = x.data[i], ext_x.data[i][i + x.h] = 1;\n        if(ext_x.row_canonicalize().size() != x.h) return matrix{0};\n        for(size_t i = 0; i != x.h; ++i) res[i] = ext_x.data[i][std::slice(x.h, x.h, 1)];\n        return res;\n    }\n\npublic:\n    explicit matrix(size_t _n = 0) : h(_n), w(_n) { resize(_n, _n);}\n    matrix(size_t _h, size_t _w) : h(_h), w(_w) { resize(_h, _w); }\n    matrix(const data_type &_data) : h(_data.size()), w(_data.size() ? _data[0].size() : 0), data(_data) {}\n    operator data_type() const { return data; }\n\n    size_t height() const { return h; }\n    size_t width() const { return w; }\n    bool is_square() const { return h == w; }\n    void resize(size_t h, size_t w, const Field val = Field(0)) { data.resize(h, std::valarray<Field>(val, w)); }\n    row_type &operator[](const size_t i) { assert(i < data.size()); return data[i]; }\n\n    static matrix identity(const size_t n)\n    {\n        data_type data(row_type(n), n);\n        for(size_t i = 0; i != n; ++i) data[i][i] = 1;\n        return data;\n    }\n\n    matrix operator-() const { return {-data}; }\n    matrix &operator+=(const matrix &other) { data += other.data; return *this; }\n    matrix &operator-=(const matrix &other) { data -= other.data; return *this; }\n    matrix &operator*=(matrix other)\n    {\n        other = transpose(other);\n        for(size_t i = 0; i != h; ++i)\n        {\n            const row_type copied{data[i]};\n            for(size_t j = 0; j != other.h; ++j) data[i][j] = (copied * other.data[j]).sum();\n        }\n        return *this;\n    }\n    matrix operator+(const matrix &x) const { return matrix(*this) += x; }\n    matrix operator-(const matrix &x) const { return matrix(*this) -= x; }\n    matrix operator*(const matrix &x) const { return matrix(*this) *= x; }\n\n    std::vector<size_t> row_canonicalize()\n    {\n        std::vector<size_t> pivots;\n        for(size_t j = 0, rank = 0; j != w; ++j)\n        {\n            bool piv = false;\n            for(size_t i = rank; i != h; ++i)\n            {\n                if(data[i][j] != Field{0})\n                {\n                    const Field coef = data[i][j];\n                    if(piv) data[i] -= data[rank] * coef;\n                    else\n                    {\n                        swap(data[rank], data[i]);\n                        data[rank] /= coef;\n                        piv = true;\n                    }\n                }\n            }\n            if(piv)\n            {\n                for(size_t k = 0; k != rank; ++k)\n                {\n                    const Field coef = data[k][j];\n                    data[k] -= data[rank] * coef;\n                }\n                ++rank;\n                pivots.emplace_back(j);\n            }\n        }\n        return pivots;\n    }\n\n    Field determinant() const\n    {\n        assert(is_square());\n        data_type copied{data};\n        Field res{1};\n        for(size_t j = 0; j != w; ++j)\n        {\n            bool piv = false;\n            for(size_t i = j; i != h; ++i)\n            {\n                if(copied[i][j] != Field{0})\n                {\n                    const Field coef = copied[i][j];\n                    if(piv) copied[i] -= copied[j] * coef;\n                    else\n                    {\n                        swap(copied[i], copied[j]);\n                        if(i != j) res = -res;\n                        res *= coef;\n                        copied[j] /= coef;\n                        piv = true;\n                    }\n                }\n            }\n            if(!piv) return 0;\n        }\n        return res;\n    }\n};\n#endif\n\n/* library end */\n\n/* The main code follows. */\n\nusing mint=modint<998244353>;\n\nstruct solver\n{\n    solver()\n    {\n        input(int,h);\n        input(int,w);\n        input(matrix<modint<2>>,a,h,w);\n        int rank=a.row_canonicalize().size();\n        int kdim=w-rank;\n        cout << mint::pow(2,h)*(mint::pow(2,w-1)-mint::pow(2,kdim-1)) << \"\\n\";\n    }\n\n    void test()\n    {\n        matrix<int> a({{1,0},{0,-1}});\n        cout << a << \"\\n\";\n        a*=a;\n        cout << a << \"\\n\";\n        return;\n    }\n}; // struct solver\n\nint main(int argc, char *argv[])\n{\n    u32 t; // loop count\n#ifdef LOCAL\n    t = 1;\n#else\n    t = 1; // single test case\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--)\n    {\n        solver();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nint grid[400][400] = {};\nint bad[400] = {};\nlong long powing(long long a, long long b) {\n\tlong long ans = 1;\n\twhile (b != 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tREP(i, n) {\n\t\tREP(q, m) {\n\t\t\tcin >> grid[i][q];\n\t\t}\n\t}\n\tlong long rank = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint itr = -1;\n\t\tfor (int q = 0; q < m; ++q) {\n\t\t\tif (bad[q] == 1) continue;\n\t\t\tif (grid[i][q] == 1) {\n\t\t\t\titr = q;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (itr == -1) continue;\n\t\tfor (int q = 0; q < m; ++q) {\n\t\t\tif (grid[i][q] == 1 && q != itr) {\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tgrid[j][q] += grid[j][itr];\n\t\t\t\t\tgrid[j][q] %= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbad[itr] = 1;\n\t\trank++;\n\t}\n\tcout << (powing(2, n + m - 1) - powing(2, n + m - 1 - rank) + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n//const int MOD = 1000000007;\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nconst int MAX_ROW = 510; //to be set\nconst int MAX_COL = 510; //to be set\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for(int col = 0; col < A.W; ++col) {\n        if(is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for(int row = rank; row < A.H; ++row) {\n            if(A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if(pivot == -1) continue;\n        swap(A[rank], A[pivot]);\n        for(int row = 0; row < A.H; ++row) {\n            if(row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint liner_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n + 1; ++j) {\n            M[i][j] = A[i][j];\n        }\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    //check if it has no solution\n    for(int row = rank; row < m; ++row) if(M[row][n]) return -1;\n\n    //answer\n    res.assign(n, 0);\n    for(int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return rank;\n}\n\nint n, m;\n\nvoid solve() {\n    bc.init(1010);\n\tcin >> n >> m;\n    BitMatrix a(n, m);\n    rep(i, n) {\n        rep(j, m) {\n            int x; cin >> x;\n            if(x) a[i][j] = 1;\n        }\n    }\n    int r = GaussJordan(a);\n    mint ans = 0;\n    for(int i = 0; i <= r; ++ i) {\n        for(int j = 1; j <= i; j += 2) {\n            ans += bc.com(r, i) * bc.com(i, j) * modpow((mint)2, r - i);\n        }\n    }\n    cout << ans * modpow((mint)2, n - r) * modpow((mint)2, m - r) << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 302;\nconst int MOD = 998244353;\n\nbitset<N>a[N];\nint32_t main() {\n\n    int n, m;\n    cin >> n >> m;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    // n ecuatii cu m necunoscute, rezultatul e 0\n    for(int i = 0; i < n; ++i) {\n        a[i][m] = 0;\n    }\n\n    int l = 0, c = 0, var_free = 0;\n    while(l < n && c < m) {\n        int poz = -1;\n        for(int i = l; i < n && poz == -1; i++)\n            if(a[i][c] != 0)\n                poz = i;\n\n        if(poz == -1) {\n            // n-am putut gasi, e deja 0\n            c++;\n            var_free++; // este variabila libea\n            continue;\n        }\n        swap(a[l], a[poz]);\n        for(int i = l + 1; i < n; ++i)\n            a[i] ^= a[l];\n        l++;\n    }\n    vector<long long>p2(n + m + 1);\n    p2[0] = 1;\n    for(int i = 1; i <= n + m; ++i)\n        p2[i] = 2 * p2[i - 1] % MOD;\n    int aux1, aux2;\n\n    aux1 = (p2[n] - 1 + MOD) % MOD, aux2 = p2[m - 1];\n    int answer = (1LL * aux1 * aux2) % MOD;\n\n    aux1 = (p2[var_free] - 1 + MOD) % MOD, aux2 = p2[m - 1];\n    int bad = (1LL * aux1 * aux2) % MOD;\n    answer = (answer - bad + MOD) % MOD;\n\n    cout << answer;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n//x,yがax+by=gcd(a,b)の解になる\nll extgcd(ll a, ll b, ll& x, ll& y) {\n\tll d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n//aのmod mでの逆元を求める\nll mod_inverse(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\nconst int N_MAX = 1 << 18;\nll p[N_MAX];\nvoid init() {\n\tp[0] = 1;\n\trep1(i, N_MAX - 1) {\n\t\tp[i] = p[i - 1] * i%mod;\n\t}\n}\n//xCyを求める\nll comb(ll x, ll y, ll m) {\n\tif (x < y)return 0;\n\tll res = p[x];\n\t(res *= mod_inverse(p[y], m)) %= mod;\n\t(res *= mod_inverse(p[x - y], m)) %= mod;\n\treturn res;\n}\nll mod_pow(ll x, int n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nint n, m;\nint a[300][300];\nint calcrank() {\n\tint res = 0;\n\tint k = min(n, m);\n\trep(i, k) {\n\t\tbool ansed = false;\n\t\tRep(j,i, n) {\n\t\t\tif (a[j][i]) {\n\t\t\t\tswap(a[j], a[i]);\n\t\t\t\tansed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ansed) {\n\t\t\tres++;\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tif (a[j][i]) {\n\t\t\t\t\trep(l, m) {\n\t\t\t\t\t\ta[j][l] ^= a[i][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nll inv2 = (1 + mod) / 2;\nll inv4 = inv2 * inv2%mod;\nll inv34 = 3 * inv4%mod;\nint main() {\n\tinit();\n\tcin >> n >> m;\n\tint num = 0;\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tint r = calcrank();\n\tll ans = 0;\n\tfor (int j = 1; j <= r; j += 2) {\n\t\tll csum = mod_pow(2, (n - r)+(m - r));\n\t\tcsum = csum * comb(r, j, mod) %mod*mod_pow(3, r - j) % mod;\n\t\t(ans += csum) %= mod;\n\t}\n\tcout << ans << endl;\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate<Int MOD>\nstruct ModInt {\n    constexpr static Int mod = MOD;\n    Int v;\n\n    ModInt(long long _v = 0) : v(set(_v)) {}\n    ModInt(const ModInt &r) : v(set(r.v)) {}\n\n    inline static Int set(const Int x) { return x < 0 ? (x % mod) + mod : x % mod; }\n    inline void set() { v = set(v); }\n\n    bool operator<(ModInt r) const { return v < r.v; }\n    bool operator>(ModInt r) const { return r.v < v; }\n    bool operator==(ModInt r) const { return v == r.v; }\n    bool operator!= (ModInt r) const { return v != r.v; }\n\n    ModInt operator-() const { return ModInt(v ? mod - v : v); }\n    ModInt &operator=(const ModInt &r) { if (this != &r) v = set(r.v); return *this; }\n    ModInt &operator+=(ModInt r) { (v += r.v) %= mod; return *this; }\n    ModInt &operator-=(ModInt r) { (v -= r.v - mod) %= mod; return *this; }\n    // ModInt &operator*=(ModInt r) { v = (__uint128_t(v) * r.v) % mod; return *this; }\n    ModInt &operator*=(ModInt r) { v = 1ULL * v * r.v % mod; return *this; }\n    ModInt &operator/=(ModInt r) { *this *= r.inv(); return *this; }\n    ModInt operator+(ModInt r) const { return ModInt(*this) += r; }\n    ModInt operator-(ModInt r) const { return ModInt(*this) -= r; }\n    ModInt operator*(ModInt r) const { return ModInt(*this) *= r; }\n    ModInt operator/(ModInt r) const { return ModInt(*this) /= r; }\n\n    ModInt inv() const {\n        long long a = v, b = mod, u = 1, w = 0;\n        while (b) {\n            long long t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * w, w);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(Int e) {\n        ModInt a = *this, x(1);\n        for ( ; 0 < e; e >>= 1) { if (e & 1) x *= a; a *= a; }\n        return x;\n    }\n    inline ModInt pow(ModInt &e) { return pow(e.v); }\n};\n\nstd::ostream &operator<<(std::ostream &os, const auto &r) { return os << r.v; }\nstd::istream &operator>>(std::istream &is, auto &r) { is >> r.v; r.set();return is; }\n\nusing Mod2 = ModInt<2>;\nusing Type = ModInt<998244353>;\nusing Vector = vector<Mod2>;\nusing Matrix = vector<Vector>;\n\nint Rank(Matrix &A) {\n    const int N = A.size(), M = A[0].size();\n    int rank = 0;\n    vector<bool> used(N, false);\n\n    for (int c = 0; c < M; ++c) {\n        int pivot = 0;\n        while (pivot < N && (used[pivot] || A[pivot][c] == 0)) ++pivot;\n        if (pivot == N) continue;\n\n        ++rank;\n        Mod2 v = A[pivot][c];\n        for (int j = 0; j < N; ++j) A[pivot][j] /= v;\n        for (int r = 0; r < N; ++r) {\n            if (r == pivot) continue;\n            for (int j = c + 1; j < M; ++j)\n                A[r][j] -= A[r][c] * A[pivot][j];\n        }\n    }\n\n    return rank;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    Matrix A(n, Vector(m));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            cin >> A[i][j];\n\n    int rank = Rank(A);\n    Type res = Type(2).pow(m + n - 1) - Type(2).pow(m + n - rank - 1);\n    cout << res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=305;\nconst int mod=998244353;\nint n,m,bin[MAXN];\nbitset<MAXN> bi[MAXN];\nint main()\n{\n\tbin[0]=1;for(int i=1;i<MAXN;i++)bin[i]=(bin[i-1]<<1)%mod;\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=m;j++)bi[i][j]=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u=i;for(int j=i+1;j<=n;j++)if(bi[j][i]){u=j;break;}\n\t\tswap(bi[i],bi[u]);if(!bi[i][i])continue;\n\t\tfor(int j=i+1;j<=n;j++)if(bi[j][i])bi[j]^=bi[i];\n\t}int cnt=0;\n\tfor(int i=1;i<=n;i++)if(bi[i].any())++cnt;\n\tcnt=n-cnt;\n\tint val=(bin[n]-bin[cnt]+mod)%mod;\n\tpr2(1LL*val*bin[m-1]%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nusing V = bitset<300>;\nint n,m;\nint calc_rank(vector<V>& a) {\n    int r = 0;\n    for (int j = 0; j < m; j++) {\n        for (int i = r+1; i < n; i++) {\n            if (a[i][j]) {\n                if (a[r][j]) a[i] ^= a[r];\n                else swap(a[r], a[i]);\n            }\n        }\n        if (a[r][j]) r++;\n        if (r == n) return n; // in case of full rank overflow, or create global V additonal-size 0\n    }\n    return r;\n}\n\nvoid solve() {\n    cin >> n >> m;\n    vector<V> a(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int x; cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = calc_rank(a);\n    //cout << r << \"\\n\";\n    mint res = mint(2).exp(n+m-1) - mint(2).exp(n+m-r-1);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 998244353ll;\n\ntypedef bitset<300> bit;\n\nint n,m;\nbit a[325];\n\nll modpow(ll a, ll b){\n  ll r = 1;\n  while(b){\n    if(b&1)r=r*a%MOD;\n    a=a*a%MOD;\n    b>>=1;\n  }\n  return r;\n}\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  REP(i,n){\n    int x;\n    REP(j,m){\n      scanf(\"%d\",&x);\n      if(x==1)a[i].set(j);\n    }\n  }\n  int cnt = 0;\n  REP(pos,m){\n    int tgt = -1;\n    FOR(i,cnt,n)if(a[i][pos]){\n      tgt = i; break;\n    }\n    if(tgt==-1)continue;\n    swap(a[cnt], a[tgt]);\n    REP(i,n)if(i != cnt && a[i][pos]){\n      a[i] ^= a[cnt];\n    }\n    cnt++;\n  }\n  ll ans = (modpow(2ll, cnt) - 1 + MOD) * modpow(2ll, n-cnt) % MOD * modpow(2ll, m-1) % MOD;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst int mod = 998244353;\n\nint modpow(int x, int y, int m) {\n  int ret = 1 % m, x2p = x;\n  while (y > 0) {\n    if (y % 2) ret = (lint)ret * x2p % m;\n    y /= 2;\n    x2p = (lint)x2p * x2p % m;\n  }\n  return ret;\n}\n\nint inv(int a, int p) { return modpow(a, p - 2, p); }\n\nvector<int> fact, inv_fact;\n\nvoid prepare_binom(int lim) {\n  fact.resize(lim + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= lim; ++i)\n    fact[i] = (lint)i * fact[i - 1] % mod;\n\n  inv_fact.resize(lim + 1);\n  inv_fact[lim] = inv(fact[lim], mod);\n  for (int i = lim - 1; i >= 0; --i)\n    inv_fact[i] = (lint)(i + 1) * inv_fact[i + 1] % mod;\n}\n\nint binom(int a, int b) {\n  if (!(0 <= b && b <= a)) return 0;\n  return (lint)fact[a] * inv_fact[b] % mod * inv_fact[a - b] % mod;\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n\n  prepare_binom(min(n, m));\n\n  vector<vector<int>> mat(n, vector<int>(m));\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      scanf(\"%d\", &mat[i][j]);\n      mat[i][j] %= 2;\n    }\n\n  int rank = 0;\n  for (int x = 0; x < m; ++x) {\n    int selected = -1;\n    for (int y = rank; y < n; ++y)\n      if (mat[y][x])\n        selected = y;\n    if (selected == -1) continue;\n    swap(mat[selected], mat[rank]);\n    for (int y = rank + 1; y < n; ++y) {\n      if (!mat[y][x]) continue;\n      for (int x2 = x; x2 < n; ++x2)\n        mat[y][x2] ^= mat[rank][x2];\n    }\n    ++rank;\n  }\n\n  int result = 0;\n  for (int i = 1; i <= rank; i += 2)\n    result = (result + (lint)binom(rank, i) * modpow(3, rank - i, mod) % mod * modpow(2, n + m - 2 * rank, mod)) % mod;\n  printf(\"%d\\n\", result);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n    ost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n    return ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n    ost<<\"{\";\n    for(int i=0;i<v.size();i++){\n        if(i)ost<<\",\";\n        ost<<v[i];\n    }\n    ost<<\"}\";\n    return ost;\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n    uint32_t a;\n    ModInt& s(uint32_t vv){\n        a=vv<mod?vv:vv-mod;\n        return *this;\n    }\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n    ModInt& operator+=(const ModInt &x){return s(a+x.a);}\n    ModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n    ModInt& operator*=(const ModInt &x){\n        a=uint64_t(a)*x.a%mod;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt &x){\n        *this*=x.inv();\n        return *this;\n    }\n\n    ModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n    ModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n    ModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n    ModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n    bool operator==(const ModInt &x)const{return a==x.a;}\n    bool operator!=(const ModInt &x)const{return a!=x.a;}\n    bool operator<(const ModInt &x)const{return a<x.a;}\n\n    ModInt operator-()const{return ModInt()-*this;}\n    ModInt pow(int64_t n)const{\n        ModInt res(1),x(*this);\n        while(n){\n            if(n&1)res*=x;\n            x*=x;\n            n>>=1;\n        }\n        return res;\n    }\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n    return (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n    return (out<<a.a);\n}\nusing mint=ModInt<998244353>;\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n    int N;\n    vector<Mint>facts,finvs,invs;\n    ModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n        const uint32_t mod=Mint(-1).a+1;\n        invs[1]=1;\n        for(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n        facts[0]=1;\n        finvs[0]=1;\n        for(int i=1;i<N;i++){\n            facts[i]=facts[i-1]*i;\n            finvs[i]=finvs[i-1]*invs[i];\n        }\n    }\n    inline Mint fact(int n)const{return facts[n];}\n    inline Mint finv(int n)const{return finvs[n];}\n    inline Mint inv(int n)const{return invs[n];}\n    inline Mint binom(int n,int k)const{\n        if(n<0||k<0||k>n)return 0;\n        return facts[n]*finvs[k]*finvs[n-k];\n    }\n    inline Mint perm(int n,int k)const{\n        if(n<0||k<0||k>n)return 0;\n        return facts[n]*finvs[n-k];\n    }\n    inline Mint catalan(int n){\n        return facts[2*n]*finvs[n+1]*finvs[n];\n    }\n};\nModIntTable<mint,20>mt;\nmint po[222222];\nmint po3[222222];\nint N,M;\nint A[333][333];\nint tmp[333][333];\nsigned main(){\n    po[0]=1;\n    for(int i=1;i<222222;i++)po[i]=po[i-1]*2;\n    po3[0]=1;\n    for(int i=1;i<222222;i++)po3[i]=po3[i-1]*3;\n    cin>>N>>M;\n    rep(i,N)rep(j,M)cin>>A[i][j];\n    rep(t,2){\n        vector<vint>X(N,vint(M));\n        rep(i,N)rep(j,M)X[i][j]=A[i][j];\n        rep(i,N){\n            for(int j=i+1;j<N;j++)if(X[i]<X[j])swap(X[i],X[j]);\n            for(int j=i+1;j<N;j++){\n                vint v=X[j];\n                rep(k,M)v[k]^=X[i][k];\n                chmin(X[j],v);\n            }\n        }\n        rep(i,N)rep(j,M)A[i][j]=X[i][j];\n     \n        rep(i,N)rep(j,M)tmp[j][i]=A[i][j];\n        swap(N,M);\n        rep(i,N)rep(j,M)A[i][j]=tmp[i][j];\n    }\n\n    mint ans=0;\n    int num=0;\n    while(num<N&&num<M&&A[num][num])num++;\n    for(int i=1;i<=num;i+=2){\n        mint tmp=mt.binom(num,i);\n        tmp*=po3[num-i];\n        ans+=tmp;\n    }\n    ans*=po[N+M-2*num];\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// binary 行列 (行列累乗と、掃き出し法)\n//\n// verified:\n//   みんなのプロコン 2019 E - Odd Subrectangles\n//     https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n// \n\n\n#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n\nconst int MAX_ROW = 510; // to be set appropriately\nconst int MAX_COL = 510; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\ntemplate<int MOD> ostream& operator << (ostream& s, BitMatrix A) {\n    s << endl; \n    for (int i = 0; i < A.H; ++i) {\n        for (int j = 0; j < A.W; ++j) {\n            s << A[i][j] << \", \";\n        }\n        s << endl;\n    }\n    return s;\n}\n\ninline BitMatrix operator * (BitMatrix A, BitMatrix B) {\n    BitMatrix R(A.H, B.W);\n    BitMatrix tB(B.W, B.H);\n    for (int i = 0; i < tB.H; ++i) for (int j = 0; j < tB.W; ++j) tB[i][j] = B[j][i];\n    for (int i = 0; i < R.H; ++i) for (int j = 0; j < R.W; ++j) R[i][j] = (A[i] & tB[j]).any();\n    return R;\n}\n\ninline BitMatrix pow(BitMatrix A, long long n) {\n    BitMatrix R(A.H, A.H);\n    for (int i = 0; i < A.H; ++i) R[i][i] = 1;\n    while (n > 0) {\n        if (n & 1) R = R * A;\n        A = A * A;\n        n >>= 1;\n    }\n    return R;\n}\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return rank;\n};\n\n\nconst int MOD = 998244353;\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() { \n    int N, M; cin >> N >> M;\n    BitMatrix A(N, M);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            int a; cin >> a;\n            if (a) A[i][j] = 1;\n        }\n    }\n    vector<int> res;\n    int r = GaussJordan(A);  \n    cout << (modpow(2LL, N+M-1, MOD) - modpow(2LL, N+M-r-1, MOD) + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <sstream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define SZ(x) (int)(x.size())\n#define F0(i,n) for(int i=0;i<n;i++)\n#define F1(i,n) for(int i=1;i<=n;i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define P(x) cerr << #x << \"=\" << x << endl\n\nconst int MOD = 998244353;\nconst double pi = atan(1.0)*4.0;\nconst double eps = 1e-8;\nll gcd(ll x, ll y) { return y ? gcd(y, x%y) : x; }\nint bc(int n) { return n ? bc((n-1)&n)+1 : 0; }\n\nconst int N = 301;\nint i, j, k, m, n, rn, bn;\nstring s;\nint a[N][N], b[N][N], used[N], ans2;\nll ans;\n\nvoid add(int& x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvoid solve() {\n    F0(i, m) F0(j, n) cin >> a[i][j];\n\n    int ind = 0;\n    CL(0, used);\n    F0(j, n) {\n        F0(i, m) if (a[i][j] && !used[i]) {\n            for (int k = i + 1; k < m; k++) if (a[k][j] && !used[k]) {\n                F0(l, n) a[k][l] ^= a[i][l];\n            }\n            ind++;\n            used[i] = 1;\n            break;\n        }\n    }\n    ans = 0;\n    F0(i, ind) {\n        ans = (ans * 2 + 1) % MOD;\n    }\n    F0(i, m - ind + n - 1) ans = (ans * 2) % MOD;\n    cout << ans << endl;\n}\n\nint main() {\n    //freopen(\"x.in\", \"r\", stdin);\n    while (cin >> m >> n) {\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\n// <<<\n// >>> gauss jordan, det\ntemplate <class T>\nint gauss_jordan(vector<vector<T>> &a) { // return rank\n    if (a.empty()) return 0;\n    const int h = a.size(), w = a[0].size();\n    int i = 0;\n    for (int j = 0; i < h && j < w; j++) {\n        int k = i;\n        while (k < h && a[k][j] == 0) k++; //\n        if (k == h) continue;\n        swap(a[i],a[k]);\n        rep (x,h) if (x != i && a[x][j] != 0) {\n            auto const d = a[x][j]/a[i][j];\n            rep (y,w) a[x][y] -= d*a[i][y];\n        }\n        i++;\n    }\n    return i;\n}\ntemplate <class T>\nT det(vector<vector<T>> a) {\n    const int n = a.size();\n    rep (i,n) assert((int)a[i].size() == n);\n    gauss_jordan(a);\n    T ans = 1;\n    rep (i,n) ans *= a[i][i];\n    return ans;\n}\n// <<<\n// >>> modint\ntemplate <uint32_t md>\nclass modint {\n    static_assert(md < (1u<<31), \"\");\n    using M = modint;\n    using i64 = int64_t;\n    uint32_t x;\npublic:\n    static constexpr uint32_t mod = md;\n    constexpr modint(i64 x = 0) : x((x%=md) < 0 ? x+md : x) { }\n    constexpr i64 val() const { return x; }\n    constexpr explicit operator i64() const { return x; }\n    constexpr bool operator==(M r) const { return x == r.x; }\n    constexpr bool operator!=(M r) const { return x != r.x; }\n    constexpr M operator+() const { return *this; }\n    constexpr M operator-() const { return M()-*this; }\n    constexpr M& operator+=(M r) { x += r.x; x = (x < md ? x : x-md); return *this; }\n    constexpr M& operator-=(M r) { x += md-r.x; x = (x < md ? x : x-md); return *this; }\n    constexpr M& operator*=(M r) { x = (uint64_t(x)*r.x)%md; return *this; }\n    constexpr M& operator/=(M r) { return *this *= r.inv(); }\n    constexpr M operator+(M r) const { return M(*this) += r; }\n    constexpr M operator-(M r) const { return M(*this) -= r; }\n    constexpr M operator*(M r) const { return M(*this) *= r; }\n    constexpr M operator/(M r) const { return M(*this) /= r; }\n    friend constexpr M operator+(i64 x, M y) { return M(x)+y; }\n    friend constexpr M operator-(i64 x, M y) { return M(x)-y; }\n    friend constexpr M operator*(i64 x, M y) { return M(x)*y; }\n    friend constexpr M operator/(i64 x, M y) { return M(x)/y; }\n    constexpr M inv() const { assert(x > 0); return pow(md-2); }\n    constexpr M pow(i64 n) const {\n        n %= md-1;\n        if (n < 0) n = (-n)*(md-2)%(md-1);\n        M v = *this, r = 1;\n        for (; n > 0; n >>= 1, v *= v) if (n&1) r *= v;\n        return r;\n    }\n#ifdef LOCAL\n    friend string to_s(M r) { return to_s(r.val(), mod); }\n#endif\n    friend ostream& operator<<(ostream& os, M r) { return os << r.val(); }\n    friend istream& operator>>(istream& is, M &r) { i64 x; is >> x; r = x; return is; }\n};\n// <<<\nconstexpr int64_t MOD = 998244353;\n//constexpr int64_t MOD = 1e9+7;\nusing mint = modint<MOD>;\n// >>> mod table\ntemplate <int32_t mod>\nstruct ModTable {\n    static constexpr int32_t Size = 1e6 + 10;\n    static_assert(Size <= mod, \"\");\n    using ll = int64_t;\n    int32_t fact[Size], finv[Size], inv[Size];\n    ModTable() {\n        fact[0] = fact[1] = finv[0] = finv[1] = inv[1] = 1;\n        for (int i = 2; i < Size; i++) {\n            fact[i] = ll(fact[i-1])*i % mod;\n            inv[i] = mod - ll(inv[mod%i])*(mod/i) % mod;\n            finv[i] = ll(finv[i-1])*inv[i] % mod;\n        }\n    }\n};\nconst ModTable<MOD> mod_tab;\n\nmodint<MOD> fact(int n) {\n    assert(0 <= n); assert(n < ModTable<MOD>::Size);\n    return mod_tab.fact[n];\n}\nmodint<MOD> finv(int n) {\n    assert(0 <= n); assert(n < ModTable<MOD>::Size);\n    return mod_tab.finv[n];\n}\nmodint<MOD> C(int n, int k) {\n    if (n < 0 || k < 0 || n < k) return 0;\n    return fact(n)*finv(k)*finv(n-k);\n}\nmodint<MOD> P(int n, int k) {\n    assert(k >= 0);\n    return fact(n)*finv(n-k);\n}\nmodint<MOD> sgn(int n) { return n%2 == 0 ? +1 : -1; }\n// <<<\n\nint32_t main() {\n    int n,m; cin >> n >> m;\n    auto a = make_v<int,2>(n,m); cin >> a;\n\n    int r = gauss_jordan(a);\n    mint ans = 0;\n    for (int i = 1; i <= r; i += 2) {\n        ans += C(r,i)*mint(3).pow(r-i)*mint(2).pow(n+m-2*r);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nll mo=998244353;\n\nconst int MAT=402;\nint A[402][402];\n\nint gf2_rank(int A[MAT][MAT]) { /* input */\n\tint i,j,k;\n\tFOR(i,H) {\n\t\tint be=i,mi=H+1;\n\t\tfor(j=i;j<H;j++) {\n\t\t\tFOR(k,W) if(A[j][k]) break;\n\t\t\tif(k<mi) be=j,mi=k;\n\t\t}\n\t\tif(mi>=H) break;\n\t\tFOR(j,W) swap(A[i][j],A[be][j]);\n\t\t\n\t\tFOR(j,H) if(i!=j&&A[j][mi]) {\n\t\t\tFOR(k,W) A[j][k] ^= A[i][k];\n\t\t}\n\t}\n\treturn i;\n}\n\nll dp[303][303];\nll p2[3030];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) FOR(x,W) cin>>A[y][x];\n\tgf2_rank(A);\n\t\n\tp2[0]=1;\n\tFOR(i,305) p2[i+1]=p2[i]*2%mo;\n\t\n\tdp[0][0]=1;\n\t\n\tFOR(y,H) {\n\t\tint num=0;\n\t\tFOR(x,W) num+=A[y][x];\n\t\t\n\t\tFOR(x,W+1) if(dp[y][x]) {\n\t\t\t(dp[y+1][x]+=dp[y][x])%=mo;\n\t\t\t(dp[y+1][x+num]+=dp[y][x])%=mo;\n\t\t}\n\t}\n\t\n\t\n\tll ret=0;\n\tfor(i=1;i<=W;i++) {\n\t\tret+=dp[H][i]*p2[i-1]%mo*p2[W-i]%mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nll mo=998244353;\n\nconst int MAT=402;\nint A[402][402];\nll dp[603][603];\nll p2[3030];\n\nint gf2_rank(int A[MAT][MAT]) { /* input */\n\tint i,j,k;\n\tFOR(i,H) {\n\t\tint be=i,mi=W+1;\n\t\tfor(j=i;j<H;j++) {\n\t\t\tFOR(k,W) if(A[j][k]) break;\n\t\t\tif(k<mi) be=j,mi=k;\n\t\t}\n\t\tif(mi>=W) break;\n\t\tFOR(j,W) swap(A[i][j],A[be][j]);\n\t\t\n\t\tFOR(j,H) if(i!=j&&A[j][mi]) {\n\t\t\tFOR(k,W) A[j][k] ^= A[i][k];\n\t\t}\n\t}\n\treturn i;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) FOR(x,W) cin>>A[y][x];\n\t\n\tp2[0]=1;\n\tFOR(i,305) p2[i+1]=p2[i]*2%mo;\n\t\n\tx=gf2_rank(A);\n\tll ret=(p2[x]+mo-1)*p2[H-x]%mo*p2[W-1]%mo;\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define MOD(x) ((x) >= mod ? (x) - mod : (x))\n#define ll long long\nusing namespace std;\nconst int maxn = 510, inf = 1e9 + 233, mod = 998244353;\nint n, m, ans, cnt;\nint a[maxn], b[maxn][maxn];\n\ntemplate<typename T>\ninline void read(T &k)\n{\n\tint f = 1; k = 0; char c = getchar();\n\twhile (c < '0' || c > '9') c == '-' && (f = -1), c = getchar();\n\twhile (c <= '9' && c >= '0') k = k * 10 + c - '0', c = getchar();\n\tk *= f;\n}\n\ninline int power(int a, int b)\n{\n\tint ans = 1; \n\tfor (; b; b >>= 1, a = 1ll * a * a % mod)\n\t\tif (b & 1) ans = 1ll * ans * a % mod;\n\treturn ans;\n}\n\nint main()\n{\n\tread(n); read(m); \n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tread(a[j]);\n\n\t\tbool flag = 1;\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tif (a[j])\n\t\t\t{\n\t\t\t\tif (b[j][0])\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 1; k <= m; k++)\n\t\t\t\t\t\ta[k] ^= b[j][k];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tb[j][0] = 1;\n\t\t\t\t\tfor (int k = 1; k <= m; k++)\n\t\t\t\t\t\tb[j][k] = a[k];\n\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\tcnt += flag;\n\t}\n\n\tans = power(2, n) - power(2, cnt) + mod; ans = MOD(ans);\n\tprintf(\"%lld\\n\", 1ll * ans * power(2, m - 1) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nvector<vector<int> > mat;\nint ma[334][334];\nlint mo=998244353;\nlint zyo(lint x,lint y){\n    lint ret=1,a=x;\n    while(y>0){\n    \tif(y%2==1) ret=(ret*a)%mo;\n    \ta=(a*a)%mo;y/=2;\n    }\n    return ret;\n}\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\trep(i,n) rep(j,m) cin>>ma[i][j];\n\tif(n<m){\n\t\trep(i,m) REP(j,i+1,m) swap(ma[i][j],ma[j][i]);\n\t}\n\tswap(n,m);\n\trep(i,n){\n\t\tvector<int> cl(m,0);\n\t\tmat.pb(cl);\n\t\trep(j,m) mat[i][j]=ma[i][j]%2;\n\t}\n\t//rep(i,n) rep(j,m) mat[i][j]%=2;\n\tint rank=0;\n\trep(i,m){\n\t\t//if(rank>=m) continue;\n\t\tREP(j,rank,n){\n\t\t\tif(mat[j][i]>0) swap(mat[j],mat[rank]);\n\t\t}\n\t\tif(mat[rank][i]<1){\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,n){\n\t\t\tif(mat[j][i]==mat[rank][i]) continue;\n\t\t\trep(k,m){\n\t\t\t\tmat[j][k]+=mat[rank][k];mat[j][k]%=2;\n\t\t\t}\n\t\t}\n\t\trank++;\n\t}\n\t//lint zyo=1;rep(i,rank) zyo=(zyo*2)%mo;zyo--;\n\tlint out=zyo(2,rank);out--;\n\tout*=zyo(2,m-1);out%=mo;\n\tout*=zyo(2,n-rank);out%=mo;\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define mp make_pair\n\nvoid print(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cout<<a[i]<<' ';\n    cout<<endl;\n}\n\nvoid get(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cin>>a[i];\n}\n\nconst ll p = 998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    s = s%p;\n    if (s<0) s+=p; \n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    \n    int n, m;\n    cin>>n>>m;\n    \n    vector<bitset<300>> a(n);\n    \n    bool t;\n    \n    for (int i = 0; i<n; i++)\n    for (int j = 0; j<m; j++) {cin>>t; a[i][j] = t;}\n    \n    vector<bool> visited(n);\n    \n    int degbasis = 0;\n    \n    for (int i = 0; i<m; i++)\n    {\n        int idx = 0;\n        while (idx<n && !(a[idx][i]==1&&!visited[idx])) idx++;\n        if (idx==n) continue;\n        visited[idx] = true;\n        degbasis++;\n        for (int i = 0; i<m; i++) if (i!=idx) a[i]^=a[idx];\n    }\n    \n    //cout<<degbasis<<endl;\n    \n    int total = po(2, m+n - 1);\n    //cout<<total<<endl;\n    total=add(total, -po(2, (m-degbasis)+n-1));\n    if (total<0) total+=p;\n    cout<<total;\n    \n}"
  },
  {
    "language": "C++",
    "code": "/************************************************\n * Au: Hany01\n * Date: Feb 10th, 2019\n * Prob: yahoo2019_e\n * Email: hany01dxx@gmail.com & hany01@foxmail.com\n * Inst: Yali High School\n************************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\n#define Rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define X first\n#define Y second\n#define PB(a) push_back(a)\n#define MP(a, b) make_pair(a, b)\n#define SZ(a) ((int)(a).size())\n#define ALL(a) a.begin(), a.end()\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 WoXiHuanNiA\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate <typename T> inline T read() {\n\tregister T _, __; register char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n//EOT\n\n\nconst int MAXN = 305;\n\nint n, m, a[MAXN][MAXN];\n\nint main() {\n#ifdef hany01\n\tfreopen(\"yahoo2019_e.in\", \"r\", stdin);\n\tfreopen(\"yahoo2019_e.out\", \"w\", stdout);\n#endif\n\n\tn = read<int>(), m = read<int>();\n\tFor(i, 1, n) For(j, 1, m)\n\t\ta[i][j] = read<int>() ^ a[i - 1][j] ^ a[i][j - 1] ^ a[i - 1][j - 1];\n\n\tLL ans = 0;\n\tFor(l1, 0, n - 1) For(l2, l1 + 1, n) {\n\t\tint cnt[2] = {0, 0};\n\t\tFor(i, 0, m) {\n\t\t\tint t = a[l1][i] ^ a[l2][i];\n\t\t\tans += cnt[t ^ 1], ++ cnt[t];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n,m,a[N][N];\nll qpow(ll a,ll n)\n{\n    ll ans=1;\n    while(n)\n    {\n        if(n&1) ans=ans*a%mod;\n        a=a*a%mod;\n        n>>=1;\n    }\n    return ans;\n}\nint guass(int n)\n{\n    int ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        int p=i;\n        while(p<=n&&!a[i][p]) p++;\n        if(p==n+1) {ans++;continue;}\n        swap(a[i],a[p]);\n        for(int j=i+1;j<=n;j++)\n            if(a[j][i])\n            for(int k=i;k<=n;k++)\n            a[j][k]^=a[i][k];\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        scanf(\"%d\",&a[i][j]);\n    int s=max(n,m);\n    int ans=guass(s);\n    if(n>m) ans-=n-m;\n    printf(\"%lld\\n\",qpow(2,n-1)*(qpow(2,m)+mod-qpow(2,ans))%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n \n \nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 302\n\nint n;\nint m;\n\nbitset<MAX> ar[MAX];\nvector<bitset<MAX> > basis;\n\n\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tar[i].set(j,a);\n\t\t}\n\t}\n\tauto cmp=[&](bitset<MAX> a,bitset<MAX> b){\n\t\tauto sz=(MAX+63)/64;\n\t\tauto a_=(const uint64_t *)&a;\n\t\tauto b_=(const uint64_t *)&b;\n\t\tfor(int i=sz-1;i>=0;i--){\n\t\t\tif(a_[i]==b_[i])continue;\n\t\t\treturn a_[i]<b_[i];\n\t\t}\n\t\treturn false;\n\t};\n\tfor(int i=0;i<n;i++){\n\t\tsort(basis.begin(),basis.end(),cmp);\n\t\tfor(int j=basis.size()-1;j>=0;j--){\n\t\t\tauto tmp=(basis[j]^ar[i]);\n\t\t\tif(cmp(tmp,ar[i])){\n\t\t\t\tswap(ar[i],tmp);\n\t\t\t}\n\t\t}\n\t\tif(ar[i].any()){\n\t\t\tbasis.push_back(ar[i]);\n\t\t}\n\t}\n\tlong long int ans=sub(ppow(2,n),ppow(2,n-basis.size()));\n\tmulto(ans,ppow(2,m-1));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/************************************************\n * Au: Hany01\n * Date: Feb 10th, 2019\n * Prob: yahoo2019_e\n * Email: hany01dxx@gmail.com & hany01@foxmail.com\n * Inst: Yali High School\n************************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\n#define Rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define X first\n#define Y second\n#define PB(a) push_back(a)\n#define MP(a, b) make_pair(a, b)\n#define SZ(a) ((int)(a).size())\n#define ALL(a) a.begin(), a.end()\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 WoXiHuanNiA\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate <typename T> inline T read() {\n\tregister T _, __; register char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n//EOT\n\n\nconst int MAXN = 305, MOD = 998244353;\n\nint fpm(int a, int b = MOD - 2) {\n\tint ans = 1;\n\tfor ( ; b; b >>= 1, a = (LL)a * a % MOD)\n\t\tif (b & 1) ans = (LL)ans * a % MOD;\n\treturn ans;\n}\n\ntypedef bitset<MAXN> BS;\n\nint n, m;\nBS a[MAXN];\n\nstruct LinearBase {\n\tBS c[MAXN];\n\tint cnt;\n\tLinearBase() { cnt = 0; }\n\tvoid insert(BS a) {\n\t\tFordown(i, n, 1)\n\t\t\tif (a.test(i)) {\n\t\t\t\tif (!c[i].test(i)) {\n\t\t\t\t\tc[i] = a;\n\t\t\t\t\tbreak;\n\t\t\t\t} else a ^= c[i];\n\t\t\t}\n\t\tif (!a.any()) ++ cnt;\n\t}\n}B;\n\nint main() {\n#ifdef hany01\n\tfreopen(\"yahoo2019_e.in\", \"r\", stdin);\n\tfreopen(\"yahoo2019_e.out\", \"w\", stdout);\n#endif\n\n\tn = read<int>(), m = read<int>();\n\tFor(i, 1, n) {\n\t\tFor(j, 1, m) a[i][j] = read<int>();\n\t\tB.insert(a[i]);\n\t}\n\n\tprintf(\"%lld\\n\", (LL)(fpm(2, n) + MOD - fpm(2, B.cnt)) % MOD * fpm(2, m - 1) % MOD);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MaxN = 303;\n\nint a[MaxN][MaxN];\nint n, m;\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n\n    cin >> n >> m;\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= m; ++j)\n            cin >> a[i][j];\n\n    int r = 0;\n\n    for(int i = 1; i <= m; ++i)\n    {\n        int y = 0;\n        for(int j = 1; y == 0 && j <= n; ++j)\n            if(a[j][i] == 1)\n                y = j;\n\n        if(!y)\n            continue;\n\n        ++r;\n\n        for(int j = 1; j <= n; ++j)\n            if(a[j][i] == 1 && j != y)\n                for(int k = i; k <= m; ++k)\n                    a[j][k] ^= a[y][k];\n\n        for(int k = i; k <= m; ++k)\n            a[y][k] = 0;\n    }\n\n    int ans = 1;\n\n    for(int i = 1; i <= n + m - 1 - r; ++i)\n        ans = (ans + ans) % MOD;\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst long long maxn = 310;\nconst long long mod = 998244353;\nlong long n , m;\nlong long a[maxn][maxn];\nlong long s[maxn][maxn];\nlong long r;\nlong long pow ( long long x ) {\n\tlong long s = 1 , f = 2;\n\twhile ( x ) {\n\t\tif ( x % 2 ) s = ( s * f ) % mod;\n\t\tf = ( f * f ) % mod; x = x / 2;\n\t}\n\treturn s;\n}\nvoid work () {\n\tlong long i , j , k;\n\tscanf ( \"%lld%lld\" , &n , &m );\n\tfor ( i = 1 ; i <= n ; i++ )\n\t\tfor ( j = 1 ; j <= m ; j++ )\n\t\t\tscanf ( \"%lld\" , &a[i][j] );\n\tfor ( i = 1 ; i <= n ; i++ ) {\n\t\tfor ( j = 1 ; j <= m ; j++ ) {\n\t\t\tif ( s[j][j] == 0 && a[i][j] == 1 ) {\n\t\t\t\tfor ( k = 1 ; k <= m ; k++ ) {\n\t\t\t\t\ts[j][k] = a[i][k];\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( a[i][j] == 1 && s[j][j] == 1 )\n\t\t\t\tfor ( k = 1 ; k <= m ; k++ ) {\n\t\t\t\t\ta[i][k] ^= s[j][k];\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf ( \"%lld\\n\" , ( pow ( n + m - 1 ) - pow ( n + m - r - 1 ) + mod ) % mod );\n}\nint main () {\n\twork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n,m,a[N][N];\nbitset<N>b[N];\nll qpow(ll a,ll n)\n{\n    ll ans=1;\n    while(n)\n    {\n        if(n&1) ans=ans*a%mod;\n        a=a*a%mod;\n        n>>=1;\n    }\n    return ans;\n}\nint guass(int n)\n{\n    int ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        int p=i;\n        while(p<=n&&!b[p][i]) p++;\n        if(p==n+1) {ans++;continue;}\n        swap(b[i],b[p]);\n        for(int j=i+1;j<=n;j++)\n            if(b[j][i])\n                b[j]^=b[i];\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        scanf(\"%d\",&a[i][j]);\n    int s=max(n,m);\n    for(int i=1;i<=s;i++)\n        for(int j=1;j<=s;j++)\n        b[i].set(j,a[i][j]);\n    int ans=guass(s);\n    if(n>m) ans-=n-m;\n    printf(\"%lld\\n\",qpow(2,n-1)*(qpow(2,m)+mod-qpow(2,ans))%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n//const ll MOD = 1e9+7;\nconst ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<ll mod> struct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x (y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    Mod_Int &operator += (const Mod_Int &p) {\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p) {\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p) {\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int &operator ++ () {return *this += (Mod_Int)1;}\n\n    Mod_Int operator ++ (int) {\n        Mod_Int tmp = *this;\n        ++*this;\n        return tmp;\n    }\n\n    Mod_Int &operator -- () {return *this -= (Mod_Int)1;}\n\n    Mod_Int operator -- (int) {\n        Mod_Int tmp = *this;\n        --*this;\n        return tmp;\n    }\n\n    Mod_Int operator - () const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow (ll n) const {\n        Mod_Int now = *this, ret = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse () const {\n        return pow(mod-2);\n    }\n};\n\nusing mint = Mod_Int<MOD>;\nconst int MAX_N = 1e6;\nmint fac[MAX_N+1], ifac[MAX_N+1];\n\nvoid init(){\n    fac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = fac[i-1]*i;\n    }\n    ifac[MAX_N] = fac[MAX_N].inverse();\n    rep3(i, MAX_N, 1){\n        ifac[i-1] = ifac[i]*i;\n    }\n}\n\nmint comb(int n, int k){\n    return fac[n]*ifac[n-k]*ifac[k];\n}\n\nmint perm(int n, int k){\n    return fac[n]*ifac[n-k];\n}\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\n\nint mat_rank(mat &A){\n    int m = sz(A), n = sz(A[0]);\n    int now = 0, ret = 0;\n    rep(j, n){\n        int pivot = now;\n        rep2(i, now, m-1){\n            if(abs(A[i][j]) > abs(A[pivot][j])) pivot = i; \n        }\n        swap(A[now], A[pivot]);\n        if(A[now][j] == 0) continue;\n        ret++;\n        rep(i, m){\n            rep2(k, j, m-1){\n                A[i][k] ^= (A[i][j]*A[now][k]);\n            }\n            A[i][j] = 0;\n        }\n        now++;\n        if(now == m) break;\n    }\n    return ret;\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    mat A(N, vec(M));\n    rep(i, N){\n        rep(j, M) cin >> A[i][j];\n    }\n    int r = mat_rank(A);\n    mint ans, tw = 2;\n    ans = tw.pow(N+M-1) - tw.pow(N+M-r-1);\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 998244353LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                // C[i][j] += A[i][k] * B[k][j]; // modなし\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// Matrix Library End\n\n// N * M 行列のランクを求める\ntemplate <typename T>\nint mat_rank(Matrix<T> A) {\n    int N = A.size(), M = A[0].size();\n\n    int res = 0;\n    for(int i=0; i<M; i++) {\n        // 絶対値が最も大きいものを探す\n        T max_elem = 0; int piv = -1;\n        for(int j=res; j<N; j++) {\n            if(abs(A[j][i]) > max_elem) {\n                max_elem = abs(A[j][i]);\n                piv = j;\n            }\n        }\n\n        // fprintf(stderr, \"# piv = %lld\\n\", piv);\n        if(piv < 0) continue;\n            \n        // res 行目を piv 行目に変えて、行基本変形\n        swap(A[res], A[piv]);\n\n        // res 行目を正規化\n        // 行列が整数の場合とかやばそう\n        // 基本的に引数は double の行列に限定すべきでは？\n\n\n        // 0, 1 しか登場しないし今回はいらない\n        /*\n        for(int k=0; k<M; k++) {\n            A[res][k] = (T)(1.0 * A[res][k] / A[res][i]);\n        }\n        */\n        \n        for(int j=0; j<N; j++) {\n            if(j == res) continue;\n            assert(A[res][i] != 0);\n            T mul = A[j][i];\n            for(int k=0; k<M; k++) {\n                // A[j][k] = (T)(A[j][k] - mul * A[res][k]);\n\n                // 0, 1 しか出ないし xor で良い\n                A[j][k] = A[j][k] ^ (mul * A[res][k]);\n            }\n        }\n        res++;\n\n        /*\n        fprintf(stderr, \"# matrix debug\\n\");\n        for(int x=0; x<N; x++) {\n            for(int y=0; y<M; y++) {\n                fprintf(stderr, \"%lld \", A[x][y]);\n            }\n            fprintf(stderr, \"\\n\");\n        }\n        */\n    }\n    return res;\n}\n\nconst int MAXN = 610;\nint pow2[MAXN + 10];\nsigned main() {\n    pow2[0] = 1;\n    for(int i=1; i<=MAXN; i++) pow2[i] = (pow2[i-1] * 2) % MOD;\n    \n    int N, M; cin >> N >> M;\n    Matrix<int> mat;\n    init_mat(mat, N, M);\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            cin >> mat[i][j];\n        }\n    }\n\n    int rank = mat_rank(mat);\n    int ansA = pow2[N + M - 1];\n    int ansB = pow2[N + M - rank - 1];\n    fprintf(stderr, \"matrix rank = %lld\\n\", rank);\n    printf(\"%lld\\n\", (ansA - ansB + MOD) % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define FOR(i,k,n) for(int(i)=(k);(i)<(n);++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v),end(v)\n#define debug(x) std::cerr<<#x<<\": \"<<x<<\"\\n\"\n#define debug2(x,y) std::cerr<<#x<<\": \"<<x<<\", \"<<#y<<\": \"<<y<<\"\\n\"\n#define debug3(x,y,z) std::cerr<<#x<<\": \"<<x<<\", \"<<#y<<\": \"<<y<<\", \"<<#z<<\": \"<<z<<\"\\n\"\n\ntypedef long long ll;\ntypedef std::vector<int> vi;\ntypedef std::vector<vi> vvi;\ntypedef std::vector<ll> vll;\ntypedef std::vector<vll> vvll;\ntemplate<typename T> using vvec=std::vector<std::vector<T>>;\ntemplate<typename T>\nauto make_v(size_t sz){return std::vector<T>(sz);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t sz,Ts...ts){return std::vector<decltype(make_v<T>(ts...))>(sz,make_v<T>(ts...));}\ntemplate<typename T>\nvoid fill_v(T&var,const T&x){var=x;}\ntemplate<typename V,typename T>\nvoid fill_v(V&v,const T&x){for(auto&& w:v){fill_v(w,x);}}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::vector<T>&v){\n  int sz=v.size();s<<\"\\n\";rep(i,sz){s<<v[i];if(i<sz-1){s<<\"\\t\";}}s<<\"\\n\";return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::vector<std::vector<T>>&v){\n  for(auto&& w:v){s<<w;}return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::deque<T>&v){\n  int sz=v.size();s<<\"\\n\";rep(i,sz){s<<v[i];if(i<sz-1){s<<\"\\t\";}}s<<\"\\n\";return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s,const std::deque<std::deque<T>>&v){\n  for(auto&& w:v){s<<w;}return s;}\ntemplate<typename T> std::ostream& operator<<(std::ostream&s, const std::set<T>&v){\n  s<<\"\\n\";for(auto&& elm:v){s<<elm<<\"\\t\";}s<<\"\\n\";return s;}\n\ninline void scan(int&a){scanf(\"%d\",&a);}\ninline void scan(ll&a){scanf(\"%lld\",&a);}\ninline void scan(char&a){scanf(\" %c\",&a);}\ninline void scan(double&a){scanf(\"%lf\",&a);}\ntemplate<typename T>\ninline void scan(std::vector<T>&v){for(auto&& sv:v){scan(sv);}}\ntemplate<typename First,typename...Args>\ninline void scan(First&f,Args&...args){scan(f);scan(args...);}\ninline void scan(std::string&s){char BUF[3000000];scanf(\" %s\",BUF);s=std::string(BUF);}\ninline void print(int a){printf(\"%d\\n\",a);}\ninline void print(ll a){printf(\"%lld\\n\",a);}\ninline void print(double a){printf(\"%.12f\\n\",a);}\ninline void print(std::string s){std::cout<<s<<\"\\n\";}\n\nusing namespace std;\n\nll mod = 998244353;\n\n/*\n * 選ぶ行を決めた時，ある列を選んだ時mod2で和が+1となるか+0となるかが決まる\n * このとき+1の列の数と+0の列の数のみで場合の数が決まる\n * よって+1の列の数が0〜Mとなるケースのそれぞれについて行の選び方の場合の数が分かればよい\n */\n\nll gcd(ll a, ll b) {\n  if (a < 0) { a *= (-1); }\n  if (b < 0) { b *= (-1); }\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n  if (a < 0) { a *= (-1); }\n  if (b < 0) { b *= (-1); }\n  return a / gcd(a, b) * b;\n}\n\nvvll gaussian_elimination_mod2(vvll a) {\n  int n = a.size();\n  int m = a[0].size();\n  int k_add = 0;\n  rep (k, n) {\n    while (true) {\n      if (k + k_add >= m) {\n        return a;\n      }\n      if (a[k][k + k_add] == 0) {\n        FOR (i, k+1, n) {\n          if (a[i][k + k_add] != 0) {\n            swap(a[k], a[i]);\n            break;\n          }\n        }\n      }\n      if (a[k][k + k_add] != 0) {\n        break;\n      } else {\n        k_add += 1;\n      }\n    }\n    FOR (i, k+1, n) {\n      if (a[i][k + k_add] == 0) { continue; }\n      FOR (j, k + k_add, m) {\n        a[i][j] = a[i][j] - a[k][j];\n        if (a[i][j] == -1) { a[i][j] *= (-1); }\n      }\n    }\n  }\n  return a;\n}\n\nint calc_rank(vvll a) {\n  int n = a.size();\n  int m = a[0].size();\n  int ret = 0;\n  rep (i, n) {\n    rep (j, m) {\n      if (a[i][j] != 0) {\n        ret += 1;\n        break;\n      }\n    }\n  }\n  return ret;\n}\n\nll po(ll k, ll x) {\n  if (x == 0) {\n    return 1;\n  }\n  if (x == 1) {\n    return k % mod;\n  }\n  ll y = po(k, x/2);\n  y = y * y % mod;\n  if (x % 2 == 1) {\n    y = y * k % mod;\n  }\n  return y;\n}\n\nint main() {\n  int n, m;\n  scan(n, m);\n  vvll a(n, vll(m));\n  scan(a);\n\n  auto b = gaussian_elimination_mod2(a);\n  int rank_a = calc_rank(b);\n\n  ll ans = po(2, n) - po(2, n - rank_a) + mod;\n  ans %= mod;\n  ans = (ans * po(2, m-1)) % mod;\n  print(ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int p=998244353;\nint n,m,a[505][505],pw[505];\nbitset<505> b[505];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tbitset<505> x;\n\t\tfor(int j=1,y;j<=m;j++){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tx[j-1]=y;\n\t\t}\n\t\tfor(int j=m-1;j>=0;j--)\n\t\t\tif(b[j].any())x^=b[j];\n\t\t\telse{b[j]=x;break;}\n\t}\n\tfor(int i=pw[0]=1;i<=n||i<=m;i++)pw[i]=2*pw[i-1]%p;\n\tint rk=0;\n\tfor(int i=0;i<=m-1;i++)if(b[i].any())rk++;\n\tint ans=1ll*(pw[n]-pw[n-rk])*pw[m-1]%p;\n\tprintf(\"%d\\n\",(ans+p)%p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=998244353;\nlong long n,m,a[333][333],pw[666],cnt,pos,cur,upper;\n/*long long Guass(long long Row,long long Column)\n{\n    long long row=1,col=1,max_r;\n    for(row=1;row<=Row&&col<=Column;row++,col++)\n    { \n        max_r=row;\n        for(long long i=row+1;i<=Row;i++)\n            if(abs(a[i][col])>abs(a[max_r][col]))\n                max_r=i;\n        if(a[max_r][col]==0)\n        {\n            row--;\n            continue;\n        }\n        if(max_r!=row)\n            for(long long i=col;i<=Column;i++)\n                swap(a[row][i],a[max_r][i]);\n\n        for(long long i=row+1;i<=Row;i++)\n        {\n            if(a[i][col]!=0)\n            {\n\n                for(long long j=col;j<=Column;j++)\n                    a[i][j]^=a[row][j];\n            }\n        }\n    }\n\treturn Column-row+1;\n}*/\nvoid gauss()\n{\n\tupper=1;\n\tfor (long long i=1;i<=m;i++)\n\t{\n\t\tpos=-1;\n\t\tfor (long long j=upper;j<=n;j++)\n\t\t{\n\t\t\tif (a[j][i])\n\t\t\t{\n\t\t\t\tpos=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~pos)\n\t\t{\n\t\t\tcnt++;\n\t\t\tfor (long long j=1;j<=m;j++) swap(a[upper][j],a[pos][j]);\n\t\t\tfor (long long j=upper+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif (a[j][i])\n\t\t\t\t{\n\t\t\t\t\tfor (long long k=i;k<=m;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][k]^=a[upper][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupper++;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tfor (long long j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tpw[0]=1;\n\tfor (long long i=1;i<=600;i++) pw[i]=pw[i-1]*2%mod;\n\tgauss();\n\tcur=pw[m-cnt];\n\tprintf(\"%lld\\n\",((pw[n+m-1]-pw[n-1]*cur)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int MN = 305, P = 998244353;\n\ntypedef std::bitset<MN> bst;\n\nbst val[MN], vec[MN];\n\nint n, m, cnt;\n\ninline int fpw(int x, int k) {\n\tint res = 1;\n\tfor (; k; k >>= 1, x = (ll) x * x % P)\n\t\tif (k & 1) res = (ll) res * x % P;\n\treturn res;\n}\n\ninline int read() {\n\tint x; bool f; char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tval[i][j] = read();\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = m; j--; )\n\t\t\tif (val[i][j]) {\n\t\t\t\tif (vec[j].count()) val[i] ^= vec[j];\n\t\t\t\telse {\n\t\t\t\t\t++cnt;\n\t\t\t\t\tvec[j] = val[i];\n\t\t\t\t\tfor (int k = j; k--; )\n\t\t\t\t\t\tif (vec[j][k]) vec[j] ^= vec[k];\n\t\t\t\t\tfor (int k = j; ++k < m; )\n\t\t\t\t\t\tif (vec[k][j]) vec[k] ^= vec[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\tprintf(\"%lld\\n\", (ll)fpw(2, m - 1) * (fpw(2, n) - fpw(2, n - k) + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nint n,m,a[310][310];\nint od[310],ev[310],bit[310];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n/*\tfor(int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tprintf(\"%d \",a[i][j]);\n*/\n\n/*\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=m;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n*/\tint cnt=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i]) continue;\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=m;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=n;i++) bit[i]=2ll*bit[i-1]%mod;\n//\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n//\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n\tint ans=1ll*(bit[n]-bit[n-cnt]+mod)%mod*bit[m-1]%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nll ans = 0;\nconst ll mo = 998244353;\nll mypow(ll a, ll b)\n{\n  ll res = 1;\n  a %= mo;\n  while (b)\n  {\n    if (b & 1)\n      res = res * a % mo;\n    a = a * a % mo;\n    b >>= 1;\n  }\n  return res;\n}\nint main()\n{\nll n , m ;\ncin >> n >> m ;\nvector<vector<ll>> v(n, vector<ll>(m,0) );\nrep(i,n)rep(j,m)cin >> v[i][j];\nrep(j,m){\n  bool a=0;\n  ll ind=0;\n  rep(i,n){\n    if(v[i][j]&&a==0){a=1;ind=i;}\n    else if(v[i][j]&&a){\n      rep(k,m){\n        v[i][k]=(v[i][k]+v[ind][k])%2;\n      }\n    }\n  }\n}\nll c=0;\nrep(i,n){\n  ll t=0;\n  rep(j,m)t+=v[i][j];\n  if(t==0)c++;\n}\nauto modmul = [](auto... modx) {\n  ll res = 1;\n  for (auto modx_ : {modx...})\n  {\n    res *= modx_;\n    res %= mo;\n  }\n  return res;\n};\nans=modmul(mypow(2,m-1),mypow(2,n)-mypow(2,c));\ncout << ans << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=300,MAX_M=300;\nconst  ll MOD=998244353;\nint N,M;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nmat mt;\nll mpw(ll n,ll m){\n\tll ret=1;\n\twhile(m){\n\t\tif(m&1){\n\t\t\tret*=n;\n\t\t\tret%=MOD;\n\t\t}\n\t\tn*=n;\n\t\tn%=MOD;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>N>>M;\n\tmt.resize(N);\n\tREP(i,N){\n\t\tmt[i].resize(M);\n\t}\n\tREP(i,N){\n\t\tREP(j,M){\n\t\t\tcin>>mt[i][j];\n\t\t}\n\t}\n\tint c=0,i=0;\n\twhile(i<N && c<M){\n\t\tint pvt=i;\n\t\tFOR(j,i+1,N){\n\t\t\tif(mt[j][c]>mt[pvt][c])pvt=j;\n\t\t}\n\t\tswap(mt[i],mt[pvt]);\n\t\tif(mt[i][c]==0){\n\t\t\tc++;\n\t\t\tcontinue;\n\t\t}\n\t\tFOR(j,i+1,N){\n\t\t\tif(mt[j][c]==1){\n\t\t\t\tFOR(k,c,M){\n\t\t\t\t\tmt[j][k]-=mt[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tint r=-1;\n\tREP(i,N)REP(j,M){\n\t\tif(mt[i][j]==1)\n\t\t\tr=i;\n\t}\n\tr++;\n\tcout<<mpw(2,N-r)*(mpw(2,r)+MOD-1)%MOD*mpw(2,M-1)%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=998244353;\nlong long n,m,a[333][333],pw[666],cnt,pos,cur,upper;\n/*long long Guass(long long Row,long long Column)\n{\n    long long row=1,col=1,max_r;\n    for(row=1;row<=Row&&col<=Column;row++,col++)\n    { \n        max_r=row;\n        for(long long i=row+1;i<=Row;i++)\n            if(abs(a[i][col])>abs(a[max_r][col]))\n                max_r=i;\n        if(a[max_r][col]==0)\n        {\n            row--;\n            continue;\n        }\n        if(max_r!=row)\n            for(long long i=col;i<=Column;i++)\n                swap(a[row][i],a[max_r][i]);\n\n        for(long long i=row+1;i<=Row;i++)\n        {\n            if(a[i][col]!=0)\n            {\n\n                for(long long j=col;j<=Column;j++)\n                    a[i][j]^=a[row][j];\n            }\n        }\n    }\n\treturn Column-row+1;\n}*/\nvoid gauss()\n{\n\tupper=1;\n\tfor (long long i=1;i<=m;i++)\n\t{\n\t\tpos=-1;\n\t\tfor (long long j=upper;j<=n;j++)\n\t\t{\n\t\t\tif (a[j][i])\n\t\t\t{\n\t\t\t\tpos=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~pos)\n\t\t{\n\t\t\tfor (long long j=1;j<=m;j++) swap(a[upper][j],a[pos][j]);\n\t\t\tfor (long long j=upper+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif (a[j][i])\n\t\t\t\t{\n\t\t\t\t\tfor (long long k=i;k<=m;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][k]^=a[upper][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupper++;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tfor (long long j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tpw[0]=1;\n\tfor (long long i=1;i<=600;i++) pw[i]=pw[i-1]*2%mod;\n\tgauss();\n\tcur=pw[m-upper];\n\tprintf(\"%lld\\n\",((pw[n+m-1]-pw[n-1]*cur)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define bp __builtin_popcountll\n#define pb push_back\n#define in(s) freopen(s, \"r\", stdin);\n#define out(s) freopen(s, \"w\", stdout);\n#define inout(s, end1, end2) freopen((string(s) + \".\" + end1).c_str(), \"r\", stdin),\\\n\t\tfreopen((string(s) + \".\" + end2).c_str(), \"w\", stdout);\n#define fi first\n#define se second\n#define bw(i, r, l) for (int i = r - 1; i >= l; i--)\n#define fw(i, l, r) for (int i = l; i < r; i++)\n#define fa(i, x) for (auto i: x)\nusing namespace std;\nconst int mod = 998244353, inf = 1061109567;\nconst long long infll = 4557430888798830399;\nconst int N = 305;\nint n, m, a[N][N], cnt[N], pw[N], equation[N][N], ans[N];\nvoid add(int &x, int y) {\n\tx += y; if (x >= mod) x -= mod;\n}\nint rem(int x, int y) {\n\tx -= y;\n\tif (x < 0) x += mod;\n\treturn x;\n}\nint mul(int x, int y) {\n\treturn 1ll * x * y % mod;\n}\nsigned main() {\n\t#ifdef BLU\n\tin(\"blu.inp\");\n\t#endif\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tpw[0] = 1;\n\tfw (i, 1, N) pw[i] = mul(pw[i - 1], 2);\n\tcin >> n >> m;\n\tfw (i, 0, n) {\n\t\tfw (j, 0, m) cin >> a[i][j];\n\t}\n\t//Fix subset of rows, if there is at least 1 odd column answer is 2 ^ (m - 1), else 0.\n\t//Count subset of rows that there are no odd columns. Use Gauss.\n\tfw (j, 0, m) ans[j] = 0;\n\tfw (j, 0, m) {\n\t\tfw (i, 0, n) equation[j][i] = a[i][j];\n\t}\n\tint cnt = 1, ptr = 0;\n//\tfw (lol, 0, m) {\n//\t\tcout << \"Equation \" << lol << \": \";\n//\t\tfw (lol2, 0, n) cout << equation[lol][lol2] << \" \";\n//\t\tcout << \"\\n\";\n//\t}\n\tfw (i, 0, n) {\n//\t\tcout << \"Variable \" << i << \"\\n\";\n\t\tbool have1 = 0;\n\t\tfw (j, ptr, m) if (equation[j][i]) have1 = 1;\n\t\tif (have1) {\n\t\t\tfw (j, ptr, m) if (equation[j][i]) {\n\t\t\t\tfw (k, 0, n) swap(equation[j][k], equation[ptr][k]);\n\t\t\t\tswap(ans[j], ans[ptr]);\n//\t\t\t\tcout << \"swap equation \" << j << \" with \" << ptr << \"\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfw (j, ptr + 1, m) if (equation[j][i]) {\n\t\t\t\tfw (k, 0, n) equation[j][k] ^= equation[ptr][k];\n\t\t\t\tans[j] ^= ans[ptr];\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n//\t\tfw (lol, 0, m) {\n//\t\t\tcout << \"Equation \" << lol << \": \";\n//\t\t\tfw (lol2, 0, n) cout << equation[lol][lol2] << \" \";\n//\t\t\tcout << \"\\n\";\n//\t\t}\n\t}\n\tcnt = pw[n - ptr];\n\tcnt = rem(pw[n], cnt);\n\tcnt = mul(cnt, pw[m - 1]);\n\tcout << cnt;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void read(T &x)\n{\n    x=0; char c=getchar();  int f=1;\n    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\n#include <bitset>\nconst int mod=998244353;\nll Pow(ll x,ll y){ll res=1; while(y){if(y&1) res=res*x%mod; x=x*x%mod,y>>=1;} return res;}\nbitset<310> f[310];\nint n,m;\nvoid print()\n{\n\tfor(int i=0;i<n;++i,puts(\"\"))\n\t{\n\t\tfor(int j=0;j<m;++j) printf(\"%d \",f[i][j]==1);\n\t}\n\tputs(\"\");\n}\nint main()\n{\n\tint x; read(n),read(m);\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j) read(x),f[i][j]=x;\n\tint ans=0;\n\tfor(int i=0;i<m;++i)\n\t{\n\t\tfor(int j=0;j<n;++j) if((!f[j][j]||j>=i)&&f[j][i]){if(j!=i)swap(f[i],f[j]); break;}//必须循环到n \n\t\tif(!f[i][i]){ans++; continue;}\n\t\tfor(int j=0;j<n;++j) if(j!=i&&f[j][i]) f[j]^=f[i];\n//\t\tprint(); \n\t}\n\tcout<<ans<<endl;\n\tprintf(\"%lld\",((Pow(2,m+n-1)-Pow(2,ans+n-1))%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    using mint = mod_int<998244353>;\n    vector a(N, vint(M));\n    rep(i, N) rep(j, M) { cin >> a[i][j]; }\n    int r = 0;\n    rep(i, min(N, M)) {\n        sort(a.begin() + i, a.begin() + N), reverse(a.begin() + i, a.begin() + N);\n        if (a[i][i]) { r++; }\n        for (int j = i + 1; j < N; j++) {\n            if (a[i][i] == a[j][i]) {\n                for (int k = i; k < M; k++) { a[j][k] ^= a[i][k]; }\n            }\n        }\n    }\n    cout << mint(2).pow(N + M - 1) - mint(2).pow(N + M - r - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n \nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n \nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n \n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[rank]);\n                ok = true;\n                break;\n            }\n        }\n \n        if(!ok) continue;\n \n \n        for(int j = i+1; j < n; j++) if(mat[j][i]) {\n \n            for(int k = i; k < n; k++) {\n \n                mat[j][k] ^= mat[i][k];\n            }\n        }\n \n        rank++;\n    }\n \n    return rank;\n}\n \n \n \nconst long long __exp_template_MOD = MOD;\n \nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n \nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n \n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n \nvoid init() {\n    \n \n \n}\n \nint main () {\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 310;\nconst int moder = 998244353;\n\nstd::bitset <N> set[N];\nint power[N];\n\nint main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; ++ i){\n        for (int j = 0; j < m; ++ j){\n            int x;\n            scanf(\"%d\", &x);\n            set[i][j] = x;\n        }\n    }\n    int now = 0;\n    for (int i = 0; i < m; ++ i){\n        for (int j = now; j < n; ++ j){\n            if (set[j][i]){\n                std::swap(set[now], set[j]);\n                break;\n            }\n        }\n        if (!set[now][i]){\n            continue;\n        }\n        for (int j = now + 1; j < n; ++ j){\n            if (set[j][i]){\n                set[j] ^= set[now];\n            }\n        }\n        ++ now;\n    }\n    power[0] = 1;\n    for (int i = 1; i < N; ++ i){\n        power[i] = 2 * power[i - 1] % moder;\n    }\n    int ans = (1ll * power[n] * (power[m - 1]) - 1ll * power[n - now] * power[m - 1]) % moder;\n    ans += ans < 0 ? moder : 0;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LL long long\n#define _rep(i,j,N) for(int i = (j);i <=(N);i++)\n#define _for(i,j,N) for(int i = (j);i <(N);i++)\n#define ALL(x) x.begin(),x.end()\n\nconst int mod = 998244353;\nconst int maxn = 305;\nint N,M;\nstring G[maxn];\n\nvoid xors(string &a,string &b){\n    _for(i,0,M){\n        if(a[i] == b[i]) b[i] = '0';\n        else b[i] = '1';\n    }\n}\n\nint pow_mod(int a,int n,int m){\n    if(n == 0) return 1;\n    int x = pow_mod(a,n/2,m);\n    LL ans = ((LL)x * x) % m;\n    if(n & 1) ans = ans * a % m;\n    return (int) ans;\n\n}\n\nint main()\n{\n    cin >> N >> M;\n    _for(i,0,N){\n        _for(j,0,M){\n            string s;\n            cin >> s;\n            G[i].push_back(s[0]);\n        }\n    }\n\n    int r = -1;\n    _for(i,0,N){\n        sort(G+i,G+N,greater<string>());\n        int index = -1;\n        _for(j,0,M) if(G[i][j] == '1'){index = j;break;}\n        if(index == -1){r = i;break;}\n        _for(j,i+1,N){\n            if(G[j][index] == '1'){\n                xors(G[i],G[j]);\n            }\n        }\n    }\n    if(r == -1) r = N;\n    int a = pow_mod(2,M+N-1,mod);\n    int b = pow_mod(2,M+N-r-1,mod);\n    int ans = ((LL)a - b + mod)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst ll MOD = 998244353;\nconst long double EPS = 1e-10;\nconst int dyx[4][2] = {\n    { 0, 1}, {-1, 0}, {0,-1}, {1, 0}\n};\n\nint n,m;\nvector< vector<int> > a(300, vector<int>(300, 0));\n\nint calc_rank(vector< vector<int> > a) {\n    // int n = a.size(), m = a[0].size();\n\n    int ii = 0;\n    for(int j=0;j<m;++j) {\n        bool all_zero = true;\n        int idx = -1;\n        for(int i=ii;i<n;++i) {\n            if(a[i][j]) {\n                if(all_zero) {\n                    idx = i;\n                    all_zero = false;\n                } else {\n                    for(int jj=0;jj<m;++jj) {\n                        a[i][jj] ^= a[idx][jj];\n                    }\n                }                \n            }\n        }\n        if(!all_zero) ++ii;\n    }\n\n    // for(int i=0;i<n;++i) {\n    //     for(int j=0;j<m;++j) {\n    //         cerr << a[i][j] << \" \";\n    //     }\n    //     cerr << \"\\n\";\n    // }\n\n    int rank = 0;\n    for(int i=0;i<n;++i) {\n        for(int j=0;j<m;++j) {\n            if(a[i][j]) {\n                ++rank;\n                break;\n            }\n        }\n    }\n    return rank;\n}\n\nll modpow(ll a, ll t) {\n    ll ret = 1LL;\n    while(t){\n        if(t & 1LL){\n            ret *= a;\n            ret %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        t >>= 1;\n    }\n    return ret;\n}\n\nint main() {\n    std::ios::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    for(int i=0;i<n;++i) for(int j=0;j<m;++j) cin >> a[i][j];\n    int r = calc_rank(a);\n    cout << (modpow(2LL, n+m-1) - modpow(2LL, n+m-r-1) + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing ll = long long;\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t r = 0;\n    for (std::size_t c = 0; c < mat.C; c++) {\n        if (c == mat.R) { break; }\n        std::size_t piv = r;\n        for (; piv < mat.R and mat[piv][c] == 0; piv++) {}\n        if (piv == mat.R) { continue; }\n        std::swap(mat[r], mat[piv]);\n        const T p = mat[r][c];\n        for (std::size_t i = 0; i < mat.R; i++) { mat[i][c] /= p; }\n        for (std::size_t j = 0; j < mat.C; j++) {\n            if (j == c) { continue; }\n            const T p = mat[r][j];\n            for (std::size_t i = 0; i < mat.R; i++) { mat[i][j] -= mat[i][c] * p; }\n        }\n        r++;\n    }\n    return r;\n}\nconstexpr ll MOD = 998244353LL;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<int> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<ll> bp(600, 1LL);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2 % MOD; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD) % MOD << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=305;\nconst int mod=998244353;\nint n,m,bin[MAXN];\nbitset<MAXN> bi[MAXN];\nint main()\n{\n\tbin[0]=1;for(int i=1;i<MAXN;i++)bin[i]=(bin[i-1]<<1)%mod;\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=m;j++)bi[i][j]=read();\n\tfor(int i=1,p=1;i<=n&&p<=m;i++,p++)\n\t{\n\t\tint u=i;for(int j=i+1;j<=n;j++)if(bi[j][p]){u=j;break;}\n\t\tswap(bi[i],bi[u]);if(!bi[i][p]){--i;continue;}\n\t\tfor(int j=i+1;j<=n;j++)if(bi[j][i])bi[j]^=bi[i];\n\t}int cnt=0;\n\tfor(int i=1;i<=n;i++)if(bi[i].any())++cnt;\n\tcnt=n-cnt;\n\tint val=(bin[n]-bin[cnt]+mod)%mod;\n\tpr2(1LL*val*bin[m-1]%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 300, md = 998244353;\nint n, m, p2[N + 1];\nvector<bitset<N> > g;\n\nvoid ad(bitset<N> v){\n\tint j = 0;\n\tf(i, 0, g.size()){\n\t\tif (v.none())return;\n\t\twhile (!v[j] && !g[i][j])++j;\n\t\tif (g[i][j] && v[j])v ^= g[i];\n\t\telse if (v[j]){\n\t\t\tg.insert(g.begin() + i, v);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (v.any())g.push_back(v);\n}\n\nint main(){\n\tp2[0] = 1;\n\tf(i, 1, N + 1)p2[i] = (ll)p2[i - 1] * 2 % md;\n\tscanf(\"%d%d\", &n, &m);\n\tf(i, 0, n){\n\t\tbitset<N> v;\n\t\tf(j, 0, m){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t)v[j] = true;\n\t\t}\n\t\tad(v);\n\t}\n\tint an = p2[n] - p2[n - g.size()] + md;\n\tan = (ll)an * p2[m - 1] % md;\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconst int N = 200 * 1000 + 5, mod = 1000 * 1000 * 1000 + 7;\nconst long long inf = 1ll * N * mod;\nint n, m;\n\nvector <pair <int, int> > adj[N];\nlong long dis1[N], dis2[N];\nint dp1[N], dp2[N];\nset <pair <long long, int> > s;\n\nvoid dij(int st, long long dis[], int cnt[]) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tdis[i] = inf;\n\t}\n\tdis[st] = 0;\n\tcnt[st] = 1;\n\ts.insert({0, st});\n\twhile (s.size()) {\n\t\tint v = (*s.begin()).second;\n\t\ts.erase(s.begin());\n\t//\tcout << \"74 \" << v << endl;\n\t\tfor (auto p : adj[v]) {\n\t\t\tint u = p.first, w = p.second;\n\t\t//\tcout << \"73 \" << v << \" \" << u << endl;\n\t\t\tif (dis[v] + w < dis[u]) {\n\t\t\t\t\n\t\t\t\ts.erase({dis[u], u});\n\t\t\t\tdis[u] = dis[v] + w;\n\t\t\t\tcnt[u] = 0;\n\t\t\t\ts.insert({dis[u], u});\n\t\t\t}\n\t\t\tif (dis[v] + w == dis[u]) {\n\t\t\t\tcnt[u] += cnt[v];\n\t\t\t\tcnt[u] %= mod;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint st, ed;\n\tcin >> n >> m >> st >> ed;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tw *= 2;\n\t\tadj[u].push_back({v, w});\n\t\tadj[v].push_back({u, w});\n\t}\n\tdij(st, dis1, dp1);\n\tdij(ed, dis2, dp2);\n//\tfor (int i = 1; i <= n; i++) {\n//\t\tcout << \"72 \" << dis1[i] << \" \" << dis2[i] << endl;\n//\t}\n\tlong long ans = 1ll * dp1[ed] * dp1[ed];\n\tans %= mod;\n//\tcout << \"71 \" << ans << endl;\n\tlong long d = dis1[ed];\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dis1[i] == d / 2) {\n\t\t\tlong long x = 1ll * dp1[i] * dp1[i];\n\t\t\tx %= mod;\n\t\t\tx *= x;\n\t\t\tx %= mod;\n\t\t\tans -= x - mod;\n\t\t\tans %= mod;\n\t\t}\n\t\tfor (auto p : adj[i]) {\n\t\t\tint u = p.first, w = p.second;\n\t\t\tif (dis1[i] < d / 2 && d / 2 < dis1[u] && 0ll + dis1[i] + w + dis2[u] == d) {\n\t\t\t\tlong long x = 1ll * dp1[i] * dp2[u];\n\t\t\t\tx %= mod;\n\t\t\t\tx *= x;\n\t\t\t\tx %= mod;\n\t\t\t\tans -= x - mod;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace io {\n    // TYPE ID (StackOverflow)\n    \n    template<class T> struct like_array : is_array<T>{};\n    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};\n    template<class T> struct like_array<vector<T>> : true_type{};\n    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }\n\n    // I/O \n    \n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n    \n    // INPUT \n    \n    template<class T> void re(T& x) { cin >> x; }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest);\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    \n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    \n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n    \n    // OUTPUT \n    \n    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {\n        os << '{' << a.f << \", \" << a.s << '}'; return os;\n    }\n    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {\n        os << '{';\n        F0R(i,SZ) {\n            if (i) {\n                os << \", \";\n                if (is_like_array(a[i])) cout << \"\\n\";\n            }\n            os << a[i];\n        }\n        os << '}';\n        return os;\n    }\n    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {\n        return printArray(os,a,SZ);\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {\n        return printArray(os,a,sz(a));\n    }\n    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {\n        os << vector<T>(all(a)); return os;\n    }\n    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {\n        os << vector<pair<T1,T2>>(all(a)); return os;\n    }\n    \n    template<class T> void pr(const T& x) { cout << x << '\\n'; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        cout << first << ' '; pr(rest...); \n    }\n}\n\nusing namespace io;\n\nnamespace modOp {\n    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }\n    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }\n    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }\n    \n    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }\n    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }\n    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }\n    \n    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }\n    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }\n    \n    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1\n        if (a == 0) return b == 1 ? 0 : -1;\n        int x = invGeneral(b%a,a); \n        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n    }\n}\n\nusing namespace modOp;\n\nint N,M,sz;\nbool done[300];\nbitset<300> b[300];\n\nint main() {\n    // you should actually read the stuff at the bottom\n    setIO(); re(N,M);\n    F0R(i,N) {\n        F0R(j,M) {\n            bool x; re(x);\n            b[i][j] = x;\n        }\n    }\n    F0R(i,300) {\n        F0R(j,300) if (!done[j] && b[j][i]) {\n            done[j] = 1; sz ++;\n            F0R(k,300) if (!done[k] && b[k][i]) b[k] ^= b[j];\n            break;\n        }\n    }\n    // pr(sz);\n    pr(sub(po(2,N+M-1),po(2,N+M-1-sz)));\n    // (2^{N+M}-2^{N+M-size(basis for cols)})/2 \n    \n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DEBUG_OUTPUT_ENABLED 1\n\t#define DBG(X) dout << #X << \"=\" << (X) << '\\n';\n\t#define SAY(X) dout << (X) << '\\n';\n\t#define dout   __debug::instance\n#else\n\t#define DEBUG_OUTPUT_ENABLED 0\n\t#define DBG(X) 42;\n\t#define SAY(X) 42;\n\t#define dout CannotCompileBecauseOfDebugOutput\n#endif\n\nusing namespace std;\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld  = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const set<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const multiset<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\nnamespace __debug {\n\tstruct DebugStream {\n\t\tprivate:\n\t\t\tbool is_first;\n\t\tpublic:\n\t\t\tDebugStream(bool _is_first): is_first(_is_first) {}\n\t\t\ttemplate<typename T> DebugStream operator<<(const T& value) const {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\tcout << value;\n\t\t\t\treturn DebugStream(false);\n\t\t\t};\n\n\t\t\ttemplate<typename T> DebugStream printArray(T* l, T* r) {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\twhile(l != r) {\n\t\t\t\t\tcout << (*l);\n\t\t\t\t\t++l;\n\t\t\t\t\tif(l == r) {\n\t\t\t\t\t\tcout << '\\n';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn DebugStream(false);\n\t\t\t}\n\t};\n\tDebugStream instance(true);\n};\n\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF  = (ll)(2e18);\n\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T> inline T fetch() { T ret; cin >> ret; return ret; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for(auto& elem: ret) cin >> elem; return ret; }\nconst int MAXN = 307;\nconst int MOD  = (int)1e9 + 7;\ninline int add(int x, int y) {\n\treturn (x + y >= MOD ? x + y - MOD : x + y);\n}\ninline int sub(int x, int y) {\n\treturn (x - y < 0 ? x - y + MOD : x - y);\n}\ninline int mult(int x, int y) {\n\tll r = x * 1LL * y;\n\tif(r >= MOD) r %= MOD;\n\treturn (int)r;\n}\nint pw2[MAXN];\nbitset<MAXN> G[MAXN], basis[MAXN];\nint n, m;\ninline int GaussAdd(bitset<MAXN> v) {\n\tfor(int i = 0; i < MAXN; ++i) if(v[i]) {\n\t\tif(basis[i].count()) {\n\t\t\tv ^= basis[i];\n\t\t} else {\n\t\t\tbasis[i] = v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid solve() {\n\tpw2[0] = 1;\n\tfor(int i = 1; i < MAXN; ++i) pw2[i] = add(pw2[i - 1], pw2[i - 1]);\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; ++i) for(int j = 0; j < m; ++j) G[i][j] = fetch<int>();\n\tint szBasis = 0;\n\tfor(int i = 0; i < n; ++i) szBasis += GaussAdd(G[i]);\n\tint countZero = pw2[n - szBasis];\n\tint countNonZero = sub(pw2[n], countZero);\n\tint answ = mult(countNonZero, pw2[m - 1]);\n\tcout << answ << '\\n';\n}\n\nint main() {\n\tfast_io();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\t int F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\t long long F=1,n=0;\n\t\t char ch;\n\t\t while((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\t ch=='-'?F=0:n=ch-'0';\n\t\t while((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\t return F?n:-n;\n\t}\n}\nint R(int l,int r)\n{\n\treturn (rand()<<15|rand())%(r-l+1)+l;\n}\nstd::bitset<333> a[333]; \nint ex[666];\nconst int M=998244353;\nint main()\n{\n\tint n=io::F(),m=io::F();\n\tfor(register int i=1;i<=n;++i)\n\t\tfor(register int j=1;j<=m;++j)\n\t\t\ta[i][j]=io::F();\n\tint up=1;\n\tfor(register int i=1;i<=m;++i)\n\t{\n\t\tint pl=0;\n\t\tfor(register int j=up;j<=n;++j)\n\t\t\tif(a[j].test(i)){pl=j;break;}\n\t\tif(pl==0)continue;\n\t\tif(pl!=up)std::swap(a[up],a[pl]);\n\t\tfor(register int j=up+1;j<=n;++j)\n\t\t\tif(a[j].test(i))a[j]^=a[up];\n\t\t++up;\n\t}\n\tint cnt=n-up+1;\n\tex[0]=1;\n\tfor(register int i=1;i<=n+m;++i)ex[i]=ex[i-1]*2%M;\n\tprintf(\"%lld\\n\",(ex[n]-ex[cnt]+M)*1ll*ex[m-1]%M);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\n#define BIT_N 333\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef bitset<BIT_N> Bit;\nvector<int> baseNum;\n\nll pow_two[2 * BIT_N];\n\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 333333\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nvector<Bit> gauss(vector<Bit> v, ll &ran){\n\tran = 0;\n\tREP(i,BIT_N) {\n\t\tint pla = -1;\n\t\tfor(int j = ran;j < v.size();j++){\n\t\t\tif(v[j][i] == 1){\n\t\t\t\tpla = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pla != -1){\n\t\t\tswap(v[ran], v[pla]);\n\t\t\tfor(int j = 0;j < v.size();j++){\n\t\t\t\tif(j != ran && v[j][i] == 1)v[j] ^= v[ran];\n\t\t\t}\n\t\t\tran++;\n\t\t}\n\t}\n\treturn v;\n}\n\nint main(){\n\t\n\tpow_two[0] = 1;\n\tREP(i,2 * BIT_N - 1)pow_two[i+1] = pow_two[i] * 2 % MOD;\n\t\n\tvector<Bit> v;\n\tll n, m;cin >> n >> m;\n\tREP(i,n){\n\t\tBit now;\n\t\tREP(j,m){\n\t\t\tint a;cin >> a;\n\t\t\tif(a)now[j] = 1;\n\t\t}\n\t\tv.PB(now);\n\t}\n\t\n\tll ran = 0;\n\tll ans = 0;\n\tgauss(v, ran);\n\tll kake = pow_two[n-ran] * pow_two[m-ran] % MOD;\n\t//cout << \"kake \" << kake << endl;\n\tfor(int i = 1;i <= ran;i+=2){\n\t\tll now = combination(ran, i) * ((pow_two[ran - i] * 2 - 1 + MOD) % MOD) % MOD;\n\t\tans = (ans + now * kake % MOD) % MOD;\n\t\t//cout << \"now \" << now << endl;\n\t}\n\t\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define pb push_back\nusing namespace std;\nll n,m;\nll a[305][305];\nll tmp[305];\nconst ll mod = 998244353;\nll ME(ll x,ll nn,ll M)\n{\n    ll result=1;\n    while(nn>0)\n    {\n        if(nn % 2 ==1)\n            result=(result * x)%M;\n        x=(x*x)%M;\n        nn=nn/2;\n    }\n    return result;\n}\nvoid swaps(ll x, ll y)\n{\n        for(ll i=0;i<m;i++) tmp[i] = a[x][i];\n        for(ll i=0;i<m;i++) a[x][i] = a[y][i];\n        for(ll i=0;i<m;i++) a[y][i] = tmp[i];\n}\nint main()\n{\n        cin >> n >> m;\n        for(ll i=0;i<n;i++) {\n                for(ll j=0;j<m;j++) {\n                        cin >> a[i][j];\n                }\n        }\n        ll sz=0;\n        for(ll i=0; i < m && sz < n; i++) {\n                bool ok = false;\n                for(ll j=sz; j<n;j++) {\n                        if(a[j][i] == 1) {\n                                swaps(sz , j);\n                                ok = true;\n                                break;\n                        }\n                }\n                if(!ok) continue;\n                for(ll j=0;j<n;j++) {\n                        if(j==sz) continue;\n                        if(a[j][i] == 1) {\n\n                                for(ll k=0;k<m;k++) {\n                                        a[j][k] ^= a[sz][k];\n                                }\n                        }\n                }\n                sz++;\n        }\n        ll r = 0;\n        for(ll i=0;i<n;i++) {\n                ll yo=0;\n                for(ll j=0;j<m;j++) yo += a[i][j];\n                if(yo>0) r++;\n        }\n        ll ans = ME(2LL,n+m-1,mod);\n        ans = (ans - ME(2LL,n+m-r-1, mod) + mod)%mod;\n        ans %= mod;\n        cout << ans << endl;\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n\nstruct fast_io {\n    static constexpr int size_in = 1 << 26, size_out = 1 << 26;\n    char data_in[size_in], data_out[size_out], *p_in, *p_out, s[30];\n    fast_io() { fread(data_in, 1, size_in, stdin), p_in = data_in, p_out = data_out; }\n    ~fast_io() { fwrite(data_out, 1, p_out - data_out, stdout); }\n    void putchar(char x) { *p_out++ = x; }\n    template<typename T> void putint(T x) {\n        if (x < 0) { *p_out++ = '-', x = -x; }\n        int i = 0;\n        do { s[i++] = x % 10 + '0'; } while (x /= 10);\n        while (i--) { *p_out++ = s[i]; }\n    }\n    template<typename T=int> T getint() {\n        while (!isdigit(*p_in) && *p_in != '-') { p_in++; }\n        bool negative = *p_in == '-';\n        T ret = negative ? 0 : *p_in - '0';\n        while (isdigit(*++p_in)) { (ret *= 10) += *p_in - '0'; };\n        return negative ? -ret : ret;\n    }\n} io;\n\ntemplate<typename T> std::vector<T> xor_eliminate(std::vector<T> src) {\n    std::vector<T> ret;\n    for (int i = 0; i < src.size(); i++) {\n        for (int j = src.size() - 1; j > i; j--) {\n            int x = src[j]._Find_first(), y = src[j - 1]._Find_first();\n            if (x < y) { src[j - 1] ^= src[j]; }\n            if (x <= y) { src[j] ^= src[j - 1]; }\n        }\n        if (src[i].none()) { break; }\n        ret.emplace_back(src[i]);\n    }\n    for (int i = ret.size() - 1; i > 0; i--) {\n        for (int j = 0; j < i; j++) {\n            if (ret[j][ret[i]._Find_first()]) { ret[j] ^= ret[i]; }\n        }\n    }\n    return ret;\n}\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nint main() {\n    int N = io.getint(), M = io.getint();\n    using bset = bitset<300>;\n    vector<bset> b(N);\n    rep(i, N) {\n        rep(j, M) {\n            int a = io.getint();\n            b[i][j] = a;\n        }\n    }\n    using mint = mod_int<998244353>;\n    io.putint((mint(2).pow(N + M - 1) - mint(2).pow(N + M - xor_eliminate(b).size() - 1)).val);\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 998244353LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                // C[i][j] += A[i][k] * B[k][j]; // modなし\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// Matrix Library End\n\n// N * M 行列のランクを求める\ntemplate <typename T>\nint mat_rank(Matrix<T> A) {\n    int N = A.size(), M = A[0].size();\n\n    int WID = min(N, M), res = 0;\n    for(int i=0; i<WID; i++) {\n        // 絶対値が最も大きいものを探す\n        T max_elem = 0; int piv = -1;\n        for(int j=res; j<N; j++) {\n            if(abs(A[j][i]) > max_elem) {\n                max_elem = abs(A[j][i]);\n                piv = j;\n            }\n        }\n\n        // fprintf(stderr, \"# piv = %lld\\n\", piv);\n        if(piv < 0) continue;\n            \n        // i 行目を piv 行目に変えて、行基本変形\n        swap(A[i], A[piv]);\n        res++;\n\n        /*\n        fprintf(stderr, \"# matrix debug\\n\");\n        for(int x=0; x<N; x++) {\n            for(int y=0; y<M; y++) {\n                fprintf(stderr, \"%lld \", A[x][y]);\n            }\n            fprintf(stderr, \"\\n\");\n        }\n        */\n            \n        for(int j=0; j<N; j++) {\n            if(i == j) continue;\n            assert(A[i][i] != 0);\n            double ratio = 1.0 * A[j][i] / A[i][i];\n            for(int k=0; k<M; k++) {\n                A[j][k] = (T)(A[j][k] - ratio * A[i][k]);\n            }\n        }\n    }\n    return res;\n}\n\nconst int MAXN = 610;\nint pow2[MAXN + 10];\nsigned main() {\n    pow2[0] = 1;\n    for(int i=1; i<=MAXN; i++) pow2[i] = (pow2[i-1] * 2) % MOD;\n    \n    int N, M; cin >> N >> M;\n    Matrix<int> mat;\n    init_mat(mat, N, M);\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            cin >> mat[i][j];\n        }\n    }\n\n    int rank = mat_rank(mat);\n    int ansA = pow2[N + M - 1];\n    int ansB = pow2[N + M - rank - 1];\n    fprintf(stderr, \"matrix rank = %lld\\n\", rank);\n    printf(\"%lld\\n\", (ansA - ansB + MOD) % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n    using namespace std;\n    #define ll long long\n    #define pb push_back\n    #define mp make_pair\n    const int N=305;\n    const int mod=998244353;\n    int a[N][N];\n    int main()\n    {\n    \tint n,m,i,j,k;\n    \tscanf(\"%i %i\",&n,&m);\n    \tfor(i=1;i<=n;i++) for(j=1;j<=m;j++) scanf(\"%i\",&a[i][j]);\n    \tint r=0;\n    \tfor(i=1;i<=n;i++)\n    \t{\n    \t\tbool ok=0;\n    \t\tfor(j=r+1;j<=n;j++)\n    \t\t{\n    \t\t\tif(a[j][i])\n    \t\t\t{\n    \t\t\t\tfor(k=i;k<=m;k++) swap(a[j][k],a[r+1][k]);\n    \t\t\t\tok=1;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\tif(!ok) continue;\n    \t\tr++;\n    \t\tfor(j=r+1;j<=n;j++) if(a[j][i])\n    \t\t{\n    \t\t\tfor(k=i;k<=m;k++) a[j][k]=(a[j][k]-a[r][k]+2)%2;\n    \t\t}\n    \t}\n    \tint ans=1,sol=1;\n    \tfor(i=1;i<=n+m-1;i++) ans=ans*2%mod;\n    \tfor(i=1;i<=n+m-r-1;i++) sol=sol*2%mod;\n    \tans-=sol;\n    \tif(ans<0) ans+=mod;\n    \tprintf(\"%i\\n\",ans);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 998244353;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> void UNIQUE(vector<T> &a){ a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; scanf(\"%lld\", &x); return x;}\nld fin(){double x; scanf(\"%lf\", &x); return x;}\nchar yuyushiki[1000010]; string stin(){scanf( \"%s\", yuyushiki ); return yuyushiki;}\n\n// head\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\nll gauss(vector<vector<ll>> A){\n  ll n = A.size();\n  ll m = A[0].size();\n  ll p = 0;\n  REP(j, m){\n    int piv = p;\n    FOR(i, p, n){\n      if(A[piv][j] < A[i][j]){\n        piv = i;\n      }\n    }\n    swap(A[p], A[piv]);\n    if(A[p][j] == 0){\n      continue;\n    }\n    assert(A[p][j] == 1);\n    REP(i, n){\n      if(p != i){\n        if(A[i][j] == 1){\n          FOR(k, j, m){\n            A[i][k] = A[i][k] ^ A[p][k];\n          }\n        }\n      }\n    }\n    p++;\n    if(p == n){\n      break;\n    }\n  }\n  return p;\n}\n\nint main(){\n  ll n = in();\n  ll m = in();\n  vector<vector<ll>> a(n, vector<ll>(m, 0));  \n  REP(i, n){\n    REP(j, m){\n      a[i][j] = in();\n    }\n  }\n\n  ll r = gauss(a);\n\n  Mod base = modpow(2, r-1) * (modpow(2, r) - 1);\n  Mod ans = base * modpow(2, n + m - 2 * r);\n\n  cout << ans.n << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/numeric/ublas/matrix.hpp>\nusing i64 = long long;\n\nconstexpr auto pow(long long x, long long n, const long long mod) {\n    long long ret = 1;\n    while(n > 0) {\n        if ((n & 1) == 1) ret = (ret * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint main() {\n    constexpr i64 mod = 998244353;\n    int n, m;\n    std::cin >> n >> m;\n    std::vector<std::bitset<310>> b(n);\n    for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n        int a;\n        std::cin >> a;\n        if (a) b[i].set(j);\n    }\n\n    int r = 0;\n    for (int j = 0; j < m; j++) {\n        int p = -1;\n        for (int i = r; i < n; i++) {\n            if (b[i][j]) {\n                p = i;\n                break;\n            }\n        }\n        if (p == -1) continue;\n        std::swap(b[p], b[r]);\n        for (int i = 0; i < n; i++) if (i != r && b[i][j]) b[i] ^= b[r];\n        ++r;\n    }\n\n    std::cout << (pow(2, n + m - 1, mod) + mod - pow(2, n + m - r - 1, mod)) % mod << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <limits.h>\nusing namespace std;\ntypedef long long LL;\ntypedef bitset<300> BS;\nconst int B=300;\nconst int N=400;\nconst BS one=BS().set(0);\nconst BS zero=BS();\nconst LL M=998244353;\n\nstruct LB {\n\tint sz;\n\tBS b[B];\n\n\tvoid build(BS *a,int n) {\n\t\tsz=0;\n\t\tfor(int i=0;i<B;i++) {\n\t\t\tb[i].reset();\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tBS x=a[i];\n\t\t\tfor(int j=B-1;j>=0;j--) {\n\t\t\t\tif(((x>>j)&one)==one) {\n\t\t\t\t\tif(b[j]!=zero) x^=b[j];\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[j]=x;\n\t\t\t\t\t\tsz++;\n\t\t\t\t\t\tfor(int k=j-1;k>=0;k--) {\n\t\t\t\t\t\t\tif(b[k]!=zero && ((b[j]>>k)&one)==one) b[j]^=b[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=j+1;k<B;k++) {\n\t\t\t\t\t\t\tif(((b[k]>>j)&one)==one) b[k]^=b[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}lb;\n\nint n,m,b;\nBS a[N];\nLL dp[N],P[N],inv_P[N],pw[N];\n\nLL exgcd(LL a,LL b,LL &x,LL &y) {\n\tLL d=a;\n\tif(b!=0) {\n\t\td=exgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}\n\telse {\n\t\tx=1;y=0;\n\t}\n\treturn d;\n}\n\nLL mod_inv(LL a,LL m) {\n\tLL x,y;\n\texgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nvoid init() {\n\tP[0]=1;\n\tinv_P[0]=1;\n\tpw[0]=1;\n\tfor(int i=1;i<N;i++) {\n\t\tP[i]=P[i-1]*i%M;\n\t\tinv_P[i]=mod_inv(P[i],M);\n\t\tpw[i]=pw[i-1]*2%M;\n\t}\n}\n\nLL C(int n,int m) {\n\treturn P[n]*inv_P[m]%M*inv_P[n-m]%M;\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++) {\n\t\ta[i].reset();\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tscanf(\"%d\",&b);\n\t\t\tif(b) a[i].set(j);\n\t\t}\n\t}\n\tlb.build(a,n);\n\n\tdp[0]=1;\n\tfor(int i=0;i<B;i++) {\n\t\tint l=lb.b[i].count();\n\t\tif(l==0) continue;\n\t\tfor(int j=m;j>=0;j--) {\n\t\t\tif(j+l<=m) dp[j+l]+=dp[j],dp[j+l]%=M;\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=m;i++) {\n\t\tfor(int j=1;j<=i;j+=2) {\n\t\t\tans+=C(i,j)*dp[i]%M*pw[m-i]%M;\n\t\t\tans%=M;\n\t\t}\n\t}\n\tans*=pw[n-lb.sz],ans%=M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\nint gauss (vector < vector< ll > > a) {\n    int n = (int) a.size();\n    int m = (int) a[0].size();\n\n    vector<int> where (m, -1);\n    for (int col=0, row=0; col<m && row<n; ++col) {\n        int sel = row;\n        for (int i=row; i<n; ++i)\n            if (abs (a[i][col]) > abs (a[sel][col]))\n                sel = i;\n        if (a[sel][col] == 0)\n            continue;\n        for (int i=col; i<m; ++i)\n            swap (a[sel][i], a[row][i]);\n        where[col] = row;\n\n        for(int i = col + 1 ; i < m ; i++){\n            assert(a[row][i] % a[row][col] == 0LL);\n\n            a[row][i] /= a[row][col];\n        }\n\n        a[row][col] /= a[row][col];\n        \n        for (int i=0; i<n; ++i)\n            if (i != row) {\n                ll c = a[i][col] / a[row][col];\n\n                assert(a[i][col] % a[row][col] == 0LL);\n                for (int j=col; j<m; ++j)\n                    a[i][j] -= a[row][j] * c;\n            }\n        ++row;\n    }\n\n    int rank = n;\n    // cout << \"m = \" << m << endl;\n    for(int i = 0 ; i < n ; i++){\n        bool has_one = false;\n\n        for(int j = 0 ; j < m ; j++){\n            if(a[i][j]){\n                has_one = true;\n                break;\n            }\n        }\n\n        if(!has_one){\n            // cout << \"Linha \" << i << \" nao tem! \" << endl;\n            rank--;\n        }\n    }\n\n    return rank;\n}\n\nvector< vector< ll > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    // cout << mod * mod << endl;\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            ll x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = gauss(a);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n + m - 1);\n    ll nr = fast_pow(2LL, n + m - rank - 1);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD(nn - nr) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\n\nvoid norm(VV<int>& a) {\n\tint n = a.size(), m = a[0].size();\n\tint pre = 0;\n\tREP(j, m) {\n\t\tint pivot = -1;\n\t\tFOR(i, pre, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tpivot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) continue;\n\t\tstd::swap(a[pre], a[pivot]);\n\n\t\tREP(i, n) if (i != pre) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tREP(k, m) {\n\t\t\t\t\ta[i][k] ^= a[pre][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++pre;\n\t}\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tMAT(int, a, n, m);\n\n\tREP(_, 2) {\n\t\tnorm(a);\n\t\tVV<int> b(m, V<int>(n));\n\t\tREP(i, n) REP(j, m) {\n\t\t\tb[j][i] = a[i][j];\n\t\t}\n\t\tstd::swap(n, m);\n\t\tstd::swap(a, b);\n\t}\n\n\tint one = 0;\n\tint zero = 0;\n\tREP(i, n) {\n\t\tbool f = false;\n\t\tREP(j, m) if (a[i][j]) f = true;\n\t\tif (f) ++one;\n\t\telse ++zero;\n\t}\n\tREP(j, m) {\n\t\tbool f = false;\n\t\tREP(i, n) if (a[i][j]) f = true;\n\t\tif (f) /*++one*/;\n\t\telse ++zero;\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= one; i += 2) {\n\t\tint sum = Combination(one, i);\n\t\t(sum *= powMod(3, one - i, MOD)) %= MOD;\n\t\t(sum *= powMod(2, zero, MOD)) %= MOD;\n\t\t(ans += sum) %= MOD;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 333333;\nconst int MOD = 998244353;\n\nint n, m;\nvector<int> a[500];\nvector<int> st[500];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            int x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n    int sz = 0;\n    for (int i = 0; i < n; i++)\n    {\n        int t = -1;\n        for (int j = 0; j < m; j++)\n        {\n            if (a[i][j] && st[j].size() == 0)\n            {\n                t = j;\n                break;\n            }\n            else\n            {\n                if (a[i][j])\n                {\n                    for (int k = 0; k < m; k++)\n                    {\n                        a[i][j] = a[i][j] ^ st[j][k];\n                    }\n                }\n            }\n        }\n        if (t > -1)\n        {\n            st[t] = a[i];\n            sz++;\n        }\n    }\n    cout << inq(2, m - 1) * (inq(2, n) - inq(2, n - sz) + MOD) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint H, W;\nlong long mod = 998244353;\nvector<int> A[309];\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tA[i].resize(W, 0);\n\t\tfor (int j = 0; j < W; j++) cin >> A[i][j];\n\t}\n\tsort(A, A + H);\n\n\tfor (int i = 0; i < W; i++) {\n\t\tint pos = 0;\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tint cnt = 0; for (int k = 0; k < i; k++) { if (A[j][k] == 1) cnt++; }\n\t\t\tif (cnt == 0) { pos = j; }\n\t\t}\n\t\tfor (int j = pos - 1; j >= 0; j--) {\n\t\t\tif (A[j][i] == 0) continue;\n\t\t\tfor (int k = 0; k < W; k++) A[j][k] ^= A[pos][k];\n\t\t}\n\t\tsort(A, A + H);\n\t}\n\n\tvector<int> ZERO(W, 0);\n\tlong long v = 1;\n\tfor (int i = 0; i < H; i++) {\n\t\tif (A[i] == ZERO) { v *= 2; v %= mod; }\n\t}\n\tlong long p = 1; for (int i = 0; i < H; i++) { p *= 2; p %= mod; }\n\tlong long q = 1; for (int i = 0; i < W; i++) { q *= 2; q %= mod; }\n\tlong long r = (p - v + mod)*q%mod;\n\tif (r % 2 == 1) r += mod; r /= 2;\n\tcout << r << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YESNO OUT(three(solve(),\"YES\",\"NO\"))\n#define YesNo OUT(three(solve(),\"Yes\",\"No\"))\n#define WL(A,B) OUT(three(solve(),A,B))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(b);i>=(LL)(a);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n#define all ALL\n#define pb emplace_back\n#define eb pb\n#define int long long\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntemplate<class T> inline bool chmax(int a, int b, T c, T d) { return c > d ? a : b; }\ntemplate<class T> inline bool chmin(int a, int b, T c, T d) { return c > d ? a : b; }\ntypedef int LL;\ntypedef double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef tuple<int, int, int, int> tapu;\ntypedef vector<tapu> Vtapu;\ntypedef priority_queue<ut, VI, greater<LL> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 1e6 + 1000;\nconst int SIZE2 = 4010;\nconst int SIZE3 = 430;\nconst int SIZE = SIZE1;\nconst int MAPSIZE = 40;\nconst LL p =998244353;\nconst LL INF = 1LL << 30;\nconst long double EPS = 1e-7;\nconst LL inf = 1000000000;\ntypedef pair<ld, ut> pld;\nut N, M, K, L, Q,  H, W, R;\nVI edges[SIZE];\nLL vals[SIZE], answer = zero;\n//LL maps[SIZE2][SIZE2];\nLL A[SIZE3][SIZE3],B[SIZE],C[SIZE],D[SIZE],E[SIZE];\nLL def = 0;\nvoid rev(int a) {\n\tREP(i, W) {\n\t\tdef ^= A[a][i];\n\t\tA[a][i] ^= 1;\n\t}\n}\nvoid xors(int a, int b) {\n\tREP(i, W)\n\t\tA[a][i] ^= A[b][i];\n}\nvoid swaps(int a, int b) {\n\tREP(i, W)\n\t\tswap(A[a][i], A[b][i]);\n}\nLL power(LL x) {\n\tLL ans = 1;\n\tREP(i, x) ans = ans * 2 % p;\n\treturn ans;\n}\nLL solve() {\n\tcin >> H >> W;\n\tREP(i, H) REP(j, W) {\n\t\tcin >> A[i][j];\n\t}\n\tLL ans = 0,rank=0;\n\tREP(j, W) {\n\t\tFOR(i,rank,H) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tswaps(i, rank);\n\t\t\t\tFOR(k, rank + 1, H) {\n\t\t\t\t\tif (A[k][rank]) xors(k, rank);\n\t\t\t\t}\n\t\t\t\trank++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (power( H + W - 1) % p - power(H+W-rank-1) % p + p) % p;\n\t//return ;\n}\n\n\n\n\n//!!!!!!!!!!!!!!!!!!!実装を詰める!!!!!!!!!!!!!!!!!!!!!!!!!\nsigned main() {\n\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(0);\n\tcout << solve() << endl;\n\t\n\t//cin >> N;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, j, k) for (int i = j; i < (int)k; i++)\n#define pb push_back\n#define mt make_tuple\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef complex<ld> point;\ntypedef vector<int> vi;\n\ninline void fileIO(string s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\n\ntemplate <class T, class S>\ninline bool smin(T &a, S b) {\n  return (T)b < a ? a = b, 1 : 0;\n}\ntemplate <class T, class S>\ninline bool smax(T &a, S b) {\n  return a < (T)b ? a = b, 1 : 0;\n}\n\nconstexpr int MOD = 924844033;\nconstexpr int N = 302;\n\ntemplate <typename T>\ninline T mod(T &v) {\n  return v = (v % MOD + MOD) % MOD;\n}\ntemplate <typename S, typename T>\ninline S add(S &l, T r) {\n  return mod(l += r);\n}\nll po(ll v, ll u) {\n  return u ? po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD : 1;\n}\n\nint n, m, id[N];\nvector<bitset<N>> paye;\nbitset<N> tmp;\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifndef LOCAL\n  // fileIO(\"superposition\");\n#endif\n  memset(id, -1, sizeof(id));\n  cin >> n >> m;\n  rep(i, 0, n) {\n    rep(j, 0, m) {\n      bool local;\n      cin >> local;\n      tmp[j] = local;\n    }\n    while (tmp.count()) {\n      int pos = tmp._Find_first();\n      if (!~id[pos]) break;\n      tmp ^= paye[id[pos]];\n    }\n    if (tmp.count()) {\n      rep(j, 0, m) if (~id[j] && tmp[j]) tmp ^= paye[id[j]];\n      id[tmp._Find_first()] = paye.size();\n      for (auto &e : paye) e ^= tmp;\n      paye.pb(tmp);\n    }\n  }\n\n  ll res = po(2, n) - po(2, n - paye.size()) + MOD;\n  mod(res *= po(2, m - 1));\n  cout << res << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 310;\nconst int mod = 998244353;\nint n , m;\nint a[maxn][maxn];\nint s[maxn][maxn];\nint r;\nint pow ( int x ) {\n\tlong long s = 1 , f = 2;\n\twhile ( x ) {\n\t\tif ( x % 2 ) s = ( s * f ) % mod;\n\t\tf = ( f * f ) % mod; x = x / 2;\n\t}\n\treturn s;\n}\nvoid work () {\n\tint i , j , k;\n\tscanf ( \"%d%d\" , &n , &m );\n\tfor ( i = 1 ; i <= n ; i++ )\n\t\tfor ( j = 1 ; j <= m ; j++ )\n\t\t\tscanf ( \"%d\" , &a[i][j] );\n\tfor ( i = 1 ; i <= n ; i++ ) {\n\t\tfor ( j = 1 ; j <= m ; j++ ) {\n\t\t\tif ( s[j][j] == 0 && a[i][j] == 1 ) {\n\t\t\t\tfor ( k = 1 ; k <= m ; k++ ) {\n\t\t\t\t\ts[j][k] = a[i][k];\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor ( k = 1 ; k <= m ; k++ ) {\n\t\t\t\ta[i][k] ^= s[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tprintf ( \"%d\\n\" , ( pow ( n + m - 1 ) - pow ( n + m - r - 1 ) + mod ) % mod );\n}\nint main () {\n\twork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nint BinaryMat_calcrank(mat A){\n    int n = A.size(), m = A[0].size();\n    int r = 0, j = 0;\n    REP(i, n){\n        bool f = false;\n        while(!f && j < m){\n            FOR(i2, i, n){\n                if(A[i2][j]){\n                    A[i].swap(A[i2]);\n                    r++;\n                    f = true;\n                    break;\n                }\n            }\n            if(f){\n                FOR(i2, i + 1, n) if(A[i2][j]){\n                    FOR(j2, j, m) A[i2][j2] ^= A[i][j2];\n                }\n            }\n            j++;\n        }\n    }\n    return r;\n}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    mat a(N, vec(M));\n    REP(i, N) readv(a[i]);\n    REP(i, N) REP(j, M) a[i][j] &= 1;\n\n    int r = BinaryMat_calcrank(a);\n    //cout << r << endl;\n\n    int mod = 998244353;\n    int ans = ((modpow(2, N, mod) - modpow(2, N - r, mod) + mod) * modpow(2, M - 1, mod)) % mod;\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T> LLI power(T n, T p, T m){if(p==0) return 1LL; if(p==1) return n; LLI k = power(n, p/2, m); return ((k*k)%m*(p%2?n:1))%m;}\n\nconst LLI mod = 998244353;\nconst double eps = 1e-9;\n\ntemplate <typename T> int rank_matrix(vector<vector<T>> mat){\n\n  int n = mat.size();\n  int m = mat[0].size();\n  int p = 0;\n\n  REP(i,n){\n    if(p>=m) break;    \n\n    bool b = true;\n    FOR(j,i,n) if(abs(mat[j][p]) > eps) b = false;\n\n    if(b){\n      ++p;\n      continue;\n    }\n\n    if(abs(mat[i][p]) <= eps ){\n      FOR(j,i+1,n){\n\tif(abs(mat[j][p]) > eps){\n\t  swap(mat[i], mat[j]);\n\t  break;\n\t}\n      }\n    }\n    \n    FOR(j,i+1,n){\n      double t = (double)mat[j][p] / mat[i][p];\n      REP(k,m) mat[j][k] -= mat[i][k] * t;\n    }\n  }\n\n  int r = 0;\n  REP(i,n){\n    REP(j,m){\n      if(mat[i][j] != 0){\n\t++r;\n\tbreak;\n      }\n    }\n  }\n\n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  while(cin >> N >> M){\n    vector<vector<double>> a(N, vector<double>(M)); cin >> a;\n    int r = rank_matrix(a);\n    dump(r);\n    \n    LLI ans = power(2LL,(LLI)(M-1),mod) * (power(2LL,(LLI)N,mod) - power(2LL,(LLI)(N-r),mod) + mod) % mod;\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=1000000007;\nconst long double eps=1e-60;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\n\nint main(){\n    ll n,m;cin>>n>>m;\n    vector<bitset<300>> v(n);\n    rep(i,n){\n        rep(j,m){\n            int a;cin>>a;\n            if(a)v[i].set(j);\n        }\n    }\n    ll cnt=n;\n    vb used(n,false);\n    rep(i,300){\n        ll k=-1;\n        rep(j,n)if(!used[j]&&v[j].test(i)){\n            if(k==-1){\n                k=j;used[j]=true;break;\n            }\n            else v[j]^=v[k];\n        }\n        if(k!=-1)cnt--;\n    }\n    out((modpow(2,n)-modpow(2,cnt)+mod)*modpow(2,m-1)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\nll mod_pow(ll a, ll b) {\n\tif (b == 0) return 1;\n\tif (b % 2 == 0) {\n\t\tll x = mod_pow(a, b / 2);\n\t\treturn (x*x) % MOD;\n\t}\n\treturn (a*mod_pow(a, b - 1)) % MOD;\n}\nint a[300][300];\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tint r = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint idx = -1, l = -1;\n\t\tfor (int j = i; j < N; j++) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < M; k++) {\n\t\t\t\tif (a[j][k]) break;\n\t\t\t}\n\t\t\tif (k < M) {\n\t\t\t\tif (idx == -1 || l > k) idx = j, l = k;\n\t\t\t}\n\t\t}\n\t\tif (idx == -1) break;\n\t\tr++;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tswap(a[i][j], a[idx][j]);\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (i == j || a[j][l] == 0) continue;\n\t\t\tfor (int k = 0; k < M; k++) {\n\t\t\t\ta[j][k] ^= a[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tll ans = mod_pow(2, N + M - 1);\n\t(ans += MOD - mod_pow(2, N + M - r - 1)) %= MOD;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\n#define BIT_N 333\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef bitset<BIT_N> Bit;\nvector<int> baseNum;\n\nll pow_two[BIT_N];\n\nvector<Bit> gauss(vector<Bit> &v, ll &ran){\n\tran = 0;\n\tREP(i,BIT_N) {\n\t\tint pla = -1;\n\t\tfor(int j = ran;j < v.size();j++){\n\t\t\tif(v[j][i] == 1){\n\t\t\t\tpla = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pla != -1){\n\t\t\tswap(v[ran], v[pla]);\n\t\t\tfor(int j = 0;j < v.size();j++){\n\t\t\t\tif(j != ran && v[j][i] == 1)v[j] ^= v[ran];\n\t\t\t}\n\t\t\tran++;\n\t\t}\n\t}\n\treturn v;\n}\n\nint main(){\n\tfastcin();\n\t\n\tpow_two[0] = 1;\n\tREP(i,BIT_N - 1)pow_two[i+1] = pow_two[i] * 2 % MOD;\n\t\n\tvector<Bit> v;\n\tll n, m;cin >> n >> m;\n\tREP(i,n){\n\t\tBit now;\n\t\tREP(j,m){\n\t\t\tint a;cin >> a;\n\t\t\tif(a)now[j] = 1;\n\t\t}\n\t\tv.PB(now);\n\t}\n\t\n\tll ran = 0;\n\tll ans = 0;\n\tgauss(v, ran);\n\t\n\tcout << ((pow_two[n] - pow_two[n - ran] + MOD) % MOD) * pow_two[m-1] % MOD << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nint add(int &a, const int &b) {\n\ta = (a + b) % MOD;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M;\n\tcin >> N >> M;\n\tvector<vector<int> > A(N, vector<int>(M));\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\n\tint cur = 0;\n\tint t = -1;\n\tfor (int k = 0; k < M; k++) {\n\t\tt = -1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (A[i][k] == 1) {\n\t\t\t\tt = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (t == -1)continue;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (t != i) {\n\t\t\t\tif (A[i][k] == 1) {\n\t\t\t\t\tfor (int j = k; j < M; j++) {\n\t\t\t\t\t\tA[i][j] ^= A[t][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(A[t], A[cur]);\n\t\tcur++;\n\n\t}\n\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcerr << A[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n\n\n\t//int base = 1;\n\t//for (int i = 0; i < N; i++) {\n\t//\tint sum = 0;\n\t//\tfor (int j = 0; j < M; j++) {\n\t//\t\tsum += A[i][j];\n\t//\t}\n\t//\tif (sum == 0) {\n\t//\t\tswap(A[i], A.back());\n\t//\t\tA.pop_back();\n\t//\t\tN = A.size();\n\t//\t\tbase = (base * 2) % MOD;\n\t//\t}\n\t//}\n\n\t//for (int j = 0; j < M; j++) {\n\t//\tint sum = 0;\n\t//\tfor (int i = 0; i < N; i++) {\n\t//\t\tsum += A[i][j];\n\t//\t}\n\t//\tif (sum == 0) {\n\t//\t\tfor (int i = 0; i < N; i++) {\n\t//\t\t\tswap(A[i][j], A[i].back());\n\t//\t\t\tA[i].pop_back();\n\t//\t\t}\n\t//\t\tM = A[0].size();\n\t//\t\tbase = (base * 2) % MOD;\n\t//\t}\n\t//}\n\n\t/*cerr << N << \" \" << M << endl;\n\n\tif (N == 0 || M == 0) {\n\t\treturn 0;\n\t}\n*/\n\n\n\n\t//for (int i = 0; i < N; i++) {\n\t//\tfor (int j = 0; j < M; j++) {\n\t//\t\tcerr << A[i][j] << \" \";\n\t//\t}\n\t//\tcerr << endl;\n\t//}\n\n\tint X = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tsum += A[i][j];\n\t\t}\n\t\tif (sum > 0)X++;\n\t}\n\n\t//cerr << X << endl;\n\n\tres = 0;\n\tvector<vector<int> > dp(X + 1, vector<int>(X + 1, 0));\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= X; i++) {\n\t\tfor (int j = 0; j <= X; j++) {\n\t\t\tif (j > 0)add(dp[i][j], dp[i - 1][j - 1]);\n\t\t\tadd(dp[i][j], 3 * dp[i - 1][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= X; i += 2) {\n\t\tadd(res, dp[X][i]);\n\t}\n\n\tfor (int i = 0; i < N + M - X - X; i++) {\n\t\tres = (res * 2) % MOD;\n\t}\n\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int MN = 305, P = 998244353;\n\ntypedef std::bitset<MN> bst;\n\nbst val[MN], vec[MN];\n\nint n, m, cnt;\n\ninline int fpw(int x, int k) {\n\tint res = 1;\n\tfor (; k; k >>= 1, x = (ll) x * x % P)\n\t\tif (k & 1) res = (ll) res * x % P;\n\treturn res;\n}\n\ninline int read() {\n\tint x; bool f; char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tval[i][j] = read();\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = m; j--; )\n\t\t\tif (val[i][j]) {\n\t\t\t\tif (vec[j].count()) val[i] ^= vec[j];\n\t\t\t\telse {\n\t\t\t\t\t++cnt;\n\t\t\t\t\tvec[j] = val[i];\n\t\t\t\t\tfor (int k = j; k--; )\n\t\t\t\t\t\tif (vec[j][k]) vec[j] ^= vec[k];\n\t\t\t\t\tfor (int k = j; ++k < m; )\n\t\t\t\t\t\tif (vec[k][j]) vec[k] ^= vec[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\tprintf(\"%lld\\n\", (ll)fpw(2, m - 1) * (fpw(2, n) - fpw(2, n - cnt) + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\ntypedef pair<ll,P> PP;\ntypedef vector<ll> vll;\n\nconst ll INF=(1LL<<50);\n\nconst long long MOD = 998244353;\n/*bool operator < (const vector<long long> &a,const vector<long long> &b){\n    bool ret=false;\n    DEBUG(\"called\");\n    for(long long i = 0; i < a.size(); i++){\n        if(a[i]>b[i]){\n            ret=false;\n            break;\n        }else if(a[i]<b[i]){\n            ret=true;\n            break;\n        }\n    }\n    return ret;\n}\n*/\nll cache_pow[600];\nll mpow(ll a){\n    static bool flag=false;\n    if(flag){\n        DEBUG(\"True\");\n        return cache_pow[a];\n    }else{\n        cache_pow[0]=1;\n        for(long long i = 1; i < 600; i++){\n            cache_pow[i]=(cache_pow[i-1]*2)%MOD;\n        }\n        flag=true;\n        return cache_pow[a];\n    }\n}\nvoid solve(long long N, long long M, std::vector<std::vector<long long>> a){\n    sort(a.begin(),a.end(),greater<vll>());\n    ll index=0;\n\n    vector<bitset<300>> A;\n    for(long long i = 0; i < a.size(); i++){\n        A.push_back(bitset<300>(0));\n        for(long long k = 0; k < a[i].size(); k++){\n            A[i][k]=a[i][k]==1;\n        }\n    }\n    ll rank=0;\n    for(long long i = 0; i < a.size(); i++){\n        DEBUG(i);\n        for(; index < a[i].size(); index++){\n            DEBUG(index);\n            for(long long j = i; j < a.size(); j++){\n                if(A[j][index]==1){\n                    if(j!=i)\n                        swap(A[j],A[i]);\n                    goto OUT;\n                }\n            }\n        }\n        OUT:\n        if(index==a[i].size()){\n            break;\n        }\n        rank++;\n        for(long long j = i+1; j < a.size(); j++){\n            if(A[j][index]==1){\n                A[j]^=A[i];\n            }\n        }\n    }\n    DEBUG(rank);\n    cout<<mpow(M+N-1)-mpow(M+N-1-rank)<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n    std::vector<std::vector<long long>> a(N, std::vector<long long>(M));\n    for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < M ; j++){\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    solve(N, M, std::move(a));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\n\nint compute_rank(vector< vector< int > > A) {\n    int n = A.size();\n    int m = A[0].size();\n    // cout << n << \" \" << m << endl;\n    int rank = n;\n    vector<bool> row_selected(n, false);\n    for (int i = 0; i < m; ++i) {\n        int j;\n        for (j = 0; j < n; ++j) {\n            if (!row_selected[j] && A[j][i])\n                break;\n        }\n\n        if (j == n) {\n            // --rank;\n        } else {\n            row_selected[j] = true;\n            for (int p = i + 1; p < m; ++p)\n                A[j][p] /= A[j][i];\n            \n            A[j][i] = 1;\n\n            for (int k = 0; k < n; ++k) {\n                if (k != j && A[k][i]) {\n                    for (int p = i + 1; p < m; ++p)\n                        A[k][p] -= A[j][p] * A[k][i];\n\n                    A[k][i] = 0;\n                }\n            }\n        }\n    }\n\n    for(int i = 0 ; i < n ; i++){\n        bool has_one = false;\n\n        for(int j = 0 ; j < m ; j++){\n            if(A[i][j]){\n                has_one = true;\n                break;\n            }\n        }\n\n        if(!has_one){\n            rank--;\n        }\n    }\n\n    return rank;\n}\n\nvector< vector< int > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            int x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = compute_rank(a);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n);\n    ll nr = fast_pow(2LL, n - rank);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD((nn - nr) * mm) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 305, MOD = 998244353;\nbitset<N> b[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int x;\n            cin >> x;\n            b[i][j] = x;\n        }\n    }\n\n    ll bad = 1;\n\n    for (int i = 0, j = 0; i < m; i++) {\n        int sel = -1;\n        for (int k = j; k < n; k++) {\n            if (b[k][i]) {\n                sel = k;\n                break;\n            }\n        }\n        if (sel == -1) {\n            bad = bad * 2 % MOD;\n        }\n        else {\n            swap(b[sel], b[j]);\n            for (int k = 0; k < n; k++) {\n                if (j != sel) {\n                    if (b[k][i]) {\n                        b[k] ^= b[j];\n                    }\n                }\n            }\n            j++;\n        }\n    }\n\n    ll ans = 1;\n    for (int i = 0; i < m; i++) {\n        ans = ans * 2 % MOD;\n    }\n\n    ans = (ans - bad + MOD) % MOD;\n\n    for (int i = 0; i < n - 1; i++) {\n        ans = ans * 2 % MOD;\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MOD 998244353\n#define MAX 350\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint fpow(int a,int b)\n{\n\tint s=1;\n\twhile(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}\n\treturn s;\n}\nint n,m,tot,a[MAX][MAX],s[MAX];\nint p[MAX][MAX];bool vis[MAX];\nvoid Insert(int x)\n{\n\tfor(int i=1;i<=m;++i)\n\t\tif(a[x][i])\n\t\t{\n\t\t\tif(vis[i])\n\t\t\t{\n\t\t\t\tfor(int j=1;j<=m;++j)a[x][j]^=p[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++tot;vis[i]=true;\n\t\t\tfor(int j=1;j<=m;++j)p[i][j]=a[x][j];break;\n\t\t}\n}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=m;++j)\n\t\t\ta[i][j]=read();\n\tfor(int i=1;i<=n;++i)Insert(i);\n\tint ans=1ll*(fpow(2,n)-fpow(2,n-tot)+MOD)*fpow(2,m-1)%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass reverse_range {private:struct I {int x;int operator*() {return x-1;}bool operator!=(I& lhs) {return x>lhs.x;}void operator++() {--x;}};I i, n;public:reverse_range(int n) :i({ 0 }), n({ n }){}reverse_range(int i, int n) :i({ i }), n({ n }){}I& begin() {return n;}I& end() {return i;}};\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }reverse_range operator!(){return reverse_range(*i,*n);}};\n\nconstexpr int mod = 998244353;\nint R,C;\nint A[312][312];\nLL pow_mod(LL a,LL n,int M=mod){\n    LL res=1;\n    a%=M;\n    while(n){\n        if(n&1)\n            res=(res*a)%M;\n        a=(a*a)%M;\n        n>>=1;\n    }\n    return res;\n}\nint get_rank(){\n    int ret = 0;\n    for(int c:range(C)){\n        int id=-1;\n        for(int i:range(ret,R)){\n            if(A[i][c]==1){\n                id=i;\n            }\n        }\n        if(id==-1)continue;\n        for(int j:range(C)){\n            swap(A[ret][c],A[id][c]);\n        }\n        ret++;\n        for(int i:range(ret,R)){\n            if(A[i][c]==1)for(int j:range(C)){\n                A[i][j] = A[i][j] xor A[ret-1][j];\n            }\n        }\n    }\n    return ret;\n}\nint main(){\n    cin>>R>>C;\n    for(int i:range(R))for(int j:range(C)){\n        cin>>A[i][j];\n    }\n    LL ret=pow_mod(2,R+C-1)-pow_mod(2,R+C-1-get_rank());\n    cout<<ret%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return max(low, min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { t = clamp(t, low, high); }\n\nnamespace __init {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifdef DEBUGGING\n#include \"../debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <int N> using BS = bitset<N>;\ntemplate <int N> using Matrix = V<BS<N>>;\n\ntemplate <size_t Row, size_t Col>\ntuple<Matrix<Col>, BS<Row>, ll> gauss_elim(Matrix<Col> mat, BS<Row> b) {\n    ll fcnt = 0;\n    ll upper_row = 0;\n    for(ll col = 0; col < Col; col++) {\n        ll row = -1;\n        for(ll r = upper_row; r < mat.size(); r++) {\n            if(mat[r].test(col)) {\n                row = r;\n                break;\n            }\n        }\n        if(row == -1) {\n            fcnt++;\n            continue;\n        }\n        swap(mat[upper_row], mat[row]);\n        bool tmp = b[upper_row];\n        b.set(upper_row, b[row]);\n        b.set(row, tmp);\n        for(ll r = 0; r < mat.size(); r++) {\n            if(r == upper_row) continue;\n            if(!mat[r].test(col)) continue;\n            mat[r] ^= mat[upper_row];\n            bool tmp = b[r] ^ b[upper_row];\n            b.set(r, tmp);\n        }\n        upper_row++;\n    }\n    return make_tuple(mat, b, fcnt);\n}\n\ntemplate <size_t Row, size_t Col>\ntuple<Matrix<Col>, ll> gauss_elim(Matrix<Col> mat) {\n    auto tmp = gauss_elim<Row, Col>(mat, BS<Row>(0));\n    return make_tuple(get<0>(tmp), get<2>(tmp));\n}\n\nconst ll mod = 998244353;\nconst ll bsize = 310;\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n    \n    Matrix<bsize> mat;\n    for(ll i = 0; i < N; i++) {\n        BS<bsize> bs(0);\n        for(ll j = 0; j < M; j++) {\n            ll a;\n            cin >> a;\n            bs.set(j, a);\n        }\n        mat.push_back(move(bs));\n    }\n\n    auto result = gauss_elim<bsize, bsize>(mat);\n    \n    ll rank = bsize - get<1>(result);\n\n    ll ans = 1;\n    for(ll i = 0; i < N + rank; i++) (ans *= 2) %= mod;\n    ll minus = 1;\n    for(ll i = 0; i < rank; i++) (minus *= 2) %= mod;\n    minus++;\n    for(ll i = 0; i < N - 1; i++) (minus *= 2) %= mod;\n    (ans += mod - minus) %= mod;\n    for(ll i = 0; i < M - rank; i++) (ans *= 2) %= mod;\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Pct puts(\"------ Yes ------\");\n#define rep(a, b, c) for(int a = (b); a <= (c); ++ a)\n#define per(a, b, c) for(int a = (b); a >= (c); -- a)\n#define fir first\n#define sec second\n#define ls son[u][0]\n#define rs son[u][1]\n#define eps 1e-8\n#define PI acos(-1.0)\nusing namespace std;\ntemplate <class T> void rd(T &x){ x = 0; int f = 1; char ch = getchar(); while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); } while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar(); x *= f; }\n\ntypedef long long ll;\nconst int maxn = 305;\nconst int mod = 998244353;\nint n, m;\nint mat[maxn][maxn];\n\nint qpow(int x, int n){ int y = 1; while(n){ if(n & 1) y = (ll) y * x % mod; x = (ll) x * x % mod; n >>= 1; } return y; }\n\nint gauss(int n, int m){\n\tint r = 1, c = 1;\n\tfor(; r <= n && c <= m; r ++, c ++){\n\t\tint p = -1;\n\t\trep(i, r, n) if(mat[i][c]){ p = i; break; }\n\t\tif(p == -1){ r --; continue; }\n\t\tif(p != r) swap(mat[r], mat[p]);\n\t\trep(i, r + 1, n) if(mat[i][c])\n\t\t\tper(j, m, c) mat[i][j] ^= mat[r][j];\n\t}\n\treturn -- r;\n}\n\nint main(){\n\trd(n), rd(m);\n\trep(i, 1, n) rep(j, 1, m) rd(mat[i][j]);\n\tprintf(\"%d\\n\", (qpow(2, n + m - 1) - qpow(2, n + m - 1 - gauss(n, m)) + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n\tfact.resize(n+1);\n\tinv.resize(n+1);\n\tinvfact.resize(n+1);\n\tfact[0]=inv[0]=invfact[0]=1;\n\tinv[1]=1;\n\trep(i,n){\n\t\tfact[i+1]=fact[i]*(i+1)%mod;\n\t\tif(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n\t\tinvfact[i+1]=invfact[i]*inv[i+1]%mod;\n\t}\n}\nll perm(int n,int k){\n\tif(n<0||k<0||k>n)return 0;\n\treturn fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n\tif(n<0||k<0||k>n)return 0;\n\treturn (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n\tll ret=1;\n\twhile(k){\n\t\tif(k&1)ret=ret*n%mod;\n\t\tn=n*n%mod;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tmod_build();\n\tint n,m;\n\tcin>>n>>m;\n\tint a[n][m];\n\trep(i,n)rep(j,m)cin>>a[i][j];\n\tint cnt=0;\n\trep(i,n){\n\t\tbool ok=false;\n\t\tint idx = -1;\n\t\tfor(int j=cnt;j<m;++j)if(a[i][j]==1)ok=true,idx=j;\n\t\tif(!ok)continue;\n\t\tif(a[i][cnt]!=1){\n\t\t\trep(k,n)swap(a[k][cnt],a[k][idx]);\n\t\t}\n\t\trep(k,n)REP(j,cnt,m)a[k][j]^=a[k][cnt];\n\t\t++cnt;\n\t}\n\tll ans=powmod(2,m+n-1);\n\tans+=mod-powmod(2,n+m-cnt-1);\n\tcout<<ans%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld; //\ntypedef double db; //\ntypedef string str; //\n//\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl; //\ntypedef pair<ld,ld> pd; //\n#define mp make_pair\n#define f first\n#define s second\n\ntypedef vector<int> vi; \ntypedef vector<bool> vb;\ntypedef vector<ll> vl; //\ntypedef vector<ld> vd; //\ntypedef vector<str> vs; //\ntypedef vector<pi> vpi; //\ntypedef vector<pl> vpl; //\ntypedef vector<pd> vpd; //\ntypedef vector<vi> vvi;\n//\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() //\n#define rsz resize\n#define ins insert //\n#define ft front() //\n#define bk back() //\n#define pf push_front //\n#define pb push_back\n#define eb emplace_back //\n#define lb lower_bound //\n#define ub upper_bound //\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353; // = (119<<23)+1\nconst int MX = 2e5+5; //\nconst ll INF = 1e18; //\nconst ld PI = 4*atan((ld)1); \nconst int xd[4] = {0,1,0,-1}, yd[4] = {1,0,-1,0}; //\n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; }\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T;\n\tT val; \n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(ll v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.val == b.val; }\n\t/**friend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.val < b.val; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend ostream& operator<<(ostream& os, const mi& a) { \n\t\treturn os << a.val; }*/\n   \n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) { \n\t\tif ((val += m.val) >= MOD) val -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((val -= m.val) < 0) val += MOD; \n\t\treturn *this; }\n\t/// mi& operator++() { return *this += 1; }\n\t/// mi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\n\tmi& operator*=(const mi& m) { \n\t\tval = (ll)val*m.val%MOD; return *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { \n\t\tassert(!(a == 0)); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n    int N, M;\n    cin >> N >> M;\n\n    vi row(M);\n    vvi mat(N, row);\n\n    for (int r=0;r<N;r++) {\n        for (int c=0;c<M;c++) {\n            cin >> mat[r][c];\n        }\n    }\n\n    int rank = 0;\n    vb used(N, false);\n\n    for (int c=0;c<M;c++) {\n        int r = 0;\n        while (r < N && (used[r] || mat[r][c] == 0)) r++;\n\n        if (r == N) continue;\n        rank++;\n        used[r] = true;\n        for (int i=0;i<N;i++){\n            if (i == r) continue;\n            if (mat[i][c] == 1) {\n                for (int j=0;j<M;j++) {\n                    mat[i][j] ^= mat[r][j];\n                }\n            }\n        }\n    }\n\n    mi ans = pow(mi(2), M+N-1) - pow(mi(2), M+N-1-rank);\n    cout << ans.val << endl;\n\n    // cout << rank << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = 305, mod = 998244353;\nint n, m, pow2[N << 1];\nvector< bitset<N> > basis;\n\nint lstBit(bitset<N> x) {\n    int ret = -1;\n    for (int i = 0; i < N; ++i) if (x[i]) ret = i;\n    return ret;\n}\n\nvoid updBasis(bitset<N> val) {\n    for (int i = 0; i < (int)basis.size(); ++i) {\n        if (!val.count() ) return ;\n        auto _ = basis[i];\n        int lst_ = lstBit(_),\n            lstVal = lstBit(val);\n        if (lst_ == lstVal) val ^= _;\n        else if (lst_ < lstVal) {\n            basis.insert(basis.begin() + i, val);\n            return ;\n        }\n    }\n    if (val.count() ) basis.push_back(val);\n}\n\nint add(int _a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n    return _a;\n}\nint sub(int _a, int _b) { return add(_a, mod - _b); }\nint mul(int _a, int _b) { return (int)( (ll)_a * _b % mod); }\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        bitset<N> val;\n        for (int j = 1; j <= m; ++j) {\n            int a; cin >> a;\n            val[j] = a;\n        }\n        updBasis(val);\n    }\n\n    pow2[0] = 1; for (int i = 1; i < (N << 1); ++i) pow2[i] = (int)(2 * pow2[i - 1] % mod);\n\n    cout << sub(pow2[n + m - 1], pow2[n + m - 1 - (int)basis.size()]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <limits.h>\nusing namespace std;\ntypedef long long LL;\ntypedef bitset<300> BS;\nconst int B=300;\nconst int N=400;\nconst BS one=BS().set(0);\nconst BS zero=BS();\nconst LL M=998244353;\n\nstruct LB {\n\tint sz;\n\tBS b[B];\n\n\tvoid build(BS *a,int n) {\n\t\tsz=0;\n\t\tfor(int i=0;i<B;i++) {\n\t\t\tb[i].reset();\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tBS x=a[i];\n\t\t\tfor(int j=B-1;j>=0;j--) {\n\t\t\t\tif(((x>>j)&one)==one) {\n\t\t\t\t\tif(b[j]!=zero) x^=b[j];\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[j]=x;\n\t\t\t\t\t\tsz++;\n\t\t\t\t\t\tfor(int k=j-1;k>=0;k--) {\n\t\t\t\t\t\t\tif(b[k]!=zero && ((b[j]>>k)&one)==one) b[j]^=b[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=j+1;k<B;k++) {\n\t\t\t\t\t\t\tif(((b[k]>>j)&one)==one) b[k]^=b[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}lb;\n\nint n,m,b;\nBS a[N];\nLL dp[N],P[N],inv_P[N],pw[N];\n\nLL exgcd(LL a,LL b,LL &x,LL &y) {\n\tLL d=a;\n\tif(b!=0) {\n\t\td=exgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}\n\telse {\n\t\tx=1;y=0;\n\t}\n\treturn d;\n}\n\nLL mod_inv(LL a,LL m) {\n\tLL x,y;\n\texgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nvoid init() {\n\tP[0]=1;\n\tinv_P[0]=1;\n\tpw[0]=1;\n\tfor(int i=1;i<N;i++) {\n\t\tP[i]=P[i-1]*i%M;\n\t\tinv_P[i]=mod_inv(P[i],M);\n\t\tpw[i]=pw[i-1]*2%M;\n\t}\n}\n\nLL C(int n,int m) {\n\treturn P[n]*inv_P[m]%M*inv_P[n-m]%M;\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++) {\n\t\ta[i].reset();\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tscanf(\"%d\",&b);\n\t\t\tif(b) a[i].set(j);\n\t\t}\n\t}\n\tlb.build(a,n);\n\n\tdp[0]=1;\n\tfor(int i=0;i<B;i++) {\n\t\tint l=lb.b[i].count();\n\t\tif(l==0) continue;\n\t\tfor(int j=m;j>=0;j--) {\n\t\t\tif(j+l<=m) dp[j+l]+=dp[j],dp[j+l]%=M;\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=m;i++) {\n\t\tfor(int j=1;j<=i;j+=2) {\n\t\t\tans+=C(i,j)*dp[i]%M*pw[m-i]%M;\n\t\t\tans%=M;\n\t\t}\n\t}\n\tans*=pw[n-lb.sz],ans%=M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll matrixrank(vector< vector<double> > mat) {\n    ll h = mat.size();\n    ll w = mat[0].size();\n    ll now = 0;\n    for (ll i = 0; i < w; i++) {\n        ll pivot = now;\n        for (ll j = now + 1; j < h; j++) {\n            if (abs(mat[pivot][i]) > eps) {\n                break;\n            }\n            pivot = j;\n        }\n        if (abs(mat[pivot][i]) < eps) {\n            continue;\n        }\n        swap(mat[now], mat[pivot]);\n        for (ll j = i + 1; j < w; j++) {\n            mat[now][j] /= mat[now][i];\n        }\n        for (ll j = now + 1; j < h; j++) {\n            for (ll k = i + 1; k < w; k++) {\n                mat[j][k] -= mat[j][i] * mat[now][k];\n            }\n        }\n        now++;\n        if (now == h) {\n            break;\n        }\n    }\n    return now;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n    ll a[N][M];\n    REP(i, 0, N) {\n        REP(j, 0, M) {\n            cin >> a[i][j];\n        }\n    }\n    vector< vector<double> > mat(N);\n    REP(i, 0, N) {\n        mat[i].resize(M);\n        REP(j, 0, M) {\n            mat[i][j] = a[i][j];\n        }\n    }\n    ll rank = matrixrank(mat);\n    // cout << rank << endl;\n    ll ans = modminus(modpower(2, N + M - 1), modpower(2, N + M - rank - 1));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nll mod = 998244353;\nvvi a;\n\nvoid _main(istream &inp){\n    int n,m;\n    inp >> n >> m;\n    a = vvi(n, vi(m));\n    rep(x,n) rep(y,m) inp >> a[x][y];\n    //debug(a);\n    rep(x,n) rep(y,m) a[x][y]%=2;\n    int rank = 0;\n    int cur_x = 0;\n    rep(y,m){\n        FOR(x,cur_x+1,n){\n            if(a[x][y]==1 && a[cur_x][y]==0){\n                swap(a[x], a[cur_x]);\n            }\n            if(a[x][y]==1 && a[x][y]==1){\n                rep(y2,m) a[x][y2]^=a[cur_x][y2];\n            }\n            \n        }\n        if(a[cur_x][y]==1){\n            rank += 1;\n            cur_x += 1;\n        }\n    }\n    //debug(rank);\n    //debug(a);\n    ll ret = 1;\n    rep(i,rank) ret = 2*ret%mod;\n    ret = (ret+mod-1)%mod;\n    rep(i,n+m-rank-1 ) ret = 2*ret%mod;\n    cout << ret << endl;\n\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\n\nint compute_rank(vector< vector< int > > A) {\n    int n = A.size();\n    int m = A[0].size();\n    // cout << n << \" \" << m << endl;\n    int rank = n;\n    vector<bool> row_selected(n, false);\n    for (int i = 0; i < m; ++i) {\n        int j;\n        for (j = 0; j < n; ++j) {\n            if (!row_selected[j] && A[j][i])\n                break;\n        }\n\n        if (j == n) {\n            // --rank;\n        } else {\n            row_selected[j] = true;\n            for (int p = i + 1; p < m; ++p)\n                A[j][p] /= A[j][i];\n            for (int k = 0; k < n; ++k) {\n                if (k != j && A[k][i]) {\n                    for (int p = i + 1; p < m; ++p)\n                        A[k][p] -= A[j][p] * A[k][i];\n                }\n            }\n        }\n    }\n\n    for(int i = 0 ; i < n ; i++){\n        if(!row_selected[i]){\n            --rank;\n        }\n    }\n\n    return rank;\n}\n\nvector< vector< int > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            int x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = compute_rank(a);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n);\n    ll nr = fast_pow(2LL, n - rank);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD((nn - nr) * mm) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nconst ll MOD=998244353;\nll n,m,a[310][310];\n\nll ad(ll x,ll y){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll rnk(ll n,ll m,ll M[][310]){\n  ll t=0,y=0;\n  bool f;\n  for(;;){\n    f=0;\n    if(M[t][y]==0){\n      f=1;\n      for(ll i=t+1;i<n;i++){\n        if(M[i][y]!=0){\n          f=0;\n          swap(M[t],M[i]);\n        }\n      }\n    }\n    if(f && y<m-1){y++;continue;}\n    if(f) return t;\n    for(ll i=t+1;i<n;i++){\n      if(M[i][y]==0) continue;\n      for(ll j=y;j<m;j++){\n        M[i][j]=(M[i][j]+M[t][j])%2;\n      }\n    }\n    t++;\n    if(t==n) return n;\n  }\n}\n\nint main(){\n  cin>>n>>m;\n  fr(i,n) fr(j,m) cin>>a[i][j];\n  cout<<ad(pwr(2,n+m-1),MOD-pwr(2,n+m-1-rnk(n,m,a)))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T> LLI power(T n, T p, T m){if(p==0) return 1LL; if(p==1) return n; LLI k = power(n, p/2, m); return ((k*k)%m*(p%2?n:1))%m;}\n\nconst LLI mod = 998244353;\nconst double eps = 1e-9;\n\ntemplate <typename T> vector<vector<T>> transpose(vector<vector<T>> mat){\n  int n = mat.size();\n  int m = mat[0].size();\n\n  vector<vector<T>> ret(m, vector<T>(n));\n\n  REP(i,n) REP(j,m) ret[j][i] = mat[i][j];\n  \n  return ret;\n}\n\ntemplate <typename T> int rank_matrix(vector<vector<T>> mat){\n\n  int n = mat.size();\n  int m = mat[0].size();\n  int p = 0;\n\n  if(n > m){\n    auto t = transpose(mat);\n    mat.swap(t);\n    swap(n,m);\n  }\n\n  REP(i,n){\n    if(p>=m) break;    \n\n    bool b = true;\n    FOR(j,i,n) if(abs(mat[j][p]) > eps) b = false;\n\n    if(b){\n      ++p;\n      continue;\n    }\n\n    if(abs(mat[i][p]) <= eps ){\n      FOR(j,i+1,n){\n\tif(abs(mat[j][p]) > eps){\n\t  swap(mat[i], mat[j]);\n\t  break;\n\t}\n      }\n    }\n    \n    FOR(j,i+1,n){\n      double t = (double)mat[j][p] / mat[i][p];\n      REP(k,m) mat[j][k] -= mat[i][k] * t;\n    }\n  }\n\n  int r = 0;\n  REP(i,n){\n    REP(j,m){\n      if(mat[i][j] != 0){\n\t++r;\n\tbreak;\n      }\n    }\n  }\n  \n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  while(cin >> N >> M){\n    vector<vector<double>> a(N, vector<double>(M)); cin >> a;\n    int r = rank_matrix(a);\n    dump(r);\n    \n    LLI ans = (power(2LL,(LLI)(N+M-1),mod) - power(2LL,(LLI)(N+M-r-1),mod) + mod) % mod;\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<bitset> \n#include<map>\nusing namespace std;\nconst int maxd=998244353,N=100000;\nconst double pi=acos(-1.0);\ntypedef long long ll;\nint n,m,cnt=0;\nll bin[320];\nbitset<320> a[320],p[320];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n\twhile ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n\treturn x*f;\n}\n\nint main()\n{\n\tn=read();m=read();\n\tint i,j;\n\tbin[0]=1;\n\tfor (i=1;i<=300;i++) bin[i]=(bin[i-1]*2)%maxd;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tfor (j=1;j<=m;j++) \n\t\t{\n\t\t\tint tmp=read();\n\t\t\tif (tmp) a[i][j]=1;\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tfor (j=1;j<=m;j++)\n\t\t{\n\t\t\tif (a[i][j])\n\t\t\t{\n\t\t\t\tif (p[i][j]) a[i]^=p[i];\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tp[i]=a[i];\n\t\t\t\t\tcnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=(((bin[n]-bin[n-cnt])*bin[m-1])%maxd+maxd)%maxd;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n\nstruct fast_io {\n    static constexpr int size_in = 1 << 26, size_out = 1 << 26;\n    char data_in[size_in], data_out[size_out], *p_in, *p_out, s[30];\n    fast_io() { fread(data_in, 1, size_in, stdin), p_in = data_in, p_out = data_out; }\n    ~fast_io() { fwrite(data_out, 1, p_out - data_out, stdout); }\n    void putchar(char x) { *p_out++ = x; }\n    template<typename T> void putint(T x) {\n        if (x < 0) { *p_out++ = '-', x = -x; }\n        int i = 0;\n        do { s[i++] = x % 10 + '0'; } while (x /= 10);\n        while (i--) { *p_out++ = s[i]; }\n    }\n    template<typename T=int> T getint() {\n        while (!isdigit(*p_in) && *p_in != '-') { p_in++; }\n        bool negative = *p_in == '-';\n        T ret = negative ? 0 : *p_in - '0';\n        while (isdigit(*++p_in)) { (ret *= 10) += *p_in - '0'; };\n        return negative ? -ret : ret;\n    }\n} io;\n\ntemplate<typename T> std::vector<T> xor_eliminate(std::vector<T> &src) {\n    std::vector<T> ret;\n    for (int i = 0; i < src.size(); i++) {\n        for (int j = src.size() - 1; j > i; j--) {\n            int x = src[j]._Find_first(), y = src[j - 1]._Find_first();\n            if (x < y) { src[j - 1] ^= src[j]; }\n            if (x <= y) { src[j] ^= src[j - 1]; }\n        }\n        if (src[i].none()) { break; }\n        ret.emplace_back(src[i]);\n    }\n    /*\n    for (int i = ret.size() - 1; i > 0; i--) {\n        for (int j = 0; j < i; j++) {\n            if (ret[j][ret[i]._Find_first()]) { ret[j] ^= ret[i]; }\n        }\n    }\n    */\n    return ret;\n}\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nint main() {\n    int N = io.getint(), M = io.getint();\n    using bset = bitset<300>;\n    vector<bset> b(N);\n    rep(i, N) {\n        rep(j, M) {\n            int a = io.getint();\n            b[i][j] = a;\n        }\n    }\n    using mint = mod_int<998244353>;\n    io.putint((mint(2).pow(N + M - 1) - mint(2).pow(N + M - xor_eliminate(b).size() - 1)).val);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 998244353\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nclass MTwo{\npublic:\n    using t = bool;\n    static t id() {\n        return false;\n    }\n\tstatic t e() {\n        return true;\n    }\n\t// * \n    static t op1(const t& l, const t& r){\n        return l && r;\n    }\n\t// + \n\tstatic t op2(const t& l, const t& r){\n        return l ^ r;\n    }\n\t// - \n\tstatic t op3(const t& x){\n        return x;\n    }\n\t// /\n\tstatic t op4(const t& x) {\n        return x;\n    }\n};\ntemplate< typename M >\nstruct Matrix{\n\tusing T = typename M::t;\n\tint H;\n\tint W;\n\tvector<T> data;\n    Matrix(int n_)\n        : H(n_), W(n_), data(n_ * n_, M::id()) {}\n    Matrix(int h_, int w_)\n        : H(h_), W(w_), data(h_ * w_, M::id()) {}\n\tMatrix(int n_,vector<T> d_)\n        : H(n_), W(n_) {data = d_;}\n    Matrix(int h_, int w_, vector<T> d_)\n        : H(h_), W(w_) {data = d_;}\n  \tvoid Update(int h,int w,T x){\n    \tdata[h*W+w] = x;\n  \t}\n  \tconst T Get(int h,int w){\n    \treturn data[h*W+w];\n  \t}\n\tint Rank(){\n\t\tint ans = 0;\n\t\tvector<T> A(H*W);\n\t\tvector<bool> used(H);\n\t\tfor(int i=0;i<H*W;i++){\n\t\t\tA[i] = data[i];\n\t\t}\n\t\tfor(int i=0;i<W;i++){\n\t\t\tint nonzero = 0;\n\t\t\twhile(nonzero < H && (used[nonzero] || A[nonzero*W+i] != M::id())){\n\t\t\t\tnonzero++;\n\t\t\t}\n\t\t\tif(nonzero == H){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans++;\n\t\t\tused[nonzero] = true;\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(used[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tT d = M::op3(M::op1(M::op4(A[nonzero*W+i]),A[j*W+i])); \n\t\t\t\tfor(int k=i;k<W;k++){\n\t\t\t\t\tA[j*W+k] = M::op2(A[j*W+k],M::op1(A[nonzero*W+k],d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn ans;\n\t}\n\tstatic Matrix I(int N){\n\t\tMatrix ans(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans.Update(i,i,M::e());\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Plus(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op2(A.Get(i,j),B.Get(i,j)));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Minus(Matrix& A){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op3(A.Get(i,j)));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Minus(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tans.Update(i,j,M::op2(A.Get(i,j),M::op3(B.Get(i,j))));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Prod(Matrix& A,Matrix& B){\n\t\tint h = A.H;\n\t\tint w = B.W;\n\t\tint K = A.W;\n\t\tMatrix ans(h,w);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tT c = M::id();\n\t\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\t\tc = M::op2(c,M::op1(A.Get(i,k),B.Get(k,j)));\n\t\t\t\t}\n\t\t\t\tans.Update(i,j,c);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic Matrix Pow(Matrix A,long r){\n\t\tint n = A.H;\n\t\tMatrix ans = I(n);\n\t\twhile(r){\n\t\t\tif(r % 2 == 1){\n\t\t\t\tans = Prod(ans,A);\n\t\t\t}\n\t\t\tA = Prod(A,A);\n\t\t\tr /= 2;\n\t\t}\n\t\treturn ans;\n\t}\n};\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tvector<bool> A(N*M);\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\tint x = rei();\n\t\t\tA[i*M+j] = x % 2 == 1;\n\t\t}\n\t}\n\tMatrix<MTwo> mat(N,M,A);\n\tint r = mat.Rank();\n\tlong ans1 = 1;\n\tlong ans2 = 1;\n\tfor(int i=0;i<N+M-1;i++){\n\t\tans1 *= 2;\n\t\tans1 %= mod;\n\t}\n\tfor(int i=0;i<N+M-r-1;i++){\n\t\tans2 *= 2;\n\t\tans2 %= mod;\n\t}\n\tcout << (ans1 - ans2 + mod) % mod << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 305, p = 998244353;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n, m;\n  cin >> n >> m;\n  vector<bitset<M> > arr(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int x;\n      cin >> x;\n      arr[i][j] = x;\n    }\n  }\n  int rank = 0;\n  for (int i = 0; i < m; i++) {\n    int row = rank;\n    while (row < n && !arr[row][i]) {\n      row++;\n    }\n    if (row < n) {\n      swap(arr[row], arr[rank]);\n      for (int j = rank + 1; j < n; j++) {\n        if (arr[j][i]) {\n          arr[j] ^= arr[rank];\n        }\n      }\n      rank++;\n    }\n  }\n  vector<int> pow(n + m);\n  pow[0] = 1;\n  for (int i = 1; i < n + m; i++) {\n    pow[i] = pow[i - 1] * 2 % p;\n  }\n  cout << (pow[n + m - 1] - pow[n - rank + m - 1] + p) % p << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 302;\n\nint a[N][N];\nint n,m;\nconst int MOD =\n998244353;\nint main()\n{\n\ncin>>n>>m;\nvector<string>s;\nint lib = 1;\nfor(int i = 0; i < n; ++i) {\n    string act;\n    bool all = 1;\n    for(int j = 0; j < m; ++j) {\n        cin >> a[i][j];\n        act += a[i][j] + '0';\n        if(a[i][j] == 1) all = 0;\n    }\n    if(all) {\n        lib = lib * 2LL % MOD;\n    }\n    else s.push_back(act);\n}\nint p2m = 1;\nfor(int i = 1; i < m; ++i) p2m = p2m * 2LL % MOD;\nint ways = p2m;\nfor(int i = 1; i < (int)s.size(); ++i) {\n    if(s[i] == s[i - 1])\n        ways = 2 * ways % MOD;\n    else ways = 2*ways%MOD,ways=(ways+p2m)%MOD;}\n    cout<<1LL*lib*ways%MOD;}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 1e18;\nlong long int mod = 998244353;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1 , number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1 , number1);\n    }\n}\n\nll i,j,k,ii,jj,n,m,a,b,c,d,e,f,g,h,r,w,l,num,ans,ok,ng,mid;\nll x[500005],y[500005],z[500005];\nll dp[305][305];\nll sum[305];\nchar s[500005],t[500005],u[500005];\nbool dame,flag;\n//string s;\n\nint main(){\n\tcin >> n >> m;\n\tans = 1;\n\tfor(i=1;i<=n;i++){\n\t\tdame = true;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tcin >> x[j];\n\t\t\tif(x[j] == 1)dame = false;\n\t\t}\n\t\tif(dame){\n\t\t\ta++;\n\t\t\tans *= 2;\n\t\t\tans %= mod;\n\t\t}else{\n\t\t\tfor(j=1;j<=m;j++){\n\t\t\t\tdp[i-a][j] = x[j];\n\t\t\t}\n\t\t}\n\t}\n\tn -= a;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=m;j++){\n\t\t\tsum[i] += dp[i][j];\n\t\t\t//pe(dp[i][j]);\n\t\t}\n\t\t//el;\n\t}\n\t//sum[i] := i行目の総和\n\tdame = true;\n\tfor(i=1;i<=n;i++){\n\t\tif(sum[i] % 2 == 1){\n\t\t\tdame = false;\n\t\t}\n\t}\n\tif(!dame){\n\t\tans *= (rui(2,m-1)* (rui(2,n) - 1));\n\t}else{\n\t\tfor(j=1;j<=m;j++){\n\t\t\tsum[j] = 0;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tsum[j] += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tdame = true;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tif(sum[j] % 2 == 1)dame = false;\n\t\t}\n\t\tif(!dame){\n\t\t\tans *= (rui(2,n-1)* (rui(2,m) - 1));\n\t\t}else{\n\t\t\tans *= (rui(2,n-1)* (rui(2,m) - 2));\n\t\t}\n\t}\n\tp(ans);\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define MOD 998244353\n\nstruct mint {\n    int n;\n    mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator+(mint a, mint b) { a.n += b.n; if (a.n >= MOD) a.n -= MOD; return a; }\nmint operator-(mint a, mint b) { a.n -= b.n; if (a.n < 0) a.n += MOD; return a; }\nmint operator*(mint a, mint b) { return (long long)a.n * b.n % MOD; }\nmint &operator+=(mint &a, mint b) { return a = a + b; }\nmint &operator-=(mint &a, mint b) { return a = a - b; }\nmint &operator*=(mint &a, mint b) { return a = a * b; }\n\nbitset<300> A[300];\nmint pw[301];\nint H, W;\n\nint main() {\n    pw[0] = 1;\n    for (int i = 1; i <= 300; i++) {\n        pw[i] = 2 * pw[i - 1];\n    }\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int a;\n            scanf(\"%d\", &a);\n            A[i][j] = a;\n        }\n    }\n    int r = 0;\n    for (int j = 0; j < W && r < H; j++) {\n        int p = -1;\n        for (int i = r; i < H; i++) {\n            if (A[i][j]) {\n                p = i;\n                break;\n            }\n        }\n        if (p == -1) continue;\n        swap(A[p], A[r]);\n        for (int i = r + 1; i < H; i++) {\n            if (A[i][j]) {\n                A[i] ^= A[r];\n            }\n        }\n        r++;\n    }\n    map<int, int> mp;\n    int rr = 0;\n    for (int j = 0; j < W; j++) {\n        int none = 1;\n        for (int i = H - 1; i >= 0; i--) {\n            if (A[i][j]) {\n                mp[i]++;\n                none = 0;\n                break;\n            }\n        }\n        rr += none;\n    }\n    mint ans = pw[H - r] * pw[rr];\n    mint dp0 = 1;\n    mint dp1 = 0;\n    for (auto kv : mp) {\n        mint dp0_ = 0;\n        mint dp1_ = 0;\n        int k = kv.second;\n        dp0_ += dp0 * pw[k];\n        dp1_ += dp1 * pw[k];\n\n        dp0_ += dp0 * pw[k - 1];\n        dp1_ += dp1 * pw[k - 1];\n\n        dp1_ += dp0 * pw[k - 1];\n        dp0_ += dp1 * pw[k - 1];\n\n        dp0 = dp0_;\n        dp1 = dp1_;\n    }\n    printf(\"%d\\n\", (dp1 * ans).n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    using mint = mod_int<998244353>;\n    vector a(N, vint(M));\n    rep(i, N) rep(j, M) { cin >> a[i][j]; }\n    int r = 0;\n    rep(i, M) {\n        sort(a.begin() + r, a.begin() + N), reverse(a.begin() + r, a.begin() + N);\n        for (int j = r + 1; j < N; j++) {\n            if (a[r][i] == a[j][i]) {\n                for (int k = i; k < M; k++) { a[j][k] ^= a[r][k]; }\n            }\n        }\n        if (a[r][i]) { r++; }\n    }\n    cout << mint(2).pow(N + M - 1) - mint(2).pow(N + M - r - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <complex>\n#include <cassert>\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define case(i) cout<<\"Case #\"<<i<<\": \"\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, ll> pr;\ntypedef complex<double> com;\nconst int mod = 1e9 + 7;\nconst int MOD = 998244353;\nconst ll INF = 1e18;\n\ntypedef double number;\nconst number eps = 1e-8;\ntypedef vector<number> array1;\ntypedef vector<array1> matrix;\n\n// O( n )\nmatrix identity1(int n,int m) {\n\tmatrix A(n, array1(m));\n\treturn A;\n}\n// O( n^3 ).\nint rank1(matrix A) {\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[r]);\n\t\tif (abs(A[r][i]) < eps) continue;\n\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\tA[r][k] /= A[r][i];\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tfor (int k = i; k < m; ++k)\n\t\t\t\tA[j][k] -= A[r][k] * A[j][i];\n\t\t++r;\n\t}\n\treturn r;\n}\n\nll mpow(int n, int k, int p) {\n\tif (k == 0)return 1;\n\tif (k % 2)return n * mpow(n, k - 1, p) % p;\n\telse {\n\t\tint sub = mpow(n, k / 2, p);\n\t\treturn sub * sub% p;\n\t}\n}\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<array1> a=identity1(n,m);\n\trep(i, 0, n) {\n\t\trep(j, 0, m) cin >> a[i][j];\n\t}\n\tll r = rank1(a);\n\tll ans = (mpow(2, n + m - 1, MOD) - mpow(2, n + m - r - 1, MOD) + MOD) % MOD;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint main(){\n    int N, M, A[300][300];\n    cin >> N >> M;\n    for(int i=0; i<N; i++) for(int j=0; j<M; j++) cin >> A[i][j];\n\n    for(int i=0; i<N; i++){\n        int pivot = -1;\n        for(int j=i; j<N; j++){\n            if(A[i][j]){\n                pivot = j;\n                break;\n            }\n        }\n        if(pivot >= 0){\n            if(pivot != i) for(int k=0; k<M; k++) swap(A[pivot][k], A[i][k]);\n            for(int j=i+1; j<N; j++){\n                if(A[j][i]) for(int k=i; k<M; k++) A[j][k] ^ A[pivot][k];\n            }\n        }\n    }\n\n    int rank = 0;\n    for(int i=0; i<min(N, M); i++) rank += A[i][i];\n\n    int64_t ans = (MOD + power_mod(2, N+M-1) - power_mod(2, N+M-rank-1)) % MOD;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// by tmt514\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#define SZ(x) ((int)(x).size())\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 998244353;\nLL bigmod(LL a, LL n) {\n  if(n==0) return 1;\n  if(n==1) return a%MOD;\n  return bigmod(a*a%MOD, n/2) * (n%2? a:1)%MOD;\n}\nint a[1005][1005] = {};\nint main(void) {\n  int n, m;\n  cin >> n >> m;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      cin >> a[i][j];\n  int rank=0, w=0;\n  for(int i=0;i<m;i++) {\n    int g=-1;\n    for(int j=w;j<n;j++)\n      if(a[j][i]==1) {\n        g=j;\n        break;\n      }\n    if(g>=0) {\n      for(int k=0;k<m;k++)\n        swap(a[w][k], a[g][k]);\n      for(int j=w+1;j<n;j++)\n        for(int k=0;k<m;k++)\n          a[j][k] ^= a[w][k];\n      ++rank;\n      ++w;\n    }\n  }\n  LL t = bigmod(2, m-1) * (bigmod(2, n) - bigmod(2, n-rank)) % MOD;\n  t=(t%MOD+MOD)%MOD;\n  cout << t << endl;\n  \n      \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(0);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\ntemplate <int mod>\nclass ModInt {\npublic:\n    ModInt() : v(0) {}\n    ModInt(int x) : v((x+mod)%mod) {}\n    int value() const {return v;}\n    const ModInt operator+(const ModInt &r) const { return ModInt(this->v + r.v); }\n    const ModInt operator-(const ModInt &r) const { return ModInt(this->v + mod - r.v); }\n    const ModInt operator*(const ModInt &r) const { return ModInt(this->v * r.v); }\n    const ModInt operator/(const ModInt &r) const { return (*this * (~r)); }\n    const ModInt operator^(int k) const { return ModInt(bpow(this->v, k)); }\n    const ModInt operator~() const { return ModInt(bpow(this->v, mod-2)); }\n    bool operator==(const ModInt &r) const { return this->v == r.v; }\n    bool operator!=(const ModInt &r) const { return this->v != r.v; }\n    ModInt& operator+=(const ModInt &r) { return *this = *this + r; }\n    ModInt& operator-=(const ModInt &r) { return *this = *this - r; }\n    ModInt& operator*=(const ModInt &r) { return *this = *this * r; }\n    ModInt& operator/=(const ModInt &r) { return *this = *this * (~r); }\nprivate:\n    int v;\n    int bpow(int a, int b) const {\n        int ret = 1;\n        while (b > 0) {\n            if (b & 1) ret = (ret * a) % mod;\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return ret;\n    }\n};\nusing Mint = ModInt<998244353>;\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    vector<valarray<int>> mat(N);\n    REP(i, N) {\n        valarray<int> row(M);\n        REP(j, M) {\n            cin >> row[j];\n        }\n        mat[i] = row;\n    }\n    int rank = 0;\n    REP(i, min(N, M)) {\n        int col = [&] {\n            REPF(j, i, N) {\n                REPF(k, i, M) {\n                    if (mat[j][k] == 1) {\n                        swap(mat[j], mat[i]);\n                        return k;\n                    }\n                }\n            }\n            return -1LL;\n        }();\n        if (col == -1) break;\n\n        dump(i, col);\n        \n        REP(j, N) swap(mat[j][i], mat[j][col]);\n        rank++;\n\n        REPF(j, i + 1, N) {\n            if (mat[j][i] == 1) mat[j] ^= mat[i];\n        }\n    }\n\n    dump(rank);\n    FORE(r, mat) {\n        FORE(x, r) {\n            cerr << x << \" \";\n        }\n        cerr << endl;\n    }\n   \n    Mint ans = (Mint(2) ^ (N + M - 1)) - (Mint(2) ^ (N + M - rank - 1));\n    cout << ans.value() << endl;\n    return (0^_^0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#define P 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nbitset <305> bt[305];\n\nint n, m;\n\nll _2[777];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++) {\n            int v;\n            scanf(\"%d\", &v);\n            if(v == 1) bt[i - 1][j - 1] = 1;\n        }\n    for(int i = 0; i < 777; i++) _2[i] = !i ? 1 : _2[i - 1] * 2 % P;\n    int nw = 0;\n    for(int i = 0; i < m; i++) {\n        for(int j = nw; j < n; j++)\n            if(bt[j][i]) {\n                swap(bt[j], bt[nw]);\n                break;\n            }\n        if(!bt[nw][i]) continue;\n        for(int j = nw + 1; j < n; j++)\n            if(bt[j][i]) bt[j] ^= bt[nw];\n    }\n    int _1 = 0, _0 = 0;\n    bitset <305> empty;\n    for(int i = 0; i < n; i++) if(bt[i] == empty) _0++; else _1++;\n    ll ans = _2[m - 1] * (_2[_1] - 1) % P * _2[_0] % P;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n \n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if(a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if(a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = INT_MAX / 2; const ll INF = LLONG_MAX / 2;\n//template end\n\nint mod = 998242353;\nstruct Mint {\n  int val;\n  Mint inv() const {\n    int tmp, a = val, b = mod, x = 1, y = 0;\n    while(b) tmp = a / b, a -= tmp * b, swap(a, b), x -= tmp * y, swap(x, y);\n    return Mint(x);\n  }\npublic:\n  Mint() :val(0) {}\n  Mint(ll x) :val(x >= 0 ? x % mod : x % mod + mod) {}\n  int mtoi() { return this->val; }\n  Mint pow(ll t) { Mint res = 1,b = *this; while(t){if(t&1)res *= b;b *= b;t >>= 1;}return res; }\n  Mint& operator+=(const Mint& x) { if ((val += x.val) >= mod) val -= mod; return *this; }\n  Mint& operator-=(const Mint& x) { if ((val += mod - x.val) >= mod) val -= mod; return *this; }\n  Mint& operator*=(const Mint& x) { val = (ll)val * x.val % mod; return *this; }\n  Mint& operator/=(const Mint& x) { return *this *= x.inv(); }\n  bool operator==(const Mint& x) const { return val == x.val; }\n  bool operator!=(const Mint& x) const { return val != x.val; }\n  bool operator<(const Mint& x) const { return val < x.val; }\n  bool operator<=(const Mint& x) const { return val <= x.val; }\n  bool operator>(const Mint& x) const { return val > x.val; }\n  bool operator>=(const Mint& x) const { return val >= x.val; }\n  Mint operator+(const Mint& x) const { return Mint(*this) += x; }\n  Mint operator-(const Mint& x) const { return Mint(*this) -= x; }\n  Mint operator*(const Mint& x) const { return Mint(*this) *= x; }\n  Mint operator/(const Mint& x) const { return Mint(*this) /= x; }\n};\nstruct factorial {\n  vector<Mint> Fact, Finv;\npublic:\n  factorial(int maxx) {\n    Fact.resize(maxx+1,Mint(1)),Finv.resize(maxx+1); rep(i,0,maxx)Fact[i+1]=Fact[i]*Mint(i+1);\n    Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*Mint(i);\n  }\n  Mint fact(int n,bool inv) { if(inv) return Finv[n]; else return Fact[n]; }\n  Mint nPr(int n,int r) { if(n<0||n<r||r<0) return Mint(0); else return Fact[n]*Finv[n-r]; }\n  Mint nCr(int n,int r) { if(n<0||n<r||r<0) return Mint(0); else return Fact[n]*Finv[r]*Finv[n-r]; }\n};\n\ntypedef vector<vector<Mint>> mat;\nmat matmul(mat a, mat b) {\n\tmat ans(a.size(), vector<Mint>(b[0].size(), 0));\n\trep(i, 0, a.size())rep(j, 0, b[0].size())rep(k,0,b.size())ans[i][j] += a[i][k]*b[k][j];\n\treturn ans;\n}\nmat matpow(mat a, ll t) {\n\tmat ans(a.size());\n\trep(i, 0, a.size()) { ans[i].resize(a.size(), 0);ans[i][i] = 1;}\n\twhile (t) {if (t % 2) ans = matmul(ans, a); a = matmul(a, a); t >>= 1;}\n\treturn ans;\n}\nint gauss(mat& a,bool flag){//flag?linear:rank\n  int m=a.size(),n=a[0].size(),rank=0;\n  rep(j,0,n){\n    if(flag&&j==n-1)break;\n    int piv=-1;\n    rep(i,rank,m)if(a[i][j].mtoi()){piv=i; break;}\n    if(piv==-1)continue;\n    swap(a[piv],a[rank]);\n    rep(k,0,n)a[rank][k]/=a[rank][j];\n    rep(i,0,m){\n      if(i!=rank&&a[i][j].mtoi()){\n        rep(k,0,n) a[i][k]-=a[rank][k]*a[i][j];\n      }\n    } rank++;\n  }\n  return rank;\n}\n\nint main(){\n  int h,w; scanf(\"%d%d\",&h,&w);\n  mat a(h);\n  rep(i,0,h){\n    a[i].resize(w);\n    rep(j,0,w)scanf(\"%d\",&a[i][j]);\n  }\n  int r=gauss(a,false);\n  Mint base=2;\n  Mint ans=base.pow(h+w-1)-base.pow(h+w-r-1);\n  printf(\"%d\\n\",ans.mtoi());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll matrixrank(vector< vector<double> > mat) {\n    ll h = mat.size();\n    ll w = mat[0].size();\n    ll now = 0;\n    for (ll i = 0; i < w; i++) {\n        ll pivot = now;\n        for (ll j = now + 1; j < h; j++) {\n            if (abs(mat[pivot][i]) > eps) {\n                break;\n            }\n            pivot = j;\n        }\n        if (abs(mat[pivot][i]) < eps) {\n            continue;\n        }\n        swap(mat[now], mat[pivot]);\n        for (ll j = i + 1; j < w; j++) {\n            mat[now][j] /= mat[now][i];\n        }\n        for (ll j = now + 1; j < h; j++) {\n            for (ll k = i + 1; k < w; k++) {\n                mat[j][k] -= mat[j][i] * mat[now][k];\n            }\n        }\n        now++;\n        if (now == h) {\n            break;\n        }\n    }\n    return now;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n    ll a[N][M];\n    REP(i, 0, N) {\n        REP(j, 0, M) {\n            cin >> a[i][j];\n        }\n    }\n    vector< vector<double> > mat(N);\n    REP(i, 0, N) {\n        mat[i].resize(M);\n        REP(j, 0, M) {\n            mat[i][j] = a[i][j];\n        }\n    }\n    ll rank = matrixrank(mat);\n    // cout << rank << endl;\n    ll ans = modminus(modpower(2, N + M - 1), modpower(2, N + M - rank - 1));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n#include <atcoder/modint>\nusing namespace atcoder;\nusing mint = modint998244353;\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define Inf 1000000000000000\n\nvoid Gauss(vector<bitset<300>> &B){\n\tint now = 0;\n\trep(i,300){\n\t\tint temp = -1;\n\t\tfor(int j=now;j<B.size();j++){\n\t\t\tif(B[j][i]){\n\t\t\t\ttemp = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(temp==-1)continue;\n\t\t\n\t\trep(j,B.size()){\n\t\t\tif(temp==j)continue;\n\t\t\tif(B[j][i])B[j] ^= B[temp];\n\t\t}\n\t\t\n\t\tswap(B[now],B[temp]);\n\t\tnow++;\n\t}\n}\n\nint main(){\n\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tvector<bitset<300>> B(N);\n\t\n\trep(i,N){\n\t\trep(j,M){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tif(t==1){\n\t\t\t\tB[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tGauss(B);\n\t\n\tmint ans = mint(2).pow(M-1);\n\t\n\tmint diff = 1;\n\trep(i,N){\n\t\tif(B[i]==0){\n\t\t\tdiff *= 2;\n\t\t}\n\t}\n\t\n\tans *= mint(2).pow(N) - diff;\n\t\n\tcout<<ans.val()<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#include <random>\n#include <iomanip>\n#include <bitset>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 988244353;\nconstexpr long double eps = 1e-6;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << v[i];\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 1010101\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n \nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nusing ld = long double;\n\nint mat_rank(vector<vector<int>>& a) {\n    int n = (int)a.size(), m = (int)a[0].size();\n    int ret = 0;\n    REP(j, m) {\n        REP(i, n) {\n            if(a[i][j]) {\n                ret++;\n                REP(k, n) {\n                    if(i == k) continue;\n                    if(a[k][j] == 0) continue;\n                    REP(l, m) a[k][l] ^= a[i][l];\n                }\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> a(n, vector<int>(m));\n    REP(i, n) REP(j, m) cin >> a[i][j];\n    int r = mat_rank(a);\n    mi ans = (mod_pow(2, m) - mod_pow(2, m - r)) * mod_pow(2, n - 1);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nvoid Gauss(vector<vector<int>> &mat) {\n    \n    int n = (int)mat.size();\n\n    for(int i = 0; i < n; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        int fs = mat[i][i];\n\n        for(int j = i+1; j < n; j++) {\n            int r = mat[j][i] / fs;\n\n            for(int k = i; k < n; k++) {\n\n                mat[j][k] ^= mat[i][k] * r;\n            }\n        }\n    }\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    if(b == 1) return a;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(max(n, m),vi(max(n,m), 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    Gauss(rec);\n\n    int r = 0;\n    REP(i, n) {\n        bool ok = false;\n        REP(j, m) {\n            if(rec[i][j] > EPS) {\n                ok = true;\n                break;\n            }\n        }\n        if(ok) r++;\n    }\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing type = double;\nusing Vec = vector<type>;\nusing Mat = vector<Vec>;\n\nconst double EPS = 1e-3;\nbool isZero(type x) { return abs(x) <= EPS; }\n\n// sweep mat[i][j] 0<=i<m && 0<=j<c(default c=n)\n// return Vec{j| i,j s.t. minj mat[i][j]!=0}\nvector<int> sweep(Mat& mat, int c = -1) {\n  if (c == -1) c = mat[0].size();\n  int m = mat.size(), n = mat[0].size();\n  int row = 0;\n  vector<int> res;\n  for (int j = 0; j < c; j++) {\n    if (row == m) break;\n    int tar = -1;\n    type v = 0;\n    for (int i = row; i < m; i++) {\n      if (!isZero(mat[i][j]) && abs(v) < abs(mat[i][j])) {\n        tar = i;\n        v = mat[i][j];\n      }\n    }\n    if (tar == -1) continue;\n    if (row != tar) swap(mat[row], mat[tar]);\n    for (int i = 0; i < m; i++) {\n      if (i == row) continue;\n      if (!isZero(mat[i][j])) {\n        type r = mat[i][j] / mat[row][j];\n        for (int k = j; k < n; k++) {\n          mat[i][k] -= r * mat[row][k];\n        }\n      }\n    }\n    res.push_back(j);\n    row++;\n  }\n  return res;\n}\n\ntype det(Mat mat) {\n  sweep(mat);\n  type res = 1;\n  int sz = mat.size();\n  for (int i = 0; i < sz; i++) {\n    if (isZero(mat[i][i])) return type(0);\n    res *= mat[i][i];\n  }\n  return res;\n}\n\nint myrank(Mat mat) { return sweep(mat).size(); }\n\nusing ll = long long;\nconstexpr ll mod = 998244353;\n\ntemplate <typename T>\nT mypow(T a, T b) {\n  if (b == 0) return 1;\n  T tmp = mypow(a, b / 2);\n  if (b % 2)\n    return (((tmp * tmp) % mod) * a) % mod;\n  else\n    return (tmp * tmp) % mod;\n}\n\nint main() {\n    ll n,m;cin>>n>>m;\n    Mat a(n, Vec(m));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            cin >> a[i][j];\n        }\n    }\n    int r = myrank(a);\n    ll ret = mypow(2LL, n+m-1) + mod - mypow(2LL, n+m-r-1);\n    cout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// binary 行列 (行列累乗と、掃き出し法)\n//\n// verified:\n//   みんなのプロコン 2019 E - Odd Subrectangles\n//     https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n// \n\n\n#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n\nconst int MAX_ROW = 510; // to be set\nconst int MAX_COL = 510; // to be set\nstruct BitMatrix {\n    int n, m;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int n_ = 1, int m_ = 1) {n = n_; m = m_;}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n    inline friend ostream& operator << (ostream& s, BitMatrix M) {\n        s << endl; \n        for (int i = 0; i < M.n; ++i) {\n            for (int j = 0; j < M.m; ++j) s << M.val[i][j];\n            s << endl;\n        }\n        return s;\n    }\n};\n\ninline BitMatrix operator * (BitMatrix A, BitMatrix B) {\n    BitMatrix R(A.n, B.m);\n    BitMatrix tB(B.m, B.n);\n    for (int i = 0; i < tB.n; ++i) for (int j = 0; j < tB.m; ++j) tB[i][j] = B[j][i];\n    for (int i = 0; i < R.n; ++i) for (int j = 0; j < R.m; ++j) R[i][j] = (A[i] & tB[j]).any();\n    return R;\n}\n\ninline BitMatrix pow(BitMatrix A, long long n) {\n    BitMatrix R(A.n, A.n);\n    for (int i = 0; i < A.n; ++i) R[i][i] = 1;\n    while (n > 0) {\n        if (n & 1) R = R * A;\n        A = A * A;\n        n >>= 1;\n    }\n    return R;\n}\n\nint calc_rank(BitMatrix &A) {\n    int r = 0;\n\tfor (int i = 0; i < A.m; ++i) {\n\t\tint pivot = -1;\n\t\tfor (int j = r; j < A.n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot != -1) {\n\t\t\tswap(A[pivot], A[r]);\n\t\t\tfor (int j = 0; j < A.n; ++j) if (j != r && A[j][i]) A[j] ^= A[r];\n\t\t\t++r;\n\t\t}\n\t}\n    return r;\n}\n\nvector<vector<int> > linear_equation(BitMatrix A, vector<int> b) {\n\tint rank = 0;\n    for (int i = 0; i < A.n; ++i) { A[i][A.m] = b[i]; }\n    \n    vector<int> core, rem;\n\tfor (int i = 0; i < A.m; ++i) {\n\t\tint pivot = -1;\n\t\tfor (int j = rank; j < A.n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot != -1) {\n            core.push_back(i);\n\t\t\tswap(A[pivot], A[rank]);\n\t\t\tfor (int j = 0; j < A.n; ++j) if (j != rank && A[j][i]) A[j] ^= A[rank];\n\t\t\t++rank;\n\t\t}\n        else rem.push_back(i);\n\t}\n    \n    vector<vector<int> > res;\n    for (int i = rank; i < A.n; ++i) \n        if (A[i][A.m]) return res;     // return -1;\n    \n    vector<int> sol(A.m, 0);\n    for (int i = 0; i < core.size(); ++i) sol[core[i]] = A[i][A.m];\n    res.push_back(sol);\n    \n    for (int i = 0; i < rem.size(); ++i) {\n        vector<int> temp(A.m, 0);\n        temp[rem[i]] = 1;\n        for (int j = 0; j < core.size(); ++j) temp[core[j]] = A[j][rem[i]];\n        res.push_back(temp);\n    }\n    \n    return res;     // return A[0].size()-rank;\n};\n\n\nconst int MOD = 998244353;\nconst int MAX = 2100;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAX; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nlong long COM(int n, int k){\n    if(n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD;\n}\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    COMinit();  \n    int N, M; cin >> N >> M;\n    BitMatrix A(N, M);\n    for (int i = 0; i < N; ++i) for (int j = 0; j < M; ++j) {\n            int a; cin >> a;\n            if (a) A[i][j] = 1;\n        }\n    int r = calc_rank(A);\n    long long fact = modpow(2LL, N-r, MOD) * modpow(2LL, M-r, MOD) % MOD;\n    long long res = 0;\n    for (int i = 1; i <= r; ++i) {\n        long long tmp = COM(r, i) * modpow(2LL, i-1, MOD) % MOD * modpow(2LL, M-i, MOD) % MOD;\n        res = (res + tmp) % MOD;\n    }\n    res = (res * fact) % MOD;\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T> LLI power(T n, T p, T m){if(p==0) return 1LL; if(p==1) return n; LLI k = power(n, p/2, m); return ((k*k)%m*(p%2?n:1))%m;}\n\nconst LLI mod = 998244353;\nconst double eps = 1e-9;\n\ntemplate <typename T> int rank_matrix(vector<vector<T>> mat){\n\n  int n = mat.size();\n  int m = mat[0].size();\n  int p = 0;\n\n  REP(i,n){\n    if(p>=m) break;    \n\n    bool b = true;\n    FOR(j,i,n) if(abs(mat[j][p]) > eps) b = false;\n\n    if(b){\n      ++p;\n      continue;\n    }\n\n    if(abs(mat[i][p]) <= eps ){\n      FOR(j,i+1,n){\n\tif(abs(mat[j][p]) > eps){\n\t  swap(mat[i], mat[j]);\n\t  break;\n\t}\n      }\n    }\n    \n    FOR(j,i+1,n){\n      double t = (double)mat[j][p] / mat[i][p];\n      REP(k,m) mat[j][k] -= mat[i][k] * t;\n    }\n  }\n\n  int r = 0;\n  REP(i,n){\n    REP(j,m){\n      if(mat[i][j] != 0){\n\t++r;\n\tbreak;\n      }\n    }\n  }\n\n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  while(cin >> N >> M){\n    vector<vector<double>> a(N, vector<double>(M)); cin >> a;\n    int r = rank_matrix(a);\n    dump(r);\n    \n    LLI ans = power(2LL,(LLI)(M-1),mod) * ((power(2LL,(LLI)N,mod) - power(2LL,(LLI)(N-r),mod) + mod*mod) % mod);\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int p=998244353;\nint a[305][305],b[305][305];\nint read() {\n\tchar c=getchar(); int x=0,f=1;\n\twhile (c<'0' || c>'9') {\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint fpow(int x,int k) {\n\tint ans=1;\n\twhile (k) {\n\t\tif (k&1) ans=1LL*ans*x%p;\n\t\tx=1LL*x*x%p;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n=read(),m=read();\n\tfor (int i=1; i<=n; i++) {\n\t\tfor (int j=1; j<=m; j++) {\n\t\t\ta[i][j]=read();\n\t\t}\n\t}\n\tfor (int i=1; i<=m; i++) {\n\t\tfor (int j=1; j<=n; j++) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tif (b[j][j]) for (int k=j; k<=n; k++) a[i][k]^=b[j][k];\n\t\t\t\telse {\n\t\t\t\t\tfor (int k=j; k<=n; k++) b[j][k]=a[i][k];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tfor (int j=1; j<=n; j++) if (b[j][j]) ++cnt;\n\tprintf(\"%d\\n\", ((fpow(2,n+m-1)-fpow(2,n+m-cnt-1))%p+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod998 = 998244353;\nconst ll intmax = 2147483647;\nconst ll llmax = 9223372036854775807;\nconst char sp = ' ';\n\nint N, M;\nll c[302][302], res, dp[301];\n\nint main() {\n\tc[0][0] = 1;\n\tfor (int i = 0; i <= 300; i++) {\n\t\tfor (int j = 0; j <= 300; j++) {\n\t\t\tc[i][j] %= mod998;\n\t\t\tc[i + 1][j] += c[i][j];\n\t\t\tc[i][j + 1] += c[i][j];\n\t\t}\n\t}\n\tcin >> N >> M;\n\tmap<string, int>mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tchar ch;\n\t\t\tcin >> ch;\n\t\t\ts.push_back(ch);\n\t\t}\n\t\tmp[s]++;\n\t}\n\tstring s = string(M, '0');\n\tfor (int i = 0; i <= mp[s]; i++) {\n\t\tdp[i] = c[i][mp[s] - i];\n\t}\n\tmp[s] = 0;\n\tfor (auto p : mp) {\n\t\tint x = p.second;\n\t\tfor (int i = N; i >= 0; i--) {\n\t\t\tfor (int j = 0; j <= x&&i + j <= N; j += 2) {\n\t\t\t\tdp[i + j] += dp[i] * c[j][x - j];\n\t\t\t\tdp[i + j] %= mod998;\n\t\t\t}\n\t\t}\n\t}\n\tll t = 1;\n\tfor (int i = 1; i < M; i++) {\n\t\tt *= 2;\n\t\tt %= mod998;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tres += t*c[i][N - i];\n\t\tres %= mod998;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tres += mod998;\n\t\tres -= dp[i];\n\t\tres %= mod998;\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define MOD 998244353\ntypedef long long ll;\nusing namespace std;\n\nint N,M;\nint A[303][303];\n\nint Gauss(){\n    int rank=0;\n    for(int j=0;j<M;j++){\n        int pivot=-1;\n        for(int i=rank;i<N;i++){\n            if(A[i][j]){\n                pivot=i;\n                break;\n            }\n        }\n\n        if(pivot>=0){\n            if(pivot!=rank){\n                for(int k=0;k<M;k++) swap(A[pivot][k],A[rank][k]);\n            }\n            for(int i=rank+1;i<N;i++){\n                if(A[i][j]){\n                    for(int k=0;k<M;k++) A[i][k]^=A[rank][k];\n                }\n            }\n            rank++;\n        }\n    }\n    return rank;\n}\n\nll my_pow(ll x,ll n){\n    ll res=1;\n    while(n>0){\n        if(n&1) res=res*x%MOD;\n        x=x*x%MOD;\n        n/=2;\n    }\n    return res;\n}\n\nint main(){\n  cin>>N>>M;\n  for(int i=0;i<N;i++) for(int j=0;j<M;++j) cin>>A[i][j];\n\n  int rank=Gauss();\n\n  ll ans=my_pow(2ll,N-1+M)-my_pow(2ll,N-1+M-rank);\n  ans=(ans+MOD)%MOD;\n\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000000;\nconstexpr ll INF = 1000000000000000000;\nconstexpr ld EPS = 1e-12;\nconstexpr ld PI = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nconstexpr ll mod = 1000000007;\nconstexpr ll modsize = 0;\nvector<ll> fac(modsize);\nvector<ll> inv(modsize);\nvector<ll> facinv(modsize);\n\nvoid modcalc() {\n\tif (modsize == 0) abort();\n\tfac[0] = 1; fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = 1; facinv[1] = 1;\n\tfor (ll i = 2; i < modsize; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modinv(ll a) {\n\tif (a == 0) abort();\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0 || n == 0 && k > 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn fac[n + k - 1] * facinv[k] % mod * facinv[n - 1] % mod;\n}\n\nint mat_rank(vector<vector<int>> mat) {\n\tint n = mat.size();\n\tint m = mat[0].size();\n\tint st = 0;\n\trep(j, m) {\n\t\tint idx = -1;\n\t\tfor (int i = st; i < n; i++) {\n\t\t\tif (mat[i][j]) {\n\t\t\t\tif (idx == -1) {\n\t\t\t\t\tidx = i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(k, m) {\n\t\t\t\t\tmat[i][k] ^= mat[idx][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = st - 1; i >= 0; i--) {\n\t\t\tif (mat[i][j]) {\n\t\t\t\tif (idx == -1) continue;\n\t\t\t\trep(k, m) {\n\t\t\t\t\tmat[i][k] ^= mat[idx][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx != -1) {\n\t\t\trep(k, m) {\n\t\t\t\tswap(mat[idx][k], mat[st][k]);\n\t\t\t}\n\t\t\tst++;\n\t\t}\n\t}\n\treturn st;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> a(n, vector<int>(m));\n\trep(i, n) rep(j, m) cin >> a[i][j];\n\tint r = mat_rank(a);\n\tcout << modpow(2, n + m - r - 1)*(modpow(2, r) - 1) % mod << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 305\n#define INF 1000000000\n#define MOD 998244353\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m,a[MAXN][MAXN];\nint bas[MAXN];\nint pow_mod(int a,int i)\n{\n    int s=1;\n    while(i)\n    {\n        if(i&1) s=1LL*s*a%MOD;\n        a=1LL*a*a%MOD;\n        i>>=1;\n    }\n    return s;\n}\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nvoid dec(int &a,int b) {a-=b; if(a<0) a+=MOD;}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            scanf(\"%d\",&a[i][j]);\n    int cnt=0;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=m;j>=1;j--)\n        {\n            if(a[i][j])\n            {\n                if(!bas[j])\n                {\n                    bas[j]=i;\n                    cnt++;\n                    break;\n                }\n                for(int k=1;k<=m;k++) a[i][k]^=a[bas[j]][k];\n            }\n        }\n    }\n    int free=n-cnt,ans=1LL*pow_mod(2,n)%MOD;\n    int res=pow_mod(2,free);dec(ans,res);\n    ans=1LL*ans*pow_mod(2,m-1)%MOD;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define mp make_pair\n\nvoid print(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cout<<a[i]<<' ';\n    cout<<endl;\n}\n\nvoid get(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cin>>a[i];\n}\n\nconst ll p = 998244353;\n\nll mul(ll a, ll b) {\n    return (1LL * a * b) % p;\n}\n\nll add(ll a, ll b) {\n    int s = (a+b);\n    s = s%p;\n    if (s<0) s+=p; \n    return s;\n}\n\nll po(ll a, ll  deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    ll t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    \n    int n, m;\n    cin>>n>>m;\n    \n    vector<bitset<320>> a(n);\n    \n    bool t;\n    \n    for (int i = 0; i<n; i++)\n    for (int j = 0; j<m; j++) {cin>>t; a[i][j] = t;}\n    \n    vector<bool> visited(n);\n    \n    int degbasis = 0;\n    \n    for (int i = 0; i<m; i++)\n    {\n        int idx = 0;\n        while (idx<n && !(a[idx][i]==1&&!visited[idx])) idx++;\n        if (idx==n) continue;\n        visited[idx] = true;\n        degbasis++;\n        for (int i = 0; i<n; i++) if (i!=idx) a[i]^=a[idx];\n    }\n    \n    //cout<<degbasis<<endl;\n    \n    ll total = po(2, m+n - 1) - po(2, m+n-1-degbasis);\n    total%=p;\n    if (total<0) total+=p;\n    cout<<total;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(int i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(int i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const int x) { return 31-__builtin_clz(x); } // floor(log2(x))\ninline int fLog2(const ll x) { return 63-__builtin_clzll(x); }\ninline int cLog2(const int x) { return (x == 1) ? 0 : 32-__builtin_clz(x-1); } // ceil(log2(x))\ninline int cLog2(const ll x) { return (x == 1) ? 0 : 64-__builtin_clzll(x-1); }\ninline int popcount(const int x) { return __builtin_popcount(x); }\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\n\nconst int MAX_ROW = 310; // to be set appropriately\nconst int MAX_COL = 310; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nostream& operator << (ostream& s, BitMatrix A) {\n    s << endl; \n    for (int i = 0; i < A.H; ++i) {\n        for (int j = 0; j < A.W; ++j) {\n            s << A[i][j] << \", \";\n        }\n        s << endl;\n    }\n    return s;\n}\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\n\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this; }\n  mint operator+(const mint a) const { return mint(*this) += a; }\n  mint operator-(const mint a) const { return mint(*this) -= a; }\n  mint operator*(const mint a) const { return mint(*this) *= a; }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a; }\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\nint main() {\n  ll n, m; cin >> n >> m;\n  BitMatrix a(n, m);\n  rep(i, n) rep(j, m) {\n    int x; cin >> x;\n    a[i][j] = x;\n  }\n\n  int r = GaussJordan(a);\n  mint ans = 1;\n  ans *= mint(2).pow(n-1);\n  ans *= mint(2).pow(m) - mint(2).pow(m-r);\n\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MaxN = 303;\n\nint a[MaxN][MaxN];\nint n, m;\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n\n    cin >> n >> m;\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= m; ++j)\n            cin >> a[i][j];\n\n    int r = 0;\n\n    for(int i = 1; i <= m; ++i)\n    {\n        int y = 0;\n        for(int j = 1; y == 0 && j <= n; ++j)\n            if(a[j][i] == 1)\n                y = j;\n\n        if(!y)\n            continue;\n\n        ++r;\n\n        for(int j = 1; j <= n; ++j)\n            if(a[j][i] == 1 && j != y)\n                for(int k = i; k <= m; ++k)\n                    a[j][k] ^= a[y][k];\n\n        for(int k = i; k <= m; ++k)\n            a[y][k] = 0;\n    }\n\n    int ans = 1;\n\n    for(int i = 1; i <= n + m - 1; ++i)\n        ans = (ans + ans) % MOD;\n\n    int s = 1;\n    for(int i = 1; i <= n + m - 1 - r; ++i)\n        s = (s + s) % MOD;\n\n    ans -= s;\n\n    if(ans < 0)\n        ans += MOD;\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 998244353LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                // C[i][j] += A[i][k] * B[k][j]; // modなし\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// Matrix Library End\n\n// N * M 行列のランクを求める\ntemplate <typename T>\nint mat_rank(Matrix<T> A) {\n    int N = A.size(), M = A[0].size();\n\n    int WID = min(N, M);\n    for(int i=0; i<WID; i++) {\n        {\n            // 非零要素を探す (i 行目以降で、どこかが非零である列があればよい)\n            T nonzero = 0; int piv = -1;\n            for(int j=i; j<N; j++) {\n                for(int k=i; k<M; k++) {\n                    if(A[j][k] != 0) {\n                        nonzero = A[j][k];\n                        piv = k;\n                    }\n                }\n            }\n            // 非零要素が存在しない\n            if(nonzero == 0) return i;\n            \n            // i 列目と piv 列目を入れ替える\n            for(int j=0; j<N; j++) {\n                swap(A[j][i], A[j][piv]);\n            }\n        }\n\n        {\n            // i 列目の中で、絶対値が最も大きいものを探す\n            T max_elem = 0; int piv = -1;\n            for(int j=i; j<N; j++) {\n                if(abs(A[j][i]) > max_elem) {\n                    max_elem = abs(A[j][i]);\n                    piv = j;\n                }\n            }\n\n            // i 行目を piv 行目に変えて、行基本変形\n            swap(A[i], A[piv]);\n\n            /*\n            for(int x=0; x<N; x++) {\n                for(int y=0; y<M; y++) {\n                    fprintf(stderr, \"%lld \", A[x][y]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n            */\n            \n            for(int j=0; j<N; j++) {\n                if(i == j) continue;\n                assert(A[i][i] != 0);\n                T ratio = 1.0 * A[j][i] / A[i][i];\n                for(int k=0; k<M; k++) {\n                    A[j][k] = A[j][k] - ratio * A[i][k];\n                }\n            }\n        }\n    }\n    return WID;\n}\n\nconst int MAXN = 610;\nint pow2[MAXN + 10];\nsigned main() {\n    pow2[0] = 1;\n    for(int i=1; i<=MAXN; i++) pow2[i] = (pow2[i-1] * 2) % MOD;\n    \n    int N, M; cin >> N >> M;\n    Matrix<int> mat;\n    init_mat(mat, N, M);\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            cin >> mat[i][j];\n        }\n    }\n\n    int rank = mat_rank(mat);\n    int ansA = pow2[N + M - 1];\n    int ansB = pow2[N + (M - rank) - 1];\n    fprintf(stderr, \"matrix rank = %lld\\n\", rank);\n    printf(\"%lld\\n\", (ansA - ansB + MOD) % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int Mx = 300;\nconst int mod = 998244353;\nll p2[Mx + 1];\n\ntypedef bitset<Mx> * It;\n\nbool bsLess(const bitset<Mx> &b1, const bitset<Mx> &b2) {\n\tfor (int i = Mx - 1; i >= 0; --i)\n\t\tif (b1[i] != b2[i])\n\t\t\treturn b1[i] < b2[i];\n\treturn false;\n}\n\nll f(It first, It last, const int pos) {\n\tif (pos < 0 || first == last) {\n\t\tassert(all_of(first, last, [](const bitset<Mx> &x) {\n\t\t\treturn x == 0;\n\t\t}));\n\t\treturn p2[last - first];\n\t}\n\n\tIt pLast = prev(last);\n\tif ((*pLast)[pos] == 0)\n\t\treturn f(first, last, pos - 1);\n\tfor (It it = first; it < pLast; ++it)\n\t\tif ((*it)[pos])\n\t\t\t*it ^= *pLast;\n\treturn f(first, pLast, pos - 1);\n}\n\nbitset<Mx> a[300];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i <= Mx; ++i)\n\t\tp2[i] = (p2[i - 1] * 2) % mod;\n\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\ta[i][j] = x;\n\t\t}\n\n\tsort(a, a + n, bsLess);\n\tll res = f(a, a + n, m - 1);\n\tcerr << res << endl;\n\tres = (p2[n] - res) * p2[m - 1];\n\tcout << (res % mod + mod) % mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 310, P = 998244353;\nint n, m, c, a[maxn][maxn], b[maxn][maxn];\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1) z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = m; j; j--) if (a[i][j]) {\n            if (b[j][j]) {\n                for (int k = 1; k <= m; k++) {\n                    a[i][k] ^= b[j][k];\n                }\n            } else {\n                for (int k = 1; k <= m; k++) {\n                    b[j][k] = a[i][k];\n                }\n                break;\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (a[i][j]) c++;\n        }\n    }\n    int ans = qp(2, n + m) - qp(2, n + m - c) + P;\n    printf(\"%lld\\n\", 1LL * ans * qp(2, P - 2) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tvector<bitset<300>>v(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> K;\n\t\t\tif (K)v[i].flip(j);\n\t\t}\n\t}\n\tvector<int>used(H);\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tif (used[j])continue;\n\t\t\tif (!v[j].test(i))continue;\n\t\t\tused[j] = 1;\n\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\tif (k == j)continue;\n\t\t\t\tif (v[k].test(i)) {\n\t\t\t\t\tv[k] ^= v[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tK = accumulate(used.begin(), used.end(), 0);\n\tcout << (power(2, K, MOD) - 1) * power(2, W - 1, MOD) % MOD*power(2, H - K, MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint main(){\n\tint N,M; cin >> N >> M;\n\tconst LL mod = 998244353;\n\tLL z = 1;\n\trepp(i,0,N){\n\t\tbool b = 0;\n\t\trepp(j,0,M){\n\t\t\tint a; cin >> a;\n\t\t\tb |= a;\n\t\t}\n\t\tif(!b) z = z*2%mod;\n\t}\n\tLL ans = 1;\n\trepp(i,0,N) ans = ans*2%mod;\n\tans = (ans+mod-z)%mod;\n\trepp(i,1,M) ans = ans*2%mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <limits.h>\nusing namespace std;\ntypedef long long LL;\ntypedef bitset<305> BS;\nconst int B=305;\nconst int N=400;\nconst BS one=BS().set(0);\nconst BS zero=BS();\nconst LL M=998244353;\n\nstruct LB {\n\tint sz;\n\tBS b[B];\n\n\tvoid build(BS *a,int n) {\n\t\tsz=0;\n\t\tfor(int i=0;i<B;i++) {\n\t\t\tb[i].reset();\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tBS x=a[i];\n\t\t\tfor(int j=B-1;j>=0;j--) {\n\t\t\t\tif(((x>>j)&one)==one) {\n\t\t\t\t\tif(b[j]!=zero) x^=b[j];\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[j]=x;\n\t\t\t\t\t\tsz++;\n\t\t\t\t\t\tfor(int k=j-1;k>=0;k--) {\n\t\t\t\t\t\t\tif(b[k]!=zero && ((b[j]>>k)&one)==one) b[j]^=b[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=j+1;k<B;k++) {\n\t\t\t\t\t\t\tif(((b[k]>>j)&one)==one) b[k]^=b[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}lb;\n\nint n,m,b;\nBS a[N];\nLL dp[N],P[N],inv_P[N],pw[N];\n\nLL exgcd(LL a,LL b,LL &x,LL &y) {\n\tLL d=a;\n\tif(b!=0) {\n\t\td=exgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}\n\telse {\n\t\tx=1;y=0;\n\t}\n\treturn d;\n}\n\nLL mod_inv(LL a,LL m) {\n\tLL x,y;\n\texgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nvoid init() {\n\tP[0]=1;\n\tinv_P[0]=1;\n\tpw[0]=1;\n\tfor(int i=1;i<N;i++) {\n\t\tP[i]=P[i-1]*i%M;\n\t\tinv_P[i]=mod_inv(P[i],M);\n\t\tpw[i]=pw[i-1]*2%M;\n\t}\n}\n\nLL C(int n,int m) {\n\treturn P[n]*inv_P[m]%M*inv_P[n-m]%M;\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++) {\n\t\ta[i].reset();\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tscanf(\"%d\",&b);\n\t\t\tif(b) a[i].set(j);\n\t\t}\n\t}\n\tlb.build(a,n);\n\n\tdp[0]=1;\n\tfor(int i=0;i<B;i++) {\n\t\tint l=lb.b[i].count();\n\t\tif(l==0) continue;\n\t\tfor(int j=m;j>=0;j--) {\n\t\t\tif(j+l<=m) dp[j+l]+=dp[j],dp[j+l]%=M;\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=m;i++) {\n\t\tfor(int j=1;j<=i;j+=2) {\n\t\t\tans+=C(i,j)*dp[i]%M*pw[m-i]%M;\n\t\t\tans%=M;\n\t\t}\n\t}\n\tans*=pw[n-lb.sz],ans%=M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <vector>\nusing namespace std;\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\n#define COUT(a) cout << (a);\n#define ENDL cout << \"\\n\";\nint map[300][300],data[300][300];\nbool odd_subrectangles(int a,int b,int c,int d){\n    int ans = 0;\n    for(int i=a;i<=c;i++) {\n        for(int j=b;j<=d;j++) {\n            ans+=data[i][j];\n        }\n    }\n    if(ans%2==0) return false;\n    else return true;\n}\n\nint main() {\n    int n,m;\n    long long ans=0;\n    scanf(\"%d %d\\n\",&n,&m);\n    REP(i,n) REP(j,m) scanf(\"%d\",&data[i][j]);\n    REP(i,n) REP(j,m) REP(k,n) REP(o,m) {\n        //i,j始点    k,o終点\n        if(odd_subrectangles(i,j,k,o)) ans++;\n    }\n    COUT(ans)\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint main(){\n    int N, M, A[300][300];\n    cin >> N >> M;\n    for(int i=0; i<N; i++) for(int j=0; j<M; j++) cin >> A[i][j];\n\n    int rank = 0;\n    for(int j=0; j<M; j++){\n        int pivot = -1;\n        for(int i=rank; i<N; i++){\n            if(A[i][j]){\n                pivot = i;\n                break;\n            }\n        }\n        if(pivot >= 0){\n            if(pivot != rank) for(int k=0; k<M; k++) swap(A[pivot][k], A[rank][k]);\n            for(int i=rank+1; i<N; i++){\n                if(A[i][j]) for(int k=0; k<M; k++) A[i][k] ^= A[rank][k];\n            }\n            rank++;\n        }\n    }\n\n    int64_t ans = (MOD + power_mod(2, N+M-1) - power_mod(2, N+M-rank-1)) % MOD;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 302;\nconst int MOD = 998244353;\n\nbitset<N>a[N];\nint32_t main() {\n    //ifstream cin(\"data.in\");\n    int n, m;\n    cin >> n >> m;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n\n\n    // n ecuatii cu m necunoscute, rezultatul e 0\n    for(int i = 0; i < n; ++i) {\n        a[i][m] = 0;\n    }\n    int l = 0, c = 0, var_free = 0;\n    while(l < n && c < m) {\n        int poz = -1;\n        for(int i = l; i < n && poz == -1; i++)\n            if(a[i][c] == 1)\n                poz = i;\n        if(poz == -1) {\n            // n-am putut gasi, e deja 0\n            c++;\n            continue;\n        }\n        swap(a[l], a[poz]);\n        for(int i = l + 1; i < n; ++i)\n            if(a[i][c] == 1)\n                a[i] ^= a[l];\n        l++;\n        c++;\n    }\n\n    for(int i=0;i<n;++i)\n    {\n        bool any=0;\n        for(int j=0;j<m;++j)\n        {\n            if(a[i][j]) any = 1;\n        }\n        if(!any)var_free++;\n    }\n\n\n    vector<long long>p2(n + m + 1);\n    p2[0] = 1;\n    for(int i = 1; i <= n + m; ++i)\n        p2[i] = 2 * p2[i - 1] % MOD;\n    int aux1, aux2;\n\n    aux1 = (p2[n] - 1 + MOD) % MOD, aux2 = p2[m - 1];\n    int answer = (1LL * aux1 * aux2) % MOD;\n\n    aux1 = (p2[var_free] - 1 + MOD) % MOD, aux2 = p2[m - 1];\n    int bad = (1LL * aux1 * aux2) % MOD;\n    answer = (answer - bad + MOD) % MOD;\n\n    cout << answer;\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass F2{\n\tbool x;\npublic:\n\tF2():x(false){}\n\tF2(long long n){ assert(n==0||n==1); x=(n==1); }\n\tF2& operator+=(const F2& a){ x=(x!=a.x); return *this; }\n\tF2& operator-=(const F2& a){ return (*this)+=a; }\n\tF2& operator*=(const F2& a){ x=(x&&a.x); return *this; }\n\tF2& operator/=(const F2& a){ assert(a.x); return *this; }\n\tF2 operator+(const F2& a)const{ return F2(*this)+=a; }\n\tF2 operator-(const F2& a)const{ return F2(*this)-=a; }\n\tF2 operator*(const F2& a)const{ return F2(*this)*=a; }\n\tF2 operator/(const F2& a)const{ return F2(*this)/=a; }\n\tbool operator==(const F2& a)const{ return x==a.x; }\n\tbool operator!=(const F2& a)const{ return !((*this)==a); }\n\tint to_int()const{ return x; }\n};\n\ntemplate<class R>\nclass matrix{\n\tvector<vector<R>> a;\npublic:\n\tmatrix(int n):a(n,vector<R>(n)){}\n\tmatrix(int m,int n):a(m,vector<R>(n)){}\n\n\tmatrix& operator+=(const matrix& A){\n\t\tassert(h()==A.h() && w()==A.w());\n\t\tint m=h(),n=w();\n\t\trep(i,m) rep(j,n) (*this)[i][j]+=A[i][j];\n\t\treturn *this;\n\t}\n\tmatrix& operator-=(const matrix& A){\n\t\tassert(h()==A.h() && w()==A.w());\n\t\tint m=h(),n=w();\n\t\trep(i,m) rep(j,n) (*this)[i][j]-=A[i][j];\n\t\treturn *this;\n\t}\n\tmatrix& operator*=(const matrix& A){\n\t\tassert(w()==A.h());\n\t\tint m=h(),n=w(),l=A.w();\n\t\tmatrix B(m,l);\n\t\trep(i,m) rep(j,l) rep(k,n) B[i][j]+=(*this)[i][k]*A[k][j];\n\t\tswap(*this,B);\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix& A)const{ return matrix(*this)+=A; }\n\tmatrix operator-(const matrix& A)const{ return matrix(*this)-=A; }\n\tmatrix operator*(const matrix& A)const{ return matrix(*this)*=A; }\n\tconst vector<R>& operator[](int i)const{ return a[i]; }\n\tvector<R>& operator[](int i){ return a[i]; }\n\n\tvector<R> operator*(const vector<R>& v)const{\n\t\tassert(w()==v.size());\n\t\tint m=h(),n=w();\n\t\tvector<R> res(m);\n\t\trep(i,m) rep(j,n) res[i]+=(*this)[i][j]*v[j];\n\t\treturn res;\n\t}\n\n\tint h()const{ return a.size(); }\n\tint w()const{ return a.empty()?0:a[0].size(); }\n\n\tstatic matrix identity(int n){\n\t\tmatrix I(n);\n\t\trep(i,n) I[i][i]=R{1};\n\t\treturn I;\n\t}\n};\n\nint matrix_rank(matrix<F2> A){\n\tint m=A.h(),n=A.w(),r=0;\n\trep(j,n){\n\t\tint piv;\n\t\tfor(piv=r;piv<m;piv++) if(A[piv][j]==1) break;\n\t\tif(piv==m) continue;\n\t\tif(piv!=r){\n\t\t\trep(k,n) swap(A[piv][k],A[r][k]);\n\t\t}\n\t\tfor(int i=r+1;i<m;i++) if(A[i][j]==1) {\n\t\t\trep(k,n) A[i][k]-=A[r][k];\n\t\t}\n\t\tr++;\n\t}\n\treturn r;\n}\n\nclass mint{\n\tstatic const int MOD=998244353;\n\tint x;\npublic:\n\tmint():x(0){}\n\tmint(long long y){ x=y%MOD; if(x<0) x+=MOD; }\n\n\tmint& operator+=(const mint& m){ x+=m.x; if(x>=MOD) x-=MOD; return *this; }\n\tmint& operator-=(const mint& m){ x-=m.x; if(x<   0) x+=MOD; return *this; }\n\tmint& operator*=(const mint& m){ x=1LL*x*m.x%MOD; return *this; }\n\tmint& operator/=(const mint& m){ return *this*=inverse(m); }\n\tmint operator+(const mint& m)const{ return mint(*this)+=m; }\n\tmint operator-(const mint& m)const{ return mint(*this)-=m; }\n\tmint operator*(const mint& m)const{ return mint(*this)*=m; }\n\tmint operator/(const mint& m)const{ return mint(*this)/=m; }\n\tmint operator-()const{ return mint(-x); }\n\n\tfriend mint inverse(const mint& m){\n\t\tint a=m.x,b=MOD,u=1,v=0;\n\t\twhile(b>0){ int t=a/b; a-=t*b; swap(a,b); u-=t*v; swap(u,v); }\n\t\treturn u;\n\t}\n\n\tfriend istream& operator>>(istream& is,mint& m){ long long t; is>>t; m=mint(t); return is; }\n\tfriend ostream& operator<<(ostream& os,const mint& m){ return os<<m.x; }\n\tint to_int()const{ return x; }\n};\n\nmint operator+(long long y,const mint& m){ return m+y; }\nmint operator*(long long y,const mint& m){ return m*y; }\n\nmint pow(mint m,long long k){\n\tmint res=1;\n\tfor(;k>0;k>>=1,m*=m) if(k&1) res*=m;\n\treturn res;\n}\n\nint main(){\n\tint m,n; scanf(\"%d%d\",&m,&n);\n\tmatrix<F2> A(m,n);\n\trep(i,m) rep(j,n) { int a; scanf(\"%d\",&a); A[i][j]=a; }\n\n\tcout<<pow(mint(2),m+n-1)-pow(mint(2),m+n-matrix_rank(A)-1)<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int64_t i=0;i < (int64_t)(n);i++)\n\n#define FILE_IN \"post.in\"\n#define FILE_OUT \"post.out\"\n#define ofile freopen(FILE_IN,\"r\",stdin);freopen(FILE_OUT,\"w\",stdout)\n#define fio ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define nfio cin.tie(0);cout.tie(0)\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define ord(a,b,c) ((a>=b)and(b>=c))\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define pow2(x) (ll(1)<<x)\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pii;\ntypedef pair<ll,pii> piii;\n#define endl \"\\n\"\n#define finish(s) {cout<<s;return 0;}\n\n\nll n,m,a[310][310];\nll od[310],ev[310],bit[310],xxj[310];\nint main()\n{\n\tfio;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n \n\tint u=max(n,m);\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%MOD)%MOD;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%MOD)%MOD;\n\t}\n\tll cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tif(xxj[j])\n\t\t\t\t\tfor(int k=j;k<=m;k++)\n\t\t\t\t\t\ta[i][k]^=a[xxj[j]][k];\n\t\t\t\telse {xxj[j]=i;cnt++;break;}\n\t\t\t}\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=u;i++) bit[i]=2ll*bit[i-1]%MOD;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%MOD;\n\tcout<<1ll*od[cnt]*bs%MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nint a[305][305];\n\nvoid GaussianElimination(int mat[305][305], int w, int h)\n{\n\tint r = 0;\n\tfor(int i = 0; i < w && r < h; i++){\n\t\tif(mat[i][r] == 0){\n\t\t\tint max_val = 0, max_j;\n\t\t\tfor(int j = r+1; j < h; j++){\n\t\t\t\tif(mat[j][i] > max_val){\n\t\t\t\t\tmax_val = mat[j][i];\n\t\t\t\t\tmax_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max_val == 0) goto end;\n\t\t\tswap(r, max_j);\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < h; j++){\n\t\t\tif(j == r) continue;\n\t\t\tif(mat[j][i] == 0) continue;\n\t\t\tfor(int k = 0; k <= w; k++){\n\t\t\t\tmat[j][k] ^= mat[r][k];\n\t\t\t}\n\t\t}\n\t\tr++;\n\t\tend:;\n\t}\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\t\n\tGaussianElimination(a, w, h);\n\t\n\tllint rank = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tbool flag = false;\n\t\tfor(int j = 0; j < w; j++) if(a[i][j]) flag = true;\n\t\tif(flag) rank++;\n\t}\n\t\n\tllint tmp = 1, tmp2 = 1;\n\tfor(int i = 0; i < h-rank; i++) tmp *= 2, tmp %= mod;\n\tfor(int i = 0; i < h; i++) tmp2 *= 2, tmp2 %= mod;\n\tllint ans = (tmp2 - tmp + mod) % mod;\n\tfor(int i = 0; i < w-1; i++) ans *= 2, ans %= mod;\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <float.h>\n#include <random>\n\n#define repeat(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\n#define debugArrayP(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge].first<< \" \" << x[hoge].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst long long INF = INT_MAX;\nconst ll MOD = 998244353;\n\nll mod_pow(ll x,int n){\n  return n? (n&1? x*mod_pow(x,n-1)%MOD:mod_pow(x*x%MOD,n/2)):1;\n}\n\nconst int MAX_ROW = 310; // to be set appropriately\nconst int MAX_COL = 310; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;\n\n    // answer\n    res.assign(n, -1);\n    int j=0;\n    for (int i = 0; i < rank; ++i){\n        for(;!M[i][j];j++);\n        res[j] = M[i][n];\n    }\n    return rank;\n}\n\nint main(){\n  int N,M;cin>>N>>M;\n  BitMatrix A(N,M);\n  repeat(i,N){\n    repeat(j,M){\n      int a;cin>>a;\n      A[i][j]=a;\n    }\n  }\n  int rank=GaussJordan(A);\n  cout<<(mod_pow(2,N+M-1)-mod_pow(2,N+M-rank-1)+MOD)%MOD<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, j, k) for (int i = j; i < (int)k; i++)\n#define pb push_back\n#define mt make_tuple\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef complex<ld> point;\ntypedef vector<int> vi;\n\ninline void fileIO(string s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\n\ntemplate <class T, class S>\ninline bool smin(T &a, S b) {\n  return (T)b < a ? a = b, 1 : 0;\n}\ntemplate <class T, class S>\ninline bool smax(T &a, S b) {\n  return a < (T)b ? a = b, 1 : 0;\n}\n\nconstexpr int MOD = 924844033;\nconstexpr int N = 302;\n\ntemplate <typename T>\ninline T mod(T &v) {\n  return v = (v % MOD + MOD) % MOD;\n}\ntemplate <typename S, typename T>\ninline S add(S &l, T r) {\n  return mod(l += r);\n}\nll po(ll v, ll u) {\n  return u ? po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD : 1;\n}\n\nint n , m, id[N];\nvector<bitset<N>> paye;\nbitset<N> tmp;\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifndef LOCAL\n  // fileIO(\"superposition\");\n#endif\n  memset(id , -1, sizeof(id));\n  cin >> n >> m;\n  rep(i , 0 , n) {\n    rep(j , 0 , m) {\n      bool local; cin >> local;\n      tmp[j] = local; \n    }\n    while (tmp.count()) {\n      int pos = tmp._Find_first();\n      if (!~id[pos]) break;\n      tmp ^= paye[id[pos]];\n    }\n    if (tmp.count()) {\n      id[tmp._Find_first()] = paye.size();\n      for (auto &e : paye) e ^= tmp;\n      paye.pb(tmp);\n    }\n  }\n  \n  ll res = po(2 , n) - po(2 , n - paye.size()) + MOD;\n  mod(res *= po(2 , m - 1));\n  cout << res << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set> \n#include<cmath>\n#include <numeric>\n#include <array>\n#include <complex>\nusing namespace std;\nlong long p = 998244353;\n//long long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nvel kai;\nvel inv_kai;\nint rui(int a, int n, int mod) {\n    if (n == 0) { return 1 % mod; }\n    int x = rui(a, n / 2, mod);\n    x *= x; x %= mod;\n    if (n % 2 == 1) { x *= a; x %= mod; }\n    return x;\n}\nint root(int x, vel& pa) {\n    if (pa[x] == -1) { return x; }\n    int ans = root(pa[x], pa); pa[x] = ans;\n    return ans;\n}\nbool mar(int x, int y, vel& pa) {\n    x = root(x, pa);\n    y = root(y, pa);\n    if (x != y) { pa[x] = y; }\n    return (x != y);\n}\nint gcd(int x, int y) {\n    if (x < y) { return gcd(y, x); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\nint lcm(int x, int y) {\n    x = abs(x); y = abs(y);\n    return x * y / gcd(x, y);\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nvoid make_kai(int max_kai) {\n    kai = vel(max_kai, 1);\n    inv_kai = kai;\n    rep(i, max_kai - 1) {\n        kai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n        inv_kai[i + 1] = modinv(kai[i + 1], p);\n    }\n}\nint com(int n, int r) {\n    if ((n < 0) || (r < 0) || (r > n)) { return 0; }\n    int ans = (kai[n] * inv_kai[r]) % p;\n    return (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n    if (x.size() == 0) { return x; }\n    sor(x);\n    int n = x.size();\n    vel ans(1, x[0]);\n    for (int j = 1; j < n; j++) {\n        if (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n    }\n    x = ans;\n    return x;\n}\nvoid pr(vel& v) {\n    int n = v.size();\n    if (n != 0) {\n        cout << v[0];\n        rep(i, n - 1) {\n            cout << \" \" << v[i + 1];\n        }\n        cout << endl;\n    }\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n    int n = way.size();\n    vel dist(n, inf); dist[st] = 0;\n    priority_queue<pin, vector<pin>, greater<pin>> pq;\n    pq.push(mkp(0, st));\n    veb is_checked(n, false);\n    while (!pq.empty()) {\n        pin x = pq.top(); pq.pop();\n        int pot = x.second;\n        if (!is_checked[pot]) {\n            is_checked[pot] = true;\n            for (auto y : way[pot]) {\n                int nex_dist = x.first + y.second;\n                int nex_pot = y.first;\n                if (dist[nex_pot] > nex_dist) {\n                    dist[nex_pot] = nex_dist;\n                    pq.push(mkp(nex_dist, y.first));\n                }\n            }\n        }\n    }\n    return dist;\n}\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\nvel mul(vel& a, vel& b) {\n    int n = a.size();\n    int m = b.size();\n    vel ans(n + m - 1, 0);\n    rep(i, n) {\n        rep(j, m) {\n            ans[i + j] += a[i] * b[j];\n            ans[i + j] %= p;\n        }\n    }\n    return ans;\n}\nvel rui_p(vel& a, int n) {\n    if (n == 0) { return { 1 }; }\n    vel qans = rui_p(a, n / 2);\n    qans = mul(qans, qans);\n    if (n % 2 == 1) {\n        qans = mul(qans, a);\n    }\n    return qans;\n}\nvvel disj_min(vel& v) {\n    int n = v.size();\n    vvel ret(22, vel(n));\n    ret[0] = v;\n    rep(i, 21) {\n        rep(j, n) {\n            int nex = j + (1 << i);\n            if (nex < n) {\n                ret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n            }\n            else {\n                ret[i + 1][j] = ret[i][j];\n            }\n        }\n    }\n    return ret;\n}\nvvel disj_max(vel& v) {\n    int n = v.size();\n    vvel ret(20, vel(n));\n    ret[0] = v;\n    rep(i, 19) {\n        rep(j, n) {\n            int nex = j + (1 << i);\n            if (nex < n) {\n                ret[i + 1][j] = max(ret[i][j], ret[i][nex]);\n            }\n            else {\n                ret[i + 1][j] = ret[i][j];\n            }\n        }\n    }\n    return ret;\n}\nint find_min(vvel& dv, int l, int r) {\n    int i = 19;\n    while (l + (1 << i) > r) {\n        i--;\n    }\n    return min(dv[i][l], dv[i][r - (1 << i)]);\n}\nint find_max(vvel& dv, int l, int r) {\n    int i = 19;\n    while (l + (1 << i) > r) {\n        i--;\n    }\n    return max(dv[i][l], dv[i][r - (1 << i)]);\n}\nbool is_prime(int n) {\n    if (n == 0 || n == 1) { return false; }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) { return false; }\n    }\n    return true;\n}\n#define double long double\n#define pd pair<double,double>\n#define bs bitset<300>\nvoid per(int& ans) {\n    ans %= p;\n    if (ans < 0) { ans += p; }\n}\nint count_zero(V<bs>& a) {\n    int n = a.size();\n    int now_st = 0;\n    rep(i, 300) {\n        int fir_ze = -1;\n        for (int j = now_st; j < n; j++) {\n            if (a[j][i]) { fir_ze = j; break; }\n        }\n        if (fir_ze >= 0) {\n            rep(j, n) {\n                if (j != fir_ze&&a[j][i]) {\n                    a[j] = a[fir_ze] xor a[i];\n                }\n            }\n            swap(a[now_st], a[fir_ze]);\n            now_st++;\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        bool fl = true;\n        rep(j, 300) {\n            if (a[i][j]) { fl = false; break; }\n        }\n        if (fl) { ans++; }\n    }\n    return ans;\n}\nsigned main() {\n    int n, m; cin >> n >> m;\n    V<bs> a(n);\n    rep(i, n) {\n        rep(j, m) {\n            int x; cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int cz = count_zero(a);\n    int ans = rui(2, n,p) - rui(2, cz,p); per(ans);\n    ans*=rui(2, m - 1, p); per(ans);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 40005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 998244353;\nint N,M;\nint a[305][305];\nint b[305][305],cnt;\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n\tx = inc(x,y);\n}\nint fpow(int x,int c) {\n\tint res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = mul(res,t);\n\t\tt = mul(t,t);\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nvoid Solve() {\n\tread(N);read(M);\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tfor(int j = 1 ; j <= M ; ++j) {\n\t\t\tread(a[i][j]);\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tfor(int j = 1 ; j <= M ; ++j) {\n\t\t\tif(a[i][j]) {\n\t\t\t\tif(!b[j][j]) {\n\t\t\t\t\tfor(int k = 1 ; k <= M ; ++k) b[j][k] = a[i][k];\n\t\t\t\t\t++cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int k = 1 ; k <= M ; ++k) a[i][k] ^= b[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = inc(fpow(2,N),MOD - fpow(2,N - cnt));\n\tans = mul(ans,fpow(2,M - 1));\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing ll = long long;\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t dim = 0, pos = 0;\n    for (std::size_t i = 0, piv = mat.C; i < mat.C and pos < mat.R; i++, pos++, piv = mat.C) {\n        if (mat[pos][i] == 0) {\n            for (std::size_t k = pos + 1; k < mat.R; k++) {\n                if (mat[k][i] != 0) {\n                    piv = k;\n                    break;\n                }\n            }\n            if (piv != mat.C) {\n                std::swap(mat[pos], mat[piv]);\n            } else {\n                pos--;\n                continue;\n            }\n        }\n        for (std::size_t j = 0; j < mat.R; j++) {\n            if (pos == j) { continue; }\n            if (mat[j][i]) {\n                const T p = mat[j][i] / mat[pos][i];\n                for (std::size_t k = 0; k < mat.C; k++) { mat[j][k] -= mat[pos][k] * p; }\n            }\n        }\n        dim++;\n    }\n    return dim;\n}\nconstexpr ll MOD = 998244353;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<int> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<ll> bp(601, 1LL);\n    for (std::size_t i = 1; i <= 600; i++) { bp[i] = bp[i - 1] * 2 % MOD; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD) % MOD << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353; //1000000007;\n\nll mod_pow(ll a,ll x){\n    ll ret=1;\n    while(x>0){\n        if(x&1){(ret*=a)%=MOD;}\n        (a*=a)%=MOD;\n        x>>=1;\n    }\n    return ret;\n}\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    vector<vector<ll>> A(n,vector<ll>(m));\n    for(auto &I:A){for(auto &T:I){cin>>T;}}\n    ll cnt=m;\n    ll w=0;\n    for(int i=0;i<n && w<m;i++,w++){\n        for(int h=i+1;h<n;h++){\n            if(A[i][w]==0 && A[h][w]==1){swap(A[i],A[h]);}\n        }\n        if(A[i][w]==0){cnt--; i--; continue;}\n        for(int h=i+1;h<n;h++){\n            if(A[h][w]){\n                for(int w=0;w<m;w++){\n                    A[h][w]^=A[i][w];\n                }\n            }\n        }\n        if(i+1==n){cnt-=m-w-1;}\n    }\n    ll ans=mod_pow(2,n+m-1)-mod_pow(2,n+m-cnt-1);\n    ans%=MOD;\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//行・列基本変形しても答えが変わらないというギャグ。\n//ランクrとすると、本質は(1, 1)をi箇所、{(0,0),(0,1),(1,0)}をr-i箇所作る問題。これは算数。\n#include <iostream>\n#include <vector>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef vector<int> Array;\ntypedef vector<Array> Mat;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn a * powmod(a, n - 1, mod) % mod;\n}\n\nint mod = 998244353;\nint fact[301];\nint finv[301];\n\nint comb(int n, int k) {\n\treturn fact[n] * finv[k] % mod * finv[n - k] % mod;\n}\n\nvoid henkei(Mat &a) {\n\tint h = a.size();\n\tint w = a[0].size();\n\t\n\tint i, j, k;\n\tint cor = 0;\n\t\n\trep(i, w) {\n\t\tfor (j = cor; j < h; j++) {\n\t\t\tif (a[j][i] == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == h) continue;\n\t\t\n\t\tint pos = j;\n\t\trep(j, w) {\n\t\t\tswap(a[cor][j], a[pos][j]);\n\t\t}\n\t\t\n\t\tfor (j = cor + 1; j < h; j++) {\n\t\t\tif (a[j][i] == 0) continue;\n\t\t\trep(k, w) {\n\t\t\t\ta[j][k] ^= a[cor][k];\n\t\t\t}\n\t\t}\n\t\tcor++;\n\t}\n}\n\nvoid tenti(Mat &a) {\n\tint h = a.size();\n\tint w = a[0].size();\n\tMat b(w, Array(h));\n\t\n\tint i, j;\n\trep(i, h) rep(j, w) b[j][i] = a[i][j];\n\ta = b;\n}\n\nint _rank(Mat &a) {\n\tint i;\n\trep(i, a.size()) {\n\t\tif (i >= a[0].size() || a[i][i] == 0) break;\n\t}\n\treturn i;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tfact[0] = finv[0] = 1;\n\tfor (i = 1; i <= 300; i++) {\n\t\tfact[i] = i * fact[i - 1] % mod;\n\t\tfinv[i] = powmod(fact[i], mod - 2, mod);\n\t}\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tMat a(n, Array(m));\n\trep(i, n) rep(j, m) cin >> a[i][j];\n\thenkei(a);\n\ttenti(a);\n\thenkei(a);\n\tint r = _rank(a);\n\tint ans = 0;\n\tfor (int i = 1; i <= r; i += 2) {\n\t\tans += comb(r, i) * powmod(3, r - i, mod) % mod;\n\t\tans %= mod;\n\t}\n\tans *= powmod(2, n + m - 2 * r, mod);\n\tans %= mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define pb push_back\n \nconst int maxn = 3e2 + 20;\nconst int mod = 998244353;\n\nbitset<maxn> a[maxn];\n\nint ind[maxn];\n\nint bpw(int a , int b)\n{\n\tif(!b)\n\t\treturn 1;\n\tint x = bpw(a , b / 2);\n\n\tx = 1LL * x * x % mod;\n\tif(b&1)\n\t\tx = 1LL * x * a % mod;\n\n\treturn x;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n , m;\n\tcin >> n >> m;\n\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\ta[i][j] = x;\n\t\t}\n\n\tmemset(ind , -1 , sizeof ind);\n\n\tint res = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = m - 1; j >= 0; j--)\n\t\t\tif(a[i][j] && ind[j] != -1)\n\t\t\t\ta[i] ^= a[ind[j]];\n\n\t\tint last = -1;\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tif(a[i][j])\n\t\t\t\tlast = j;\n\n\t\tif(last == -1)\n\t\t\tcontinue;\n\n\t\tfor(int j = m - 1; j >= 0; j--)\n\t\t\tif(ind[j] != -1 && a[ind[j]][last])\n\t\t\t\ta[ind[j]] ^= a[i];\n\n\t\tind[last] = i;\n\t\tres++;\n\t}\n\n\tres = (1LL * bpw(2 , n - res) * (bpw(2 , res) - 1 + mod)) % mod;\n\tres = 1LL * res * bpw(2 , m - 1) % mod;\n\n\tcout << res << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define rollcall cout << \"I'm Sucu.\" << endl;\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define fi first\n#define se second\n// debug\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p){\n  os << \"(\" << p.first << \",\" << p.second << \")\";return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v){\n  for (auto it = v.begin();it != v.end();++it){\n    if(it != v.begin())os << \" \";os << *it;\n      }return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp){\n  for(auto x: mp)os << \"(\" << x.first << \",\" << x.second << \")\" << endl;\n  return os;\n}\ntemplate<typename T, int SIZE>\nint array_length(const T (&)[SIZE]){return SIZE;}\ntemplate<typename T, int N>\nvoid PRINTF(const T (&a)[N], int s = N, int t = -1, bool f = true){\n\tif(t == -1){rep(i,s){if(i)cout << \" \";cout << a[i];}}\n\telse repi(i,s,t){if(i!=s)cout << \" \";cout << a[i];}\n\tif(f)cout << \"\\n\";\n}\ntemplate<typename T, int N1, int N2>\nvoid PRINTF(const T (&a)[N1][N2], int h = N1, int w = N2){\n\trep(i,h){rep(j,w){cout << a[i][j] << \" \\n\"[j==w-1];}}\n}\nstring substr(const string &str, int S1, int S2 = -1){\n  if(S2 == -1)return str.substr(S1);\n  return str.substr(S1, S2-S1);\n}\n// typedef\ntypedef complex<double> Point;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nconst int mod = 998244353;\n\nvector<int> mat[400];\nvoid XOR(vi &A, vi &B){\n  int n = A.size();\n  rep(i,n)A[i] ^= B[i];\n}\n\nint Pow(int x, int n){\n  if(n < 0)n += mod-1;\n  int ans = 1;\n  while(n > 0){\n    if(n & 1)ans = (ans*x)%mod;\n    x = (x*x)%mod;\n    n >>= 1;\n  }\n  return ans;\n}\n\nint calc_rank(int h, int w){\n  int r = 0;\n  rep(j,w){\n    int pivot = -1;\n    rep(i,h)if(mat[i][j]){\n      pivot = i;break;\n    }\n    if(pivot == -1)continue;\n    swap(mat[pivot], mat[r]);\n    rep(i,h)if(i != r){\n      if(mat[i][j])XOR(mat[i], mat[r]);\n    }\n    r++;\n  }\n  return r;\n}\n\nsigned main(){\n  int h, w;\n  scanf(\"%lld%lld\", &h, &w);\n  rep(i,h)rep(j,w){\n    int tmp;scanf(\"%lld\", &tmp);\n    mat[i].pb(tmp);\n  }\n  int r = calc_rank(h, w);\n  int ans = Pow(2, h)-Pow(2, h-r);\n  ans = (ans%mod)*Pow(2, w-1);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)if(a[j][now])for(int k = now; k < m; ++k)a[j][k] ^= a[i][k];\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint main(){\n    int N, M, A[300][300];\n    cin >> N >> M;\n    for(int i=0; i<N; i++) for(int j=0; j<M; j++) cin >> A[i][j];\n\n    int rank = 0;\n    for(int j=0; j<M; j++){\n        int pivot = -1;\n        for(int i=rank; i<N; i++){\n            if(A[i][j]){\n                pivot = i;\n                break;\n            }\n        }\n        if(pivot >= 0){\n            if(pivot != rank) for(int k=0; k<M; k++) swap(A[pivot][k], A[rank][k]);\n            for(int i=rank+1; i<N; i++){\n                if(A[i][j]) for(int k=0; k<M; k++) A[i][k] ^ A[rank][k];\n            }\n            rank++;\n        }\n    }\n\n    int64_t ans = (MOD + power_mod(2, N+M-1) - power_mod(2, N+M-rank-1)) % MOD;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define FL \"a\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double dd;\nconst int N=305;\nconst int inf=2147483647;\nconst dd pi=acos(-1);\nconst ll INF=1ll<<60;\nconst int mod=998244353;\ninline ll read(){\n  ll data=0,w=1;char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n  if(ch=='-')w=-1,ch=getchar();\n  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n  return data*w;\n}\ninline void file(){\n  freopen(FL\".in\",\"r\",stdin);\n  freopen(FL\".out\",\"w\",stdout);\n}\n\nint n,m,a[N][N],now[N],in[N],p[N][N],r;\ninline int poww(int a,int b){\n  int res=1;\n  for(;b;b>>=1,a=1ll*a*a%mod)\n    if(b&1)res=1ll*res*a%mod;\n  return res;\n}\n\nint main()\n{\n  n=read();m=read();\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=m;j++)a[i][j]=read();\n  for(int i=1;i<=n;i++){\n    memcpy(now,a[i],sizeof(now));\n    for(int j=1;j<=m;j++)\n      if(now[j]){\n\tif(in[j])for(int k=j;k<=m;k++)now[k]^=p[j][k];\n\telse{in[j]=1;memcpy(p[j],now,sizeof(p[j]));r++;break;}\n      }\n  }\n  printf(\"%lld\\n\",1ll*(poww(2,n)-poww(2,n-r)+mod)%mod*poww(2,m-1)%mod);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<unsigned char, unsigned char> pcc;\ntypedef pair<double, double> pdd;\ntypedef bitset<305> bs;\n\nconst int MOD = 998244353;\n\nbs matrix[305];\n\nll modpow(ll b, ll e, ll m) {\n  ll r = 1;\n  while(e) {\n    if(e%2) {\n      r*=b;\n      r%=m;\n    }\n    b*=b;\n    b%=m;\n    e/=2;\n  }\n  return r;\n}\n\nvoid solve() {\n  int r, c;\n  cin >> r >> c;\n  for(int i = 0; i < r; i++) {\n    for(int j = 0; j < c; j++) {\n      int t;\n      cin >> t;\n      if(t) matrix[i].set(j);\n    }\n  }\n  int rank = 0;\n  for(int j = 0; j < c; j++) {\n    bool found = false;\n    for(int i = rank; i < r; i++) {\n      if(matrix[i][j]) {\n        found = true;\n        if(i != rank) swap(matrix[i], matrix[rank]);\n      }\n    }\n    if(found) {\n      for(int i = rank+1; i < r; i++) {\n        if(matrix[i][j]) matrix[i] ^= matrix[rank];\n      }\n      rank++;\n    }\n  }\n  ll ret = modpow(2, r+c-1, MOD);\n  ret -= modpow(2, r+c-1-rank, MOD);\n  ret += MOD;\n  cout << ret%MOD << \"\\n\";\n}\n\nvoid casesolve() {\n  int t;\n  cin >> t;\n  for(int i = 1; i <= t; i++) {\n    cout << \"Case #\" << i << \":\" << \"\\n\";\n    solve();\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); cout.tie(NULL);\n  solve();\n  // casesolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\t//ans= (2^(n+m) - 2^(n+m-rank))/2\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h,i,j,n,m;cin>>n>>m;\n\tvector<vector<int>>mat(n,vector<int>(m));\n\tint x=0;//rank\n\tvector<int>kara(m);\n\tfor(h=0;h<n;h++){\n\t\tfor(j=0;j<m;j++){cin>>mat[x][j];}\n\t\tfor(i=0;i<x;i++){\n\t\t\tif(mat[i]<=mat[x]){//辞書順で楽\n\t\t\t\tfor(j=0;j<m;j++){mat[x][j]^=mat[i][j];}\n\t\t\t}\n\t\t}\n\t\tif(mat[x]==kara){continue;}\n\t\t\n\t\tint bas=x;\n\t\twhile(bas>0&&mat[bas]>mat[bas-1]){swap(mat[bas],mat[bas-1]);bas--;}\n\t\tx++;\n\t\t/*cerr<<\"de\"<<endl;\n\t\tfor(i=0;i<x;i++){\n\t\t\tfor(j=0;j<m;j++){\n\t\t\t\tcerr<<mat[i][j];\n\t\t\t}cerr<<endl;\n\t\t}*/\n\t}\n\tllint ans=1;\n\tfor(i=0;i<x;i++){ans*=2;ans%=mod;}\n\tans--;\n\tfor(i=1;i<n+m-x;i++){ans*=2;ans%=mod;}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0); \n\tlong long pow[610] = {}; \n\tlong long mod = 998244353; \n\tpow[0] = 1; \n\tfor(int i = 1; i < 605; i++) pow[i] = pow[i-1] * 2 % mod; \n\tint N, M; cin >> N >> M; \n\tbool A[310][310] = {}; \n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < M; j++){\n\t\t\tcin >> A[i][j]; \n\t\t}\n\t}\n\tint p = -1; \n\tfor(int j = 0; j < M; j++){\n\t\tfor(int i = p + 1; i < N; i++){\n\t\t\tif(A[i][j]){\n\t\t\t\tswap(A[i], A[p + 1]); \n\t\t\t\tp++; \n\t\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\t\tif(k == p) continue; \n\t\t\t\t\tif(A[k][j]){\n\t\t\t\t\t\tfor(int l = 0; l < M; l++) A[k][l] ^= A[p][l]; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tp++; \n\tcout << (pow[p] + mod - 1) * pow[N + M - p - 1] % mod << \"\\n\"; \n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\nusing BS=bitset<333>;\n\nBS a[333];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,m;\n\tcin>>n>>m;\n\trep(i,n){\n\t\ta[i].reset();\n\t\trep(j,m){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x) a[i][j]=1;\n\t\t}\n\t}\n\tint o=0;\n\trep(j,m){\n\t\tint tmp=-1;\n\t\treps(i,o,n)if(a[i][j]){\n\t\t\ttmp=i; break;\n\t\t}\n\t\tif(tmp<0) continue;\n\t\tif(o!=tmp) swap(a[o],a[tmp]);\n\t\trep(i,n)if(i!=o && a[i][j]) a[i]^=a[o];\n\t\t++o;\n\t}\n\t// rep(i,n){rep(j,m) cout<<a[i][j];cout<<endl;}\n\tmint ker=1;\n\tint t=0;\n\trep(i,n)if(a[i].count()==0) ker+=ker, ++t;\n\tassert(t+o==n);\n\tout(ker,1);\n\tmint re=modpow(mint(2),m-1);\n\tcout<<re*(modpow(mint(2),n)-modpow(mint(2),t))<<endl;\n\t// cout<<(1ll<<4)*((1ll<<5)-1)%MOD<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln = '\\n';\n//constexpr long long MOD = 1000000007;\nconstexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nconst int COL = 400;\ntemplate<int MAX_COL>\nstruct BitMatrix {\n    int N,M;\n    vector<bitset<MAX_COL>> A;\n    BitMatrix(int N, int M) : N(N),A(N),M(M) {}\n\n    int GaussJordan() {\n        int rank = 0;\n        for (int col = 0; col < M; ++col) {\n            int pivot = -1;\n            for (int row = rank; row < N; ++row) {\n                if (A[row][col]) {\n                    pivot = row;\n                    break;\n                }\n            }\n            if (pivot == -1) continue;\n            swap(A[pivot], A[rank]);\n            for (int row = 0; row < N; ++row) {\n                if (row != rank && A[row][col]) A[row] ^= A[rank];\n            }\n            ++rank;\n        }\n        return rank;\n    }\n};\n\nusing BM = BitMatrix<COL>;\n\ntemplate <uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept {return a;}\n    constexpr const u64 &value() const noexcept {return a;}\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr bool operator==(const ModInt &rhs) const noexcept {return a == rhs.a;}\n    constexpr bool operator!=(const ModInt &rhs) const noexcept {return a != rhs.a;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt rhs = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n\n    friend ostream &operator<<(ostream& os, const ModInt& rhs) noexcept {return os << rhs.a;}\n    friend istream &operator>>(istream& is, ModInt& rhs) noexcept {long long a; is >> a; rhs = a; return is;}\n};\n\nusing mint = ModInt<MOD>;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,M; cin >> N >> M;\n    vector<vector<int>> A(N, vector<int>(M));\n    rep(i,N) rep(j,M) cin >> A[i][j];\n\n    BM mat(N,M+1);\n    rep(i,N) rep(j,M) mat.A[i][j] = A[i][j];\n    int k = mat.GaussJordan();\n    mint ans = 1;\n    rep(i,N) ans *= 2;\n    mint val = 1;\n    rep(i,N-k) val *= 2;\n    ans -= val;\n    rep(i,M-1) ans *= 2;\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n        mat<COL_SIZE> b(r);\n        for(int i = 0; i < r; i++) b[i] = a[i];\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n        return a[index];\n    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<300>a(m);\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = a.rank();\n//    cerr << r << endl;\n    cout << (mod_pow(2,n+m-1) -mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n2 2\n0 1\n1 0\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=305;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=998244353LL;\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nbitset<maxn> b[maxn];\n\nbitset<maxn> head[maxn];\nbool vis[maxn];\nint main()\n{\n\tIOS;\n\tint n,m;\n\tcin>>n>>m;\n\tREP(i,n) REP(j,m){\n\t\tbool tmp;\n\t\tcin>>tmp;\n\t\tb[i][j]=tmp;\n\t}\n\n\tint cnt=0;\n\tREP(i,n){\n\t\tbool flag=0;\n\t\tfor(int j=m-1;j>=0;j--) if(b[i][j]){\n\t\t\tif(vis[j]){\n\t\t\t\tb[i]^=head[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvis[j]=1;\n\t\t\t\thead[j]=b[i];\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) cnt++;\n\t}\n\n\tcout<<(mypow(2,n)-mypow(2,cnt)+MOD)*(mypow(2,m-1))%MOD<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing ll = long long;\nusing i_i = tuple<int, int>;\n\nconst int MOD = 998244353;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> a(N, vector<int>(M));\n    rep(i, N) rep(j, M) scanf(\"%d\", &a[i][j]);\n    int k = 0;\n    rep(j, M) {\n        int i0;\n        for (i0 = k; i0 < N && !a[i0][j]; i0++);\n        if (i0 == N) continue;\n        swap(a[k], a[i0]);\n        for (int i = k + 1; i < N; i++)\n            if (a[i][j])\n                rep(j, M)\n                    a[i][j] ^= a[k][j];\n        k++;\n    }\n    int rank = k;\n    vector<ll> pow2(N + M + 1);\n    pow2[0] = 1;\n    rep(x, N + M) pow2[x + 1] = pow2[x] * 2 % MOD;\n    ll ans = (pow2[N] - pow2[N - rank]) * pow2[M - 1] % MOD;\n    cout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int mod = 998244353;\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> a(n, vector<int>(m));\n  for (auto &ai : a) {\n    for (auto &aij : ai) {\n      cin >> aij;\n    }\n  }\n  ll dp[n][m][2][2][2];\n  fill(dp[0][0][0][0], dp[n][0][0][0], 0);\n  dp[0][0][0][0][0] = dp[0][0][0][1][0] = dp[0][0][0][0][1] = dp[0][0][a[0][0]][1][1] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      for (int o = 0; o < 2; o++) {\n        for (int r = 0; r < 2; r++) {\n          for (int c = 0; c < 2; c++) {\n            int o2 = r && c ? (o ^ a[i][j]) : o;\n            if (i) {\n              dp[i][j][o2][r][c] += dp[i - 1][j][o][0][c];\n              dp[i][j][o2][r][c] += dp[i - 1][j][o][1][c];\n            }\n            if (j) {\n              dp[i][j][o2][r][c] += dp[i][j - 1][o][r][0];\n              dp[i][j][o2][r][c] += dp[i][j - 1][o][r][1];\n            }\n            if (i && j) {\n              dp[i][j][o2][r][c] -= dp[i - 1][j - 1][o][0][0];\n              dp[i][j][o2][r][c] -= dp[i - 1][j - 1][o][1][0];\n              dp[i][j][o2][r][c] -= dp[i - 1][j - 1][o][0][1];\n              dp[i][j][o2][r][c] -= dp[i - 1][j - 1][o][1][1];\n            }\n          }\n        }\n      }\n    }\n  }\n  ll t = 0;\n  for (int r = 0; r < 2; r++) {\n    for (int c = 0; c < 2; c++) {\n      t += dp[n - 1][m - 1][1][r][c];\n    }\n  }\n  cout << t << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,k,n) for(int i=k;i<=n;i++)\n#define rep2(i,k,n) for(int i=k;i>=n;i--)\n#define mod 998244353\nusing namespace std;\ninline void upd(int& x,int y){\n\tx+=y;\n\tx-= (x>=mod) ? mod : 0;\n}\nconst int N=305;\nint pw[N<<1],f[N],a[N][N],n,m;\nint main(){\n\tpw[0]=1;rep(i,1,600)pw[i]=pw[i-1],upd(pw[i],pw[i-1]);\n\trep(i,1,N-1)f[i]=pw[(i-1)<<1],upd(f[i],f[i-1]),upd(f[i],f[i-1]);\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n)rep(j,1,m)scanf(\"%d\",&a[i][j]);\n\tint r=0;\n\trep(i,1,m){\n\t\tint t=0;\n\t\trep(j,i,n)if(a[j][i]){t=j;break;}\n\t\tif(!t)continue;\n\t\tr++;\n\t\trep(j,1,m)swap(a[i][j],a[t][j]);\n\t\trep(j,i+1,n)if(a[j][i]){\n\t\t\trep(k,i,m)a[j][k]^=a[i][k];\n\t\t}\n\t}\n\tint ans=1ll*f[r]*pw[n-r]%mod*pw[m-r]%mod;\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\n#define BIT_N 333\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef bitset<BIT_N> Bit;\nvector<int> baseNum;\n\nll pow_two[2 * BIT_N];\n\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n \n#define MAX_K 333333\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nvector<Bit> gauss(vector<Bit> &v, ll &ran){\n\tran = 0;\n\tREP(i,BIT_N) {\n\t\tint pla = -1;\n\t\tfor(int j = ran;j < v.size();j++){\n\t\t\tif(v[j][i] == 1){\n\t\t\t\tpla = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pla != -1){\n\t\t\tswap(v[ran], v[pla]);\n\t\t\tfor(int j = 0;j < v.size();j++){\n\t\t\t\tif(j != ran && v[j][i] == 1)v[j] ^= v[ran];\n\t\t\t}\n\t\t\tran++;\n\t\t}\n\t}\n\treturn v;\n}\n\nint main(){\n\t\n\tpow_two[0] = 1;\n\tREP(i,BIT_N - 1)pow_two[i+1] = pow_two[i] * 2 % MOD;\n\t\n\tvector<Bit> v;\n\tll n, m;cin >> n >> m;\n\tREP(i,n){\n\t\tBit now;\n\t\tREP(j,m){\n\t\t\tint a;cin >> a;\n\t\t\tif(a)now[j] = 1;\n\t\t}\n\t\tv.PB(now);\n\t}\n\t\n\tll ran = 0;\n\tll ans = 0;\n\tgauss(v, ran);\n\t\n\tcout << ((pow_two[n] - pow_two[n - ran] + MOD) % MOD) * pow_two[m-1] % MOD << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 998244353;\n\nint64 power_mod(int64 a, int n) {\n  int64 ret = 1;\n  for (; n; n >>= 1) {\n    if (n & 1) ret = ret * a % MOD;\n    a = a * a % MOD;\n  }\n  return ret;\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  int cnt = 0;\n  for (int i = 0; i < n; ++i) {\n    int sum = 0, x;\n    for (int j = 0; j < m; ++j) {\n      scanf(\"%d\", &x);\n      sum += x;\n    }\n    if (sum == 0) ++cnt;\n  }\n  int ret = (power_mod(2, n) + MOD - power_mod(2, cnt)) *\n    power_mod(2, m - 1) % MOD;\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=310;\nconst int mod=998244353;\nbitset<MAXN>a[MAXN],b[MAXN];\nint n,m,x,ans;\nlong long poww(long long x,long long y)\n{\n\tlong long ans=1;\n\tfor (;y;y>>=1,x=(x*x)%mod) if (y&1) ans=(ans*x)%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\tfor (int j=1;j<=m;j++) \n\t{\n\t\tscanf(\"%d\",&x);\n\t\tif (x==1) a[i].set(j-1);\n\t}\n\t}\n    for (int i=1;i<=n;i++)\n    {\n    \tfor (int j=1;j<=m;j++) \n    \t\tif (!a[i][j]) continue;\n    \telse\n    \t\tif (!b[j].any()) {\n    \t\t\tb[j]=a[i]; break;\n    \t\t}\n    \t\telse a[i]^=b[j];\n    }\n    for (int i=1;i<=max(n,m);i++) if (b[i].any()) ans++;\n    cout << (poww(2,n)-poww(2,n-ans)+mod)%mod*poww(2,m-1)%mod << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int MN = 305, P = 99824353;\n\ntypedef std::bitset<MN> bst;\n\nbst val[MN], vec[MN];\n\nint n, m, k;\n\ninline int fpw(int x, int k) {\n\tint res = 1;\n\tfor (; k; k >>= 1, x = (ll) x * x % P)\n\t\tif (k & 1) res = (ll) res * x % P;\n\treturn res;\n}\n\ninline int read() {\n\tint x; bool f; char c;\n\tfor (f = 0; (c = getchar()) < '0' || c > '9'; f = c == '-');\n\tfor (x = c ^ '0'; (c = getchar()) >= '0' && c <= '9'; x = (x << 1) + (x << 3) + (c ^ '0'));\n\treturn f ? -x : x;\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tval[i][j] = read();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = m; j--; )\n\t\t\tif (val[i][j]) {\n\t\t\t\tvec[j] ^= val[i];\n\t\t\t\tif (vec[j] == val[i]) {\n\t\t\t\t\tfor (int k = j; ++k < m; )\n\t\t\t\t\t\tif (vec[k][j]) vec[j] ^= vec[k];\n\t\t\t\t\tfor (int k = j; k--; )\n\t\t\t\t\t\tif (vec[k][j]) vec[k] ^= vec[j];\n\t\t\t\t\t++k;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\tprintf(\"%lld\\n\", (ll)fpw(2, m - 1) * (fpw(2, n) - fpw(2, n - k) + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\ntemplate <int COL_SIZE> class mat {\nprivate:\n    // (or, and) の意味での積(正方かつ対称行列に限る(重みなし無向グラフの隣接行列とか))\n    mat operator*(const mat& m) const {\n        mat ans;\n        for(int i = 0; i < COL_SIZE; i++){\n            for(int j = 0; j < COL_SIZE; j++){\n                if(this->a[i][j] == 0) continue;\n                ans.a[i] |= m.a[j];\n            }\n        }\n        return ans;\n    }\n    \npublic:\n    bitset<COL_SIZE>* a;\n    int r;\n    // 正方行列の場合\n    mat(){ a = new bitset<COL_SIZE>[COL_SIZE]; }\n    // 一般の行列の場合\n    mat(int row_size) : r(row_size){ a = new bitset<COL_SIZE>[r]; }\n    int rank() const {\n        int res = 0;\n        mat<COL_SIZE> b(r);\n        for(int i = 0; i < r; i++) b[i] = a[i];\n//        auto b = a;\n        for(int i = 0; i < COL_SIZE; i++){\n            if(res == r) return res;\n            int pivot = res;\n            if(!b[pivot][i]){\n                for(int j = res + 1; j < r; j++){\n                    if(b[j][i]){\n                        pivot = j;\n                        break;\n                    }\n                }\n                if(!b[pivot][i]) continue;\n                swap(b[pivot], b[res]);\n            }\n            for(int j = res + 1; j < r; j++){\n                if(b[j][i]) b[j] ^= b[res];\n            }\n            res++;\n        }\n        return res;\n    }\n    inline const bitset<COL_SIZE>& operator[](size_t index) const {\n        return a[index];\n    }\n    inline bitset<COL_SIZE>& operator[](size_t index){\n        return a[index];\n    }\n    friend mat pow(mat m, long long cnt){\n        mat res;\n        for(int i = 0; i < COL_SIZE; i++) res[i][i] = 1;\n        while(cnt){\n            if(cnt & 1){\n                res = res * m;\n            }\n            m = m * m;\n            cnt >>= 1;\n        }\n        return res;\n    }\n};\nll mod = 998244353;\nll mod_pow(ll a, ll b){\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res = mod_pow(a,b/2);\n    res = res * res % mod;\n    if(b%2)res = res * a % mod;\n    return res;\n}\nint main(){\n    int n,m;\n    cin >> n >> m;\n    mat<305>a;\n    rep(i,n){\n        rep(j,m){\n            int x;\n            cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int r = a.rank();\n    cerr << r << endl;\n    cout << (mod_pow(2,n+m-1) - mod_pow(2,n+m-r-1) + mod ) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MOD = 998244353;\nconst Int MAX = 1000;\nInt fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nInt COM(Int n, Int k) {\n    if (n < k || n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nInt POW(Int n, Int m) {\n    if (m == 0) return 1;\n    if (m % 2 == 0) return POW(n * n % MOD, m / 2);\n    return n * POW(n, m - 1) % MOD;\n}\nint gaussian_elimination(vector<vector<int>> &A) {\n    int N = A.size(), M = A[0].size();\n    int t = 0;\n    for (int i = 0; i < N; i++) {\n        for (; t < M; t++) {\n            for (int j = i; j < N; j++) {\n                if (A[j][t]) {\n                    swap(A[i], A[j]);\n                    break;\n                }\n            }\n            if (A[i][t]) break;\n        }\n        if (t >= M) return i;\n        for (int j = i + 1; j < N; j++) {\n            if (j != i && A[j][t]) {\n                for (int k = 0; k < M; k++) A[j][k] ^= A[i][k];\n            }\n        }\n        t++;\n    }\n    return N;\n}\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    COMinit();\n    int N, M; cin >> N >> M;\n    vector<vector<int>> A(N, vector<int>(M));\n    for (auto &row : A) for (auto &a : row) cin >> a;\n    int rank = gaussian_elimination(A);\n    Int ans = 0;\n    for (int i = 1; i <= rank; i++) {\n        for (int j = 1; j <= i; j += 2) {\n            ans = ans + COM(rank, i) * COM(i, j) % MOD * POW(2, M - i) % MOD;\n        }\n    }\n    ans %= MOD;\n    ans = ans * POW(2, N - rank) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define MOD 998244353\n\nconst int N = 300;\nint n, m;\nint A[N + 7][N + 7];\n\nll power(ll a, int k){\n\tll ans = 1;\n\twhile(k > 0){\n\t\tif(k&1)\n\t\t\tans = ans * a % MOD;\n\t\ta = a * a % MOD;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t\tcin >> A[i][j];\n\n\tint myi = 0;\n\tfor(int j = 0; j < m && myi < n; j++){\n\t\tfor(int i = myi; i < n; i++)\n\t\t\tif(A[i][j]){\n\t\t\t\tswap(A[i], A[myi]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(!A[myi][j])\n\t\t\tcontinue;\n\t\tfor(int i = myi; i < n; i++)\n\t\t\tfor(int jj = j; jj < m; jj++)\n\t\t\t\tA[i][jj] = A[i][jj] ^ (A[myi][jj] * A[i][j]);\n\t\tmyi++; \n\t}\n\n\tll ans = power(2, n + m - 1);\n\tll ans2 = power(2, n + m - 1 - myi);\n\tans -= ans2;\n\tif(ans < 0)\n\t\tans += MOD;\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nconst int _=305,yl=998244353;\nint g[_],cnt,n,m;\nbitset<_>a[_],f[_];\nll POW(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)res=res*x%yl;\n\t\tx=x*x%yl;y>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tint x;cin>>x;\n\t\t\tif(x)a[i].set(j);\n\t\t}\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tif(a[i][j]){\n\t\t\t\tif(g[j])a[i]^=f[j];\n\t\t\t\telse {f[j]=a[i];g[j]=1;++cnt;break;}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(POW(2,m)-POW(2,m-cnt)+yl)*POW(2,n-1)%yl<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<bitset>\n\ntypedef long long LL;\n\nconst int N=305;\nconst int MOD=998244343;\n\nint n,m,tot;\nbool vis[N];\nstd::bitset<N> bit[N],bas[N];\n\nint ksm(int x,int y)\n{\n\tint ans=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ans=(LL)ans*x%MOD;\n\t\tx=(LL)x*x%MOD;y>>=1;\n\t}\n\treturn ans;\n}\n\nvoid gauss()\n{\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tif (bit[i][j])\n\t\t\t{\n\t\t\t\tif (vis[j]) bit[i]^=bas[j];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbas[j]=bit[i];\n\t\t\t\t\ttot++;\n\t\t\t\t\tvis[j]=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tbit[i][j]=x;\n\t\t}\n\tgauss();\n\tint ans=(LL)ksm(2,n-1)*(ksm(2,m)-ksm(2,m-tot))%MOD;\n\tans+=ans<0?MOD:0;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, j, k) for (int i = j; i < (int)k; i++)\n#define pb push_back\n#define mt make_tuple\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef complex<ld> point;\ntypedef vector<int> vi;\n\ninline void fileIO(string s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\n\ntemplate <class T, class S>\ninline bool smin(T &a, S b) {\n  return (T)b < a ? a = b, 1 : 0;\n}\ntemplate <class T, class S>\ninline bool smax(T &a, S b) {\n  return a < (T)b ? a = b, 1 : 0;\n}\n\nconstexpr int MOD = 998244353;\nconstexpr int N = 302;\n\ntemplate <typename T>\ninline T mod(T &v) {\n  return v = (v % MOD + MOD) % MOD;\n}\ntemplate <typename S, typename T>\ninline S add(S &l, T r) {\n  return mod(l += r);\n}\nll po(ll v, ll u) {\n  return u ? po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD : 1;\n}\n\nint n, m, id[N], sz;\nbitset<N> tmp, paye[N];\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifndef LOCAL\n  // fileIO(\"superposition\");\n#endif\n\n  memset(id, -1, sizeof(id));\n  cin >> n >> m;\n  rep(i, 0, n) {\n    rep(j, 0, m) {\n      bool local;\n      cin >> local;\n      tmp[j] = local;\n    }\n    rep(j, 0, m) if (~id[j] && tmp[j]) tmp ^= paye[id[j]];\n    if (tmp.count()) {\n      int me = tmp._Find_first();\n      id[me] = sz;\n      rep(j, 0, sz) if (paye[j][me]) paye[j] ^= tmp;\n      paye[sz++] = tmp;\n    }\n  }\n\n  ll res = po(2, n) - po(2, n - sz) + MOD;\n  mod(res *= po(2, m - 1));\n  cout << res << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n//x,yがax+by=gcd(a,b)の解になる\nll extgcd(ll a, ll b, ll& x, ll& y) {\n\tll d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n//aのmod mでの逆元を求める\nll mod_inverse(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\nconst int N_MAX = 1 << 18;\nll p[N_MAX];\nvoid init() {\n\tp[0] = 1;\n\trep1(i, N_MAX - 1) {\n\t\tp[i] = p[i - 1] * i%mod;\n\t}\n}\n//xCyを求める\nll comb(ll x, ll y, ll m) {\n\tif (x < y)return 0;\n\tll res = p[x];\n\t(res *= mod_inverse(p[y], m)) %= mod;\n\t(res *= mod_inverse(p[x - y], m)) %= mod;\n\treturn res;\n}\nint n, m;\nint a[300][300];\nll odd[300][2];\nll mod_pow(ll x, int n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nll dp[2];\nll cop[2];\nll inv2 = (1 + mod) / 2;\nll inv4 = inv2 * inv2%mod;\nint main() {\n\tinit();\n\tcin >> n >> m;\n\tint num = 0;\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tcin >> a[i][j];\n\t\t\tif (a[i][j])num++;\n\t\t}\n\t}\n\tll ans = mod_pow(2, n + m);\n\tll z = mod_pow(2, n + m);\n\tfor (int j = 1; j <= num; j += 2) {\n\t\tll csum = mod_pow(inv4, j);\n\t\tcsum = csum * comb(num, j, mod) % mod;\n\t\tcsum = csum * z%mod;\n\t\tans = ans * csum%mod;\n\t}\n\tcout << ans << endl;\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 305;\nconst int MOD = 998244353;\nbitset<N> a[N]; \nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile(k) {\n\t\tif(k&1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD; \n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = m-1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t) a[i].set(j);\n\t\t}\n\t}\n \tfor (int i = 0; i < n; i++) {\n \t\tfor (auto b : base) {\n \t\t\tauto bb = b^a[i];\n \t\t\tfor (int j = m-1; j >= 0; j--) {\n \t\t\t\tif(bb[j] < a[i][j]) {\n \t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t }\n\t\t\t}\n\t\t }\t\n\t\t if(a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", (q_pow(2, n+m-1) - q_pow(2, n+m-1-cnt) + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){for(;;);}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ninline void setmin(int &x, int y) { if (y < x) x = y; }\ninline void setmax(int &x, int y) { if (y > x) x = y; }\ninline void setmin(ll &x, ll y) { if (y < x) x = y; }\ninline void setmax(ll &x, ll y) { if (y > x) x = y; }\n\nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 52;\n\nint min_bit(vector<int> &a) {\n    int p = 0;\n    while (p < sz(a) && a[p] == 0) {\n        p++;\n    }\n    return p;\n}\n\nvector<int> check(vector<vector<int> > &basis, vector<int> v) {\n    rep(i, 0, sz(basis)) {\n        int b = min_bit(basis[i]);\n        if (v[b] == 1) {\n            rep(j, 0, sz(v)) {\n                v[j] ^= basis[i][j];\n            }\n        }\n    }\n    return v;\n}\n\nbool is_zero(vector<int> &a) {\n    rep(i, 0, sz(a)) {\n        if (a[i] != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint solve(int n, vector<vector<int> > a) {\n    vector<vector<int> > basis;\n    rep(i, 0, n) {\n        vector<int> v = check(basis, a[i]);\n        if (!is_zero(v)) {\n            basis.push_back(v);\n            int p = sz(basis) - 1;\n            while (p - 1 >= 0) {\n                if (min_bit(basis[p]) < min_bit(basis[p - 1])) {\n                    basis[p].swap(basis[p - 1]);\n                    p--;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    return sz(basis);\n}\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD2) {\n        x -= MOD2;\n    }\n}\n\nint a[300][300];\nint dp[300][300];\nll pw[300 + 1];\n\nvoid init() {\n    pw[0] = 1;\n    rep(i, 1, 300 + 1) {\n        pw[i] = pw[i - 1] * 2 % MOD2;\n    }\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int> > a(n, vector<int> (m));\n    rep(i, 0, n) {\n        rep(j, 0, m) {\n            cin >> a[i][j];\n        }\n    }\n    int sz_basis = solve(n, a);\n    cout << (pw[n] - pw[n - sz_basis] + MOD2) * pw[m - 1] % MOD2 << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/************************************************\n * Au: Hany01\n * Date: Feb 10th, 2019\n * Prob: yahoo2019_e\n * Email: hany01dxx@gmail.com & hany01@foxmail.com\n * Inst: Yali High School\n************************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\n#define Rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define X first\n#define Y second\n#define PB(a) push_back(a)\n#define MP(a, b) make_pair(a, b)\n#define SZ(a) ((int)(a).size())\n#define ALL(a) a.begin(), a.end()\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 WoXiHuanNiA\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate <typename T> inline T read() {\n\tregister T _, __; register char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n//EOT\n\n\nconst int MAXN = 305;\n\nint n, m, a[MAXN][MAXN];\n\nint main() {\n#ifdef hany01\n\tfreopen(\"yahoo2019_e.in\", \"r\", stdin);\n\tfreopen(\"yahoo2019_e.out\", \"w\", stdout);\n#endif\n\n\tn = read<int>(), m = read<int>();\n\tFor(i, 1, n) For(j, 1, m)\n\t\ta[i][j] = read<int>() ^ a[i - 1][j] ^ a[i][j - 1] ^ a[i - 1][j - 1];\n\n\tLL ans = 0;\n\tFor(l1, 0, n - 1) For(l2, l1 + 1, n) {\n\t\tint cnt[2] = {0, 0};\n\t\tFor(i, 0, m) {\n\t\t\tint t = a[l1][i] ^ a[l2][i];\n\t\t\tans += cnt[t ^ 1], ++ cnt[t];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#define inf 20021225\n#define ll long long\n#define mdn 998244353\nusing namespace std;\n\nbitset<310> r[310],a[310]; int n,m;\nint gauss()\n{\n\tint w = 0;\n\t/**for(int i=1,j;i<=min(n,m);i++)\n\t{\n\t\tif(!r[i][i])\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t\tif(r[j][i])\tbreak;\n\t\t\tif(j>n)\tcontinue;\n\t\t\tswap(r[i],r[j]);\n\t\t}\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tif(r[j][i])\tr[j]^=r[i];\n\t}\n\tfor(int i=1;i<=min(n,m);i++)\tif(r[i][i])\tw++;*/\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=m;j;j--)\n\t\t{\n\t\t\tif(!r[i][j])\tcontinue;\n\t\t\tif(!a[j].any())\n\t\t\t{\n\t\t\t\ta[j]^=r[i],w++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\tr[i]^=a[j];\n\t\t}\n\t}\n\treturn w;\n}\nint ksm(int bs,int mi)\n{\n\tint ans = 1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=(ll)ans*bs%mdn;\n\t\tbs=(ll)bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tr[i][j] = x;\n\t\t}\n\tint ans = ksm(2,n+m-1)-ksm(2,n+m-1-gauss());\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <limits.h>\nusing namespace std;\ntypedef long long LL;\ntypedef bitset<305> BS;\nconst int B=305;\nconst int N=400;\nconst BS one=BS().set(0);\nconst BS zero=BS();\nconst LL M=998244353;\n\nstruct LB {\n\tint sz;\n\tBS b[B];\n\n\tvoid build(BS *a,int n) {\n\t\tsz=0;\n\t\tfor(int i=0;i<B;i++) {\n\t\t\tb[i].reset();\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tBS x=a[i];\n\t\t\tfor(int j=B-1;j>=0;j--) {\n\t\t\t\tif(((x>>j)&one)==one) {\n\t\t\t\t\tif(b[j]!=zero) x^=b[j];\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[j]=x;\n\t\t\t\t\t\tsz++;\n\t\t\t\t\t\tfor(int k=j-1;k>=0;k--) {\n\t\t\t\t\t\t\tif(b[k]!=zero && ((b[j]>>k)&one)==one) b[j]^=b[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=j+1;k<B;k++) {\n\t\t\t\t\t\t\tif(((b[k]>>j)&one)==one) b[k]^=b[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}lb;\n\nint n,m,b;\nBS a[N];\nLL dp[N],P[N],inv_P[N],pw[N];\n\nLL exgcd(LL a,LL b,LL &x,LL &y) {\n\tLL d=a;\n\tif(b!=0) {\n\t\td=exgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}\n\telse {\n\t\tx=1;y=0;\n\t}\n\treturn d;\n}\n\nLL mod_inv(LL a,LL m) {\n\tLL x,y;\n\texgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nvoid init() {\n\tP[0]=1;\n\tinv_P[0]=1;\n\tpw[0]=1;\n\tfor(int i=1;i<N;i++) {\n\t\tP[i]=P[i-1]*i%M;\n\t\tinv_P[i]=mod_inv(P[i],M);\n\t\tpw[i]=pw[i-1]*2%M;\n\t}\n}\n\nLL C(int n,int m) {\n\treturn P[n]*inv_P[m]%M*inv_P[n-m]%M;\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++) {\n\t\ta[i].reset();\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tscanf(\"%d\",&b);\n\t\t\tif(b) a[i].set(j);\n\t\t}\n\t}\n\tlb.build(a,n);\n\n\tdp[0]=1;\n\tfor(int i=0;i<B;i++) {\n\t\tint l=lb.b[i].count();\n\t\tif(l==0) continue;\n\t\tfor(int j=m;j>=0;j--) {\n\t\t\tif(j+l<=m) dp[j+l]+=dp[j],dp[j+l]%=M;\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=m;i++) {\n\t\tfor(int j=1;j<=i;j+=2) {\n\t\t\tans+=C(i,j)*dp[i]%M*pw[m-i]%M;\n\t\t\tans%=M;\n\t\t}\n\t}\n\tans*=pw[n-lb.sz],ans%=M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nbitset <333> dp[333];\nint a[333][333];\nint n, m;\nconst int mod = 998244353;\n\nlong long ans[333];\nlong long pw[333];\n\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%d %d\", &n, &m);\n\tpw[0] = 1;\n\tfor(int i = 1; i <= max(n, m); i++) {\n\t\tpw[i] = pw[i - 1] << 1;\n\t\tpw[i] %= mod;\n\t} \n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\tfor(int j = 0; j < m; j++) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdp[i].reset();\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int x = 0; x <= j; x++) {\n\t\t\t\tdp[i][x] = a[i][x];\n\t\t\t}\n\t\t}\n\t\tint ptr = 0;\n\t\tfor(int x = 0; x <= j; x++) {\n\t\t\tfor(int i = ptr; i < n; i++) {\n\t\t\t\tif(dp[i][x] == 1) {\n\t\t\t\t\tswap(dp[i], dp[ptr]);\n\t\t\t\t\tfor(int k = ptr + 1; k < n; k++) {\n\t\t\t\t\t\tif(dp[k][x] == 1) {\n\t\t\t\t\t\t\tdp[k] ^= dp[ptr];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++ptr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[j] = 1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(dp[i].count() == 0) {\n\t\t\t\tans[j] <<= 1;\n\t\t\t\tans[j] %= mod;\n\t\t\t}\n\t\t}\n\t\t// printf(\"%lld\\n\", ans[j]);\n\t}\n\tlong long res = pw[m-1] * (pw[n] - ans[0]);\n\tres %= mod;\n\tif(res < 0) res += mod;\n\tfor(int i = 1; i < n; i++) {\n\t\tres += pw[m-1] * (ans[i - 1] - ans[i]);\n\t\tres %= mod;\n\t\tif(res < 0) res += mod;\n\t}\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#define P 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nbitset <305> bt[305];\n\nint n, m;\n\nll _2[777];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++) {\n            int v;\n            scanf(\"%d\", &v);\n            if(v == 1) bt[i - 1][j - 1] = 1;\n        }\n    for(int i = 0; i < 777; i++) _2[i] = !i ? 1 : _2[i - 1] * 2 % P;\n    int nw = 0;\n    for(int i = 0; i < m; i++) {\n        for(int j = nw; j < n; j++)\n            if(bt[j][i]) {\n                swap(bt[j], bt[nw]);\n                break;\n            }\n        if(!bt[nw][i]) continue;\n        for(int j = nw + 1; j < n; j++)\n            if(bt[j][i]) bt[j] ^= bt[nw];\n        nw++;\n    }\n    int _1 = nw, _0 = n - nw;\n    ll ans = _2[m - 1] * (_2[_1] - 1) % P * _2[_0] % P;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\nint gauss (vector < vector< double > > a) {\n    int n = (int) a.size();\n    int m = (int) a[0].size();\n\n    vector<int> where (m, -1);\n    for (int col=0, row=0; col<m && row<n; ++col) {\n        int sel = row;\n        for (int i=row; i<n; ++i)\n            if (fabs (a[i][col]) > fabs (a[sel][col]))\n                sel = i;\n        if (fabs(a[sel][col]) < EPS)\n            continue;\n        for (int i=col; i<m; ++i)\n            swap (a[sel][i], a[row][i]);\n        where[col] = row;\n\n        // for(int i = col + 1 ; i < m ; i++){\n        //     assert(a[row][i] % a[row][col] == 0LL);\n\n        //     a[row][i] /= a[row][col];\n        // }\n        \n        for (int i=0; i<n; ++i)\n            if (i != row) {\n                double c = a[i][col] / a[row][col];\n\n                // assert(a[i][col] % a[row][col] == 0LL);\n                for (int j=col; j<m; ++j)\n                    a[i][j] -= a[row][j] * c;\n            }\n        ++row;\n    }\n\n    int rank = n;\n    // cout << \"m = \" << m << endl;\n    for(int i = 0 ; i < n ; i++){\n        bool has_one = false;\n\n        for(int j = 0 ; j < m ; j++){\n            if(fabs(a[i][j]) > EPS){\n                has_one = true;\n                break;\n            }\n        }\n\n        if(!has_one){\n            // cout << \"Linha \" << i << \" nao tem! \" << endl;\n            rank--;\n        }\n    }\n\n    return rank;\n}\n\nvector< vector< double > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    // cout << mod * mod << endl;\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            double x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = gauss(a);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n + m - 1);\n    ll nr = fast_pow(2LL, n + m - rank - 1);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD(nn - nr) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,k,n) for(int i=k;i<=n;i++)\n#define rep2(i,k,n) for(int i=k;i>=n;i--)\n#define mod 998244353\nusing namespace std;\ninline void upd(int& x,int y){\n\tx+=y;\n\tx-= (x>mod) ? mod : 0;\n}\nconst int N=305;\nint pw[N<<1],f[N],a[N][N],n,m;\nint main(){\n\tpw[0]=1;rep(i,1,600)pw[i]=pw[i-1],upd(pw[i],pw[i-1]);\n\trep(i,1,N-1)f[i]=pw[(i-1)<<1],upd(f[i],f[i-1]),upd(f[i],f[i-1]);\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n)rep(j,1,m)scanf(\"%d\",&a[i][j]);\n\tint r=0;\n\trep(i,1,n){\n\t\tint t=0;\n\t\trep(j,i,n)if(a[j][i]){t=j;break;}\n\t\tif(!t)continue;\n\t\tr++;\n\t\trep(j,1,m)swap(a[i][j],a[t][j]);\n\t\trep(j,i+1,n)if(a[j][i]){\n\t\t\trep(k,i,m)a[j][k]^=a[i][k];\n\t\t}\n\t}\n\tint ans=1ll*f[r]*pw[n-r]%mod*pw[m-r]%mod;\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <tuple>\ntemplate <typename T> constexpr T my_abs(const T &x) { return x < 0 ? -x : x; }\nusing ll = long long;\nconstexpr int MOD = 998244353;\ninline int quick_pow(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (ll)res * a % MOD;\n\t\ta = (ll)a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint fact[305], inv[305], arr[305][305], dp[305];\ninline int C(int n, int m) { return (ll)fact[n] * inv[m] % MOD * inv[n - m] % MOD; }\nint main()\n{\n\t// freopen(\"yahoo2019-E.in\", \"r\", stdin);\n\tint n, m, k = 0, ans = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tscanf(\"%d\", arr[i] + j);\n\t}\n\tfact[0] = inv[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD;\n\t\tinv[i] = quick_pow(fact[i], MOD - 2);\n\t}\n\tfor (int col = 0; col < m; col++)\n\t{\n\t\tint row = k;\n\t\twhile (row < n && !arr[row][col])\n\t\t\trow++;\n\t\tif (row >= n)\n\t\t\tcontinue;\n\t\tstd::swap(arr[row], arr[k]);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (!arr[i][col] || i == k)\n\t\t\t\tcontinue;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tarr[i][j] ^= arr[k][j];\n\t\t}\n\t\tk++;\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tsum += arr[i][j];\n\t\tfor (int j = m - sum; j >= 0; j--)\n\t\t\t(dp[j + sum] += dp[j]) %= MOD;\n\t}\n\tfor (int i = 0; i <= m; i++)\n\t{\n\t\tint coef = 0;\n\t\tfor (int j = 1; j <= i; j += 2)\n\t\t\t(coef += C(i, j)) %= MOD;\n\t\tans = (ans + (ll)dp[i] * coef % MOD * quick_pow(2, m - i)) % MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <limits.h>\nusing namespace std;\ntypedef long long LL;\ntypedef bitset<305> BS;\nconst int B=305;\nconst int N=400;\nconst BS one=BS().set(0);\nconst BS zero=BS();\nconst LL M=998244353;\n\nstruct LB {\n\tint sz;\n\tBS b[B];\n\n\tvoid build(BS *a,int n) {\n\t\tsz=0;\n\t\tfor(int i=0;i<B;i++) {\n\t\t\tb[i].reset();\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tBS x=a[i];\n\t\t\tfor(int j=B-1;j>=0;j--) {\n\t\t\t\tif(((x>>j)&one)==one) {\n\t\t\t\t\tif(b[j]!=zero) x^=b[j];\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[j]=x;\n\t\t\t\t\t\tsz++;\n\t\t\t\t\t\tfor(int k=j-1;k>=0;k--) {\n\t\t\t\t\t\t\tif(b[k]!=zero && ((b[j]>>k)&one)==one) b[j]^=b[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k=j+1;k<B;k++) {\n\t\t\t\t\t\t\tif(((b[k]>>j)&one)==one) b[k]^=b[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}lb;\n\nint n,m,b;\nBS a[N];\nLL dp[N],pw[N];\n\nint main() {\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++) {\n\t\ta[i].reset();\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tscanf(\"%d\",&b);\n\t\t\tif(b) a[i].set(j);\n\t\t}\n\t}\n\tlb.build(a,n);\n\n\tpw[0]=1;\n\tfor(int i=1;i<N;i++) {\n\t\tpw[i]=pw[i-1]*2%M;\n\t}\n\tLL ans=(pw[lb.sz]-1+M)%M*pw[n-lb.sz]%M*pw[m-1]%M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n\nconst ll MOD=998244353;\nll n,m,a[310][310];\n\nll ad(ll x,ll y){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll rnk(ll n,ll m,ll M[][310]){\n  ll d=0;\n  fr(i,n){\n    bool f=0;\n    if(M[i][d]==0){\n      f=1;\n      for(ll k=i+1;k<n;k++){\n        if(M[k][d]!=0){\n          f=0;\n          swap(M[i],M[k]);\n        }\n      }\n    }\n    if(f && d<m-1){i--;d++;continue;}\n    if(f) return i;\n    for(ll k=i+1;k<n;k++){\n      if(M[k][d]==0) continue;\n      for(ll j=d;j<m;j++){\n        M[k][j]=(M[k][j]+M[k][d])%2;\n      }\n    }\n    if(i==n-1) return n;\n  }\n}\n\nint main(){\n  cin>>n>>m;\n  fr(i,n) fr(j,m) cin>>a[i][j];\n  cout<<ad(pwr(2,n+m-1),MOD-pwr(2,n+m-1-rnk(n,m,a)))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n\n#define cMOD 998244353ULL\n#define cINF ((1ull<<62)-1)\n#define cINFINT ((1<<30)-1)\n\n\ntemplate <typename T>\nvoid calcFactional_mod( size_t size, \n\tvector<T>& fac, vector<T>& inv, vector<T>& facInv, T mod )\n{\n\tfor( T i = 2; i < size; ++i )\n\t{\n\t\tfac[i] = fac[i - 1] * i % mod; // n! % mod\n\t\tinv[i] = mod - inv[mod % i] * ( mod / i ) % mod; // 逆元計算 (n)^-1 % mod\n\t\tfacInv[i] = facInv[i - 1] * inv[i] % mod; // (n!)^-1 % mod\n\t}\n}\ntemplate <typename T>\nT pow_mod(T x, T n, T mod)\n{\n\tT res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (res * x) % mod;\n\t\tx = (x * x) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\ntemplate< typename T >\nclass Matrix\n{\npublic:\n\texplicit Matrix( size_t row_size, size_t col_size )\n\t{\n\t\tassign( row_size, col_size );\n\t}\n\n\tvoid assign( size_t row_size, size_t col_size )\n\t{\n\t\tmElement.assign( row_size, vector<T>() );\n\t\tREP( i, row_size ) mElement[i].assign( col_size, T(0) );\n\t}\n\n\tconst vector<T>& operator[] ( size_t row ) const\n\t{ return mElement[row]; }\n\tvector<T>& operator[] ( size_t row )\n\t{ return mElement[row]; }\n\n\tconst size_t rowSize() const\n\t{ return mElement.size(); }\n\tconst size_t colSize() const\n\t{ return mElement[0].size(); }\n\n\t/*T get( size_t row, size_t col ) const\n\t{ return mElement[row][col]; }\n\tvoid set( size_t row, size_t col, T value )\n\t{ mElement[row][col] = value; }*/\n\n\tMatrix<T> operator* ( const Matrix& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.rowSize() );\n\t\tMatrix ret( this->rowSize(), rhs.colSize() );\n\t\tREP( i, ret.rowSize() )\n\t\tREP( k, k_ )\n\t\tREP( j, ret.colSize() )\n\t\t\tret[i][j] = ret[i][j] + (*this)[i][k] * rhs[k][j];\n\t\treturn ret;\n\t}\n\n\tvector<T> operator* ( const vector<T>& rhs ) const\n\t{\n\t\tsize_t k_ = min( this->colSize(), rhs.size() );\n\t\tvector<T> ret( this->rowSize(), T() );\n\t\tREP( i, ret.size() )\n\t\tREP( k, k_ )\n\t\t\tret[i] = ret[i] + (*this)[i][k] * rhs[k];\n\t\treturn ret;\n\t}\n\n\t// O( N^3 )\n\t// Ax = b を解く\n\t// T = double にしないと割り算で狂うので注意\n\tstruct GaussJordanData\n\t{\n\t\tint rank = 0;\n\t\tint result = 0; // -1:解なし 0:不定 1:解あり\n\t\tvector<T> solution;\n\t};\n\tGaussJordanData gaussJordan() const\n\t{\n\t\tvector<T> b( rowSize(), 0 );\n\t\treturn gaussJordan( b );\n\t}\n\tGaussJordanData gaussJordan( const vector<T>& b ) const\n\t{\n\t\tGaussJordanData data;\n\t\tdata.result = 1;\n\n\t\t// 1列余分に取って、そこにbを入れる\n\t\tMatrix<T> B( rowSize(), colSize() + 1 );\n\t\tREP( i, rowSize() ) REP( j, colSize() + 1 )\n\t\t{\n\t\t\tif( j < colSize() ) B[i][j] = (*this)[i][j];\n\t\t\telse B[i][j] = b[i];\n\t\t}\n\n\t\tfor( int i = 0, j = 0; i < rowSize() && j < colSize(); ++i, ++j )\n\t\t{\n\t\t\t// j列目の値の絶対値が大きい行をi行目に持ってくる\n\t\t\tsize_t pivot = i;\n\t\t\tfor( int k = i + 1; k < rowSize(); ++k )\n\t\t\t\tif( abs( B[k][j] )> abs( B[pivot][j] ) ) pivot = k;\n\t\t\tswap( B[i], B[pivot] );\n\t\t\t// 解が一意でない\n\t\t\tif( abs( B[i][j] ) < numeric_limits<double>::epsilon() )\n\t\t\t{\n\t\t\t\t--i;\n\t\t\t\tdata.result = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Rankを1増やす\n\t\t\t++data.rank;\n\t\t\t// [i][j]を1にするようにi行目を割る\n\t\t\tfor( int l = j + 1; l <= colSize(); ++l )\n\t\t\t\tB[i][l] /= B[i][j];\n\t\t\tB[i][j] = 1;\n\t\t\t// k番目の行からi番目の行を引いて、j番目の列の数を消去\n\t\t\tREP( k, rowSize() ) if( k != i )\n\t\t\t{\n\t\t\t\tT coef = B[k][j];\n\t\t\t\tfor( int l = j; l <= colSize(); ++l )\n\t\t\t\t\tB[k][l] -= coef * B[i][l];\n\t\t\t}\n\t\t}\n\n\t\t// 解xを作る\n\t\tdata.solution.assign( colSize(), T() );\n\t\tfor( int i = 0, j = 0; j < colSize(); ++i, ++j )\n\t\t{\n\t\t\tif( i >= rowSize() || B[i][j] == 0 )\n\t\t\t{\n\t\t\t\tdata.solution[j] = 0;\n\t\t\t\t--i; continue;\n\t\t\t}\n\t\t\telse data.solution[j] = *( B[i].rbegin() );\n\t\t}\n\n\t\t// 解なしかをチェック\n\t\tif( data.result == 0 || ( data.rank ) < b.size() )\n\t\t{\n\t\t\tauto m = ( *this ) * data.solution;\n\t\t\tREP( i, m.size() ) if( m[i] != b[i] )\n\t\t\t{ data.result = -1; break; }\n\t\t}\n\t\tif( data.result != -1 )\n\t\t{\n\t\t\t// 解が一意\n\t\t\tif( data.rank == colSize() ) data.result = 1;\n\t\t\t// 解が不定\n\t\t\telse data.result = 0;\n\t\t}\n\t\t\n\t\treturn data;\n\t}\n\nprotected:\n\tvector<vector<T>> mElement;\n};\n\n\nint main()\n{\n\tconst ll maxN = 1000010;\n\tvector<ll> fac( maxN, 1 ), inv( maxN, 1 ), facInv( maxN, 1 );\n\tcalcFactional_mod<ll>( maxN, fac, inv, facInv, cMOD);\n\tauto mod = cMOD;\n\tauto add = [mod]      ( ll a, ll b ) { return ( a + b ) % mod; };\n\tauto sub = [mod]      ( ll a, ll b ) { return ( a + mod -b ) % mod; };\n\tauto mul = [mod]      ( ll a, ll b ) { return a * b % mod; };\n\tauto div = [&inv, mod]( ll a, ll b ) { return a * inv[b] % mod; };\n\tauto pow = [mod]      ( ll a, ll b ) { return pow_mod<ll>( a, b, mod ); };\n\t\n\tull n,m; cin >> n >> m;\n\tMatrix<double> mtx( n, m );\n\tREP( i, n ) REP( j, m ) cin >> mtx[i][j];\n\t\n\tauto data = mtx.gaussJordan();\n\tll ans = sub( pow( 2ull, n ), pow( 2ull, n - data.rank ) );\n\tans = mul( ans, pow( 2ull, m - 1 ) );\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 310;\nconst long long mod = 998244353;\nlong long power(long long x, long long k)\n{\n\tlong long ans = 1;\n\twhile(k)\n\t{\n\t\tif(k & 1)\n\t\t\t(ans *= x) %= mod;\n\t\tk >>= 1;\n\t\t(x *= x) %= mod;\n\t}\n\treturn ans;\n}\nint n, m;\nbool v[maxn][maxn];\nbool base[maxn][maxn] = {0};\nint cnt = 0;\nvoid insert(int x)\n{\n\tfor(int i = 1; i <= m; i ++)\n\t{\n\t\tif(v[x][i])\n\t\t{\n\t\t\tif(!base[i][i])\n\t\t\t{\n\t\t\t\tfor(int j = i; j <= m; j ++)\n\t\t\t\t\tbase[i][j] = v[x][j];\n\t\t\t\tcnt ++;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int j = i; j <= m; j ++)\n\t\t\t\t\tv[x][j] ^= base[x][j];\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= m; j ++)\n\t\t\tcin >> v[i][j];\n\t\tinsert(i);\n\t}\n\t/*\n\tcout << cnt << endl;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= m; j ++)\n\t\t\tcout << base[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\t*/\n\tcout << (power(2, n) - power(2, n - cnt) + mod) * power(2, m - 1) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace io {\n    // TYPE ID (StackOverflow)\n    \n    template<class T> struct like_array : is_array<T>{};\n    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};\n    template<class T> struct like_array<vector<T>> : true_type{};\n    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }\n\n    // I/O \n    \n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n    \n    // INPUT \n    \n    template<class T> void re(T& x) { cin >> x; }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest);\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    \n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    \n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n    \n    // OUTPUT \n    \n    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {\n        os << '{' << a.f << \", \" << a.s << '}'; return os;\n    }\n    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {\n        os << '{';\n        F0R(i,SZ) {\n            if (i) {\n                os << \", \";\n                if (is_like_array(a[i])) cout << \"\\n\";\n            }\n            os << a[i];\n        }\n        os << '}';\n        return os;\n    }\n    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {\n        return printArray(os,a,SZ);\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {\n        return printArray(os,a,sz(a));\n    }\n    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {\n        os << vector<T>(all(a)); return os;\n    }\n    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {\n        os << vector<pair<T1,T2>>(all(a)); return os;\n    }\n    \n    template<class T> void pr(const T& x) { cout << x << '\\n'; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        cout << first << ' '; pr(rest...); \n    }\n}\n\nusing namespace io;\n\nnamespace modOp {\n    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }\n    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }\n    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }\n    \n    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }\n    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }\n    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }\n    \n    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }\n    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }\n    \n    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1\n        if (a == 0) return b == 1 ? 0 : -1;\n        int x = invGeneral(b%a,a); \n        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n    }\n}\n\nusing namespace modOp;\n\nint N,M,sz;\nbool done[300];\nbitset<300> b[300];\n\nint main() {\n    // you should actually read the stuff at the bottom\n    setIO(); re(N,M);\n    F0R(i,N) {\n        F0R(j,M) {\n            bool x; re(x);\n            b[i][j] = x;\n        }\n    }\n    F0R(i,300) {\n        F0R(j,300) if (!done[j] && b[j][i]) {\n            done[j] = 1; sz ++;\n            F0R(k,300) if (!done[k] && b[k][i]) b[k] ^= b[j];\n            break;\n        }\n    }\n    // pr(sz);\n    pr(sub(po(2,N+M-1),po(2,N+M-1-sz)));\n    // (2^{N+M}-2^{N+M-size(basis for cols)})/2 \n    \n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(Int n){\n    if(n+1<=(signed)fact.size()) return;\n    fact.assign(n+1,1);\n    finv.assign(n+1,1);\n    invs.assign(n+1,1);\n    \n    for(Int i=1;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(Int i=n;i>=1;i--) finv[i-1]=finv[i]*Mint(i);\n    for(Int i=1;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(Int n,Int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(Int n,Int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(Int n,Int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(Int n,Int k){\n    Mint res;\n    init(k);\n    for(Int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(Int n,Int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(Int i=0;i<=n;i++){\n      for(Int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(Int n,Int k){\n    Mint res;\n    for(Int j=1;j<=k;j++) res+=S(n,j);\n    return res;\n  }\n\n  static Mint montmort(Int n){\n    Mint res;\n    init(n);\n    for(Int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    Int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(Int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(Int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n\nconst Int MAX = 303;\nusing BS = bitset<MAX*2>;\nusing mat = vector<BS>;\n\nvoid gauss(mat &v){\n  Int n=v.size();\n  for(Int i=0;i<n;i++){\n    for(Int k=i;k<n;k++){\n      if(v[k][i]){\n        swap(v[i],v[k]);\n        break;\n      }\n    }\n    for(Int k=0;k<n;k++)\n      if(i!=k&&v[k][i]) v[k]^=v[i];\n  }\n}\n\nInt mrank(mat v,Int m){\n  Int n=v.size();\n  Int r=0,c=0;\n  for(Int i=0;i<n;i++){\n    Int s=-1;\n    while(c<m){\n      for(Int j=i;j<n;j++){\n        if(v[j][c]){\n          s=j;\n          break;\n        }\n      }\n      if(~s) break;\n      c++;\n    }\n    if(c>=m) break;\n    \n    swap(v[i],v[s]);\n    for(Int j=0;j<n;j++)\n      if(i!=j&&v[j][c]) v[j]^=v[i];\n    \n    r++;c++;\n  }\n  return r;\n}\n\n//INSERT ABOVE HERE\nInt a[MAX][MAX];\nusing M = Mint<Int, 998244353>;\nM dp[2][MAX][MAX];\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<m;j++)\n      cin>>a[i][j];\n\n  mat X(n);\n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<m;j++)\n      if(a[i][j]) X[i].flip(j);\n  \n  Int r=mrank(X,m);\n  //cout<<n<<\" \"<<r<<endl;\n  M ans(1);\n  ans*=M(2).pow(n)-M(2).pow(n-r);\n  ans*=M(2).pow(m-1);\n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 1005\n#define MP make_pair\ntypedef long long LL;\nconst int mod = 998244353;\n\nint n, m;\nint a[500][500];\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tscanf(\"%d\", &a[j][i]);\n\t\n\tint r = 1;\n\tfor (int i = 1; i <= m; ++i)\n\t{\n\t\tint k = -1;\n\t\tfor (int j = r; j <= n; ++j)\n\t\t\tif (a[j][i]) k = j;\n\t\t\n\t\tif (k == -1) continue;\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tswap(a[k][j], a[r][j]);\n\t\tfor (int j = r + 1; j <= n; ++j)\n\t\t{\n\t\t\tif (!a[j][i]) continue;\n\t\t\tfor (int l = i; l <= m; ++l)\n\t\t\t\ta[j][l] ^= a[r][l];\n\t\t}\n\t\t++r;\n\t}\n\tint t = 1;\n\tr--; r = n - r;\n\twhile (r--) t = t * 2 % mod;\n\t\n\tLL ans = 1;\n\tint t1 = 1, t2 = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tt1 = t1 * 2 % mod;\n\tfor (int i = 1; i < m; ++i)\n\t\tt2 = t2 * 2 % mod;\n\t\n\tans = 1LL * (t1 - t) * t2 % mod;\n\tif (ans < 0) ans += mod;\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cout<<v[i][j]<<\" \";}cout<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nvii rotate(vii a) {\n  int h = a.size(), w = a[0].size();\n  vii b(w, vi(h));\n  rep (i, h) {\n    rep (j, w) {\n      b[j][i] = a[i][j];\n    }\n  }\n  return b;\n}\n\n\nconst int MAXN = 3010;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n\tfact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n\tfor (ll i = 2; i <= n; i++) {\n\t\tfact[i] = i * fact[i - 1] % M;\n\t\trfact[i] = mod_inverse(fact[i], M);\n\t}\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  ll ret = fact[n];\n  ret = (ret*rfact[r]) % M;\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\n\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n  vii a(h, vi(w));\n  rep (i, h) {\n    rep (j, w) {\n      cin >> a[i][j];\n    }\n  }\n  if (h < w) {\n    swap(h, w);\n    a = rotate(a);\n  }\n  set_fact(h + 100);\n  int no = 0;\n  rep (j, w) {\n    if (a[j][j] == 0) {\n      for (int i = j + 1; i < h; i++) {\n        if (a[i][j] == 1) {\n          swap(a[i], a[j]);\n          break;\n        }\n      }\n    }\n    if (a[j][j] == 0) {\n      no++;\n      continue;\n    }\n    for (int i = 0; i < h; i++) {\n      if (i == j) continue;\n      a[i][j] = 0;\n    }\n  }\n  ll ans = 0;\n  for (int x = 1; x <= w - no; x += 2) {\n    for (int y = 0; y <= w - no - x; y++) {\n      ans += mod_pow(2, h - w) * nCr(w - no, x) % MOD * mod_pow(2, 2 * no) % MOD * nCr(w - no - x, y) % MOD * mod_pow(2, w - no - x - y) % MOD;\n      ans %= MOD;\n    }\n      \n    \n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout << (x) << '\\n'\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n#define int long long\n#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) {if (a > b) a = b;}\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) {if (a < b) a = b;}\nvoid fail() { cout << -1 << endl; exit(0); }\n\ntypedef pair<int, int> pii; typedef pair<long long, long long> pll;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nll MOD = 998244353;\nconstexpr int MAX = 5050;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\nconstexpr ll LINF = 1e18 + 1; constexpr int INF = 1e9 + 1;\n//const int dx[4] = { 0,0,-1,1 }, dy[4] = { 1,-1,0,0 };\n\nconst int MAX_ROW = 510; // to be set appropriately\nconst int MAX_COL = 510; // to be set appropriately\nstruct BitMatrix {\n\tint H, W;\n\tbitset<MAX_COL> val[MAX_ROW];\n\tBitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n\tinline bitset<MAX_COL>& operator [] (int i) { return val[i]; }\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n\tint rank = 0;\n\tfor (int col = 0; col < A.W; ++col) {\n\t\tif (is_extended && col == A.W - 1) break;\n\t\tint pivot = -1;\n\t\tfor (int row = rank; row < A.H; ++row) {\n\t\t\tif (A[row][col]) {\n\t\t\t\tpivot = row;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) continue;\n\t\tswap(A[pivot], A[rank]);\n\t\tfor (int row = 0; row < A.H; ++row) {\n\t\t\tif (row != rank && A[row][col]) A[row] ^= A[rank];\n\t\t}\n\t\t++rank;\n\t}\n\treturn rank;\n}\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\nstruct mint {\n\tll x; // typedef long long ll;\n\tmint(ll x = 0) :x((x%mod + mod) % mod) {}\n\tmint operator-() const { return mint(-x); }\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += mod - a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) { (x *= a.x) %= mod; return *this; }\n\tmint operator+(const mint a) const { return mint(*this) += a; }\n\tmint operator-(const mint a) const { return mint(*this) -= a; }\n\tmint operator*(const mint a) const { return mint(*this) *= a; }\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime mod\n\tmint inv() const { return pow(mod - 2); }\n\tmint& operator/=(const mint a) { return *this *= a.inv(); }\n\tmint operator/(const mint a) const { return mint(*this) /= a; }\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\n\n\nint A[303][303];\nvoid solve() {\n\tCOMinit();\n\tint N, M; cin >> N >> M;\n\tBitMatrix mat(N, M);\n\tREP(i, N) {\n\t\tREP(j, M) {\n\t\t\tcin >> A[i][j];\n\t\t\tmat[i][j] = A[i][j];\n\t\t}\n\t}\n\tint r = GaussJordan(mat);\n\t//DEBUG(r);\n\tmint ans = 0;\n\tmint tw = 2;\n\tFOR(k, 1, r + 1) {\n\t\tmint c = COM(r, k);\n\t\tfor (int i = 1; i <= k; i += 2) {\n\t\t\tans += c * COM(k, i)*tw.pow(r - k);\n\t\t}\n\t}\n\tans *= tw.pow(N - r)*tw.pow(M - r);\n\tprint(ans);\n}\n\n\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//mt.seed((int)(time(0)));\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\tsolve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(0);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\ntemplate <int mod>\nclass ModInt {\npublic:\n    ModInt() : v(0) {}\n    ModInt(int x) : v((x+mod)%mod) {}\n    int value() const {return v;}\n    const ModInt operator+(const ModInt &r) const { return ModInt(this->v + r.v); }\n    const ModInt operator-(const ModInt &r) const { return ModInt(this->v + mod - r.v); }\n    const ModInt operator*(const ModInt &r) const { return ModInt(this->v * r.v); }\n    const ModInt operator/(const ModInt &r) const { return (*this * (~r)); }\n    const ModInt operator^(int k) const { return ModInt(bpow(this->v, k)); }\n    const ModInt operator~() const { return ModInt(bpow(this->v, mod-2)); }\n    bool operator==(const ModInt &r) const { return this->v == r.v; }\n    bool operator!=(const ModInt &r) const { return this->v != r.v; }\n    ModInt& operator+=(const ModInt &r) { return *this = *this + r; }\n    ModInt& operator-=(const ModInt &r) { return *this = *this - r; }\n    ModInt& operator*=(const ModInt &r) { return *this = *this * r; }\n    ModInt& operator/=(const ModInt &r) { return *this = *this * (~r); }\nprivate:\n    int v;\n    int bpow(int a, int b) const {\n        int ret = 1;\n        while (b > 0) {\n            if (b & 1) ret = (ret * a) % mod;\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return ret;\n    }\n};\nusing Mint = ModInt<1000000007>;\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    vector<valarray<int>> mat(N);\n    REP(i, N) {\n        valarray<int> row(M);\n        REP(j, M) {\n            cin >> row[j];\n        }\n        mat[i] = row;\n    }\n    int rank = 0;\n    REP(i, N) {\n        int col = [&] {\n            REPF(j, i, N) {\n                REPF(k, i, M) {\n                    if (mat[j][k] == 1) {\n                        swap(mat[j], mat[i]);\n                        return k;\n                    }\n                }\n            }\n            return -1LL;\n        }();\n        if (col == -1) break;\n\n        dump(i, col);\n        \n        REP(j, N) swap(mat[j][i], mat[j][col]);\n        rank++;\n        REP(j, N) {\n            if (j == i) continue;\n            if (mat[j][i] == 1) mat[j] ^= mat[i];\n        }\n    }\n\n    dump(rank);\n    FORE(r, mat) {\n        FORE(x, r) {\n            cerr << x << \" \";\n        }\n        cerr << endl;\n    }\n   \n    Mint ans = (Mint(2) ^ (N + M - 1)) - (Mint(2) ^ (N + M - rank - 1));\n    cout << ans.value() << endl;\n    return (0^_^0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define MOD(x) ((x) >= mod ? (x) - mod : (x))\n#define ll long long\nusing namespace std;\nconst int maxn = 510, inf = 1e9 + 233, mod = 998244353;\nint n, m, ans, cnt;\nint a[maxn], b[maxn][maxn];\n\ntemplate<typename T>\ninline void read(T &k)\n{\n\tint f = 1; k = 0; char c = getchar();\n\twhile (c < '0' || c > '9') c == '-' && (f = -1), c = getchar();\n\twhile (c <= '9' && c >= '0') k = k * 10 + c - '0', c = getchar();\n\tk *= f;\n}\n\ninline int power(int a, int b)\n{\n\tint ans = 1; \n\tfor (; b; b >>= 1, a = 1ll * a * a % mod)\n\t\tif (b & 1) ans = 1ll * ans * a % mod;\n\treturn ans;\n}\n\nint main()\n{\n\tread(n); read(m); \n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tread(a[j]);\n\n\t\tbool flag = 1;\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tif (a[j])\n\t\t\t{\n\t\t\t\tif (b[j][0])\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 1; k <= m; k++)\n\t\t\t\t\t\ta[k] ^= b[j][k];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tb[j][0] = 1;\n\t\t\t\t\tfor (int k = 1; k <= m; k++)\n\t\t\t\t\t\tb[j][k] = a[k];\n\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\tcnt += flag;\n\t}\n\n\tans = power(2, n) - power(2, cnt) + mod; ans = MOD(ans);\n\tprintf(\"%lld\\n\", 1ll * ans * power(2, m - 1));\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#ifdef MY_DEBUG\n#include \"header/header.hpp\"\n#else\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n#ifdef MY_DEBUG\n#include\"print.hpp\"\n#include\"debug.hpp\"\n#endif\n// }}}\n\nconst long long MOD = 998244353;\n\n//{{{ modular algebra\ntemplate<int mod=MOD>\nstruct Num{\n\tint v;\n\tNum(int n):v(n){}\n\tNum():v(0){}\n\toperator int() const {return v;}\n\toperator long long() const {return v;}\n\ttemplate<class T>\n\tNum operator =(int n){v=n;return *this;}\n\n\ttemplate<class T>\n\tinline void operator *=(const T &a) {\n\t\tv = (v*(long long)a)%mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator *(const T &a) {\n\t\tNum n(*this);n*=a;\n\t\treturn n;\n\t}\n\ttemplate<class T>\n\tinline void operator+=(const T &a){\n\t\tv+=(int)a;\n\t\tif(v>=mod)v-=mod;\n\t\t//\tassert(0<=v and v<mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator+(const T &a){\n\t\tNum n(*this);n+=a;\n\t\treturn n;\n\t}\n\tinline Num operator -(){\n\t\tif(v==0)return 0;\n\t\telse return Num(mod-v);\n\t}\n\ttemplate<class T>\n\tinline void operator -=(const T &a){\n\t\tv-=(int)a;\n\t\tif(v<0)v+=mod;\n\t}\n\ttemplate<class T>\n\tinline Num operator -(const T &a){\n\t\tNum n(*this);n-=a;\n\t\treturn n;\n\t}\n\n#ifdef __GCD_H\n\tinline Num inv(){\n\t\treturn Num(invMod(this->v,mod));\n\t}\n\ttemplate<class T>\n\tinline void operator /=(const T &a){\n\t\t(*this)*=invMod((int)a,mod);\n\t}\n\ttemplate<class T>\n\tinline Num operator /(const T &a){\n\t\tNum n(*this);n/=a;\n\t\treturn n;\n\t}\n#endif\n};\n\ntemplate<int mod=MOD>\nint abs(Num<mod> &a){\n\treturn a.v;\n}\ntemplate<class T, int mod>\nT& operator <<(T &os, const Num<mod> &n){\n\tos<<(int)n.v;\n\treturn os;\n}\n\ntemplate<class T, int mod>\nT& operator >>(T &is, Num<mod> &n){\n\tis>>n.v;\n\treturn is;\n}\n//}}}\ntypedef Num<MOD> mod_int;\n\n//{{{ mod_pow(Num<mod> x,Int k)\n/* (x^k)%m */\ntemplate<int mod=MOD>\ninline Num<mod> mod_pow(Num<mod> x, Int k){\n\tif(k==0) return 1;\n\tNum<mod> res(mod_pow(x,k/2));\n\tres*=res;\n\tif(k%2)res*=x;\n\treturn res;\n}\n//}}}\n\nInt N;\nInt M;\nvector<vector<Int>> a;\nvector<vector<Int>> a2;\n\n//{{{ rix library: MATRIX<T> A(n); MATRIX<T> A(n,m); VECTOR<T> v(n);\ntemplate<class T>\nstruct VECTOR:public vector<T>{\n\tconst int &n;\n\tVECTOR(const int &n):n(n){\n\t\tthis->assign(n,0);\n\t}\n};\n\n// O( n )\ntemplate<class T>\nT inner_product(const VECTOR<T> &a, const VECTOR<T> &b) {\n\tT ans = 0;\n\tfor (int i = 0; i < a.n; ++i)\n\t\tans += a[i]*b[i];\n\treturn ans;\n}\n\ntemplate<class T>\nstruct MATRIX:vector<vector<T> > {\n\tconst int n,m;\n\tMATRIX(int n):n(n),m(n){\n\t\tthis->assign(n,vector<T>(n,0));\n\t}\n\tMATRIX(const pair<int,int> &p):n(p.first),m(p.second){\n\t\tthis->assign(n,vector<T>(m,0));\n\t}\n\t// O( n )\n\tvoid operator+=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] += B[i][j];\n\t}\n\tvoid operator-=(const MATRIX<T> &B){\n\t\tREP(i,n)REP(j,m)(*this)[i][j] -= B[i][j];\n\t}\n};\n\ntemplate<class T>\nMATRIX<T> identity(int n) {\n\tMATRIX<T> A(n);\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> zero(int n) {\n\tMATRIX<T> A(n);\n\treturn A;\n}\n\ntemplate<class T>\nMATRIX<T> operator+(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC+=B;\n\treturn C;\n}\ntemplate<class T>\nMATRIX<T> operator-(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C{A};\n\tC-=B;\n\treturn C;\n}\n// O( n^2 )\ntemplate<class T>\nVECTOR<T> operator*(const MATRIX<T> &A, const VECTOR<T> &x) {\n\tVECTOR<T> y(A.n);\n\tfor (int i = 0; i < A.n; ++i)\n\t\tfor (int j = 0; j < A.m; ++j)\n\t\t\ty[i] += T(A[i][j])*x[j];\n\treturn y;\n}\n// O( n^3 )\ntemplate<class T>\nMATRIX<T> operator*(const MATRIX<T> &A, const MATRIX<T> &B) {\n\tMATRIX<T> C({A.n,B.m});\n\tfor (int i = 0; i < C.n; ++i)\n\t\tfor (int j = 0; j < C.m; ++j)\n\t\t\tfor (int k = 0; k < A.m; ++k)\n\t\t\t\tC[i][j] += T(A[i][k])*B[k][j];\n\treturn C;\n}\n// O( n^3 )\ntemplate<class T>\nvoid operator*=(MATRIX<T> &A, const MATRIX<T> &B){\n\tA = A*B;\n}\n\n// O( n^3 log e )\ntemplate<class T>\nMATRIX<T> pow(const MATRIX<T> &A, long long e) {\n\treturn e == 0 ? identity<T>(A.size())  :\n\te % 2 == 0 ? pow(A*A, e/2) : A*pow(A, e-1);\n}\n\ntypedef int Number;\ntypedef MATRIX<Number> Matrix;\ntypedef VECTOR<Number> Vector;\n\n//}}}\n\n//{{{ gauss\ntemplate<class T>\nint gauss(MATRIX<T> &A, VECTOR<T> &b) {\n\t//int gauss(& A) {//returns rank\n\tconst int n = A.size(),m = A[0].size();\n\tint pi = 0;\n\tfor(int pj = 0;pj < m;pj++){\n\t\tfor(int i = pi+1; i < n; i++) {\n\t\t\tif (abs(A[i][pj]) > abs(A[pi][pj])) {\n\t\t\t\tswap(A[i], A[pi]);\n\t\t\t\tswap(b[i], b[pi]);\n\t\t\t}\n\t\t}\n\t\tif (abs(A[pi][pj]) > 0) {\n\t\t\tT d = A[pi][pj];//1/A[pi][pj]\n\t\t\tREP(j, m)A[pi][j] *= d;\n\t\t\tb[pi] *= d;\n\t\t\tREP(i,n){\n\t\t\t\tif(i==pi)continue;\n\t\t\t\tT k = A[i][pj];\n\t\t\t\tREP(j, m) A[i][j] -= k * A[pi][j];\n\t\t\t\tb[i] -= k * b[pi];\n\t\t\t}\n\t\t\tpi++;\n\t\t}\n\t}\n\treturn pi;\n\t/*\n\t   for(int i = pi; i < n; i++)\n\t   if (abs(b[i]) > 0)\n\t   throw Inconsistent();\n\t   if (pi < m || pj < m)\n\t   throw Ambiguous();\n\t   for(int j = m-1; j >= 0; j--)\n\t   REP(i, j)\n\t   b[i] = modulo(b[i] - b[j] * A[i][j]);\n\t   */\n}\n//}}}\n\nvoid solve(){\n\tMATRIX<Num<2> > a2({N,M});\n\tVECTOR<Num<2> > b(N);\n\tREP(i,N)REP(j,M)a2[i][j] = a[i][j];\n\tint t = gauss(a2,b);\n\t/*\n\tREP(i,a2.size()){\n\t\tREP(j,a2[0].size()){\n\t\t\tcout<<a2[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<t<<endl;\n\t*/\n\tmod_int ans = mod_pow((mod_int)2,N) - mod_pow((mod_int)2,N-t);\n\tans *= mod_pow((mod_int)2,M-1);\n\tcout<<ans<<endl;\n}\n\n//{{{ main fucnction\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> N;\n\tcin >> M;\n\ta.assign(N, vector<Int>(M));\n\tfor(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < M ; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tsolve();\n\treturn 0;\n}\n\n//}}}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 1000001;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a%b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) *b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\n\n///////////////////////////\n\nll p(ll n) {\n\tif (n == 0) { return 1; }\n\treturn p(n - 1) * 2 % MOD;\n}\n\n\n\nint main() {\n\tll N, M;\n\tcin >> N >> M;\n\n\tvector<vector<ll>> a(N + 1, vector<ll>(M + 1));\n\n\trepn(i, N)repn(j, M) cin >> a[i][j];\n\n\tvector<ll> see(N + 1, 0);\n\n\trepn(i, M) {\n\t\tll t = 0;\n\t\trepn(j, N) {\n\t\t\tif (a[j][i] == 1&&see[j]==0) { t = j; break; }\n\t\t}\n\n\t\tsee[t] = 1;\n\n\t\tif (t == 0) { continue; }\n\n\t\tfor (ll j = t+1; j <= N; j++) {\n\t\t\tif (a[j][i] == 0) { continue; }\n\n\t\t\tfor (ll k = i; k <= M; k++) {\n\t\t\t\ta[j][k] = (a[j][k] + a[t][k]) % 2;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tll zero = 0;\n\t\n\trepn(i, N) {\n\t\tll b = 1;\n\t\trepn(j, M) {\n\t\t\tif (a[i][j] != 0) { b = 0; }\n\t\t\t//cout << a[i][j];\n\t\t}\n\t\t//cout << endl;\n\t\tzero += b;\n\t}\n\n\t\n\tll X = p(N) - p(zero);\n\tX = (X%MOD + MOD) % MOD;\n\n\tll ans = X * p(M - 1) % MOD;\n\tcout << ans;\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nusing namespace atcoder;\nusing mint = modint998244353;\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define Inf 1000000000000000\n\nvoid Gauss(vector<bitset<300>> &B){\n\tint now = 0;\n\trep(i,300){\n\t\tint temp = -1;\n\t\tfor(int j=now;j<B.size();j++){\n\t\t\tif(B[j][i]){\n\t\t\t\ttemp = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(temp==-1)continue;\n\t\t\n\t\trep(j,B.size()){\n\t\t\tif(temp==j)continue;\n\t\t\tif(B[j][i])B[j] ^= B[temp];\n\t\t}\n\t\t\n\t\tswap(B[now],B[temp]);\n\t\tnow++;\n\t}\n}\n\nint main(){\n\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tvector<bitset<300>> B(N);\n\t\n\trep(i,N){\n\t\trep(j,M){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tif(t==1){\n\t\t\t\tB[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tGauss(B);\n\t\n\tmint ans = mint(2).pow(M-1);\n\t\n\tmint diff = 1;\n\trep(i,N){\n\t\tif(B[i]==0){\n\t\t\tdiff *= 2;\n\t\t}\n\t}\n\t\n\tans *= mint(2).pow(N) - diff;\n\t\n\tcout<<ans.val()<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nint n,m,a[310][310];\nint od[310],ev[310],bit[310],xxj[310];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n\n\tint u=max(n,m);\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tint cnt=0;\n/*\tfor(int i=1;i<=u;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i]) continue;\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=u;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n*/\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tif(xxj[j])\n\t\t\t\t\tfor(int k=j;k<=m;k++)\n\t\t\t\t\t\ta[i][k]^=a[xxj[j]][k];\n\t\t\t\telse {xxj[j]=i;cnt++;break;}\n\t\t\t}\n\t}\n\tbit[0]=1;\n\tfor(int i=1;i<=u;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set> \n#include<cmath>\n#include <numeric>\n#include <array>\n#include <complex>\nusing namespace std;\nlong long p = 998244353;\n//long long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nvel kai;\nvel inv_kai;\nint rui(int a, int n, int mod) {\n    if (n == 0) { return 1 % mod; }\n    int x = rui(a, n / 2, mod);\n    x *= x; x %= mod;\n    if (n % 2 == 1) { x *= a; x %= mod; }\n    return x;\n}\nint root(int x, vel& pa) {\n    if (pa[x] == -1) { return x; }\n    int ans = root(pa[x], pa); pa[x] = ans;\n    return ans;\n}\nbool mar(int x, int y, vel& pa) {\n    x = root(x, pa);\n    y = root(y, pa);\n    if (x != y) { pa[x] = y; }\n    return (x != y);\n}\nint gcd(int x, int y) {\n    if (x < y) { return gcd(y, x); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\nint lcm(int x, int y) {\n    x = abs(x); y = abs(y);\n    return x * y / gcd(x, y);\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nvoid make_kai(int max_kai) {\n    kai = vel(max_kai, 1);\n    inv_kai = kai;\n    rep(i, max_kai - 1) {\n        kai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n        inv_kai[i + 1] = modinv(kai[i + 1], p);\n    }\n}\nint com(int n, int r) {\n    if ((n < 0) || (r < 0) || (r > n)) { return 0; }\n    int ans = (kai[n] * inv_kai[r]) % p;\n    return (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n    if (x.size() == 0) { return x; }\n    sor(x);\n    int n = x.size();\n    vel ans(1, x[0]);\n    for (int j = 1; j < n; j++) {\n        if (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n    }\n    x = ans;\n    return x;\n}\nvoid pr(vel& v) {\n    int n = v.size();\n    if (n != 0) {\n        cout << v[0];\n        rep(i, n - 1) {\n            cout << \" \" << v[i + 1];\n        }\n        cout << endl;\n    }\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n    int n = way.size();\n    vel dist(n, inf); dist[st] = 0;\n    priority_queue<pin, vector<pin>, greater<pin>> pq;\n    pq.push(mkp(0, st));\n    veb is_checked(n, false);\n    while (!pq.empty()) {\n        pin x = pq.top(); pq.pop();\n        int pot = x.second;\n        if (!is_checked[pot]) {\n            is_checked[pot] = true;\n            for (auto y : way[pot]) {\n                int nex_dist = x.first + y.second;\n                int nex_pot = y.first;\n                if (dist[nex_pot] > nex_dist) {\n                    dist[nex_pot] = nex_dist;\n                    pq.push(mkp(nex_dist, y.first));\n                }\n            }\n        }\n    }\n    return dist;\n}\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\nvel mul(vel& a, vel& b) {\n    int n = a.size();\n    int m = b.size();\n    vel ans(n + m - 1, 0);\n    rep(i, n) {\n        rep(j, m) {\n            ans[i + j] += a[i] * b[j];\n            ans[i + j] %= p;\n        }\n    }\n    return ans;\n}\nvel rui_p(vel& a, int n) {\n    if (n == 0) { return { 1 }; }\n    vel qans = rui_p(a, n / 2);\n    qans = mul(qans, qans);\n    if (n % 2 == 1) {\n        qans = mul(qans, a);\n    }\n    return qans;\n}\nvvel disj_min(vel& v) {\n    int n = v.size();\n    vvel ret(22, vel(n));\n    ret[0] = v;\n    rep(i, 21) {\n        rep(j, n) {\n            int nex = j + (1 << i);\n            if (nex < n) {\n                ret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n            }\n            else {\n                ret[i + 1][j] = ret[i][j];\n            }\n        }\n    }\n    return ret;\n}\nvvel disj_max(vel& v) {\n    int n = v.size();\n    vvel ret(20, vel(n));\n    ret[0] = v;\n    rep(i, 19) {\n        rep(j, n) {\n            int nex = j + (1 << i);\n            if (nex < n) {\n                ret[i + 1][j] = max(ret[i][j], ret[i][nex]);\n            }\n            else {\n                ret[i + 1][j] = ret[i][j];\n            }\n        }\n    }\n    return ret;\n}\nint find_min(vvel& dv, int l, int r) {\n    int i = 19;\n    while (l + (1 << i) > r) {\n        i--;\n    }\n    return min(dv[i][l], dv[i][r - (1 << i)]);\n}\nint find_max(vvel& dv, int l, int r) {\n    int i = 19;\n    while (l + (1 << i) > r) {\n        i--;\n    }\n    return max(dv[i][l], dv[i][r - (1 << i)]);\n}\nbool is_prime(int n) {\n    if (n == 0 || n == 1) { return false; }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) { return false; }\n    }\n    return true;\n}\n#define double long double\n#define pd pair<double,double>\n#define bs bitset<300>\nvoid per(int& ans) {\n    ans %= p;\n    if (ans < 0) { ans += p; }\n}\nint count_zero(V<bs>& a) {\n    int n = a.size();\n    int now_st = 0;\n    rep(i, 300) {\n        int fir_ze = -1;\n        for (int j = now_st; j < n; j++) {\n            if (a[j][i]) { fir_ze = j; break; }\n        }\n        if (fir_ze >= 0) {\n            rep(j, n) {\n                if (j != fir_ze&&a[j][i]) {\n                    a[j] = a[fir_ze] xor a[j];\n                }\n            }\n            swap(a[now_st], a[fir_ze]);\n            now_st++;\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        bool fl = true;\n        rep(j, 300) {\n            if (a[i][j]) { fl = false; break; }\n        }\n        if (fl) { ans++; }\n    }\n    return ans;\n}\nsigned main() {\n    int n, m; cin >> n >> m;\n    V<bs> a(n);\n    rep(i, n) {\n        rep(j, m) {\n            int x; cin >> x;\n            a[i][j] = x;\n        }\n    }\n    int cz = count_zero(a);\n    int ans = rui(2, n,p) - rui(2, cz,p); per(ans);\n    ans*=rui(2, m - 1, p); per(ans);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(0);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)if(a[j][now])for(int k = 0; k < m; ++k)a[j][k] ^= a[i][k];\n        ++ret;\n        ++now;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n\n    vector<vector<long>> a(N, vector<long>(M));\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n\n    auto r = rankF2(a);\n    cout << r << endl;\n    cout << modpow(N + M - r - 1) * (modpow(r) - 1) % m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void wri(ll a){write(a); putchar(' ');}\ninline void writeln(ll a){write(a); puts(\"\");}\nconst int N=300,mod=998244353;\nint get(int n){\n\tint ans=1;\n\tfor(int i=1;i<=n;i++)ans=ans*2%mod;\n\treturn ans;\n}\nbitset<N> s[N];\nsigned main(){\n\tint n=read(),m=read();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++)s[i][j]=read();\n\t}\n\tint rk=0;\n\tfor(int i=0,j=0;i<m;i++){\n\t\tfor(int k=j;k<n;k++)if(s[k][i]){swap(s[k],s[j]); break;}\n\t\tif(!s[j][i])continue; else rk++;\n\t\tfor(int k=j+1;k<n;k++)if(s[k][i])s[k]^=s[j];\n\t\tj++;\n\t}\n\tint ans=get(n)-get(n-rk)+mod;\n\tcout<<(ll)ans*get(m-1)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\nint N, M;\nint A[311][311];\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &M);\n    REP (i, N) REP (j, M) scanf(\"%d\", &A[i][j]);\n\n    int r = 0, c = 0;\n    while (r < N && c < M) {\n\tint p = -1;\n\tfor (int i=r; i<N; i++) if (A[i][c]) {\n\t    p = i;\n\t    break;\n\t}\n\tif (p == -1) {\n\t    c++;\n\t    continue;\n\t}\n\tfor (int j=c; j<M; j++) swap(A[r][j], A[p][j]);\n\tREP (i, N) if (i != p && A[i][c]) {\n\t    for (int j=c; j<M; j++) A[i][j] ^= A[p][j];\n\t}\n\tr++; c++;\n    }\n \n    \n    Mint ans = (Mint(2).pow(r) - 1) * Mint(2).pow(N-r) * Mint(2).pow(M-1);\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing ll = long long;\ntemplate <typename T>\nstruct Matrix\n{\n    static Matrix<T> I(const std::size_t N)\n    {\n        Matrix<T> ans(N, N);\n        for (std::size_t i = 0; i < N; i++) { ans[i][i] = T(1); }\n        return ans;\n    }\n    Matrix(const std::size_t R, const std::size_t C) : R{R}, C{C}, table(R, std::vector<T>(C, T(0))) {}\n    const std::vector<T>& operator[](const std::size_t r) const { return table[r]; }\n    std::vector<T>& operator[](const std::size_t r) { return table[r]; }\n    Matrix<T> operator-() const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = -table[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator+(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] + m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator-(const Matrix<T>& m) const\n    {\n        assert(R == m.R and C == m.C);\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] - m[i][j]; }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const Matrix<T>& m) const\n    {\n        assert(C == m.R);\n        Matrix<T> ans(R, m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < m.C; j++) {\n                for (std::size_t k = 0; k < C; k++) { ans[i][j] += table[i][k] * m[k][j]; }\n            }\n        }\n        return ans;\n    }\n    Matrix<T> operator*(const T& t) const\n    {\n        Matrix<T> ans(R, C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { ans[i][j] = table[i][j] * t; }\n        }\n        return ans;\n    }\n    template <typename C>\n    Matrix<T> operator^(const C n) const { return n == 0 ? I(R) : n % 2 == 1 ? (*this) * ((*this) ^ (n - 1)) : (((*this) * (*this)) ^ (n / 2)); }\n    Matrix<T>& operator=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator+=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] += m[i][j]; }\n        }\n    }\n    Matrix<T>& operator-=(const Matrix<T>& m)\n    {\n        assert(R == m.R and C == m.C);\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] -= m[i][j]; }\n        }\n        return *this;\n    }\n    Matrix<T>& operator*=(const Matrix<T>& m) { return *this = (*this) * m; }\n    Matrix<T>& operator*=(const T& t)\n    {\n        for (std::size_t i = 0; i < R; i++) {\n            for (std::size_t j = 0; j < C; j++) { table[i][j] *= t; }\n        }\n        return *this;\n    }\n    template <typename C>\n    Matrix<T>& operator^=(const C n) { return (*this) = ((*this) ^ n); }\n    const std::size_t R, C;\n    std::vector<std::vector<T>> table;\n};\ntemplate <typename T>\nMatrix<T> operator*(const T& t, const Matrix<T>& m) { return m * t; }\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < m.R; i++) {\n        os << \"[\";\n        for (std::size_t j = 0; j < m.C; j++) { os << m[i][j] << \" \"; }\n        os << \"]\\n\";\n    }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct Vector\n{\n    Vector(const std::size_t R) : R{R}, table(R, T(0)) {}\n    const T& operator[](const std::size_t r) const { return table[r]; }\n    T& operator[](const std::size_t r) { return table[r]; }\n    Vector<T> operator+(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    Vector<T> operator-(const Vector<T>& v) const\n    {\n        assert(R == v.R);\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    Vector<T> operator*(const T& t) const\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    Vector<T>& operator=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    Vector<T>& operator+=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    Vector<T>& operator-=(const Vector<T>& v)\n    {\n        assert(R == v.R);\n        for (std::size_t i = 0; i < R; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    Vector<T>& operator*=(const T& t)\n    {\n        Vector<T> ans(R);\n        for (std::size_t i = 0; i < R; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t R;\n    std::vector<T> table;\n};\ntemplate <typename T>\nVector<T> operator*(const T& t, const Vector<T>& v) { return v * t; }\ntemplate <typename T>\nVector<T> operator*(const Matrix<T>& m, const Vector<T>& v)\n{\n    assert(m.C == v.R);\n    Vector<T> ans(m.R);\n    for (std::size_t i = 0; i < m.R; i++) {\n        for (std::size_t j = 0; j < m.C; j++) { ans[i] += m[i][j] * v[j]; }\n    }\n    return ans;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const Vector<T>& v)\n{\n    os << \"[\\n\";\n    for (std::size_t i = 0; i < v.R; i++) { os << v[i] << \"\\n\"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstruct TVector\n{\n    TVector(const std::size_t C) : C{C}, table(C, T(0)) {}\n    const T& operator[](const std::size_t c) const { return table[c]; }\n    T& operator[](const std::size_t c) { return table[c]; }\n    TVector<T> operator+(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] + v[i]; }\n        return ans;\n    }\n    TVector<T> operator-(const TVector<T>& v) const\n    {\n        assert(C == v.C);\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] - v[i]; }\n        return ans;\n    }\n    TVector<T> operator*(const T& t) const\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { ans[i] = table[i] * t; }\n        return ans;\n    }\n    TVector<T>& operator=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] = v[i]; }\n        return *this;\n    }\n    TVector<T>& operator+=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] += v[i]; }\n        return *this;\n    }\n    TVector<T>& operator-=(const TVector<T>& v)\n    {\n        assert(C == v.C);\n        for (std::size_t i = 0; i < C; i++) { table[i] -= v[i]; }\n        return *this;\n    }\n    TVector<T>& operator*=(const T& t)\n    {\n        TVector<T> ans(C);\n        for (std::size_t i = 0; i < C; i++) { table[i] *= t; }\n        return *this;\n    }\n    const std::size_t C;\n    std::vector<T> table;\n};\ntemplate <typename T>\nTVector<T> operator*(const T& t, const TVector<T>& v) { return v * t; }\ntemplate <typename T>\nTVector<T> operator*(const TVector<T>& v, const Matrix<T>& m)\n{\n    assert(v.C == m.R);\n    TVector<T> ans(m.C);\n    for (std::size_t i = 0; i < m.C; i++) {\n        for (std::size_t j = 0; j < m.R; j++) { ans[i] += v[j] * m[j][i]; }\n    }\n    return ans;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const TVector<T>& v)\n{\n    os << \"[ \";\n    for (std::size_t i = 0; i < v.C; i++) { os << v[i] << \" \"; }\n    return (os << \"]\\n\");\n}\ntemplate <typename T>\nstd::size_t Rank(Matrix<T> mat)\n{\n    std::size_t r = 0;\n    for (std::size_t c = 0; c < mat.C; c++) {\n        if (r == mat.R) { break; }\n        std::size_t piv = r;\n        for (; piv < mat.R and mat[piv][c] == 0; piv++) {}\n        if (piv == mat.R) { continue; }\n        std::swap(mat[r], mat[piv]);\n        const T p = mat[r][c];\n        for (std::size_t i = r; i < mat.R; i++) { mat[i][c] /= p; }\n        for (std::size_t j = 0; j < mat.C; j++) {\n            if (j == c) { continue; }\n            const T p = mat[r][j];\n            for (std::size_t i = 0; i < mat.R; i++) { mat[i][j] -= mat[i][c] * p; }\n        }\n        r++;\n    }\n    return r;\n}\nconstexpr ll MOD = 998244353LL;\nint main()\n{\n    std::size_t N, M;\n    std::cin >> N >> M;\n    Matrix<int> a(N, M);\n    for (std::size_t i = 0; i < N; i++) {\n        for (std::size_t j = 0; j < M; j++) { std::cin >> a[i][j]; }\n    }\n    const std::size_t R = Rank(a);\n    std::vector<ll> bp(600, 1LL);\n    for (std::size_t i = 1; i < 600; i++) { bp[i] = bp[i - 1] * 2 % MOD; }\n    std::cout << (bp[N + M - 1] - bp[N + M - R - 1] + MOD) % MOD << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int DVD = 998244353;\nlong long pow2(int x){\n\tint a = 1; long long ans = 1;\n\twhile(x){\n\t\ta = (2*a)%DVD;\n\t\tif(x%2) ans = (ans*a)%DVD;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint main(void){\n\tint n,m; scanf(\"%d %d\",&n,&m);\n\tint kk = 0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tif(x==1) kk++;\n\t\t}\n\t}\n\tlong long ans=0;\n\tint k = n+m; int tmp = kk;\n\tbool flg = true;\n\twhile(k && tmp--){\n\t\tk-=2;\n\t\tif(flg){\n\t\t\tans = (ans+pow2(k))%DVD;\n\t\t}\n\t\telse{\n\t\t\tans = (ans+DVD-pow2(k))%DVD;\n\t\t}\n\t\tflg=!flg;\n\t}\n\tans = (kk*ans)%DVD;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconstexpr double eps = 1e-9;\nusing matrix = vector<vector<int>>;\n\nint myrank(matrix A) {\n  const int n = A.size(), m = A[0].size();\n  int r = 0;\n  for (int i = 0; r < n && i < m; ++i) {\n    int pivot = r;\n    for (int j = r + 1; j < n; ++j)\n      if (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[r]);\n    if (abs(A[r][i]) < eps) continue;\n    for (int k = m - 1; k >= i; --k) A[r][k] /= A[r][i];\n    for (int j = r + 1; j < n; ++j)\n      for (int k = i; k < m; ++k) A[j][k] -= A[r][k] * A[j][i];\n    ++r;\n  }\n  return r;\n}\n\nusing ll = long long;\nconstexpr ll mod = 998244353;\n\ntemplate <typename T>\nT mypow(T a, T b) {\n  if (b == 0) return 1;\n  T tmp = mypow(a, b / 2);\n  if (b % 2)\n    return (((tmp * tmp) % mod) * a) % mod;\n  else\n    return (tmp * tmp) % mod;\n}\n\nint main() {\n  ll n, m;\n  cin >> n >> m;\n  matrix a(n, vector<int>(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> a[i][j];\n    }\n  }\n\n  int rank = 0;\n  for (int j = 0; j < m; j++) {\n    int pivot = -1;\n    for (int i = rank; i < n; i++) {\n      if (a[i][j]) {\n        pivot = i;\n        break;\n      }\n    }\n    if (pivot >= 0) {\n      if (pivot != rank)\n        for (int k = 0; k < m; k++) swap(a[pivot][k], a[rank][k]);\n      for (int i = rank + 1; i < n; i++) {\n        if (a[i][j])\n          for (int k = 0; k < m; k++) a[i][k] ^= a[rank][k];\n      }\n      rank++;\n    }\n  }\n\n  ll ret = mypow(2LL, n + m - 1) + mod - mypow(2LL, n + m - rank - 1);\n  cout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define che\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=303;\nconst LL MOD= 998244353;\ntypedef bitset<N> bs;\n\nbs a[N];\nLL pw[N];\nint n,m;\n\n\n\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tscanf(\"%d%d\", &n, &m);\n\tpw[0]=1;\n\tfor (int i=1; i<N; ++i) pw[i]=(pw[i-1]<<1)%MOD;\n\tfor (int i=0,x; i<n; ++i)\n\t\tfor (int j=0; j<m; ++j){\n\t\t\tscanf(\"%d\", &x);\n\t\t\tif ( x) a[i].flip(j);\n\t\t}\n\t\n\tfor (int i=0,j=0; i<n && j<m; ++j){\n\t\tbool flag=false;\n\t\tfor (int k=i; k<n; ++k)\n\t\t\tif ( a[k].test(j)){\n\t\t\t\tswap(a[i],a[k]);\n\t\t\t\tflag= true;break;\n\t\t\t}\n\t\tif ( flag){\n\t\t\tfor (int k=i; k<n; ++k)\n\t\t\t\tif ( a[k].test(j)) a[k]^=a[i];\n\t\t\t++i;\n\t\t}\n\t}\n\tint fr=0;// free row\n\tfor (int i=0; i<n; ++i) if ( a[i].count()==0) ++fr;\n\tLL ans= (pw[n]-pw[fr]+MOD)%MOD;\n\tans=ans*pw[m-1]%MOD;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const {\n        long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u);\n    }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r;\n}\ntypedef ModInt<2> mint1;\ntypedef ModInt<998244353> mint2;\ntemplate <typename T> int gaussianElimination(vector<vector<T>> &A, int var = -1) {\n    int N = A.size(), M = A[0].size();\n    if (var < 0) {\n        var = N;\n        assert(N <= M);\n    }\n    int k = 0, rank = var;\n    rep(i, 0, var) {\n        int v = -1;\n        for (int j = k; j < N && v == -1; j++) if (A[j][i] != 0) v = j;\n        if (v == -1) {\n            rank--;\n            continue;\n        }\n        //a[i] = k;\n        swap(A[k], A[v]);\n        T x = T(1) / A[k][i];\n        rep(j, 0, M) A[k][j] = A[k][j] * x;\n        rep(j, 0, N) if (j != k) {\n            T y = A[j][i];\n            for (int h = M - 1; h >= i; h--)\n                A[j][h] = A[j][h] - A[k][h] * y;\n        }\n        k++;\n    }\n\n    return rank;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nint N, M;\nint v[606];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n\n    vector<vector<mint1>> v(N, vector<mint1>(M));\n\n    rep(i, 0, N) rep(j, 0, M) {\n        int a; cin >> a;\n        v[i][j] = a;\n    }\n\n    int R = gaussianElimination(v);\n\n    mint2 ans = ((mint2(2) ^ N) - (mint2(2) ^ (N-R))) * (mint2(2) ^ (M - 1));\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MOD = 998244353;\nconst Int MAX = 1000;\nInt fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nInt COM(Int n, Int k) {\n    if (n < k || n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nInt POW(Int n, Int m) {\n    if (m == 0) return 1;\n    if (m % 2 == 0) return POW(n * n % MOD, m / 2);\n    return n * POW(n, m - 1) % MOD;\n}\nint gaussian_elimination(vector<vector<int>> &A) {\n    int N = A.size(), M = A[0].size();\n    int t = 0;\n    for (int i = 0; i < N; i++) {\n        for (; t < M; t++) {\n            for (int j = i; j < N; j++) {\n                if (A[j][t]) {\n                    swap(A[i], A[j]);\n                    break;\n                }\n            }\n            if (A[i][t]) break;\n        }\n        if (t >= M) return i;\n        for (int j = i + 1; j < N; j++) {\n            if (j != i && A[j][t]) {\n                for (int k = 0; k < M; k++) A[j][k] ^= A[i][k];\n            }\n        }\n        t++;\n    }\n    return N;\n}\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    COMinit();\n    int N, M; cin >> N >> M;\n    vector<vector<int>> A(N, vector<int>(M));\n    for (auto &row : A) for (auto &a : row) cin >> a;\n    int rank = gaussian_elimination(A);\n    Int ans = 0;\n    for (int i = 1; i <= rank; i++) {\n        for (int j = 1; j <= i; j += 2) {\n            ans = ans + COM(rank, i) * COM(i, j) % MOD * POW(2, M - j) % MOD;\n        }\n    }\n    ans %= MOD;\n    ans = ans * POW(2, N - rank) % MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 303, mod = 998244353;\n\nint n, m;\nbitset<max_n> b;\nvector<bitset<max_n>> v;\n\nint power(int n) {\n    int res = 1;\n    for (int i = 0; i < n; ++i) {\n        res *= 2;\n        res %= mod;\n    }\n    return res;\n}\n\nbool operator < (const bitset<max_n> &a, const bitset<max_n> &b) {\n    for (int i = 0; i < m; ++i) {\n        if (a[i] != b[i]) {\n            return a[i] < b[i];\n        }\n    }\n    return false;\n}\n\nvoid add(bitset<max_n> b) {\n    for (int i = 0; i < v.size(); ++i) {\n        if ((b ^ v[i]) < b) {\n            b ^= v[i];\n        }\n    }\n    if (b == 0) {\n        return;\n    }\n    for (int i = 0; i < v.size(); ++i) {\n        if ((b ^ v[i]) < v[i]) {\n            v[i] ^= b;\n        }\n    }\n    v.push_back(b);\n    //sort(v.begin(), v.end());\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int x;\n            cin >> x;\n            b[j] = x;\n        }\n        add(b);\n    }\n    int ans = 1LL * power(n - v.size()) * (power(v.size()) - 1) % mod;\n    ans = 1LL * ans * power(m - 1) % mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\nusing namespace std;\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define LL long long\n#define pb push_back\n\nconst int N = 305;\nconst int MOD = 998244353;\nbitset<N> a[N];\nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile (k) {\n\t\tif (k & 1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD;\n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = m - 1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t) a[i].flip(j);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (bitset<N> b : base) {\n\t\t\tbitset<N> bb = b ^ a[i];\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (bb[j] != a[i][j]) {\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", ((q_pow(2, n + m - 1) - q_pow(2, n + m - 1 - cnt)) % MOD + MOD) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int mod=998244353;\nconst int N=700;\nint n,m,a[N][N];\nint od[N],ev[N],bit[N],xxj[N];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tcin>>a[i][j],a[i][j]&=1;\n\tif(n<m)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=i+1;j<=m;j++)\n\t\t\t\tswap(a[i][j],a[j][i]);\n\t\tswap(n,m);\n\t}\n\n\tint u=max(n,m);\n\tod[1]=1;ev[1]=3;\n\tfor(int i=2;i<=u;i++)\n\t{\n\t\tod[i]=(ev[i-1]+3ll*od[i-1]%mod)%mod;\n\t\tev[i]=(od[i-1]+3ll*ev[i-1]%mod)%mod;\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=u;i++)\n\t{\n\t\tint p=i;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[i][i]<a[j][i]) p=j;\n\t\tif(p!=i) swap(a[p],a[i]);\n\t\tif(!a[i][i])\n\t\t{\n\t\t\tu++;swap(a[i],a[u]);\n\t\t\tcontinue;\n\t\t}\n\t\tcnt++;\n\t\tfor(int j=i+1;j<=u;j++)\n\t\t\tif(a[j][i])\n\t\t\t\tfor(int k=i;k<=u;k++)\n\t\t\t\t\ta[j][k]^=a[i][k];\n\t}\n/*\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tif(xxj[j])\n\t\t\t\t\tfor(int k=j;k<=m;k++)\n\t\t\t\t\t\ta[i][k]^=a[xxj[j]][k];\n\t\t\t\telse {xxj[j]=i;cnt++;break;}\n\t\t\t}\n\t}\n*/\tbit[0]=1;\n\tfor(int i=1;i<=u;i++) bit[i]=2ll*bit[i-1]%mod;\n\tint bs=1ll*bit[n-cnt]*bit[m-cnt]%mod;\n\tprintf(\"%lld\\n\",1ll*od[cnt]*bs%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 310, P = 998244353;\nint n, m;\nbitset<maxn> a[maxn];\nvector<bitset<maxn> > base;\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1) z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        for (int j = m - 1, t; ~j; j--) {\n            scanf(\"%d\", &t);\n            if (t) a[i].set(j);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (auto b : base) {\n            auto c = b ^ a[i];\n            for (int j = m - 1; ~j; j--) {\n                if (c[j] < a[i][j]) { a[i] = c; break; }\n                else if (c[j] > a[i][j]) break;\n            }\n        }\n        if (a[i].any()) base.push_back(a[i]);\n    }\n    printf(\"%d\\n\", (qp(2, n + m - 1) - qp(2, n + m - 1 - base.size()) + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = 998244353ll;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n   ll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n   ll pow(ll a, ll b){if (b == 0) return 1; else if (b % 2 == 0) return pow(a * a, b / 2); else return pow(a * a, b / 2) * a;}\n   ll pow(ll a, ll b, ll m){if (b == 0) return 1; else if (b % 2 == 0) return (pow(a * a, b / 2, m) % m); else return (pow(a * a, b / 2) * a) % m;}\n   ll residue(ll a, ll m){return ((a % m) + m) % m;};\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\n\n//与えられたF2上の行列をAとして、(1 << (M * N - rank(A) - 1)) * ((1 << rank(A)) - 1 )が答え.\nll const MAX_M = 300, MAX_N = 300;\nll N, M;\nll a[MAX_N][MAX_M];\n\nll rnk(){\n   ll r = 0;\n   ll i = 0, j = 0;\n   while(i < N && j < M){\n      if(a[i][j]){\n         r++;\n         for(ll k = i + 1; k < N; k++){\n            if(a[k][j] == 0) continue;\n            for(ll l = j; l < M; l++){\n               a[k][l] = (a[k][l] + a[i][l]) % 2;\n            }\n         }\n         i++; j++;\n      }\n      else{\n         for(ll k = i + 1; k < N; k++){\n            if(a[k][j]){\n               for(ll l = j; l < M; l++){\n                  swap(a[i][l], a[k][l]);\n               }\n               break;\n            }\n         }\n         if(a[i][j]){\n            r++;\n            for(ll k = i + 1; k < N; k++){\n               if(a[k][j] == 0) continue;\n               for(ll l = j; l < M; l++){\n                  a[k][l] = (a[k][l] + a[i][l]) % 2;\n               }\n            }\n            i++; j++;\n         }\n         else{\n            j++;\n         }\n      }\n   }\n   return r;\n}\n\nint main(){\n   cin >> N >> M;\n   REP(i, N)REP(j, M) cin >> a[i][j];\n   ll r = rnk();\n   /*\n   REP(i, N){\n      REP(j, M){\n         if(j) {cout << \" \";}\n         cout << a[i][j];\n      }\n      cout << endl;\n   }\n   cout << \"rnk = \" << r << endl;\n   */\n   cout << residue(pow(2ll, M + N - 1, MOD) - pow(2ll, M + N - 1 - r, MOD), MOD) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<tuple>\n#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\n#define REP(i,x) for (int i=0;i<x;i++)\n#define REPP(i,x,y) for (int i=x;i<=y;i++)\n#define SI(x) scanf(\"%d\",&x)\n#define SL(x) scanf(\"%lld\",&x)\n#define MX3(x,y,z) max(x,max(y,z))\n#define MX4(x,y,z,p) max(x,max(y,max(z,p)))\n#define MX5(x,y,z,p,q) max(x,max(y,max(z,max(p,q))))\n#define MN3(x,y,z) min(x,min(y,z))\n#define MN4(x,y,z,p) min(x,min(y,min(z,p)))\n#define MN5(x,y,z,p,q) min(x,min(y,min(z,min(p,q))))\n#define amax(x,y) x=max(x,y)\n#define amin(x,y) x=min(x,y)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<vb> vvb;\ntypedef long double ld;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef tuple<int,int,int> ti;\ntypedef tuple<ll,ll,ll> tl;\n// #####################################################################\nconst long long MOD = 998244353;\n\nconst double __gauss_template_EPS = 1e-8;\nconst double EPS = __gauss_template_EPS;\n\nint Gauss(vector<vector<int>> &mat) {\n    \n    int rank = 0;\n    int n = (int)mat.size();\n    int m = (int)mat[0].size();\n\n    for(int i = 0; i < m; i++) {\n        bool ok = false;\n        for(int j = i; j < n; j++) {\n            if(mat[j][i]) {\n                swap(mat[j], mat[i]);\n                ok = true;\n                break;\n            }\n        }\n\n        if(!ok) continue;\n\n        rank++;\n\n        for(int j = i+1; j < n; j++) if(mat[j][i]) {\n\n            for(int k = i; k < m; k++) {\n\n                mat[j][k] ^= mat[i][k];\n            }\n        }\n    }\n\n    return rank;\n}\n\n\n\nconst long long __exp_template_MOD = MOD;\n\nlong long exp(int a, int b) {\n    if(b == 0) return 1;\n    long long tmp = exp(a, b/2);\n    if(b & 1) {\n        return (long long)tmp*tmp%__exp_template_MOD*a%__exp_template_MOD;\n    }\n    return (long long)tmp*tmp%__exp_template_MOD;\n}\n\nvoid solve() {\n    int n, m;\n    SI(n);\n    SI(m);\n    vvi rec(n,vi(m, 0));\n    REP(i, n) {\n        REP(j, m) {\n            scanf(\"%d\", &rec[i][j]);\n        }\n    }\n    int r = Gauss(rec);\n\n    printf(\"%lld\\n\", ((exp(2, n+m-1) - exp(2, n+m-r-1))%MOD+MOD)%MOD);\n}\n\nvoid init() {\n    \n\n\n}\n\nint main () {\n    init();\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=1000000007;\nconst long double eps=1e-60;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\n\nint main(){\n    ll n,m;cin>>n>>m;\n    vector<bitset<300>> v(n);\n    rep(i,n){\n        rep(j,m){\n            int a;cin>>a;\n            if(a)v[i].set(j);\n        }\n    }\n    ll cnt=n;\n    vb used(n,false);\n    rep(i,300){\n        ll k=-1;\n        rep(j,n)if(!used[j]&&v[j].test(i)){\n            if(k==-1){\n                k=j;used[j]=true;break;\n            }\n            else v[j]^=v[k];\n        }\n        if(k!=-1)cnt--;\n    }\n    out(cnt);\n    out((modpow(2,n)-modpow(2,cnt)+mod)*modpow(2,m-1)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nll mod = 998244353;\n\nvoid _main(istream &inp){\n    int n,m;\n    inp >> n >> m;\n    vvi a(n, vi(m));\n    rep(x,n) rep(y,m) inp >> a[x][y];\n    debug(a);\n    rep(x,n) rep(y,m) a[x][y]%=2;\n    int rank = 0;\n    int cur_x = 0;\n    rep(y,m){\n        FOR(x,cur_x+1,n){\n            if(a[x][y]==1 && a[cur_x][y]==0){\n                swap(a[x], a[cur_x]);\n            }\n            if(a[x][y]==1 && a[x][y]==1){\n                rep(y2,m) a[x][y2]^=a[cur_x][y2];\n            }\n            \n        }\n        if(a[cur_x][y]==1){\n            rank += 1;\n            cur_x += 1;\n        }\n    }\n    debug(rank);\n    debug(a);\n    ll ret = 1;\n    rep(i,rank) ret = 2*ret%mod;\n    ret = (ret+mod-1)%mod;\n    rep(i,n+m-rank-1 ) ret = 2*ret%mod;\n    cout << ret << endl;\n\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"out2.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n#define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \n// void bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid amax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid amin(T& x, T y) {\n    x = min(x, y);\n}\n\n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-12;\nconst int maxn = 5e4 + 3, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst int base2 = 998244353;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % base2;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % base2;\n    }\n}\n\nconst int N = 305;\n\nint gauss (vector < bitset<N> > a, int n, int m) {    \n    vector<int> where (m, -1);\n    \n    int rank = max(n, m);\n    for (int col=0, row=0; col<m && row<n; ++col) {\n        for (int i=row; i<n; ++i)\n            if (a[i][col]) {\n                swap (a[i], a[row]);\n                break;\n            }\n        if (!a[row][col]) {\n            rank--;\n            continue;\n        }\n        where[col] = row;\n\n        for (int i=0; i<n; ++i)\n            if (i != row && a[i][col])\n                a[i] ^= a[row];\n        ++row;\n    }\n\n    return rank;\n}\n\nint main() {\n   // files1;\n\n    int n, m;\n    cin >> n >> m;\n    vector<bitset<N> > a(n);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            bool x;\n            cin >> x;\n            a[i][j] = x;\n        }\n\n    int r = gauss(a, n, m);\n    cout << (binpow(2, n + m - 1) - binpow(2, n + m - r - 1) + base) % base;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = (ll)998244353;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n   ll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n   ll pow(ll a, ll b){if (b == 0) return 1; else if (b % 2 == 0) return pow(a * a, b / 2); else return pow(a * a, b / 2) * a;}\n   ll pow(ll a, ll b, ll m){if (a == 0) return 0; else if (b == 0) return 1; else if (b % 2 == 0) return (pow((a * a) % m, b / 2, m) % m); else return (pow((a * a) % m, b / 2) * a) % m;}\n   ll residue(ll a, ll m){return ((a % m) + m) % m;};\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\n\n//与えられたF2上の行列をAとして、(1 << (M * N - rank(A) - 1)) * ((1 << rank(A)) - 1 )が答え.\nconst ll MAX_M = 300, MAX_N = 300;\nll N, M;\nll a[MAX_N][MAX_M];\n\nll rnk(){\n   ll r = 0;\n   ll i = 0, j = 0;\n   while(i < N && j < M){\n      if(a[i][j]){\n         r++;\n         for(ll k = i + 1; k < N; k++){\n            if(a[k][j] == 0) continue;\n            for(ll l = j; l < M; l++){\n               a[k][l] = (a[k][l] + a[i][l]) % 2;\n            }\n         }\n         i++; j++;\n      }\n      else{\n         for(ll k = i + 1; k < N; k++){\n            if(a[k][j]){\n               for(ll l = j; l < M; l++){\n                  swap(a[i][l], a[k][l]);\n               }\n               break;\n            }\n         }\n         if(a[i][j]){\n            r++;\n            for(ll k = i + 1; k < N; k++){\n               if(a[k][j] == 0) continue;\n               for(ll l = j; l < M; l++){\n                  a[k][l] = (a[k][l] + a[i][l]) % 2;\n               }\n            }\n            i++; j++;\n         }\n         else{\n            j++;\n         }\n      }\n   }\n   return r;\n}\n\nint main(){\n   cin >> N >> M;\n   REP(i, N) REP(j, M) cin >> a[i][j];\n   ll r = rnk();\n/*\n   REP(i, N){\n      REP(j, M){\n         if(j) {cout << \" \";}\n         cout << a[i][j];\n      }\n      cout << endl;\n   }\n   cout << \"rnk = \" << r << endl;\n*/\n   cout << residue(pow(2ll, N + M - 1, MOD) - pow(2ll, N + M - 1 - r, MOD), MOD) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// by tmt514\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#define SZ(x) ((int)(x).size())\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 998244353;\nLL bigmod(LL a, LL n) {\n  if(n==0) return 1;\n  if(n==1) return a%MOD;\n  return bigmod(a*a%MOD, n/2) * (n%2? a:1)%MOD;\n}\nint a[1005][1005] = {};\nint main(void) {\n  int n, m;\n  cin >> n >> m;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<m;j++)\n      cin >> a[i][j];\n  int rank=0, w=0;\n  if(n>m) {\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n        swap(a[i][j], a[j][i]);\n    swap(n, m);\n  }\n  for(int i=0;i<m;i++) {\n    int g=-1;\n    for(int j=w;j<n;j++)\n      if(a[j][i]==1) {\n        g=j;\n        break;\n      }\n    if(g>=0) {\n      for(int k=0;k<m;k++)\n        swap(a[w][k], a[g][k]);\n      for(int j=w+1;j<n;j++) {\n          if(a[j][i]==1)\n        for(int k=0;k<m;k++)\n          a[j][k] ^= a[w][k];\n      }\n      ++rank;\n      ++w;\n    }\n  }\n  \n  LL t = bigmod(2, m-1) * (bigmod(2, n) - bigmod(2, n-rank)) % MOD;\n  t=(t%MOD+MOD)%MOD;\n  cout << t << endl;\n  \n      \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define che\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=303;\nconst LL MOD= 998244353;\ntypedef bitset<N> bs;\n\nbs a[N];\nLL pw[N];\nint n,m;\n\n\n\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tscanf(\"%d%d\", &n, &m);\n\tpw[0]=1;\n\tfor (int i=1; i<N; ++i) pw[i]=(pw[i-1]<<1)%MOD;\n\tfor (int i=0,x; i<n; ++i)\n\t\tfor (int j=0; j<m; ++j){\n\t\t\tscanf(\"%d\", &x);\n\t\t\tif ( x) a[i].flip(j);\n\t\t}\n\t\n\tfor (int i=0,j=0; i<n && j<m; ++j){\n\t\tbool flag=false;\n\t\tfor (int k=i; k<n; ++k)\n\t\t\tif ( a[k].test(j)){\n\t\t\t\tswap(a[i],a[k]);\n\t\t\t\tflag= true;break;\n\t\t\t}\n\t\tif ( flag){\n\t\t\tfor (int k=i+1; k<n; ++k)\n\t\t\t\tif ( a[k].test(j)) a[k]^=a[i];\n\t\t\t++i;\n\t\t}\n\t}\n\tint fr=0;// free row\n\tfor (int i=0; i<n; ++i) if ( a[i].count()==0) ++fr;\n\tLL ans= (pw[n]-pw[fr]+MOD)%MOD;\n\tans=ans*pw[m-1]%MOD;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\n\nvoid norm(VV<int>& a) {\n\tint n = a.size(), m = a[0].size();\n\tint pivot = -1;\n\tint pre = 0;\n\tREP(j, m) {\n\t\tFOR(i, pre, n) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tpivot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot == -1) continue;\n\t\tpre = pivot + 1;\n\n\t\tREP(i, n) if(i != pivot) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tREP(k, m) {\n\t\t\t\t\ta[i][k] ^= a[pivot][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tMAT(int, a, n, m);\n\n\tREP(_, 2) {\n\t\tnorm(a);\n\t\tVV<int> b(m, V<int>(n));\n\t\tREP(i, n) REP(j, m) {\n\t\t\tb[j][i] = a[i][j];\n\t\t}\n\t\tstd::swap(n, m);\n\t\tstd::swap(a, b);\n\t}\n\n\tint one = 0;\n\tint zero = 0;\n\tREP(i, n) {\n\t\tbool f = false;\n\t\tREP(j, m) if (a[i][j]) f = true;\n\t\tif (f) ++one;\n\t\telse ++zero;\n\t}\n\tREP(j, m) {\n\t\tbool f = false;\n\t\tREP(i, n) if (a[i][j]) f = true;\n\t\tif (f) /*++one*/;\n\t\telse ++zero;\n\t}\n\n\tint ans = powMod(2, n, MOD) - powMod(2, n - one, MOD);\n\t(ans *= powMod(2, m - 1, MOD)) %= MOD;\n\tif (ans < 0) ans += MOD;\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n\nconst int MAX_ROW = 510; // to be set appropriately\nconst int MAX_COL = 510; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\n\nconst int MOD = 998244353;\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() { \n    int N, M; cin >> N >> M;\n    BitMatrix A(N, M);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            int a; cin >> a;\n            if (a) A[i][j] = 1;\n        }\n    }\n    vector<int> res;\n    int r = GaussJordan(A);  \n    cout << (modpow(2LL, N+M-1, MOD) - modpow(2LL, N+M-r-1, MOD) + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=998244353;\nlong long n,m,a[333][333],pw[666],cnt,pos,cur,upper;\n/*long long Guass(long long Row,long long Column)\n{\n    long long row=1,col=1,max_r;\n    for(row=1;row<=Row&&col<=Column;row++,col++)\n    { \n        max_r=row;\n        for(long long i=row+1;i<=Row;i++)\n            if(abs(a[i][col])>abs(a[max_r][col]))\n                max_r=i;\n        if(a[max_r][col]==0)\n        {\n            row--;\n            continue;\n        }\n        if(max_r!=row)\n            for(long long i=col;i<=Column;i++)\n                swap(a[row][i],a[max_r][i]);\n\n        for(long long i=row+1;i<=Row;i++)\n        {\n            if(a[i][col]!=0)\n            {\n\n                for(long long j=col;j<=Column;j++)\n                    a[i][j]^=a[row][j];\n            }\n        }\n    }\n\treturn Column-row+1;\n}*/\nvoid gauss()\n{\n\tupper=1;\n\tfor (long long i=1;i<=m && upper<=n;i++)\n\t{\n\t\tpos=-1;\n\t\tfor (long long j=upper;j<=n;j++)\n\t\t{\n\t\t\tif (a[j][i])\n\t\t\t{\n\t\t\t\tpos=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~pos)\n\t\t{\n\t\t\tcnt++;\n\t\t\tfor (long long j=1;j<=m;j++) swap(a[i][j],a[pos][j]);\n\t\t\tfor (long long j=upper+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif (a[j][i])\n\t\t\t\t{\n\t\t\t\t\tfor (long long k=i;k<=m;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][k]^=a[upper][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupper++;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tfor (long long j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tpw[0]=1;\n\tfor (long long i=1;i<=600;i++) pw[i]=pw[i-1]*2%mod;\n\tgauss();\n\tcur=pw[m-cnt];\n\tprintf(\"%lld\\n\",((pw[n+m-1]-pw[n-1]*cur)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<bitset>\nusing namespace std;\n#define MAXN 300\n#define MOD 998244353\nint n,m;\nbitset<MAXN+5> A[MAXN+5],B[MAXN+5];\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*f; \n}\nint fst_pow(int a,int b)\n{\n\tint res=1;\n\twhile(b)\n\t{\n\t\tif(b&1)res=(1LL*res*a)%MOD;\n\t\ta=(1LL*a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\tA[i][j]=(read()==1);\n\tint r=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\tif(A[i][j])\n\t\t{\n\t\t\tif(B[j][j])A[i]^=B[j];\n\t\t\telse\n\t\t\t{B[j]=A[i];r++;break;}\n\t\t}\n\tprintf(\"%d\",(fst_pow(2,n+m-1)-fst_pow(2,n-r+m-1)+MOD)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 y11\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define LL long long\n//#define mp make_pair\n#define pb push_back\n#define ls rt<<1, l, m\n#define rs rt<<1|1, m+1, r\n#define ULL unsigned LL\n#define pll pair<LL, LL>\n#define pli pair<LL, int>\n#define pii pair<int, int>\n#define piii pair<pii, int>\n#define pdd pair<double, double>\n#define mem(a, b) memset(a, b, sizeof(a))\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//head\n\nconst int N = 305;\nconst int MOD = 998244353;\nbitset<N> a[N]; \nvector<bitset<N>> base;\nLL q_pow(LL n, LL k) {\n\tLL res = 1;\n\twhile(k) {\n\t\tif(k&1) res = (res*n) % MOD;\n\t\tk >>= 1;\n\t\tn = (n*n) % MOD; \n\t}\n\treturn res;\n}\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i].reset();\n\t\tfor (int j = m-1; j >= 0; --j) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif(t) a[i].flip(j);\n\t\t}\n\t}\n\tcout << (a[0]^a[1]) << endl;\n \tfor (int i = 0; i < n; i++) {\n \t\tfor (bitset<N> b : base) {\n \t\t\tbitset<N> bb = b^a[i];\n \t\t\tfor (int j = m-1; j >= 0; j--) {\n \t\t\t\tif(bb[j] < a[i][j]) {\n \t\t\t\t\ta[i] = bb;\n\t\t\t\t\tbreak;\n\t\t\t\t }\n\t\t\t}\n\t\t }\t\n\t\t if(a[i].any()) base.pb(a[i]);\n\t}\n\tint cnt = (int)base.size();\n\tprintf(\"%lld\\n\", ((q_pow(2, n+m-1) - q_pow(2, n+m-1-cnt)) % MOD+ MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 1e18;\nlong long int mod = 998244353;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1 , number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1 , number1);\n    }\n}\n\nll i,j,k,ii,jj,n,m,a,b,c,d,e,f,g,h,r,w,l,num,ans,ok,ng,mid;\nll x[500005],y[500005],z[500005];\nll dp[305][305];\nll sum[305];\nchar s[500005],t[500005],u[500005];\nbool dame,flag;\n//string s;\n\nint main(){\n\tcin >> n >> m;\n\tans = 1;\n\tfor(i=1;i<=n;i++){\n\t\tdame = true;\n\t\tfor(j=1;j<=m;j++){\n\t\t\tcin >> x[j];\n\t\t\tif(x[j] == 1)dame = false;\n\t\t}\n\t\tif(dame){\n\t\t\ta++;\n\t\t\tans *= 2;\n\t\t\tans %= mod;\n\t\t}else{\n\t\t\tfor(j=1;j<=m;j++){\n\t\t\t\tdp[i-a][j] = x[j];\n\t\t\t}\n\t\t}\n\t}\n\tn -= a;\n\tfor(j=1;j<=m;j++){\n\t\tdame = true;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(dp[i][j] % 2 == 1)dame = false;\n\t\t}\n\t\tif(dame){\n\t\t\tb++;\n\t\t\tans *= 2;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tm -= b;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=m+b;j++){\n\t\t\tsum[i] += dp[i][j];\n\t\t\t//pe(dp[i][j]);\n\t\t}\n\t\t//el;\n\t}\n\t//sum[i] := i行目の総和\n\tdame = true;\n\tfor(i=1;i<=n;i++){\n\t\tif(sum[i] % 2 == 1){\n\t\t\tdame = false;\n\t\t}\n\t}\n\tif(!dame){\n\t\tans *= (rui(2,m-1)* (rui(2,n) - 1))%mod;\n\t\tans %= mod;\n\t}else{\n\t\tfor(j=1;j<=m+b;j++){\n\t\t\tsum[j] = 0;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tsum[j] += dp[i][j];\n\t\t\t}\n\t\t}\n\t\tdame = true;\n\t\tfor(j=1;j<=m+b;j++){\n\t\t\tif(sum[j] % 2 == 1)dame = false;\n\t\t}\n\t\tif(!dame){\n\t\t\tans *= (rui(2,n-1)* (rui(2,m) - 1))%mod;\n\t\t\tans %= mod;\n\t\t}else{\n\t\t\t//p(\"!\");\n\t\t\tans *= (rui(2,n-1)* (rui(2,m) - 2))%mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tp(ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=998244353;\nint n,m,ans,A[305][305],two[605];\nvoid up(int &x){if (x>=P) x-=P;}\n\nint xor_guass(int m, int n) //AÊÇÒì»ò·½³Ì×éÏµÊý¾ØÕó ·µ»ØÖÈ\n{\n    int i = 0, j = 0, k, r, u;\n    while(i < m && j < n){//µ±Ç°ÕýÔÚ´¦ÀíµÚi¸ö·½³Ì,µÚj¸ö±äÁ¿\n        r = i;\n        for(int k = i; k < m; k++) if(A[k][j]){r = k; break;}\n        if(A[r][j]){\n             if(r != i) for(k = 0; k <= n; k++) swap(A[r][k], A[i][k]);\n             //ÏûÔªÍê³ÉÖ®ºóµÚiÐÐµÄµÚÒ»¸ö·Ç0ÁÐÊÇµÚjÁÐ,ÇÒµÚu>iÐÐµÄµÚjÁÐÈ«ÊÇ0\n            for(u = i + 1; u < m; u++) if(A[u][j])\n                for(k = i; k <= n; k++) A[u][k] ^= A[i][k];\n            i++;\n        }\n        j++;\n    }\n    return i;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tA[j-1][i-1]=x;\n\t\t}\n\t \n\ttwo[0]=1;\n\tfor (int i=1;i<=n+m;i++)\n\t\ttwo[i]=two[i-1]*2%P;\n\tans=1ll*(two[n]-two[min(n,m)-xor_guass(n,m)]+P)*two[m-1]%P; \n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(int v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(int v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define LLI long long int\n#define fst first\n#define snd second\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.71828182845904523536\n#endif\n#ifdef DEBUG\n#include <boost/core/demangle.hpp>\n#define dump(x) cerr << \"L\" << __LINE__ << \": in \" << __PRETTY_FUNCTION__ << \" \\e[32;1m\" << boost::core::demangle(typeid(x).name()) << \"\\e[37m\" << \" \" << (#x) << \" = \" << (x) << \"\\e[m\" << endl;\n#else\n#define dump(x)\n#endif\n#define pln(x) cout << (x) << endl\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T, typename U> using P = pair<T,U>;\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename Iter> ostream& out_container(ostream &os, Iter first, Iter last){\n  os << \"{\"; auto itr = first; while(itr != last){if(itr != first) os << \",\"; os << *itr; ++itr;} os << \"}\"; return os;\n}\n\ntemplate <typename T> ostream& operator<<(ostream &os, const vector<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const deque<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T> ostream& operator<<(ostream &os, const unordered_set<T> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream &os, const unordered_map<T,U> &c){return out_container(os,ALL(c));}\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T,U> &p){os << \"(\" << p.first << \",\" << p.second << \")\"; return os;}\n\ntemplate <typename T, typename U> T& chmin(T &a, const U &b){return a = (a<=b?a:b);}\ntemplate <typename T, typename U> T& chmax(T &a, const U &b){return a = (a>=b?a:b);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename T> LLI power(T n, T p, T m){if(p==0) return 1LL; if(p==1) return n; LLI k = power(n, p/2, m); return ((k*k)%m*(p%2?n:1))%m;}\n\nconst LLI mod = 998244353;\n\ntemplate <int M> class mod_int_64{\npublic:\n  int64_t val;\n  mod_int_64(): val(0){}\n  mod_int_64(int64_t n): val(n){}\n  mod_int_64(int32_t n): val(n){}\n  \n  const mod_int_64 operator+(const mod_int_64 &a) const {return mod_int_64((val+a.val)%M);}\n  const mod_int_64 operator-(const mod_int_64 &a) const {return mod_int_64((val-a.val+M)%M);}\n  const mod_int_64 operator*(const mod_int_64 &a) const {return mod_int_64((val*a.val)%M);}\n  const mod_int_64 operator/(const mod_int_64 &a) const {return mod_int_64((val*a.mod_inv().val)%M);}\n  \n  const mod_int_64& operator=(const mod_int_64 &a){val = a.val; return *this;}\n  const mod_int_64& operator+=(const mod_int_64 &a){(val += a.val) %= M; return *this;}\n  const mod_int_64& operator-=(const mod_int_64 &a){((val -= a.val) += M) %= M; return *this;}\n  const mod_int_64& operator*=(const mod_int_64 &a){(val *= a.val) %= M; return *this;}\n  const mod_int_64& operator/=(const mod_int_64 &a){(val *= a.mod_inv().val) %= M; return *this;}\n\n  const bool operator==(const mod_int_64 &a) const {return val==a.val;}\n  const bool operator!=(const mod_int_64 &a) const {return val!=a.val;}\n\n  const mod_int_64 power(LLI p) const{\n    mod_int_64 ret = 1, e = val;\n    for(; p; e *= e, p >>= 1) if(p&1) ret *= e;\n    return ret;\n  }\n  \n  const mod_int_64 mod_inv() const{\n    return power(M-2);\n  }\n};\n\ntemplate <int M> istream& operator>>(istream &is, mod_int_64<M> &a){is >> a.val; return is;}\ntemplate <int M> ostream& operator<<(ostream &os, const mod_int_64<M> &a){ os << a.val; return os;}\n\n\n\ntemplate <typename T> int rank_matrix(vector<vector<T>> mat){\n\n  int n = mat.size();\n  int m = mat[0].size();\n  int p = 0;\n  \n\n  REP(i,n){\n    if(p>=m) break;    \n\n    bool b = true;\n    FOR(j,i,n) if(mat[j][p] != 0) b = false;\n\n    if(b){\n      ++p;\n      continue;\n    }\n\n    if(mat[i][p] == 0){\n      FOR(j,i+1,n){\n\tif(mat[j][p] != 0){\n\t  swap(mat[i], mat[j]);\n\t  break;\n\t}\n      }\n    }\n    \n    FOR(j,i+1,n){\n      T t = mat[j][p] / mat[i][p];\n      REP(k,m) mat[j][k] -= mat[i][k] * t;\n    }\n  }\n\n  int r = 0;\n  REP(i,n){\n    REP(j,m){\n      if(mat[i][j] != 0){\n\t++r;\n\tbreak;\n      }\n    }\n  }\n\n  return r;\n}\n\nusing mod2 = mod_int_64<2>;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  while(cin >> N >> M){\n    vector<vector<mod2>> a(N, vector<mod2>(M)); cin >> a;\n\n    int r = rank_matrix(a);\n    \n    LLI ans = power(2LL,(LLI)(M-1),mod) * (power(2LL,(LLI)N,mod) - power(2LL,(LLI)(N-r),mod) + mod) % mod;\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n   typedef long long ll;\n   typedef pair<ll, ll> Pii;\n   typedef vector<ll> Vi;\n   typedef vector<Vi> VVi;\n\n   const double EPS = (1e-7);\n   const ll INF =(1e13);\n   const double PI = (acos(-1));\n   const ll MOD = (ll)998244353;\n\n   #define REP(i, n) for(ll i = 0; i < (ll)(n); i++)\n   #define REPR(i, n) for(ll i = n; i > -1; i--)\n   #define FOR(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)\n   #define ALL(x) (x).begin(),(x).end()\n   #define SORT(x) sort((x).begin(), (x).end())\n   #define RSORT(x) sort((x).rbegin(), (x).rend())\n   #define REVERSE(x) reverse((x).begin(), (x).end())\n   #define SZ(x) ((ll)(x).size())\n   #define pb push_back\n   #define mp make_pair\n\n   //chmax(a, b): a>bならaをbで更新　更新したときにtrueを返す\n   //chmin(a, b): a<bならaをbで更新　更新したときにtrueを返す\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n   template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n   #define dump(x) cerr<< #x << \"= \" << (x) << endl;\n\n   ll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n   ll pow(ll a, ll b){if (b == 0) return 1; else if (b % 2 == 0) return pow(a * a, b / 2); else return pow(a * a, b / 2) * a;}\n   ll pow(ll a, ll b, ll m){if (b == 0) return 1; else if (b % 2 == 0) return (pow((a * a) % m, b / 2, m) % m); else return (pow((a * a) % m, b / 2) * a) % m;}\n   ll residue(ll a, ll m){return ((a % m) + m) % m;};\n\n   ll dx[4]={1,0,-1,0};\n   ll dy[4]={0,1,0,-1};\n\n//与えられたF2上の行列をAとして、(1 << (M * N - rank(A) - 1)) * ((1 << rank(A)) - 1 )が答え.\nll const MAX_M = 300, MAX_N = 300;\nll N, M;\nll a[MAX_N][MAX_M];\n\nll rnk(){\n   ll r = 0;\n   ll i = 0, j = 0;\n   while(i < N && j < M){\n      if(a[i][j]){\n         r++;\n         for(ll k = i + 1; k < N; k++){\n            if(a[k][j] == 0) continue;\n            for(ll l = j; l < M; l++){\n               a[k][l] = (a[k][l] + a[i][l]) % 2;\n            }\n         }\n         i++; j++;\n      }\n      else{\n         for(ll k = i + 1; k < N; k++){\n            if(a[k][j]){\n               for(ll l = j; l < M; l++){\n                  swap(a[i][l], a[k][l]);\n               }\n               break;\n            }\n         }\n         if(a[i][j]){\n            r++;\n            for(ll k = i + 1; k < N; k++){\n               if(a[k][j] == 0) continue;\n               for(ll l = j; l < M; l++){\n                  a[k][l] = (a[k][l] + a[i][l]) % 2;\n               }\n            }\n            i++; j++;\n         }\n         else{\n            j++;\n         }\n      }\n   }\n   return r;\n}\n\nint main(){\n   cin >> N >> M;\n   REP(i, N)REP(j, M) cin >> a[i][j];\n   ll r = rnk();\n/*\n   REP(i, N){\n      REP(j, M){\n         if(j) {cout << \" \";}\n         cout << a[i][j];\n      }\n      cout << endl;\n   }\n   cout << \"rnk = \" << r << endl;\n*/\n   cout << residue(pow((ll)2, M + N - 1, MOD) - pow((ll)2, M + N - 1 - r, MOD), MOD) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsize_t rankF2(vector<vector<long>>& a){ // calculate rank of matrix in F_2\n    long n = a.size(), m = a[0].size();\n    auto add = [&m](vector<long>& to, vector<long>& from){\n        for(int i = 0; i < m; ++i)to[i] ^= from[i];\n    };\n    size_t now(0), ret(0);\n    while(now < m && ret < n){\n        size_t i(ret);\n        for(; i < n; ++i)if(a[i][now])break;\n        if(i == n){\n            ++now;\n            continue;\n        }\n        size_t j(i + 1);\n        for(; j < n; ++j)add(a[j], a[i]);\n        swap(a[ret], a[i]);\n        ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    constexpr long m = 998244353;\n    auto modpow = [&m](long n){\n        long r = 1, p = 2;\n        while(n){\n            if(n & 1){\n                r *= p;\n                r %= m;\n            }\n            p *= p;\n            p %= m;\n            n >>= 1;\n        }\n        return r;\n    };\n    long N, M;\n    cin >> N >> M;\n    bool f = false;\n    if(N > M && (f = true))swap(N, M);\n    vector<vector<long>> a(N, vector<long>(M));\n    long s(0);\n    if(f)for(int i = 0; i < M; ++i)for(int j = 0; j < N; ++j)scanf(\"%ld\", &a[j][i]);\n    else for(auto& i : a)for(auto &j : i)scanf(\"%ld\", &j);\n    auto r = rankF2(a);\n    cout << modpow(N + M - r - 1) * (modpow(r) + m - 1) % m << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// Containers Start\n#include <algorithm>\n#include <bitset>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n/// C Header Files\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <math.h>\n#include <stdio.h>\n/// Containers End\n\nusing namespace std;\n\n/// Math Start\n#define PI acos(-1.0)\n#define Pi 3.141592653589793\n#define EPS (1e-7)\n#define INF (0x3f3f3f3f)\n/// Math End\n\n/// Extra Start\n#define nn '\\n'\n#define pb push_back\n#define ull unsigned long long\n#define ll long long\n// #define MOD 1000000007\n#define MOD 998244353\n#define sz(a) int((a).size())\n#define space \" \"\n#define All(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n/// Extra End\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define Cini(a)                                                                \\\n    int a;                                                                     \\\n    cin >> a;\n#define Cinii(a, b)                                                            \\\n    int a, b;                                                                  \\\n    cin >> a >> b;\n#define Ciniii(a, b, c)                                                        \\\n    int a, b, c;                                                               \\\n    cin >> a >> b >> c;\n#define Cins(s)                                                                \\\n    string s;                                                                  \\\n    cin >> s;\n#define Cinss(s1, s2)                                                          \\\n    string s1, s2;                                                             \\\n    cin >> s1 >> s2;\n#define Cinc(c)                                                                \\\n    char c;                                                                    \\\n    cin >> c;\n/// Functions End\n\n/// Graph Start\nstruct edge {\n    int from, to;\n    long long cost;\n};\n/// Graph End\n\n/// Debug Start\n#define deb(x) cout << #x << \": \" << x << endl\n#define deb2(x, y) cout << #x << \": \" << x << '\\t' << #y << \": \" << y << endl;\n#define deb3(x, y, z)                                                          \\\n    cout << #x << \": \" << x << '\\t' << #y << \": \" << y << '\\t' << #z << \": \"   \\\n         << z << endl;\n/// Debug End\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\n/**>>>>>>>>>>>>>>>>>>> END <<<<<<<<<<<<<<<<<<**/\n\n/// template\n\n#define int long long\n\nsigned main(void) {\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n    Cinii(N, M);\n    int a[N + 1][M + 1], row[N + 1], col[M + 1];\n    fill(row, row + N + 1, 0);\n    fill(col, col + N + 1, 0);\n    vector<pair<int, int> > p;\n    rep(i, N) rep(j, M) cin >> a[i + 1][j + 1];\n    rep(i, N) {\n        rep(j, M) { row[1 + i] += a[i + 1][j + 1]; }\n    }\n    rep(i, M) {\n        rep(j, N) { col[1 + i] += a[j][i]; }\n    }\n    long long dp[N + 1];\n    long long mypow2[301];\n    mypow2[0] = 1;\n    rep(i, 300) mypow2[i + 1] = (mypow2[i] * 2) % MOD;\n    fill(dp, dp + N + 1, 0);\n    dp[0] = 0;\n    for (ll i = 1; i <= N; i++) {\n        dp[i] =  ((dp[i-1] +  ((M-row[i]) * dp[i-1])%MOD)%MOD + ((row[i])*(mypow2[i-1+M]-dp[i-1]))%MOD)%MOD;\n    }\n    cout << dp[N]/2LL << nn;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n#define PI  (3.1415926535)\n\n#define rep(i,n) for(ll i=0LL; i<n; ++i)\n#define srep(i,s,n) for(ll i=s; i<n; ++i)\n#define rrep(i,n) for(ll i=n-1LL; i>=0LL; --i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n        assert(!cin.eof()); \\\n        cin >> x; \\\n        assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T> >;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll> > q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void build(const T arr[]) {\n        memcpy(nodes + nodecount / 2LL, arr, sizeof(T) * itemcount);\n        rrep (i, nodecount / 2LL) {\n            nodes[i] = op(nodes[i * 2LL + 1LL], nodes[i * 2LL + 2LL]);\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    virtual T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    virtual T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n    T query_fast(ll start, ll end) const {\n        start += nodecount / 2LL;\n        end += nodecount / 2LL;\n        T lval = unit;\n        T rval = unit;\n        for ( ; start < end; start >>= 1LL, end >>= 1LL) {\n            if (!(start & 1LL)) lval = op(lval, nodes[start]);\n            if (!(end & 1LL)) rval = op(rval, nodes[end-1]);\n            end--;\n        }\n        return op(lval, rval);\n    }\n\n};\n\n//// update : sum / query : range sum\n// ll op(ll x, ll y){ return x + y; }\n// void op_upd(ll &x, ll y) { x += y; }\n// ll op_div(ll x) { return x / 2LL; }\n// ll op_mlt(ll x, ll y) { return x * y; }\n//// update : sum / query : range max\n// ll op(ll x, ll y) { return max(x, y); }\n// void op_upd(ll &x, ll y) { x += y; }\n// ll op_div(ll x) { return x; }\n// ll op_mlt(ll x, ll y) { return x; }\n//// update : substitute / query : range sum\n// ll add(ll x, ll y) { return x + y; }\n// void upd(ll &x, ll y) { x = y; }\n// ll div(ll x) { return x / 2LL; }\n// ll mlt(ll x, ll y) { return x * y; }\ntemplate <typename T>\nstruct SegmentTreeLazy : public SegmentTree<T> {\n    T *lzvals;\n    bool *lzvalids;\n    ll unit_upd;\n    void (*op_upd)(T&, T);\n    T (*op_div)(T);\n    T (*op_mlt)(T, T);\n\n    SegmentTreeLazy(ll itemcount, T unit, T unit_upd,\n                    T op(T, T), void op_upd(T&, T), T op_div(T), T op_mlt(T, T))\n        : SegmentTree<T>(itemcount, unit, op) {\n        this->lzvals = new T[this->nodecount];\n        this->lzvalids = new bool[this->nodecount];\n        this->unit_upd = unit_upd;\n        this->op_upd = op_upd;\n        this->op_div = op_div;\n        this->op_mlt = op_mlt;\n        rep (i, this->nodecount) this->lzvals[i] = unit_upd;\n        memset(this->lzvalids, 0, sizeof(bool) * this->nodecount);\n    }\n\n    // newval = op_upd(oldval, lzval);\n    void eval(ll nodeidx) {\n        if (!lzvalids[nodeidx]) return;\n\n        op_upd(this->nodes[nodeidx], lzvals[nodeidx]);\n\n        if (nodeidx * 2LL + 2LL < this->nodecount) {\n            ll downval = op_div(lzvals[nodeidx]);\n            op_upd(lzvals[nodeidx * 2LL + 1LL], downval);\n            op_upd(lzvals[nodeidx * 2LL + 2LL], downval);\n            lzvalids[nodeidx * 2LL + 1LL] = lzvalids[nodeidx * 2LL + 2LL] = true;\n        }\n\n        lzvalids[nodeidx] = false;\n        lzvals[nodeidx] = this->unit_upd;\n    }\n\n    void update(ll start, ll end, ll val) {\n        _update(start, end, val, 0LL);\n    }\n\n    void _update(ll start, ll end, ll val, ll nodeidx) {\n        eval(nodeidx);\n\n        ll rstart = get<0>(this->ranges[nodeidx]);\n        ll rend = get<1>(this->ranges[nodeidx]);\n        if (end <= rstart || rend <= start) return;\n\n        if (start <= rstart && rend <= end) {\n            op_upd(lzvals[nodeidx], op_mlt(val, rend - rstart));\n            lzvalids[nodeidx] = true;\n            eval(nodeidx);\n        }\n        else {\n            _update(start, end, val, nodeidx * 2LL + 1LL);\n            _update(start, end, val, nodeidx * 2LL + 2LL);\n            this->nodes[nodeidx] = this->op(this->nodes[nodeidx * 2LL + 1LL],\n                                            this->nodes[nodeidx * 2LL + 2LL]);\n        }\n    }\n\n    // query to [start, end)\n    virtual T query(ll start, ll end) {\n        return _query(start, end, 0LL);\n    }\n\n    virtual T _query(ll start, ll end, ll nodeidx) {\n        ll rstart = get<0>(this->ranges[nodeidx]);\n        ll rend = get<1>(this->ranges[nodeidx]);\n\n        eval(nodeidx);\n\n        if (start <= rstart && rend <= end) {\n            return this->nodes[nodeidx];\n        }\n        if (rend <= start || end <= rstart) {\n            return this->unit;\n        }\n        T left = _query(start, end, nodeidx * 2LL + 1LL);\n        T right = _query(start, end, nodeidx * 2LL + 2LL);\n        return this->op(left, right);\n    }\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n    }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\n#if 0\nS V<ll> edgelist[n+1];\n#endif\nvoid make_edgelist(const V<t2> &srclist, V<ll> edgelist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        edgelist[a].pb(b);\n        edgelist[b].pb(a);\n    }\n}\n\n#if 0\nS ll parents[n+1];\nS V<ll> children[n+1];\nS ll levels[n+1];\n#endif\nvoid make_parental_relation(const V<ll> edgelist[], ll root, ll n,\n                            ll parents[], V<ll> children[], ll levels[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parents[root] = root;\n    levels[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : edgelist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parents[next] = now;\n            children[now].pb(next);\n            levels[next] = levels[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _manacher(V<ll> &rlist, const string &s)\n{\n    ll n = s.size();\n    rep (i, n) rlist.pb(1);\n\n    ll center = -1;\n\n    rep (i, n) {\n        assert(center < i);\n        if (center < 0) {\n            center = 0;\n            continue;\n        }\n\n        ll opi = center - (i - center);\n        if (opi <= center - rlist[center]) {\n            rlist[i] = 1LL;\n            ll d = 1LL;\n            while (i-d >= 0 && i+d < n && s[i-d] == s[i+d]) rlist[i]++, d++;\n            center = i;\n            continue;\n        }\n\n        if (i + rlist[opi] < center + rlist[center]) {\n            rlist[i] = rlist[opi];\n            continue;\n        }\n\n        rlist[i] = center + rlist[center] - i;\n        ll d = center + rlist[center] - i;\n        while (i-d >= 0 && i+d < n && s[i-d] == s[i+d]) rlist[i]++, d++;\n        center = i;\n    }\n}\n\nvoid manacher(V<ll> &r_oddlist, V<ll> &r_evenlist, const string &s)\n{\n    _manacher(r_oddlist, s);\n\n    string ps;\n    ps += s[0];\n    srep (i, 1, s.size()) {\n        ps += \"$\";\n        ps += s[i];\n    }\n\n    V<ll> tmpr;\n    _manacher(tmpr, ps);\n    rep (i, s.size()-1) r_evenlist.pb(tmpr[i*2+1] / 2LL);\n    r_evenlist.pb(0LL);\n}\n\ndouble xy_distance(double x1, double y1, double x2, double y2)\n{\n    double xx = (x1 - x2) * (x1 - x2);\n    double yy = (y1 - y2) * (y1 - y2);\n    return sqrt(xx + yy);\n}\n\ndouble heron(double a, double b, double c)\n{\n    double s = (a + b + c) / 2.;\n    double ret = 1.;\n    ret *= s;\n    ret *= (s - a);\n    ret *= (s - b);\n    ret *= (s - c);\n    ret = sqrt(ret);\n    return ret;\n}\n\ndouble rad_normarize(double rad)\n{\n    while (rad < -PI) rad += 2. * PI;\n    while (rad > PI) rad -= 2. * PI;\n    return rad;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n         << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD  (998244353LL)\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n#if 0\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    ll m; llin(m);\n    S V<V<ll>> grid;\n    rep (i, n) {\n        V<ll> tmp; llina(tmp, m);\n        grid.pb(tmp);\n    }\n\n    ll nnow = 0;\n\n    rep (mm, m) {\n        if (nnow >= n) break;\n\n        if (!grid[nnow][mm]) {\n            srep (nn, nnow+1, n) {\n                if (!grid[nn][mm]) continue;\n                rep (mmm, m) grid[nnow][mmm] ^= grid[nn][mmm];\n                break;\n            }\n        }\n\n        if (!grid[nnow][mm]) continue;\n\n        srep (nn, nnow+1, n) {\n            if (!grid[nn][mm]) continue;\n            rep (mmm, m) grid[nn][mmm] ^= grid[nnow][mmm];\n        }\n\n        nnow++;\n    }\n\n    ll deg = nnow;\n\n    debug_printf(\"---- reg grid\\n\");\n    rep (nn, n) {\n        rep (mm, m) debug_printf(\"%lld \", grid[nn][mm]);\n        debug_printf(\"\\n\");\n    }\n\n    debug_printf(\"---- deg=%lld\\n\", deg);\n\n    S ll pows[100000];\n    pows[0] = 1;\n    rep (i, 99998) {\n        pows[i+1] = pows[i] * 2LL;\n        pows[i+1] %= MOD;\n    }\n\n    ll ans = pows[m];\n    ans -= pows[m-deg];\n    if (ans < 0) ans += MOD;\n    ans *= pows[n];\n    ans %= MOD;\n    ans *= mod_inv(2LL, MOD);\n    ans %= MOD;\n\n    debug_printf(\"---- ans\\n\");\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod998 = 998244353;\nconst ll intmax = 2147483647;\nconst ll llmax = 9223372036854775807;\nconst char sp = ' ';\n\nint N, M;\nll c[302][302], res, dp[301];\n\nint main() {\n\tc[0][0] = 1;\n\tfor (int i = 0; i <= 300; i++) {\n\t\tfor (int j = 0; j <= 300; j++) {\n\t\t\tc[i][j] %= mod998;\n\t\t\tc[i + 1][j] += c[i][j];\n\t\t\tc[i][j + 1] += c[i][j];\n\t\t}\n\t}\n\tcin >> N >> M;\n\tmap<string, int>mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tchar ch;\n\t\t\tcin >> ch;\n\t\t\ts.push_back(ch);\n\t\t}\n\t\tmp[s]++;\n\t}\n\tstring s = string(M, '0');\n\tfor (int i = 0; i <= mp[s]; i++) {\n\t\tdp[i] = c[i][mp[s] - i];\n\t}\n\tmp[s] = 0;\n\tfor (auto p : mp) {\n\t\tint x = p.second;\n\t\tfor (int i = N; i >= 0; i--) {\n\t\t\tfor (int j = 2; j <= x&&i + j <= N; j += 2) {\n\t\t\t\tdp[i + j] += dp[i] * c[j][x - j];\n\t\t\t\tdp[i + j] %= mod998;\n\t\t\t}\n\t\t}\n\t}\n\tll t = 1;\n\tfor (int i = 1; i < M; i++) {\n\t\tt *= 2;\n\t\tt %= mod998;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tres += t*c[i][N - i];\n\t\tres %= mod998;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tres += mod998;\n\t\tres -= dp[i] * t % mod998;\n\t\tres %= mod998;\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//05, 03, 2019, 11:12:14 Rafaelcs cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst double EPS = 1E-9;\nconst ll mod = 998244353LL;\nint gauss (vector < vector< double > > a) {\n    int n = (int) a.size();\n    int m = (int) a[0].size();\n\n    vector<int> where (m, -1);\n    for (int col=0, row=0; col<m && row<n; ++col) {\n        int sel = row;\n        for (int i=row; i<n; ++i)\n            if (abs (a[i][col]) > abs (a[sel][col]))\n                sel = i;\n        if (a[sel][col] == 0)\n            continue;\n        for (int i=col; i<m; ++i)\n            swap (a[sel][i], a[row][i]);\n        where[col] = row;\n\n        // for(int i = col + 1 ; i < m ; i++){\n        //     assert(a[row][i] % a[row][col] == 0LL);\n\n        //     a[row][i] /= a[row][col];\n        // }\n\n        a[row][col] /= a[row][col];\n        \n        for (int i=0; i<n; ++i)\n            if (i != row) {\n                double c = a[i][col] / a[row][col];\n\n                // assert(a[i][col] % a[row][col] == 0LL);\n                for (int j=col; j<m; ++j)\n                    a[i][j] -= a[row][j] * c;\n            }\n        ++row;\n    }\n\n    int rank = n;\n    // cout << \"m = \" << m << endl;\n    for(int i = 0 ; i < n ; i++){\n        bool has_one = false;\n\n        for(int j = 0 ; j < m ; j++){\n            if(a[i][j]){\n                has_one = true;\n                break;\n            }\n        }\n\n        if(!has_one){\n            // cout << \"Linha \" << i << \" nao tem! \" << endl;\n            rank--;\n        }\n    }\n\n    return rank;\n}\n\nvector< vector< double > > a;\n\nll fast_pow(ll base, int n){\n    ll carry = base;\n    ll res = 1LL;\n\n    while(n){\n        if(n & 1){\n            res = (res * carry) % mod;\n        }\n\n        n /= 2;\n        carry = (carry * carry) % mod;\n    }\n    \n    return res;\n}\n\nll MOD(ll x){\n    return ((x % mod) + mod) % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n\n    // cout << mod * mod << endl;\n    cin >> n >> m;\n\n    a.resize(n);\n\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < m ; j++){\n            double x;\n            cin >> x;\n            a[i].push_back(x);\n        }\n    }\n\n    int rank = gauss(a);\n    // cout << \"rank = \" << rank << endl;\n    // cout << \"voltei!\" << endl;\n    ll nn = fast_pow(2LL, n + m - 1);\n    ll nr = fast_pow(2LL, n + m - rank - 1);   \n    ll mm = fast_pow(2LL, m - 1);\n\n    cout << MOD(nn - nr) << endl; \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bitset>\n#include<cstdio>\n#include<algorithm>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\nusing namespace std;\n\nconst int N=510,mod=998244353;\nint n,m,y,rk,ans,a[N][N],pw[N];\nbitset<N> b[N];\n\nint main(){\n\tscanf(\"%d%d\",&n,&m); pw[0]=1;\n\trep(i,1,n){\n\t\tbitset<N>x(0);\n\t\trep(j,1,m) scanf(\"%d\",&y),x[j-1]=y;\n\t\tfor(int j=m-1; ~j; j--)\n\t\t\tif (x[j]){\n\t\t\t\tif (b[j].any()) x^=b[j];\n\t\t\t\t else{ b[j]=x; break; }\n\t\t\t}\n\t}\n\trep(i,1,min(n,m)) pw[i]=2*pw[i-1]%mod;\n\trep(i,0,m-1) if (b[i].any()) rk++;\n\tans=1ll*(pw[n]-pw[n-rk])*pw[m-1]%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 3e2 + 6, MOD = 998244353;\nint n, m;\nint Arr[N][N];\n\nvoid swap_row (int l, int r) {\n\tfor (int i = 0; i < m; i++)\n\t\tswap(Arr[l][i], Arr[r][i]);\n}\n\nvoid xor_row (int l, int r) {\n\tfor (int i = 0; i < m; i++)\n\t\tArr[r][i] ^= Arr[l][i];\n}\n\nint _sub (int a, int b) {\n\tint c = a - b;\n\tif (c < 0)\n\t\tc += MOD;\n\treturn c;\n}\n\nint _mul (int a, int b) {\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\n\nint _pow (int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1)\n\t\t\tres = _mul(res, a);\n\t\ta = _mul(a, a);\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tcin >> Arr[i][j];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint ind = -1;\n\t\tfor (int j = i; j < n; j++)\n\t\t\tif (Arr[j][i])\n\t\t\t\tind = j;\n\n\t\tif (ind == -1)\n\t\t\tcontinue;\n\n\t\tswap_row(i, ind);\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (Arr[j][i])\n\t\t\t\txor_row(i, j);\n\t}\n\n\tint num = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (Arr[i][j]) {\n\t\t\t\tnum++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\tif (!num) {\n\t\tcout << \"0\\n\";\n\t\treturn 0;\n\t}\n\n\tint res = _mul(_sub(_pow(2, num), 1), _pow(2, n - num));\n\tcout << _mul(res, _pow(2, m - 1)) << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 2500;\nconst int K = 19;\nint n, q;\nint mod = 998244353;\nint a[N][N], f[N], invf[N];\nvector < pair < int, int > > v;\nint binpow(int x, int y){\n    if (y == 0) return 1;\n    if (y % 2) return x * binpow(x, y - 1) % mod;\n    int z = binpow(x, y / 2);\n    return z * z % mod;\n}\nint c(int n, int k){\n    if (k < 0) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= m; j++) cin >> a[i][j];\n    }\n    int r = 0;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= m; j++){\n            if (a[i][j] != 0){\n                for (int l = j + 1; l <= m; l++){\n                    if (a[i][l] == 1){\n                        for (int k = 1; k <= n; k++){\n                            a[k][l] ^= a[k][j];\n                        }\n                    }\n                }\n                r++;\n                break;\n            }\n        }\n    }\n    cout << (binpow(2, n + m - 1) - binpow(2, n + m - 1 - r) + mod) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define che\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=303;\nconst LL MOD= 998244353;\ntypedef bitset<N> bs;\n\nbs a[N];\nLL pw[N];\nint n,m;\n\n\n\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tscanf(\"%d%d\", &n, &m);\n\tpw[0]=1;\n\tfor (int i=1; i<N; ++i) pw[i]=(pw[i-1]<<1)%MOD;\n\tfor (int i=0,x; i<n; ++i)\n\t\tfor (int j=0; j<m; ++j){\n\t\t\tscanf(\"%d\", &x);\n\t\t\tif ( x) a[i].flip(j);\n\t\t}\n\tint fr=0;// free row\n\tfor (int i=0;i<n; ++i){\n\t\tbool flag= false;\n\t\tfor (int j=i; j<n; ++j) if ( a[j].test(i)){\n\t\t\tswap(a[i],a[j]);\n\t\t\tflag=true;break;\n\t\t}\n\t\tif ( flag){\n\t\t\tfor (int j=i+1; j<n; ++j)\n\t\t\t\tif ( a[j].test(i)) a[j]^=a[i];\n\t\t}\telse\t++fr;\n\t}\n\tLL ans=(pw[n]-pw[fr]+MOD)%MOD;\n\tans=ans*pw[m-1]%MOD;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<bitset>\n#include<stack>\nusing namespace std;\n#define MOD 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nbitset<324> mat[324];\nInt cnt,n, m,a;\nInt mod_pow(Int x, Int a, Int m = MOD){\n  if(a == 0)return 1;\n  Int res = mod_pow(x, a / 2, m);\n  res = res * res % m;\n  if(a % 2)res *= x;\n  return res % m;\n}\n\nInt inv(Int x, Int m = MOD){\n  return mod_pow(x, m-2, m);\n}\n\n\nint main(){\n  cin >> n >> m;\n  for(int i = 0;i < n;i++){\n    for(int j = 0;j < m;j++){\n      cin >> a;\n      if(a)mat[i].set(j);\n    }\n  }\n  for(int i = 0;i < n;i++){\n\tif(i == m)break;\n    int st = i;\n    while(st < n && !mat[st][i])st++;\n    if(st == n)continue;\n    cnt++;\n    if(st != i)swap(mat[st], mat[i]);\n    for(int j = i+1;j < n;j++){\n      if(mat[j][i])mat[j] ^= mat[i];\n    }\n  }\n  cout << ((mod_pow(2, n+m) - mod_pow(2,n+m-cnt))*inv(2) % MOD+ MOD )% MOD << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 310, mod = 998244353;\n\nbitset<N> a[N];\nll p2[N];\n\nint rref(int n, int m);\n\nint main() {\n\tfast_cin();\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint temp; cin >> temp;\n\t\t\ta[i][j] = temp;\n\t\t}\n\t}\n\tp2[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tp2[i] = (p2[i - 1] * 2) % mod;\n\t}\n\tint fvar = rref(n, m);\n\tll ans = p2[n - 1] * (p2[m] - p2[fvar] + mod);\n\tcout << ans % mod << endl;\n}\n\nint rref(int n, int m) {\n\tint sr = 0, pivots = 0;\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = sr; i < n; ++i) {\n\t\t\tif (a[i][j]) {\n\t\t\t\tswap(a[i], a[sr]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!a[sr][j]) {\n\t\t\tcontinue;\n\t\t}\n\t\t++pivots;\n\t\tfor (int i = sr + 1; i < n; ++i) {\n\t\t\tif (a[i][j]) {\n\t\t\t\ta[i] ^= a[sr];\n\t\t\t}\n\t\t}\n\t\t++sr;\n\t}\n\treturn m - pivots;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ri register int\nconst int N=500005,M=998244353;\nint n,m,i,j,ans,vis[305];\nbitset<305> p[305],a[305];\nlong long qpow(long long a,long long b)\n{\n\tlong long s=a,ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*s%M;\n\t\ts=s*s%M;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\",&t);\n\t\t\ta[i][j-1]=t;\n\t\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=m-1;j>=0;--j)\n\t\t\tif(a[i][j])\n\t\t\t\tif(vis[j]==0)\n\t\t\t\t{\n\t\t\t\t\tp[j]=a[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvis[j]=1;\n\t\t\t\t\ta[i]^=p[j];\n\t\t\t\t}\n\t\tif(j<0)\n\t\t\tans++;\n\t}\n\tcout<<((qpow(2,n)-qpow(2,ans))*qpow(2,m-1)%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\nusing namespace std;\nconst int MOD=998244353;\nbitset<302> p[302],b[302],zero;\nvoid insert(bitset<302> x) {\n    for (int i = 301; i >= 0; i --) if (x[i]==1) {\n        if ( p[i] != zero ) {\n            x ^= p[i];\n        } else {\n            p[i] = x; \n            break;\n        }\n    }\n} \nint n,m;\nint main() {\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            int x; scanf(\"%d\",&x);\n            if(x) b[i][j]=1;\n        }\n        insert(b[i]);\n    }\n\n    int pivot=0;\n    for(int i=0;i<302;i++){\n        if(p[i] != zero) pivot ++;\n    }\n    int fre = n - pivot;\n    int ans = 1, sub = 1;\n\n    for(int i=1;i<=n;i++){\n        ans=ans*2LL%MOD;\n    }\n    for(int i=1;i<=fre;i++){\n        sub=sub*2LL%MOD;\n    }\n    ans = (ans-sub+MOD)%MOD;\n\n    int mul=1;\n    for(int i=1;i<m;i++){\n        mul=mul*2%MOD;\n    }\n\n    ans=1LL*ans*mul%MOD;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nconst ll MOD = 998244353;\nconst long double EPS = 1e-10;\nconst int dyx[4][2] = {\n    { 0, 1}, {-1, 0}, {0,-1}, {1, 0}\n};\n\nint n,m;\nvector< vector<int> > a(300, vector<int>(300, 0));\n\nint calc_rank(vector< vector<int> > a) {\n    // int n = a.size(), m = a[0].size();\n\n    int rank = 0;\n    for(int j=0;j<m;++j) {\n        int pivot = -1;\n        for(int i=rank;i<n;++i) {\n            if(a[i][j]) {\n                pivot = i;\n                break;\n            }\n        }\n        if(pivot == -1) continue;\n        if(pivot != rank) for(int j=0;j<m;++j)  swap(a[pivot][j], a[rank][j]);\n        for(int i=rank+1;i<n;++i) {\n            if(a[i][j]) for(int j=0;j<m;++j) a[i][j] ^= a[rank][j];\n        }\n        ++rank;\n    }\n\n    // for(int i=0;i<n;++i) {\n    //     for(int j=0;j<m;++j) {\n    //         cerr << a[i][j] << \" \";\n    //     }\n    //     cerr << \"\\n\";\n    // }\n\n    return rank;\n}\n\nll modpow(ll a, ll t) {\n    ll ret = 1LL;\n    while(t){\n        if(t & 1LL){\n            ret *= a;\n            ret %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        t >>= 1;\n    }\n    return ret;\n}\n\nint main() {\n    std::ios::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    for(int i=0;i<n;++i) for(int j=0;j<m;++j) cin >> a[i][j];\n    int r = calc_rank(a);\n    cout << (modpow(2LL, n+m-1) - modpow(2LL, n+m-r-1) + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\nint N, M;\nint A[311][311];\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &M);\n    REP (i, N) REP (j, M) scanf(\"%d\", &A[i][j]);\n\n    int r = 0, c = 0;\n    while (r < N && c < M) {\n\tint p = -1;\n\tfor (int i=r; i<N; i++) if (A[i][c]) {\n\t    p = i;\n\t    break;\n\t}\n\tif (p == -1) {\n\t    c++;\n\t    continue;\n\t}\n\tfor (int j=c; j<M; j++) swap(A[r][j], A[p][j]);\n\tREP (i, N) if (i != r && A[i][c]) {\n\t    for (int j=c; j<M; j++) A[i][j] ^= A[r][j];\n\t}\n\tr++; c++;\n    }\n \n    \n    Mint ans = (Mint(2).pow(r) - 1) * Mint(2).pow(N-r) * Mint(2).pow(M-1);\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\nconst int MAX_H = 510, MAX_W = 510;\nstruct MatrixB {\n  int H, W;\n  bitset<MAX_W> val[MAX_H];\n  MatrixB(int m = 1, int n = 1): H(m), W(n){}\n  inline bitset<MAX_W>& operator[](size_t i){return val[i];}\n  int gauss_jordan(bool is_extended = false){\n    int rank = 0;\n    for(int col = 0; col < W; col++){\n      if(col == W - 1 && is_extended)break;\n      int pivot = -1;\n      for(int row = rank; row < H; row++){\n        if(val[row][col]){\n          pivot = row;\n          break;\n        }\n      }\n      if(pivot == -1)continue;\n      swap(val[pivot], val[rank]);\n      for(int row = 0; row < H; row++){\n        if(row != rank && val[row][col])val[row] ^= val[rank];\n      }\n      rank++;\n    }\n    return rank;\n  }\n};\n\nint linear_eq(MatrixB &A, vector<int> b, vector<int> & res){\n  int m = A.H, n = A.W;\n  MatrixB M(m, n + 1);\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++){\n      M[i][j] = A[i][j];\n    }\n    M[i][n] = b[i];\n  }\n  int rank = M.gauss_jordan(true);\n\n  for(int row = rank; row < m; row++){\n    if(M[row][n])return -1;\n  }\n\n  res.assign(n, 0);\n  for(int i = 0; i < rank; i++)res[i] = M[i][n];\n  return rank;\n}\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)(res * curr % mod);\n    }\n    curr = (T)(curr * curr % mod);\n    tmp >>= 1;\n  }\n\n  return res;\n}\n\nint a[301][301];\n\nint main(int argc, char const* argv[])\n{\n  int n, m; cin >> n >> m;\n  rep(i, n){\n    rep(j, m)cin >> a[i][j];\n  }\n  MatrixB mat(n, m);\n  rep(i, n){\n    rep(j, m)mat[i][j] = a[i][j];\n  }\n  int r = mat.gauss_jordan();\n  ll t = power<ll>(2, m - r, mod);\n  ll res = power<ll>(2, n + m, mod);\n  (res -= t * power<ll>(2, n, mod) % mod) %= mod;\n  (res -= (power<ll>(2, m, mod) - t) * power<ll>(2, n - 1, mod) % mod) %= mod;\n  if(res < 0)res += mod;\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\nimport Data.Bits\nimport Data.List\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport Control.Monad\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.Applicative\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Control.Monad.State.Strict\nimport Data.Int\nimport Data.Word\nimport System.IO\nimport Data.Function\nimport Control.Monad.Primitive\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.STRef\nimport Data.IORef\nimport Control.DeepSeq\n\nmain :: IO ()\nmain = do\n  [n,m] <- map readInt . words <$> getLine\n  a <- V.unfoldrN n (runStateT\n                      $ foldM\n                         (\\ !acc _ -> (shiftL acc 1 +) . toInteger <$> rInt)\n                         0 [1..m]) <$> BSL.getContents\n  let rank = countRank n m a\n  print $ fromMon $ 2^(n+m-1) - 2^(n+m-rank-1)\n      \n\n{-# INLINE countRank #-}\ncountRank :: Int -> Int -> V.Vector Integer -> Int\ncountRank n m = fst . until (V.null . snd) go . (0,)\n  where\n    go (!acc,!vec) = case V.find (`testBit` 0) vec of\n      Nothing -> (acc, force $ V.filter (/=0) $ V.map (`shiftR` 1) vec)\n      Just row -> (acc+1, force $ V.filter (/= 0)\n                    $ V.map (\\row1 -> (`shiftR` 1) $\n                              if testBit row1 0 then row1 `xor` row else row1)\n                          vec)\n              \n            \n  \n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y + if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32) $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\nimport Data.Bits\nimport Data.List\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport Control.Monad\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.Applicative\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Control.Monad.State.Strict\nimport Data.Int\nimport Data.Word\nimport System.IO\nimport Data.Function\nimport Control.Monad.Primitive\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.STRef\nimport Data.IORef\nimport Control.DeepSeq\nimport Numeric.Natural\n\nmain :: IO ()\nmain = do\n  [n,m] <- map readInt . words <$> getLine\n  a <- V.unfoldrN n (runStateT\n                      $ foldM\n                         (\\ !acc _ -> (shiftL acc 1 .|.).fromIntegral <$> rInt)\n                         0 [1..m]) <$> BSL.getContents\n  let rank = countRank n m a\n  print $ fromMon $ 2^(n+m-1) - 2^(n+m-rank-1)\n      \n\n{-# INLINE countRank #-}\ncountRank :: Int -> Int -> V.Vector Natural -> Int\ncountRank n m = (\\(acc,_,_) -> acc) .\n                  until (\\(!acc,!j,!vec) -> j < 0) go\n                  . (0,m-1,) . V.filter (/=0)\n  where\n    go (!acc,!j,!vec) = case V.find (`testBit` j) vec of\n      Nothing -> (acc, j-1, vec)\n      Just row ->\n        (acc+1, j-1,\n         V.filter (/=0)\n          $ V.map (\\ !row1 -> if testBit row1 j then xor row1 row else row1)\n          $ vec)\n              \n            \n  \n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y + if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32) $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\nimport Data.Bits\nimport Data.List\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport Control.Monad\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.Applicative\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Control.Monad.State.Strict\nimport Data.Int\nimport Data.Word\nimport System.IO\nimport Data.Function\nimport Control.Monad.Primitive\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.STRef\nimport Data.IORef\nimport Control.DeepSeq\n\nmain :: IO ()\nmain = do\n  [n,m] <- map readInt . words <$> getLine\n  a <- V.unfoldrN n (runStateT\n                      $ foldM\n                         (\\ !acc _ -> (shiftL acc 1 +) . toInteger <$> rInt)\n                         0 [1..m]) <$> BSL.getContents\n  let rank = countRank n m a\n  print $ fromMon $ 2^(n+m-1) - 2^(n+m-rank-1)\n      \n\n{-# INLINE countRank #-}\ncountRank :: Int -> Int -> V.Vector Integer -> Int\ncountRank n m = fst . until (V.null . snd) go . (0,)\n  where\n    go (!acc,!vec) = case V.find (`testBit` 0) vec of\n      Nothing -> (acc, V.filter (/=0) $ V.map (`shiftR` 1) vec)\n      Just row ->\n        (acc+1, V.filter (/=0)\n                $ V.map (\\ !row1 -> (`shiftR` 1) $ xor row1\n                              $ if testBit row1 0 then row else 0)\n                $ vec)\n              \n            \n  \n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y + if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32) $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\nimport Data.Bits\nimport Data.List\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport Control.Monad\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.Applicative\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Control.Monad.State.Strict\nimport Data.Int\nimport Data.Word\nimport System.IO\nimport Data.Function\nimport Control.Monad.Primitive\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.STRef\nimport Data.IORef\nimport Control.DeepSeq\n\nmain :: IO ()\nmain = do\n  [n,m] <- map readInt . words <$> getLine\n  a <- V.unfoldrN n (runStateT\n                      $ foldM\n                         (\\ !acc _ -> (shiftL acc 1 +) . toInteger <$> rInt)\n                         0 [1..m]) <$> BSL.getContents\n  let rank = countRank n m a\n  print $ fromMon $ 2^(n+m-1) - 2^(n+m-rank-1)\n      \n\n{-# INLINE countRank #-}\ncountRank :: Int -> Int -> V.Vector Integer -> Int\ncountRank n m = fst . until (V.null . snd) go . (0,)\n  where\n    go (!acc,!vec) = case V.find (`testBit` 0) vec of\n      Nothing -> (acc, V.filter (/=0) $ V.map (`shiftR` 1) vec)\n      Just row ->\n        (acc+1, V.filter (/=0)\n                $ V.map (\\ !row1 -> (`shiftR` 1) $\n                              if testBit row1 0 then xor row1 row else row1)\n                $ vec)\n              \n            \n  \n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y + if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32) $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\nimport Data.Bits\nimport Data.List\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport Control.Monad\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.Applicative\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Control.Monad.State.Strict\nimport Data.Int\nimport Data.Word\nimport System.IO\nimport Data.Function\nimport Control.Monad.Primitive\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.STRef\nimport Data.IORef\nimport Control.DeepSeq\n\nmain :: IO ()\nmain = do\n  [n,m] <- map readInt . words <$> getLine\n  a <- V.unfoldrN n (runStateT\n                      $ foldM\n                         (\\ !acc _ -> (shiftL acc 1 .|.) . toInteger <$> rInt)\n                         0 [1..m]) <$> BSL.getContents\n  let rank = countRank n m a\n  print $ fromMon $ 2^(n+m-1) - 2^(n+m-rank-1)\n      \n\n{-# INLINE countRank #-}\ncountRank :: Int -> Int -> V.Vector Integer -> Int\ncountRank n m = (\\(acc,_,_) -> acc) .\n                  until (\\(!acc,!j,!vec) -> j < 0) go\n                  . (0,m-1,) . V.filter (/=0)\n  where\n    go (!acc,!j,!vec) = case V.find (`testBit` j) vec of\n      Nothing -> (acc, j-1, vec)\n      Just row ->\n        (acc+1, j-1,\n         V.filter (/=0)\n          $ V.map (\\ !row1 -> if testBit row1 j then xor row1 row else row1)\n          $ vec)\n              \n            \n  \n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y + if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32) $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\nimport Data.Bits\nimport Data.List\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport Control.Monad\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.Applicative\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Control.Monad.State.Strict\nimport Data.Int\nimport Data.Word\nimport System.IO\nimport Data.Function\nimport Control.Monad.Primitive\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.STRef\nimport Data.IORef\nimport Control.DeepSeq\n\nmain :: IO ()\nmain = do\n  [n,m] <- map readInt . words <$> getLine\n  a <- V.unfoldrN n (runStateT\n                      $ foldM\n                         (\\ !acc _ -> (shiftL acc 1 +) . toInteger <$> rInt)\n                         0 [1..m]) <$> BSL.getContents\n  let rank = countRank n m a\n  print $ fromMon $ 2^(n+m-1) - 2^(n+m-rank-1)\n      \n\n{-# INLINE countRank #-}\ncountRank :: Int -> Int -> V.Vector Integer -> Int\ncountRank n m = (\\(acc,_,_) -> acc) .\n                  until (\\(!acc,!j,!vec) -> j < 0) go\n                  . (0,m-1,) . V.filter (/=0)\n  where\n    go (!acc,!j,!vec) = case V.find (`testBit` j) vec of\n      Nothing -> (acc, j-1, vec)\n      Just row ->\n        (acc+1, j-1,\n         V.filter (/=0)\n          $ V.map (\\ !row1 -> xor row1 $ if testBit row1 j then row else 0)\n          $ vec)\n              \n            \n  \n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y + if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32) $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\nimport Data.Bits\nimport Data.List\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport Control.Monad\nimport Control.Monad.ST\n-- import Control.Monad.ST.Safe\nimport Control.Applicative\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Control.Monad.State.Strict\nimport Data.Int\nimport Data.Word\nimport System.IO\nimport Data.Function\nimport Control.Monad.Primitive\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport Data.STRef\nimport Data.IORef\n\nmain :: IO ()\nmain = do\n  [n,m] <- map readInt . words <$> getLine\n  a_ <-  map (==1) . unfoldr (runStateT $ rInt) <$> BSL.getContents\n  let rank = countRank n m a_\n  print $ fromMon $ 2^(n+m-1) - 2^(n+m-rank-1)\n      \n\n{-# INLINE countRank #-}\ncountRank :: Int -> Int -> [Bool] -> Int\ncountRank n m a_ = runST $ do\n  a <- A.newListArray ((0,0),(n-1,m-1)) a_ :: ST s (STUArray s (Int,Int) Bool)\n  check <- newSTUA (0,n-1) True\n  foldM (\\ !acc j -> do\n            colj <- forM [0..n-1] $ \\i ->\n              (&&) <$> A.readArray a (i,j) <*> A.readArray check i\n            case findIndex id colj of\n              Nothing -> return acc\n              Just i -> do\n                A.writeArray check i False \n                forM_ [0..n-1] $ \\i1 ->\n                  when (i /= i1) $ do\n                  ai1j <- A.readArray a (i1,j)\n                  when ai1j $ do\n                    forM_ [j..m-1] $ \\j1 -> do\n                      A.writeArray a (i1,j1) =<<\n                        xor <$> A.readArray a (i1,j1) <*> A.readArray a (i,j1)\n                return $! acc+1 \n                 ) 0 [0..m-1]\n              \n            \n  \n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y + if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32) $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 998244353\n//#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nll n,m;\nll a[310][310];\nll b[310][310];\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(n<m){\n\t\trep(i,0,n)rep(j,0,m)scanf(\"%lld\",&a[j][i]);\n\t\tll t=n;n=m;m=t;\n\t}else{\n\t\trep(i,0,n)rep(j,0,m)scanf(\"%lld\",&a[i][j]);\n\t}\n\tll r=0;\n\trep(j,0,m){\n\t\tll t=-1;\n\t\trep(i,0,n)if(a[i][j]){\n\t\t\tt=i;\n\t\t\tbreak;\n\t\t}\n\t\tif(t!=-1){\n\t\t\tr++;\n\t\t\trep(i,0,n)if(i==t)rep(k,0,m)a[i][k]^=a[t][k];\n\t\t}\n\t}\n\tll ans=pom(2,r-1,MOD)*(pom(2,r,MOD)-1+MOD)%MOD*pom(2,n-r,MOD)%MOD*pom(2,m-r,MOD)%MOD;\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null dp[500][500];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tull rank = 0;\n\tfor (rank = 0; rank < n && rank < m; rank++) {\n\t\tfor (i = rank; i < n; i++) {\n\t\t\tfor (j = rank; j < m; j++) {\n\t\t\t\tif (table[i][j]) break;\n\t\t\t}\n\t\t\tif (j < m) break;\n\t\t}\n\t\tif (i == n) break;\n\n\t\tif (j > rank) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\ttable[ki][rank] ^= table[ki][j];\n\t\t\t\ttable[ki][j] ^= table[ki][rank];\n\t\t\t\ttable[ki][rank] ^= table[ki][j];\n\t\t\t}\n\t\t}\n\t\tif (i > rank) {\n\t\t\tfor (li = rank; li < m; li++) {\n\t\t\t\ttable[rank][li] ^= table[i][li];\n\t\t\t\ttable[i][li] ^= table[rank][li];\n\t\t\t\ttable[rank][li] ^= table[i][li];\n\t\t\t}\n\t\t}\n\t\tfor (ki = rank + 1; ki < n; ki++) {\n\t\t\tif (!table[ki][rank]) continue;\n\t\t\tfor (li = rank; li < m; li++) {\n\t\t\t\ttable[ki][li] ^= table[rank][li];\n\t\t\t}\n\t\t}\n\t\t// for (li = rank + 1; li < m; li++) {\n\t\t// \tfor (ki = rank; ki < n; ki++) {\n\t\t// \t\ttable[ki][li] ^= table[ki][rank];\n\t\t// \t}\n\t\t// }\n\t}\n\t// printf(\"rank; %llu\\n\", rank);\n\n\tif (rank == 0) {\n\t\tresult = 0;\n\t} else {\n\t\t// dp[0][0] = 1;\n\t\t// for (i = 0; i < rank; i++) {\n\t\t// \tfor (j = 0; j < 2; j++) {\n\t\t// \t\tdp[i + 1][j] = (dp[i][j] * 3 + dp[i][j ^ 1]) % FOD;\n\t\t// \t}\n\t\t// }\n\t\t// result = dp[rank][1] * bitpow(2, m + n - rank * 2, FOD) % FOD;\n\t\tresult = (FOD + bitpow(2, n, FOD) - bitpow(2, n - rank, FOD)) * bitpow(2, m - 1, FOD) % FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tscanf(\"%lld\", &table[i][j]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 998244353\n//#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nll n,m;\nll a[310][310];\nll b[310][310];\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(n<m){\n\t\trep(i,0,n)rep(j,0,m)scanf(\"%lld\",&a[j][i]);\n\t\tll t=n;n=m;m=t;\n\t}else{\n\t\trep(i,0,n)rep(j,0,m)scanf(\"%lld\",&a[i][j]);\n\t}\n\n\tll r=0;\n\trep(j,0,m){\n\t\tll t=-1;\n\t\trep(i,0,n)if(a[i][j]){\n\t\t\tt=i;\n\t\t\tbreak;\n\t\t}\n\t\tif(t!=-1){\n//\t\t\tprintf(\"%lld %lld\\n\",j,t);\n\t\t\tr++;\n\t\t\trep(i,0,n)if(i!=t)if(a[i][j])rep(k,0,m)a[i][k]^=a[t][k];\n\t\t}\n\t}\n//\trep(i,0,n){rep(j,0,m)printf(\"%lld\",a[i][j]);puts(\"\");}\n\tll ans=pom(2,r-1,MOD)*(pom(2,r,MOD)-1+MOD)%MOD*pom(2,n-r,MOD)%MOD*pom(2,m-r,MOD)%MOD;\n//\tprintf(\"%lld \",r);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null dp[500][500];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tull rank = 0;\n\tfor (rank = 0; rank < n && rank < m; rank++) {\n\t\tfor (i = rank; i < n; i++) {\n\t\t\tfor (j = rank; j < m; j++) {\n\t\t\t\tif (table[i][j]) break;\n\t\t\t}\n\t\t\tif (j < m) break;\n\t\t}\n\t\tif (i == n) break;\n\n\t\tif (j > rank) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\ttable[ki][rank] ^= table[ki][j];\n\t\t\t}\n\t\t}\n\t\tif (i > rank) {\n\t\t\tfor (li = rank; li < m; li++) {\n\t\t\t\ttable[rank][li] ^= table[i][li];\n\t\t\t}\n\t\t}\n\t\tfor (ki = rank + 1; ki < n; ki++) {\n\t\t\tfor (li = rank; li < m; li++) {\n\t\t\t\ttable[ki][li] ^= table[rank][li];\n\t\t\t}\n\t\t}\n\t\tfor (li = rank + 1; li < m; li++) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\ttable[ki][li] ^= table[ki][rank];\n\t\t\t}\n\t\t}\n\t}\n\t// printf(\"rank; %llu\\n\", rank);\n\n\tif (rank == 0) {\n\t\tresult = 0;\n\t} else {\n\t\t// dp[0][0] = 1;\n\t\t// for (i = 0; i < rank; i++) {\n\t\t// \tfor (j = 0; j < 2; j++) {\n\t\t// \t\tdp[i + 1][j] = (dp[i][j] * 3 + dp[i][j ^ 1]) % FOD;\n\t\t// \t}\n\t\t// }\n\t\t// result = dp[rank][1] * bitpow(2, m + n - rank * 2, FOD) % FOD;\n\t\tresult = (FOD + bitpow(2, n, FOD) - bitpow(2, n - rank, FOD)) * bitpow(2, m - 1, FOD) % FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tscanf(\"%lld\", &table[i][j]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 998244353\n//#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nll n,m;\nll a[310][310];\nll b[310][310];\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(n<m){\n\t\trep(i,0,n)rep(j,0,m)scanf(\"%lld\",&a[j][i]);\n\t\tll t=n;n=m;m=t;\n\t}else{\n\t\trep(i,0,n)rep(j,0,m)scanf(\"%lld\",&a[i][j]);\n\t}\n\n\tll r=0;\n\trep(j,0,m){\n\t\tll t=-1;\n\t\trep(i,r,n)if(a[i][j]){\n\t\t\tt=i;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(t!=-1){\n//\t\t\tprintf(\"%lld %lld\\n\",j,t);\n\t\t\trep(i,0,n)if(i!=t)if(a[i][j])rep(k,0,m)a[i][k]^=a[t][k];\n\t\t\trep(k,0,m){ll temp=a[r][k];a[r][k]=a[t][k];a[t][k]=temp;}\n\t\t\tr++;\n\t\t}\n\t}\n//\trep(i,0,n){rep(j,0,m)printf(\"%lld\",a[i][j]);puts(\"\");}\n\tll ans=pom(2,r-1,MOD)*(pom(2,r,MOD)-1+MOD)%MOD*pom(2,n-r,MOD)%MOD*pom(2,m-r,MOD)%MOD;\n//\tprintf(\"%lld \",r);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null dp[500][500];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tull rank = 0;\n\tfor (rank = 0; rank < n && rank < m; rank++) {\n\t\tfor (i = rank; i < n; i++) {\n\t\t\tfor (j = rank; j < m; j++) {\n\t\t\t\tif (table[i][j]) break;\n\t\t\t}\n\t\t\tif (j < m) break;\n\t\t}\n\t\tif (i == n) break;\n\n\t\tif (j > rank) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\ttable[ki][rank] ^= table[ki][j];\n\t\t\t\ttable[ki][j] ^= table[ki][rank];\n\t\t\t\ttable[ki][rank] ^= table[ki][j];\n\t\t\t}\n\t\t}\n\t\tif (i > rank) {\n\t\t\tfor (li = rank; li < m; li++) {\n\t\t\t\ttable[rank][li] ^= table[i][li];\n\t\t\t\ttable[i][li] ^= table[rank][li];\n\t\t\t\ttable[rank][li] ^= table[i][li];\n\t\t\t}\n\t\t}\n\t\tfor (ki = rank + 1; ki < n; ki++) {\n\t\t\tfor (li = rank; li < m; li++) {\n\t\t\t\ttable[ki][li] ^= table[rank][li];\n\t\t\t}\n\t\t}\n\t\t// for (li = rank + 1; li < m; li++) {\n\t\t// \tfor (ki = rank; ki < n; ki++) {\n\t\t// \t\ttable[ki][li] ^= table[ki][rank];\n\t\t// \t}\n\t\t// }\n\t}\n\t// printf(\"rank; %llu\\n\", rank);\n\n\tif (rank == 0) {\n\t\tresult = 0;\n\t} else {\n\t\t// dp[0][0] = 1;\n\t\t// for (i = 0; i < rank; i++) {\n\t\t// \tfor (j = 0; j < 2; j++) {\n\t\t// \t\tdp[i + 1][j] = (dp[i][j] * 3 + dp[i][j ^ 1]) % FOD;\n\t\t// \t}\n\t\t// }\n\t\t// result = dp[rank][1] * bitpow(2, m + n - rank * 2, FOD) % FOD;\n\t\tresult = (FOD + bitpow(2, n, FOD) - bitpow(2, n - rank, FOD)) * bitpow(2, m - 1, FOD) % FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tscanf(\"%lld\", &table[i][j]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 998244353\n//#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nll n,m;\nll a[310][310];\nll b[310][310];\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\trep(i,0,n)rep(j,0,m)scanf(\"%lld\",&a[j][i]);\n\n\tll r=0;\n\trep(j,0,m){\n\t\tll t=-1;\n\t\trep(i,0,n)if(a[i][j]){\n\t\t\tt=i;\n\t\t\tbreak;\n\t\t}\n\t\tif(t!=-1){\n\t\t\tr++;\n\t\t\trep(i,0,n)if(i!=t)rep(k,0,m)a[i][k]^=a[t][k];\n\t\t}\n\t}\n\tll ans=pom(2,r-1,MOD)*(pom(2,r,MOD)-1+MOD)%MOD*pom(2,n-r,MOD)%MOD*pom(2,m-r,MOD)%MOD;\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 998244353\n//#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nll n,m;\nll a[310][310];\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\trep(i,0,n)rep(j,0,m)scanf(\"%lld\",&a[i][j]);\n\t\n\tll r=0;\n\trep(j,0,m){\n\t\tll t=-1;\n\t\trep(i,0,n)if(a[i][j]){\n\t\t\tt=i;\n\t\t\tbreak;\n\t\t}\n\t\tif(t!=-1){\n\t\t\tr++;\n\t\t\trep(i,0,n)if(i==t)rep(k,0,m)a[i][k]^=a[t][k];\n\t\t}\n\t}\n\tll ans=pom(2,r-1,MOD)*(pom(2,r,MOD)-1+MOD)%MOD*pom(2,n-r,MOD)%MOD*pom(2,m-r,MOD)%MOD;\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p 998244353\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nint rank(int N, int M, int **a){\n\tint i, j, k, l;\n\tint **sub = (int **)malloc(sizeof(int *) * N);\n\tfor(i = 0; i < N; i++){\n\t\tsub[i] = (int *)malloc(sizeof(int) * M);\n\t\tfor(j = 0; j < M; j++){\n\t\t\tsub[i][j] = a[i][j];\n\t\t}\n\t}\n\tfor(i = 0, j = 0; i < N && j < M; i++, j++){\n//\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\tfor(k = i; k < N; k++){\n\t\t\tif(sub[k][j] == 1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(k == N){\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tint *tmp = sub[i];\n\t\tsub[i] = sub[k];\n\t\tsub[k] = tmp;\n\t\tfor(k = 0; k < N; k++){\n\t\t\tif(i != k && sub[k][j] == 1){\n\t\t\t\tfor(l = j; l < M; l++){\n\t\t\t\t\tsub[k][l] ^= sub[i][l];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn i;\n}\n\nsigned main(){\n\tint N, M, i, j;\n\tscanf(\"%lld%lld\", &N, &M);\n\tint **a = (int **)malloc(sizeof(int *) * N);\n\tfor(i = 0; i < N; i++){\n\t\ta[i] = (int *)malloc(sizeof(int) * N);\n\t\tfor(j = 0; j < M; j++){\n\t\t\tscanf(\"%lld\", &a[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", MOD((power(2, N) - power(2, N - rank(N, M, a))) * power(2, M - 1)));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null dp[500][500];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tull rank = 0;\n\tfor (rank = 0; rank < n && rank < m; rank++) {\n\t\tfor (i = rank; i < n; i++) {\n\t\t\tfor (j = rank; j < m; j++) {\n\t\t\t\tif (table[i][j]) break;\n\t\t\t}\n\t\t\tif (j < m) break;\n\t\t}\n\t\tif (i == n) break;\n\n\t\tif (j > rank) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\ttable[ki][rank] ^= table[ki][j];\n\t\t\t}\n\t\t}\n\t\tif (i > rank) {\n\t\t\tfor (li = rank; li < m; li++) {\n\t\t\t\ttable[rank][li] ^= table[i][li];\n\t\t\t}\n\t\t}\n\t\tfor (ki = rank + 1; ki < n; ki++) {\n\t\t\tfor (li = rank; li < m; li++) {\n\t\t\t\ttable[ki][li] ^= table[rank][li];\n\t\t\t}\n\t\t}\n\t\tfor (li = rank + 1; li < m; li++) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\ttable[ki][li] ^= table[ki][rank];\n\t\t\t}\n\t\t}\n\t}\n\t// printf(\"rank; %llu\\n\", rank);\n\n\tif (rank == 0) {\n\t\tresult = 0;\n\t} else {\n\t\tdp[0][0] = 1;\n\t\tfor (i = 0; i < rank; i++) {\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tdp[i + 1][j] = (dp[i][j] * 3 + dp[i][j ^ 1]) % FOD;\n\t\t\t}\n\t\t}\n\t\tresult = dp[rank][1] * bitpow(2, m + n - rank * 2, FOD) % FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tscanf(\"%lld\", &table[i][j]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p 998244353\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nint rank(int N, int M, int **a){\n\tint i, j, k, l;\n\tint **sub = (int **)malloc(sizeof(int *) * N);\n\tfor(i = 0; i < N; i++){\n\t\tsub[i] = (int *)malloc(sizeof(int) * M);\n\t\tfor(j = 0; j < M; j++){\n\t\t\tsub[i][j] = a[i][j];\n\t\t}\n\t}\n\tfor(i = 0, j = 0; i < N && j < M; i++, j++){\n//\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\tfor(k = i; k < N; k++){\n\t\t\tif(sub[k][j] == 1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"k = %lld\\n\", k);\n\t\tif(k == N){\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tint *tmp = sub[i];\n\t\tsub[i] = sub[k];\n\t\tsub[k] = tmp;\n\t\tfor(k = 0; k < N; k++){\n\t\t\tif(i != k && sub[k][j] == 1){\n\t\t\t\tfor(l = j; l < M; l++){\n\t\t\t\t\tsub[k][l] ^= sub[i][l];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tprintf(\"sub:\\n\");\n\t\tfor(k = 0; k < N; k++){\n\t\t\tfor(l = 0; l < M; l++){\n\t\t\t\tprintf(\"%lld \", sub[k][l]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n*/\t}\n/*\tprintf(\"sub:\\n\");\n\tfor(k = 0; k < N; k++){\n\t\tfor(l = 0; l < M; l++){\n\t\t\tprintf(\"%lld \", sub[k][l]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\treturn i;\n}\n\nsigned main(){\n\tint N, M, i, j;\n\tscanf(\"%lld%lld\", &N, &M);\n\tint **a = (int **)malloc(sizeof(int *) * N);\n\tfor(i = 0; i < N; i++){\n\t\ta[i] = (int *)malloc(sizeof(int) * M);\n\t\tfor(j = 0; j < M; j++){\n\t\t\tscanf(\"%lld\", &a[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", MOD((power(2, N) - power(2, N - rank(N, M, a))) * power(2, M - 1)));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 998244353\n//#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nll n,m;\nll a[310][310];\nll b[310][310];\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(n<m){\n\t\trep(i,0,n)rep(j,0,m)scanf(\"%lld\",&a[j][i]);\n\t}else{\n\t\trep(i,0,n)rep(j,0,m)scanf(\"%lld\",&a[i][j]);\n\t}\n\tll r=0;\n\trep(j,0,m){\n\t\tll t=-1;\n\t\trep(i,0,n)if(a[i][j]){\n\t\t\tt=i;\n\t\t\tbreak;\n\t\t}\n\t\tif(t!=-1){\n\t\t\tr++;\n\t\t\trep(i,0,n)if(i==t)rep(k,0,m)a[i][k]^=a[t][k];\n\t\t}\n\t}\n\tll ans=pom(2,r-1,MOD)*(pom(2,r,MOD)-1+MOD)%MOD*pom(2,n-r,MOD)%MOD*pom(2,m-r,MOD)%MOD;\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "Julia",
    "code": "function reader(pos::Int)\n    global membuff\n    val = 0\n    sign = 1\n    @inbounds r = membuff[pos]\n    pos += 1\n    while r < 0x30 || 0x39 < r\n        sign = r == '-' ? -1 : sign\n        @inbounds r = membuff[pos]\n        pos += 1\n    end\n    while 0x30 <= r <= 0x39\n        val = val * 10 + r - 0x30 \n        @inbounds r = membuff[pos]\n        pos += 1\n    end\n    return val*sign, pos\nend\n\nconst io = VERSION > v\"1.0\" ? stdin : STDIN\nconst membuff = read(io,1145141919)\n\n#using LinearAlgebra: rank # 1.0 なら必要\nfunction main()\n    pos = 1\n    N, pos = reader(pos)\n    M, pos = reader(pos)\n    a = zeros(Int,(N,M))\n    for j=1:M,i=1:N # j が先に回る\n        a[i,j], pos = reader(pos)\n    end\n    r = rank(a)\n    mod = 998244353\n    ans = powermod(2, N+M-1, mod) - powermod(2, N+M-r-1, mod)\n    println( (ans+mod) % mod )\nend\n\nmain()"
  },
  {
    "language": "Julia",
    "code": "function reader(pos::Int)\n    global membuff\n    val = 0\n    sign = 1\n    @inbounds r = membuff[pos]\n    pos += 1\n    while r < 0x30 || 0x39 < r\n        sign = r == '-' ? -1 : sign\n        @inbounds r = membuff[pos]\n        pos += 1\n    end\n    while 0x30 <= r <= 0x39\n        val = val * 10 + r - 0x30 \n        @inbounds r = membuff[pos]\n        pos += 1\n    end\n    return val*sign, pos\nend\n\nconst io = VERSION > v\"1.0\" ? stdin : STDIN\nconst membuff = read(io,1145141919)\n\n#using LinearAlgebra: rank\nfunction main()\n    pos = 1\n    N, pos = reader(pos)\n    M, pos = reader(pos)\n    a = zeros(Int,(M,N))\n    for i=1:N, j=1:M\n        @inbounds a[j,i], pos = reader(pos)\n    end\n    r = rank(a)\n    mod = 998244353\n    ans = powermod(2, N+M-1, mod) - powermod(2, N+M-r-1, mod)\n    println( ans < 0 ? ans + mod : ans )\nend\n\nmain()"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.BitSet;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.util.Comparator;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        static final int mod = 998244353;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            BitSet[] bitset = new BitSet[n];\n            for (int y = 0; y < n; y++) {\n                bitset[y] = new BitSet();\n                for (int x = 0; x < m; x++) {\n                    if (in.nextInt() == 1) {\n                        bitset[y].set(x);\n                    }\n                }\n            }\n            Arrays.sort(bitset, Comparator.comparing(BitSet::cardinality).reversed());\n            int rank = 0;\n            for (int y = 0, x = 0; y < n && x < m; x++) {\n                for (int i = y; i < n; i++) {\n                    if (bitset[i].get(x)) {\n                        swap(bitset, i, y);\n                        break;\n                    }\n                }\n                if (bitset[y].get(x)) {\n                    for (int i = y + 1; i < n; i++) {\n                        bitset[i].xor(bitset[y]);\n                    }\n                    rank++;\n                    y++;\n                }\n            }\n\n            out.println(((pow(2, n) - pow(2, n - rank)) * pow(2, m - 1) % mod + mod) % mod);\n        }\n\n        long pow(int n, int r) {\n            long ans = 1;\n            for (int i = 0; i < r; i++) ans = ans * n % mod;\n            return ans;\n        }\n\n        static <T> void swap(T[] xs, int i, int j) {\n            T t = xs[i];\n            xs[i] = xs[j];\n            xs[j] = t;\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n\n\n  private static void solve() {\n     int n = ni();\n     int m = ni();\n     // int[][] mat = ntable(n, m);\n     int[][] mat = new int[n][m];\n     for (int i = 0; i < n; i++) {\n     for (int j = 0; j < m; j++) {\n     mat[i][j] = 1;\n     }\n     }\n     System.out.println(solve(mat));\n  }\n\n\n  private static long solve(int[][] mat) {\n\n    int n = mat.length;\n    int m = mat[0].length;\n\n    int rank = rank(mat, 2);\n\n    int mod = 998244353;\n    long[] p2 = new long[1000];\n    p2[0] = 1;\n    for (int i = 0; i < p2.length - 1; i++) {\n      p2[i + 1] = p2[i] * 2 % mod;\n    }\n\n    int[][] fif = enumFIF(1000, mod);\n\n    long ret = 0;\n    for (int i = 1; i <= rank; i ++) {\n      long now = 0;\n      for (int j = 1; j <= i; j += 2) {\n        now += CX(rank, i, mod, fif) * CX(i, j, mod, fif) % mod;\n        now %= mod;\n      }\n      ret += now * p2[m - i] % mod * p2[n - rank] % mod ;\n      ret %= mod;\n    }\n    return ret;\n  }\n\n  public static long CX(long n, long r, int p, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    int np = (int) (n % p), rp = (int) (r % p);\n    if (np < rp)\n      return 0;\n    if (n == 0 && r == 0)\n      return 1;\n    int nrp = np - rp;\n    if (nrp < 0)\n      nrp += p;\n    return (long) fif[0][np] * fif[1][rp] % p * fif[1][nrp] % p * CX(n / p, r / p, p, fif) % p;\n  }\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static int rank(int[][] M, int p) {\n    if (M.length == 0)\n      return 0;\n    int n = M.length, m = M[0].length;\n\n    // Forward Elimination\n    for (int i = 0; i < n; i++) {\n      // select pivot\n      boolean pivotFound = false;\n      out: for (int pi = i; pi < n; pi++) {\n        for (int pj = i; pj < m; pj++) {\n          if (M[pi][pj] != 0) {\n            // pivot found\n            if (pj != i) {\n              // swap columns\n              for (int k = 0; k < n; k++) {\n                int d = M[k][pj];\n                M[k][pj] = M[k][i];\n                M[k][i] = d;\n              }\n            }\n            if (pi != i) {\n              // swap rows\n              int[] d = M[pi];\n              M[pi] = M[i];\n              M[i] = d;\n            }\n            pivotFound = true;\n            break out;\n          }\n        }\n      }\n      if (!pivotFound)\n        return i;\n\n      long ID = invl(M[i][i], p);\n      M[i][i] = 1;\n      for (int j = i + 1; j < m; j++) {\n        M[i][j] = (int) (M[i][j] * ID % p);\n      }\n\n      for (int j = i + 1; j < n; j++) {\n        long B = p - M[j][i];\n        M[j][i] = 0;\n        for (int k = i + 1; k < m; k++) {\n          M[j][k] = (int) ((M[j][k] + M[i][k] * B) % p);\n        }\n      }\n    }\n    return n;\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        int mod = 998244353;\n\n        long pow(long a, long p, int mod) {\n            if (p == 0) {\n                return 1;\n            }\n\n            long t = pow(a, p / 2, mod);\n\n            if (p % 2 != 0) {\n                return (((t * t) % mod) * a) % mod;\n            } else {\n                return (t * t) % mod;\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[][] a = new int[n][m];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = in.nextInt();\n                }\n            }\n\n            MatrixRank rank = new MatrixRank();\n\n            int r = rank.matrixRankFF2(a);\n\n            long ans = pow(2, n + m - 1, mod);\n            ans -= pow(2, n + m - r - 1, mod);\n\n            ans %= mod;\n\n            if (ans < 0) {\n                ans += mod;\n            }\n\n            out.println(ans);\n        }\n\n        class MatrixRank {\n            int matrixRankFF2(int[][] a) {\n                int n = a.length;\n                int m = a[0].length;\n\n                int rank = 0;\n\n                boolean[] done = new boolean[n];\n\n                for (int i = 0; i < m; i++) {\n                    int ind = -1;\n                    for (int j = 0; j < n; j++) {\n                        if (a[j][i] == 1 && !done[j]) {\n                            ind = j;\n                            break;\n                        }\n                    }\n\n                    if (ind == -1)\n                        continue;\n\n                    done[ind] = true;\n                    rank++;\n\n                    for (int j = ind + 1; j < n; j++) {\n                        if (a[j][i] == 1) {\n                            for (int k = i; k < m; k++) {\n                                a[j][k] ^= a[ind][k];\n                            }\n                        }\n                    }\n                }\n\n                return rank;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        int mod = 998244353;\n\n        long pow(long a, long p, int mod) {\n            if (p == 0) {\n                return 1;\n            }\n\n            long t = pow(a, p / 2, mod);\n\n            if (p % 2 != 0) {\n                return (((t * t) % mod) * a) % mod;\n            } else {\n                return (t * t) % mod;\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[][] a = new int[n][m];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = in.nextInt();\n                }\n            }\n\n            MatrixRank rank = new MatrixRank();\n\n            int r = rank.matrixRankFF2(a);\n\n            long ans = pow(2, n + m - 1, mod);\n            ans -= pow(2, n + m - r - 1, mod);\n\n            ans %= mod;\n\n            if (ans < 0) {\n                ans += mod;\n            }\n\n            out.println(ans);\n        }\n\n        class MatrixRank {\n            int matrixRankFF2(int[][] a) {\n                int n = a.length;\n                int m = a[0].length;\n\n                Arrays.sort(a, (row1, row2) ->\n                {\n                    for (int i = 0; i < m; i++) {\n                        if (row1[i] > row2[i]) {\n                            return -1;\n                        } else if (row1[i] < row2[i]) {\n                            return 1;\n                        }\n                    }\n                    return 0;\n                });\n\n                int rank = 0;\n\n                for (int i = 0; i < n; i++) {\n                    int fsi = -1;\n                    for (int j = 0; j < m; j++) {\n                        if (a[i][j] == 1) {\n                            fsi = j;\n                            break;\n                        }\n                    }\n\n                    if (fsi == -1) {\n                        return rank;\n                    }\n\n                    rank++;\n\n                    for (int j = i + 1; j < n; j++) {\n                        if (a[j][fsi] == 1) {\n                            for (int k = fsi; k < m; k++) {\n                                a[j][k] = a[j][k] ^ a[i][k];\n                            }\n                        }\n                    }\n\n                    Arrays.sort(a, (row1, row2) ->\n                    {\n                        for (int j = 0; j < m; j++) {\n                            if (row1[j] > row2[j]) {\n                                return -1;\n                            } else if (row1[j] < row2[j]) {\n                                return 1;\n                            }\n                        }\n                        return 0;\n                    });\n                }\n\n                return rank;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.BitSet;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            int[][] a = in.readIntTable(n, m);\n\n            BitSet[] data = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                data[i] = new BitSet();\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    if (a[i][j] == 1) data[i].set(j);\n                }\n            }\n\n            int idx = 0;\n            for (int i = m - 1; i >= 0; i--) {\n                Arrays.sort(data, Comparator.comparing(BitSet::length).reversed());\n                if (!data[idx].get(i)) continue;\n\n                for (int j = 0; j < n; j++) {\n                    if (j != idx && data[j].get(i)) data[j].xor(data[idx]);\n                }\n\n                idx++;\n            }\n\n            int rank = 0;\n            for (int i = 0; i < n; i++) {\n                if (!data[i].isEmpty()) rank++;\n            }\n\n            Modulo modulo = new Modulo(998244353);\n            long tmp1 = modulo.pow(2, n);\n            long tmp2 = modulo.pow(2, n - rank);\n            long tmp3 = modulo.pow(2, m - 1);\n\n            out.printLine(modulo.mlt(modulo.sub(tmp1, tmp2), tmp3));\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class Modulo {\n        long m;\n\n        public Modulo(long m) {\n            this.m = m;\n        }\n\n        public long sub(long a, long b) {\n            return (a - b + m) % m;\n        }\n\n        public long mlt(long a, long b) {\n            return (a * b) % m;\n        }\n\n        public long pow(long a, long x) {\n            long ans = 1 % m;\n            while (x > 0) {\n                if ((x & 1) != 0) {\n                    ans = (ans * a) % m;\n                }\n                x >>= 1;\n                a = (a * a) % m;\n            }\n            return ans;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[][] readIntTable(int rowCount, int columnCount) {\n            int[][] table = new int[rowCount][];\n            for (int i = 0; i < rowCount; i++) {\n                table[i] = readIntArray(columnCount);\n            }\n            return table;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n\n    int mod = 998244353;\n    int[][] p = ntable(n, m);\n\n    int rank = rank(p, 2);\n\n    int[][] fif = enumFIF(n + m, mod);\n\n    long ret = 0;\n    for (int i = 1; i <= rank; i += 2) {\n      ret += C(rank, i, mod, fif) * pow(2, n - rank, mod) % mod * pow(2, m - i, mod) % mod;\n      ret += C(rank, i, mod, fif) * pow(2, m - rank, mod) % mod * pow(2, n - i, mod) % mod;\n      ret += mod - C(rank, i, mod, fif) * pow(2, (n - rank) + (m - rank), mod);\n      ret %= mod;\n    }\n    System.out.println(ret);\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n  }\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n\n  public static long pow(long a, long n, long mod) {\n    // a %= mod;\n    long ret = 1;\n    int x = 63 - Long.numberOfLeadingZeros(n);\n    for (; x >= 0; x--) {\n      ret = ret * ret % mod;\n      if (n << 63 - x < 0)\n        ret = ret * a % mod;\n    }\n    return ret;\n  }\n\n\n  public static int rank(int[][] M, int p) {\n    if (M.length == 0)\n      return 0;\n    int n = M.length, m = M[0].length;\n\n    // Forward Elimination\n    for (int i = 0; i < n; i++) {\n      // select pivot\n      boolean pivotFound = false;\n      out: for (int pi = i; pi < n; pi++) {\n        for (int pj = i; pj < m; pj++) {\n          if (M[pi][pj] != 0) {\n            // pivot found\n            if (pj != i) {\n              // swap columns\n              for (int k = 0; k < n; k++) {\n                int d = M[k][pj];\n                M[k][pj] = M[k][i];\n                M[k][i] = d;\n              }\n            }\n            if (pi != i) {\n              // swap rows\n              int[] d = M[pi];\n              M[pi] = M[i];\n              M[i] = d;\n            }\n            pivotFound = true;\n            break out;\n          }\n        }\n      }\n      if (!pivotFound)\n        return i;\n\n      long ID = invl(M[i][i], p);\n      M[i][i] = 1;\n      for (int j = i + 1; j < m; j++) {\n        M[i][j] = (int) (M[i][j] * ID % p);\n      }\n\n      for (int j = i + 1; j < n; j++) {\n        long B = p - M[j][i];\n        M[j][i] = 0;\n        for (int k = i + 1; k < m; k++) {\n          M[j][k] = (int) ((M[j][k] + M[i][k] * B) % p);\n        }\n      }\n    }\n    return n;\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n\n    int mod = 998244353;\n    int[][] p = ntable(n, m);\n\n    int rank = rank(p, 2);\n\n    int[][] fif = enumFIF(n + m, mod);\n\n    long ret = 0;\n    for (int i = 1; i <= rank; i += 2) {\n      ret += C(rank, i, mod, fif) * pow(2, n - rank, mod) % mod * pow(2, m - i, mod) % mod;\n      ret += C(rank, i, mod, fif) * pow(2, m - rank, mod) % mod * pow(2, n - i, mod) % mod;\n      ret += mod - C(rank, i, mod, fif) * pow(2, (n - rank) + (m - rank), mod) % mod;\n      ret %= mod;\n    }\n    System.out.println(ret);\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n  }\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n\n  public static long pow(long a, long n, long mod) {\n    // a %= mod;\n    long ret = 1;\n    int x = 63 - Long.numberOfLeadingZeros(n);\n    for (; x >= 0; x--) {\n      ret = ret * ret % mod;\n      if (n << 63 - x < 0)\n        ret = ret * a % mod;\n    }\n    return ret;\n  }\n\n\n  public static int rank(int[][] M, int p) {\n    if (M.length == 0)\n      return 0;\n    int n = M.length, m = M[0].length;\n\n    // Forward Elimination\n    for (int i = 0; i < n; i++) {\n      // select pivot\n      boolean pivotFound = false;\n      out: for (int pi = i; pi < n; pi++) {\n        for (int pj = i; pj < m; pj++) {\n          if (M[pi][pj] != 0) {\n            // pivot found\n            if (pj != i) {\n              // swap columns\n              for (int k = 0; k < n; k++) {\n                int d = M[k][pj];\n                M[k][pj] = M[k][i];\n                M[k][i] = d;\n              }\n            }\n            if (pi != i) {\n              // swap rows\n              int[] d = M[pi];\n              M[pi] = M[i];\n              M[i] = d;\n            }\n            pivotFound = true;\n            break out;\n          }\n        }\n      }\n      if (!pivotFound)\n        return i;\n\n      long ID = invl(M[i][i], p);\n      M[i][i] = 1;\n      for (int j = i + 1; j < m; j++) {\n        M[i][j] = (int) (M[i][j] * ID % p);\n      }\n\n      for (int j = i + 1; j < n; j++) {\n        long B = p - M[j][i];\n        M[j][i] = 0;\n        for (int k = i + 1; k < m; k++) {\n          M[j][k] = (int) ((M[j][k] + M[i][k] * B) % p);\n        }\n      }\n    }\n    return n;\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n    int[][] mat = ntable(n, m);\n\n    System.out.println(solve(mat));\n\n\n    // Random gen = new Random();\n    // while( true) {\n    // int n = gen.nextInt(5) + 1;\n    // int m = gen.nextInt(5) + 1;\n    // int[][] mat = new int[n][m];\n    // for (int i = 0; i < n; i ++) {\n    // for (int j = 0; j < m; j ++) {\n    // mat[i][j] = gen.nextInt(2);\n    // }\n    // }\n    //\n    // long ret2 = solve(mat);\n    // long ret = solve(mat);\n    // if (ret != ret2) {\n    // System.out.println(ret + \" \" + ret2);\n    // System.out.println(Arrays.deepToString(mat));\n    // break;\n    // }\n    // }\n  }\n\n  private static long solve2(int[][] mat) {\n    int n = mat.length;\n    int m = mat[0].length;\n\n    int ret = 0;\n    for (int i = 0; i < (1 << n); i++) {\n      for (int j = 0; j < (1 << m); j++) {\n\n        int sum = 0;\n        for (int p = 0; p < n; p++) {\n          if (((i >> p) & 1) == 0)\n            continue;\n          for (int q = 0; q < m; q++) {\n            if (((j >> q) & 1) == 0)\n              continue;\n\n            sum += mat[p][q];\n          }\n        }\n        if (sum % 2 == 1) {\n          ret++;\n        }\n      }\n    }\n    return ret;\n  }\n\n  private static long solve(int[][] mat) {\n\n    int n = mat.length;\n    int m = mat[0].length;\n\n    int rank = rank(mat, 2);\n\n    int mod = 998244353;\n    long[] p2 = new long[1000];\n    p2[0] = 1;\n    for (int i = 0; i < p2.length - 1; i++) {\n      p2[i + 1] = p2[i] * 2 % mod;\n    }\n\n    long ret = p2[m - 1] * (p2[n] - p2[n - rank]);\n    ret %= mod;\n    if (ret < 0)\n      ret += mod;\n    return ret;\n  }\n\n  public static long CX(long n, long r, int p, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    int np = (int) (n % p), rp = (int) (r % p);\n    if (np < rp)\n      return 0;\n    if (n == 0 && r == 0)\n      return 1;\n    int nrp = np - rp;\n    if (nrp < 0)\n      nrp += p;\n    return (long) fif[0][np] * fif[1][rp] % p * fif[1][nrp] % p * CX(n / p, r / p, p, fif) % p;\n  }\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static int rank(int[][] M, int p) {\n    if (M.length == 0)\n      return 0;\n    int n = M.length, m = M[0].length;\n\n    // Forward Elimination\n    for (int i = 0; i < n; i++) {\n      // select pivot\n      boolean pivotFound = false;\n      out: for (int pi = i; pi < n; pi++) {\n        for (int pj = i; pj < m; pj++) {\n          if (M[pi][pj] != 0) {\n            // pivot found\n            if (pj != i) {\n              // swap columns\n              for (int k = 0; k < n; k++) {\n                int d = M[k][pj];\n                M[k][pj] = M[k][i];\n                M[k][i] = d;\n              }\n            }\n            if (pi != i) {\n              // swap rows\n              int[] d = M[pi];\n              M[pi] = M[i];\n              M[i] = d;\n            }\n            pivotFound = true;\n            break out;\n          }\n        }\n      }\n      if (!pivotFound)\n        return i;\n\n      long ID = invl(M[i][i], p);\n      M[i][i] = 1;\n      for (int j = i + 1; j < m; j++) {\n        M[i][j] = (int) (M[i][j] * ID % p);\n      }\n\n      for (int j = i + 1; j < n; j++) {\n        long B = p - M[j][i];\n        M[j][i] = 0;\n        for (int k = i + 1; k < m; k++) {\n          M[j][k] = (int) ((M[j][k] + M[i][k] * B) % p);\n        }\n      }\n    }\n    return n;\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.BitSet;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.util.Comparator;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        static final int mod = 998244353;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            BitSet[] bitset = new BitSet[n];\n            for (int y = 0; y < n; y++) {\n                bitset[y] = new BitSet();\n                for (int x = 0; x < m; x++) {\n                    if (in.nextInt() == 1) {\n                        bitset[y].set(x);\n                    }\n                }\n            }\n            Arrays.sort(bitset, Comparator.comparing(BitSet::length).reversed());\n            int rank = 0;\n            for (int y = 0, x = 0; y < n && x < m; x++) {\n                for (int i = y; i < n; i++) {\n                    if (bitset[i].get(x)) {\n                        swap(bitset, i, y);\n                        break;\n                    }\n                }\n                if (bitset[y].get(x)) {\n                    for (int i = y + 1; i < n; i++) {\n                        bitset[i].xor(bitset[y]);\n                    }\n                    rank++;\n                    y++;\n                }\n            }\n\n            out.println(((pow(2, n) - pow(2, n - rank)) * pow(2, m - 1) % mod + mod) % mod);\n        }\n\n        long pow(int n, int r) {\n            long ans = 1;\n            for (int i = 0; i < r; i++) ans = ans * n % mod;\n            return ans;\n        }\n\n        static <T> void swap(T[] xs, int i, int j) {\n            T t = xs[i];\n            xs[i] = xs[j];\n            xs[j] = t;\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[][] a = new int[n][];\n\t\tfor(int i= 0;i < n;i++){\n\t\t\ta[i] = na(m);\n\t\t}\n\t\tboolean[][] b = new boolean[n][m];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j= 0;j < m;j++){\n\t\t\t\tb[i][j] = a[i][j] == 1;\n\t\t\t}\n\t\t}\n\t\tint mod = 998244353;\n\t\tint r = rank(b);\n\t\tlong ret = pow(2, m-1, mod) * (pow(2, n, mod) -pow(2, n-r, mod));\n\t\tret %= mod;\n\t\tif(ret < 0)ret += mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static int rank(boolean[][] M)\n\t{\n\t\tint n = M.length, m = M[0].length;\n\t\t\n\t\t// Forward Elimination\n\t\tfor(int i = 0;i < n;i++){\n\t\t\t// select pivot\n\t\t\tboolean pivotFound = false;\n\t\t\tout:\n\t\t\tfor(int pi = i;pi < n;pi++){\n\t\t\t\tfor(int pj = i;pj < m;pj++){\n\t\t\t\t\tif(M[pi][pj]){\n\t\t\t\t\t\t// pivot found\n\t\t\t\t\t\t// swap columns\n\t\t\t\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\t\t\t\tboolean u = M[k][pj]; M[k][pj] = M[k][i]; M[k][i] = u;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(pi != i){\n\t\t\t\t\t\t\t// swap rows\n\t\t\t\t\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\t\t\t\t\tboolean u = M[pi][k]; M[pi][k] = M[i][k]; M[i][k] = u;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpivotFound = true;\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!pivotFound)return i;\n\t\t\t\n\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\tif(M[j][i]){\n\t\t\t\t\tfor(int k = i;k < m;k++){\n\t\t\t\t\t\tM[j][k] ^= M[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = n-1;j >= 0;j--){\n\t\t\tfor(int i = j-1;i >= 0;i--){\n\t\t\t\tif(M[i][j]){\n\t\t\t\t\tfor(int k = j;k < m;k++){\n\t\t\t\t\t\tM[i][k] ^= M[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn n;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.BitSet;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            int[][] a = in.readIntTable(n, m);\n\n            BitSet[] data = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                data[i] = new BitSet();\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    if (a[i][j] == 1) data[i].set(j);\n                }\n            }\n\n            int idx = 0;\n            for (int i = m - 1; i >= 0 && idx < n; i--) {\n                Arrays.sort(data, Comparator.comparing(BitSet::length).reversed());\n                if (!data[idx].get(i)) continue;\n\n                for (int j = 0; j < n; j++) {\n                    if (j != idx && data[j].get(i)) data[j].xor(data[idx]);\n                }\n\n                idx++;\n            }\n\n            int rank = 0;\n            for (int i = 0; i < n; i++) {\n                if (!data[i].isEmpty()) rank++;\n            }\n\n            Modulo modulo = new Modulo(998244353);\n            long tmp1 = modulo.pow(2, n);\n            long tmp2 = modulo.pow(2, n - rank);\n            long tmp3 = modulo.pow(2, m - 1);\n\n            out.printLine(modulo.mlt(modulo.sub(tmp1, tmp2), tmp3));\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class Modulo {\n        long m;\n\n        public Modulo(long m) {\n            this.m = m;\n        }\n\n        public long sub(long a, long b) {\n            return (a - b + m) % m;\n        }\n\n        public long mlt(long a, long b) {\n            return (a * b) % m;\n        }\n\n        public long pow(long a, long x) {\n            long ans = 1 % m;\n            while (x > 0) {\n                if ((x & 1) != 0) {\n                    ans = (ans * a) % m;\n                }\n                x >>= 1;\n                a = (a * a) % m;\n            }\n            return ans;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[][] readIntTable(int rowCount, int columnCount) {\n            int[][] table = new int[rowCount][];\n            for (int i = 0; i < rowCount; i++) {\n                table[i] = readIntArray(columnCount);\n            }\n            return table;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final long MOD = 998244353;\n\tstatic int N, M;\n\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tint[][] mat = new int[N][M];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tmat[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tint dim = 0;\n\t\tint col = 0;\n\t\tboolean[] fix = new boolean[N];\n\t\tfor (int i = 0; i < N && col < M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (!fix[j] && mat[j][col] == 1) {\n\t\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\t\tif (k == j || mat[k][col] == 0) continue;\n\t\t\t\t\t\tfor (int l = 0; l < M; l++) {\n\t\t\t\t\t\t\tmat[k][l] ^= mat[j][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++dim;\n\t\t\t\t\tfix[j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++col;\n\t\t}\n//\t\tfor (int i = 0; i < N; i++) {\n//\t\t\tfor (int j = 0; j < M; j++) {\n//\t\t\t\tSystem.err.print(mat[i][j] + \" \");\n//\t\t\t}\n//\t\t\tSystem.err.println();\n//\t\t}\n\n\t\tlong[] pow2 = new long[301];\n\t\tpow2[0] = 1;\n\t\tfor (int i = 1; i < pow2.length; i++) {\n\t\t\tpow2[i] = pow2[i - 1] * 2 % MOD;\n\t\t}\n\t\tlong[][] comb = new long[301][301];\n\t\tfor (int i = 0; i < comb.length; i++) {\n\t\t\tcomb[i][0] = comb[i][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < comb.length; i++) {\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tcomb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 1; i <= dim; i++) {\n\t\t\tlong here = 0;\n\t\t\tfor (int j = 1; j <= i; j += 2) {\n\t\t\t\there += comb[i][j];\n\t\t\t\there %= MOD;\n\t\t\t}\n\t\t\there *= comb[dim][i];\n\t\t\there %= MOD;\n\t\t\there *= pow2[M - i];\n\t\t\there %= MOD;\n\t\t\tans += here;\n\t\t}\n\t\tans %= MOD;\n\t\tans *= pow2[N - dim];\n\t\tans %= MOD;\n\t\tSystem.out.println(ans);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static class bitset {\n\t\tlong[] a=new long[8];\n\t\tpublic void set(long v,int id) {\n\t\t\ta[id/50]|=v<<(id%50);\n\t\t}\n\t\tpublic int get(int id) {\n\t\t\treturn (int)((a[id/50]>>(id%50))&1);\n\t\t}\n\t\tpublic void xor(bitset rhs) {\n\t\t\tfor (int i=0;i<8;++i) a[i]^=rhs.a[i];\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint m=in.nextInt();\n\t\tbitset[] bit=new bitset[n];\n\t\tfor (int i=0;i<n;++i) {\n\t\t\tbit[i]=new bitset();\n\t\t\tfor (int j=0;j<m;++j) {\n\t\t\t\tint x=in.nextInt();\n\t\t\t\tbit[i].set(x,j);\n\t\t\t}\n\t\t}\n\t\tlong mod=998244353;\n\t\tlong[] p=new long[n+m];\n\t\tp[0]=1;\n\t\tfor (int i=1;i<n+m;++i) p[i]=(p[i-1]+p[i-1])%mod;\n\t\tint rk=0;\n\t\tfor (int i=0;i<m;++i) {\n\t\t\tboolean flag=false;\n\t\t\tfor (int j=rk;j<n;++j) if (bit[j].get(i)==1) {\n\t\t\t\tbitset tmp=bit[j];\n\t\t\t\tbit[j]=bit[rk];\n\t\t\t\tbit[rk]=tmp;\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!flag) continue;\n\t\t\t++rk;\n\t\t\tfor (int j=rk;j<n;++j) if (bit[j].get(i)==1)\n\t\t\t\tbit[j].xor(bit[rk-1]);\n\t\t}\n\t\tSystem.out.println((p[n+m-1]-p[n+m-1-rk]+mod)%mod);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        int mod = 998244353;\n\n        long pow(long a, long p, int mod) {\n            if (p == 0) {\n                return 1;\n            }\n\n            long t = pow(a, p / 2, mod);\n\n            if (p % 2 != 0) {\n                return (((t * t) % mod) * a) % mod;\n            } else {\n                return (t * t) % mod;\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[][] a = new int[n][m];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = in.nextInt();\n                }\n            }\n\n            MatrixRank rank = new MatrixRank();\n\n            int r = rank.matrixRankFF2(a);\n\n            long ans = pow(2, n + m - 1, mod);\n            ans -= pow(2, n + m - r - 1, mod);\n\n            ans %= mod;\n\n            if (ans < 0) {\n                ans += mod;\n            }\n\n            out.println(ans);\n        }\n\n        class MatrixRank {\n            int matrixRankFF2(int[][] a) {\n                int n = a.length;\n                int m = a[0].length;\n\n                Arrays.sort(a, (row1, row2) ->\n                {\n                    for (int i = 0; i < m; i++) {\n                        if (row1[i] > row2[i]) {\n                            return -1;\n                        } else if (row1[i] < row2[i]) {\n                            return 1;\n                        }\n                    }\n                    return 0;\n                });\n\n                int rank = 0;\n\n                for (int i = 0; i < n; i++) {\n                    int fsi = -1;\n                    for (int j = 0; j < m; j++) {\n                        if (a[i][j] == 1) {\n                            fsi = j;\n                            break;\n                        }\n                    }\n\n                    if (fsi == -1) {\n                        return rank;\n                    }\n\n                    rank++;\n\n                    for (int j = i + 1; j < n; j++) {\n                        if (a[j][fsi] == 1) {\n                            for (int k = fsi; k < m; k++) {\n                                a[j][k] = 1 - a[j][k];\n                            }\n                        }\n                    }\n\n                    Arrays.sort(a, (row1, row2) ->\n                    {\n                        for (int j = 0; j < m; j++) {\n                            if (row1[j] > row2[j]) {\n                                return -1;\n                            } else if (row1[j] < row2[j]) {\n                                return 1;\n                            }\n                        }\n                        return 0;\n                    });\n                }\n\n                return rank;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        int mod = 998244353;\n\n        long pow(long a, long p, int mod) {\n            if (p == 0) {\n                return 1;\n            }\n\n            long t = pow(a, p / 2, mod);\n\n            if (p % 2 != 0) {\n                return (((t * t) % mod) * a) % mod;\n            } else {\n                return (t * t) % mod;\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[][] a = new int[n][m];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = in.nextInt();\n                }\n            }\n\n            MatrixRank rank = new MatrixRank();\n\n            int r = rank.matrixRankFF2(a);\n\n            long ans = pow(2, n + m - 1, mod);\n            ans -= pow(2, n + m - r - 1, mod);\n\n            ans %= mod;\n\n            if (ans < 0) {\n                ans += mod;\n            }\n\n            out.println(ans);\n        }\n\n        class MatrixRank {\n            int matrixRankFF2(int[][] a) {\n                int n = a.length;\n                int m = a[0].length;\n\n//            Arrays.sort(a, (row1, row2) ->\n//            {\n//                for (int i = 0; i < m; i++) {\n//                    if (row1[i] > row2[i]) {\n//                        return -1;\n//                    } else if (row1[i] < row2[i]) {\n//                        return 1;\n//                    }\n//                }\n//                return 0;\n//            });\n//\n//            int rank = 0;\n//\n//            for (int i = 0; i < n; i++) {\n//                int fsi = -1;\n//                for (int j = 0; j < m; j++) {\n//                    if (a[i][j] == 1) {\n//                        fsi = j;\n//                        break;\n//                    }\n//                }\n//\n//                if (fsi == -1) {\n//                    return rank;\n//                }\n//\n//                rank++;\n//\n//                for (int j = i + 1; j < n; j++) {\n//                    if (a[j][fsi] == 1) {\n//                        for (int k = fsi; k < m; k++) {\n//                            a[j][k] = a[j][k] ^ a[i][k];\n//                        }\n//                    }\n//                }\n//\n//                Arrays.sort(a, (row1, row2) ->\n//                {\n//                    for (int j = 0; j < m; j++) {\n//                        if (row1[j] > row2[j]) {\n//                            return -1;\n//                        } else if (row1[j] < row2[j]) {\n//                            return 1;\n//                        }\n//                    }\n//                    return 0;\n//                });\n//            }\n//\n//            return rank;\n\n                int rank = 0;\n\n                for (int i = 0; i < m; i++) {\n                    int ind = -1;\n                    for (int j = 0; j < n; j++) {\n                        if (a[j][i] == 1) {\n                            ind = j;\n                            break;\n                        }\n                    }\n\n                    if (ind == -1)\n                        continue;\n\n                    rank++;\n\n                    for (int j = ind + 1; j < n; j++) {\n                        if (a[j][i] == 1) {\n                            for (int k = i; k < m; k++) {\n                                a[j][k] ^= a[ind][k];\n                            }\n                        }\n                    }\n                }\n\n                return rank;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.BitSet;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            int[][] a = in.readIntTable(n, m);\n\n            BitSet[] data = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                data[i] = new BitSet();\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    if (a[i][j] == 1) data[i].set(j);\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                Arrays.sort(data, Comparator.comparing(BitSet::length));\n                if (!data[i].get(i)) continue;\n\n                for (int j = 0; j < n; j++) {\n                    if (j != i && data[j].get(i)) data[j].xor(data[i]);\n                }\n            }\n\n            int rank = 0;\n            for (int i = 0; i < n; i++) {\n                if (!data[i].isEmpty()) rank++;\n            }\n\n            Modulo modulo = new Modulo(998244353);\n            long tmp1 = modulo.pow(2, n);\n            long tmp2 = modulo.pow(2, n - rank);\n            long tmp3 = modulo.pow(2, m - 1);\n\n            out.printLine(modulo.mlt(modulo.sub(tmp1, tmp2), tmp3));\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class Modulo {\n        long m;\n\n        public Modulo(long m) {\n            this.m = m;\n        }\n\n        public long sub(long a, long b) {\n            return (a - b + m) % m;\n        }\n\n        public long mlt(long a, long b) {\n            return (a * b) % m;\n        }\n\n        public long pow(long a, long x) {\n            long ans = 1 % m;\n            while (x > 0) {\n                if ((x & 1) != 0) {\n                    ans = (ans * a) % m;\n                }\n                x >>= 1;\n                a = (a * a) % m;\n            }\n            return ans;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[][] readIntTable(int rowCount, int columnCount) {\n            int[][] table = new int[rowCount][];\n            for (int i = 0; i < rowCount; i++) {\n                table[i] = readIntArray(columnCount);\n            }\n            return table;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tE_OddSubrectangles solver = new E_OddSubrectangles();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class E_OddSubrectangles {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int MOD = 998244353;\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\t\t\tBigInteger[] a = new BigInteger[height];\n\t\t\tfor (int r = 0; r < height; r++) {\n\t\t\t\ta[r] = BigInteger.ZERO;\n\t\t\t\tfor (int c = 0; c < width; c++) {\n\t\t\t\t\tint x = in.nextInt();\n\t\t\t\t\tif (x == 1) {\n\t\t\t\t\t\ta[r] = a[r].or(BigInteger.ONE.shiftLeft(c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint rank = calcRank(a.clone());\n\n\t\t\tlong[] p2 = new long[height + width + 1];\n\t\t\tp2[0] = 1;\n\t\t\tfor (int i = 1; i < p2.length; i++) {\n\t\t\t\tp2[i] = 2 * p2[i - 1] % MOD;\n\t\t\t}\n\t\t\tlong ans = p2[height + width - 1] - p2[height + width - 1 - rank];\n\t\t\tif (ans < 0) {\n\t\t\t\tans += MOD;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate int calcRank(BigInteger[] rows) {\n\t\t\tdiagonalize(rows);\n\t\t\tint res = 0;\n\t\t\tfor (BigInteger row : rows) {\n\t\t\t\tif (!row.equals(BigInteger.ZERO)) {\n\t\t\t\t\t++res;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate void diagonalize(BigInteger[] a) {\n\t\t\tint lastR = a.length - 1;\n\t\t\tint r = 0;\n\t\t\twhile (r <= lastR) {\n\t\t\t\tif (a[r].equals(BigInteger.ZERO)) {\n\t\t\t\t\tBigInteger t = a[r];\n\t\t\t\t\ta[r] = a[lastR];\n\t\t\t\t\ta[lastR] = t;\n\t\t\t\t\t--lastR;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint or = r;\n\t\t\t\twhile (!a[r].testBit(or)) {\n\t\t\t\t\t++or;\n\t\t\t\t}\n\t\t\t\tif (or != r) {\n\t\t\t\t\tfor (int i = 0; i <= lastR; i++) {\n\t\t\t\t\t\tboolean bitR = a[i].testBit(r);\n\t\t\t\t\t\tboolean bitOR = a[i].testBit(or);\n\t\t\t\t\t\tif (bitOR) {\n\t\t\t\t\t\t\ta[i] = a[i].setBit(r);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ta[i] = a[i].clearBit(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (bitR) {\n\t\t\t\t\t\t\ta[i] = a[i].setBit(or);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ta[i] = a[i].clearBit(or);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = r + 1; i <= lastR; i++) {\n\t\t\t\t\tif (a[i].testBit(r)) {\n\t\t\t\t\t\ta[i] = a[i].xor(a[r]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t++r;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EOddSubrectangles solver = new EOddSubrectangles();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EOddSubrectangles {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            BitSet[] mat = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                mat[i] = new BitSet(m);\n                for (int j = 0; j < m; j++) {\n                    if (in.readChar() == '1') {\n                        mat[i].set(j);\n                    } else {\n                        mat[i].clear(j);\n                    }\n                }\n            }\n            GenericLinearBasis glb = new GenericLinearBasis(m);\n            for (int i = 0; i < n; i++) {\n                glb.add(mat[i]);\n            }\n\n            Modular mod = new Modular(998244353);\n            Power pow = new Power(mod);\n            int rowSet = mod.subtract(pow.pow(2, n), pow.pow(2, n - glb.size()));\n            int ans = mod.mul(rowSet, pow.pow(2, m - 1));\n\n            out.println(ans);\n        }\n\n    }\n\n    static final class BitSet implements Serializable, Cloneable {\n        private long[] data;\n        private long tailAvailable;\n        private int capacity;\n        private int m;\n        private static final int SHIFT = 6;\n        private static final int LOW = 63;\n        private static final int BITS_FOR_EACH = 64;\n        private static final long ALL_ONE = ~0L;\n        private static final long ALL_ZERO = 0L;\n\n        public BitSet(int n) {\n            capacity = n;\n            this.m = (capacity + 64 - 1) / 64;\n            data = new long[m];\n            tailAvailable = oneBetween(0, offset(capacity - 1));\n        }\n\n        public BitSet(BitSet bs) {\n            this.data = bs.data.clone();\n            this.tailAvailable = bs.tailAvailable;\n            this.capacity = bs.capacity;\n            this.m = bs.m;\n        }\n\n        private BitSet(BitSet bs, int l, int r) {\n            capacity = r - l + 1;\n            tailAvailable = oneBetween(0, offset(capacity - 1));\n            data = Arrays.copyOfRange(bs.data, word(l), word(r) + 1);\n            this.m = data.length;\n            leftShift(offset(l));\n            this.m = (capacity + 64 - 1) / 64;\n            data[m - 1] &= tailAvailable;\n            for (int i = m; i < data.length; i++) {\n                data[i] = 0;\n            }\n        }\n\n        public boolean get(int i) {\n            return (data[word(i)] & (1L << offset(i))) != 0;\n        }\n\n        public void set(int i) {\n            data[word(i)] |= (1L << offset(i));\n        }\n\n        private static int word(int i) {\n            return i >>> SHIFT;\n        }\n\n        private static int offset(int i) {\n            return i & LOW;\n        }\n\n        private long oneBetween(int l, int r) {\n            if (r < l) {\n                return 0;\n            }\n            long lBegin = 1L << offset(l);\n            long rEnd = 1L << offset(r);\n            return (ALL_ONE ^ (lBegin - 1)) & ((rEnd << 1) - 1);\n        }\n\n        public void clear(int i) {\n            data[word(i)] &= ~(1L << offset(i));\n        }\n\n        public int capacity() {\n            return capacity;\n        }\n\n        public void copy(BitSet bs) {\n            int n = Math.min(this.m, bs.m);\n            System.arraycopy(bs.data, 0, data, 0, n);\n            Arrays.fill(data, n, n, 0);\n        }\n\n        public void xor(BitSet bs) {\n            int n = Math.min(this.m, bs.m);\n            for (int i = 0; i < n; i++) {\n                data[i] ^= bs.data[i];\n            }\n        }\n\n        public int nextSetBit(int start) {\n            int offset = offset(start);\n            int w = word(start);\n            if (offset != 0) {\n                long mask = oneBetween(offset, 63);\n                if ((data[w] & mask) != 0) {\n                    return Long.numberOfTrailingZeros(data[w] & mask) + w * BITS_FOR_EACH;\n                }\n                w++;\n            }\n\n            while (w < m && data[w] == ALL_ZERO) {\n                w++;\n            }\n            if (w >= m) {\n                return capacity();\n            }\n            return Long.numberOfTrailingZeros(data[w]) + w * BITS_FOR_EACH;\n        }\n\n        public void leftShift(int n) {\n            int wordMove = word(n);\n            int offsetMove = offset(n);\n            int rshift = 63 - (offsetMove - 1);\n\n            if (offsetMove != 0) {\n                //slightly\n                for (int i = 0; i < m; i++) {\n                    if (i > 0) {\n                        data[i - 1] |= data[i] << rshift;\n                    }\n                    data[i] >>>= offsetMove;\n                }\n            }\n            if (wordMove > 0) {\n                for (int i = 0; i < m; i++) {\n                    if (i >= wordMove) {\n                        data[i - wordMove] = data[i];\n                    }\n                    data[i] = 0;\n                }\n            }\n        }\n\n        public BitSet clone() {\n            return new BitSet(this);\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder(\"{\");\n            for (int i = nextSetBit(0); i < capacity(); i++) {\n                builder.append(i).append(',');\n            }\n            if (builder.length() > 1) {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append(\"}\");\n            return builder.toString();\n        }\n\n        public int hashCode() {\n            int ans = 1;\n            for (int i = 0; i < m; i++) {\n                ans = ans * 31 + Long.hashCode(data[i]);\n            }\n            return ans;\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof BitSet)) {\n                return false;\n            }\n            BitSet other = (BitSet) obj;\n            if (other.capacity != capacity) {\n                return false;\n            }\n            for (int i = 0; i < m; i++) {\n                if (other.data[i] != data[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n    }\n\n    static class GenericLinearBasis {\n        private BitSet[] basis;\n        private int size;\n        private int dimension;\n        private BitSet or;\n        private BitSet buf;\n\n        public GenericLinearBasis(int dimension) {\n            this.dimension = dimension;\n            basis = new BitSet[dimension];\n            for (int i = 0; i < dimension; i++) {\n                basis[i] = new BitSet(dimension);\n            }\n            or = new BitSet(dimension);\n            buf = new BitSet(dimension);\n        }\n\n        public void add(BitSet bits) {\n            buf.copy(bits);\n            bits = buf;\n            for (int i = dimension - 1; i >= 0; i--) {\n                if (!bits.get(i)) {\n                    continue;\n                }\n                if (or.get(i)) {\n                    for (int j = 0; j < dimension; j++) {\n                        bits.xor(basis[i]);\n                    }\n                    continue;\n                }\n                or.set(i);\n                size++;\n                basis[i].copy(bits);\n                for (int j = i + 1; j < dimension; j++) {\n                    if (!or.get(j) || !basis[j].get(i)) {\n                        continue;\n                    }\n                    for (int k = 0; k < dimension; k++) {\n                        basis[j].xor(basis[i]);\n                    }\n                }\n                return;\n            }\n        }\n\n        public int size() {\n            return size;\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final long MOD = 998244353;\n\tstatic int N, M;\n\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tint[][] mat = new int[N][M];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tmat[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tint dim = 0;\n\t\tint col = 0;\n\t\tboolean[] fix = new boolean[N];\n\t\tfor (int i = 0; i < N && col < M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (!fix[j] && mat[j][col] == 1) {\n\t\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\t\tif (k == j || mat[k][col] == 0) continue;\n\t\t\t\t\t\tfor (int l = 0; l < M; l++) {\n\t\t\t\t\t\t\tmat[k][l] ^= mat[j][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++dim;\n\t\t\t\t\tfix[j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++col;\n\t\t}\n//\t\tfor (int i = 0; i < N; i++) {\n//\t\t\tfor (int j = 0; j < M; j++) {\n//\t\t\t\tSystem.err.print(mat[i][j] + \" \");\n//\t\t\t}\n//\t\t\tSystem.err.println();\n//\t\t}\n\n\t\tlong[] pow2 = new long[301];\n\t\tpow2[0] = 1;\n\t\tfor (int i = 1; i < pow2.length; i++) {\n\t\t\tpow2[i] = pow2[i - 1] * 2 % MOD;\n\t\t}\n\t\tlong[][] comb = new long[301][301];\n\t\tfor (int i = 0; i < comb.length; i++) {\n\t\t\tcomb[i][0] = comb[i][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < comb.length; i++) {\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tcomb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 1; i <= dim; i++) {\n\t\t\tlong here = 0;\n\t\t\tfor (int j = 1; j <= i; j += 2) {\n\t\t\t\there += comb[i][j];\n\t\t\t\there %= MOD;\n\t\t\t}\n\t\t\there *= comb[dim][i];\n\t\t\there %= MOD;\n\t\t\there *= pow2[M - i];\n\t\t\there %= MOD;\n\t\t\tans += here;\n\t\t}\n\t\tans *= pow2[N - dim];\n\t\tans %= MOD;\n\t\tSystem.out.println(ans);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final long MOD = 998244353;\n\tstatic int N, M;\n\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tint[][] mat = new int[N][M];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tmat[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tint dim = 0;\n\t\tint col = 0;\n\t\tboolean[] fix = new boolean[N];\n\t\tfor (int i = 0; i < N && col < M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (!fix[j] && mat[j][col] == 1) {\n\t\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\t\tif (k == j || mat[k][col] == 0) continue;\n\t\t\t\t\t\tfor (int l = 0; l < M; l++) {\n\t\t\t\t\t\t\tmat[k][l] ^= mat[j][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++dim;\n\t\t\t\t\tfix[j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++col;\n\t\t}\n//\t\tfor (int i = 0; i < N; i++) {\n//\t\t\tfor (int j = 0; j < M; j++) {\n//\t\t\t\tSystem.err.print(mat[i][j] + \" \");\n//\t\t\t}\n//\t\t\tSystem.err.println();\n//\t\t}\n\n\t\tlong[] pow2 = new long[301];\n\t\tpow2[0] = 1;\n\t\tfor (int i = 1; i < pow2.length; i++) {\n\t\t\tpow2[i] = pow2[i - 1] * 2 % MOD;\n\t\t}\n\t\tlong[][] comb = new long[301][301];\n\t\tfor (int i = 0; i < comb.length; i++) {\n\t\t\tcomb[i][0] = comb[i][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < comb.length; i++) {\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tcomb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 1; i <= dim; i++) {\n\t\t\tlong here = 0;\n\t\t\tfor (int j = 1; j <= i; j += 2) {\n\t\t\t\there += comb[i][j];\n\t\t\t\there %= MOD;\n\t\t\t}\n\t\t\there *= comb[dim][i];\n\t\t\there %= MOD;\n\t\t\there *= pow2[M - i];\n\t\t\there %= MOD;\n\t\t\tans += here;\n\t\t\tans %= MOD;\n\t\t}\n\t\tans *= pow2[N - dim];\n\t\tans %= MOD;\n\t\tSystem.out.println(ans);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n    int[][] mat = ntable(n, m);\n\n    System.out.println(solve(mat));\n\n\n    // Random gen = new Random();\n    // while( true) {\n    // int n = gen.nextInt(5) + 1;\n    // int m = gen.nextInt(5) + 1;\n    // int[][] mat = new int[n][m];\n    // for (int i = 0; i < n; i ++) {\n    // for (int j = 0; j < m; j ++) {\n    // mat[i][j] = gen.nextInt(2);\n    // }\n    // }\n    //\n    // long ret2 = solve(mat);\n    // long ret = solve(mat);\n    // if (ret != ret2) {\n    // System.out.println(ret + \" \" + ret2);\n    // System.out.println(Arrays.deepToString(mat));\n    // break;\n    // }\n    // }\n  }\n\n  private static long solve2(int[][] mat) {\n    int n = mat.length;\n    int m = mat[0].length;\n\n    int ret = 0;\n    for (int i = 0; i < (1 << n); i++) {\n      for (int j = 0; j < (1 << m); j++) {\n\n        int sum = 0;\n        for (int p = 0; p < n; p++) {\n          if (((i >> p) & 1) == 0)\n            continue;\n          for (int q = 0; q < m; q++) {\n            if (((j >> q) & 1) == 0)\n              continue;\n\n            sum += mat[p][q];\n          }\n        }\n        if (sum % 2 == 1) {\n          ret++;\n        }\n      }\n    }\n    return ret;\n  }\n\n  private static long solve(int[][] mat) {\n\n    int n = mat.length;\n    int m = mat[0].length;\n\n    int rank = rank(mat, 2);\n\n    int mod = 998244353;\n    long[] p2 = new long[1000];\n    p2[0] = 1;\n    for (int i = 0; i < p2.length - 1; i++) {\n      p2[i + 1] = p2[i] * 2 % mod;\n    }\n\n    int[][] fif = enumFIF(1000, mod);\n\n    long ret = 0;\n    for (int i = 1; i <= rank; i += 2) {\n      long now = CX(rank, i, mod, fif) * ((p2[rank - i] + p2[rank - i] - 1) % mod) % mod;\n      ret += now * p2[n - rank] % mod * p2[m - rank] % mod;\n      ret %= mod;\n    }\n    if (ret < 0) ret += mod;\n    return ret;\n  }\n\n  public static long CX(long n, long r, int p, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    int np = (int) (n % p), rp = (int) (r % p);\n    if (np < rp)\n      return 0;\n    if (n == 0 && r == 0)\n      return 1;\n    int nrp = np - rp;\n    if (nrp < 0)\n      nrp += p;\n    return (long) fif[0][np] * fif[1][rp] % p * fif[1][nrp] % p * CX(n / p, r / p, p, fif) % p;\n  }\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static int rank(int[][] M, int p) {\n    if (M.length == 0)\n      return 0;\n    int n = M.length, m = M[0].length;\n\n    // Forward Elimination\n    for (int i = 0; i < n; i++) {\n      // select pivot\n      boolean pivotFound = false;\n      out: for (int pi = i; pi < n; pi++) {\n        for (int pj = i; pj < m; pj++) {\n          if (M[pi][pj] != 0) {\n            // pivot found\n            if (pj != i) {\n              // swap columns\n              for (int k = 0; k < n; k++) {\n                int d = M[k][pj];\n                M[k][pj] = M[k][i];\n                M[k][i] = d;\n              }\n            }\n            if (pi != i) {\n              // swap rows\n              int[] d = M[pi];\n              M[pi] = M[i];\n              M[i] = d;\n            }\n            pivotFound = true;\n            break out;\n          }\n        }\n      }\n      if (!pivotFound)\n        return i;\n\n      long ID = invl(M[i][i], p);\n      M[i][i] = 1;\n      for (int j = i + 1; j < m; j++) {\n        M[i][j] = (int) (M[i][j] * ID % p);\n      }\n\n      for (int j = i + 1; j < n; j++) {\n        long B = p - M[j][i];\n        M[j][i] = 0;\n        for (int k = i + 1; k < m; k++) {\n          M[j][k] = (int) ((M[j][k] + M[i][k] * B) % p);\n        }\n      }\n    }\n    return n;\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n\n    int[][] mat = ntable(n, m);\n    int rank = rank(mat, 2);\n\n    int mod = 998244353;\n    long[] p2 = new long[1000];\n    p2[0] = 1;\n    for (int i = 0; i < p2.length - 1; i++) {\n      p2[i + 1] = p2[i] * 2 % mod;\n    }\n\n    int[][] fif = enumFIF(1000, mod);\n\n    long ret = 0;\n    for (int i = 1; i <= rank; i += 2) {\n      long now = CX(rank, i, mod, fif) * (p2[rank - i] + p2[rank - i] - 1) % mod;\n      ret += now * p2[n - rank] % mod * p2[m - rank] % mod;\n      ret %= mod;\n    }\n    System.out.println(ret);\n\n  }\n\n  public static long CX(long n, long r, int p, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    int np = (int) (n % p), rp = (int) (r % p);\n    if (np < rp)\n      return 0;\n    if (n == 0 && r == 0)\n      return 1;\n    int nrp = np - rp;\n    if (nrp < 0)\n      nrp += p;\n    return (long) fif[0][np] * fif[1][rp] % p * fif[1][nrp] % p * CX(n / p, r / p, p, fif) % p;\n  }\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static int rank(int[][] M, int p) {\n    if (M.length == 0)\n      return 0;\n    int n = M.length, m = M[0].length;\n\n    // Forward Elimination\n    for (int i = 0; i < n; i++) {\n      // select pivot\n      boolean pivotFound = false;\n      out: for (int pi = i; pi < n; pi++) {\n        for (int pj = i; pj < m; pj++) {\n          if (M[pi][pj] != 0) {\n            // pivot found\n            if (pj != i) {\n              // swap columns\n              for (int k = 0; k < n; k++) {\n                int d = M[k][pj];\n                M[k][pj] = M[k][i];\n                M[k][i] = d;\n              }\n            }\n            if (pi != i) {\n              // swap rows\n              int[] d = M[pi];\n              M[pi] = M[i];\n              M[i] = d;\n            }\n            pivotFound = true;\n            break out;\n          }\n        }\n      }\n      if (!pivotFound)\n        return i;\n\n      long ID = invl(M[i][i], p);\n      M[i][i] = 1;\n      for (int j = i + 1; j < m; j++) {\n        M[i][j] = (int) (M[i][j] * ID % p);\n      }\n\n      for (int j = i + 1; j < n; j++) {\n        long B = p - M[j][i];\n        M[j][i] = 0;\n        for (int k = i + 1; k < m; k++) {\n          M[j][k] = (int) ((M[j][k] + M[i][k] * B) % p);\n        }\n      }\n    }\n    return n;\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.BitSet;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        static final int mod = 998244353;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            BitSet[] bitset = new BitSet[n];\n            for (int y = 0; y < n; y++) {\n                bitset[y] = new BitSet();\n                for (int x = 0; x < m; x++) {\n                    if (in.nextInt() == 1) {\n                        bitset[y].set(x);\n                    }\n                }\n            }\n            int rank = 0;\n            for (int y = 0, x = m - 1; y < n; x--) {\n                Arrays.sort(bitset, y, n, Comparator.comparing(BitSet::length).reversed());\n                while (x >= 0 && !bitset[y].get(x)) x--;\n                if (x < 0) break;\n                if (bitset[y].get(x)) {\n                    for (int i = y + 1; i < n; i++) {\n                        if (bitset[i].get(x)) {\n                            bitset[i].xor(bitset[y]);\n                        }\n                    }\n                    rank++;\n                    y++;\n                }\n            }\n            dump(rank);\n\n            out.println(((pow(2, n) - pow(2, n - rank)) * pow(2, m - 1) % mod + mod) % mod);\n        }\n\n        long pow(int n, int r) {\n            long ans = 1;\n            for (int i = 0; i < r; i++) ans = ans * n % mod;\n            return ans;\n        }\n\n        static void dump(Object... o) {\n            System.err.println(Arrays.deepToString(o));\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\npublic class Main {\n\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n\n    int[][] mat = ntable(n, m);\n    int rank = rank(mat, 2);\n\n    int mod = 998244353;\n    long[] p2 = new long[1000];\n    p2[0] = 1;\n    for (int i = 0; i < p2.length - 1; i++) {\n      p2[i + 1] = p2[i] * 2 % mod;\n    }\n\n    int[][] fif = enumFIF(1000, mod);\n\n    long ret = 0;\n    for (int i = 1; i <= rank; i += 2) {\n      long now = CX(rank, i, mod, fif) * p2[n - rank] % mod * p2[m - rank] % mod;\n      ret += now;\n    }\n    System.out.println(ret);\n\n  }\n\n  public static long CX(long n, long r, int p, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    int np = (int) (n % p), rp = (int) (r % p);\n    if (np < rp)\n      return 0;\n    if (n == 0 && r == 0)\n      return 1;\n    int nrp = np - rp;\n    if (nrp < 0)\n      nrp += p;\n    return (long) fif[0][np] * fif[1][rp] % p * fif[1][nrp] % p * CX(n / p, r / p, p, fif) % p;\n  }\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static int rank(int[][] M, int p) {\n    if (M.length == 0)\n      return 0;\n    int n = M.length, m = M[0].length;\n\n    // Forward Elimination\n    for (int i = 0; i < n; i++) {\n      // select pivot\n      boolean pivotFound = false;\n      out: for (int pi = i; pi < n; pi++) {\n        for (int pj = i; pj < m; pj++) {\n          if (M[pi][pj] != 0) {\n            // pivot found\n            if (pj != i) {\n              // swap columns\n              for (int k = 0; k < n; k++) {\n                int d = M[k][pj];\n                M[k][pj] = M[k][i];\n                M[k][i] = d;\n              }\n            }\n            if (pi != i) {\n              // swap rows\n              int[] d = M[pi];\n              M[pi] = M[i];\n              M[i] = d;\n            }\n            pivotFound = true;\n            break out;\n          }\n        }\n      }\n      if (!pivotFound)\n        return i;\n\n      long ID = invl(M[i][i], p);\n      M[i][i] = 1;\n      for (int j = i + 1; j < m; j++) {\n        M[i][j] = (int) (M[i][j] * ID % p);\n      }\n\n      for (int j = i + 1; j < n; j++) {\n        long B = p - M[j][i];\n        M[j][i] = 0;\n        for (int k = i + 1; k < m; k++) {\n          M[j][k] = (int) ((M[j][k] + M[i][k] * B) % p);\n        }\n      }\n    }\n    return n;\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EOddSubrectangles solver = new EOddSubrectangles();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EOddSubrectangles {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            BitSet[] mat = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                mat[i] = new BitSet(m);\n                for (int j = 0; j < m; j++) {\n                    if (in.readChar() == '1') {\n                        mat[i].set(j);\n                    } else {\n                        mat[i].clear(j);\n                    }\n                }\n            }\n            GenericLinearBasis glb = new GenericLinearBasis(m);\n            for (int i = 0; i < n; i++) {\n                glb.add(mat[i]);\n            }\n\n            Modular mod = new Modular(998244353);\n            Power pow = new Power(mod);\n            int rowSet = mod.subtract(pow.pow(2, n), pow.pow(2, n - glb.size()));\n            int ans = mod.mul(rowSet, pow.pow(2, m - 1));\n\n            out.println(ans);\n        }\n\n    }\n\n    static final class BitSet implements Serializable, Cloneable {\n        private long[] data;\n        private long tailAvailable;\n        private int capacity;\n        private int m;\n        private static final int SHIFT = 6;\n        private static final int LOW = 63;\n        private static final int BITS_FOR_EACH = 64;\n        private static final long ALL_ONE = ~0L;\n        private static final long ALL_ZERO = 0L;\n\n        public BitSet(int n) {\n            capacity = n;\n            this.m = (capacity + 64 - 1) / 64;\n            data = new long[m];\n            tailAvailable = oneBetween(0, offset(capacity - 1));\n        }\n\n        public BitSet(BitSet bs) {\n            this.data = bs.data.clone();\n            this.tailAvailable = bs.tailAvailable;\n            this.capacity = bs.capacity;\n            this.m = bs.m;\n        }\n\n        private BitSet(BitSet bs, int l, int r) {\n            capacity = r - l + 1;\n            tailAvailable = oneBetween(0, offset(capacity - 1));\n            data = Arrays.copyOfRange(bs.data, word(l), word(r) + 1);\n            this.m = data.length;\n            leftShift(offset(l));\n            this.m = (capacity + 64 - 1) / 64;\n            data[m - 1] &= tailAvailable;\n            for (int i = m; i < data.length; i++) {\n                data[i] = 0;\n            }\n        }\n\n        public boolean get(int i) {\n            return (data[word(i)] & (1L << offset(i))) != 0;\n        }\n\n        public void set(int i) {\n            data[word(i)] |= (1L << offset(i));\n        }\n\n        private static int word(int i) {\n            return i >>> SHIFT;\n        }\n\n        private static int offset(int i) {\n            return i & LOW;\n        }\n\n        private long oneBetween(int l, int r) {\n            if (r < l) {\n                return 0;\n            }\n            long lBegin = 1L << offset(l);\n            long rEnd = 1L << offset(r);\n            return (ALL_ONE ^ (lBegin - 1)) & ((rEnd << 1) - 1);\n        }\n\n        public void clear(int i) {\n            data[word(i)] &= ~(1L << offset(i));\n        }\n\n        public int capacity() {\n            return capacity;\n        }\n\n        public void copy(BitSet bs) {\n            int n = Math.min(this.m, bs.m);\n            System.arraycopy(bs.data, 0, data, 0, n);\n            Arrays.fill(data, n, n, 0);\n        }\n\n        public void xor(BitSet bs) {\n            int n = Math.min(this.m, bs.m);\n            for (int i = 0; i < n; i++) {\n                data[i] ^= bs.data[i];\n            }\n        }\n\n        public int nextSetBit(int start) {\n            int offset = offset(start);\n            int w = word(start);\n            if (offset != 0) {\n                long mask = oneBetween(offset, 63);\n                if ((data[w] & mask) != 0) {\n                    return Long.numberOfTrailingZeros(data[w] & mask) + w * BITS_FOR_EACH;\n                }\n                w++;\n            }\n\n            while (w < m && data[w] == ALL_ZERO) {\n                w++;\n            }\n            if (w >= m) {\n                return capacity();\n            }\n            return Long.numberOfTrailingZeros(data[w]) + w * BITS_FOR_EACH;\n        }\n\n        public void leftShift(int n) {\n            int wordMove = word(n);\n            int offsetMove = offset(n);\n            int rshift = 63 - (offsetMove - 1);\n\n            if (offsetMove != 0) {\n                //slightly\n                for (int i = 0; i < m; i++) {\n                    if (i > 0) {\n                        data[i - 1] |= data[i] << rshift;\n                    }\n                    data[i] >>>= offsetMove;\n                }\n            }\n            if (wordMove > 0) {\n                for (int i = 0; i < m; i++) {\n                    if (i >= wordMove) {\n                        data[i - wordMove] = data[i];\n                    }\n                    data[i] = 0;\n                }\n            }\n        }\n\n        public BitSet clone() {\n            return new BitSet(this);\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder(\"{\");\n            for (int i = nextSetBit(0); i < capacity(); i++) {\n                builder.append(i).append(',');\n            }\n            if (builder.length() > 1) {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append(\"}\");\n            return builder.toString();\n        }\n\n        public int hashCode() {\n            int ans = 1;\n            for (int i = 0; i < m; i++) {\n                ans = ans * 31 + Long.hashCode(data[i]);\n            }\n            return ans;\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof BitSet)) {\n                return false;\n            }\n            BitSet other = (BitSet) obj;\n            if (other.capacity != capacity) {\n                return false;\n            }\n            for (int i = 0; i < m; i++) {\n                if (other.data[i] != data[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n    }\n\n    static class GenericLinearBasis {\n        private BitSet[] basis;\n        private int size;\n        private int dimension;\n        private BitSet or;\n        private BitSet buf;\n\n        public GenericLinearBasis(int dimension) {\n            this.dimension = dimension;\n            basis = new BitSet[dimension];\n            for (int i = 0; i < dimension; i++) {\n                basis[i] = new BitSet(dimension);\n            }\n            or = new BitSet(dimension);\n            buf = new BitSet(dimension);\n        }\n\n        public void add(BitSet bits) {\n            buf.copy(bits);\n            bits = buf;\n            for (int i = dimension - 1; i >= 0; i--) {\n                if (!bits.get(i)) {\n                    continue;\n                }\n                if (or.get(i)) {\n                    bits.xor(basis[i]);\n                    continue;\n                }\n                or.set(i);\n                size++;\n                basis[i].copy(bits);\n                for (int j = i + 1; j < dimension; j++) {\n                    if (!or.get(j) || !basis[j].get(i)) {\n                        continue;\n                    }\n                    basis[j].xor(basis[i]);\n                }\n                return;\n            }\n        }\n\n        public int size() {\n            return size;\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.System.in;\n\npublic class Main {\n    static int n,m;\n    static long mod = 998244353;\n    public static void main(String[] args)throws IOException{\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt(); m = sc.nextInt();\n        int[][] a= new int[n][m];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++) a[i][j]=sc.nextInt();\n        }\n        int rank = getRank(a);\n        long ans = (power(2,n+m-1)-power(2,n+m-rank-1)+mod)%mod;\n        System.out.println(ans);\n    }\n    static long power(long base, long q){\n        long ans = 1;\n        while(q>0){\n            if(q%2==1) ans = ans*base%mod;\n            base = base*base%mod;\n            q /= 2;\n        }\n        return ans;\n    }\n    static int getRank(int[][] A){\n        int rank = 0;\n        for(int j=0;j<m;j++){\n            int pivot = -1;\n            for(int i=rank;i<n;i++){\n                if(A[i][j]>0){\n                    pivot = i;\n                    break;\n                }\n            }\n            if(pivot<0) continue; // following col may still contains non-zero. need to go on\n            if(pivot!=rank){ // swap the chosen line to the top of the concerned area\n                for(int k=0;k<m;k++){\n                    int c = A[pivot][k];\n                    A[pivot][k] = A[rank][k];\n                    A[rank][k] = c;\n                }\n            }\n            for(int i=rank+1;i<n;i++){\n                if(A[i][j]==0) continue;\n                for(int k=j;k<m;k++) A[i][k]^=A[rank][k];\n            }\n            rank++;\n        }\n        return rank;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.BitSet;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        static final int mod = 998244353;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            BitSet[] bitset = new BitSet[n];\n            for (int y = 0; y < n; y++) {\n                bitset[y] = new BitSet();\n                for (int x = 0; x < m; x++) {\n                    if (in.nextInt() == 1) {\n                        bitset[y].set(x);\n                    }\n                }\n            }\n            int rank = 0;\n            for (int y = 0, x = m - 1; y < n; x--) {\n                Arrays.sort(bitset, y, n, Comparator.comparing(BitSet::length).reversed());\n                while (x >= 0 && !bitset[y].get(x)) x--;\n                if (x < 0) break;\n                if (bitset[y].get(x)) {\n                    for (int i = y + 1; i < n; i++) {\n                        bitset[i].xor(bitset[y]);\n                    }\n                    rank++;\n                    y++;\n                }\n            }\n            dump(rank);\n\n            out.println(((pow(2, n) - pow(2, n - rank)) * pow(2, m - 1) % mod + mod) % mod);\n        }\n\n        long pow(int n, int r) {\n            long ans = 1;\n            for (int i = 0; i < r; i++) ans = ans * n % mod;\n            return ans;\n        }\n\n        static void dump(Object... o) {\n            System.err.println(Arrays.deepToString(o));\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.BitSet;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            int[][] a = in.readIntTable(n, m);\n\n            BitSet[] data = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                data[i] = new BitSet();\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    if (a[i][j] == 1) data[i].set(j);\n                }\n            }\n\n            int idx = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                Arrays.sort(data, Comparator.comparing(BitSet::length).reversed());\n                if (!data[idx].get(i)) continue;\n\n                for (int j = 0; j < n; j++) {\n                    if (j != idx && data[j].get(i)) data[j].xor(data[idx]);\n                }\n\n                idx++;\n            }\n\n            int rank = 0;\n            for (int i = 0; i < n; i++) {\n                if (!data[i].isEmpty()) rank++;\n            }\n\n            Modulo modulo = new Modulo(998244353);\n            long tmp1 = modulo.pow(2, n);\n            long tmp2 = modulo.pow(2, n - rank);\n            long tmp3 = modulo.pow(2, m - 1);\n\n            out.printLine(modulo.mlt(modulo.sub(tmp1, tmp2), tmp3));\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class Modulo {\n        long m;\n\n        public Modulo(long m) {\n            this.m = m;\n        }\n\n        public long sub(long a, long b) {\n            return (a - b + m) % m;\n        }\n\n        public long mlt(long a, long b) {\n            return (a * b) % m;\n        }\n\n        public long pow(long a, long x) {\n            long ans = 1 % m;\n            while (x > 0) {\n                if ((x & 1) != 0) {\n                    ans = (ans * a) % m;\n                }\n                x >>= 1;\n                a = (a * a) % m;\n            }\n            return ans;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[][] readIntTable(int rowCount, int columnCount) {\n            int[][] table = new int[rowCount][];\n            for (int i = 0; i < rowCount; i++) {\n                table[i] = readIntArray(columnCount);\n            }\n            return table;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.BitSet;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        static final int mod = 998244353;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            BitSet[] bitset = new BitSet[n];\n            for (int y = 0; y < n; y++) {\n                bitset[y] = new BitSet();\n                for (int x = 0; x < m; x++) {\n                    if (in.nextInt() == 1) {\n                        bitset[y].set(x);\n                    }\n                }\n            }\n            int rank = 0;\n            for (int y = 0, x = m - 1; y < n; x--) {\n                Arrays.sort(bitset, y, n, Comparator.comparing(BitSet::length).reversed());\n                while (x >= 0 && !bitset[y].get(x)) x--;\n                if (x < 0) break;\n                if (bitset[y].get(x)) {\n                    for (int i = y + 1; i < n; i++) {\n                        if (bitset[i].get(x)) {\n                            bitset[i].xor(bitset[y]);\n                        }\n                    }\n                    rank++;\n                    y++;\n                }\n            }\n            dump(rank);\n\n            out.println(((pow(2, n) - pow(2, n - rank)) * pow(2, m - 1) % mod + mod) % mod);\n        }\n\n        long pow(int n, int r) {\n            long ans = 1;\n            for (int i = 0; i < r; i++) ans = ans * n % mod;\n            return ans;\n        }\n\n        static void dump(Object... o) {\n            System.err.println(Arrays.deepToString(o));\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Set;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        int mod = 998244353;\n\n        long pow(long a, long p, int mod) {\n            if (p == 0) {\n                return 1;\n            }\n\n            long t = pow(a, p / 2, mod);\n\n            if (p % 2 != 0) {\n                return (((t * t) % mod) * a) % mod;\n            } else {\n                return (t * t) % mod;\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[][] a = new int[n][m];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = in.nextInt();\n                }\n            }\n\n            MatrixRank rank = new MatrixRank();\n\n            int r = rank.matrixRankFF2(a);\n\n            long ans = pow(2, n + m - 1, mod);\n            ans -= pow(2, n + m - r - 1, mod);\n\n            ans %= mod;\n\n            if (ans < 0) {\n                ans += mod;\n            }\n\n            out.println(ans);\n        }\n\n        class MatrixRank {\n            int matrixRankFF2(int[][] a) {\n                int n = a.length;\n                int m = a[0].length;\n\n//            Arrays.sort(a, (row1, row2) ->\n//            {\n//                for (int i = 0; i < m; i++) {\n//                    if (row1[i] > row2[i]) {\n//                        return -1;\n//                    } else if (row1[i] < row2[i]) {\n//                        return 1;\n//                    }\n//                }\n//                return 0;\n//            });\n//\n//            int rank = 0;\n//\n//            for (int i = 0; i < n; i++) {\n//                int fsi = -1;\n//                for (int j = 0; j < m; j++) {\n//                    if (a[i][j] == 1) {\n//                        fsi = j;\n//                        break;\n//                    }\n//                }\n//\n//                if (fsi == -1) {\n//                    return rank;\n//                }\n//\n//                rank++;\n//\n//                for (int j = i + 1; j < n; j++) {\n//                    if (a[j][fsi] == 1) {\n//                        for (int k = fsi; k < m; k++) {\n//                            a[j][k] = a[j][k] ^ a[i][k];\n//                        }\n//                    }\n//                }\n//\n//                Arrays.sort(a, (row1, row2) ->\n//                {\n//                    for (int j = 0; j < m; j++) {\n//                        if (row1[j] > row2[j]) {\n//                            return -1;\n//                        } else if (row1[j] < row2[j]) {\n//                            return 1;\n//                        }\n//                    }\n//                    return 0;\n//                });\n//            }\n//\n//            return rank;\n\n                int rank = 0;\n\n                Set<Integer> s = new HashSet<>();\n\n                for (int i = 0; i < m; i++) {\n                    int ind = -1;\n                    for (int j = 0; j < n; j++) {\n                        if (a[j][i] == 1 && !s.contains(j)) {\n                            ind = j;\n                            break;\n                        }\n                    }\n\n                    if (ind == -1)\n                        continue;\n\n                    s.add(ind);\n                    rank++;\n\n                    for (int j = ind + 1; j < n; j++) {\n                        if (a[j][i] == 1) {\n                            for (int k = i; k < m; k++) {\n                                a[j][k] ^= a[ind][k];\n                            }\n                        }\n                    }\n                }\n\n                return rank;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        int mod = 998244353;\n\n        long pow(long a, long p, int mod) {\n            if (p == 0) {\n                return 1;\n            }\n\n            long t = pow(a, p / 2, mod);\n\n            if (p % 2 != 0) {\n                return (((t * t) % mod) * a) % mod;\n            } else {\n                return (t * t) % mod;\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[][] a = new int[n][m];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = in.nextInt();\n                }\n            }\n\n            MatrixRank rank = new MatrixRank();\n\n            int r = rank.matrixRankFF2(a);\n\n            long ans = pow(2, n + m - 1, mod);\n            ans -= pow(2, n + m - r - 1, mod);\n\n            ans %= mod;\n\n            if (ans < 0) {\n                ans += mod;\n            }\n\n            out.println(ans);\n        }\n\n        class MatrixRank {\n            int matrixRankFF2(int[][] a) {\n                int n = a.length;\n                int m = a[0].length;\n\n//            Arrays.sort(a, (row1, row2) ->\n//            {\n//                for (int i = 0; i < m; i++) {\n//                    if (row1[i] > row2[i]) {\n//                        return -1;\n//                    } else if (row1[i] < row2[i]) {\n//                        return 1;\n//                    }\n//                }\n//                return 0;\n//            });\n//\n//            int rank = 0;\n//\n//            for (int i = 0; i < n; i++) {\n//                int fsi = -1;\n//                for (int j = 0; j < m; j++) {\n//                    if (a[i][j] == 1) {\n//                        fsi = j;\n//                        break;\n//                    }\n//                }\n//\n//                if (fsi == -1) {\n//                    return rank;\n//                }\n//\n//                rank++;\n//\n//                for (int j = i + 1; j < n; j++) {\n//                    if (a[j][fsi] == 1) {\n//                        for (int k = fsi; k < m; k++) {\n//                            a[j][k] = a[j][k] ^ a[i][k];\n//                        }\n//                    }\n//                }\n//\n//                Arrays.sort(a, (row1, row2) ->\n//                {\n//                    for (int j = 0; j < m; j++) {\n//                        if (row1[j] > row2[j]) {\n//                            return -1;\n//                        } else if (row1[j] < row2[j]) {\n//                            return 1;\n//                        }\n//                    }\n//                    return 0;\n//                });\n//            }\n//\n//            return rank;\n\n                int rank = 0;\n\n                //Set<Integer> s = new HashSet<>();\n\n                boolean[] done = new boolean[n];\n\n                for (int i = 0; i < m; i++) {\n                    int ind = -1;\n                    for (int j = 0; j < n; j++) {\n                        if (a[j][i] == 1 && !done[j]) {\n                            ind = j;\n                            break;\n                        }\n                    }\n\n                    if (ind == -1)\n                        continue;\n\n                    done[ind] = true;\n                    rank++;\n\n                    for (int j = ind + 1; j < n; j++) {\n                        if (a[j][i] == 1) {\n                            for (int k = i; k < m; k++) {\n                                a[j][k] ^= a[ind][k];\n                            }\n                        }\n                    }\n                }\n\n                return rank;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.System.in;\n\npublic class Main {\n    static int n,m;\n    static long mod = 998244353;\n    public static void main(String[] args)throws IOException{\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt(); m = sc.nextInt();\n        int[][] a= new int[n][m];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++) a[i][j]=sc.nextInt();\n        }\n        int rank = getRank(a);\n        long ans = (power(2,n+m-1)-power(2,n+m-rank-1)+mod)%mod;\n        System.out.println(ans);\n    }\n    static long power(long base, long q){\n        long ans = 1;\n        while(q>0){\n            if(q%2==1) ans = ans*base%mod;\n            base = base*base%mod;\n            q /= 2;\n        }\n        return ans;\n    }\n    static int getRank(int[][] A){\n        int rank = 0;\n        for(int j=0;j<m;j++){\n            int pivot = -1;\n            for(int i=rank;i<n;i++){\n                if(A[i][j]>0){\n                    pivot = i;\n                    break;\n                }\n            }\n            if(pivot<0) continue; // following col may still contains non-zero. need to go on\n            if(pivot!=rank){ // swap the chosen line to the top of the concerned area\n                for(int k=0;k<m;k++){\n                    int c = A[pivot][k];\n                    A[pivot][k] = A[rank][k];\n                    A[rank][k] = c;\n                }\n            }\n            for(int i=rank+1;i<n;i++){\n                if(A[i][j]==0) continue;\n                for(int k=j;k<m;k++) A[i][j]^=A[rank][k];\n            }\n            rank++;\n        }\n        return rank;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n\n\n  private static void solve() {\n     int n = ni();\n     int m = ni();\n     int[][] mat = ntable(n, m);\n\n     System.out.println(solve(mat));\n  }\n\n\n  private static long solve(int[][] mat) {\n\n    int n = mat.length;\n    int m = mat[0].length;\n\n    int rank = rank(mat, 2);\n\n    int mod = 998244353;\n    long[] p2 = new long[1000];\n    p2[0] = 1;\n    for (int i = 0; i < p2.length - 1; i++) {\n      p2[i + 1] = p2[i] * 2 % mod;\n    }\n\n    int[][] fif = enumFIF(1000, mod);\n\n    long ret = 0;\n    for (int i = 1; i <= rank; i ++) {\n      long now = 0;\n      for (int j = 1; j <= i; j += 2) {\n        now += CX(rank, i, mod, fif) * CX(i, j, mod, fif) % mod;\n        now %= mod;\n      }\n      ret += now * p2[m - i] % mod * p2[n - rank] % mod ;\n      ret %= mod;\n    }\n    return ret;\n  }\n\n  public static long CX(long n, long r, int p, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    int np = (int) (n % p), rp = (int) (r % p);\n    if (np < rp)\n      return 0;\n    if (n == 0 && r == 0)\n      return 1;\n    int nrp = np - rp;\n    if (nrp < 0)\n      nrp += p;\n    return (long) fif[0][np] * fif[1][rp] % p * fif[1][nrp] % p * CX(n / p, r / p, p, fif) % p;\n  }\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static int rank(int[][] M, int p) {\n    if (M.length == 0)\n      return 0;\n    int n = M.length, m = M[0].length;\n\n    // Forward Elimination\n    for (int i = 0; i < n; i++) {\n      // select pivot\n      boolean pivotFound = false;\n      out: for (int pi = i; pi < n; pi++) {\n        for (int pj = i; pj < m; pj++) {\n          if (M[pi][pj] != 0) {\n            // pivot found\n            if (pj != i) {\n              // swap columns\n              for (int k = 0; k < n; k++) {\n                int d = M[k][pj];\n                M[k][pj] = M[k][i];\n                M[k][i] = d;\n              }\n            }\n            if (pi != i) {\n              // swap rows\n              int[] d = M[pi];\n              M[pi] = M[i];\n              M[i] = d;\n            }\n            pivotFound = true;\n            break out;\n          }\n        }\n      }\n      if (!pivotFound)\n        return i;\n\n      long ID = invl(M[i][i], p);\n      M[i][i] = 1;\n      for (int j = i + 1; j < m; j++) {\n        M[i][j] = (int) (M[i][j] * ID % p);\n      }\n\n      for (int j = i + 1; j < n; j++) {\n        long B = p - M[j][i];\n        M[j][i] = 0;\n        for (int k = i + 1; k < m; k++) {\n          M[j][k] = (int) ((M[j][k] + M[i][k] * B) % p);\n        }\n      }\n    }\n    return n;\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        int mod = 998244353;\n\n        long pow(long a, long p, int mod) {\n            if (p == 0) {\n                return 1;\n            }\n\n            long t = pow(a, p / 2, mod);\n\n            if (p % 2 != 0) {\n                return (((t * t) % mod) * a) % mod;\n            } else {\n                return (t * t) % mod;\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[][] a = new int[n][m];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = in.nextInt();\n                }\n            }\n\n            MatrixRank rank = new MatrixRank();\n\n            int r = rank.matrixRankFF2(a);\n\n            long ans = pow(2, n + m - 1, mod);\n            ans -= pow(2, n + m - r - 1, mod);\n\n            ans %= mod;\n\n            if (ans < 0) {\n                ans += mod;\n            }\n\n            out.println(ans);\n        }\n\n        class MatrixRank {\n            int matrixRankFF2(int[][] a) {\n                int n = a.length;\n                int m = a[0].length;\n\n                Arrays.sort(a, (row1, row2) ->\n                {\n                    for (int i = 0; i < m; i++) {\n                        if (row1[i] > row2[i]) {\n                            return -1;\n                        } else if (row1[i] < row2[i]) {\n                            return 1;\n                        }\n                    }\n                    return 0;\n                });\n\n                int rank = 0;\n\n                for (int i = 0; i < n; i++) {\n                    int fsi = -1;\n                    for (int j = 0; j < m; j++) {\n                        if (a[i][j] == 1) {\n                            fsi = j;\n                            break;\n                        }\n                    }\n\n                    if (fsi == -1) {\n                        return rank;\n                    }\n\n                    rank++;\n\n                    for (int j = i + 1; j < n; j++) {\n                        if (a[j][fsi] == 1) {\n                            for (int k = fsi; k < m; k++) {\n                                a[j][k] = 1 - a[j][k];\n                            }\n                        }\n                    }\n                }\n\n                return rank;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n    int[][] mat = ntable(n, m);\n\n    System.out.println(solve(mat));\n\n\n    // Random gen = new Random();\n    // while( true) {\n    // int n = gen.nextInt(5) + 1;\n    // int m = gen.nextInt(5) + 1;\n    // int[][] mat = new int[n][m];\n    // for (int i = 0; i < n; i ++) {\n    // for (int j = 0; j < m; j ++) {\n    // mat[i][j] = gen.nextInt(2);\n    // }\n    // }\n    //\n    // long ret2 = solve(mat);\n    // long ret = solve(mat);\n    // if (ret != ret2) {\n    // System.out.println(ret + \" \" + ret2);\n    // System.out.println(Arrays.deepToString(mat));\n    // break;\n    // }\n    // }\n  }\n\n  private static long solve2(int[][] mat) {\n    int n = mat.length;\n    int m = mat[0].length;\n\n    int ret = 0;\n    for (int i = 0; i < (1 << n); i++) {\n      for (int j = 0; j < (1 << m); j++) {\n\n        int sum = 0;\n        for (int p = 0; p < n; p++) {\n          if (((i >> p) & 1) == 0)\n            continue;\n          for (int q = 0; q < m; q++) {\n            if (((j >> q) & 1) == 0)\n              continue;\n\n            sum += mat[p][q];\n          }\n        }\n        if (sum % 2 == 1) {\n          ret++;\n        }\n      }\n    }\n    return ret;\n  }\n\n  private static long solve(int[][] mat) {\n\n    int n = mat.length;\n    int m = mat[0].length;\n\n    int rank = rank(mat, 2);\n\n    int mod = 998244353;\n    long[] p2 = new long[1000];\n    p2[0] = 1;\n    for (int i = 0; i < p2.length - 1; i++) {\n      p2[i + 1] = p2[i] * 2 % mod;\n    }\n\n    int[][] fif = enumFIF(1000, mod);\n\n    long ret = 0;\n    for (int i = 1; i <= rank; i += 2) {\n      long now = CX(rank, i, mod, fif) * ((p2[rank - i] + p2[rank - i] - 1) % mod) % mod;\n      ret += now * p2[n - rank] % mod * p2[m - rank] % mod;\n      ret %= mod;\n    }\n    return ret;\n  }\n\n  public static long CX(long n, long r, int p, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    int np = (int) (n % p), rp = (int) (r % p);\n    if (np < rp)\n      return 0;\n    if (n == 0 && r == 0)\n      return 1;\n    int nrp = np - rp;\n    if (nrp < 0)\n      nrp += p;\n    return (long) fif[0][np] * fif[1][rp] % p * fif[1][nrp] % p * CX(n / p, r / p, p, fif) % p;\n  }\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static int rank(int[][] M, int p) {\n    if (M.length == 0)\n      return 0;\n    int n = M.length, m = M[0].length;\n\n    // Forward Elimination\n    for (int i = 0; i < n; i++) {\n      // select pivot\n      boolean pivotFound = false;\n      out: for (int pi = i; pi < n; pi++) {\n        for (int pj = i; pj < m; pj++) {\n          if (M[pi][pj] != 0) {\n            // pivot found\n            if (pj != i) {\n              // swap columns\n              for (int k = 0; k < n; k++) {\n                int d = M[k][pj];\n                M[k][pj] = M[k][i];\n                M[k][i] = d;\n              }\n            }\n            if (pi != i) {\n              // swap rows\n              int[] d = M[pi];\n              M[pi] = M[i];\n              M[i] = d;\n            }\n            pivotFound = true;\n            break out;\n          }\n        }\n      }\n      if (!pivotFound)\n        return i;\n\n      long ID = invl(M[i][i], p);\n      M[i][i] = 1;\n      for (int j = i + 1; j < m; j++) {\n        M[i][j] = (int) (M[i][j] * ID % p);\n      }\n\n      for (int j = i + 1; j < n; j++) {\n        long B = p - M[j][i];\n        M[j][i] = 0;\n        for (int k = i + 1; k < m; k++) {\n          M[j][k] = (int) ((M[j][k] + M[i][k] * B) % p);\n        }\n      }\n    }\n    return n;\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            boolean[][] mat = new boolean[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    mat[i][j] = in.readChar() == '1';\n                }\n            }\n            GeneralizedLinearBasis glb = new GeneralizedLinearBasis(m);\n            for (int i = 0; i < n; i++) {\n                glb.add(mat[i]);\n            }\n\n            NumberTheory.Modular mod = new NumberTheory.Modular(998244353);\n            NumberTheory.Power pow = new NumberTheory.Power(mod);\n            int rowSet = mod.subtract(pow.pow(2, n), pow.pow(2, n - glb.size()));\n            int ans = mod.mul(rowSet, pow.pow(2, m - 1));\n\n            out.println(ans);\n        }\n\n    }\n\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return modular.valueOf(1);\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n    }\n\n    static class GeneralizedLinearBasis {\n        private boolean[][] basis;\n        private int size;\n        private int dimension;\n        private boolean[] or;\n        private boolean[] buf;\n\n        public GeneralizedLinearBasis(int dimension) {\n            this.dimension = dimension;\n            basis = new boolean[dimension][dimension];\n            or = new boolean[dimension];\n            buf = new boolean[dimension];\n        }\n\n        public void add(boolean[] bits) {\n            System.arraycopy(bits, 0, buf, 0, dimension);\n            bits = buf;\n            for (int i = dimension - 1; i >= 0; i--) {\n                if (!bits[i]) {\n                    continue;\n                }\n                if (or[i]) {\n                    for (int j = 0; j < dimension; j++) {\n                        bits[j] = bits[j] != basis[i][j];\n                    }\n                    continue;\n                }\n                or[i] = true;\n                size++;\n                System.arraycopy(bits, 0, basis[i], 0, dimension);\n                for (int j = i + 1; j < dimension; j++) {\n                    if (!or[j] || !basis[j][i]) {\n                        continue;\n                    }\n                    for (int k = 0; k < dimension; k++) {\n                        basis[j][k] = basis[j][k] != basis[i][k];\n                    }\n                }\n                return;\n            }\n        }\n\n        public int size() {\n            return size;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final long MOD = 998244353;\n\tstatic int N, M;\n\n\tpublic static void main(String[] args) {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tint[][] mat = new int[N][M];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tmat[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tint dim = 0;\n\t\tint col = 0;\n\t\tboolean[] fix = new boolean[N];\n\t\tfor (int i = 0; col < M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (!fix[j] && mat[j][col] == 1) {\n\t\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\t\tif (k == j || mat[k][col] == 0) continue;\n\t\t\t\t\t\tfor (int l = 0; l < M; l++) {\n\t\t\t\t\t\t\tmat[k][l] ^= mat[j][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++dim;\n\t\t\t\t\tfix[j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++col;\n\t\t}\n//\t\tfor (int i = 0; i < N; i++) {\n//\t\t\tfor (int j = 0; j < M; j++) {\n//\t\t\t\tSystem.err.print(mat[i][j] + \" \");\n//\t\t\t}\n//\t\t\tSystem.err.println();\n//\t\t}\n\n\t\tlong[] pow2 = new long[301];\n\t\tpow2[0] = 1;\n\t\tfor (int i = 1; i < pow2.length; i++) {\n\t\t\tpow2[i] = pow2[i - 1] * 2 % MOD;\n\t\t}\n\t\tlong[][] comb = new long[301][301];\n\t\tfor (int i = 0; i < comb.length; i++) {\n\t\t\tcomb[i][0] = comb[i][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < comb.length; i++) {\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tcomb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 1; i <= dim; i++) {\n\t\t\tlong here = 0;\n\t\t\tfor (int j = 1; j <= i; j += 2) {\n\t\t\t\there += comb[i][j];\n\t\t\t\there %= MOD;\n\t\t\t}\n\t\t\there *= comb[dim][i];\n\t\t\there %= MOD;\n\t\t\there *= pow2[M - i];\n\t\t\there %= MOD;\n\t\t\tans += here;\n\t\t\tans %= MOD;\n\t\t}\n\t\tans *= pow2[N - dim];\n\t\tans %= MOD;\n\t\tSystem.out.println(ans);\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.util.BitSet;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tE_OddSubrectangles solver = new E_OddSubrectangles();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class E_OddSubrectangles {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int MOD = 998244353;\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\t\t\tBitSet[] a = new BitSet[height];\n\t\t\tfor (int r = 0; r < height; r++) {\n\t\t\t\ta[r] = new BitSet(width);\n\t\t\t\tfor (int c = 0; c < width; c++) {\n\t\t\t\t\tint x = in.nextInt();\n\t\t\t\t\tif (x == 1) {\n\t\t\t\t\t\ta[r].set(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint rank = calcRank(a.clone());\n\n\t\t\tlong[] p2 = new long[height + width + 1];\n\t\t\tp2[0] = 1;\n\t\t\tfor (int i = 1; i < p2.length; i++) {\n\t\t\t\tp2[i] = 2 * p2[i - 1] % MOD;\n\t\t\t}\n\t\t\tlong ans = p2[height + width - 1] - p2[height + width - 1 - rank];\n\t\t\tif (ans < 0) {\n\t\t\t\tans += MOD;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate int calcRank(BitSet[] rows) {\n\t\t\tdiagonalize(rows);\n\t\t\tint res = 0;\n\t\t\tfor (BitSet row : rows) {\n\t\t\t\tif (row.cardinality() != 0) {\n\t\t\t\t\t++res;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate void diagonalize(BitSet[] a) {\n\t\t\tint lastR = a.length - 1;\n\t\t\tint r = 0;\n\t\t\twhile (r <= lastR) {\n\t\t\t\tif (a[r].cardinality() == 0) {\n\t\t\t\t\tBitSet t = a[r];\n\t\t\t\t\ta[r] = a[lastR];\n\t\t\t\t\ta[lastR] = t;\n\t\t\t\t\t--lastR;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint or = a[r].nextSetBit(r);\n\t\t\t\tif (or != r) {\n\t\t\t\t\tfor (int i = 0; i <= lastR; i++) {\n\t\t\t\t\t\tboolean bitR = a[i].get(r);\n\t\t\t\t\t\tboolean bitOR = a[i].get(or);\n\t\t\t\t\t\ta[i].set(r, bitOR);\n\t\t\t\t\t\ta[i].set(or, bitR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = r + 1; i <= lastR; i++) {\n\t\t\t\t\tif (a[i].get(r)) {\n\t\t\t\t\t\ta[i].xor(a[r]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t++r;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static class bitset {\n\t\tlong[] a=new long[8];\n\t\tpublic void set(long v,int id) {\n\t\t\ta[id/50]|=v<<(id%50);\n\t\t}\n\t\tpublic int get(int id) {\n\t\t\treturn (int)((a[id/50]>>(id%50))&1);\n\t\t}\n\t\tpublic void xor(bitset rhs) {\n\t\t\tfor (int i=0;i<8;++i) a[i]^=rhs.a[i];\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint m=in.nextInt();\n\t\tbitset[] bit=new bitset[n];\n\t\tfor (int i=0;i<n;++i) {\n\t\t\tbit[i]=new bitset();\n\t\t\tfor (int j=0;j<m;++j) {\n\t\t\t\tint x=in.nextInt();\n\t\t\t\tbit[i].set(x,j);\n\t\t\t}\n\t\t}\n\t\tlong mod=998244353;\n\t\tlong[] p=new long[n+m];\n\t\tp[0]=1;\n\t\tfor (int i=1;i<n+m;++i) p[i]=(p[i-1]+p[i-1])%mod;\n\t\tint rk=0;\n\t\tfor (int i=0;i<m;++i) {\n\t\t\tboolean flag=false;\n\t\t\tfor (int j=i;j<n;++j) if (bit[j].get(i)==1) {\n\t\t\t\tbitset tmp=bit[j];\n\t\t\t\tbit[j]=bit[i];\n\t\t\t\tbit[i]=tmp;\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t\tif (!flag) continue;\n\t\t\t++rk;\n\t\t\tfor (int j=i+1;j<n;++j) if (bit[j].get(i)==1)\n\t\t\t\tbit[j].xor(bit[i]);\n\t\t}\n\t\tSystem.out.println((p[n+m-1]-p[n+m-1-rk]+mod)%mod);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n\n    int mod = 998244353;\n    int[][] p = ntable(n, m);\n\n    int rank = rank(p, 2);\n\n    int[][] fif = enumFIF(n + m, mod);\n\n    long ret = 0;\n    for (int i = 1; i <= rank; i += 2) {\n      ret += C(rank, i, mod, fif) * pow(2, (n - rank) + (m - rank), mod) % mod\n          * pow(3, rank - i, mod) % mod;\n      ret %= mod;\n    }\n    System.out.println(ret);\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n  }\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n\n  public static long pow(long a, long n, long mod) {\n    // a %= mod;\n    long ret = 1;\n    int x = 63 - Long.numberOfLeadingZeros(n);\n    for (; x >= 0; x--) {\n      ret = ret * ret % mod;\n      if (n << 63 - x < 0)\n        ret = ret * a % mod;\n    }\n    return ret;\n  }\n\n\n  public static int rank(int[][] M, int p) {\n    if (M.length == 0)\n      return 0;\n    int n = M.length, m = M[0].length;\n\n    // Forward Elimination\n    for (int i = 0; i < n; i++) {\n      // select pivot\n      boolean pivotFound = false;\n      out: for (int pi = i; pi < n; pi++) {\n        for (int pj = i; pj < m; pj++) {\n          if (M[pi][pj] != 0) {\n            // pivot found\n            if (pj != i) {\n              // swap columns\n              for (int k = 0; k < n; k++) {\n                int d = M[k][pj];\n                M[k][pj] = M[k][i];\n                M[k][i] = d;\n              }\n            }\n            if (pi != i) {\n              // swap rows\n              int[] d = M[pi];\n              M[pi] = M[i];\n              M[i] = d;\n            }\n            pivotFound = true;\n            break out;\n          }\n        }\n      }\n      if (!pivotFound)\n        return i;\n\n      long ID = invl(M[i][i], p);\n      M[i][i] = 1;\n      for (int j = i + 1; j < m; j++) {\n        M[i][j] = (int) (M[i][j] * ID % p);\n      }\n\n      for (int j = i + 1; j < n; j++) {\n        long B = p - M[j][i];\n        M[j][i] = 0;\n        for (int k = i + 1; k < m; k++) {\n          M[j][k] = (int) ((M[j][k] + M[i][k] * B) % p);\n        }\n      }\n    }\n    return n;\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lewin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        EOddSubrectangles solver = new EOddSubrectangles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EOddSubrectangles {\n        int mod = 998244353;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), m = in.nextInt();\n            int[][] arr = new int[n][m];\n            BigInteger[] bs = new BigInteger[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = in.readIntArray(m);\n                bs[i] = BigInteger.ZERO;\n                for (int j = 0; j < m; j++) {\n                    if (arr[i][j] == 1) bs[i] = bs[i].setBit(j);\n                }\n            }\n\n            EOddSubrectangles.Basis bb = new EOddSubrectangles.Basis();\n            for (int i = 0; i < n; i++) {\n                bb.add(bs[i]);\n            }\n\n            if (bb.size == 0) {\n                out.println(0);\n                return;\n            }\n\n            long ans = 1;\n            for (int j = 0; j < bb.size; j++) ans = ans * 2 % mod;\n            ans = (ans + mod - 1) % mod;\n            for (int j = 0; j < m - 1; j++) ans = ans * 2 % mod;\n            for (int j = bb.size; j < n; j++) ans = ans * 2 % mod;\n            out.println(ans);\n        }\n\n        static class Basis {\n            public int size;\n            public BigInteger[] basis;\n\n            public Basis() {\n                basis = new BigInteger[301];\n                size = 0;\n            }\n\n            public boolean add(BigInteger x) {\n                for (int i = size - 1; i >= 0; i--) {\n                    BigInteger t = x.xor(basis[i]);\n                    if (t.compareTo(x) < 0) {\n                        x = t;\n                    }\n                }\n                if (x.compareTo(BigInteger.ZERO) == 0) return false;\n                basis[size++] = x;\n                for (int i = size - 2; i >= 0; i--) {\n                    if (basis[i].compareTo(basis[i + 1]) > 0) {\n                        BigInteger t = basis[i + 1];\n                        basis[i + 1] = basis[i];\n                        basis[i] = t;\n                    }\n                }\n                return true;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int tokens) {\n            int[] ret = new int[tokens];\n            for (int i = 0; i < tokens; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            boolean[][] mat = new boolean[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    mat[i][j] = in.readChar() == '1';\n                }\n            }\n            GeneralizedLinearBasis glb = new GeneralizedLinearBasis(m);\n            for (int i = 0; i < n; i++) {\n                glb.add(mat[i]);\n            }\n\n            NumberTheory.Modular mod = new NumberTheory.Modular(998244353);\n            NumberTheory.Power pow = new NumberTheory.Power(mod);\n            int rowSet = mod.subtract(pow.pow(2, n), pow.pow(2, n - glb.size()));\n            int ans = mod.mul(rowSet, pow.pow(2, m - 1));\n\n            out.println(ans);\n        }\n\n    }\n\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return modular.valueOf(1);\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n    }\n\n    static class GeneralizedLinearBasis {\n        private boolean[][] basis;\n        private int size;\n        private int dimension;\n        private boolean[] or;\n\n        public GeneralizedLinearBasis(int dimension) {\n            this.dimension = dimension;\n            basis = new boolean[dimension][dimension];\n            or = new boolean[dimension];\n        }\n\n        public void add(boolean[] bits) {\n            for (int i = dimension - 1; i >= 0; i--) {\n                if (!bits[i]) {\n                    continue;\n                }\n                if (or[i]) {\n                    for (int j = 0; j < dimension; j++) {\n                        bits[i] = bits[j] != basis[i][j];\n                    }\n                    continue;\n                }\n                or[i] = true;\n                size++;\n                System.arraycopy(bits, 0, basis[i], 0, dimension);\n                for (int j = i + 1; j < dimension; j++) {\n                    if (!or[j] || !basis[j][i]) {\n                        continue;\n                    }\n                    for (int k = 0; k < dimension; k++) {\n                        basis[j][k] = basis[j][k] != basis[i][k];\n                    }\n                }\n                return;\n            }\n        }\n\n        public int size() {\n            return size;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.util.BitSet;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tE_OddSubrectangles solver = new E_OddSubrectangles();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class E_OddSubrectangles {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tfinal int MOD = 998244353;\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\t\t\tBitSet[] a = new BitSet[height];\n\t\t\tfor (int r = 0; r < height; r++) {\n\t\t\t\ta[r] = new BitSet(width);\n\t\t\t\tfor (int c = 0; c < width; c++) {\n\t\t\t\t\tint x = in.nextInt();\n\t\t\t\t\tif (x == 1) {\n\t\t\t\t\t\ta[r].set(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint rank = calcRank(a.clone());\n\n\t\t\tlong[] p2 = new long[height + width + 1];\n\t\t\tp2[0] = 1;\n\t\t\tfor (int i = 1; i < p2.length; i++) {\n\t\t\t\tp2[i] = 2 * p2[i - 1] % MOD;\n\t\t\t}\n\t\t\tlong ans = p2[height + width - 1] - p2[height + width - 1 - rank];\n\t\t\tif (ans < 0) {\n\t\t\t\tans += MOD;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate int calcRank(BitSet[] rows) {\n\t\t\tdiagonalize(rows);\n\t\t\tint res = 0;\n\t\t\tfor (BitSet row : rows) {\n\t\t\t\tif (row.cardinality() != 0) {\n\t\t\t\t\t++res;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate void diagonalize(BitSet[] a) {\n\t\t\tint lastR = a.length - 1;\n\t\t\tint r = 0;\n\t\t\twhile (r <= lastR) {\n\t\t\t\tif (a[r].cardinality() == 0) {\n\t\t\t\t\tBitSet t = a[r];\n\t\t\t\t\ta[r] = a[lastR];\n\t\t\t\t\ta[lastR] = t;\n\t\t\t\t\t--lastR;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint or = a[r].nextSetBit(r);\n\t\t\t\tif (or != r) {\n\t\t\t\t\tfor (int i = 0; i <= lastR; i++) {\n\t\t\t\t\t\tboolean bitR = a[i].get(r);\n\t\t\t\t\t\tboolean bitOR = a[i].get(or);\n\t\t\t\t\t\ta[i].set(r, bitOR);\n\t\t\t\t\t\ta[i].set(or, bitR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = r + 1; i <= lastR; i++) {\n\t\t\t\t\ta[i].xor(a[r]);\n\t\t\t\t}\n\n\t\t\t\t++r;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.UInt32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var a = Enumerate(n, x => new int[m]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    a[i][j] = ri;\n            var used = new bool[n];\n            var vec = Enumerate(m, x => -1);\n            for (int j = 0; j < m; j++) {\n                for (int i = 0; i < n; i++) {\n                    if (used[i]) continue;\n                    if (a[i][j] == 1) { vec[j] = i; break; }\n                }\n                if (vec[j] == -1) continue;\n                for (int i = 0; i < n; i++) {\n                    if (i == vec[j]) continue;\n                    if (a[i][j] == 1) a[i] = xor(a[i], a[vec[j]]);\n                }\n                used[vec[j]] = true;\n            }\n            foreach(var x in a)\n                Debug.WriteLine(x.AsJoinedString());\n            var cnt = used.Count(x => x == false);\n            Debug.WriteLine(cnt);\n            var ans = ModInt.Pow(2, n + m) - ModInt.Pow(2, cnt) * ModInt.Pow(2, m);\n            ans *= ModInt.Inverse(2);\n            Console.WriteLine(ans);\n\n        }\n        int[] xor(int[] a, int[] b) {\n            var res = new int[a.Length];\n            for (int i = 0; i < a.Length; i++)\n                res[i] = a[i] ^ b[i];\n            return res;\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = 998244353;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n    int F => int.Parse(Str);\n    long FL => long.Parse(Str);\n    int[] G => Strs.Select(int.Parse).ToArray();\n    long[] GL => Strs.Select(long.Parse).ToArray();\n    string Str => ReadLine();\n    string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n    const int MOD = 998244353;\n    public K()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        WriteLine(Solve());\n        Out.Flush();\n    }\n    long Solve()\n    {\n        var I = G;\n        int Y = I[0], X = I[1];\n        var mat = new BitVector[Y];\n        for (var y = 0; y < Y; y++)\n        {\n            var row = new bool[X];\n            I = G;\n            for (var x = 0; x < X; x++) row[x] = I[x] != 0;\n            mat[y] = new BitVector(row);\n        }\n        var r = 0;\n        for (var c = 0; c < X; c++)\n        {\n            int y = r;\n            while (y < Y && !mat[y][c]) y++;\n            if (y == Y) continue;\n            if (y != r) mat[r].Add(mat[y]);\n            for (y = r + 1; y < Y; y++) if (mat[y][c]) mat[y].Add(mat[r]);\n            r++;\n        }\n        return (Pow(X + Y - 1) - Pow(X + Y - r - 1) + MOD) % MOD;\n    }\n    public static long Pow(long b)\n    {\n        var p = 1L;\n        var x = 2;\n        while (b > 0)\n        {\n            if ((b & 1) == 1) p = p * x % MOD;\n            b >>= 1;\n            x = x * x % MOD;\n        }\n        return p;\n    }\n}\nclass BitVector\n{\n    readonly int N;\n    readonly ulong[] bits;\n    public bool this[int i] => (bits[i / 64] & (1ul << (i % 64))) != 0;\n    public BitVector(int n) { N = n; bits = new ulong[(n + 63) / 64]; }\n    public BitVector(bool[] b) : this(b.Length)\n    {\n        for (var i = 0; i < N; i++) if (b[i]) bits[i / 64] |= 1ul << (i % 64);\n    }\n    public void Add(BitVector v)\n    {\n        for (var i = 0; i < bits.Length; i++) bits[i] ^= v.bits[i];\n    }\n    public static BitVector operator ^(BitVector a, BitVector b)\n    {\n        var c = new BitVector(a.N);\n        for (var i = 0; i < a.bits.Length; i++) c.bits[i] = a.bits[i] ^ b.bits[i];\n        return c;\n    }\n    public static BitVector operator |(BitVector a, BitVector b)\n    {\n        var c = new BitVector(a.N);\n        for (var i = 0; i < a.bits.Length; i++) c.bits[i] = a.bits[i] | b.bits[i];\n        return c;\n    }\n    public static BitVector operator &(BitVector a, BitVector b)\n    {\n        var c = new BitVector(a.N);\n        for (var i = 0; i < a.bits.Length; i++) c.bits[i] = a.bits[i] & b.bits[i];\n        return c;\n    }\n    public static BitVector operator !(BitVector a)\n    {\n        var c = new BitVector(a.N);\n        for (var i = 0; i < a.bits.Length; i++) c.bits[i] = ~a.bits[i];\n        return c;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main(string[] args)\n    {\n        sc.Multi(out n, out m);\n        var a = new int[n][];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = sc.IntArr;\n        }\n        int r = rank(a);\n        MyMath.Mod = M2;\n        Prt((MyMath.pow(2, r) - 1) * MyMath.pow(2, n - r) % M2 * MyMath.pow(2, m - 1) % M2);\n        sw.Flush();\n    }\n    static int n, m;\n    static int compare(int[] a, int[] b) {\n        for (int i = 0; i < a.Length; i++)\n        {\n            if (a[i] != b[i]) {\n                return b[i].CompareTo(a[i]);\n            }\n        }\n        return 0;\n    }\n    static int rank(int[][] a) {\n        while (true) {\n            bool f = false;\n            Array.Sort(a, compare);\n            for (int i = 0; i + 1 < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    if (a[i][j] != a[i + 1][j]) break;\n                    if (a[i][j] == 1 && a[i + 1][j] == 1) {\n                        a[i + 1] = xor(a[i], a[i + 1]);\n                        f = true;\n                        break;\n                    }\n                }\n            }\n            if (!f) break;\n        }\n        int ret = n;\n        for (int i = 0; i < n; i++)\n        {\n            bool f = true;\n            for (int j = 0; j < m; j++)\n            {\n                if (a[i][j] != 0) f = false;\n            }\n            if (f) --ret;\n        }\n        return ret;\n    }\n    static int[] xor(int[] a, int[] b) {\n        var ret = new int[a.Length];\n        for (int i = 0; i < a.Length; i++)\n        {\n            ret[i] = a[i] ^ b[i];\n        }\n        return ret;\n    }\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n\nstatic class MyMath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long pow(long a, long b) {\n        a %= Mod;\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts, invs;\n    public static void setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 1; i <= n; i++) facts[i] = facts[i - 1] * i % Mod;\n        invs = new long[n + 1];\n        invs[n] = inv(facts[n]);\n        for (int i = n; i > 0 ; i--) invs[i - 1] = invs[i] * i % Mod;\n    }\n    public static long comb(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[r] % Mod * invs[n - r] % Mod;\n        if (n - r < r) r = n - r;\n        long numer = 1, denom = 1;\n        for (long i = 0; i < r; i++) {\n            numer = numer * ((n - i) % Mod) % Mod;\n            denom = denom * ((i + 1) % Mod) % Mod;\n        }\n        return numer * inv(denom) % Mod;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n    public static bool nextPermutation<T>(IList<T> p) where T : struct, IComparable<T> {\n        for (int i = p.Count - 2; i >= 0; --i) {\n            if (p[i].CompareTo(p[i + 1]) < 0) {\n                for (int j = p.Count - 1; ; --j) {\n                    if (p[j].CompareTo(p[i]) > 0) {\n                        p.swap(i, j);\n                        for(++i, j = p.Count - 1; i < j; ++i, --j)\n                            p.swap(i, j);\n\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    public static bool nextPermutation<T>(IList<T> p, Comparison<T> compare) where T : struct {\n        for (int i = p.Count - 2; i >= 0; --i) {\n            if (compare(p[i], p[i + 1]) < 0) {\n                for (int j = p.Count - 1; ; --j) {\n                    if (compare(p[j], p[i]) > 0) {\n                        p.swap(i, j);\n                        for (++i, j = p.Count - 1; i < j; ++i, --j)\n                            p.swap(i, j);\n\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nclass Program{\n\tconst int mod=998244353;\n\tconst long o=1;\n\tstatic int[][] h;\n\tstatic int[] s;\n\tstatic long ans=0,r=1;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\ts=sc.Ia;\n\t\th=new int[s[0]][];\n\t\tfor(int i=0;i<s[0];i++){\n\t\t\th[i]=sc.Ia;\n\t\t}\n\t\tfor(int i=0;i<s[1]-1;i++){\n\t\t\tr*=2;\n\t\t\tr%=mod;\n\t\t}\n\t\tfor(int i=0;i<s[0];i++){\n\t\t\tint[] q=new int[s[1]];\n\t\t\tfor(int j = 0;j<s[1];j++) {\n\t\t\t\tq[j]=h[i][j];\n\t\t\t}\n\t\t\tFu(i-1,q);\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",ans);\n\t}\n\tstatic void Fu(int a,int[] q){\n\t\tif(a==-1){\n\t\t\tbool b=false;\n\t\t\tfor(int j = 0;j<s[1];j++) {\n\t\t\t\tif(q[j]%2==1){b=true;break;}\n\t\t\t}\n\t\t\tif(b){ans+=r;}\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tint[] p=new int[s[1]];\n\t\t\tfor(int j = 0;j<s[1];j++) {p[j]=q[j];}\n\t\t\tFu(a-1,p);\n\t\t\tfor(int j = 0;j<s[1];j++) {\n\t\t\t\tp[j]+=h[a][j];\n\t\t\t}\n\t\t\tFu(a-1,p);\n\t\t}\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.UInt32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var a = Enumerate(n, x => new int[m]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    a[i][j] = ri;\n            var used = new bool[n];\n            var vec = Enumerate(m, x => -1);\n            for (int j = 0; j < m; j++) {\n                for (int i = 0; i < n; i++) {\n                    if (used[i]) continue;\n                    if (a[i][j] == 1) { vec[j] = i; break; }\n                }\n                if (vec[j] == -1) continue;\n                for (int i = 0; i < n; i++) {\n                    if (i == vec[j]) continue;\n                    if (a[i][j] == 1) a[i] = xor(a[i], a[vec[j]]);\n                }\n                used[vec[j]] = true;\n            }\n            var cnt = n - vec.Count(x => x != -1);\n            Debug.WriteLine(cnt);\n            var ans = ModInt.Pow(2, n + m) - ModInt.Pow(2, cnt) * ModInt.Pow(2, m);\n            ans *= ModInt.Inverse(2);\n            Console.WriteLine(ans);\n\n        }\n        int[] xor(int[] a, int[] b) {\n            var res = new int[a.Length];\n            for (int i = 0; i < a.Length; i++)\n                res[i] = a[i] ^ b[i];\n            return res;\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApp51\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] dm = Console.ReadLine().Split().Select(x => int.Parse(x)).ToArray();\n            int[][] mt = new int[dm[0]][];\n            for (int i = 0; i < dm[0]; ++i)\n                mt[i] = Console.ReadLine().Split().Select(x => int.Parse(x)).ToArray();\n            Solution sol = new Solution();\n            Console.WriteLine(sol.GetOddRectangles(mt, dm[0], dm[1]));\n        }\n    }\n\n\n    public class Solution\n    {\n        public int GetOddRectangles(int[][] mt, int N, int M)\n        {\n            int[,] acc = new int[N + 1, M + 1];\n\n            for (int i = 1; i <= N; ++i)\n                for (int j = 1; j <= M; ++j)\n                    acc[i, j] = acc[i - 1, j] + acc[i, j - 1] - acc[i - 1, j - 1] + mt[i - 1][j - 1];\n\n            int sol = 0;\n            for (int i = 1; i <= N; ++i)\n                for (int j = 1; j <= M; ++j)\n                    for (int l = i; l <= N; ++l)\n                        for (int k = j; k <= M; ++k)\n                            sol += (acc[l, k] - acc[l, j - 1] - acc[i - 1, k] + acc[i - 1, j - 1]) & 1;\n            return sol % 998244353;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.UInt32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var a = Enumerate(n, x => new int[m]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    a[i][j] = ri;\n            var used = new bool[n];\n            var vec = Enumerate(m, x => -1);\n            for (int j = 0; j < m; j++) {\n                for (int i = 0; i < n; i++) {\n                    if (used[i]) continue;\n                    if (a[i][j] == 1) { vec[j] = i; break; }\n                }\n                if (vec[j] == -1) continue;\n                for (int i = 0; i < n; i++) {\n                    if (i == vec[j]) continue;\n                    if (a[i][j] == 1) a[i] = xor(a[i], a[vec[j]]);\n                }\n                used[vec[j]] = true;\n            }\n            var cnt = used.Count(x => x == false);\n            Debug.WriteLine(cnt);\n            var ans = ModInt.Pow(2, n + m) - ModInt.Pow(2, cnt) * ModInt.Pow(2, m);\n            ans *= ModInt.Inverse(2);\n            Console.WriteLine(ans);\n\n        }\n        int[] xor(int[] a, int[] b) {\n            var res = new int[a.Length];\n            for (int i = 0; i < a.Length; i++)\n                res[i] = a[i] ^ b[i];\n            return res;\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n    int F => int.Parse(Str);\n    long FL => long.Parse(Str);\n    int[] G => Strs.Select(int.Parse).ToArray();\n    long[] GL => Strs.Select(long.Parse).ToArray();\n    string Str => ReadLine();\n    string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n    const int MOD = 998244353;\n    public K()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        WriteLine(Solve());\n        Out.Flush();\n    }\n    Random rand = new Random();\n    long Solve()\n    {\n        var I = G;\n        int Y = I[0], X = I[1];\n        var mat = new bool[Y][];\n        for (var y = 0; y < Y; y++)\n        {\n            mat[y] = new bool[X];\n            I = G;\n            for (var x = 0; x < X; x++) mat[y][x] = I[x] != 0;\n        }\n        var r = 0;\n        for (var c = 0; c < X; c++)\n        {\n            int y = r;\n            while (y < Y && !mat[y][c]) y++;\n            if (y == Y) continue;\n            if (y != r) AddTo(mat[r], mat[y]);\n            for (y = r + 1; y < Y; y++) if (mat[y][c]) AddTo(mat[y], mat[r]);\n            r++;\n        }\n        return (Pow(2, X + Y - 1, MOD) - Pow(2, X + Y - r - 1, MOD) + MOD) % MOD;\n    }\n    void Print(bool[] a) => WriteLine(string.Join(\"\", a.Select(b => b ? 1 : 0)));\n    public static long Pow(long a, long b, long mod)\n    {\n        var p = 1L;\n        var x = a;\n        while (b > 0)\n        {\n            if ((b & 1) == 1) p = (p * x) % mod;\n            b >>= 1;\n            x = (x * x) % mod;\n        }\n        return p;\n    }\n    // a += b\n    void AddTo(bool[] a, bool[] b)\n    {\n        var n = a.Length;\n        for (var i = 0; i < n; i++) a[i] = a[i] ^ b[i];\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n    int F => int.Parse(Str);\n    long FL => long.Parse(Str);\n    int[] G => Strs.Select(int.Parse).ToArray();\n    long[] GL => Strs.Select(long.Parse).ToArray();\n    string Str => ReadLine();\n    string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n    const int MOD = 998244353;\n    public K()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        WriteLine(Solve());\n        Out.Flush();\n    }\n    long Solve()\n    {\n        var I = G;\n        int Y = I[0], X = I[1];\n        var mat = new bool[Y][];\n        for (var y = 0; y < Y; y++)\n        {\n            mat[y] = new bool[X];\n            I = G;\n            for (var x = 0; x < X; x++) mat[y][x] = I[x] != 0;\n        }\n        var r = 0;\n        for (var c = 0; c < X; c++)\n        {\n            int y = r;\n            while (y < Y && !mat[y][c]) y++;\n            if (y == Y) continue;\n            if (y != r) { var t = mat[y]; mat[y] = mat[r]; mat[r] = t; }\n            for (y = r + 1; y < Y; y++) if (mat[y][c]) AddTo(mat[y], mat[r]);\n            r++;\n        }\n        return Pow(2, X + Y - 1, MOD) - Pow(2, X + Y - r - 1, MOD);\n    }\n    public static long Pow(long a, long b, long mod)\n    {\n        var p = 1L;\n        var x = a;\n        while (b > 0)\n        {\n            if ((b & 1) == 1) p = (p * x) % mod;\n            b >>= 1;\n            x = (x * x) % mod;\n        }\n        return p;\n    }\n    // a += b\n    void AddTo(bool[] a, bool[] b)\n    {\n        var n = a.Length;\n        for (var i = 0; i < n; i++) a[i] = a[i] ^ b[i];\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n    int F => int.Parse(Str);\n    long FL => long.Parse(Str);\n    int[] G => Strs.Select(int.Parse).ToArray();\n    long[] GL => Strs.Select(long.Parse).ToArray();\n    string Str => ReadLine();\n    string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n    const int MOD = 998244353;\n    public K()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        WriteLine(Solve());\n        Out.Flush();\n    }\n    Random rand = new Random();\n    long Solve()\n    {\n        var I = G;\n        int Y = I[0], X = I[1];\n        var mat = new bool[Y][];\n        for (var y = 0; y < Y; y++)\n        {\n            mat[y] = new bool[X];\n            // I = G;\n            // for (var x = 0; x < X; x++) mat[y][x] = I[x] != 0;\n            for (var x = 0; x < X; x++) mat[y][x] = rand.Next(6) == 0;\n        }\n        var r = 0;\n        for (var c = 0; c < X; c++)\n        {\n            int y = r;\n            while (y < Y && !mat[y][c]) y++;\n            if (y == Y) continue;\n            if (y != r) AddTo(mat[r], mat[y]);\n            for (y = r + 1; y < Y; y++) if (mat[y][c]) AddTo(mat[y], mat[r]);\n            r++;\n        }\n        WriteLine($\"rank = {r}\");\n        foreach (var m in mat) Print(m);\n        return (Pow(2, X + Y - 1, MOD) - Pow(2, X + Y - r - 1, MOD) + MOD) % MOD;\n    }\n    void Print(bool[] a) => WriteLine(string.Join(\"\", a.Select(b => b ? 1 : 0)));\n    public static long Pow(long a, long b, long mod)\n    {\n        var p = 1L;\n        var x = a;\n        while (b > 0)\n        {\n            if ((b & 1) == 1) p = (p * x) % mod;\n            b >>= 1;\n            x = (x * x) % mod;\n        }\n        return p;\n    }\n    // a += b\n    void AddTo(bool[] a, bool[] b)\n    {\n        var n = a.Length;\n        for (var i = 0; i < n; i++) a[i] = a[i] ^ b[i];\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nclass Z { static void Main() => new K(); }\nclass K\n{\n    int F => int.Parse(Str);\n    long FL => long.Parse(Str);\n    int[] G => Strs.Select(int.Parse).ToArray();\n    long[] GL => Strs.Select(long.Parse).ToArray();\n    string Str => ReadLine();\n    string[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n    const int MOD = 998244353;\n    public K()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        WriteLine(Solve());\n        Out.Flush();\n    }\n    long Solve()\n    {\n        var I = G;\n        int Y = I[0], X = I[1];\n        var mat = new BitVector[Y];\n        for (var y = 0; y < Y; y++)\n        {\n            var row = new bool[X];\n            I = G;\n            for (var x = 0; x < X; x++) row[x] = I[x] != 0;\n            mat[y] = new BitVector(row);\n        }\n        var r = 0;\n        for (var c = 0; c < X; c++)\n        {\n            int y = r;\n            while (y < Y && !mat[y][c]) y++;\n            if (y == Y) continue;\n            if (y != r) mat[r].Add(mat[y]);\n            for (y = r + 1; y < Y; y++) if (mat[y][c]) mat[y].Add(mat[r]);\n            r++;\n        }\n        return (Pow(X + Y - 1) - Pow(X + Y - r - 1) + MOD) % MOD;\n    }\n    public static long Pow(long b)\n    {\n        var p = 1L;\n        var x = 2;\n        while (b > 0)\n        {\n            if ((b & 1) == 1) p = p * x % MOD;\n            b >>= 1;\n            x = x * x % MOD;\n        }\n        return p;\n    }\n}\nclass BitVector\n{\n    readonly int N;\n    readonly byte[] bits;\n    public bool this[int i] => (bits[i / 8] & (1u << (i % 8))) != 0;\n    public BitVector(bool[] b)\n    {\n        N = b.Length;\n        bits = new byte[(N + 7) / 8];\n        for (var i = 0; i < N; i++) if (b[i]) bits[i / 8] |= (byte)(1u << (i % 8));\n    }\n    public void Add(BitVector v)\n    {\n        for (var i = 0; i < bits.Length; i++) bits[i] ^= v.bits[i];\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.UInt32;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var a = Enumerate(n, x => new int[m]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    a[i][j] = ri;\n            var used = new bool[n];\n            var vec = Enumerate(m, x => -1);\n            for (int j = 0; j < m; j++) {\n                for (int i = 0; i < n; i++) {\n                    if (used[i]) continue;\n                    if (a[i][j] == 1) { vec[j] = i; break; }\n                }\n                if (vec[j] == -1) continue;\n                for (int i = 0; i < n; i++) {\n                    if (i == vec[j]) continue;\n                    if (a[i][j] == 1) a[i] = xor(a[i], a[vec[j]]);\n                }\n            }\n            var cnt = n - vec.Count(x => x != -1);\n            Debug.WriteLine(cnt);\n            var ans = ModInt.Pow(2, n + m) - ModInt.Pow(2, cnt) * ModInt.Pow(2, m);\n            ans *= ModInt.Inverse(2);\n            Console.WriteLine(ans);\n\n        }\n        int[] xor(int[] a, int[] b) {\n            var res = new int[a.Length];\n            for (int i = 0; i < a.Length; i++)\n                res[i] = a[i] ^ b[i];\n            return res;\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\"\nvar Main=function(input){\n  input=input.trim().split(/\\s+/).map(x=>x-0);\n  var N=input.shift();\n  var M=input.shift();\n  var rankCounter=0;\n  var A=new Matrix(N,M,input);\n  while(A.low.length>0){\n    let i1=0;\n    for(let i=0;i<A.low.length;i++){\n      if(A.low[i][0]===1)break;\n      i1++;\n    }\n    if(i1===A.low.length){\n      A.swapColumn(0,A.low[0].length-1);\n      A.deleteColumn();\n    }else{\n      rankCounter+=1;\n      while(true){\n        let i2=i1+1;\n        for(let i=i1+1;i<A.low.length;i++){\n          if(A.low[i][0]===1)break;\n          i2++;\n        }\n        if(i2===A.low.length)break;\n        A.low[i2]=XOR(A.low[i1],A.low[i2]);\n      }\n      A.swapLow(i1,A.low.length-1);\n      A.deleteLow();\n    }\n  }\n  var r=rankCounter;\n  var ans=Math.pow(2,N+M-1)-Math.pow(2,Math.min(M,N)-r+Math.max(M,N)-1);\n  console.log(ans);\n}\n\nfunction xor(a,b){\n  return a===b?0:1;\n}\n\nfunction XOR(arr1,arr2){\n  return arr1.map((x,i)=>xor(x,arr2[i]));\n}\n\nfunction Matrix(N,M,elements){//elements are given as concated lows.\n  var A=this;\n  A.low=[];\n  for(let i=0;i<N;i++)A.low[i]=[];\n  for(let i=0;i<N;i++)for(let j=0;j<M;j++){\n    A.low[i][j]=elements[i*M+j];\n  }\n}\n\nfunction swap(arr,i1,i2){\n  var a=arr[i1];\n  var b=arr[i2];\n  arr[i1]=b,arr[i2]=a;\n}\n\nMatrix.prototype.swapLow=function(i1,i2){\n  var A=this;\n  swap(A.low,i1,i2);\n}\n\nMatrix.prototype.deleteLow=function(){//delete the last low.\n  var A=this;\n  var L=A.low;\n  L.pop();\n}\n\nMatrix.prototype.swapColumn=function(j1,j2){\n  var A=this;\n  for(let i=0;i<A.low.length;i++)\n    swap(A.low[i],j1,j2);\n}\n\nMatrix.prototype.deleteColumn=function(){//delete the last Column.\n  var A=this;\n  var L=A.low;\n  var N=L.length;\n  if(L[0].length===1)A.low=[];\n  for(let i=0;i<N;i++)\n    L[i].pop();\n}\n\n\nMain(require('fs').readFileSync('/dev/stdin','utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\"\nvar Main=function(input){\n  input=input.trim().split(/\\s+/).map(x=>x-0);\n  var N=input.shift();\n  var M=input.shift();\n  var rankCounter=0;\n  var A=new Matrix(N,M,input);\n  while(A.low.length>0){\n    let i1=0;\n    for(let i=0;i<A.low.length;i++){\n      if(A.low[i][0]===1)break;\n      i1++;\n    }\n    if(i1===A.low.length){\n      A.swapColumn(0,A.low[0].length-1);\n      A.deleteColumn();\n    }else{\n      rankCounter+=1;\n      while(true){\n        let i2=i1+1;\n        for(let i=i1+1;i<A.low.length;i++){\n          if(A.low[i][0]===1)break;\n          i2++;\n        }\n        if(i2===A.low.length)break;\n        A.low[i2]=XOR(A.low[i1],A.low[i2]);\n      }\n      A.swapLow(i1,A.low.length-1);\n      A.deleteLow();\n    }\n  }\n  var r=rankCounter;\n  var K=998244353;\n  var term1=1;\n  var term2=1;\n  for(let i=1;i<=M+N-1;i++)\n    term1+=term1-(2*term1>K?K:0);\n  for(let i=1;i<=M+N-r-1;i++)\n    term2+=term2-(2*term2>K?K:0);\n  var ans=term1-term2;\n  console.log(ans);\n}\n\nfunction xor(a,b){\n  return a===b?0:1;\n}\n\nfunction XOR(arr1,arr2){\n  return arr1.map((x,i)=>xor(x,arr2[i]));\n}\n\nfunction Matrix(N,M,elements){//elements are given as concated lows.\n  var A=this;\n  A.low=[];\n  for(let i=0;i<N;i++)A.low[i]=[];\n  for(let i=0;i<N;i++)for(let j=0;j<M;j++){\n    A.low[i][j]=elements[i*M+j];\n  }\n}\n\nfunction swap(arr,i1,i2){\n  var a=arr[i1];\n  var b=arr[i2];\n  arr[i1]=b,arr[i2]=a;\n}\n\nMatrix.prototype.swapLow=function(i1,i2){\n  var A=this;\n  swap(A.low,i1,i2);\n}\n\nMatrix.prototype.deleteLow=function(){//delete the last low.\n  var A=this;\n  var L=A.low;\n  L.pop();\n}\n\nMatrix.prototype.swapColumn=function(j1,j2){\n  var A=this;\n  for(let i=0;i<A.low.length;i++)\n    swap(A.low[i],j1,j2);\n}\n\nMatrix.prototype.deleteColumn=function(){//delete the last Column.\n  var A=this;\n  var L=A.low;\n  var N=L.length;\n  if(L[0].length===1)A.low=[];\n  for(let i=0;i<N;i++)\n    L[i].pop();\n}\n\n\nMain(require('fs').readFileSync('/dev/stdin','utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\"\nvar Main=function(input){\n  input=input.trim().split(/\\s+/).map(x=>x-0);\n  var N=input.shift();\n  var M=input.shift();\n  var rankCounter=0;\n  var A=new Matrix(N,M,input);\n  while(A.low.length>0){\n    let i1=0;\n    for(let i=0;i<A.low.length;i++){\n      if(A.low[i][0]===1)break;\n      i1++;\n    }\n    if(i1===A.low.length){\n      A.swapColumn(0,A.low[0].length-1);\n      A.deleteColumn();\n    }else{\n      rankCounter+=1;\n      while(true){\n        let i2=i1+1;\n        for(let i=i1+1;i<A.low.length;i++){\n          if(A.low[i][0]===1)break;\n          i2++;\n        }\n        if(i2===A.low.length)break;\n        A.low[i2]=XOR(A.low[i1],A.low[i2]);\n      }\n      A.swapLow(i1,A.low.length-1);\n      A.deleteLow();\n    }\n  }\n  var r=rankCounter;\n  var K=998244353;\n  var term1=1;\n  var term2=1;\n  for(let i=1;i<=M+N-1;i++)\n    term1+=term1-(2*term1>=K?K:0);\n  for(let i=1;i<=M+N-r-1;i++)\n    term2+=term2-(2*term2\n>=K?K:0);\n  var ans=term1-term2;\n  console.log(ans);\n}\n\nfunction xor(a,b){\n  return a===b?0:1;\n}\n\nfunction XOR(arr1,arr2){\n  return arr1.map((x,i)=>xor(x,arr2[i]));\n}\n\nfunction Matrix(N,M,elements){//elements are given as concated lows.\n  var A=this;\n  A.low=[];\n  for(let i=0;i<N;i++)A.low[i]=[];\n  for(let i=0;i<N;i++)for(let j=0;j<M;j++){\n    A.low[i][j]=elements[i*M+j];\n  }\n}\n\nfunction swap(arr,i1,i2){\n  var a=arr[i1];\n  var b=arr[i2];\n  arr[i1]=b,arr[i2]=a;\n}\n\nMatrix.prototype.swapLow=function(i1,i2){\n  var A=this;\n  swap(A.low,i1,i2);\n}\n\nMatrix.prototype.deleteLow=function(){//delete the last low.\n  var A=this;\n  var L=A.low;\n  L.pop();\n}\n\nMatrix.prototype.swapColumn=function(j1,j2){\n  var A=this;\n  for(let i=0;i<A.low.length;i++)\n    swap(A.low[i],j1,j2);\n}\n\nMatrix.prototype.deleteColumn=function(){//delete the last Column.\n  var A=this;\n  var L=A.low;\n  var N=L.length;\n  if(L[0].length===1)A.low=[];\n  for(let i=0;i<N;i++)\n    L[i].pop();\n}\n\n\nMain(require('fs').readFileSync('/dev/stdin','utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\"\nvar Main=function(input){\n  input=input.trim().split(/\\s+/).map(x=>x-0);\n  var N=input.shift();\n  var M=input.shift();\n  var rankCounter=0;\n  var A=new Matrix(N,M,input);\n  while(A.low.length>0){\n    let i1=0;\n    for(let i=0;i<A.low.length;i++){\n      if(A.low[i][0]===1)break;\n      i1++;\n    }\n    if(i1===A.low.length){\n      A.swapColumn(0,A.low[0].length-1);\n      A.deleteColumn();\n    }else{\n      rankCounter+=1;\n      while(true){\n        let i2=i1+1;\n        for(let i=i1+1;i<A.low.length;i++){\n          if(A.low[i][0]===1)break;\n          i2++;\n        }\n        if(i2===A.low.length)break;\n        A.low[i2]=XOR(A.low[i1],A.low[i2]);\n      }\n      A.swapLow(i1,A.low.length-1);\n      A.deleteLow();\n    }\n  }\n  var r=rankCounter;\n  var K=998244353;\n  var term1=1;\n  var term2=1;\n  for(let i=1;i<=M+N-1;i++)\n    term1+=term1-(2*term1>=K?K:0);\n  for(let i=1;i<=M+N-r-1;i++)\n    term2+=term2-(2*term2\n>=K?K:0);\n  var ans=(term1-term2)%K;\n  console.log(ans);\n}\n\nfunction xor(a,b){\n  return a===b?0:1;\n}\n\nfunction XOR(arr1,arr2){\n  return arr1.map((x,i)=>xor(x,arr2[i]));\n}\n\nfunction Matrix(N,M,elements){//elements are given as concated lows.\n  var A=this;\n  A.low=[];\n  for(let i=0;i<N;i++)A.low[i]=[];\n  for(let i=0;i<N;i++)for(let j=0;j<M;j++){\n    A.low[i][j]=elements[i*M+j];\n  }\n}\n\nfunction swap(arr,i1,i2){\n  var a=arr[i1];\n  var b=arr[i2];\n  arr[i1]=b,arr[i2]=a;\n}\n\nMatrix.prototype.swapLow=function(i1,i2){\n  var A=this;\n  swap(A.low,i1,i2);\n}\n\nMatrix.prototype.deleteLow=function(){//delete the last low.\n  var A=this;\n  var L=A.low;\n  L.pop();\n}\n\nMatrix.prototype.swapColumn=function(j1,j2){\n  var A=this;\n  for(let i=0;i<A.low.length;i++)\n    swap(A.low[i],j1,j2);\n}\n\nMatrix.prototype.deleteColumn=function(){//delete the last Column.\n  var A=this;\n  var L=A.low;\n  var N=L.length;\n  if(L[0].length===1)A.low=[];\n  for(let i=0;i<N;i++)\n    L[i].pop();\n}\n\n\nMain(require('fs').readFileSync('/dev/stdin','utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\"\nvar Main=function(input){\n  input=input.trim().split(/\\s+/).map(x=>x-0);\n  var N=input.shift();\n  var M=input.shift();\n  var rankCounter=0;\n  var A=new Matrix(N,M,input);\n  while(A.low.length>0){\n    let i1=0;\n    for(let i=0;i<A.low.length;i++){\n      if(A.low[i][0]===1)break;\n      i1++;\n    }\n    if(i1===A.low.length){\n      A.swapColumn(0,A.low[0].length-1);\n      A.deleteColumn();\n    }else{\n      rankCounter+=1;\n      while(true){\n        let i2=i1+1;\n        for(let i=i1+1;i<A.low.length;i++){\n          if(A.low[i][0]===1)break;\n          i2++;\n        }\n        if(i2===A.low.length)break;\n        A.low[i2]=XOR(A.low[i1],A.low[i2]);\n      }\n      A.swapLow(i1,A.low.length-1);\n      A.deleteLow();\n    }\n  }\n  var r=rankCounter;\n  var K=998244353;\n  var term1=1;\n  var term2=1;\n  for(let i=1;i<=M+N-1;i++){\n    term1*=2;\n    if(term1>=K)term1-=K;\n  }\n  for(let i=1;i<=M+N-r-1;i++){\n    term2*=2;\n    if(term2>=K)term1-=K;\n  }\n  var ans=term1-term2;\n  if(ans<0)ans+=K;\n  console.log(ans);\n}\n\nfunction xor(a,b){\n  return a===b?0:1;\n}\n\nfunction XOR(arr1,arr2){\n  return arr1.map((x,i)=>xor(x,arr2[i]));\n}\n\nfunction Matrix(N,M,elements){//elements are given as concated lows.\n  var A=this;\n  A.low=[];\n  for(let i=0;i<N;i++)A.low[i]=[];\n  for(let i=0;i<N;i++)for(let j=0;j<M;j++){\n    A.low[i][j]=elements[i*M+j];\n  }\n}\n\nfunction swap(arr,i1,i2){\n  var a=arr[i1];\n  var b=arr[i2];\n  arr[i1]=b,arr[i2]=a;\n}\n\nMatrix.prototype.swapLow=function(i1,i2){\n  var A=this;\n  swap(A.low,i1,i2);\n}\n\nMatrix.prototype.deleteLow=function(){//delete the last low.\n  var A=this;\n  var L=A.low;\n  L.pop();\n}\n\nMatrix.prototype.swapColumn=function(j1,j2){\n  var A=this;\n  for(let i=0;i<A.low.length;i++)\n    swap(A.low[i],j1,j2);\n}\n\nMatrix.prototype.deleteColumn=function(){//delete the last Column.\n  var A=this;\n  var L=A.low;\n  var N=L.length;\n  if(L[0].length===1)A.low=[];\n  for(let i=0;i<N;i++)\n    L[i].pop();\n}\n\n\nMain(require('fs').readFileSync('/dev/stdin','utf8'));"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table << gets.split.map(&:to_i)\nend\n\ncombi = []\ncount = 0\n(1..(2 ** n - 1)).each do |i|\n  i = i.to_s(2)\n  x_len = i.length - 1\n  x_array = i.split(\"\").map.with_index{|e,i| e == \"1\" ? x_len - i : nil}.compact\n    (1..(2 ** m - 1)).each do |j|\n      j = j.to_s(2)\n      y_len = j.length - 1\n      y_array = j.reverse.split(\"\").map.with_index{|e,i| e == \"1\" ? y_len - i : nil}.compact\n      combi << [x_array,y_array]\n    end\nend\n\ncombi.each do |pair|\n  sum = 0\n  pair[0].reverse_each do |x|\n    pair[1].reverse_each do |y|\n      sum += table[x][y].to_i\n    end\n  end\n  count += 1 if sum % 2 == 1\nend\n\nputs count % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table << gets.split.map(&:to_i)\nend\ncombi = []\ncount = 0\n(1..(2 ** n - 1)).each do |i|\n  x_array = i.to_s(2).reverse.split(\"\").map.with_index{|e,i| e == \"1\" ? i : nil}.compact\n    (1..(2 ** m - 1)).each do |j|\n      y_array = j.to_s(2).reverse.split(\"\").map.with_index{|e,i| e == \"1\" ? i : nil}.compact\n      combi << [x_array,y_array]\n    end\nend\n \ncombi.each do |pair|\n  sum = 0\n  pair[0].reverse_each do |x|\n    pair[1].reverse_each do |y|\n      sum += table[x][y].to_i\n    end\n  end\n  count += 1 if sum % 2 == 1\nend\n \nputs count % 998244353\n"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\n\nx_array = [0,1].repeated_permutation(n).to_a.map{|ele| ele.size.times.select{|i| 1 == ele[i]}}\ny_array = [0,1].repeated_permutation(m).to_a.map{|ele| ele.size.times.select{|i| 1 == ele[i]}}\ncombi = x_array.product(y_array)\ncount = 0\ncombi.each do |pair|\n  judge = false\n  pair[0].each do |x|\n    pair[1].each do |y|\n     judge =  judge == true ? false : true if table[x][y] == 1\n    end\n  end\n  count += 1 if judge == true\nend\n\nputs count % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\n\ncount = 0\n (0..(n - 1)).each do |x|\n   judge = false\n   (0..(m - 1)).each do |y|\n     if table[x][y] == 1\n       judge = true\n       break\n     end\n   end\n  count += 1 if judge == false\nend\nputs count\nputs ((2 ** n - 2 ** count) * (2 ** (m - 1))) % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n, m = gets.split.map(&:to_i)\nas = n.times.map do\n  gets.split(nil, m).map(&:to_i)\nend\n\nresult = 0\n(1..n).each do |i|\n  (1..m).each do |j|\n    (1..n).to_a.combination(i).each do |n_range|\n      (1..m).to_a.combination(j).each do |m_range|\n        sum = 0\n        n_range.each do |k|\n          m_range.each do |l|\n            sum += as[k-1][l-1]\n          end\n        end\n        result += sum if sum.odd?\n      end\n    end\n  end\nend\n\nputs result % 998_244_353\n"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |n|\n  table << gets.split.map(&:to_i)\nend\ncombi = []\ncount = 0\n(1..(2 ** n - 1)).each do |i|\n  x_array = i.to_s(2).split(\"\")\n    (1..(2 ** m - 1)).each do |j|\n      y_array = j.to_s(2).split(\"\")\n      combi << [x_array,y_array]\n    end\nend\n\ncombi.each do |pair|\n  sum = 0\n  x_num = -1\n  pair[0].reverse_each do |x|\n    y_num = -1\n    x_num += 1\n    next if x == \"0\"\n    pair[1].reverse_each do |y|\n      y_num += 1\n      next if y == \"0\"\n\n      sum += table[x_num][y_num].to_i\n    end\n  end\n  count += 1 if sum % 2 == 1\nend\n\nputs count % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\nr = table.uniq.size\nr -= 1 if table.include?(Array.new(m,0))\n\ntable = table.transpose\nR = table.uniq.size\nR -= 1 if table.include?(Array.new(n,0))\nr = r < R ? r : R\nputs ((2 ** (n + m - 1)) % 998244353 - (2 ** (n + m - r - 1)) % 998244353) % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\n\nx_array = [0,1].repeated_permutation(n).to_a.map{|ele| ele.size.times.select{|i| 1 == ele[i]}}\ncount = 0\nx_array.each do |x_comb|\n  judge = false\n  (0..(m - 1)).each do |y|\n    x_comb.each do |x|\n      if table[x][y] == 1\n        judge = true\n        break\n      end\n    end\n    if judge == true\n      break\n    end\n  end\n  count += 1 if judge == true\nend\n\nputs (count * (2 ** (m - 1))) % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\n\ncount = 0\n (0..(n - 1)).each do |x|\n   judge = false\n   (0..(m - 1)).each do |y|\n     if table[x][y] == 1\n       judge = true\n       break\n     end\n   end\n  count += 1 if judge == false\nend\nputs ((2 ** n - 2 ** count) * (2 ** (m - 1))) % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\n\ncount = 0\nif n < m\n  (0..(n - 1)).each do |x|\n    judge = false\n    (0..(m - 1)).each do |y|\n      if table[x][y] == 1\n        judge = true\n        break\n      end\n    end\n    count += 1 if judge == false\n  end\n  puts (((2 ** n) - (2 ** count)) * (2 ** (m - 1))) % 998244353\nelse\n  (0..(m - 1)).each do |y|\n    judge = false\n    (0..(n - 1)).each do |x|\n      if table[x][y] == 1\n        judge = true\n        break\n      end\n    end\n    count += 1 if judge == false\n  end\n  puts (((2 ** m) - (2 ** count)) * (2 ** (n - 1))) % 998244353\nend"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table << gets.split.map(&:to_i)\nend\n\ncombi = []\ncount = 0\n(1..(2 ** n - 1)).each do |i|\n  i = i.to_s(2)\n  x_len = i.length - 1\n  x_array = i.split(\"\").map.with_index{|e,i| e == \"1\" ? x_len - i : nil}.compact\n    (1..(2 ** m - 1)).each do |j|\n      j = j.to_s(2)\n      y_len = j.length - 1\n      y_array = j.reverse.split(\"\").map.with_index{|e,i| e == \"1\" ? y_len - i : nil}.compact\n      combi << [x_array,y_array]\n    end\nend\n\ncombi.each do |pair|\n  sum = 0\n  pair[0].each do |x|\n    pair[1].each do |y|\n      sum += table[x][y].to_i\n    end\n  end\n  count += 1 if sum % 2 == 1\nend\n\nputs count % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\n\ncombi = []\ncount = 0\n(1..(2 ** n - 1)).each do |i|\n  i = i.to_s(2)\n  x_len = i.length - 1\n  x_array = i.split(\"\").map.with_index{|e,i| e == \"1\" ? x_len - i : nil}.compact\n    (1..(2 ** m - 1)).each do |j|\n      j = j.to_s(2)\n      y_len = j.length - 1\n      y_array = j.split(\"\").map.with_index{|e,i| e == \"1\" ? y_len - i : nil}.compact\n      combi.push([x_array,y_array])\n    end\nend\n\ncombi.each do |pair|\n  sum = 0\n  pair[0].each do |x|\n    pair[1].each do |y|\n      sum += table[x][y].to_i\n    end\n  end\n  count += 1 if sum % 2 == 1\nend\n\nputs count % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\n\ncount = 0\nif n < m\n  (0..(n - 1)).each do |x|\n    judge = false\n    (0..(m - 1)).each do |y|\n      if table[x][y] == 1\n        judge = true\n        break\n      end\n    end\n    count += 1 if judge == false\n  end\n  puts ((((2 ** n) % 998244353) - ((2 ** count)) % 998244353) * ((2 ** (m - 1))% 998244353) % 998244353\nelse\n  (0..(m - 1)).each do |y|\n    judge = false\n    (0..(n - 1)).each do |x|\n      if table[x][y] == 1\n        judge = true\n        break\n      end\n    end\n    count += 1 if judge == false\n  end\n  puts ((((2 ** m) % 998244353) - ((2 ** count)) % 998244353) * ((2 ** (n - 1))% 998244353) % 998244353\nend"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |n|\n  table << gets.split.map(&:to_i)\nend\ncombi = []\ncount = 0\n(1..(2 ** n - 1)).each do |i|\n  x_array = i.to_s(2).split(\"\").reverse.map(&:to_i)\n    (1..(2 ** m - 1)).each do |j|\n      y_array = j.to_s(2).split(\"\").reverse.map(&:to_i)\n      combi << [x_array,y_array]\n    end\nend\n\ncombi.each do |pair|\n  sum = 0\n  x_num = -1\n  pair[0].each do |x|\n    y_num = -1\n    x_num += 1\n    next if x == 0\n    pair[1].each do |y|\n      y_num += 1\n      next if y == 0\n\n      sum += table[x_num][y_num].to_i\n    end\n  end\n  count += 1 if sum % 2 == 1\nend\n\nputs count % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\n\ncount = 0\nif n < m\n  (0..(n - 1)).each do |x|\n    judge = false\n    (0..(m - 1)).each do |y|\n      if table[x][y] == 1\n        judge = true\n        break\n      end\n    end\n    count += 1 if judge == false\n  end\n  puts ((((2 ** n) % 998244353) - ((2 ** count)) % 998244353) * ((2 ** (m - 1)) % 998244353)) % 998244353\nelse\n  (0..(m - 1)).each do |y|\n    judge = false\n    (0..(n - 1)).each do |x|\n      if table[x][y] == 1\n        judge = true\n        break\n      end\n    end\n    count += 1 if judge == false\n  end\n  puts ((((2 ** m) % 998244353) - ((2 ** count)) % 998244353) * ((2 ** (n - 1)) % 998244353)) % 998244353\nend"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\nr = table.uniq.size\nr -= 1 if table.include?(Array.new(m,0))\ntable.uniq.size\nputs ((2 ** (n + m - 1)) % 998244353 - (2 ** (n + m - r - 1)) % 998244353) % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |i|\n  table.push(gets.split.map(&:to_i))\nend\nr = table.uniq.size\nr -= 1 if table.include?(Array.new(m,0))\ntable.uniq.size\nputs ((2 ** (n + m - 1)) - (2 ** (n + m - r - 1))) % 998244353"
  },
  {
    "language": "Ruby",
    "code": "  x_array = [0,1].repeated_permutation(n).to_a.map{|ele| ele.size.times.select{|i| 1 == ele[i]}}\n  y_array = [0,1].repeated_permutation(m).to_a.map{|ele| ele.size.times.select{|i| 1 == ele[i]}}\n  combi = x_array.product(y_array)\n  count = 0\n  combi.each do |pair|\n    judge = false\n    pair[0].each do |x|\n      pair[1].each do |y|\n       judge =  judge == true ? false : true if table[x][y] == 1\n      end\n    end\n    count += 1 if judge == true\n  end\n  \n  puts count % 998244353"
  },
  {
    "language": "Ruby",
    "code": "n,m = gets.split.map(&:to_i)\ntable = []\n(1..n).each do |n|\n  table.push(gets.split.map(&:to_i))\nend\ncombi = []\ncount = 0\n(1..(2 ** n - 1)).each do |i|\n  x_array = i.to_s(2).split(\"\")\n    (1..(2 ** m - 1)).each do |j|\n      y_array = j.to_s(2).split(\"\")\n      combi.push([x_array,y_array])\n    end\nend\n \ncombi.each do |pair|\n  sum = 0\n  x_num = -1\n  pair[0].reverse_each do |x|\n    y_num = -1\n    x_num += 1\n    next if x == \"0\"\n    pair[1].reverse_each do |y|\n      y_num += 1\n      next if y == \"0\"\n \n      sum += table[x_num][y_num].to_i\n    end\n  end\n  count += 1 if sum % 2 == 1\nend\n \nputs count % 998244353"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nvar ymap map[int]int\nvar table [][]int\n\nfunc init() {\n\tymap = map[int]int{}\n}\n\nfunc getRow(idx, left, right int) int {\n\tk := left + (1000*right) + (1000000*idx)\n\tif v, ok := ymap[k]; ok {\n\t\treturn v\n\t} else {\n\t\tv := 0\n\t\tfor x := left; x <= right; x++ {\n\t\t\tv+=table[idx][x]\n\t\t}\n\t\tymap[k] = v\n\t\treturn v\n\t}\n}\n\nfunc main() {\n\tvar n,m int\n\tfmt.Scanf(\"%d %d\\n\", &n, &m)\n\ttable = make([][]int, n)\n\tfor y := 0; y < n; y++ {\n\t\ttable[y] = make([]int, m)\n\t\tfor x := 0; x < m; x++ {\n\t\t\tfmt.Scanf(\"%d\", &table[y][x])\n\t\t}\n\t}\n\tvar count int\n\tfor y1 := 0; y1 < n; y1++ {\n\t\tfor y2 := 0; y2 < n; y2++ {\n\t\t\tfor x1 := 0; x1 < m; x1++ {\n\t\t\t\tfor x2 := 0; x2 < m; x2++ {\n\t\t\t\t\tsum := 0\n\t\t\t\t\tfor y := y1; y <= y2; y++ {\n\t\t\t\t\t\tsum += getRow(y, x1, x2)\n\t\t\t\t\t}\n\t\t\t\t\tif sum % 2 == 1 {\n\t\t\t\t\t\tcount++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Println(count)\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar n,m int\n\tfmt.Scanf(\"%d %d\\n\", &n, &m)\n\ttable := make([][]int, n)\n\tfor y := 0; y < n; y++ {\n\t\ttable[y] = make([]int, m)\n\t\tfor x := 0; x < m; x++ {\n\t\t\tfmt.Scanf(\"%d\", &table[y][x])\n\t\t}\n\t}\n\tvar count int\n\tfor y1 := 0; y1 < n; y1++ {\n\t\tfor y2 := 0; y2 < n; y2++ {\n\t\t\tfor x1 := 0; x1 < m; x1++ {\n\t\t\t\tfor x2 := 0; x2 < m; x2++ {\n\t\t\t\t\tsum := 0\n\t\t\t\t\tfor y := y1; y <= y2; y++ {\n\t\t\t\t\t\tfor x := x1; x <= x2; x++ {\n\t\t\t\t\t\t\tsum+=table[y][x]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif sum % 2 == 1 {\n\t\t\t\t\t\tcount++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Println(count)\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum MO = 998244353L;\nenum LIM = 310;\n\nint M, N;\nint[][] A;\n\nvoid main() {\n  auto two = new long[LIM];\n  two[0] = 1;\n  foreach (i; 1 .. LIM) {\n    two[i] = (two[i - 1] * 2) % MO;\n  }\n  \n  try {\n    for (; ; ) {\n      M = readInt();\n      N = readInt();\n      A = new int[][](M, N);\n      foreach (i; 0 .. M) foreach (j; 0 .. N) {\n        A[i][j] = readInt();\n      }\n      \n      auto a = new int[][](M, N);\n      foreach (i; 0 .. M) foreach (j; 0 .. N) {\n        a[i][j] = A[i][j];\n      }\n      int r;\n      foreach (h; 0 .. N) {\n        foreach (i; r .. M) {\n          if (a[i][h]) {\n            swap(a[r], a[i]);\n            break;\n          }\n        }\n        if (a[r][h]) {\n          foreach (i; r + 1 .. M) {\n            if (a[i][h]) {\n              foreach (j; h .. N) {\n                a[i][j] ^= a[r][j];\n              }\n            }\n          }\n          ++r;\n        }\n      }\n      debug {\n        writeln(\"rank = \", r);\n      }\n      long ans;\n      ans += two[M + N - 1];\n      ans -= two[M + N - 1 - r];\n      ans = (ans % MO + MO) % MO;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.bigint;\nimport std.math, std.random, std.datetime;\nimport std.array, std.range, std.algorithm, std.container, std.format;\nstring read(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\n/*\n\n横幅が l <= j <= r で、縦幅の下端が i\n偶数 x[i][l][r]\n奇数 y[i][l][r]\n\n*/\n\nconst long mod = 998244353;\n\nvoid main(){\n\tlong n = read.to!long;\n\tlong m = read.to!long;\n\t\n\tlong[][] as = new long[][](n, m);\n\t\n\tforeach(i; 0 .. n){\n\t\tforeach(j; 0 .. m){\n\t\t\tas[i][j] = read.to!long;\n\t\t}\n\t}\n\t\n\tlong ans;\n\tlong[][][] xs = new long[][][](n, m, m);\n\tlong[][][] ys = new long[][][](n, m, m);\n\tforeach(i; 0 .. n){\n\t\tforeach(l; 0 .. m){\n\t\t\tlong sum = 0;\n\t\t\tforeach(r; l .. m){\n\t\t\t\tsum += as[i][r];\n\t\t\t\tif(sum % 2 == 1){ // この行では奇数\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\txs[i][l][r] = 0;\n\t\t\t\t\t\tys[i][l][r] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\txs[i][l][r] = ys[i - 1][l][r];\n\t\t\t\t\t\tys[i][l][r] = xs[i - 1][l][r] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ // この行では偶数\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\txs[i][l][r] = 1;\n\t\t\t\t\t\tys[i][l][r] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\txs[i][l][r] = xs[i - 1][l][r] + 1;\n\t\t\t\t\t\tys[i][l][r] = ys[i - 1][l][r];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += ys[i][l][r], ans %= mod;\n\t\t\t\tdebug writeln(\"i:\", i, \" l:\", l, \" r:\", r, \" sum:\", sum, \" xs:\", xs, \" ys:\", ys, \" ans:\", ans);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans.writeln;\n\t\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum MO = 998244353L;\nenum LIM = 610;\n\nint M, N;\nint[][] A;\n\nvoid main() {\n  auto two = new long[LIM];\n  two[0] = 1;\n  foreach (i; 1 .. LIM) {\n    two[i] = (two[i - 1] * 2) % MO;\n  }\n  \n  try {\n    for (; ; ) {\n      M = readInt();\n      N = readInt();\n      A = new int[][](M, N);\n      foreach (i; 0 .. M) foreach (j; 0 .. N) {\n        A[i][j] = readInt();\n      }\n      \n      auto a = new int[][](M, N);\n      foreach (i; 0 .. M) foreach (j; 0 .. N) {\n        a[i][j] = A[i][j];\n      }\n      int r;\n      foreach (h; 0 .. N) {\n        foreach (i; r .. M) {\n          if (a[i][h]) {\n            swap(a[r], a[i]);\n            break;\n          }\n        }\n        if (r < M && a[r][h]) {\n          foreach (i; r + 1 .. M) {\n            if (a[i][h]) {\n              foreach (j; h .. N) {\n                a[i][j] ^= a[r][j];\n              }\n            }\n          }\n          ++r;\n        }\n      }\n      debug {\n        writeln(\"rank = \", r);\n      }\n      long ans;\n      ans += two[M + N - 1];\n      ans -= two[M + N - 1 - r];\n      ans = (ans % MO + MO) % MO;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.bigint;\nimport std.math, std.random, std.datetime;\nimport std.array, std.range, std.algorithm, std.container, std.format;\nstring read(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\n/*\n\n横幅が l <= j <= r で、縦幅の下端が i\n偶数 x[i][l][r]\n奇数 y[i][l][r]\n\n*/\n\nconst long mod = 998244353;\n\nvoid main(){\n\tlong n = read.to!long;\n\tlong m = read.to!long;\n\t\n\tlong[][] as = new long[][](n, m);\n\t\n\tforeach(i; 0 .. n){\n\t\tforeach(j; 0 .. m){\n\t\t\tas[i][j] = read.to!long;\n\t\t}\n\t}\n\t\n\tlong[][][] xs = new long[][][](n, m, m);\n\tlong[][][] ys = new long[][][](n, m, m);\n\tlong[][] xp = new long[][](m, m);\n\tlong[][] yp = new long[][](m, m);\n\tforeach(i; 0 .. n){\n\t\tforeach(l; 0 .. m){\n\t\t\tlong sum = 0;\n\t\t\tforeach(r; l .. m){\n\t\t\t\tsum += r, sum %= 2;\n\t\t\t\tif(sum == 1){\n\t\t\t\t\tif(i > 0){\n\t\t\t\t\t\txs[i][l][r] = yp[l][r], xs[i][l][r] %= mod;\n\t\t\t\t\t\tys[i][l][r] = xp[l][r], ys[i][l][r] %= mod;\n\t\t\t\t\t\txp[l][r] += xs[i][l][r], xp[l][r] %= mod;\n\t\t\t\t\t\typ[l][r] += ys[i][l][r], yp[l][r] %= mod;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\txs[i][l][r] = 0;\n\t\t\t\t\t\tys[i][l][r] = 1;\n\t\t\t\t\t\txp[l][r] += xs[i][l][r], xp[l][r] %= mod;\n\t\t\t\t\t\typ[l][r] += ys[i][l][r], yp[l][r] %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(i > 0){\n\t\t\t\t\t\txs[i][l][r] = xp[l][r], xs[i][l][r] %= mod;\n\t\t\t\t\t\tys[i][l][r] = yp[l][r], ys[i][l][r] %= mod;\n\t\t\t\t\t\txp[l][r] += xs[i][l][r], xp[l][r] %= mod;\n\t\t\t\t\t\typ[l][r] += ys[i][l][r], yp[l][r] %= mod;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\txs[i][l][r] = 1;\n\t\t\t\t\t\tys[i][l][r] = 0;\n\t\t\t\t\t\txp[l][r] += xs[i][l][r], xp[l][r] %= mod;\n\t\t\t\t\t\typ[l][r] += ys[i][l][r], yp[l][r] %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong ans;\n\tforeach(l; 0 .. m) foreach(r; 0 .. m) ans += yp[l][r], ans %= mod;\n\tans.writeln;\n\t\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.bigint;\nimport std.math, std.random, std.datetime;\nimport std.array, std.range, std.algorithm, std.container, std.format;\nstring read(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\n/*\n\n横幅が l <= j <= r で、縦幅の下端が i\n偶数 x[i][l][r]\n奇数 y[i][l][r]\n\n*/\n\nconst long mod = 998244353;\n\nvoid main(){\n\tlong n = read.to!long;\n\tlong m = read.to!long;\n\t\n\tlong[][] as = new long[][](n, m);\n\t\n\tforeach(i; 0 .. n){\n\t\tforeach(j; 0 .. m){\n\t\t\tas[i][j] = read.to!long;\n\t\t}\n\t}\n\t\n\tlong ans;\n\tlong[][][] xs = new long[][][](n, m, m);\n\tlong[][][] ys = new long[][][](n, m, m);\n\tforeach(i; 0 .. n){\n\t\tforeach(l; 0 .. m){\n\t\t\tlong sum = 0;\n\t\t\tforeach(r; l .. m){\n\t\t\t\tsum += as[i][r];\n\t\t\t\tif(sum % 2 == 1){\n\t\t\t\t\tif(i > 0){ // この行では奇数\n\t\t\t\t\t\txs[i][l][r] = ys[i - 1][l][r];\n\t\t\t\t\t\tys[i][l][r] = xs[i - 1][l][r] + 1;\n\t\t\t\t\t\tans += ys[i][l][r], ans %= mod;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\txs[i][l][r] = 0;\n\t\t\t\t\t\tys[i][l][r] = 1;\n\t\t\t\t\t\tans += ys[i][l][r], ans %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ // この行では偶数\n\t\t\t\t\tif(i > 0){\n\t\t\t\t\t\txs[i][l][r] = xs[i - 1][l][r] + 1;\n\t\t\t\t\t\tys[i][l][r] = ys[i - 1][l][r];\n\t\t\t\t\t\tans += ys[i][l][r], ans %= mod;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\txs[i][l][r] = 1;\n\t\t\t\t\t\tys[i][l][r] = 0;\n\t\t\t\t\t\tans += ys[i][l][r], ans %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdebug writeln(\"i:\", i, \" l:\", l, \" r:\", r, \" sum:\", sum, \" xs:\", xs, \" ys:\", ys, \" ans:\", ans);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tans.writeln;\n\t\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum MO = 998244353L;\nenum LIM = 610;\n\nint M, N;\nint[][] A;\n\nvoid main() {\n  auto two = new long[LIM];\n  two[0] = 1;\n  foreach (i; 1 .. LIM) {\n    two[i] = (two[i - 1] * 2) % MO;\n  }\n  \n  try {\n    for (; ; ) {\n      M = readInt();\n      N = readInt();\n      A = new int[][](M, N);\n      foreach (i; 0 .. M) foreach (j; 0 .. N) {\n        A[i][j] = readInt();\n      }\n      \n      auto a = new int[][](M, N);\n      foreach (i; 0 .. M) foreach (j; 0 .. N) {\n        a[i][j] = A[i][j];\n      }\n      int r;\n      foreach (h; 0 .. N) {\n        foreach (i; r .. M) {\n          if (a[i][h]) {\n            swap(a[r], a[i]);\n            break;\n          }\n        }\n        if (a[r][h]) {\n          foreach (i; r + 1 .. M) {\n            if (a[i][h]) {\n              foreach (j; h .. N) {\n                a[i][j] ^= a[r][j];\n              }\n            }\n          }\n          ++r;\n        }\n      }\n      debug {\n        writeln(\"rank = \", r);\n      }\n      long ans;\n      ans += two[M + N - 1];\n      ans -= two[M + N - 1 - r];\n      ans = (ans % MO + MO) % MO;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}"
  },
  {
    "language": "Nim",
    "code": "import algorithm\nimport future\nimport macros\nimport math\nimport queues\nimport sequtils\nimport sets\nimport strutils\nimport tables\n\nconst INF* = int(1e18 + 373)\n\nproc readLine*(): string =\n  stdin.readLine().strip()\nproc readSeq*(): seq[string] =\n  readLine().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeqWith(n, readLine())\nproc readIntSeq*(): seq[int] =\n  result = readSeq().map(parseInt)\nproc readIntSeq*(n: Natural): seq[int] =\n  result = readSeq(n).map(parseInt)\nproc readInt1*(): int =\n  readLine().parseInt()\nproc readInt2*(): (int, int) =\n  let a = readIntSeq(); return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readIntSeq(); return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readIntSeq(); return (a[0], a[1], a[2], a[3])\n\nproc newSeqOf*[T](n: Natural; e: T): seq[T] =\n  result = newSeq[T](n)\n  result.fill(e)\nproc newSeq*[T](n: Natural; e: T): seq[T] =\n  newSeqOf[T](n, e)\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] =\n  newSeqOf(n1, newSeq[T](n2))\nproc newSeq2*[T](n1, n2: Natural; e: T): seq2[T] =\n  newSeqOf(n1, newSeqOf(n2, e))\ntype seq3*[T] = seq[seq[seq[T]]]\nproc newSeq3*[T](n1, n2, n3: Natural): seq3[T] =\n  newSeqOf(n1, newSeqOf(n2, newSeq[T](n3)))\nproc newSeq3*[T](n1, n2, n3: Natural; e: T): seq3[T] =\n  newSeqOf(n1, newSeqOf(n2, newSeqOf(n3, e)))\n\nwhen defined(ENABLE_DEBUG_MACRO):\n  macro debug*(args: varargs[untyped]): untyped =\n    result = nnkStmtList.newTree()\n    for i in 0..<args.len():\n      let par1 = newIdentNode(\"stderr\")\n      let par2 = newLit(args[i].repr)\n      let par3 = newLit(\" = \")\n      let par4 = args[i]\n      result.add(newCall(\"write\", par1, par2, par3, par4))\n      if i + 1 < args.len():\n        result.add(newCall(\"write\", newIdentNode(\"stderr\"), newLit(\", \")))\n    result.add(newCall(\"writeLine\", newIdentNode(\"stderr\"), newLit(\"\")))\nelse:\n  macro debug*(args: varargs[untyped]): untyped =\n    result = nnkDiscardStmt.newTree(newLit(nil))\n\n#------------------------------------------------------------------------------#\nconst MOD* = 998244353\n\ntype Mint* = object\n  v: int\n\nproc initMint*(v: int): Mint =\n  result.v = (v mod MOD + MOD) mod MOD\n\nproc `$`*(x: Mint): string =\n  $x.v\n\nproc `$$`*(x: Mint): string =\n  if abs(x.v) < abs(x.v - MOD):\n    $x.v\n  else:\n    $(x.v - MOD)\n\nproc pow*(x: Mint; n: int): Mint =\n  if n < 0:\n    return pow(x, -n).pow(MOD - 2)\n\n  var m = n\n  var p = 1\n  var xx = x.v\n  while m > 0:\n    if (m and 1) != 0:\n      p = p * xx mod MOD\n    xx = xx * xx mod MOD\n    m = m shr 1\n\n  result.v = p\n\nproc inv*(x: Mint): Mint =\n  pow(x, MOD - 2)\n\nproc `+`*(x: Mint): Mint =\n  result.v = x.v\nproc `-`*(x: Mint): Mint =\n  result.v = (-x.v + MOD) mod MOD\n\nproc `+`*(x0: Mint, x1: Mint): Mint =\n  result.v = (x0.v + x1.v) mod MOD\nproc `-`*(x0: Mint, x1: Mint): Mint =\n  result.v = (x0.v - x1.v + MOD) mod MOD\nproc `*`*(x0: Mint, x1: Mint): Mint =\n  result.v = x0.v * x1.v mod MOD\nproc `/`*(x0: Mint, x1: Mint): Mint =\n  result.v = x0.v * x1.inv().v mod MOD\nproc `^`*(x0: Mint, x1: int): Mint =\n  x0.pow(x1)\n\nproc `+`*(x0: Mint, x1: int): Mint =\n  x0 + initMint(x1)\nproc `-`*(x0: Mint, x1: int): Mint =\n  x0 - initMint(x1)\nproc `*`*(x0: Mint, x1: int): Mint =\n  x0 * initMint(x1)\nproc `/`*(x0: Mint, x1: int): Mint =\n  x0 / initMint(x1)\n\nproc `+`*(x0: int, x1: Mint): Mint =\n  initMint(x0) + x1\nproc `-`*(x0: int, x1: Mint): Mint =\n  initMint(x0) - x1\nproc `*`*(x0: int, x1: Mint): Mint =\n  initMint(x0) * x1\nproc `/`*(x0: int, x1: Mint): Mint =\n  initMint(x0) / x1\n\nproc `+=`*(x0: var Mint; x1: Mint) =\n  x0 = x0 + x1\nproc `-=`*(x0: var Mint; x1: Mint) =\n  x0 = x0 - x1\nproc `*=`*(x0: var Mint; x1: Mint) =\n  x0 = x0 * x1\nproc `/=`*(x0: var Mint; x1: Mint) =\n  x0 = x0 / x1\n\nproc `+=`*(x0: var Mint; x1: int) =\n  x0 = x0 + x1\nproc `-=`*(x0: var Mint; x1: int) =\n  x0 = x0 - x1\nproc `*=`*(x0: var Mint; x1: int) =\n  x0 = x0 * x1\nproc `/=`*(x0: var Mint; x1: int) =\n  x0 = x0 / x1\nproc `^=`*(x0: var Mint; x1: int) =\n  x0 = x0 ^ x1\n\n#------------------------------------------------------------------------------#\n\nproc main() =\n  let (n, m) = readInt2()\n  var a = newSeq2[int](n, 0)\n  for i in 0..<n:\n    a[i] = readIntSeq()\n\n  var r = 0\n  for j in 0..<m:\n    var p = -1\n    for i in r..<n:\n      if a[i][j] == 1:\n        p = i\n        break\n\n    if p == -1:\n      continue\n\n    for k in 0..<m:\n      swap(a[r][k], a[p][k])\n\n    for i in r + 1..<n:\n      if a[i][j] == 0:\n        continue\n      for k in 0..<m:\n        a[i][k] = a[i][k] xor a[r][k]\n\n    r += 1\n\n  debug(r)\n\n  let combB = initMint(2) ^ m - initMint(2) ^ (m - r)\n  let combA = initMint(2) ^ (n - 1)\n  let ans = combA * combB\n  debug(combB, combA)\n  echo ans\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import itertools\ndef inpl(): return list(map(int, input().split()))\nN, M = inpl()\nG = [list(itertools.accumulate(inpl())) for _ in [0]*N]\nG = list(map(list, zip(*G)))\nG = [list(itertools.accumulate(g)) for g in G]\nfor j in range(M):\n    G[j] = [v % 2 for v in G[j]]\nGrow = [list(itertools.accumulate(g)) for g in G]\nG = list(map(list, zip(*G)))\nGrow = list(map(list, zip(*Grow)))\nGcol = [list(itertools.accumulate(g)) for g in G]\n\nmod = 998244353\nans = 0\nfor i in range(N):\n    for j in range(M):\n        if G[i][j] % 2:\n            ans += (Grow[i][j]-1)*(Gcol[i][j]-1) + (i+2-Grow[i][j])*(j+2-Gcol[i][j])   \n        else:\n            ans += Grow[i][j]*(j+1-Gcol[i][j]) + (i+1-Grow[i][j])*Gcol[i][j]\n        ans %= mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# from : https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4212377\nH,W = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(H)]\nMOD = 998244353\n\npiv = 0\nfor w in range(W): # fix column, \n    r = -1\n    for h in range(piv, H):\n        if A[h][w] == 1:\n            r = h\n            break\n    if r == -1: # there is no odd cell for all the rows inside intersections.\n        continue \n\n    # You want to set ODD ROW ( A[h][w] == 1 ) into pivot row.\n    if r != piv: # already, skip.\n        for w in range(W): # swap rows\n            A[r][w], A[piv][w] = A[piv][w], A[r][w]\n\n    for h in range(H):\n        if h != piv and A[h][w] == 1: # really needed?\n            for k in range(h, W):\n                A[h][k] ^= A[piv][k] # for other rows, erase ...\n                # Hakidashi method: http://senkei.nomaki.jp/gaussian_elimination.html\n                # https://ja.wikipedia.org/wiki/%E3%82%AC%E3%82%A6%E3%82%B9%E3%81%AE%E6%B6%88%E5%8E%BB%E6%B3%95 : Gaussian Elimination\n    piv += 1\n\n\n# from pprint import pprint; pprint(A)\n\nret = 1\nret = pow(2, H, MOD)\n# for h in range(H):\n#     ret = ret * 2 % MOD\n\nsub = 1\n# for i in range(H-piv):\n#     sub = sub * 2 % MOD\nsub = pow(2, H-piv, MOD)\n\n\nret += MOD - sub          # ret = 2^N - 2^(N-r)\nret %= MOD\n\nfor i in range(W-1):      # ret *= 2^(M-1)\n    ret = ret * 2 % MOD\n\n# from editorial  : https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n# rank : r \n# 2^(N+M-1) - 2^(N+M-r-1)\n\nprint(ret % MOD) \n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    A_ = [0 for i in range(N)]\n    for i in range(N):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & 0x01 << i) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    for i in range(min(N, M)):\n        for j in range(i+1, N):\n            if ((A_[j] >> i) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[i]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - r\n    count1 = 1\n    for i in range(M-1):\n        count1 = (count1 * 2)%998244353\n    count2 = 1\n    for i in range(N):\n        count2 = (count2 * 2)%998244353\n    count3 = 1\n    for i in range(k):\n        count3 = (count3 * 2)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#include<bits/stdc++.h>\n#define rep(i,k,n) for(int i=k;i<=n;i++)\n#define rep2(i,k,n) for(int i=k;i>=n;i--)\n#define mod 998244353\nusing namespace std;\ninline void upd(int& x,int y){\n\tx+=y;\n\tx-= (x>mod) ? mod : 0;\n}\nconst int N=305;\nint pw[N<<1],f[N],a[N][N],n,m;\nint main(){\n\tpw[0]=1;rep(i,1,600)pw[i]=pw[i-1],upd(pw[i],pw[i-1]);\n\trep(i,1,N-1)f[i]=pw[(i-1)<<1],upd(f[i],f[i-1]),upd(f[i],f[i-1]);\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n)rep(j,1,m)scanf(\"%d\",&a[i][j]);\n\tint r=0;\n\trep(i,1,n){\n\t\tint t=0;\n\t\trep(j,i,n)if(a[j][i]){t=j;break;}\n\t\tif(!t)continue;\n\t\tr++;\n\t\trep(j,1,m)swap(a[i][j],a[t][j]);\n\t\trep(j,i+1,n)if(a[j][i]){\n\t\t\trep(k,i,m)a[j][k]^=a[i][k];\n\t\t}\n\t}\n\tint ans=1ll*f[r]*pw[n-r]%mod*pw[m-r]%mod;\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nN,M=map(int, raw_input().split())\nA=np.array( [ map(int, raw_input().split()) for i in range(N) ] )\n\nR=np.linalg.matrix_rank(A)\n\nprint (2**N - 2**(N-R) )*2**(M-1) "
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    A_ = [0 for i in range(N)]\n    all_zero_count = 0\n    for i in range(max(M, N)):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & (0x01 << i)) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            all_zero_count += 1\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    for i in range(min(N, M)):\n        for j in range(i+1, N):\n            if ((A_[j] >> i) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[i]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - min(r, M - all_zero_count)\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n \nn,m = map(int,input().split())\na = [list(map(int,input().split())) for i in range(n)]\n \na_np = np.array(a)\nrank = np.linalg.matrix_rank(a_np)\n \nteisu = 998244353\nans = (pow(2,m-1,teisu)*(pow(2,n,teisu)-pow(2,n-rank,teisu)))\nprint(ans%teisu)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nMOD = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in [0]*n])\n#a[:, [0, 1]] = a[:, [1, 0]]\n#print(a)\nr = 0\nfor i in range(min(m, n)):\n\tif a[i][i] != 1:\n\t\tfor j in range(i+1, m):\n\t\t\tif a[i][j] == 1:\n\t\t\t\ta[:, [i, j]] = a[:, [j, i]]\n\t\t\t\tbreak\n\t\telse:\n\t\t\tfor j in range(i+1, n):\n\t\t\t\tif a[j][i] == 1:\n\t\t\t\t\ta[[i, j]] = a[[j, i]]\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tbreak\n\tif a[i][i] == 0:\n\t\tcontinue\n\n\tr += 1\n\tfor j in range(i+1, m):\n\t\ta[:, j] += a[i][j] * a[:, i]\n\t\ta[:, j] %= 2\n\tfor j in range(i+1, n):\n\t\ta[j] += a[j][i] * a[i]\n\t\ta[j] %= 2\n#print(r)\nprint((pow(2, n+m-1, MOD) - pow(2, n+m-r-1, MOD)) % MOD)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN, M = map(int, input().split())\naij = np.zeros((N,M),dtype=int)\nfor i in range(M):\n  lst = list(map(int, input().split()))\n  for j, aj in enumerate(lst):\n    aij[i,j] = aj\n\ntotal = 0\nfor i in range(N):\n  for j in range(N+1):\n    for k in range(M):\n      for l in range(M+1):\n        part = aij[i:j, k:l]\n        if np.sum(part) % 2 != 0:\n          total += np.sum(part)\nprint(total)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as b,sys;(n,m),*a=[list(map(int,s.split()))for s in sys.stdin];o=998244353;n+=m-1;print((pow(2,n,o)-pow(2,n-b.linalg.matrix_rank(a,0),o))%o)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn,m=map(int,input().split())\nmod=998244353\nA=[]\nfor _ in range(n):\n    A.append(list(map(int,input().split())))\nrank=np.linalg.matrix_rank(A)\na=1\nb=1\nfor _ in range(n+m-1):\n    a*=2\n    a%=mod\nfor _ in range(n+m-rank-1):\n    b*=2\n    b%=mod\nprint(a-b)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    is_all_zero_set = set([])\n    A_ = [0 for i in range(N)]\n    all_zero_count = 0\n    for i in range(max(M, N)):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & (0x01 << i)) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            all_zero_count += 1\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_all_zero_set.add(j)\n                    is_set.add(j)\n                    break\n\n    row = 0\n    for i in range(min(N, M)):\n        if i in is_all_zero_set:\n            break\n        row += 1\n        for j in range(row+1, N):\n            if ((A_[j] >> row) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[row]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - min(r, M - all_zero_count)\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in range(n)])\nr = int(np.linalg.matrix_rank(a))\nprint((pow(2, n+m-1, mod)-pow(2, n+m-r-1, mod))%mod)\n"
  },
  {
    "language": "Python",
    "code": "# from : https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4212377\nH,W = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(H)]\nMOD = 998244353\n\npiv = 0\n\n# Gaussian Elimination to calculate rank of the matrix A\nfor w in range(W): # fix column, \n    r = -1\n    for h in range(piv, H):\n        if A[h][w] == 1:\n            r = h\n            break\n    if r == -1: # there is no odd cell for all the rows inside intersections.\n        continue \n\n    # You want to set ODD ROW ( A[h][w] == 1 ) into pivot row.\n    if r != piv: # already, skip.\n        for j in range(W): # swap rows\n            A[r][j], A[piv][j] = A[piv][j], A[r][j]\n\n    for h in range(H):\n        if h != piv and A[h][w] == 1: # really needed?\n            for j in range(W):\n                A[h][j] ^= A[piv][j] # for other rows, erase ...\n                # Hakidashi method: http://senkei.nomaki.jp/gaussian_elimination.html\n                # https://ja.wikipedia.org/wiki/%E3%82%AC%E3%82%A6%E3%82%B9%E3%81%AE%E6%B6%88%E5%8E%BB%E6%B3%95 : Gaussian Elimination\n    piv += 1\n\n\n# print(\"----output matrix ----\")\n# for h in range(H):\n#     print(A[h])\n# exit(0)\n\n\n# from pprint import pprint; pprint(A)\n\nret = 1\nret = pow(2, H, MOD)\n# for h in range(H):\n#     ret = ret * 2 % MOD\n\nsub = 1\n# for i in range(H-piv):\n#     sub = sub * 2 % MOD\nsub = pow(2, H-piv, MOD)\n\n\nret += MOD - sub          # ret = 2^N - 2^(N-r)\nret %= MOD\n\nfor i in range(W-1):      # ret *= 2^(M-1)\n    ret = ret * 2 % MOD\n\n# from editorial  : https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n# rank : r \n# 2^(N+M-1) - 2^(N+M-r-1)\n\nprint(ret % MOD) "
  },
  {
    "language": "Python",
    "code": "import numpy as np\n \nN,M=map(int, raw_input().split())\nA=np.array( [ map(int, raw_input().split()) for i in range(N) ] )\n \nR=np.linalg.matrix_rank(A)\n\nprint pow(2,N+M-1,998244353)-pow(2,N+M-R-1,998244353)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod=998244353\nn,m=map(int,input().split())\na=[0]*n\nfor i in range(n):\n    a[i] = list(map(int,input().split()))\nrnk = np.linalg.matrix_rank(np.array(a))\nx=n-rnk\ny=m-rnk\n\ndef powe(n,e):\n    ret=1\n    b=n\n    while e>0:\n        if e%2==1:\n            ret*=b\n        b=b*b\n        ret%=mod\n        b%=mod\n        e//=2\n    return ret\n\ntable = [[0]*301 for x in range(301)]\n\ndef inv(q):\n    return powe(q,mod-2)\n\nfor i in range(301):\n    table[i][0]=1\nfor p in range(301):\n    for q in range(1,p+1):\n        table[p][q] = (table[p][q-1]*(p-q+1)*inv(q))%mod\ndef nck(p,q):\n    return table[p][q]\nret=0\nfor s in range(1,rnk+1):\n    odds=0\n    for t in range(1,s+1):\n        if t%2==1:\n            odds+=nck(s,t)\n            odds%=mod\n    ret+=nck(rnk,s)*odds*powe(2,rnk-s)\n    ret%=mod\nprint((ret*powe(2,x)*powe(2,y))%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nmod=998244353\n\n\nn,m=map(int,input().split())\nA=[list(map(float,input().split())) for i in range(n)]\n\nA.sort(reverse=1)\nA=np.array(A)\n\n# if A[0][0]!=0\n\n#print(A)\nfor i in range(min(n,m)):\n    #print(A)\n    A=list(A)\n    A[i:].sort(reverse=1,key=lambda x:x[i])\n    if A[i][i]==0 :\n        A[i:].sort(key=lambda x:x[i])\n    A=np.array(A)\n    if A[i][i]!=0 :\n        w=A[i][i]\n        for k in range(m):\n            \n            A[i][k]/=w\n        for j in range(i+1,n):\n            A[j]-=A[i]*A[j][i]\n\n#print(A)\n\nr=0\nj=0\nfor i in range(m):\n    if A[j][i]!=0 :\n        r+=1\n        j+=1\n\nfor i in range(n):\n    for i in range(m):\n        A[i][j]=int(A[i][j])\n#print(A)\nprint(r) #rank\n\na=1\nb=1\n\nfor i in range(n+m-1):\n    a=(a*2)%mod\nfor i in range(n+m-1-r):\n    b=(b*2)%mod\n#print((a-b)%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport sys\n\nmod = 998244353\nn,m = list(map(int, input().split()))\ns = max(n,m)\nmat = np.zeros((s,s))\n\nfor i in range(n):\n    l = list(map(int, input().split()))\n    for j in range(m):\n      mat[i,j] = l[j]\n    \nr = np.linalg.matrix_rank(mat)\n\nans = (pow(2,n+m-1) - pow(2,n+m-r-1)) % mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    A_ = [0 for i in range(N)]\n    for i in range(N):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & 0x01 << i) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    for i in range(min(N, M)):\n        for j in range(i+1, N):\n            if (A_[j] >> i & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[i]\n    k = 0\n    for i in range(N):\n        if A_[i] == 0:\n            k += 1\n    k = N - k\n    count1 = 1\n    for i in range(M-1):\n        count1 = (count1 * 2)%998244353\n    count2 = 1\n    for i in range(N):\n        count2 = (count2 * 2)%998244353\n    count3 = 1\n    for i in range(k):\n        count3 = (count3 * 2)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "I=input;N,M=map(int,I().split());B=[]\nfor i in range(N):\n    s=int(I().replace(\" \",\"\"),2)\n    for b in B:s=min(s,s^b)\n    if s!=0:B.append(s)\nN+=M-1;print((2**N-2**(N-len(B)))%998244353)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n \nN,M=map(int, raw_input().split())\nA=np.array( [ map(int, raw_input().split()) for i in range(N) ] )\n \nR=np.linalg.matrix_rank(A)\n \nprint (2**N - 2**(N-R) )*2**(M-1) "
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport random\n\nmod=998244353\n\n\nn,m=map(int,input().split())\nA=[list(map(int,input().split())) for i in range(n)]\n\n#n,m=300,300\n#A=[[int(random.randint(0,1)) for j in range(m)] for i in range(n)]\n\n\n#A=np.array(A)\n\n#print(\"A\")\ni=0\nj=0\nr=0 #rank\nwhile i<n and j<m :\n    #print(i)\n    t=0\n    if A[i][j]==0 :\n        k=i\n        while k<n and A[k][j]==0 :\n            k+=1\n        if k<n :\n            A[i],A[k]=A[k],A[i]\n\n            #print(A)\n        else :\n            t=1\n            j+=1\n    if t==0 :\n        r+=1\n        for p in range(i+1,n):\n            if A[p][j]>0 :\n                for kk in range(j,m):\n                    A[p][kk]=(A[p][kk]-A[i][kk])%2\n        i+=1\n        j+=1\n\n\n\n#r=0\n#j=0\n#for i in range(m):\n#    if j<n :\n#        if A[j][i]!=0 :\n#            r+=1\n#            j+=1\n\nfor i in range(n):\n    for j in range(m):\n        A[i][j]=int(A[i][j])\n#print(A)\nprint(r) #rank\n\na=1\nb=1\n\nfor i in range(n+m-1):\n    a=(a*2)%mod\nfor i in range(n+m-1-r):\n    b=(b*2)%mod\n\nprint((a-b)%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport random\n\nmod=998244353\n\n\n#n,m=map(int,input().split())\n#A=[list(map(float,input().split())) for i in range(n)]\n\nn,m=300,250\n\nA=[[float(random.randint(0,1)) for j in range(m)] for i in range(n)]\n\nif n<m :\n    n,m=m,n\n    A=np.array(A)\n    A=A.T\n    A=list(A)\n\n\n\n# if A[0][0]!=0\n\n#print(A)\nfor i in range(min(n,m)):\n    #print(A)\n    A=list(A)\n    A[i:].sort(reverse=1,key=lambda x:x[i])\n    if A[i][i]==0 :\n        A[i:].sort(key=lambda x:x[i])\n    A=np.array(A)\n    if A[i][i]!=0 :\n        w=A[i][i]\n        for k in range(m):\n            \n            A[i][k]/=w\n        for j in range(i+1,n):\n            A[j]-=A[i]*A[j][i]\n\n#print(A)\n\nr=0\nj=0\nfor i in range(m):\n    if j<n :\n        if A[j][i]!=0 :\n            r+=1\n            j+=1\n\nfor i in range(n):\n    for j in range(m):\n        A[i][j]=int(A[i][j])\n#print(A)\n#print(r) #rank\n\na=1\nb=1\n\nfor i in range(n+m-1):\n    a=(a*2)%mod\nfor i in range(n+m-1-r):\n    b=(b*2)%mod\n\nprint((a-b)%mod)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    A_ = [0 for i in range(N)]\n    for i in range(N):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & 0x01 << i) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    for i in range(min(N, M)):\n        for j in range(i+1, N):\n            if ((A_[j] >> i) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[i]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - min(r, M)\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod = 998244353\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\n#F2で考えている\ndef rank(a):\n    n, m = len(a), len(a[0])\n    rank = 0\n    i, j = 0, 0\n    while i < n and j < m:\n        if a[i][j]:\n            rank += 1\n        else:\n            for ii in range(i+1, n):\n                if a[ii][j]:\n                    a[i], a[ii] = a[ii], a[i]\n                    rank += 1\n                    break\n\n            #breakで終わらなかった場合\n            else:\n                j += 1\n                continue\n        for ii in range(i+1, n):\n            if a[ii][j]:\n                for jj in range(j, m):\n                    a[ii][jj] = (a[ii][jj] + a[i][jj])%2\n        i += 1\n        j += 1\n\n    return rank\n\nr = rank(a)\nans = (pow(2, n+m-1, mod)-pow(2, n+m-r-1, mod))%mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# from : https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4212377\nH,W = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(H)]\nMOD = 998244353\n\npiv = 0\nfor w in range(W): # fix column, \n    r = -1\n    for h in range(piv, H):\n        if A[h][w] == 1:\n            r = h\n            break\n    if r == -1: # there is no odd cell for all the rows inside intersections.\n        continue \n\n    # You want to set ODD ROW ( A[h][w] == 1 ) into pivot row.\n    if r != piv: # already, skip.\n        for w in range(W): # swap rows\n            A[r][w], A[piv][w] = A[piv][w], A[r][w]\n\n    for h in range(H):\n        if h != piv and A[h][w] == 1:\n            for k in range(h, W):\n                A[h][k] ^= A[piv][k] # for other rows, erase ...\n                # Hakidashi method: http://senkei.nomaki.jp/gaussian_elimination.html\n                # https://ja.wikipedia.org/wiki/%E3%82%AC%E3%82%A6%E3%82%B9%E3%81%AE%E6%B6%88%E5%8E%BB%E6%B3%95 : Gaussian Elimination\n    piv += 1\n\n\n# from pprint import pprint; pprint(A)\n\nret = 1\nfor h in range(H):\n    ret = ret * 2 % MOD\n\nsub = 1\nfor i in range(H-piv):\n    sub = sub * 2 % MOD\n\nret += MOD - sub          # ret = 2^N - 2^(N-r)\n\nret %= MOD\nfor i in range(W-1):      # ret *= 2^(M-1)\n    ret = ret * 2 % MOD\n\n# from editorial  : https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n# rank : r \n# 2^(N+M-1) - 2^(N+M-r-1)\n\nprint(ret) "
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    is_all_zero_set = set([])\n    A_ = [0 for i in range(N)]\n    all_zero_count = 0\n    for i in range(max(M, N)):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & (0x01 << i)) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            all_zero_count += 1\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_all_zero_set.add(j)\n                    is_set.add(j)\n                    break\n\n    row = -1\n    for i in range(min(N, M)):\n        if i in is_all_zero_set:\n            break\n        row += 1\n        for j in range(row+1, N):\n            if ((A_[j] >> row) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[row]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - min(r, M - all_zero_count)\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n,m=map(int,input().split())\na=[int(input().replace(\" \",\"\"),2) for i in range(n)]\no=998244353\nc=0\nfor j in range(m)[::-1]:\n for i in range(c,n):\n  if a[i]&1<<j:\n   for k in range(n):\n    if i!=k and a[k]&1<<j:\n     a[k]^=a[i]\n   a[i],a[c]=a[c],a[i]\n   c+=1\np=lambda x:pow(2,x,o)\nprint(p(n+m-c-1)*(p(c)-1)%o)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    A_ = [0 for i in range(N)]\n    all_zero_count = 0\n    for i in range(max(M, N)):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & (0x01 << i)) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            all_zero_count += 1\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    for i in range(min(N, M)):\n        for j in range(i+1, N):\n            if ((A_[j] >> i) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[i]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - min(r, M)\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys, os\ntry: from typing import Any, Union, List, Tuple, Dict\nexcept ImportError: pass\nsys.setrecursionlimit(10**6)\nif os.environ.get(\"USER\") == \"shun\":\n    def debug(*args): print(*args, file=sys.stderr)\nelse:\n    print(\"NO DEBUG\", file=sys.stderr)\n    def debug(*args): pass\ndef exit(): sys.exit(0)\n\n\nl = int(input())\na = []\nfor _ in range(l):\n    a.append(int(input()))\n\ninit_score = 0\nfor i in range(l):\n    if a[i] == 0:\n        init_score += 2\n    elif a[i] % 2 == 0:\n        pass\n    else:\n        init_score += 1\n\nleft = [0]\nfor i in range(l):\n    left.append(left[i])\n    if a[i] == 0:\n        left[i+1] -= 2\n    elif a[i] % 2 == 0:\n        left[i+1] += a[i]\n    else:\n        left[i+1] += a[i] - 1\nleft_i = 0\nleft_min = left[0]\nfor i in range(l+1):\n    if left[i] < left_min:\n        left_i = i\n        left_min = left[i]\ndebug(left_i, left)\n\nright = [0] * (l+1)\nfor i in range(l, 0, -1):\n    right[i-1] = right[i]\n    if a[i-1] == 0:\n        right[i-1] -= 2\n    elif a[i-1] % 2 == 0:\n        right[i-1] += a[i-1]\n    else:\n        right[i-1] += a[i-1] - 1\nright_i = 0\nright_min = right[0]\nfor i in range(l+1):\n    if right[i] < right_min:\n        right_i = i\n        right_min = right[i]\ndebug(right_i, right)\n\n\n# odd\ntemp_score = init_score + left_min + right_min\nb = a[left_i:right_i]\nk = len(b)\n\nfor i in range(k):\n    if b[i] == 0:\n        temp_score -= 1\n    elif b[i] % 2 == 0:\n        temp_score += 1\n    else:\n        temp_score -= 1\n\n\nleft = [0]\nfor i in range(k):\n    left.append(left[i])\n    if b[i] == 0:\n        left[i+1] += 1\n    elif b[i] % 2 == 0:\n        left[i+1] -= 1\n    else:\n        left[i+1] += 1\nleft_i = 0\nleft_min = left[0]\nfor i in range(k+1):\n    if left[i] < left_min:\n        left_i = i\n        left_min = left[i]\ndebug(left_i, left)\n\nright = [0] * (k+1)\nfor i in range(k, 0, -1):\n    right[i-1] = right[i]\n    if b[i-1] == 0:\n        right[i-1] += 1\n    elif b[i-1] % 2 == 0:\n        right[i-1] -= 1\n    else:\n        right[i-1] += 1\nright_i = 0\nright_min = right[0]\nfor i in range(k+1):\n    if right[i] < right_min:\n        right_i = i\n        right_min = right[i]\ndebug(right_i, right)\n\nscore = temp_score + left_min + right_min\nprint(score)\n"
  },
  {
    "language": "Python",
    "code": "N,M=map(int,input().split());mod=998244353;B=[]\nfor i in range(N):\n    s=int(input().replace(\" \",\"\"),2)\n    for b in B:s=min(s,s^b)\n    if s!=0:B.append(s)\nprint((pow(2,N+M-1,mod)*(1-pow(2,mod-1-len(B),mod)))%mod)\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\nmod = 998244353\n\nfor i in range(n):\n    for j in range(m):\n        a[i][j] = a[i][j] % 2\n\n# 掃き出し法\nrank = 0\nfor i in range(n):\n    target = -1\n    for j in range(rank, m):\n        if a[i][j]:\n            target = j\n            break\n\n    if target == -1:\n        continue\n\n    if target != rank:\n        for k in range(rank, n):\n            a[k][rank], a[k][target] = a[k][target], a[k][rank]\n\n    for k in range(rank+1, n):\n        if a[k][rank]:\n            for j in range(rank, m):\n                a[k][j] -= a[rank][j]\n\n    rank += 1\n\n\ndef modpow(a, n, mod=mod):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * a % mod\n        a = a * a % mod\n        n >>= 1\n    return res\n\nprint(modpow(2, m-1) * (modpow(2, n) - modpow(2, n-rank)) % mod)\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m:\n            if a[j][s] > 0:\n                d = a[j][s]/a[i][s]\n                for k in range(s,m):\n                    a[j][k] -= d*a[i][k]\nr = 0\nfor i in range(n):\n    if sum(a[i]) != 0:\n        r += 1\nprint(pow(2,n+m-1)-pow(2,n-r+m-1))\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\na = [int(input().replace(\" \",\"\"),2) for i in range(n)]\nmod = 998244353\ncnt = 0\nfor j in range(m)[::-1]:\n  for i in range(cnt,n):\n    if a[i] & 1<<j:\n      for k in range(n):\n        if (i != k) and (a[k] & 1<<j):\n          a[k] ^= a[i]\n      a[i],a[cnt] = a[cnt],a[i]\n      cnt += 1\nans = pow(2,n+m-2*cnt,mod)*pow(2,cnt-1,mod)*(pow(2,cnt,mod)-1)%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\nmod = 998244353\n\nfor i in range(n):\n    for j in range(m):\n        a[i][j] = a[i][j] % 2\n\n# 掃き出し法\nrank = 0\nfor i in range(n):\n    target = -1\n    for j in range(rank, m):\n        if a[i][j]:\n            target = j\n            break\n\n    if target == -1:\n        continue\n\n    if target != rank:\n        for i in range(rank, n):\n            a[i][rank], a[i][target] = a[i][target], a[i][rank]\n\n    for k in range(rank+1, n):\n        if a[k][rank]:\n            for j in range(rank, m):\n                a[k][j] -= a[rank][j]\n\n    rank += 1\n\n\ndef modpow(a, n, mod=mod):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * a % mod\n        a = a * a % mod\n        n >>= 1\n    return res\n\nprint(modpow(2, m-1) * (modpow(2, n) - modpow(2, n-rank) % mod))\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nmod = 998244353\nn,m = list(map(int, input().split()))\nmat = np.zeros((n,m))\n\nfor i in range(n):\n    l = list(map(int, input().split()))\n    for j in range(m):\n      mat[i,j] = l[j]\n    \nr = np.linalg.matrix_rank(mat)\n\nans = (pow(2,m-1,mod) * ((pow(2,n,mod) - pow(2,n-r,mod + mod*mod)) % mod)) % mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN, M = map(int, input().split())\naij = np.zeros((N,M),dtype=int)\nfor i in range(N):\n  lst = list(map(int, input().split()))\n  for j, aj in enumerate(lst):\n    aij[i,j] = aj\n\ntotal = 0\nfor i in range(N):\n  for j in range(N+1):\n    for k in range(M):\n      for l in range(M+1):\n        part = aij[i:j, k:l]\n        if np.sum(part) % 2 != 0:\n          total += np.sum(part)\nprint(total)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    is_all_zero_set = set([])\n    A_ = [0 for i in range(N)]\n    all_zero_count = 0\n\n\n    for i in range(max(M, N)):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & (0x01 << i)) > 0:\n                is_all_zero =False\n            if (A[j] & (0x01 << i)) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            is_all_zero_set.add(i)\n            all_zero_count += 1\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    row = -1\n    for i in range(min(N, M)):\n        if i in is_all_zero_set:\n            continue\n        row += 1\n        for j in range(row+1, N):\n            if ((A_[j] >> i) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[row]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - min(r, M - all_zero_count)\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\nmod = 998244353\n\nfor i in range(n):\n    for j in range(m):\n        a[i][j] = a[i][j] % 2\n\n# 掃き出し法\nrank = 0\nfor i in range(n):\n    target = -1\n    for j in range(rank, m):\n        if a[i][j]:\n            target = j\n            break\n\n    if target == -1:\n        continue\n\n    if target != rank:\n        for k in range(n):\n            a[k][rank], a[k][target] = a[k][target], a[k][rank]\n\n    for k in range(rank+1, n):\n        if a[k][rank]:\n            for j in range(rank, m):\n                a[k][j] ^= a[rank][j]\n\n    rank += 1\n\n\ndef modpow(a, n, mod=mod):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * a % mod\n        a = a * a % mod\n        n >>= 1\n    return res\n\nprint(modpow(2, m-1) * (modpow(2, n) - modpow(2, n-rank)) % mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN()=lambda:list(map(int,input().split()))\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=np.linalg.matrix_rank(a)\nprint((2**(n+m-1)-2**(n+m-1-r))%998244353)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] != 0:\n            if a[j][s] > 0:\n                for k in range(s,m):\n                    a[j][k] -= 1*a[i][k]\n                    a[j][k] = abs(a[j][k])\nr = 0\nfor i in range(n):\n    if sum(a[i]) > 0:r += 1\nprint((pow(2,n+m-1)-pow(2,n-r+m-1))%998244353)\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "def rankmod2(A):\n    global N, M\n    ret = 0\n    i = 0\n    j = 0\n    while i < N and j < M:\n        if A[i][j]:\n            ret += 1\n        else:\n            for ii in range(i+1, N):\n                if A[ii][j]:\n                    A[i], A[ii] = A[ii], A[i]\n                    ret += 1\n                    break\n            else:\n                j += 1\n                continue\n                \n        for ii in range(i+1, N):\n            if A[ii][j]:\n                for jj in range(j, M):\n                    A[ii][jj] = (A[ii][jj] + A[i][jj]) % 2\n        i += 1\n        j += 1\n        \n    return ret\n                        \nP = 998244353\nN, M = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nr = rankmod2(A)\nprint((pow(2, N+M-1, P)-pow(2, N+M-r-1, P)) % P)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN=lambda:list(map(int,input().split()))\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=np.linalg.matrix_rank(a)\nprint((2**(n+m-1)-2**(n+m-1-r))%998244353)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod=998244353\nn,m=map(int,input().split())\na=[0]*n\nfor i in range(n):\n    a[i] = list(map(int,input().split()))\nrnk = np.linalg.matrix_rank(np.array(a))\nx=n-rnk\ny=m-rnk\n\ndef powe(n,e):\n    ret=1\n    b=n\n    while e>0:\n        if e%2==1:\n            ret*=b\n        b=b*b\n        ret%=mod\n        b%=mod\n        e//=2\n    return ret\n\ntable = [[0]*301 for x in range(301)]\n\ndef inv(q):\n    return powe(q,mod-2)\n\nfor i in range(301):\n    table[i][0]=1\nfor p in range(301):\n    for q in range(1,p+1):\n        table[p][q] = (table[p][q-1]*(p-q+1)*inv(q))%mod\ndef nck(p,q):\n    return table[p][q]\nret=0\nfor s in range(1,rnk+1):\n    odds=0\n    for t in range(1,s+1):\n        if t%2==1:\n            odds+=nck(s,t)\n            odds%=mod\n    ret+=nck(rnk,s)*odds*powe(2,rnk-s)\n    ret%=mod\nprint(ret)\nprint((ret*powe(2,x)*powe(2,y))%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport itertools\nfrom scipy import signal\n \nN, M = [int(s) for s in input().split()]\nA = np.zeros([N, M])\nfor n in range(N):\n\tA[n] = [int(m) for m in input().split()]\n \nN_fft, M_fft = 2*N, 2*M\nFa = np.fft.rfft2(A, [N_fft,M_fft])\n \noddnum = 0\nfor n, m in itertools.product(range(N), range(M)):\n\tW = np.fft.rfft2(np.ones([n+1,m+1]), [N_fft,M_fft]);\n\tAw = np.fft.irfft2(Fa*W).astype(int)\n\toddnum += np.sum(Aw[n:N, m:M] % 2 == 1)\n \nprint(oddnum % 998244353)"
  },
  {
    "language": "Python",
    "code": "# from : https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4212377\nN,M = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(N)]\nMOD = 998244353\n\n\nimport numpy as np\nnpA = np.array(A)\nrank = np.linalg.matrix_rank(npA)\n\n# ret = 1\n# for h in range(H):\n#     ret = ret * 2 % MOD\n# sub = 1\n# for i in range(H-rank):\n#     sub = sub * 2 % MOD\n# ret = (ret+ MOD  - sub) % MOD\n# \n# for w in range(W-1):\n#     ret = ret * 2 % MOD\n\n# from editorial  : https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n# rank : r \n# 2^(N+M-1) - 2^(N+M-r-1)\n\nprint ( (2**(N+M-1) - 2**(N+M-rank-1))%MOD ) \n# print(ret % MOD) \n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn,m=map(int,input().split())\nmod=998244353\nA=np.empty((0,m))\nfor _ in range(n):\n    A=np.append(A,np.array([list(map(int,input().split()))]),axis=0)\nrank=np.linalg.matrix_rank(A)\na=1\nb=1\nfor _ in range(n+m-1):\n    a*=2\n    a%=mod\nfor _ in range(n+m-rank-1):\n    b*=2\n    b%=mod\nans=(a-b)%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nmod = 998244353\n\nwhile True:\n    try:\n        n,m = map(int, raw_input().split())\n\n        mat = np.zeros((n,m))\n\n        for i in range(n):\n            mat[i] = map(int, raw_input().split())\n        \n        r = np.linalg.matrix_rank(mat)\n\n        ans = (pow(2,m-1,mod) * ((pow(2,n,mod) - pow(2,n-r,mod)) % mod)) % mod\n        print ans\n    except:\n        break\n        \n\n    \n"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\na = [int(input().replace(\" \",\"\"),2) for i in range(n)]\nmod = 998244353\ncnt = 0\nfor j in range(m):\n  for i in range(cnt,n):\n    if a[i] & 1<<j:\n      for k in range(n):\n        if i != k and a[k] & 1<<j:\n          a[k] ^= a[i]\n      a[i],a[cnt] = a[cnt],a[i]\n      cnt += 1\nans = pow(2,n+m-2*cnt,mod)*pow(2,cnt-1,mod)*(pow(2,cnt,mod)-1)%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\n\n# この２行は\n#   a   1 0 1 0\n#   b   1 1 0 0\n# こうしても、作れる集合の内訳が変わらない\n#   a   1 0 1 0\n#   b^a 0 1 1 0\n# {両方未選択, 上だけ選択, 下だけ選択, 両方選択}: {φ, a, b, a^b} == {φ, a, b^a, b}\n# これは列方向に対しても同じことなので、掃き出し法チックなことをして\n#   1 0 ... 0 0 0\n#   0 1 ... 0 0 0\n#   : :     : : :\n#   0 0 ... 1 0 0\n#   0 0 ... 0 0 0\n# こんな形にできる\n# ここで、行の選び方で'1'のある行を1つでも含むような選び方は、\n# その'1'の場所の列(どれでもいいので1つ)を選択するかしないかで、\n# 全体の和が偶数, 奇数となるパターンがちょうど半分ずつとなる。\n# よって、以下が答え\n# (行の全体の選び方 - '1'のある行を１つも含めない選び方) * 列の全体の選び方 / 2\n\nn, m = map(int, input().split())\nMOD = 998244353\nrows = []\nfor line in sys.stdin:\n    b = ''.join(line.rstrip().split())\n    rows.append(int(b, base=2))\n\nindependent_row = 0\nwhile rows:\n    x = max(rows)\n    if x == 0:\n        break\n    independent_row += 1\n    y = 1 << (x.bit_length() - 1)\n    rows = [r ^ x if r & y else r for r in rows if r != x]\n\nans = (pow(2, n + m - 1, MOD) - pow(2, n + m - independent_row - 1, MOD)) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nMOD = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in [0]*n])\n#a[:, [0, 1]] = a[:, [1, 0]]\n#print(a)\nr = 0\nfor i in range(min(m, n)):\n\tif a[i][i] != 1:\n\t\tfor j in range(i+1, m):\n\t\t\tif a[i][j] == 1:\n\t\t\t\ta[:, [i, j]] = a[:, [j, i]]\n\t\t\t\tbreak\n\t\telse:\n\t\t\tfor j in range(i+1, n):\n\t\t\t\tif a[j][i] == 1:\n\t\t\t\t\ta[[i, j]] = a[j, i]\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tbreak\n\tif a[i][i] == 0:\n\t\tcontinue\n\n\tr += 1\n\tfor j in range(i+1, m):\n\t\ta[:, j] -= a[i][j] * a[:, i]\n\t\ta[:, j] %= 2\n\tfor j in range(i+1, n):\n\t\ta[j] -= a[j][i] * a[i]\n\t\ta[j] %= 2\n\n#print(r)\nprint((pow(2, n+m-1, MOD) - pow(2, n+m-r-1, MOD)) % MOD)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nmod = 998244353\nn,m = list(map(int, input().split()))\nmat = np.zeros((n,m))\n\nfor i in range(n):\n    l = list(map(int, input().split()))\n    for j in range(m):\n      mat[i,j] = l[j]\n    \nr = np.linalg.matrix_rank(mat)\n\nans = (pow(2,n+m-1,mod) - pow(2,n+m-r-1,mod) + mod*mod) % mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn,m = map(int, input().split())\nA = np.array([ list(map(int, input().split())) for _ in range(n) ])\nr = np.linalg.matrix_rank(A)\nprint(((2**n - 2**(n-r))*(2**(m-1))) % 998244353)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n \nN,M=map(int, raw_input().split())\nA=np.array( [ map(int, raw_input().split()) for i in range(N) ] )\n \nR=np.linalg.matrix_rank(A)\n \nprint (2**N - 2**(N-R) )*2**(M-1) %998244353"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n \nn,m = map(int,input().split())\na = [list(map(int,input().split())) for i in range(n)]\n \na_np = np.array(a)\nrank = np.linalg.matrix_rank(a_np)\n \nteisu = 998244353\nans =(pow(2,n+m-1,teisu)-pow(2,n+m-1-rank,teisu))\nprint(ans%teisu)"
  },
  {
    "language": "Python",
    "code": "# 800 points\nimport math\n\n\n# -*- coding: utf-8 -*-\n# スペース区切りの整数の入力\nn, m = map(int, input().split())\n\n\nmatrix = []\n\nfor k in range(n):\n\n    str_row = input().split()\n    row = []\n    for j in range(m):\n\n        row.append(int(str_row[j]) % 2)\n\n    matrix.append(row)\nres_sum = 0\n\nfor mmin in range(m):\n    for mmax in range(mmin, m):\n        for nmin in range(n):\n            for nmax in range(nmin, n):\n\n                print(mmin,mmax,nmin,nmax)\n                counter = 0\n                for mi in range(mmin, mmax + 1):\n                    for ni in range(nmin, nmax + 1):\n                        counter += matrix[ni][mi]\n                        print(mi,ni)\n\n                print(\"couner\",counter)\n\n                if counter % 2 == 1:\n                    res_sum = (res_sum + 1) % 998244353\n\n\nprint(res_sum)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod=998244353\nn,m=map(int,input().split())\na=[0]*n\nfor i in range(n):\n    a[i] = list(map(int,input().split()))\nrnk = np.linalg.matrix_rank(np.array(a,dtype='int32'))\nx=n-rnk\ny=m-rnk\n\ndef powe(n,e):\n    ret=1\n    b=n\n    while e>0:\n        if e%2==1:\n            ret*=b\n        b=b*b\n        ret%=mod\n        b%=mod\n        e//=2\n    return ret\n\ntable = [[0]*301 for x in range(301)]\n\ndef inv(q):\n    return powe(q,mod-2)\n\nfor i in range(301):\n    table[i][0]=1\nfor p in range(301):\n    for q in range(1,p+1):\n        table[p][q] = (table[p][q-1]*(p-q+1)*inv(q))%mod\ndef nck(p,q):\n    return table[p][q]\nret=0\nfor s in range(1,rnk+1):\n    odds=0\n    for t in range(1,s+1):\n        if t%2==1:\n            odds+=nck(s,t)\n            odds%=mod\n    ret+=nck(rnk,s)*odds*powe(2,rnk-s)\n    ret%=mod\nprint((ret*powe(2,x)*powe(2,y))%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in range(n)])\nr = int(np.linalg.matrix_rank(a))\nprint(pow(2, n+m-1, mod)-pow(2, n+m-r-1, mod))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    A_ = [0 for i in range(N)]\n    for i in range(N):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & 0x01 << i) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    for i in range(min(N, M)):\n        for j in range(i+1, N):\n            if (A[i] >> i & 0x01) > 0:\n                A[j] = A[j] ^ A[i]\n    k = 0\n    for i in range(N):\n        if A[i] == 0:\n            k += 1\n\n    count1 = 1\n    for i in range(M-1):\n        count1 = (count1 * 2)%998244353\n    count2 = 1\n    for i in range(N):\n        count2 = (count2 * 2)%998244353\n    count3 = 1\n    for i in range(k):\n        count3 = (count3 * 2)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    is_all_zero_set = set([])\n    A_ = [0 for i in range(N)]\n    all_zero_count = 0\n    for i in range(max(M, N)):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & (0x01 << i)) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            all_zero_count += 1\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_all_zero_set.add(j)\n                    is_set.add(j)\n                    break\n\n    row = -1\n    for i in range(min(N, M)):\n        if i in is_all_zero_set:\n            continue\n        row += 1\n        for j in range(row+1, N):\n            if ((A_[j] >> row) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[row]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - min(r, M - all_zero_count)\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] != 0:\n            if a[j][s] > 0:\n                d = a[j][s]/a[i][s]\n                for k in range(s,m):\n                    a[j][k] -= d*a[i][k]\nr = 0\nfor i in range(n):\n    if sum(a[i]) > 0:r += 1\nprint((pow(2,n+m-1)-pow(2,n-r+m-1))%998244353)\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "#!venv/bin/python\n\nimport math\n\nN,M = [int(x) for x in input().split()]\nA = []\nfor i in range(N):\n    A.append([int(x) for x in input().split()])\n\nMOD = 998244353\n\nA0 = []\nA0_num = 0\nfor i in range(N):\n    a = A[i]\n    for n in a:\n        if n == 1:\n            A0.append(False)\n            break\n    else:\n        A0.append(True)\n        A0_num += 1\n\ncol_sum = [0 for i in range(M)]\n# print(A)\nfor col in range(M):\n    col_sum[col] += sum([x[col] for x in A])\n\n# print(col_sum)\n\nsmallest_col_sum = sorted(col_sum)[0]\n# print(smallest_col_sum)\n\ndef cmb_mod(n, k, mod=998244353):\n    # nCk (mod m)\n    def mod_permutation(n, k, mod):\n        if n<=k:\n            return 1\n        else:\n            return (n * mod_permutation(n-1,k,mod))%mod\n\n    def mod_inv_permutation(k, mod):\n        k, mod = int(k), int(mod)\n        if k<=1:\n            return 1\n        else:\n            return (pow(k,mod-2,mod) * mod_inv_permutation(k-1, mod))%mod\n\n    return (mod_permutation(n,n-k,mod) * mod_inv_permutation(k, mod))%mod\n\ndame_pair = 0\nfor evenval in range(2,smallest_col_sum + 1,2):\n    dame_pair += cmb_mod(smallest_col_sum,evenval)\nif dame_pair == 0:\n    dame_pair = 1\n\nans = 1\nfor i in range(N):\n    ans = ans * 2\n    ans = ans % MOD\n# print(\"ans\")\n# print(ans)\n\n# print(\"a0 num\")\n# print(A0_num)\ndame = dame_pair\nfor i in range(A0_num):\n    dame = dame * 2\n    dame = dame % MOD\n#dame += 1   # 0\n# print(\"dame\")\n# print(dame)\n\nans = (ans - dame) % MOD\nfor i in range(M-1):\n    ans = ans * 2\n    ans = ans % MOD\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    A_ = [0 for i in range(N)]\n    for i in range(N):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & 0x01 << i) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    for i in range(min(N, M)):\n        for j in range(i+1, N):\n            if (A_[j] >> i & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[i]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = M - r\n    count1 = 1\n    for i in range(M-1):\n        count1 = (count1 * 2)%998244353\n    count2 = 1\n    for i in range(N):\n        count2 = (count2 * 2)%998244353\n    count3 = 1\n    for i in range(k):\n        count3 = (count3 * 2)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod=998244353\nn,m=map(int,input().split())\na=[0]*n\nfor i in range(n):\n    a[i] = list(map(int,input().split()))\nrnk = np.linalg.matrix_rank(a)\nx=n-rnk\ny=m-rnk\n\ndef powe(n,e):\n    ret=1\n    b=n\n    while e>0:\n        if e%2==1:\n            ret*=b\n        b=b*b\n        ret%=mod\n        b%=mod\n        e//=2\n    return ret\n\ntable = [[0]*301 for x in range(301)]\n\ndef inv(q):\n    return powe(q,mod-2)\n\nfor i in range(301):\n    table[i][0]=1\nfor p in range(301):\n    for q in range(1,p+1):\n        table[p][q] = (table[p][q-1]*(p-q+1)*inv(q))%mod\ndef nck(p,q):\n    return table[p][q]\n\nret=0\nfor s in range(1,rnk+1):\n    odds=0\n    for t in range(1,s+1):\n        if t%2==1:\n            odds+=nck(s,t)\n            odds%=mod\n    ret+=nck(rnk,s)*odds*powe(2,rnk-s)\n    ret%=mod\n\nprint((ret*powe(2,x)*powe(2,y))%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport random\n\nmod=998244353\n\n\nn,m=map(int,input().split())\nA=[list(map(int,input().split())) for i in range(n)]\n\n#n,m=10,10\n#A=[[int(random.randint(0,1)) for j in range(m)] for i in range(n)]\n\n\n#A=np.array(A)\n\n#print(A)\ni=0\nj=0\nwhile i<n and j<m :\n    #for ii in range(len(A)):\n        #print(A[ii])\n    #print(\"\\n\")\n    t=0\n    #print(A[i][j])\n    if A[i][j]==0 :\n        #print(\"B\")\n        k=i\n        while k<n and A[k][j]==0 :\n            k+=1\n        #print(str(i)+\" \"+str(k))\n        if k<n :\n            #print(A)\n            #B=[A[i][0],A[i][1]]\n            #A[i]=[A[k][0],A[k][1]]\n            #A[k]=[B[0],B[1]]\n            for u in range(m):\n                A[i][u],A[k][u]=A[k][u],A[i][u]\n\n            #print(A)\n        else :\n            t=1\n            j+=1\n    #print(t)\n    if t==0 :\n        #print(\"A\")\n        #print(i)\n        for p in range(i+1,n):\n            #print(\"AA\")\n            if A[p][j]>0 :\n                #print(p)\n                for kk in range(m):\n                    A[p][kk]=(A[p][kk]-A[i][kk])%2\n        i+=1\n        j+=1\n\n\n#for i in range(len(A)):\n#    print(A[i])\n\nr=0\nj=0\nfor i in range(m):\n    if j<n :\n        if A[j][i]!=0 :\n            r+=1\n            j+=1\n\nfor i in range(n):\n    for j in range(m):\n        A[i][j]=int(A[i][j])\n#print(A)\n#print(r) #rank\n\na=1\nb=1\n\nfor i in range(n+m-1):\n    a=(a*2)%mod\nfor i in range(n+m-1-r):\n    b=(b*2)%mod\n\nprint((a-b)%mod)\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(N)]\n\nimport numpy as np\n\nrank = np.linalg.matrix_rank(np.array(A)).item()\n\nans = 1\nsub = 1\n\nMOD = 998244353\n# ans = 2**(N+M-r-r) * ( 2**r - 1 ) * ( 2 ** (r-1) )\n#     = 2**(N+M-r) * 2**(r-1) - 2**(N+M-r-1)\n#     = 2**(N+M-1)    - 2**(N+M-r-1)\n\nans = pow(2, N+M-1 , MOD)\nsub = pow(2, N+M-rank-1, MOD)\n\nprint( (ans - sub)%MOD)\n\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN=lambda:list(map(int,input().split()))\np=998244353\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=np.linalg.matrix_rank(a)\nprint((pow(2,n+m-1,p)-pow(2,n+m-1-r,p))%p)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\nimport numpy as np\nn,m = LI()\na = LIR(n)\na = np.array(a)\n\"\"\"\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] == 0:\n            if a[j][s] > 0:\n                d = a[j][s]/a[i][s]\n                for k in range(s,m):\n                    a[j][k] -= d*a[i][k]\nr = 0\nfor i in range(n):\n    if sum(a[i]) != 0:\n        r += 1\n\"\"\"\nr = np.linalg.matrix_rank(a)\nprint((pow(2,n+m-1)-pow(2,n-r+m-1))%998244353)\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\n\"\"\"\n列ベクトルが M 個ある\nいくつかを選ぶ（和をとる）→すべての行が0となる選び方：0、その他：2^{N-1}通り\n列ベクトル空間の生成する次元：d次元\nans = 2^{N-1} * (2^M - 2^[M-d})\n= 2^{N+M-1} * (1-2^{-rank})\n\"\"\"\n\nimport numpy as np\nMOD = 998244353\nN,M = map(int,input().split())\nA = np.array([[int(x) for x in input().split()] for _ in range(N)])\n\ndef rank(A):\n    # F_2 上の行列のrank\n    N,M = A.shape\n    if N == 0 or M == 0:\n        return 0\n    nz = np.nonzero(A[0])[0]\n    if len(nz) == 0:\n        # first col = zero\n        return rank(A[1:])\n    i = nz[0]\n    # swap\n    temp = A[:,i].copy()\n    A[:,i] = A[:,0]\n    A[:,0] = temp\n    # (0,0) 成分が 1 になった。行基本変形。\n    A ^= A[0][None,:] * A[:,0][:,None]\n    return 1 + rank(A[1:,1:])\n\nd = rank(A)\nanswer = pow(2,N+M-1,MOD) * (1 - pow(2,(-d)%(MOD-1), MOD)) % MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\nimport numpy as np\nn,m = LI()\na = LIR(n)\na = np.array(a)\n\"\"\"\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] == 0:\n            if a[j][s] > 0:\n                d = a[j][s]/a[i][s]\n                for k in range(s,m):\n                    a[j][k] -= d*a[i][k]\nr = 0\nfor i in range(n):\n    if sum(a[i]) != 0:\n        r += 1\n\"\"\"\nr = np.linalg.matrix_rank(a)\nprint(pow(2,n+m-1)-pow(2,n-r+m-1))\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nmod=998244353\n\n\nn,m=map(int,input().split())\nA=[list(map(float,input().split())) for i in range(n)]\n\nA.sort(reverse=1)\nA=np.array(A)\n\n# if A[0][0]!=0\n\n#print(A)\nfor i in range(min(n,m)):\n    #print(A)\n    A=list(A)\n    A[i:].sort(reverse=1,key=lambda x:x[i])\n    A=np.array(A)\n    if A[i][i]!=0 :\n        w=A[i][i]\n        for k in range(m):\n            \n            A[i][k]/=w\n        for j in range(i+1,n):\n            A[j]-=A[i]*A[j][i]\n\n#print(A)\n\nr=0\nj=0\nfor i in range(m):\n    if A[j][i]!=0 :\n        r+=1\n        j+=1\n\n#print(r) #rank\n\na=1\nb=1\n\nfor i in range(n+m-1):\n    a=(a*2)%mod\nfor i in range(n+m-1-r):\n    b=(b*2)%mod\nprint((a-b)%mod)\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] != 0:\n            if a[j][s] > 0:\n                for k in range(s,m):\n                    a[j][k] -= 1\n                    a[j][k] = abs(a[j][k])\nr = 0\nfor i in range(n):\n    if sum(a[i]) > 0:r += 1\nprint((pow(2,n+m-1)-pow(2,n-r+m-1))%998244353)\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in range(n)])\n\n#F2で考えている\ndef rank(a):\n    n, m = len(a), len(a[0])\n    rank = 0\n    i, j = 0, 0\n    while i < n and j < m:\n        if a[i][j]:\n            rank += 1\n        else:\n            for ii in range(i+1, n):\n                if a[ii][j]:\n                    a[i], a[ii] = a[ii], a[i]\n                    rank += 1\n                    break\n\n            #breakで終わらなかった場合\n            else:\n                j += 1\n                continue\n        for ii in range(i+1, n):\n            if a[ii][j]:\n                for jj in range(j, m):\n                    a[ii][jj] = (a[ii][jj] + a[i][jj])%2\n        i += 1\n        j += 1\n\n    return rank\n\nr = rank(a)\nans = (pow(2, n+m-1, mod)-pow(2, n+m-r-1, mod))%mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn,m = map(int, input().split())\nA = np.array([ list(map(int, input().split())) for _ in range(n) ])\nr = np.linalg.matrix_rank(A)\nprint((2**n - 2**(n-r))*2**(m-1))"
  },
  {
    "language": "Python",
    "code": "N,M=map(int,input().split())\nA=[[int(i) for i in input().split()] for i in range(N)]\nr=0\nmod=998244353\nfor j in range(M):\n  flag=False\n  for i in range(r,N):\n    if not flag:\n      if A[i][j]:\n        flag=True\n        A[i],A[r]=A[r],A[i]\n        r+=1\n    else:\n      if A[i][j]:\n        for k in range(M):\n          A[i][k]^=A[r-1][k]\n\nFactorial=[1]*(r+1)\nfor i in range(1,r+1):\n  Factorial[i]=Factorial[i-1]*(i)%mod\ndef power(x,y):\n  if y==0:\n    return 1\n  elif y==1:\n    return x%mod\n  elif y%2==0:\n    return power(x,y//2)**2%mod\n  else:\n    return (power(x,y//2)**2)*x%mod\n  \ninverseFactorial=[1]*(r+1)\ninverseFactorial[r]=power(Factorial[r],mod-2)\nfor i in range(0,r)[::-1]:\n  inverseFactorial[i]=(inverseFactorial[i+1]*(i+1))%mod\n  \ndef comb(x,y):\n  if x<y or y<0:\n    return 0\n  else:\n    return (Factorial[x]*inverseFactorial[y]*inverseFactorial[x-y])%mod\n\nans=0\na=1\nwhile a<=r:\n  ans=(ans+comb(r,a)*power(3,r-a)*power(4,min(N,M)-r)*power(2,max(N,M)-min(N,M)))%mod\n  a+=2\nprint(ans)\n  \n  \n        "
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN()=lambda:list(map(int,input().split()))\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=np.np.linalg.matrix_rank(a)\nprint((2**(n+m-1)-2**(n+m-1-r))%998244353)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn,m = map(int, input().split())\nA = np.array([ list(map(int, input().split())) for _ in range(n) ])\nr = int(np.linalg.matrix_rank(A))\nprint((pow(2, n+m-1, 998244353) - pow(2, n+m-r-1, 998244353)) % 998244353)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nmod = 998244353\n\nwhile True:\n    try:\n        n,m = map(long, raw_input().split())\n\n        mat = np.zeros((n,m))\n\n        for i in range(n):\n            mat[i] = map(long, raw_input().split())\n        \n        r = np.linalg.matrix_rank(mat)\n\n        ans = (pow(2,m-1,mod) * ((pow(2,n,mod) - pow(2,n-r,mod)) % mod)) % mod\n        print ans\n    except:\n        break\n        \n\n    \n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    mod = 998244353\n    N, M = map(int, input().split())\n    grid = []\n    for _ in range(N):\n        line = list(map(bool, map(int, input().split())))\n        grid.append(line)\n\n    cs = [[False] * (M+1) for _ in range(N+1)]\n    for i in range(N):\n        for j in range(M):\n            cs[i+1][j+1] = cs[i+1][j] ^ cs[i][j+1] ^ cs[i][j] ^ grid[i][j]\n\n    ans = 0\n    for i in range(N+1):\n        for j in range(i+1, N+1):\n            one = 0\n            for k in range(M+1):\n                if cs[i][k] ^ cs[j][k]:\n                    one += 1\n            ans = (ans + (one * (M+1 - one))%mod)%mod\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# from : https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4212377\nH,W = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(H)]\nMOD = 998244353\n\n\nimport numpy as np\nnpA = np.array(A)\nrank = np.linalg.matrix_rank(npA)\n\nret = 1\nfor h in range(H):\n    ret = ret * 2 % MOD\nsub = 1\nfor i in range(H-rank):\n    sub = sub * 2 % MOD\nret = (ret+ MOD  - sub) % MOD\n\nfor w in range(W-1):\n    ret = ret * 2 % MOD\n\n# from editorial  : https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n# rank : r \n# 2^(N+M-1) - 2^(N+M-r-1)\n\nprint(ret % MOD) "
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\n# MOD = 10 ** 9 + 7\nMOD = 998244353\n\nN, M = list(map(int, sys.stdin.readline().split()))\nA = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n\n# 列を選んだときに 1 が 1 個でもあれば奇数になるように選べるのが 2^(N-1) 通り\n# 0 個になる数を数えて引く\n\n# 方程式とく\nA = np.array(A, dtype=int)\nA = np.hstack((A, [[0] for _ in range(N)])).astype(bool)\nrank = 0\nfor col in range(M):\n    if rank >= N:\n        break\n    row = A[rank:, col].argmax() + rank\n    if not A[row, col]:\n        continue\n    pivot_row = A[row].copy()\n    A[A[:, col]] ^= pivot_row\n    A[row] = A[rank]\n    A[rank] = pivot_row\n    rank += 1\n\n# 1が1つ以上ある列の選び方\ncol_count = pow(2, M, MOD) - pow(2, M - rank, MOD)\n# 1が1つ以上ある列から行の選び方が 2^(N-1) ある\nans = col_count * pow(2, N - 1, MOD) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    A_str = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        A_str.append(input_raw)\n    is_all_zero_set = set([])\n    for i in range(M):\n        is_all_zero = True\n        for j in range(N):\n            if A_str[j][i] != \"0\":\n                is_all_zero = False\n                break\n        if is_all_zero == True:\n            is_all_zero_set.add(i)\n\n\n    for i in range(N):\n        col = -1\n        a = 0\n        for j in range(M):\n            if j in is_all_zero_set:\n                continue\n            col += 1\n            a += int(A_str[i][j]) << col\n        A.append(a)\n    M_new = col + 1\n##    is_set = set([])\n##    is_all_zero_set = set([])\n##    A_ = [0 for i in range(N)]\n##    all_zero_count = 0\n\n##    for i in range(max(M, N)):\n##        is_all_zero = True\n##        for j in range(N):\n##            if (A[j] & (0x01 << i)) > 0 and j not in is_set:\n##                A_[i] = A[j]\n##                is_set.add(j)\n##                break\n\n##    for i in range(max(M, N)):\n##        is_all_zero = True\n##        for j in range(N):\n##            if (A[j] & (0x01 << i)) > 0:\n##                is_all_zero =False\n##            if (A[j] & (0x01 << i)) > 0 and j not in is_set:\n##                A_[i] = A[j]\n##                is_set.add(j)\n##                is_all_zero =False\n##                break\n##        if is_all_zero == True:\n##            is_all_zero_set.add(i)\n##            all_zero_count += 1\n##            for j in range(N):\n##                if j not in is_set:\n##                    A_[i] = A[j]\n##                    is_set.add(j)\n##                    break\n\n    for i in range(min(N, M_new)):\n        if (A[i] >> i) & 0x01 == 0:\n            for j in range(i + 1, N):\n                if (A[j] >> i) & 0x01 > 0:\n                    tmp = A[j]\n                    A[j] = A[i]\n                    A[i] = tmp\n\n        for j in range(N):\n            if j == i:\n                continue\n            if ((A[j] >> i) & 0x01) > 0:\n                A[j] = A[j] ^ A[i]\n    r = 0\n    for i in range(N):\n        if A[i] != 0:\n            r += 1\n    k = N - min(r, M_new)\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    A_ = [0 for i in range(N)]\n    for i in range(N):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & 0x01 << i) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    for i in range(min(N, M)):\n        for j in range(i+1, N):\n            if ((A_[j] >> i) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[i]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - r\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\nmod = 998244353\n\nfor i in range(n):\n    for j in range(m):\n        a[i][j] = a[i][j] % 2\n\n# 掃き出し法\nrank = 0\nfor i in range(n):\n    target = -1\n    for j in range(rank, m):\n        if a[i][j]:\n            target = j\n            break\n\n    if target == -1:\n        continue\n\n    if target != rank:\n        for i in range(rank, n):\n            a[i][rank], a[i][target] = a[i][target], a[i][rank]\n\n    for i in range(rank+1, n):\n        if a[i][rank]:\n            for j in range(rank, m):\n                a[i][j] -= a[rank][j]\n\n    rank += 1\n\n\ndef modpow(a, n, mod=mod):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * a % mod\n        a = a * a % mod\n        n >>= 1\n    return res\n\nprint(modpow(2, m-1) * (modpow(2, n) - modpow(2, n-rank) % mod) )\n"
  },
  {
    "language": "Python",
    "code": "class GE():\n    def __init__(self, A, mod):\n        self.N = len(A)\n        self.M = len(A[0])\n        self.A = A[:]\n        self.mod = mod\n        self.uptri = None\n        self.pivot = []\n        self.R = None\n    def ut(self):\n        if self.uptri is not None:\n            return self.uptri\n        self.uptri = self.A[:]\n        \n        c = 0\n        for i in range(self.N):\n            if i + c >= self.M:\n                break\n            while self.uptri[i][i+c] == 0:\n                for j in range(i+1, self.N):\n                    if self.uptri[j][i+c]:\n                        self.uptri[i], self.uptri[j] = self.uptri[j], self.uptri[i]\n                        break\n                else:\n                    c += 1\n                    if i + c == self.M:\n                        return self.uptri\n            self.pivot.append((i, i+c))\n            t = pow(self.uptri[i][i+c], self.mod - 2, self.mod)\n            for j in range(i+1, self.N):\n                tj = t * self.uptri[j][i+c]\n                self.uptri[j][i+c:] = [(aj - tj*ai) % self.mod for ai, aj in zip(self.uptri[i][i+c:], self.uptri[j][i+c:])]\n        for pi, pj in self.pivot[::-1]:\n            t = pow(self.uptri[pi][pj], self.mod-2, self.mod)\n            self.uptri[pi][pj:] = [(ai * t) % self.mod for ai in self.uptri[pi][pj:]]\n            for i in range(pi-1, -1, -1):\n                ti = self.uptri[i][pj]\n                self.uptri[i][pj:] = [(ai - api*ti) % self.mod for ai, api in zip(self.uptri[i][pj:], self.uptri[pi][pj:])]\n        \n        return self.uptri\n    def rank(self):\n        if self.R is not None:\n            return self.R\n        self.ut()\n        self.R = len(self.pivot)\n        return self.R\nN, M = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nmod = 998244353\nT = GE(A, 2)\nprint((pow(2, N+M-1, mod) - pow(2, N+M-T.rank()-1, mod)) % mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as b,sys;(n,m),*a=[list(map(int,s.split()))for s in sys.stdin];o=998244353;n+=m-1;print((pow(2,n,o)-pow(2,n-b.linalg.matrix_rank(a),o))%o)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn,m = map(int,input().split())\na = [list(map(int,input().split())) for i in range(n)]\n\na_np = np.array(a)\nrank = np.linalg.matrix_rank(a_np)\n\nteisu = 998244353\nprint(pow(2,m-1,teisu)*(pow(2,n,teisu)-pow(2,n-rank,teisu)))"
  },
  {
    "language": "Python",
    "code": "N,M=map(int, raw_input().split())\nA=[ map(int, raw_input().split()) for i in range(N) ]\n\nif N>M:  N,M=M,N\n\nfor k in range(N): #k: pivot\n\tif A[k][k]==0 and max(A[k])==1:\n\t\tfor i in range(N):\n\t\t\tif A[i][k]==1:\n\t\t\t\t#Gyou koukan\n\t\t\t\tA[k],A[i] = A[i],A[k]\n\t\t\t\tbreak\n\n\tfor i in range(N):\n\t\tif i!=k and A[i][k]==1:\n\t\t\tfor j in range(M):\n\t\t\t\tA[i][j]+=A[k][j]\n\t\t\t\tA[i][j]%=2\n\nr=0 #Rank\n\nfor x in A:\n\tif max(x)!=0: r+=1\n\n\np=998244353\n\nprint ( pow(2,N+M-1,p)-pow(2,N+M-r-1,p) )%p\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    is_all_zero_set = set([])\n    A_ = [0 for i in range(N)]\n    all_zero_count = 0\n    for i in range(max(M, N)):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & (0x01 << i)) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            is_all_zero_set.add(i)\n            all_zero_count += 1\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    row = -1\n    for i in range(min(N, M)):\n        if i in is_all_zero_set:\n            continue\n        row += 1\n        for j in range(row+1, N):\n            if ((A_[j] >> row) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[row]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - min(r, M - all_zero_count)\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "N,M=map(int, raw_input().split())\nA=[ map(int, raw_input().split()) for i in range(N) ]\n\nfor k in range( min(N,M) ): #k: pivot\n\tif A[k][k]==0:\n\t\tfor i in range(N):\n\t\t\tif A[i][k]==1:\n\t\t\t\t#Gyou koukan\n\t\t\t\tA[k],A[i] = A[i],A[k]\n\t\t\t\tbreak\n\n\tfor i in range(N):\n\t\tif i!=k and A[i][k]==1:\n\t\t\tfor j in range(M):\n\t\t\t\tA[i][j]+=A[i-1][j]\n\t\t\t\tA[i][j]%=2\n\nr=0 #Rank\n\nfor x in A:\n\tif max(x)!=0: r+=1\n\n\np=998244353\n\nprint ( pow(2,N+M-1,p)-pow(2,N+M-r-1,p) )%p"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn,m=map(int,input().split())\nmod=998244353\nA=[]\nfor _ in range(n):\n    A.append(list(map(int,input().split())))\nrank=np.linalg.matrix_rank(A)\nans=2**(n+m-1)%mod-2**(n+m-rank-1)%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in range(n)])\nif n > m:\n    a = a.T\n    n, m = m, n\nr = int(np.linalg.matrix_rank(a))\nans = (pow(2, n+m-1, mod)-pow(2, n+m-r-1, mod))%mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def intmod2(n):\n    return int(n) % 2\n\ndef rankmod2(A):\n    global N, M\n    ret = 0\n    i = 0\n    j = 0\n    while i < N and j < M:\n        if A[i][j]:\n            ret += 1\n        else:\n            for ii in range(i+1, N):\n                if A[ii][j]:\n                    A[i], A[ii] = A[ii], A[i]\n                    ret += 1\n                    break\n            else:\n                j += 1\n                continue\n                \n        for ii in range(i+1, N):\n            if A[ii][j]:\n                for jj in range(j, M):\n                    A[ii][jj] = (A[ii][jj] + A[i][jj]) % 2\n        i += 1\n        j += 1\n        \n    return ret\n                        \nP = 998244353\nN, M = map(int, input().split())\nA = [list(map(intmod2, input().split())) for _ in range(N)]\nr = rankmod2(A)\nprint((pow(2, N+M-1, P)-pow(2, N+M-r-1, P)) % P)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn,m=map(int,input().split())\nmod=998244353\nA=[]\nfor _ in range(n):\n    A.append(list(map(int,input().split())))\nrank=np.linalg.matrix_rank(A)\nans=((2**(n+m)-2**(n+m-rank))//2)%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\na = [int(input().replace(\" \",\"\"),2) for i in range(n)]\nmod = 998244353\ncnt = 0\nfor j in range(m)[::-1]:\n  for i in range(cnt,n):\n    if a[i] & 1<<j:\n      for k in range(n):\n        if (i != k) and (a[k] & 1<<j):\n          a[k] ^= a[i]\n      a[i],a[cnt] = a[cnt],a[i]\n      cnt += 1\nif cnt == 0:\n  print(0)\nelse:\n  ans = pow(2,n+m-2*cnt,mod)*pow(2,cnt-1,mod)*(pow(2,cnt,mod)-1)%mod\n  print(ans)"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\nmod = 998244353\n\nfor i in range(n):\n    for j in range(m):\n        a[i][j] = a[i][j] % 2\n\n# 掃き出し法\nrank = 0\nfor i in range(n):\n    target = -1\n    for j in range(rank, m):\n        if a[i][j]:\n            target = j\n            break\n\n    if target == -1:\n        continue\n\n    if target != rank:\n        for k in range(rank, n):\n            a[k][rank], a[k][target] = a[k][target], a[k][rank]\n\n    for k in range(rank+1, n):\n        if a[k][rank]:\n            for j in range(rank, m):\n                a[k][j] ^= a[rank][j]\n\n    rank += 1\n\n\ndef modpow(a, n, mod=mod):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * a % mod\n        a = a * a % mod\n        n >>= 1\n    return res\n\nprint(modpow(2, m-1) * (modpow(2, n) - modpow(2, n-rank)) % mod)\n"
  },
  {
    "language": "Python",
    "code": "class GE():\n    #mod2　なら　Aは1重リストで渡して, max(bit_length) をMに渡してあげた方が速い\n    def __init__(self, A, mod, M = 0):\n        self.N = len(A)\n        if M:\n            self.M = M\n        else:\n            self.M = len(A[0])\n        self.mod = mod\n        self.A = A[:]\n        self.uptri = None\n        self.A2 = None\n        self.pivot = []\n        self.R = None\n    def ut(self):\n        if self.mod != 2:\n            if self.uptri is not None:\n                return self.uptri\n            self.uptri = self.A[:]\n            c = 0\n            for i in range(self.N):\n                if i + c >= self.M:\n                    break\n                while self.uptri[i][i+c] == 0:\n                    for j in range(i+1, self.N):\n                        if self.uptri[j][i+c]:\n                            self.uptri[i], self.uptri[j] = self.uptri[j], self.uptri[i]\n                            break\n                    else:\n                        c += 1\n                        if i + c == self.M:\n                            break\n                else:\n                    self.pivot.append((i, i+c))\n                    t = pow(self.uptri[i][i+c], self.mod - 2, self.mod)\n                    for j in range(i+1, self.N):\n                        tj = t * self.uptri[j][i+c]\n                        self.uptri[j][i+c:] = [(aj - tj*ai) % self.mod for ai, aj in zip(self.uptri[i][i+c:], self.uptri[j][i+c:])]\n                    continue\n                break\n            for pi, pj in self.pivot[::-1]:\n                t = pow(self.uptri[pi][pj], self.mod-2, self.mod)\n                self.uptri[pi][pj:] = [(ai * t) % self.mod for ai in self.uptri[pi][pj:]]\n                for i in range(pi-1, -1, -1):\n                    ti = self.uptri[i][pj]\n                    self.uptri[i][pj:] = [(ai - api*ti) % self.mod for ai, api in zip(self.uptri[i][pj:], self.uptri[pi][pj:])]\n            \n            return self.uptri\n        else:\n            if self.A2 is not None:\n                return self.A2\n            self.A2 = self.A[:]\n            c = 0\n            for i in range(self.N):\n                if i + c >= self.M:\n                    break\n                while not self.A2[i] & 2**(i+c):\n                    for j in range(i+1, self.N):\n                        if self.A2[j] & 2**(i+c):\n                            self.A2[i], self.A2[j] = self.A2[j], self.A2[i]\n                            break\n                    else:\n                        c += 1\n                        if i + c == self.M:\n                            break\n                else:\n                    self.pivot.append((i, i+c))\n                    for j in range(i+1, self.N):\n                        if self.A2[j] & 2**(i+c):\n                            self.A2[j] ^= self.A2[i]\n                    continue\n                break\n            for pi, pj in self.pivot[::-1]:\n                for i in range(pi-1, -1, -1):\n                    if 2**pj & self.A2[i]:\n                        self.A2[i] ^= self.A2[pi]\n            \n            return self.A2\n            \n                \n    def rank(self):\n        if self.R is not None:\n            return self.R\n        self.ut()\n        self.R = len(self.pivot)\n        return self.R\n\nN, M = map(int, input().split())\nA = [sum(2**i for i, v in enumerate(map(int, input().split())) if v == 1)  for _ in range(N)]\nmod = 998244353\nT = GE(A, 2, M)\nprint((pow(2, N+M-1, mod) - pow(2, N+M-T.rank()-1, mod)) % mod)\n"
  },
  {
    "language": "Python",
    "code": "N,M=map(int,input().split());mod=998244353;base=[]\nfor i in range(N):\n    A=input().split();s=sum(int(A[j])*2**j for j in range(M))\n    for b in base:s=min(s,s^b)\n    if s!=0:base.append(s)\nres=N-len(base);print((pow(2,N+M-1,mod)-pow(2,M-1+res,mod))%mod)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn,m = map(int,input().split())\na = [list(map(int,input().split())) for i in range(n)]\n\na_np = np.array(a)\nrank = np.linalg.matrix_rank(a_np)\n\nprint((2**(m-1))*(2**n - 2**(n-rank)))"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport random\n\nmod=998244353\n\n\n#n,m=map(int,input().split())\n#A=[list(map(int,input().split())) for i in range(n)]\n\nn,m=300,300\nA=[[int(random.randint(0,1)) for j in range(m)] for i in range(n)]\n\n\n#A=np.array(A)\n\n#print(\"A\")\ni=0\nj=0\nr=0 #rank\nwhile i<n and j<m :\n    #print(i)\n    t=0\n    if A[i][j]==0 :\n        k=i\n        while k<n and A[k][j]==0 :\n            k+=1\n        if k<n :\n            A[i],A[k]=A[k],A[i]\n\n            #print(A)\n        else :\n            t=1\n            j+=1\n    if t==0 :\n        r+=1\n        for p in range(i+1,n):\n            if A[p][j]>0 :\n                for kk in range(j,m):\n                    A[p][kk]=(A[p][kk]-A[i][kk])%2\n        i+=1\n        j+=1\n\n\n\n#r=0\n#j=0\n#for i in range(m):\n#    if j<n :\n#        if A[j][i]!=0 :\n#            r+=1\n#            j+=1\n\nfor i in range(n):\n    for j in range(m):\n        A[i][j]=int(A[i][j])\n#print(A)\nprint(r) #rank\n\na=1\nb=1\n\nfor i in range(n+m-1):\n    a=(a*2)%mod\nfor i in range(n+m-1-r):\n    b=(b*2)%mod\n\nprint((a-b)%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN=lambda:list(map(int,input().split()))\nPJ=lambda x:pow(2,x,998244353)\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=np.linalg.matrix_rank(a)\nprint(PJ(n+m-1)-PJ(n+m-1-r))"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nmod = 998244353\n\ndef modpow(x, n):\n    if(n==0):\n        return 1\n    else:\n        return (modpow(x, n-1)*x) % mod\n\nn,m = map(int, input().split())\na = np.array([ list(map(int, input().split())) for _ in range(n) ])\n\nr = np.linalg.matrix_rank(a)\nans = (modpow(2, n+m-1) - modpow(2, n+m-r-1)) % mod\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N,M=map(int,input().split());mod=998244353;B=set([0])\nfor i in range(N):\n    A=input().split();s=sum(int(A[j])*2**j for j in range(M))\n    for b in B:s=min(s,s^b)\n    B.add(s)\nprint((pow(2,N+M-1,mod)*(1-pow(2,mod-len(B),mod)))%mod)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod=998244353\nn,m=map(int,input().split())\na=[0]*n\nfor i in range(n):\n    a[i] = list(map(int,input().split()))\nrnk = np.linalg.matrix_rank(a)\n\ndef powe(n,e):\n    ret=1\n    b=n\n    while e>0:\n        if e%2==1:\n            ret*=b\n        b=b*b\n        ret%=mod\n        b%=mod\n        e//=2\n    return ret\n\nprint((mod+powe(2,n+m-1)-powe(2,n+m-rnk-1))%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as b,sys;(n,m),*a=[list(map(int,s.split()))for s in sys.stdin];n+=m-1;print((2**n-2**int(n-b.linalg.matrix_rank(a,0)))%998244353)"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nMOD = 998244353\n\n\nru = [[0] * (m + 1) for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        ru[i][j + 1] = ru[i][j] + a[i][j]\n\nans = 0\nfor l in range(m):\n    for r in range(l + 1, m + 1):\n        cnt = []\n        for i in range(n):\n            cnt.append((ru[i][r] - ru[i][l]) % 2)\n        \n        dp = [[0] * (n + 1) for i in range(2)]\n        for i, val in enumerate(cnt):\n            dp[val][i + 1] = 1\n            dp[0 ^ val][i + 1] += dp[0][i]\n            dp[0 ^ val][i + 1] %= MOD\n            dp[1 ^ val][i + 1] += dp[1][i]\n            dp[1 ^ val][i + 1] %= MOD\n        ans += sum(dp[1])\n        ans %= MOD\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    A_ = [0 for i in range(N)]\n    for i in range(N):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & 0x01 << i) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    for i in range(min(N, M)):\n        for j in range(i+1, N):\n            if (A_[j] >> i & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[i]\n    k = 0\n    for i in range(N):\n        if A_[i] == 0:\n            k += 1\n\n    count1 = 1\n    for i in range(M-1):\n        count1 = (count1 * 2)%998244353\n    count2 = 1\n    for i in range(N):\n        count2 = (count2 * 2)%998244353\n    count3 = 1\n    for i in range(k):\n        count3 = (count3 * 2)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nMOD = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in [0]*n])\n#a[:, [0, 1]] = a[:, [1, 0]]\n#print(a)\nr = 0\nfor i in range(n):\n\tif a[i][i] != 1:\n\t\tfor j in range(i+1, m):\n\t\t\tif a[i][j] == 1:\n\t\t\t\ta[:, [i, j]] = a[:, [j, i]]\n\t\t\t\tbreak\n\t\telse:\n\t\t\tfor j in range(i+1, n):\n\t\t\t\tif a[j][i] == 1:\n\t\t\t\t\ta[[i, j]] = a[[j, i]]\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tbreak\n\tif a[i][i] == 0:\n\t\tcontinue\n\n\tr += 1\n\tfor j in range(i+1, m):\n\t\ta[:, [j]] += a[i][j] * a[:, [i]]\n\t\ta[:, [j]] %= 2\n\tfor j in range(i+1, n):\n\t\ta[[j]] += a[j][i] * a[[i]]\n\t\ta[[j]] %= 2\n#print(r)\nprint((pow(2, n+m-1, MOD) - pow(2, n+m-r-1, MOD)) % MOD)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport random\n\nmod=998244353\n\n\n#n,m=map(int,input().split())\n#A=[list(map(float,input().split())) for i in range(n)]\n\nn,m=300,250\n\nA=[[float(random.randint(0,1)) for j in range(m)] for i in range(n)]\n\nif n<m :\n    n,m=m,n\n    A=np.array(A)\n    A=A.T\n    A=list(A)\n\n\n\n# if A[0][0]!=0\n\n#print(A)\nfor i in range(min(n,m)):\n    #print(A)\n    A=list(A)\n    A[i:].sort(reverse=1,key=lambda x:x[i])\n    if A[i][i]==0 :\n        A[i:].sort(key=lambda x:x[i])\n    A=np.array(A)\n    if A[i][i]!=0 :\n        w=A[i][i]\n        for k in range(m):\n            \n            A[i][k]/=w\n        for j in range(i+1,n):\n            A[j]-=A[i]*A[j][i]\n\n#print(A)\n\nr=0\nj=0\nfor i in range(m):\n    if j<n :\n        if A[j][i]!=0 :\n            r+=1\n            j+=1\n\nfor i in range(n):\n    for j in range(m):\n        A[i][j]=int(A[i][j])\n#print(A)\nprint(r) #rank\n\na=1\nb=1\n\nfor i in range(n+m-1):\n    a=(a*2)%mod\nfor i in range(n+m-1-r):\n    b=(b*2)%mod\n\nprint((a-b)%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn,m = map(int, input().split())\nA = np.array([ list(map(int, input().split())) for _ in range(n) ])\nr = np.linalg.matrix_rank(A)\nprint(((2**n - 2**(n-r))*2**(m-1)) % 998244353)"
  },
  {
    "language": "Python",
    "code": "# from : https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4212377\nH,W = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(H)]\nMOD = 998244353\n\npiv = 0\n\n# Gaussian Elimination to calculate rank of the matrix A\nfor w in range(W): # fix column, \n    r = -1\n    for h in range(piv, H):\n        if A[h][w] == 1:\n            r = h\n            break\n    if r == -1: # there is no odd cell for all the rows inside intersections.\n        continue \n\n    # You want to set ODD ROW ( A[h][w] == 1 ) into pivot row.\n    if r != piv: # already, skip.\n        for j in range(W): # swap rows\n            A[r][j], A[piv][j] = A[piv][j], A[r][j]\n\n    # for h in \n    for h in range(H):\n        if h != piv and A[h][w] == 1: # really needed?\n            # for j in range(W):\n            for k in range(h, W):\n                A[h][k] ^= A[piv][k]\n                # A[h][j] ^= A[piv][j] # for other rows, erase ...\n                # Hakidashi method: http://senkei.nomaki.jp/gaussian_elimination.html\n                # https://ja.wikipedia.org/wiki/%E3%82%AC%E3%82%A6%E3%82%B9%E3%81%AE%E6%B6%88%E5%8E%BB%E6%B3%95 : Gaussian Elimination\n    piv += 1\n\n\n# print(\"----output matrix ----\")\n# for h in range(H):\n#     print(A[h])\n# exit(0)\n\n\n# from pprint import pprint; pprint(A)\n\nret = 1\nret = pow(2, H, MOD)\n# for h in range(H):\n#     ret = ret * 2 % MOD\n\nsub = 1\n# for i in range(H-piv):\n#     sub = sub * 2 % MOD\nsub = pow(2, H-piv, MOD)\n\n\nret += MOD - sub          # ret = 2^N - 2^(N-r)\nret %= MOD\n\nfor i in range(W-1):      # ret *= 2^(M-1)\n    ret = ret * 2 % MOD\n\n# from editorial  : https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n# rank : r \n# 2^(N+M-1) - 2^(N+M-r-1)\n\nprint(ret % MOD) "
  },
  {
    "language": "Python",
    "code": "N,M=map(int, raw_input().split())\nA=[ map(int, raw_input().split()) for i in range(N) ]\n\nif N>M:  N,M=M,N\n\nfor k in range(N): #k: pivot\n\tif A[k][k]==0:\n\t\tfor i in range(N):\n\t\t\tif A[i][k]==1:\n\t\t\t\t#Gyou koukan\n\t\t\t\tA[k],A[i] = A[i],A[k]\n\t\t\t\tbreak\n\n\tfor i in range(N):\n\t\tif i!=k and A[i][k]==1:\n\t\t\tfor j in range(M):\n\t\t\t\tA[i][j]+=A[k][j]\n\t\t\t\tA[i][j]%=2\n\nr=0 #Rank\n\nfor x in A:\n\tif max(x)!=0: r+=1\n\n\np=998244353\n\nprint ( pow(2,N+M-1,p)-pow(2,N+M-r-1,p) )%p"
  },
  {
    "language": "Python",
    "code": "N,M=map(int, raw_input().split())\nA=[ map(int, raw_input().split()) for i in range(N) ] \n\nfor k in range(N):\t#k: pivot\n\n\tif A[k][k]==0:\n\t\tfor i in range(N):\n\t\t\tif A[i][k]==1:\n\t\t\t\t#Gyou koukan\n\t\t\t\tfor j in range(M):\n\t\t\t\t\tA[k][j],A[i][j] = A[i][j],A[k][j]\n\t\t\t\tbreak\n\n\tfor i in range(N):\n\t\tif i!=k:\n\t\t\tfor j in range(M):\t#retsu\n\t\t\t\tif A[i][k]==1:\n\t\t\t\t\tfor j in range(M):\n\t\t\t\t\t\tA[i][j]+=A[i-1][j]\n\t\t\t\t\t\tA[i][j]%=2\n\n\nr=0 #Rank\n\nfor x in A:\n\tif max(x)!=0: r+=1\n\n\np=998244353\n\nprint ( pow(2,N+M-1,p)-pow(2,N+M-r-1,p) )%p"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN=lambda:list(map(int,input().split()))\np=998244353\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=np.linalg.matrix_rank(a)\nf=n+m-1\nd=f-r\nprint((pow(2,f,p)-pow(2,d,p))%p)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    is_all_zero_set = set([])\n    A_ = [0 for i in range(N)]\n    all_zero_count = 0\n    for i in range(max(M, N)):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & (0x01 << i)) > 0:\n                is_all_zero =False\n            if (A[j] & (0x01 << i)) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            is_all_zero_set.add(i)\n            all_zero_count += 1\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    row = -1\n    for i in range(min(N, M)):\n        if i in is_all_zero_set:\n            continue\n        row += 1\n        for j in range(row+1, N):\n            if ((A_[j] >> row) & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[row]\n    r = 0\n    for i in range(N):\n        if A_[i] != 0:\n            r += 1\n    k = N - min(r, M - all_zero_count)\n    count1 = 1L\n    for i in range(M-1):\n        count1 = (count1 * 2L)%998244353\n    count2 = 1L\n    for i in range(N):\n        count2 = (count2 * 2L)%998244353\n    count3 = 1L\n    for i in range(k):\n        count3 = (count3 * 2L)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn,m=map(int,input().split())\nmod=998244353\nA=np.empty((0,m))\nfor _ in range(n):\n    A=np.append(A,np.array([list(map(int,input().split()))]),axis=0)\nif n>m:\n    A=A.T\nrank=np.linalg.matrix_rank(A)\na=1\nb=1\nfor _ in range(n+m-1):\n    a*=2\n    a%=mod\nfor _ in range(n+m-rank-1):\n    b*=2\n    b%=mod\nans=(a-b)%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n,m=map(int,input().split())\na=[int(input().replace(\" \",\"\"),2) for i in range(n)]\no=998244353\nc=0\nfor j in range(m)[::-1]:\n for i in range(c,n):\n  if a[i]&1<<j:\n   for k in range(n):\n    if i!=k and a[k]&1<<j:a[k]^=a[i]\n   a[i],a[c]=a[c],a[i];c+=1\np=lambda x:pow(2,x,o)\nprint(p(n+m-c-1)*(p(c)-1)%o)"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\nmod = 998244353\n\nfor i in range(n):\n    for j in range(m):\n        a[i][j] = a[i][j] % 2\n\n# 掃き出し法\nrank = 0\nfor i in range(n):\n    target = -1\n    for j in range(rank, m):\n        if a[i][j]:\n            target = j\n            break\n\n    if target == -1:\n        continue\n\n    if target != rank:\n        for k in range(rank, n):\n            a[k][rank], a[k][target] = a[k][target], a[k][rank]\n\n    for k in range(i+1, n):\n        if a[k][rank]:\n            for j in range(m):\n                a[k][j] ^= a[i][j]\n\n    rank += 1\n\n\ndef modpow(a, n, mod=mod):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * a % mod\n        a = a * a % mod\n        n >>= 1\n    return res\n\nprint(modpow(2, m-1) * (modpow(2, n) - modpow(2, n-rank)) % mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn,m=map(int,input().split())\nmod=998244353\nA=[]\nfor _ in range(n):\n    A.append(list(map(int,input().split())))\nrank=np.linalg.matrix_rank(A)\na=1\nb=1\nfor _ in range(n+m-1):\n    a*=2\n    a%=mod\nfor _ in range(n+m-rank-1):\n    b*=2\n    b%=mod\nans=(a-b)%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "class GE():\n    def __init__(self, A, mod):\n        self.N = len(A)\n        self.M = len(A[0])\n        self.A = A[:]\n        self.mod = mod\n        self.uptri = None\n        self.pivot = []\n        self.R = None\n        \n    def ut(self):\n        if self.uptri is not None:\n            return self.uptri\n        self.uptri = self.A[:]\n        \n        c = 0\n        for i in range(self.N):\n            if i + c >= self.M:\n                break\n            while self.uptri[i][i+c] == 0:\n                for j in range(i+1, self.N):\n                    if self.uptri[j][i+c]:\n                        self.uptri[i], self.uptri[j] = self.uptri[j], self.uptri[i]\n                        break\n                else:\n                    c += 1\n                    if i + c == self.M:\n                        return self.uptri\n            self.pivot.append((i, i+c))\n            t = pow(self.uptri[i][i+c], self.mod - 2, self.mod)\n            for j in range(i+1, self.N):\n                tj = t * self.uptri[j][i+c]\n                self.uptri[j][i+c:] = [(aj - tj*ai) % self.mod for ai, aj in zip(self.uptri[i][i+c:], self.uptri[j][i+c:])]\n            for pi, pj in self.pivot[::-1]:\n                t = pow(self.uptri[pi][pj], self.mod-2, self.mod)\n                self.uptri[pi][pj:] = [(ai * t) % self.mod for ai in self.uptri[pi][pj:]]\n                for i in range(pi-1, -1, -1):\n                    ti = self.uptri[i][pj]\n                    self.uptri[i][pj:] = [(ai - api*ti) % self.mod for ai, api in zip(self.uptri[i][pj:], self.uptri[pi][pj:])]\n        \n        return self.uptri\n    def rank(self):\n        if self.R is not None:\n            return self.R\n        self.ut()\n        self.R = len(self.pivot)\n        return self.R\n\nN, M = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nmod = 998244353\nT = GE(A, 2)\nprint((pow(2, N+M-1, mod) - pow(2, N+M-T.rank()-1, mod)) % mod)\n"
  },
  {
    "language": "Python",
    "code": "n,m=map(int,input().split())\nmatrix=[list(map(int,input().split())) for i in range(n)]\ndef change(i,j,matrix):\n    line=(matrix[i],matrix[j])\n    matrix[i]=line[1]\n    matrix[j]=line[0]\n    return matrix\n\ndef kbai(i,k,matrix):\n    for j in range(len(matrix[0])):\n        matrix[i][j]*=k\n    return matrix\n\ndef plus(i,j,k,matrix):\n    for _  in range(len(matrix[0])):\n        matrix[i][_]+=matrix[j][_]*k\n    return matrix\n\n\ndef rank(n,m,matrix):\n    now=0\n    for j in range(m):\n        exist=set()\n        jiku=-1\n        for i in range(n):\n            if matrix[i][j]!=0:\n                if jiku==-1 and i>=now:jiku=i\n                else:exist|={i,}\n        if jiku==-1:continue\n        for x in range(len(exist)):\n            y=exist.pop()\n            matrix=plus(y,jiku,-1,matrix)\n        matrix=change(jiku,now,matrix)\n        now+=1\n    return now\n\n\nr=rank(n,m,matrix)\nx,y=0,0\nnum=1\nfor i in range(1,n+m):\n    num=num*2%998244353\n    if i==n+m-r-1:y=num\n    if i==n+m-1:x=num\nprint((x-y)%998244353)\n#https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf"
  },
  {
    "language": "Python",
    "code": "N,M=map(int,input().split())\na=[]\nfor i in range(N):\n    a.append(list(map(int,input().split())))\nmod=998244353\n\nB=[]\nfor i in range(M):\n    b=0\n    for j in range(N):\n        b+=a[j][i]*2**j\n    B.append(b)\n\nbase=[]\nfor i in range(M):\n    t=B[i]\n    for b in base:\n        t=min(t,t^b)\n    if t!=0:\n        base.append(t)\n\nres=M-len(base)\nans=pow(2,N-1,mod)*(pow(2,M,mod)-pow(2,res,mod))\nprint(ans%mod)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn,m=map(int,input().split())\nA=[]\nfor _ in range(n):\n    A.append(list(map(int,input().split())))\nrank=np.linalg.matrix_rank(A)\nans=(2**(n+m)-2**(n+m-rank))//2\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN, M = map(int, input().split())\naij = np.zeros((N,M),dtype=int)\nfor i in range(M):\n  lst = list(map(int, input().split()))\n  for j, aj in enumerate(lst):\n    aij[i,j] = aj\n\ntotal = 0\nfor i in range(N):\n  for j in range(N+1):\n    for k in range(M):\n      for l in range(M+1):\n        part = aij[i:j, k:l]\n        if np.sum(part) % 2 != 0:\n          total += np.sum(part)\nprint(total)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nMOD = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in [0]*n])\nif n > m:\n\ta = a.T\n\tn, m = m, n\n#a[:, [0, 1]] = a[:, [1, 0]]\n#print(a)\nr = 0\nfor i in range(n):\n\tif a[i][i] != 1:\n\t\tfor j in range(i+1, m):\n\t\t\tif a[i][j] == 1:\n\t\t\t\ta[:, [i, j]] = a[:, [j, i]]\n\t\t\t\tbreak\n\t\telse:\n\t\t\tfor j in range(i+1, n):\n\t\t\t\tif a[j][i] == 1:\n\t\t\t\t\ta[[i, j]] = a[[j, i]]\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tbreak\n\tif a[i][i] == 0:\n\t\tcontinue\n\n\tr += 1\n\tfor j in range(i+1, m):\n\t\ta[:, j] += a[i][j] * a[:, i]\n\t\ta[:, j] %= 2\n\tfor j in range(i+1, n):\n\t\ta[j] += a[j][i] * a[i]\n\t\ta[j] %= 2\n#print(r)\nprint((pow(2, n+m-1, MOD) - pow(2, n+m-r-1, MOD)) % MOD)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\nimport numpy as np\nn,m = LI()\na = LIR(n)\na = np.array(a)\n\"\"\"\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] == 0:\n            if a[j][s] > 0:\n                d = a[j][s]/a[i][s]\n                for k in range(s,m):\n                    a[j][k] -= d*a[i][k]\nr = 0\nfor i in range(n):\n    if sum(a[i]) != 0:\n        r += 1\n\"\"\"\nr = np.linalg.matrix_rank(a)\nprint((((pow(2,n)-pow(2,n-r))%998244353)*pow(2,m-1))%998244353)\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport random\n\nmod=998244353\n\n\nn,m=map(int,input().split())\nA=[list(map(int,input().split())) for i in range(n)]\n\n#n,m=300,300\n#A=[[int(random.randint(0,1)) for j in range(m)] for i in range(n)]\n\n\n#A=np.array(A)\n\n#print(\"A\")\ni=0\nj=0\nr=0 #rank\nwhile i<n and j<m :\n    #print(i)\n    t=0\n    if A[i][j]==0 :\n        k=i\n        while k<n and A[k][j]==0 :\n            k+=1\n        if k<n :\n            A[i],A[k]=A[k],A[i]\n\n            #print(A)\n        else :\n            t=1\n            j+=1\n    if t==0 :\n        r+=1\n        for p in range(i+1,n):\n            if A[p][j]>0 :\n                for kk in range(j,m):\n                    A[p][kk]=(A[p][kk]-A[i][kk])%2\n        i+=1\n        j+=1\n\n\n\n#r=0\n#j=0\n#for i in range(m):\n#    if j<n :\n#        if A[j][i]!=0 :\n#            r+=1\n#            j+=1\n\nfor i in range(n):\n    for j in range(m):\n        A[i][j]=int(A[i][j])\n#print(A)\n#print(r) #rank\n\na=1\nb=1\n\nfor i in range(n+m-1):\n    a=(a*2)%mod\nfor i in range(n+m-1-r):\n    b=(b*2)%mod\n\nprint((a-b)%mod)\n"
  },
  {
    "language": "Python",
    "code": "# from : https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4212377\nH,W = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(H)]\nMOD = 998244353\n\npiv = 0\nfor w in range(W): # fix column, \n    r = -1\n    for h in range(piv, H):\n        if A[h][w] == 1:\n            r = h\n            break\n    if r == -1: # there is no odd cell for all the rows inside intersections.\n        continue \n\n    # You want to set ODD ROW ( A[h][w] == 1 ) into pivot row.\n    if r != piv: # already, skip.\n        for w in range(W): # swap rows\n            A[r][w], A[piv][w] = A[piv][w], A[r][w]\n\n    for h in range(H):\n        if h != piv and A[h][w] == 1: # really needed?\n            for k in range(h, W):\n                A[h][k] ^= A[piv][k] # for other rows, erase ...\n                # Hakidashi method: http://senkei.nomaki.jp/gaussian_elimination.html\n                # https://ja.wikipedia.org/wiki/%E3%82%AC%E3%82%A6%E3%82%B9%E3%81%AE%E6%B6%88%E5%8E%BB%E6%B3%95 : Gaussian Elimination\n    piv += 1\n\n\n# from pprint import pprint; pprint(A)\n\nret = 1\nfor h in range(H):\n    ret = ret * 2 % MOD\n\nsub = 1\nfor i in range(H-piv):\n    sub = sub * 2 % MOD\n\nret += MOD - sub          # ret = 2^N - 2^(N-r)\n\nret %= MOD\nfor i in range(W-1):      # ret *= 2^(M-1)\n    ret = ret * 2 % MOD\n\n# from editorial  : https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n# rank : r \n# 2^(N+M-1) - 2^(N+M-r-1)\n\nprint(ret % MOD) "
  },
  {
    "language": "Python",
    "code": "# from : https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4212377\nN,M = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(N)]\nMOD = 998244353\n\n\nimport numpy as np\nnpA = np.array(A)\nrank = np.linalg.matrix_rank(npA)\nrank = rank.item()\n\n# ret = 1\n# for h in range(H):\n#     ret = ret * 2 % MOD\n# sub = 1\n# for i in range(H-rank):\n#     sub = sub * 2 % MOD\n# ret = (ret+ MOD  - sub) % MOD\n# \n# for w in range(W-1):\n#     ret = ret * 2 % MOD\n\n# from editorial  : https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n# rank : r \n# 2^(N+M-1) - 2^(N+M-r-1)\n\nprint ( (pow(2,(N+M-1),MOD) - pow(2,(N+M-rank-1),  MOD))%MOD ) \n# print(ret % MOD) "
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nmod=998244353\n\n\nn,m=map(int,input().split())\nA=[list(map(float,input().split())) for i in range(n)]\n\nA.sort(reverse=1)\nA=np.array(A)\n\n# if A[0][0]!=0\n\n#print(A)\nfor i in range(min(n,m)):\n    #print(A)\n    A=list(A)\n    A[i:].sort(reverse=1,key=lambda x:x[i])\n    if A[i][i]==0 :\n        A[i:].sort(key=lambda x:x[i])\n    A=np.array(A)\n    if A[i][i]!=0 :\n        w=A[i][i]\n        for k in range(m):\n            \n            A[i][k]/=w\n        for j in range(i+1,n):\n            A[j]-=A[i]*A[j][i]\n\n#print(A)\n\nr=0\nj=0\nfor i in range(m):\n    if A[j][i]!=0 :\n        r+=1\n        j+=1\n\nfor i in range(n):\n    for i in range(m):\n        A[i][j]=int(A[i][j])\n#print(A)\n#print(r) #rank\n\na=1\nb=1\n\nfor i in range(n+m-1):\n    a=(a*2)%mod\nfor i in range(n+m-1-r):\n    b=(b*2)%mod\nprint((a-b)%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n \nN,M=map(int, raw_input().split())\nA=np.array( [ map(int, raw_input().split()) for i in range(N) ] )\n \nR=np.linalg.matrix_rank(A)\np=998244353\n\nprint ( pow(2,N+M-1,p)-pow(2,N+M-R-1,p) )%p"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN=lambda:list(map(int,input().split()))\np=998244353\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=int(np.linalg.matrix_rank(a))\nprint((pow(2,n+m-1,p)-pow(2,n+m-1-r,p))%p)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\nimport numpy as np\nn,m = LI()\na = LIR(n)\na = np.array(a)\n\"\"\"\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] == 0:\n            if a[j][s] > 0:\n                d = a[j][s]/a[i][s]\n                for k in range(s,m):\n                    a[j][k] -= d*a[i][k]\nr = 0\nfor i in range(n):\n    if sum(a[i]) != 0:\n        r += 1\n\"\"\"\nr = np.linalg.matrix_rank(a)\nprint(pow(2,n+m-1)-pow(2,n-r+m-1))\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "import numpy as b,sys;(n,m),*a=[list(map(int,s.split()))for s in sys.stdin];n+=m-1;print((2**n-2**int(n-b.linalg.matrix_rank(a)))%998244353)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] != 0:\n            if a[j][s] > 0:\n                for k in range(s,m):\n                    a[j][k] -= 1\n                    a[j][k] = abs(a[j][k])\nr = 0\nfor i in range(n):\n    if sum(a[i]) > 0:r += 1\nprint((pow(2,n+m-1)-pow(2,n-r+m-1))%998244353)\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "import numpy as b,sys;(n,m),*a=[list(map(int,s.split()))for s in sys.stdin];n+=m-1;print((2**n-pow(2,int(n-b.linalg.matrix_rank(a))))%998244353)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nNM = [int(x) for x in input().split()]\nN = NM[0]\nM = NM[1]\na = [[int(x) for x in input().split()] for l in range(N)]\n#print(a)\nA =np.array(a)\ncount = 0\n\nfor i in range (0, M):\n    for j in range(i, M):\n        for k in range (0, N):\n            for l in range(k, N):\n                if A[i:j+1,k:l+1].sum() % 2 == 1:\n                    #print(a)\n                    #print(i,j,k,l,A[i:j+1,k:l+1])\n                    count += 1\nprint(count % 998244353)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n \nN,M=map(int, input().split())\nA=[ list( map(int, input().split()) ) for i in range(N) ] \n \nR=np.linalg.matrix_rank(A)\n \nprint ( (2**N - 2**(N-R) )*2**(M-1) )"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\n\"\"\"\n列ベクトルが M 個ある\nいくつかを選ぶ（和をとる）→すべての行が0となる選び方：0、その他：2^{N-1}通り\n列ベクトル空間の生成する次元：d次元\nans = 2^{N-1} * (2^M - 2^[M-d})\n= 2^{N+M-1} * (1-2^{-rank})\n\"\"\"\n\nimport numpy as np\nMOD = 998244353\nN,M = map(int,input().split())\nA = np.array([[int(x) for x in input().split()] for _ in range(N)])\n\ndef rank(A):\n    # F_2 上の行列のrank\n    N,M = A.shape\n    if N == 0 or M == 0:\n        return 0\n    nz = np.nonzero(A[0])[0]\n    if len(nz) == 0:\n        # first col = zero\n        return rank(A[1:])\n    i = nz[0]\n    # swap\n    temp = A[:,i].copy()\n    A[:,i] = A[:,0]\n    A[:,0] = temp\n    # (0,0) 成分が 1 になった。行基本変形。\n    A ^= A[0] * A[:,0]\n    return 1 + rank(A[1:,1:])\n\nd = rank(A)\nanswer = pow(2,N+M-1,MOD) * (1 - pow(2,(-d)%(MOD-1), MOD)) % MOD\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN=lambda:list(map(int,input().split()))\np=998244353\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=np.linalg.matrix_rank(a)\nf=n+m-1\nd=f-r\nprint((p+pow(2,f,p)-pow(2,d,p))%p)"
  },
  {
    "language": "Python",
    "code": "class GE():\n    #mod2　なら　Aは1重リストで渡して, max(bit_length) をMに渡してあげた方が速い\n    def __init__(self, A, mod, M = 0):\n        self.N = len(A)\n        if M:\n            self.M = M\n        else:\n            self.M = len(A[0])\n        self.mod = mod\n        self.A = A[:]\n        self.uptri = None\n        self.A2 = None\n        self.pivot = []\n        self.R = None\n    def ut(self):\n        if self.mod != 2:\n            if self.uptri is not None:\n                return self.uptri\n            self.uptri = self.A[:]\n            c = 0\n            for i in range(self.N):\n                if i + c >= self.M:\n                    break\n                while self.uptri[i][i+c] == 0:\n                    for j in range(i+1, self.N):\n                        if self.uptri[j][i+c]:\n                            self.uptri[i], self.uptri[j] = self.uptri[j], self.uptri[i]\n                            break\n                    else:\n                        c += 1\n                        if i + c == self.M:\n                            break\n                else:\n                    self.pivot.append((i, i+c))\n                    t = pow(self.uptri[i][i+c], self.mod - 2, self.mod)\n                    for j in range(i+1, self.N):\n                        tj = t * self.uptri[j][i+c]\n                        self.uptri[j][i+c:] = [(aj - tj*ai) % self.mod for ai, aj in zip(self.uptri[i][i+c:], self.uptri[j][i+c:])]\n                    continue\n                break\n            for pi, pj in self.pivot[::-1]:\n                t = pow(self.uptri[pi][pj], self.mod-2, self.mod)\n                self.uptri[pi][pj:] = [(ai * t) % self.mod for ai in self.uptri[pi][pj:]]\n                for i in range(pi-1, -1, -1):\n                    ti = self.uptri[i][pj]\n                    self.uptri[i][pj:] = [(ai - api*ti) % self.mod for ai, api in zip(self.uptri[i][pj:], self.uptri[pi][pj:])]\n            \n            return self.uptri\n        else:\n            if self.A2 is not None:\n                return self.A2\n            self.A2 = self.A[:]\n            c = 0\n            for i in range(self.N):\n                if i + c >= self.M:\n                    break\n                while not self.A2[i] & 2**(i+c):\n                    for j in range(i+1, self.N):\n                        if self.A2[j] & 2**(i+c):\n                            self.A2[i], self.A2[j] = self.A2[j], self.A2[i]\n                            break\n                    else:\n                        c += 1\n                        if i + c == self.M:\n                            break\n                else:\n                    self.pivot.append((i, i+c))\n                    for j in range(i+1, self.N):\n                        if self.A2[j] & 2**(i+c):\n                            self.A2[j] ^= self.A2[i]\n                    continue\n                break\n            for pi, pj in self.pivot[::-1]:\n                for i in range(pi-1, -1, -1):\n                    if 2**pj & self.A2[i]:\n                        self.A2[i] ^= self.A2[pi]\n            \n            return self.A2\n            \n                \n    def rank(self):\n        if self.R is not None:\n            return self.R\n        self.ut()\n        self.R = len(self.pivot)\n        return self.R\n\nN, M = map(int, input().split())\nA = [sum(2**i for i, v in enumerate(map(int, input().split())) if v == 1)  for _ in range(N)]\nmod = 998244353\nT = GE(A, 2, M)\nprint((pow(2, N+M-1, mod) - pow(2, N+M-T.rank()-1, mod)) % mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nMOD = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in [0]*n])\n#a[:, [0, 1]] = a[:, [1, 0]]\n#print(a)\nr = 0\nfor i in range(min(m, n)):\n\tif a[i][i] != 1:\n\t\tfor j in range(i+1, m):\n\t\t\tif a[i][j] == 1:\n\t\t\t\ta[:, [i, j]] = a[:, [j, i]]\n\t\t\t\tbreak\n#\t\telse:\n#\t\t\tfor j in range(i+1, n):\n#\t\t\t\tif a[j][i] == 1:\n#\t\t\t\t\ta[[i, j]] = a[[j, i]]\n#\t\t\t\tbreak\n#\t\t\telse:\n#\t\t\t\tbreak\n\tif a[i][i] == 0:\n\t\tcontinue\n\n\tr += 1\n\tfor j in range(i+1, m):\n\t\ta[:, j] += a[i][j] * a[:, i]\n\t\ta[:, j] %= 2\n\tfor j in range(i+1, n):\n\t\ta[j] += a[j][i] * a[i]\n\t\ta[j] %= 2\n#print(r)\nprint((pow(2, n+m-1, MOD) - pow(2, n+m-r-1, MOD)) % MOD)"
  },
  {
    "language": "Python",
    "code": "# from : https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4212377\nH,W = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(H)]\nMOD = 998244353\n\npiv = 0\n\n# Gaussian Elimination to calculate rank of the matrix A\nfor w in range(W): # fix column, \n    r = -1\n    for h in range(piv, H):\n        if A[h][w] == 1:\n            r = h\n            break\n    if r == -1: # there is no odd cell for all the rows inside intersections.\n        continue \n\n    # You want to set ODD ROW ( A[h][w] == 1 ) into pivot row.\n    if r != piv: # already, skip.\n        for j in range(W): # swap rows\n            A[r][j], A[piv][j] = A[piv][j], A[r][j]\n\n    # for h in \n    for h in range(H):\n        if h != piv and A[h][w] == 1: # really needed?\n            # for j in range(W):\n            for k in range(piv, W):\n                A[h][k] ^= A[piv][k]\n                # A[h][j] ^= A[piv][j] # for other rows, erase ...\n                # Hakidashi method: http://senkei.nomaki.jp/gaussian_elimination.html\n                # https://ja.wikipedia.org/wiki/%E3%82%AC%E3%82%A6%E3%82%B9%E3%81%AE%E6%B6%88%E5%8E%BB%E6%B3%95 : Gaussian Elimination\n    piv += 1\n\n\n# print(\"----output matrix ----\")\n# for h in range(H):\n#     print(A[h])\n# exit(0)\n\n\n# from pprint import pprint; pprint(A)\n\nret = 1\nret = pow(2, H, MOD)\n# for h in range(H):\n#     ret = ret * 2 % MOD\n\nsub = 1\n# for i in range(H-piv):\n#     sub = sub * 2 % MOD\nsub = pow(2, H-piv, MOD)\n\n\nret += MOD - sub          # ret = 2^N - 2^(N-r)\nret %= MOD\n\nfor i in range(W-1):      # ret *= 2^(M-1)\n    ret = ret * 2 % MOD\n\n# from editorial  : https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n# rank : r \n# 2^(N+M-1) - 2^(N+M-r-1)\n\nprint(ret % MOD) "
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\nmod = 998244353\n\nfor i in range(n):\n    for j in range(m):\n        a[i][j] = a[i][j] % 2\n\n# 掃き出し法\nrank = 0\nfor i in range(n):\n    target = -1\n    for j in range(rank, m):\n        if a[i][j]:\n            target = j\n            break\n\n    if target == -1:\n        continue\n\n    if target != rank:\n        for k in range(rank, n):\n            a[k][rank], a[k][target] = a[k][target], a[k][rank]\n\n    for k in range(rank+1, n):\n        if a[k][rank]:\n            for j in range(rank, m):\n                a[k][j] -= a[rank][j]\n\n    rank += 1\n\n\ndef modpow(a, n, mod=mod):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * a % mod\n        a = a * a % mod\n        n >>= 1\n    return res\n\nprint(modpow(2, m-1) * (modpow(2, n) - modpow(2, n-rank) % mod))\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN=lambda:list(map(int,input().split()))\np=998244353\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=np.linalg.matrix_rank(a)\nprint((pow(2,n*m-1,p)-pow(2,n*m-1-r,p))%p)"
  },
  {
    "language": "Python",
    "code": "N,M=map(int, raw_input().split())\nA=[ map(int, raw_input().split()) for i in range(N) ]\n\nif N>M: N,M=M,N\n\nfor k in range(N):\t#k: pivot\n\tif A[k][k]==0:\n\t\tfor i in range(N):\n\t\t\tif A[i][k]==1:\n\t\t\t\t#Gyou koukan\n\t\t\t\tfor j in range(M):\n\t\t\t\t\tA[k][j],A[i][j] = A[i][j],A[k][j]\n\t\t\t\tbreak\n\n\tfor i in range(N):\n\t\tif i!=k and A[i][k]==1:\n\t\t\tfor j in range(M):\n\t\t\t\tA[i][j]+=A[i-1][j]\n\t\t\t\tA[i][j]%=2\n\n\nr=0 #Rank\n\nfor x in A:\n\tif max(x)!=0: r+=1\n\n\np=998244353\n\nprint ( pow(2,N+M-1,p)-pow(2,N+M-r-1,p) )%p"
  },
  {
    "language": "Python",
    "code": "def rankmod2(A):\n    n,m=len(A),len(A[0])\n    rank=0\n    i,j=0,0\n    while i<n and j<m:\n        if A[i][j]:\n            rank+=1\n        else:\n            for ii in range(i+1,n):\n                if A[ii][j]:\n                    A[i],A[ii]=A[ii],A[i]\n                    rank+=1\n                    break\n            else:\n                j+=1\n                continue\n        for ii in range(i+1,n):\n            if A[ii][j]:\n                for jj in range(j,m):\n                    A[ii][jj]=(A[ii][jj]+A[i][jj])% 2\n        i+=1\n        j+=1\n    return rank\n\nn,m=map(int,input().split())\nmod=998244353\nA=[list(map(int,input().split())) for _ in range(n)]\nr=rankmod2(A)\nans=(pow(2,n+m-1,mod)-pow(2,n+m-r-1,mod))%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nmod = 998244353\nn,m = list(map(int, input().split()))\nmat = np.zeros((n,m))\n\nfor i in range(n):\n    l = list(map(int, input().split()))\n    for j in range(m):\n      mat[i,j] = l[j]\n    \nr = np.linalg.matrix_rank(mat)\n\nans = (pow(2,n+m-1) - pow(2,n+m-r-1)) % mod\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nMOD = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in [0]*n])\n#a[:, [0, 1]] = a[:, [1, 0]]\n#print(a)\nr = 0\nfor i in range(n):\n\tif a[i][i] != 1:\n\t\tfor j in range(i+1, m):\n\t\t\tif a[i][j] == 1:\n\t\t\t\ta[:, [i, j]] = a[:, [j, i]]\n\t\t\t\tbreak\n\t\telse:\n\t\t\tfor j in range(i+1, n):\n\t\t\t\tif a[j][i] == 1:\n\t\t\t\t\ta[[i, j]] = a[[j, i]]\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tbreak\n\tif a[i][i] == 0:\n\t\tcontinue\n\n\tr += 1\n\tfor j in range(i+1, m):\n\t\ta[:, j] += a[i][j] * a[:, i]\n\t\ta[:, j] %= 2\n\tfor j in range(i+1, n):\n\t\ta[j] += a[j][i] * a[i]\n\t\ta[j] %= 2\n#print(r)\nprint((pow(2, n+m-1, MOD) - pow(2, n+m-r-1, MOD)) % MOD)"
  },
  {
    "language": "Python",
    "code": "import numpy as b,sys;(n,m),*a=[map(int,s.split())for s in sys.stdin];o=998244353;n+=m-1;print((pow(2,n,o)-pow(2,n-b.linalg.matrix_rank(a),o))%o)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport itertools\nfrom scipy import signal\n \nN, M = [int(s) for s in input().split()]\nA = np.zeros([N, M])\nfor n in range(N):\n\tA[n] = [int(m) for m in input().split()]\n\nN_fft, M_fft = 2*N, 2*M\nFa = np.fft.rfft2(A, [N_fft,M_fft])\n\noddnum = 0\nfor n, m in itertools.product(range(N), range(M)):\n\tW = np.fft.rfft2(np.ones([n+1,m+1]), [N_fft,M_fft]);\n\tAw = np.fft.irfft2(Fa*W).astype(int)\n\tprint(Aw[n:N, m:M])\n\toddnum += np.sum(Aw[n:N, m:M] % 2 == 1)\n \nprint(oddnum % 998244353)"
  },
  {
    "language": "Python",
    "code": "#!venv/bin/python\n\nimport math\n\nN,M = [int(x) for x in input().split()]\nA = []\nfor i in range(N):\n    A.append([int(x) for x in input().split()])\n\nMOD = 998244353\n\nA0 = []\nA0_num = 0\nfor i in range(N):\n    a = A[i]\n    for n in a:\n        if n == 1:\n            A0.append(False)\n            break\n    else:\n        A0.append(True)\n        A0_num += 1\n\ncol_sum = [0 for i in range(M)]\n# print(A)\nfor col in range(M):\n    col_sum[col] += sum([x[col] for x in A])\n\n# print(col_sum)\n\nsmallest_col_sum = sorted(col_sum)[0]\n# print(smallest_col_sum)\n\ndef cmb_mod(n, k, mod=998244353):\n    # nCk (mod m)\n    def mod_permutation(n, k, mod):\n        if n<=k:\n            return 1\n        else:\n            return (n * mod_permutation(n-1,k,mod))%mod\n\n    def mod_inv_permutation(k, mod):\n        k, mod = int(k), int(mod)\n        if k<=1:\n            return 1\n        else:\n            return (pow(k,mod-2,mod) * mod_inv_permutation(k-1, mod))%mod\n\n    return (mod_permutation(n,n-k,mod) * mod_inv_permutation(k, mod))%mod\n\ndame_pair = 0\nfor evenval in range(2,smallest_col_sum + 1,2):\n    dame_pair += cmb_mod(smallest_col_sum,evenval)\n\nans = 1\nfor i in range(N):\n    ans = ans * 2\n    ans = ans % MOD\n# print(\"ans\")\n# print(ans)\n\n# print(\"a0 num\")\n# print(A0_num)\ndame = dame_pair + 1\nfor i in range(A0_num):\n    dame = dame * 2\n    dame = dame % MOD\n#dame += 1   # 0\n# print(\"dame\")\n# print(dame)\n\nans = (ans - dame) % MOD\nfor i in range(M-1):\n    ans = ans * 2\n    ans = ans % MOD\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nmod=998244353\nn,m=map(int,input().split())\na=[0]*n\nfor i in range(n):\n    a[i] = list(map(int,input().split()))\nrnk = np.linalg.matrix_rank(np.array(a))\nx=n-rnk\ny=m-rnk\n\ndef powe(n,e):\n    ret=1\n    b=n\n    while e>0:\n        if e%2==1:\n            ret*=b\n        b=b*b\n        ret%=mod\n        b%=mod\n        e//=2\n    return ret\n\ntable = [[0]*301 for x in range(301)]\n\ndef inv(q):\n    return powe(q,mod-2)\n\nfor i in range(301):\n    table[i][0]=1\nfor p in range(301):\n    for q in range(1,p+1):\n        table[p][q] = (table[p][q-1]*(p-q+1)*inv(q))%mod\ndef nck(p,q):\n    return table[p][q]\nret=0\nfor s in range(1,rnk+1):\n    odds=0\n    for t in range(1,s+1):\n        if t%2==1:\n            odds+=nck(s,t)\n            odds%=mod\n    ret+=nck(rnk,s)*odds*powe(2,rnk-s)\n    ret%=mod\nprint(ret)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport random\n\nmod=998244353\n\n\nn,m=map(int,input().split())\nA=[list(map(float,input().split())) for i in range(n)]\n\n#n,m=300,250\n\n#A=[[float(random.randint(0,1)) for j in range(m)] for i in range(n)]\n\nif n<m :\n    n,m=m,n\n    A=np.array(A)\n    A=A.T\n    A=list(A)\n\n\n\n# if A[0][0]!=0\n\n#print(A)\nfor i in range(min(n,m)):\n    #print(A)\n    A=list(A)\n    A[i:].sort(reverse=1,key=lambda x:x[i])\n    if A[i][i]==0 :\n        A[i:].sort(key=lambda x:x[i])\n    A=np.array(A)\n    if A[i][i]!=0 :\n        w=A[i][i]\n        for k in range(m):\n            \n            A[i][k]/=w\n        for j in range(i+1,n):\n            A[j]-=A[i]*A[j][i]\n\n#print(A)\n\nr=0\nj=0\nfor i in range(m):\n    if j<n :\n        if A[j][i]!=0 :\n            r+=1\n            j+=1\n\nfor i in range(n):\n    for j in range(m):\n        A[i][j]=int(A[i][j])\n#print(A)\n#print(r) #rank\n\na=1\nb=1\n\nfor i in range(n+m-1):\n    a=(a*2)%mod\nfor i in range(n+m-1-r):\n    b=(b*2)%mod\n\nprint((a-b)%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nMOD = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in [0]*n])\n#a[:, [0, 1]] = a[:, [1, 0]]\n#print(a)\nr = 0\nfor i in range(n):\n\tif a[i][i] != 1:\n\t\tfor j in range(i+1, m):\n\t\t\tif a[i][j] == 1:\n\t\t\t\ta[:, [i, j]] = a[:, [j, i]]\n\t\t\t\tbreak\n\t\telse:\n\t\t\tfor j in range(i+1, n):\n\t\t\t\tif a[j][i] == 1:\n\t\t\t\t\ta[[i, j]] = a[[j, i]]\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tbreak\n\tif a[i][i] == 0:\n\t\tcontinue\n\n\tr += 1\n\tfor j in range(i+1, m):\n\t\ta[:, [j]] += a[i][j] * a[:, [i]]\n\t\ta[:, [j]] %= 2\n\tfor j in range(i+1, n):\n\t\ta[[j]] += a[j][i] * a[[i]]\n\t\ta[[j]] %= 2\n#print(r)\nprint((pow(2, n+m-1, MOD) - pow(2, n+m-r-1, MOD)) % MOD)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nM=998244353\nn,m=map(int, input().split())\na=np.array([list(map(int, input().split())) for _ in [0]*n])\nr=int(np.linalg.matrix_rank(a))\nprint((pow(2,n+m-1,M)-pow(2,n+m-r-1,M))%M)"
  },
  {
    "language": "Python",
    "code": "def intmod2(n):\n    return int(n) % 2\n\ndef rankmod2(A):\n    global N, M\n    ret = 0\n    i = 0\n    j = 0\n    while i < N and j < M:\n        ii = i\n        if A[i][j]:\n            ret += 1\n        else:\n            for ii in range(i+1, N):\n                if A[ii][j]:\n                    A[i], A[ii] = A[ii], A[i]\n                    ret += 1\n                    break\n            else:\n                j += 1\n                continue\n                \n        for ii in range(i+1, N):\n            if A[ii][j]:\n                for jj in range(j, M):\n                    A[ii][jj] = (A[ii][jj] + A[i][jj]) % 2\n        i += 1\n        j += 1\n        \n    return ret\n                        \nP = 998244353\nN, M = map(int, input().split())\nA = [list(map(intmod2, input().split())) for _ in range(N)]\n\nr = rankmod2(A)\nprint(pow(2, N+M-1, P)-pow(2, N+M-r-1, P))"
  },
  {
    "language": "Python",
    "code": "N,M=map(int, raw_input().split())\nA=[ map(int, raw_input().split()) for i in range(N) ]\n\nif N>M:  N,M=M,N\n\nfor k in range(N): #k: pivot\n\tif A[k][k]==0 and max(A[k])==1:\n\t\tfor i in range(N):\n\t\t\tif A[i][k]==1:\n\t\t\t\t#Gyou koukan\n\t\t\t\tA[k],A[i] = A[i],A[k]\n\t\t\t\tbreak\n\n\tfor i in range(N):\n\t\tif i!=k and A[i][k]==1:\n\t\t\tfor j in range(M):\n\t\t\t\tA[i][j]+=A[k][j]\n\t\t\t\tA[i][j]%=2\n\nr=0 #Rank\n\ns=set()\nfor x in A:\n\tt=\"\"\n\tif max(x)!=0:\n\t\tfor i in x:\n\t\t\tt+=str(i)\n\t\ts.add(t)\n\nr=len(s)\n\n\np=998244353\n\nprint ( pow(2,N+M-1,p)-pow(2,N+M-r-1,p) )%p\n"
  },
  {
    "language": "Python",
    "code": "def intmod2(n):\n    return int(n) % 2\n\ndef rankmod2(A):\n    global N, M\n    ret = 0\n    i = 0\n    j = 0\n    while i < N and j < M:\n        if A[i][j]:\n            ret += 1\n        else:\n            for ii in range(i+1, N):\n                if A[ii][j]:\n                    A[i], A[ii] = A[ii], A[i]\n                    ret += 1\n                    break\n            else:\n                j += 1\n                continue\n                \n        for ii in range(i+1, N):\n            if A[ii][j]:\n                for jj in range(j, M):\n                    A[ii][jj] = (A[ii][jj] + A[i][jj]) % 2\n        i += 1\n        j += 1\n        \n    return ret\n                        \nP = 998244353\nN, M = map(int, input().split())\nA = [list(map(intmod2, input().split())) for _ in range(N)]\nr = rankmod2(A)\nprint((pow(2, N+M-1, P)-pow(2, N+M-r-1, P)) % P)"
  },
  {
    "language": "Python",
    "code": "N,M=map(int,input().split())\na=[]\nfor i in range(N):\n    a.append(list(map(int,input().split())))\nmod=998244353\n\nB=[]\nfor i in range(M):\n    b=0\n    for j in range(N):\n        b+=a[j][i]*2**j\n    B.append(b)\n\nbase=[]\nfor i in range(M):\n    t=B[i]\n    for b in base:\n        t=min(t,t^b)\n    if t!=0:\n        base.append(t)\n\nres=M-len(base)\nans=pow(2,N-1,mod)*(pow(2,M,mod)-pow(2,res,mod))\nprint(ans%mod)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn,m = map(int, input().split())\nA = np.array([ list(map(int, input().split())) for _ in range(n) ])\nr = np.linalg.matrix_rank(A)\nprint((2**(n+m-1) - 2**(n+m-r-1)) % 998244353)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport itertools\nfrom scipy import signal\n\nN, M = [int(s) for s in input().split()]\nA = np.zeros([N, M])\nfor n in range(N):\n\tA[n] = [int(m) for m in input().split()]\n\noddnum = 0\nfor n, m in itertools.product(range(N), range(M)):\n\tw = np.ones([n+1,m+1]);\n\tAw = signal.convolve2d(A, w, 'valid').astype(int)\n\toddnum += np.sum(Aw % 2 == 1)\n\nprint(oddnum % 998244353)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return list(sys.stdin.readline())\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nn,k = LI()\nif 2*(k-1) < n:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\"\"\"\n\n#B\n\"\"\"\nc = LIR(3)\nv = [[] for i in range(4)]\nfor i in range(3):\n    c[i][0] -= 1\n    c[i][1] -= 1\n    v[c[i][0]].append(c[i][1])\n    v[c[i][1]].append(c[i][0])\n\nfor i in range(4):\n    li = [True for i in range(4)]\n    li[i] = False\n    q = [i]\n    c = 0\n    while q:\n        x = q.pop(-1)\n        k = 0\n        for j in v[x]:\n            if li[j]:\n                li[j] = False\n                q.append(j)\n                if k == 0:\n                    c += 1\n                    k += 1\n    if c == 3:\n        print(\"YES\")\n        quit()\nprint(\"NO\")\n\"\"\"\n\n#C\n\"\"\"\nk,a,b = LI()\nif k <= a:\n    print(k+1)\nelse:\n    if b-a < 3:\n        print(k+1)\n    else:\n        ans = a+((k-a+1)//2)*(b-a)+(k-a+1)%2\n        print(ans)\n\"\"\"\n\n#D\n\n#E\nn,m = LI()\na = LIR(n)\na.sort()\na = a[::-1]\nfor i in range(n):\n    for j in range(i+1,n):\n        s = 0\n        while a[i][s] == 0 and s < m-1:s+=1\n        if s < m and a[i][s] == 0:\n            if a[j][s] > 0:\n                d = a[j][s]/a[i][s]\n                for k in range(s,m):\n                    a[j][k] -= d*a[i][k]\nr = 0\nfor i in range(n):\n    if sum(a[i]) != 0:\n        r += 1\nprint(pow(2,n+m-1)-pow(2,n-r+m-1))\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\na = [int(input().replace(\" \",\"\"),2) for i in range(n)]\nmod = 998244353\ncnt = 0\nfor j in range(m)[::-1]:\n  for i in range(cnt,n):\n    if a[i] & 1<<j:\n      for k in range(n):\n        if (i != k) and (a[k] & 1<<j):\n          a[k] ^= a[i]\n      a[i],a[cnt] = a[cnt],a[i]\n      cnt += 1\n\"\"\"\nans = pow(2,n+m-2*cnt,mod)*pow(2,cnt-1,mod)*(pow(2,cnt,mod)-1)%mod\nprint(ans)\n\"\"\""
  },
  {
    "language": "Python",
    "code": "import numpy as np\nMOD = 998244353\nn, m = map(int, input().split())\na = np.array([list(map(int, input().split())) for _ in [0]*n])\n#a[:, [0, 1]] = a[:, [1, 0]]\n#print(a)\nr = 0\nfor i in range(n):\n\tif a[i][i] != 1:\n\t\tfor j in range(i+1, m):\n\t\t\tif a[i][j] == 1:\n\t\t\t\ta[:, [i, j]] = a[:, [j, i]]\n\t\t\t\tbreak\n\t\telse:\n\t\t\tfor j in range(i+1, n):\n\t\t\t\tif a[j][i] == 1:\n\t\t\t\t\ta[[i, j]] = a[[j, i]]\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tbreak\n\tif a[i][i] == 0:\n\t\tcontinue\n\n\tr += 1\n\tfor j in range(i+1, m):\n\t\ta[:, j] += a[i][j] * a[:, i]\n\t\ta[:, j] %= 2\n\tfor j in range(i+1, n):\n\t\ta[j] += a[j][i] * a[i]\n\t\ta[j] %= 2\n#print(r)\nprint((pow(2, n+m-1, MOD) - pow(2, n+m-r-1, MOD)) % MOD)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport sys\n\nmod = 998244353\nn,m = list(map(int, input().split()))\nmat = np.zeros((n,m))\n\nfor i in range(n):\n    l = list(map(int, input().split()))\n    for j in range(m):\n      mat[i,j] = l[j]\n    \nr = np.linalg.matrix_rank(mat)\n\nans = (pow(2,n+m-1,mod) - pow(2,n+m-r-1,mod) + mod) % mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nmod = 998244353\n\nwhile True:\n    try:\n        n,m = map(long, raw_input().split())\n\n        mat = np.zeros((n,m))\n\n        for i in range(n):\n            mat[i] = map(long, raw_input().split())\n        \n        r = np.linalg.matrix_rank(mat)\n\n        ans = (pow(2,m-1,mod) * ((pow(2,n,mod) - pow(2,n-r,mod)) % mod)) % mod\n        print ans\n    except:\n        break\n        \n\n    \n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn, m = map(int, input().split())\nf = n * m > 998244353\nlis = []\nfor i in range(n):\n  lis.append(list(map(int, input().split())))\narr = np.array(lis)\ncache_dict = {}\n\ndef search(base, x1, x2, y1, y2):\n  use_arr = arr[x1:x2+1, y1:y2+1]\n  return (base + use_arr.sum()) % 2\n\ndef rec_search(base, x1, x2, y1, y2):\n  cache_dict[(x1, x2, y1, y2)] = base\n  if x1-1 >= 0:\n    arg1 = (x1-1, x2, y1, y2)\n    if not arg1 in cache_dict:\n      next_base = search(base, x1-1, x1-1, y1, y2)\n      cache_dict[arg1] = next_base\n      rec_search(next_base, x1-1, x2, y1, y2)\n  if x2+1 <= m-1:\n    arg2 = (x1, x2+1, y1, y2)  \n    if not arg2 in cache_dict:\n      next_base = search(base, x2+1, x2+1, y1, y2)\n      cache_dict[arg2] = next_base\n      rec_search(next_base, x1, x2+1, y1, y2)\n  if y1 - 1 >= 0:\n    arg3 = (x1, x2, y1-1, y2)  \n    if not arg3 in cache_dict:\n      next_base = search(base, x1, x2, y1-1, y1-1)\n      cache_dict[arg3] = next_base\n      rec_search(next_base, x1, x2, y1-1, y2)\n  if y2 + 1 <= n-1:\n    arg4 = (x1, x2, y1, y2+1)  \n    if not arg4 in cache_dict:\n      next_base = search(base, x1, x2, y2+1, y2+1)\n      cache_dict[arg4] = next_base\n      rec_search(next_base, x1, x2, y1, y2+1)\n\npoint_1 = np.where(arr==1)\nfor ind in zip(point_1[0], point_1[1]):\n  cache_dict[(ind[1], ind[1], ind[0], ind[0])] = 1\n  rec_search(1, ind[1], ind[1], ind[0], ind[0])\nprint(sum(cache_dict.values()) % 998244353)"
  },
  {
    "language": "Python",
    "code": "# from : https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4212377\nH,W = map(int, input().split())\nA = [ [int(j) for j in input().split()] for _ in range(H)]\nMOD = 998244353\n\npiv = 0\nfor w in range(W): # fix column, \n    r = -1\n    for h in range(piv, H):\n        if A[h][w] == 1:\n            r = h\n            break\n    if r == -1: # there is no odd cell for all the rows inside intersections.\n        continue \n\n    # You want to set ODD ROW ( A[h][w] == 1 ) into pivot row.\n    if r != piv: # already, skip.\n        for w in range(W): # swap rows\n            A[r][w], A[piv][w] = A[piv][w], A[r][w]\n    else:\n        continue\n\n    for h in range(H):\n        if h != piv and A[h][w] == 1: # really needed?\n            for k in range(h, W):\n                A[h][k] ^= A[piv][k] # for other rows, erase ...\n                # Hakidashi method: http://senkei.nomaki.jp/gaussian_elimination.html\n                # https://ja.wikipedia.org/wiki/%E3%82%AC%E3%82%A6%E3%82%B9%E3%81%AE%E6%B6%88%E5%8E%BB%E6%B3%95 : Gaussian Elimination\n    piv += 1\n\n\n# from pprint import pprint; pprint(A)\n\nret = 1\nfor h in range(H):\n    ret = ret * 2 % MOD\n\nsub = 1\nfor i in range(H-piv):\n    sub = sub * 2 % MOD\n\nret += MOD - sub          # ret = 2^N - 2^(N-r)\n\nret %= MOD\nfor i in range(W-1):      # ret *= 2^(M-1)\n    ret = ret * 2 % MOD\n\n# from editorial  : https://img.atcoder.jp/yahoo-procon2019-qual/editorial.pdf\n# rank : r \n# 2^(N+M-1) - 2^(N+M-r-1)\n\nprint(ret % MOD) \n"
  },
  {
    "language": "Python",
    "code": "N,M=map(int,input().split());mod=998244353;B=[]\nfor i in range(N):\n    s=int(input().split().replace(\" \",\"\"),2)\n    for b in B:s=min(s,s^b)\n    if s!=0:B.append(s)\nprint((pow(2,N+M-1,mod)*(1-pow(2,mod-1-len(B),mod)))%mod)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [long(input_raw[0]), long(input_raw[1])]\n    A = []\n    for i in range(N):\n        input_raw = read_func().strip().split()\n        a = 0\n        for j in range(M):\n            a += int(input_raw[j]) << j\n        A.append(a)\n    is_set = set([])\n    A_ = [0 for i in range(N)]\n    for i in range(N):\n        is_all_zero = True\n        for j in range(N):\n            if (A[j] & 0x01 << i) > 0 and j not in is_set:\n                A_[i] = A[j]\n                is_set.add(j)\n                is_all_zero =False\n                break\n        if is_all_zero == True:\n            for j in range(N):\n                if j not in is_set:\n                    A_[i] = A[j]\n                    is_set.add(j)\n                    break\n\n    for i in range(min(N, M)):\n        for j in range(i+1, N):\n            if (A_[i] >> i & 0x01) > 0:\n                A_[j] = A_[j] ^ A_[i]\n    k = 0\n    for i in range(N):\n        if A_[i] == 0:\n            k += 1\n\n    count1 = 1\n    for i in range(M-1):\n        count1 = (count1 * 2)%998244353\n    count2 = 1\n    for i in range(N):\n        count2 = (count2 * 2)%998244353\n    count3 = 1\n    for i in range(k):\n        count3 = (count3 * 2)%998244353\n    count = (count1 * ((count2 - count3) %998244353))%998244353\n    print count\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "N,M=map(int,input().split());B=[]\nfor i in[0]*N:\n    s=int(input().replace(\" \",\"\"),2)\n    for b in B:s=min(s,s^b)\n    B+=[s]*(s!=0)\nN+=M-1;print((2**N-2**(N-len(B)))%998244353)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN=lambda:list(map(int,input().split()))\np=998244353\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=int(np.linalg.matrix_rank(a))\nprint((p+pow(2,n+m-1,p)-pow(2,n+m-1-r,p))%p)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nIN=lambda:list(map(int,input().split()))\nPJ=lambda x:pow(2,x,998244353)\nn,m=IN()\na=np.array([IN() for i in range(n)])\nr=np.linalg.matrix_rank(a)\nprint(PJ(n*m-1)-PJ(n*m-1-r))"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let a: Vec<Vec<i64>> = (0..n).map(|_| sc.vec(m)).collect();\n    let rank = f2_gauss_jordan(a);\n\n    let mut pow2 = vec![1; n + m + 1];\n    for i in 1..pow2.len() {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n\n    let ans = pow2[n + m - 1] + MOD - pow2[n + m - rank - 1];\n    println!(\"{}\", ans % MOD);\n}\n\nfn f2_gauss_jordan(mut a: Vec<Vec<i64>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    let mut row = 0;\n    for col in 0..m {\n        match (row..n).filter(|&i| a[i][col] == 1).next() {\n            Some(pivot) => {\n                a.swap(row, pivot);\n                rank += 1;\n                for k in (row + 1)..n {\n                    if a[k][col] == 1 {\n                        for i in 0..m {\n                            a[k][i] ^= a[row][i];\n                        }\n                    }\n                }\n\n                row += 1;\n            }\n            None => {}\n        }\n\n        if row >= n {\n            break;\n        }\n    }\n    rank\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n = sc.read();\n    let m = sc.read();\n    let a: Vec<Vec<i64>> = (0..n).map(|_| sc.vec(m)).collect();\n    let rank = f2_gauss_jordan(a);\n\n    let dim_kernel = n - rank;\n    let kernel_size = pow(2, dim_kernel);\n    let ans = (pow(2, n) + MOD - kernel_size) % MOD * pow(2, m - 1);\n    println!(\"{}\", ans % MOD);\n}\n\nfn f2_gauss_jordan(mut a: Vec<Vec<i64>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    let mut row = 0;\n    for col in 0..m {\n        match (row..n).filter(|&i| a[i][col] == 1).next() {\n            Some(pivot) => {\n                a.swap(row, pivot);\n                rank += 1;\n                for k in (row + 1)..n {\n                    if a[k][col] == 1 {\n                        for i in 0..m {\n                            a[k][i] ^= a[row][i];\n                        }\n                    }\n                }\n\n                row += 1;\n            }\n            None => {}\n        }\n\n        if row >= n {\n            break;\n        }\n    }\n    rank\n}\n\nfn pow(mut x: usize, mut e: usize) -> usize {\n    let mut result = 1;\n    while e > 0 {\n        if e & 1 == 1 {\n            result *= x;\n            result %= MOD;\n        }\n        e >>= 1;\n        x *= x;\n        x %= MOD;\n    }\n    result\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 998244353;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let mut a: Vec<Vec<i64>> = (0..n)\n        .map(|_| (0..m).map(|_| sc.read()).collect())\n        .collect();\n\n    let mut rank = 0;\n    for col in 0..m {\n        match (col..n).find(|&j| a[j][col] == 1) {\n            Some(row) => {\n                a.swap(col, row);\n                rank += 1;\n                for i in 0..n {\n                    if i == col {\n                        continue;\n                    }\n                    for j in 0..m {\n                        a[i][j] ^= a[col][j];\n                    }\n                }\n            }\n            None => {}\n        }\n    }\n\n    let mut pow2 = vec![0; n + m + 1];\n    pow2[0] = 1;\n    for i in 1..pow2.len() {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n    let ans = pow2[n + m - 1] + MOD - pow2[n + m - rank - 1];\n    println!(\"{}\", ans % MOD);\n\n    // C(rank, x) * 2^(x-1) * 2^(m-x) * 2^(n-rank)\n    // 2^(n+m-rank-1) * sum C(rank, x)\n    // 2^(n+m-rank-1) * 2^rank - 2^(n+m-rank-1)\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nconst MOD: i64 = 998244353;\n\nfn rank(mut a: Vec<Vec<i32>>) -> usize {\n\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    for j in 0..m {\n        'lp: for i in rank..n {\n            if a[i][j] == 1 {\n                if i != rank {\n                    for k in 0..m {\n                        let tmp = a[rank][k];\n                        a[rank][k] = a[i][k];\n                        a[i][k] = tmp;\n                    }\n                }\n\n                rank += 1;\n                for d in rank..n {\n                    if a[d][j] == 1 {\n                        for k in 0..m {\n                            a[d][k] ^= a[rank][k];\n                        }\n                    }\n                }\n                break 'lp;\n            }\n        }\n    }\n    // debug!(a);\n    rank\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        a: [[i32; m]; n]\n    };\n    let mut p2 = vec![0; n+m];\n    p2[0] = 1;\n    for i in 1..n+m {\n        p2[i] = p2[i-1] * 2 % MOD;\n    }\n\n\n    let rank = rank(a);\n    // debug!(rank);\n    let mut ans = p2[m-1] * p2[n-rank] % MOD * (p2[rank] + MOD - 1) % MOD;\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 998244353;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let mut a = vec![vec![0; m]; n];\n    for i in 0..n {\n        for j in 0..m {\n            a[i][j] = sc.read::<i64>();\n        }\n    }\n\n    let rank = f2_gauss_jordan(a);\n    let mut pow2 = vec![1; n + m];\n    for i in 1..(n + m) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n\n    let ans = pow2[n + m - 1] + MOD - pow2[n + m - 1 - rank];\n    println!(\"{}\", ans % MOD);\n    // X = N-R\n    // Y = M-R\n    // C(R, i) * 2^(i-1) *2^X *2^(M-i)\n    // 2^(X-1) * C(R,i) *2^M i=1 to R\n    // 2^(M+X-1) * (2^R-1)\n    // 2^(N+M-1) - 2(M+N-1-R)\n}\n\nfn f2_gauss_jordan(mut a: Vec<Vec<i64>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    let mut row = 0;\n    for col in 0..m {\n        match (row..n).filter(|&i| a[i][col] == 1).next() {\n            Some(pivot) => {\n                a.swap(row, pivot);\n                rank += 1;\n                for k in (row + 1)..n {\n                    if a[k][col] == 1 {\n                        for i in 0..m {\n                            a[k][i] ^= a[row][i];\n                        }\n                    }\n                }\n\n                row += 1;\n            }\n            None => {}\n        }\n\n        if row >= n {\n            break;\n        }\n    }\n    rank\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    input!{\n        n: usize,\n        m: usize,\n        a: [[usize; m]; n]\n    }\n    let d = 998244353;\n    let mut acc: Vec<Vec<usize>> = vec![vec![0; m + 1]; n];\n    for i in 0..n {\n        for j in 0..m {\n            acc[i][j + 1] = acc[i][j] + a[i][j];\n        }\n    }\n    let mut ans = 0;\n    for l in 0..m {\n        for r in l + 1..m + 1 {\n            let mut s_e = 1;\n            let mut s_o = 0;\n            let mut c = 0;\n            let mut prev = 0;\n            for i in 0..n {\n                if (acc[i][r] - acc[i][l]) % 2 == 0 {\n                    c += s_o;\n                    if prev == 0 {\n                        s_e += 1;\n                    } else {\n                        s_o += 1;\n                    }\n                } else {\n                    c += s_e;\n                    if prev == 0 {\n                        s_o += 1;\n                    } else {\n                        s_e += 1;\n                    }\n                }\n            }\n            ans = (ans + c) % d;\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 998244353;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let mut a: Vec<Vec<i64>> = (0..n)\n        .map(|_| (0..m).map(|_| sc.read()).collect())\n        .collect();\n\n    let mut rank = 0;\n    for col in 0..m {\n        match (rank..n).find(|&i| a[i][col] == 1) {\n            Some(row) => {\n                a.swap(rank, row);\n                assert_eq!(a[rank][col], 1);\n                for i in 0..n {\n                    if i == rank || a[i][col] != 1 {\n                        continue;\n                    }\n                    for j in 0..m {\n                        a[i][j] ^= a[rank][j];\n                    }\n                }\n                rank += 1;\n            }\n            None => {}\n        }\n    }\n\n    let mut pow2 = vec![0; n + m + 1];\n    pow2[0] = 1;\n    for i in 1..pow2.len() {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n    let ans = pow2[n + m - 1] + MOD - pow2[n + m - rank - 1];\n    println!(\"{}\", ans % MOD);\n\n    // C(rank, x) * 2^(x-1) * 2^(m-x) * 2^(n-rank)\n    // 2^(n+m-rank-1) * sum C(rank, x)\n    // 2^(n+m-rank-1) * 2^rank - 2^(n+m-rank-1)\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nconst MOD: i64 = 998244353;\n\nfn rank(mut a: Vec<Vec<i32>>) -> usize {\n\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    for j in 0..m {\n        for i in 0..n {\n            if a[i][j] == 1 {\n                rank += 1;\n                for d in i+1..n {\n                    if a[d][j] == 1 {\n                        for k in 0..m {\n                            a[d][k] ^= a[i][k];\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    }\n    rank\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        a: [[i32; m]; n]\n    };\n    let mut p2 = vec![0; n+m];\n    p2[0] = 1;\n    for i in 1..n+m {\n        p2[i] = p2[i-1] * 2 % MOD;\n    }\n\n\n    let rank = rank(a);\n    let mut ans = p2[m-1] * p2[n-rank] % MOD * (p2[rank] + MOD - 1) % MOD;\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 998244353;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let mut a: Vec<Vec<i64>> = (0..n)\n        .map(|_| (0..m).map(|_| sc.read()).collect())\n        .collect();\n\n    let mut rank = 0;\n    for col in 0..m {\n        match (rank..n).find(|&i| a[i][col] == 1) {\n            Some(row) => {\n                a.swap(rank, row);\n                assert_eq!(a[rank][col], 1);\n                for i in 0..n {\n                    if i == rank {\n                        continue;\n                    }\n                    for j in 0..m {\n                        a[i][j] ^= a[rank][j];\n                    }\n                }\n                rank += 1;\n            }\n            None => {}\n        }\n    }\n\n    let mut pow2 = vec![0; n + m + 1];\n    pow2[0] = 1;\n    for i in 1..pow2.len() {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n    let ans = pow2[n + m - 1] + MOD - pow2[n + m - rank - 1];\n    println!(\"{}\", ans % MOD);\n\n    // C(rank, x) * 2^(x-1) * 2^(m-x) * 2^(n-rank)\n    // 2^(n+m-rank-1) * sum C(rank, x)\n    // 2^(n+m-rank-1) * 2^rank - 2^(n+m-rank-1)\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 998244353;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let comb = Combination::new(n + m + 1, MOD);\n    let matrix = (0..n).map(|_| sc.vec(m)).collect();\n    let rank = f2_gauss_jordan(matrix);\n\n    let mut pow2 = vec![0; n + m + 1];\n    pow2[0] = 1;\n    for i in 0..(n + m) {\n        pow2[i + 1] = (pow2[i] * 2) % MOD;\n    }\n\n    let mut ans = 0;\n    for i in 1..(rank + 1) {\n        let columns = comb.get(rank, i); // choose i columns\n        let rows = pow2[i - 1]; // rows, which interact with selected columns\n        let other_rows = pow2[rank - i];\n        let outside_rows = pow2[n - rank];\n        let outside_columns = pow2[m - rank];\n\n        let mut tmp = (columns * rows) % MOD;\n        tmp = (tmp * other_rows) % MOD;\n        tmp = (tmp * outside_rows) % MOD;\n        tmp = (tmp * outside_columns) % MOD;\n\n        ans = (ans + tmp) % MOD;\n    }\n    println!(\"{}\", ans);\n}\n\npub struct Combination {\n    fact: Vec<usize>,\n    inv_fact: Vec<usize>,\n    modulo: usize,\n}\n\nimpl Combination {\n    pub fn new(max: usize, modulo: usize) -> Combination {\n        let mut inv = vec![0; max + 1];\n        let mut fact = vec![0; max + 1];\n        let mut inv_fact = vec![0; max + 1];\n        inv[1] = 1;\n        for i in 2..(max + 1) {\n            inv[i] = inv[modulo % i] * (modulo - modulo / i) % modulo;\n        }\n        fact[0] = 1;\n        inv_fact[0] = 1;\n        for i in 0..max {\n            fact[i + 1] = fact[i] * (i + 1) % modulo;\n        }\n        for i in 0..max {\n            inv_fact[i + 1] = inv_fact[i] * inv[i + 1] % modulo;\n        }\n        Combination {\n            fact: fact,\n            inv_fact: inv_fact,\n            modulo: modulo,\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> usize {\n        assert!(x >= y);\n        self.fact[x] * self.inv_fact[y] % self.modulo * self.inv_fact[x - y] % self.modulo\n    }\n\n    pub fn h(&self, n: usize, r: usize) -> usize {\n        self.get(n + r - 1, r)\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\nfn f2_gauss_jordan(mut a: Vec<Vec<i64>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    let mut row = 0;\n    for col in 0..m {\n        match (row..n).filter(|&i| a[i][col] == 1).next() {\n            Some(pivot) => {\n                a.swap(row, pivot);\n                rank += 1;\n                for k in (row + 1)..n {\n                    if a[k][col] == 1 {\n                        for i in 0..m {\n                            a[k][i] ^= a[row][i];\n                        }\n                    }\n                }\n\n                row += 1;\n            }\n            None => {}\n        }\n\n        if row >= n {\n            break;\n        }\n    }\n    rank\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nconst MOD: i64 = 998244353;\n\nfn rank(mut a: Vec<Vec<i32>>) -> usize {\n\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    for j in 0..m {\n        'lp: for i in rank..n {\n            if a[i][j] == 1 {\n                rank += 1;\n                for d in i+1..n {\n                    if a[d][j] == 1 {\n                        for k in 0..m {\n                            a[d][k] ^= a[i][k];\n                        }\n                    }\n                }\n                break 'lp;\n            }\n        }\n    }\n    // debug!(a);\n    rank\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        a: [[i32; m]; n]\n    };\n    let mut p2 = vec![0; n+m];\n    p2[0] = 1;\n    for i in 1..n+m {\n        p2[i] = p2[i-1] * 2 % MOD;\n    }\n\n\n    let rank = rank(a);\n    // debug!(rank);\n    let mut ans = p2[m-1] * p2[n-rank] % MOD * (p2[rank] + MOD - 1) % MOD;\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nconst MOD: i64 = 998244353;\n\nfn rank(mut a: Vec<Vec<i32>>) -> usize {\n\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    for j in 0..m {\n        'lp: for i in rank..n {\n            if a[i][j] == 1 {\n                if i != rank {\n                    for k in 0..m {\n                        let tmp = a[rank][k];\n                        a[rank][k] = a[i][k];\n                        a[i][k] = tmp;\n                    }\n                }\n\n                rank += 1;\n                for d in rank+1..n {\n                    if a[d][j] == 1 {\n                        for k in 0..m {\n                            a[d][k] ^= a[i][k];\n                        }\n                    }\n                }\n                break 'lp;\n            }\n        }\n    }\n    // debug!(a);\n    rank\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        a: [[i32; m]; n]\n    };\n    let mut p2 = vec![0; n+m];\n    p2[0] = 1;\n    for i in 1..n+m {\n        p2[i] = p2[i-1] * 2 % MOD;\n    }\n\n\n    let rank = rank(a);\n    // debug!(rank);\n    let mut ans = p2[m-1] * p2[n-rank] % MOD * (p2[rank] + MOD - 1) % MOD;\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    input!{\n        n: usize,\n        m: usize,\n        a: [[usize; m]; n]\n    }\n    let d = 998244353;\n    let r = rank2(&a);\n    let ans = pow_m(2, n + m - 1, d) + d - pow_m(2, n + m - r - 1, d);\n    println!(\"{}\", ans % d);\n}\n\nfn rank2(a: &Vec<Vec<usize>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut b = a.clone();\n    let mut r = 0;\n    for i in 0..n {\n        let mut idx = 0;\n        while idx < m && b[i][idx] == 0 {\n            idx += 1;\n        }\n        if idx == m {\n            continue;\n        }\n        for j in i + 1..n {\n            for k in 0..m {\n                b[j][k] = (b[j][k] + b[i][k]) & 1;\n            }\n        }\n        r += 1;\n    }\n    r\n}\n\nfn pow_m(n: usize, mut p: usize, d: usize) -> usize {\n    let mut r = n;\n    let mut ret = 1;\n    while p > 0 {\n        if p % 2 == 0 {\n            r = r * r % d;\n            p /= 2;\n        } else {\n            ret = ret * r % d;\n            p -= 1;\n        }\n    }\n    ret\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 998244353;\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let mut a: Vec<Vec<i64>> = (0..n)\n        .map(|_| (0..m).map(|_| sc.read()).collect())\n        .collect();\n\n    let mut rank = 0;\n    for col in 0..m {\n        match (rank..n).find(|&j| a[j][col] == 1) {\n            Some(row) => {\n                a.swap(rank, row);\n                for i in 0..n {\n                    if i == rank {\n                        continue;\n                    }\n                    for j in 0..m {\n                        a[i][j] ^= a[rank][j];\n                    }\n                }\n                rank += 1;\n            }\n            None => {}\n        }\n    }\n\n    let mut pow2 = vec![0; n + m + 1];\n    pow2[0] = 1;\n    for i in 1..pow2.len() {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n    let ans = pow2[n + m - 1] + MOD - pow2[n + m - rank - 1];\n    println!(\"{}\", ans % MOD);\n\n    // C(rank, x) * 2^(x-1) * 2^(m-x) * 2^(n-rank)\n    // 2^(n+m-rank-1) * sum C(rank, x)\n    // 2^(n+m-rank-1) * 2^rank - 2^(n+m-rank-1)\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nconst MOD: i64 = 998244353;\n\nfn rank(mut a: Vec<Vec<i32>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    for j in 0..m {\n        'lp: for i in rank..n {\n            if a[i][j] == 1 {\n                if i != rank {\n                    for k in 0..m {\n                        let tmp = a[rank][k];\n                        a[rank][k] = a[i][k];\n                        a[i][k] = tmp;\n                    }\n                }\n                for d in 0..n {\n                    if d != rank && a[d][j] == 1 {\n                        for k in 0..m {\n                            a[d][k] ^= a[rank][k];\n                        }\n                    }\n                }\n                rank += 1;\n                break 'lp;\n            }\n        }\n    }\n    // debug!(a, rank);\n    rank\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        a: [[i32; m]; n]\n    };\n    let mut p2 = vec![0; n+m];\n    p2[0] = 1;\n    for i in 1..n+m {\n        p2[i] = p2[i-1] * 2 % MOD;\n    }\n\n\n    let rank = rank(a);\n    let ans = p2[m-1] * p2[n-rank] % MOD * (p2[rank] + MOD - 1) % MOD;\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < M::m());\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt::new_internal(self.x * other.x % M::m())\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new_internal(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 { sum += cur; }\n                cur += cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { self.mul_fast(other.into()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998244353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        m: usize,\n        a: [[i32; m]; n],\n    }\n    let mut a = a;\n    let mut c = 0;\n    for r in 0..m {\n        if c >= n {\n            break;\n        }\n        let mut c2 = None;\n        for i in c..n {\n            if a[i][r] == 1 {\n                c2 = Some(i);\n                break;\n            }\n        }\n        if c2.is_none() {\n            continue;\n        }\n        let c2 = c2.unwrap();\n        a.swap(c, c2);\n        for k in c + 1..n {\n            if a[k][r] == 1 {\n                for j in 0..m {\n                    a[k][j] ^= a[c][j];\n                }\n            }\n        }\n        c += 1;\n    }\n    let two = ModInt::new(2);\n    // eprintln!(\"n = {}, c = {}\", n, c);\n    let mut prod = two.pow(n as i64) - two.pow((n - c) as i64);\n    prod *= two.pow(m as i64 - 1);\n    puts!(\"{}\\n\", prod);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use self::mod_int::ModInt;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let a = (0..n).map(|_| (0..m).map(|_| sc.read()).collect()).collect();\n    let rank = gauss_jordan(a);\n    let two = ModInt::new(2);\n    let ans = (two.pow(n) - two.pow(n - rank)) * two.pow(m - 1);\n    println!(\"{}\", ans.0);\n}\n\nfn gauss_jordan(mut a: Vec<Vec<usize>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    let mut row = 0;\n    for col in 0..m {\n        let mut pivot = None;\n        for i in row..n {\n            if a[i][col] == 1 {\n                pivot = Some(i);\n                break;\n            }\n        }\n        if pivot.is_none() {\n            continue;\n        }\n\n        let pivot = pivot.unwrap();\n        a.swap(row, pivot);\n        rank += 1;\n        for k in row + 1..n {\n            if a[k][col] == 1 {\n                for j in 0..m {\n                    a[k][j] ^= a[row][j];\n                }\n            }\n        }\n\n        row += 1;\n        if row >= n {\n            break;\n        }\n    }\n    rank\n}\n\npub mod mod_int {\n    use std::ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign};\n\n    use super::MOD;\n\n    type Num = usize;\n\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: Num) -> ModInt<Num> {\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: Num) -> ModInt<Num> {\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn new(value: Num) -> Self {\n            ModInt(value)\n        }\n\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt::new(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n = sc.read();\n    let m = sc.read();\n    let a: Vec<Vec<i64>> = (0..n).map(|_| sc.vec(m)).collect();\n    let rank = f2_gauss_jordan(a);\n\n    let mut pow = vec![0; n + m + 1];\n    pow[0] = 1;\n    for i in 1..(n + m + 1) {\n        pow[i] = (pow[i - 1] * 2) % MOD;\n    }\n\n    let ans = pow[n + m - 1] + MOD - pow[n + m - rank - 1];\n    println!(\"{}\", ans % MOD);\n}\n\nfn f2_gauss_jordan(mut a: Vec<Vec<i64>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    let mut row = 0;\n    for col in 0..m {\n        match (row..n).filter(|&i| a[i][col] == 1).next() {\n            Some(pivot) => {\n                a.swap(row, pivot);\n                rank += 1;\n                for k in (row + 1)..n {\n                    if a[k][col] == 1 {\n                        for i in 0..m {\n                            a[k][i] ^= a[row][i];\n                        }\n                    }\n                }\n\n                row += 1;\n            }\n            None => {}\n        }\n\n        if row >= n {\n            break;\n        }\n    }\n    rank\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nconst MOD: i64 = 998244353;\n\nfn rank(mut a: Vec<Vec<i32>>) -> usize {\n\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    for j in 0..m {\n        'lp: for i in 0..n {\n            if a[i][j] == 1 {\n                rank += 1;\n                for d in i+1..n {\n                    if a[d][j] == 1 {\n                        for k in 0..m {\n                            a[d][k] ^= a[i][k];\n                        }\n                    }\n                }\n                break 'lp;\n            }\n        }\n    }\n    rank\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        a: [[i32; m]; n]\n    };\n    let mut p2 = vec![0; n+m];\n    p2[0] = 1;\n    for i in 1..n+m {\n        p2[i] = p2[i-1] * 2 % MOD;\n    }\n\n\n    let rank = rank(a);\n    let mut ans = p2[m-1] * p2[n-rank] % MOD * (p2[rank] + MOD - 1) % MOD;\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    input!{\n        n: usize,\n        m: usize,\n        a: [[usize; m]; n]\n    }\n    let d = 998244353;\n    let r = rank2(&a);\n    let ans = pow_m(2, n + m - 1, d) + d - pow_m(2, n + m - r - 1, d);\n    println!(\"{}\", ans % d);\n}\n\nfn rank2(a: &Vec<Vec<usize>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut b = a.clone();\n    let mut r = 0;\n    for i in 0..n {\n        let mut idx = 0;\n        while idx < m && b[i][idx] == 0 {\n            idx += 1;\n        }\n        if idx == m {\n            continue;\n        }\n        for j in i + 1..n {\n            if b[j][idx] == 1 {\n                for k in 0..m {\n                    b[j][k] = (b[j][k] + b[i][k]) & 1;\n                }\n            }\n        }\n        r += 1;\n    }\n    r\n}\n\nfn pow_m(n: usize, mut p: usize, d: usize) -> usize {\n    let mut r = n;\n    let mut ret = 1;\n    while p > 0 {\n        if p % 2 == 0 {\n            r = r * r % d;\n            p /= 2;\n        } else {\n            ret = ret * r % d;\n            p -= 1;\n        }\n    }\n    ret\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nconst MOD: i64 = 998244353;\n\nfn rank(mut a: Vec<Vec<i32>>) -> usize {\n\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    for j in 0..m {\n        'lp: for i in rank..n {\n            if a[i][j] == 1 {\n                rank += 1;\n                for d in i+1..n {\n                    if a[d][j] == 1 {\n                        for k in 0..m {\n                            a[d][k] ^= a[i][k];\n                        }\n                    }\n                }\n                break 'lp;\n            }\n        }\n    }\n    // debug!(a);\n    rank\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        a: [[i32; m]; n]\n    };\n    let mut p2 = vec![0; n+m];\n    p2[0] = 1;\n    for i in 1..n+m {\n        p2[i] = p2[i-1] * 2 % MOD;\n    }\n\n\n    let rank = rank(a);\n    debug!(rank);\n    let mut ans = p2[m-1] * p2[n-rank] % MOD * (p2[rank] + MOD - 1) % MOD;\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use self::mod_int::ModInt;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let mut a: Vec<Vec<u8>> = (0..n).map(|_| (0..m).map(|_| sc.read()).collect()).collect();\n    let mut c = 0;\n    for r in 0..m {\n        if c >= n {\n            break;\n        }\n        let mut c2 = None;\n        for i in c..n {\n            if a[i][r] == 1 {\n                c2 = Some(i);\n                break;\n            }\n        }\n        if c2.is_none() {\n            continue;\n        }\n        let c2 = c2.unwrap();\n        a.swap(c, c2);\n        for k in c + 1..n {\n            if a[k][r] == 1 {\n                for j in 0..m {\n                    a[k][j] ^= a[c][j];\n                }\n            }\n        }\n        c += 1;\n    }\n\n    let two = ModInt::new(2);\n    let mut prod = two.pow(n) - two.pow(n - c);\n    prod *= two.pow(m - 1);\n    println!(\"{}\", prod.0);\n}\n\npub mod mod_int {\n    use std::ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign};\n\n    use super::MOD;\n\n    type Num = usize;\n\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: Num) -> ModInt<Num> {\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: Num) -> ModInt<Num> {\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn new(value: Num) -> Self {\n            ModInt(value)\n        }\n\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt::new(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use self::mod_int::ModInt;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let a = (0..n).map(|_| (0..m).map(|_| sc.read()).collect()).collect();\n    let rank = f2_gauss_jordan(a);\n    let two = ModInt::new(2);\n    let ans = (two.pow(n) - two.pow(n - rank)) * two.pow(m - 1);\n    println!(\"{}\", ans.0);\n}\n\nfn f2_gauss_jordan(mut a: Vec<Vec<usize>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    let mut row = 0;\n    for col in 0..m {\n        match (row..n).filter(|&i| a[i][col] == 1).next() {\n            Some(pivot) => {\n                a.swap(row, pivot);\n                rank += 1;\n                for k in (row + 1)..n {\n                    if a[k][col] == 1 {\n                        for j in 0..m {\n                            a[k][j] ^= a[row][j];\n                        }\n                    }\n                }\n\n                row += 1;\n            }\n            None => {}\n        }\n\n        if row >= n {\n            break;\n        }\n    }\n    rank\n}\n\npub mod mod_int {\n    use std::ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign};\n\n    use super::MOD;\n\n    type Num = usize;\n\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: Num) -> ModInt<Num> {\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: Num) -> ModInt<Num> {\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn new(value: Num) -> Self {\n            ModInt(value)\n        }\n\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt::new(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n = sc.read();\n    let m = sc.read();\n    let a: Vec<Vec<i64>> = (0..n).map(|_| sc.vec(m)).collect();\n    let rank = f2_gauss_jordan(a);\n    let ans = (pow(2, n) + MOD - pow(2, n - rank)) % MOD * pow(2, m - 1);\n    println!(\"{}\", ans % MOD);\n}\n\nfn f2_gauss_jordan(mut a: Vec<Vec<i64>>) -> usize {\n    let n = a.len();\n    let m = a[0].len();\n    let mut rank = 0;\n    let mut row = 0;\n    for col in 0..m {\n        match (row..n).filter(|&i| a[i][col] == 1).next() {\n            Some(pivot) => {\n                a.swap(row, pivot);\n                rank += 1;\n                for k in (row + 1)..n {\n                    if a[k][col] == 1 {\n                        for i in 0..m {\n                            a[k][i] ^= a[row][i];\n                        }\n                    }\n                }\n\n                row += 1;\n            }\n            None => {}\n        }\n\n        if row >= n {\n            break;\n        }\n    }\n    rank\n}\n\nfn pow(mut x: usize, mut e: usize) -> usize {\n    let mut result = 1;\n    while e > 0 {\n        if e & 1 == 1 {\n            result *= x;\n            result %= MOD;\n        }\n        e >>= 1;\n        x *= x;\n        x %= MOD;\n    }\n    result\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use crate::mod_int::ModInt;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n    let mut matrix = vec![vec![0; m]; n];\n    for i in 0..n {\n        for j in 0..m {\n            matrix[i][j] = sc.read();\n        }\n    }\n\n    let comb = Combination::new(n + m, MOD);\n    let rank = f(matrix);\n\n    let mut ans = m_int(0);\n    for i in 1..=rank {\n        if i % 2 == 0 {\n            continue;\n        }\n        let c = m_int(comb.get(rank, i));\n        ans += c * m_int(2).pow(m - rank) * m_int(2).pow(n - rank) * m_int(3).pow(rank - i);\n    }\n    println!(\"{}\", ans.value());\n}\n\nfn m_int(v: usize) -> ModInt<usize> {\n    ModInt::new(v, MOD)\n}\n\npub mod mod_int {\n    use std::ops::{\n        Add, AddAssign, BitAnd, Div, DivAssign, Mul, MulAssign, RemAssign, ShrAssign, Sub,\n        SubAssign,\n    };\n\n    pub struct ModInt<T> {\n        v: T,\n        m: T,\n    }\n\n    impl<T> ModInt<T>\n    where\n        T: Copy,\n    {\n        pub fn value(&self) -> T {\n            self.v\n        }\n        pub fn modulo(&self) -> T {\n            self.m\n        }\n    }\n\n    impl<T> ModInt<T> {\n        fn new_unchecked(v: T, modulo: T) -> Self {\n            Self { v, m: modulo }\n        }\n    }\n\n    impl<T> ModInt<T>\n    where\n        T: Copy + RemAssign + PartialOrd,\n    {\n        pub fn new(mut v: T, modulo: T) -> Self {\n            if v >= modulo {\n                v %= modulo;\n            }\n            Self::new_unchecked(v, modulo)\n        }\n    }\n\n    impl<T> ModInt<T>\n    where\n        T: Copy\n            + Sub<Output = T>\n            + ShrAssign\n            + BitAnd<Output = T>\n            + PartialEq\n            + PartialOrd\n            + Div<Output = T>\n            + RemAssign,\n        ModInt<T>: MulAssign,\n    {\n        pub fn pow(self, e: T) -> Self {\n            let zero = self.modulo() - self.modulo();\n            let one = self.modulo() / self.modulo();\n            let mut e = e;\n            let mut result = Self::new_unchecked(one, self.modulo());\n            let mut cur = self;\n            while e > zero {\n                if e & one == one {\n                    result *= cur;\n                }\n                e >>= one;\n                cur *= cur;\n            }\n            result\n        }\n    }\n\n    impl<T> Copy for ModInt<T> where T: Copy {}\n    impl<T> Clone for ModInt<T>\n    where\n        T: Copy,\n    {\n        fn clone(&self) -> Self {\n            Self::new_unchecked(self.value(), self.modulo())\n        }\n    }\n\n    impl<T> Add<T> for ModInt<T>\n    where\n        T: AddAssign + SubAssign + RemAssign + Copy + PartialOrd,\n    {\n        type Output = Self;\n        fn add(self, mut rhs: T) -> Self::Output {\n            if rhs >= self.modulo() {\n                rhs %= self.modulo();\n            }\n            rhs += self.value();\n            if rhs >= self.modulo() {\n                rhs -= self.modulo();\n            }\n            Self::new_unchecked(rhs, self.modulo())\n        }\n    }\n\n    impl<T> Sub<T> for ModInt<T>\n    where\n        T: AddAssign + SubAssign + RemAssign + Copy + PartialOrd,\n    {\n        type Output = Self;\n        fn sub(self, mut rhs: T) -> Self::Output {\n            if rhs >= self.modulo() {\n                rhs %= self.modulo();\n            }\n\n            let mut result = self.value();\n            result += self.modulo();\n            result -= rhs;\n\n            if result >= self.modulo() {\n                result -= self.modulo();\n            }\n            Self::new_unchecked(result, self.modulo())\n        }\n    }\n\n    impl<T> Mul<T> for ModInt<T>\n    where\n        T: MulAssign + RemAssign + Copy + PartialOrd,\n    {\n        type Output = Self;\n        fn mul(self, mut rhs: T) -> Self::Output {\n            if rhs >= self.modulo() {\n                rhs %= self.modulo();\n            }\n            rhs *= self.value();\n            rhs %= self.modulo();\n            Self::new_unchecked(rhs, self.modulo())\n        }\n    }\n\n    impl<T> Add<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Add<T, Output = ModInt<T>>,\n    {\n        type Output = Self;\n        fn add(self, rhs: ModInt<T>) -> Self::Output {\n            self + rhs.value()\n        }\n    }\n    impl<T> Sub<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Sub<T, Output = ModInt<T>>,\n    {\n        type Output = Self;\n        fn sub(self, rhs: ModInt<T>) -> Self::Output {\n            self - rhs.value()\n        }\n    }\n    impl<T> Mul<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Mul<T, Output = ModInt<T>>,\n    {\n        type Output = Self;\n        fn mul(self, rhs: ModInt<T>) -> Self::Output {\n            self * rhs.value()\n        }\n    }\n    impl<T> Div<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Div<T, Output = ModInt<T>>,\n    {\n        type Output = Self;\n        fn div(self, rhs: ModInt<T>) -> Self::Output {\n            self / rhs.value()\n        }\n    }\n\n    impl<T> AddAssign<T> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Add<T, Output = ModInt<T>>,\n    {\n        fn add_assign(&mut self, other: T) {\n            *self = *self + other;\n        }\n    }\n    impl<T> AddAssign<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Add<ModInt<T>, Output = ModInt<T>>,\n    {\n        fn add_assign(&mut self, other: ModInt<T>) {\n            *self = *self + other;\n        }\n    }\n\n    impl<T> SubAssign<T> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Sub<T, Output = ModInt<T>>,\n    {\n        fn sub_assign(&mut self, other: T) {\n            *self = *self - other;\n        }\n    }\n\n    impl<T> SubAssign<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Sub<ModInt<T>, Output = ModInt<T>>,\n    {\n        fn sub_assign(&mut self, other: ModInt<T>) {\n            *self = *self - other;\n        }\n    }\n\n    impl<T> DivAssign<T> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Div<T, Output = ModInt<T>>,\n    {\n        fn div_assign(&mut self, rhs: T) {\n            *self = *self / rhs\n        }\n    }\n    impl<T> DivAssign<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Div<ModInt<T>, Output = ModInt<T>>,\n    {\n        fn div_assign(&mut self, rhs: ModInt<T>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl<T> MulAssign<T> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Mul<T, Output = ModInt<T>>,\n    {\n        fn mul_assign(&mut self, rhs: T) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T> MulAssign<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Mul<ModInt<T>, Output = ModInt<T>>,\n    {\n        fn mul_assign(&mut self, rhs: ModInt<T>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T> Div<T> for ModInt<T>\n    where\n        T: Copy\n            + Add<Output = T>\n            + Sub<Output = T>\n            + Div<Output = T>\n            + BitAnd<Output = T>\n            + PartialEq\n            + PartialOrd\n            + ShrAssign\n            + RemAssign\n            + MulAssign,\n    {\n        type Output = Self;\n        fn div(self, mut rhs: T) -> Self::Output {\n            if rhs >= self.modulo() {\n                rhs %= self.modulo();\n            }\n            let one = self.modulo() / self.modulo();\n            let two = one + one;\n            self * Self::new_unchecked(rhs, self.modulo()).pow(self.modulo() - two)\n        }\n    }\n}\n\nfn f(mut matrix: Vec<Vec<usize>>) -> usize {\n    let h = matrix.len();\n    let w = matrix[0].len();\n    let mut rank = 0;\n\n    for pos in 0..w {\n        if let Some(i) = (rank..h).find(|&i| matrix[i][pos] == 1) {\n            matrix.swap(rank, i);\n            for i in 0..h {\n                if i == rank || matrix[i][pos] == 0 {\n                    continue;\n                }\n                for j in 0..w {\n                    matrix[i][j] ^= matrix[rank][j];\n                }\n            }\n            rank += 1;\n        }\n    }\n    rank\n}\npub struct Combination {\n    fact: Vec<usize>,\n    inv_fact: Vec<usize>,\n    modulo: usize,\n}\n\nimpl Combination {\n    pub fn new(max: usize, modulo: usize) -> Self {\n        let mut inv = vec![0; max + 1];\n        let mut fact = vec![0; max + 1];\n        let mut inv_fact = vec![0; max + 1];\n        inv[1] = 1;\n        for i in 2..(max + 1) {\n            inv[i] = inv[modulo % i] * (modulo - modulo / i) % modulo;\n        }\n        fact[0] = 1;\n        inv_fact[0] = 1;\n        for i in 0..max {\n            fact[i + 1] = fact[i] * (i + 1) % modulo;\n        }\n        for i in 0..max {\n            inv_fact[i + 1] = inv_fact[i] * inv[i + 1] % modulo;\n        }\n        Self {\n            fact,\n            inv_fact,\n            modulo,\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> usize {\n        assert!(x >= y);\n        self.fact[x] * self.inv_fact[y] % self.modulo * self.inv_fact[x - y] % self.modulo\n    }\n\n    pub fn h(&self, n: usize, r: usize) -> usize {\n        self.get(n + r - 1, r)\n    }\n}\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> Self {\n        Self(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  }
]