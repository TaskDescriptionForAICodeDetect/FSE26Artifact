[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 998244353\n\nint grid[15][15];\nint N, M;\n\nint countOddSubset() {\n    long long result = 0;\n    \n    for (int rowMask = 0; rowMask < (1 << N); rowMask++) {\n        for (int colMask = 0; colMask < (1 << M); colMask++) {\n            int oddSum = 0;\n            \n            for (int i = 0; i < N; i++) {\n                if (rowMask & (1 << i)) {\n                    for (int j = 0; j < M; j++) {\n                        if (colMask & (1 << j)) {\n                            oddSum += grid[i][j];\n                        }\n                    }\n                }\n            }\n            \n            if (oddSum % 2 == 1) {\n                result++;\n            }\n        }\n    }\n    \n    return result % MOD;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    printf(\"%d\\n\", countOddSubset());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:56:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int **grid = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        grid[i] = (int *)malloc(M * sizeof(int));\n        for (int j = 0; j < M; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    int *row_parity = (int *)calloc(N, sizeof(int));\n    int *col_parity = (int *)calloc(M, sizeof(int));\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            row_parity[i] ^= grid[i][j];\n            col_parity[j] ^= grid[i][j];\n        }\n    }\n    \n    int a = 0, b = 0;\n    for (int i = 0; i < N; i++) {\n        if (row_parity[i]) a++;\n    }\n    for (int j = 0; j < M; j++) {\n        if (col_parity[j]) b++;\n    }\n    \n    long long *pow2 = (long long *)malloc((N + M + 1) * sizeof(long long));\n    pow2[0] = 1;\n    for (int i = 1; i <= N + M; i++) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n    \n    long long res = 0;\n    for (int k = 1; k <= a && k <= b; k += 2) {\n        long long comb_a = 1, comb_b = 1;\n        long long temp_a = 1, temp_b = 1;\n        for (int i = 1; i <= k; i++) {\n            temp_a = temp_a * (a - i + 1) % MOD;\n            temp_a = temp_a * pow(i, MOD - 2, MOD) % MOD;\n            temp_b = temp_b * (b - i + 1) % MOD;\n            temp_b = temp_b * pow(i, MOD - 2, MOD) % MOD;\n        }\n        comb_a = temp_a;\n        comb_b = temp_b;\n        res = (res + comb_a * comb_b % MOD * pow2[N - a + M - b] % MOD) % MOD;\n    }\n    \n    printf(\"%lld\\n\", res);\n    \n    for (int i = 0; i < N; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n    free(row_parity);\n    free(col_parity);\n    free(pow2);\n    \n    return 0;\n}\n\nlong long pow(long long x, long long y, long long p) {\n    long long res = 1;\n    x = x % p;\n    while (y > 0) {\n        if (y & 1) {\n            res = (res * x) % p;\n        }\n        y = y >> 1;\n        x = (x * x) % p;\n    }\n    return res;\n}",
    "timestamp": "2025-08-05 22:56:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<string> grid(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> grid[i];\n    }\n\n    vector<int> row_parity(N);\n    vector<int> col_parity(M);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            if (grid[i][j] == '1') {\n                row_parity[i] ^= 1;\n                col_parity[j] ^= 1;\n            }\n        }\n    }\n\n    int a = accumulate(row_parity.begin(), row_parity.end(), 0);\n    int b = accumulate(col_parity.begin(), col_parity.end(), 0);\n    int c = min(a, b);\n    int d = max(a, b);\n\n    vector<vector<long long>> comb(N + 1, vector<long long>(N + 1, 0));\n    comb[0][0] = 1;\n    for (int i = 1; i <= N; ++i) {\n        comb[i][0] = 1;\n        for (int j = 1; j <= i; ++j) {\n            comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n        }\n    }\n\n    long long row_even = 0, row_odd = 0;\n    for (int k = 0; k <= N; ++k) {\n        if (k % 2 == 0) {\n            row_even = (row_even + comb[N][k]) % MOD;\n        } else {\n            row_odd = (row_odd + comb[N][k]) % MOD;\n        }\n    }\n\n    long long col_even = 0, col_odd = 0;\n    for (int k = 0; k <= M; ++k) {\n        if (k % 2 == 0) {\n            col_even = (col_even + comb[M][k]) % MOD;\n        } else {\n            col_odd = (col_odd + comb[M][k]) % MOD;\n        }\n    }\n\n    long long ans = 0;\n    for (int k = 1; k <= c; k += 2) {\n        long long term = comb[a][k] * comb[M - b][a - k] % MOD;\n        term = term * comb[b][k] % MOD;\n        term = term * comb[N - a][b - k] % MOD;\n        ans = (ans + term) % MOD;\n    }\n\n    if (a == 0 && b == 0) {\n        ans = (row_even * col_even % MOD + row_odd * col_odd % MOD) % MOD;\n    } else if (a == 0) {\n        ans = row_even * col_odd % MOD;\n    } else if (b == 0) {\n        ans = row_odd * col_even % MOD;\n    }\n\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:57:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int[][] grid = new int[N][M];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n\n        int[] rowParity = new int[N];\n        int[] colParity = new int[M];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                rowParity[i] ^= grid[i][j];\n                colParity[j] ^= grid[i][j];\n            }\n        }\n\n        int totalOdd = 0;\n        for (int maskA = 1; maskA < (1 << N); maskA++) {\n            for (int maskB = 1; maskB < (1 << M); maskB++) {\n                int sum = 0;\n                for (int i = 0; i < N; i++) {\n                    if ((maskA & (1 << i)) == 0) continue;\n                    for (int j = 0; j < M; j++) {\n                        if ((maskB & (1 << j)) == 0) continue;\n                        sum ^= grid[i][j];\n                    }\n                }\n                if (sum % 2 == 1) {\n                    totalOdd++;\n                }\n            }\n        }\n\n        System.out.println(totalOdd % MOD);\n    }\n}",
    "timestamp": "2025-08-05 22:58:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MOD = 998244353;\n\n    public static int countOddSumSubsets(int[][] grid) {\n        int N = grid.length;\n        int M = grid[0].length;\n        \n        int result = 0;\n        \n        for (int rowMask = 0; rowMask < (1 << N); rowMask++) {\n            for (int colMask = 0; colMask < (1 << M); colMask++) {\n                if (isOddSum(grid, rowMask, colMask)) {\n                    result = (result + 1) % MOD;\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    private static boolean isOddSum(int[][] grid, int rowMask, int colMask) {\n        int sum = 0;\n        \n        for (int i = 0; i < grid.length; i++) {\n            if ((rowMask & (1 << i)) != 0) {\n                for (int j = 0; j < grid[0].length; j++) {\n                    if ((colMask & (1 << j)) != 0) {\n                        sum += grid[i][j];\n                    }\n                }\n            }\n        }\n        \n        return sum % 2 == 1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        int[][] grid = new int[N][M];\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        System.out.println(countOddSumSubsets(grid));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:58:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<vector<int>> grid(N, vector<int>(M));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    long long result = 0;\n    \n    for (int rowMask = 0; rowMask < (1 << N); rowMask++) {\n        for (int colMask = 0; colMask < (1 << M); colMask++) {\n            int sum = 0;\n            \n            for (int i = 0; i < N; i++) {\n                if (rowMask & (1 << i)) {\n                    for (int j = 0; j < M; j++) {\n                        if (colMask & (1 << j)) {\n                            sum += grid[i][j];\n                        }\n                    }\n                }\n            }\n            \n            if (sum % 2 == 1) {\n                result++;\n            }\n        }\n    }\n    \n    cout << result % MOD << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:58:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 998244353\n\ndef count_odd_sums(grid):\n    N = len(grid)\n    M = len(grid[0])\n    \n    row_par = [0] * N\n    col_par = [0] * M\n    \n    for i in range(N):\n        for j in range(M):\n            row_par[i] ^= grid[i][j]\n            col_par[j] ^= grid[i][j]\n    \n    row_odd = sum(1 for par in row_par if par == 1)\n    col_odd = sum(1 for par in col_par if par == 1)\n    row_even = N - row_odd\n    col_even = M - col_odd\n    \n    total_pairs = pow(2, N) * pow(2, M)\n    even_pairs = pow(2, row_even) * pow(2, col_even) + pow(2, row_odd) * pow(2, col_odd)\n    odd_pairs = total_pairs - even_pairs\n    \n    return odd_pairs % MOD\n\n# Example usage:\ngrid = [\n    [0, 1, 0],\n    [1, 0, 1],\n    [1, 1, 0]\n]\nprint(count_odd_sums(grid))  # Example function call",
    "timestamp": "2025-08-13 13:03:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class OddSumPairs {\n    private static final int MOD = 998244353;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[][] grid = new int[N][M];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        scanner.close();\n\n        long powerRows = 1;\n        long powerCols = 1;\n        long totalCells = 0;\n\n        for (int i = 0; i < N; i++) {\n            long rowSum = 0;\n            for (int j = 0; j < M; j++) {\n                if (grid[i][j] == 1) {\n                    rowSum++;\n                }\n            }\n            totalCells += rowSum;\n        }\n\n        for (int i = 0; i < N; i++) {\n            powerRows = (powerRows * 2) % MOD;\n        }\n        for (int j = 0; j < M; j++) {\n            powerCols = (powerCols * 2) % MOD;\n        }\n\n        long totalPairs = (powerRows * powerCols) % MOD;\n        long evenPairs = (powerRows / 2) * (powerCols / 2) % MOD;\n        long oddPairs = (totalPairs - evenPairs + MOD) % MOD;\n\n        if (totalCells % 2 == 0) {\n            System.out.println(evenPairs);\n        } else {\n            System.out.println(oddPairs);\n        }\n    }\n}",
    "timestamp": "2025-08-13 13:03:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    int grid[N][M];\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int even_count = 0, odd_count = 0;\n\n    // Calculate pair counts\n    for (int row_mask = 0; row_mask < (1 << N); row_mask++) {\n        for (int col_mask = 0; col_mask < (1 << M); col_mask++) {\n            int sum = 0;\n            for (int i = 0; i < N; i++) {\n                if (row_mask & (1 << i)) {\n                    for (int j = 0; j < M; j++) {\n                        if (col_mask & (1 << j)) {\n                            sum += grid[i][j];\n                        }\n                    }\n                }\n            }\n\n            if (sum % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n            if (even_count >= MOD) even_count -= MOD;\n            if (odd_count >= MOD) odd_count -= MOD;\n        }\n    }\n\n    printf(\"%d\\n\", odd_count);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:03:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function oddSumPairs(n, m, grid) {\n  const MOD = 998244353;\n  let rowOdd = new Array(1 << n).fill(0);\n  let colOdd = new Array(1 << m).fill(0);\n\n  for (let mask = 0; mask < (1 << n); mask++) {\n    let countOdd = 0;\n    for (let i = 0; i < m; i++) {\n      let sum = 0;\n      for (let j = 0; j < n; j++) {\n        if (mask & (1 << j)) {\n          sum += grid[j][i];\n        }\n      }\n      if (sum % 2 !== 0) countOdd++;\n    }\n    rowOdd[mask] = countOdd;\n  }\n\n  for (let mask = 0; mask < (1 << m); mask++) {\n    let countOdd = 0;\n    for (let i = 0; i < n; i++) {\n      let sum = 0;\n      for (let j = 0; j < m; j++) {\n        if (mask & (1 << j)) {\n          sum += grid[i][j];\n        }\n      }\n      if (sum % 2 !== 0) countOdd++;\n    }\n    colOdd[mask] = countOdd;\n  }\n\n  let totalPairs = 0;\n  for (let rowMask = 0; rowMask < (1 << n); rowMask++) {\n    for (let colMask = 0; colMask < (1 << m); colMask++) {\n      let sumOdds = 0;\n      for (let i = 0; i < n; i++) {\n        if (rowMask & (1 << i)) {\n          for (let j = 0; j < m; j++) {\n            if (colMask & (1 << j)) {\n              sumOdds += grid[i][j];\n            }\n          }\n        }\n      }\n      if (sumOdds % 2 !== 0) {\n        totalPairs++;\n      }\n    }\n  }\n  return totalPairs % MOD;\n}",
    "timestamp": "2025-08-13 13:03:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(grid, N, M):\n    MOD = 998244353\n    \n    # Precompute row and column sums\n    row_sums = [sum(row) for row in grid]\n    col_sums = [sum(col) for col in zip(*grid)]\n    \n    total_count = 0\n    \n    # Iterate through all possible row and column subsets\n    for row_mask in range(1 << N):\n        for col_mask in range(1 << M):\n            subset_sum = 0\n            \n            # Calculate sum of selected rows and columns\n            for r in range(N):\n                if row_mask & (1 << r):\n                    for c in range(M):\n                        if col_mask & (1 << c):\n                            subset_sum += grid[r][c]\n            \n            # Check if subset sum is odd\n            if subset_sum % 2 == 1:\n                total_count += 1\n    \n    return total_count % MOD\n\n# Input parsing\nN, M = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(N)]\n\n# Print result\nprint(solve(grid, N, M))",
    "timestamp": "2025-08-13 13:04:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(grid) {\n    const N = grid.length;\n    const M = grid[0].length;\n    const MOD = 998244353;\n\n    let result = 0;\n    for (let rowMask = 0; rowMask < (1 << N); rowMask++) {\n        for (let colMask = 0; colMask < (1 << M); colMask++) {\n            let sum = 0;\n            for (let r = 0; r < N; r++) {\n                if (rowMask & (1 << r)) {\n                    for (let c = 0; c < M; c++) {\n                        if (colMask & (1 << c)) {\n                            sum += grid[r][c];\n                        }\n                    }\n                }\n            }\n            if (sum % 2 === 1) {\n                result = (result + 1) % MOD;\n            }\n        }\n    }\n    return result;\n}",
    "timestamp": "2025-08-13 13:04:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\nMOD = 998244353\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(N)]\n    \n    row_parity = [0] * N\n    col_parity = [0] * M\n    \n    for i in range(N):\n        cnt = 0\n        for j in range(M):\n            if grid[i][j] == '1':\n                cnt += 1\n        row_parity[i] = cnt % 2\n    \n    for j in range(M):\n        cnt = 0\n        for i in range(N):\n            if grid[i][j] == '1':\n                cnt += 1\n        col_parity[j] = cnt % 2\n    \n    a = sum(row_parity)\n    b = sum(col_parity)\n    \n    # The answer is (2^{a} * 2^{M - b} + 2^{N - a} * 2^{b} - 2^{N + M - 1}) mod MOD\n    # But need to handle cases when N or M is zero, but in the problem N and M are at least 1.\n    \n    term1 = pow(2, a, MOD) * pow(2, M - b, MOD) % MOD\n    term2 = pow(2, N - a, MOD) * pow(2, b, MOD) % MOD\n    total = (term1 + term2) % MOD\n    \n    # Subtract the overcounted cases where both row and column selections are even (which sum to even)\n    # But the initial terms count (odd row and even col) + (even row and odd col)\n    # So total is correct as (odd row and even col) + (even row and odd col) = total required.\n    # Alternatively, the answer is (2^{N + M - 1}) mod MOD if the total sum is odd, else (2^{N + M} - 2^{N + M - 1}) mod MOD.\n    # But the above approach is more straightforward.\n    \n    # However, the correct formula is (2^{a + M - b} + 2^{N - a + b} - 2^{N + M - 1}) mod MOD if the total sum is odd, else (2^{N + M - 1}) mod MOD.\n    # But the initial approach seems to match the required condition.\n    \n    # Another way: The answer is (2^{N + M - 1}) mod MOD if the total sum of all cells is odd, else (2^{N + M} - 2^{N + M - 1}) mod MOD.\n    total_sum = 0\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                total_sum += 1\n    total_sum %= 2\n    \n    if total_sum == 1:\n        ans = pow(2, N + M - 1, MOD)\n    else:\n        ans = (pow(2, N + M, MOD) - pow(2, N + M - 1, MOD)) % MOD\n    \n    print(ans)\n\nsolve()",
    "timestamp": "2025-08-13 13:04:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 998244353;\n\nfunction solve() {\n    const input = require('fs').readFileSync(0, 'utf-8').trim().split('\\n');\n    const [N, M] = input[0].split(' ').map(Number);\n    const grid = input.slice(1, N + 1).map(row => row.split('').map(Number));\n    \n    let rowXor = Array(N).fill(0);\n    let colXor = Array(M).fill(0);\n    \n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < M; j++) {\n            rowXor[i] ^= grid[i][j];\n            colXor[j] ^= grid[i][j];\n        }\n    }\n    \n    const countRow = [0, 0];\n    for (const x of rowXor) {\n        countRow[x]++;\n    }\n    \n    const countCol = [0, 0];\n    for (const x of colXor) {\n        countCol[x]++;\n    }\n    \n    let ans = 0;\n    for (let k = 1; k <= Math.min(countRow[1], countCol[1]); k += 2) {\n        const c1 = countRow[1];\n        const c0 = countRow[0];\n        const d1 = countCol[1];\n        const d0 = countCol[0];\n        \n        const comb_c1 = combMod(c1, k, MOD);\n        const comb_d1 = combMod(d1, k, MOD);\n        const pow_c0 = powMod(2, c0, MOD);\n        const pow_d0 = powMod(2, d0, MOD);\n        \n        const term = (comb_c1 * comb_d1 % MOD) * (pow_c0 * pow_d0 % MOD) % MOD;\n        ans = (ans + term) % MOD;\n    }\n    \n    console.log(ans);\n}\n\nfunction combMod(n, k, mod) {\n    if (k < 0 || k > n) return 0;\n    let res = 1;\n    for (let i = 1; i <= k; i++) {\n        res = res * (n - k + i) % mod;\n        res = res * invMod(i, mod) % mod;\n    }\n    return res;\n}\n\nfunction invMod(a, mod) {\n    return powMod(a, mod - 2, mod);\n}\n\nfunction powMod(a, b, mod) {\n    let res = 1;\n    a = a % mod;\n    while (b > 0) {\n        if (b % 2 === 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b = Math.floor(b / 2);\n    }\n    return res;\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:04:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 998244353;\n\nint main() {\n    int N, M;\n    std::cin >> N >> M;\n\n    std::vector<std::vector<int>> grid(N, std::vector<int>(M));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            std::cin >> grid[i][j];\n        }\n    }\n\n    int totalSum = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            totalSum += grid[i][j];\n        }\n    }\n\n    int pow2NM = 1;\n    for (int i = 0; i < N + M; ++i) {\n        pow2NM = (pow2NM * 2) % MOD;\n    }\n\n    int result = (totalSum % 2) * (pow2NM / 2) % MOD;\n    std::cout << result << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:37:33"
  }
]