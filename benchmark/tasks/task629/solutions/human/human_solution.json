[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <map>\n\nclass EmdeBoasTree;\n\ntemplate <size_t Height>\nclass EmdeBoasTreeNode {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<Height+1>;\n  using IndexType = unsigned long long;\n  static constexpr int HALF_WIDTH=1<<(Height-1);\n\n  IndexType min_=1, max_=0;\n  EmdeBoasTreeNode<Height-1> *summary=nullptr;\n  std::map<IndexType, EmdeBoasTreeNode<Height-1>> cluster={};\n\n  EmdeBoasTreeNode() = default;\n\n  constexpr IndexType upper(IndexType u) const {\n    return u >> HALF_WIDTH;\n  }\n\n  constexpr IndexType lower(IndexType u) const {\n    return u & ((IndexType(1) << HALF_WIDTH) - 1);\n  }\n\n  bool contains(IndexType u) const {\n    if (u == min_ || u == max_) return true;\n    if (u < min_ || max_ < u) return false;\n    if (summary == nullptr || !summary->contains(upper(u))) return false;\n    assert(cluster.find(upper(u)) != cluster.end());\n    return cluster.at(upper(u)).contains(lower(u));\n  }\n\n  IndexType successor(IndexType u) const {\n    if (empty() || u >= max_) throw std::out_of_range(\"no successor\");\n    if (u < min_) return min_;\n    if (summary == nullptr) return max_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu < cluster.at(uu).max())\n      return uu << HALF_WIDTH | cluster.at(uu).successor(lu);\n\n    if (uu >= summary->max()) return max_;\n    IndexType bucket=summary->successor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).min();\n  }\n\n  IndexType predecessor(IndexType u) const {\n    if (empty() || u <= min_) throw std::out_of_range(\"no predecessor\");\n    if (u > max_) return max_;\n    if (summary == nullptr) return min_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu > cluster.at(uu).min())\n      return uu << HALF_WIDTH | cluster.at(uu).predecessor(lu);\n\n    if (uu <= summary->min()) return min_;\n    IndexType bucket=summary->predecessor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).max();\n  }\n\n  bool insert(IndexType u) {\n    if (empty()) {\n      min_ = max_ = u;\n      return true;\n    }\n    if (u == min_ || u == max_) return false;\n\n    if (min_ == max_) {\n      if (max_ < u) {\n        max_ = u;\n        return true;\n      }\n      min_ = u;\n      return true;\n    }\n\n    if (min_ > u) {\n      std::swap(min_, u);\n    } else if (max_ < u) {\n      std::swap(max_, u);\n    }\n\n    if (summary == nullptr) summary = new EmdeBoasTreeNode<Height-1>;\n    summary->insert(upper(u));\n\n    auto it=cluster.lower_bound(upper(u));\n    if (it == cluster.end() || it->first != upper(u))\n      it = cluster.emplace_hint(it, upper(u), EmdeBoasTreeNode<Height-1>());\n\n    return it->second.insert(lower(u));\n  }\n\n  bool erase(IndexType u) {\n    if (min_ == max_) {\n      if (min_ == u) {\n        min_ = 1;\n        max_ = 0;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    if (u < min_ || max_ < u) return false;\n\n    if (summary == nullptr) {\n      if (u == min_) {\n        min_ = max_;\n        return true;\n      } else if (u == max_) {\n        max_ = min_;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    IndexType bucket=upper(u), v=lower(u);\n    if (u == min_) {\n      bucket = summary->min();\n      v = cluster.at(bucket).min();\n      min_ = bucket << HALF_WIDTH | v;\n    } else if (u == max_) {\n      bucket = summary->max();\n      v = cluster.at(bucket).max();\n      max_ = bucket << HALF_WIDTH | v;\n    } else {\n      if (!summary->contains(bucket)) return false;\n    }\n    bool res=cluster.at(bucket).erase(v);\n    if (res && cluster.at(bucket).empty()) {\n      cluster.erase(bucket);\n      summary->erase(bucket);\n      if (summary->empty()) {\n        delete summary;\n        summary = nullptr;\n      }\n    }\n    return res;\n  }\n\n  IndexType min() const {\n    if (empty()) throw std::out_of_range(\"min() on {}\");\n    return min_;\n  }\n\n  IndexType max() const {\n    if (empty()) throw std::out_of_range(\"max() on {}\");\n    return max_;\n  }\n\n  bool empty() const {\n    return max_ < min_;\n  }\n};\n\ntemplate <>\nclass EmdeBoasTreeNode<3> {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<4>;\n  using IndexType = unsigned long long;\n\n  IndexType vec[4]={};\n\n  EmdeBoasTreeNode() = default;\n\n  bool contains(IndexType u) const {\n    return vec[u/64] >> (u%64) & 1;\n  }\n\n  IndexType successor(IndexType u) const {\n    IndexType tmp=vec[u/64]&-(1uLL<<((u+1)%64));\n    if (tmp > 0) return (u/64*64) | __builtin_ctzll(tmp);\n    for (size_t i=u/64+1; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"u <= minimum\");\n  }\n\n  IndexType predecessor(IndexType u) const {\n    IndexType tmp=vec[u/64]&((1uLL<<(u%64))-1);\n    if (tmp > 0) return (u/64*64) | (63-__builtin_clzll(tmp));\n    for (size_t i=u/64; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"u >= maximum\");\n  }\n\n  bool insert(IndexType u) {\n    if (vec[u/64] >> (u%64) & 1) return false;\n    vec[u/64] |= 1uLL << (u%64);\n    return true;\n  }\n\n  bool erase(IndexType u) {\n    if (!(vec[u/64] >> (u%64) & 1)) return false;\n    vec[u/64] ^= 1uLL << (u%64);\n    return true;\n  }\n\n  IndexType min() const {\n    for (int i=0; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"min() on {}\");\n  }\n\n  IndexType max() const {\n    for (size_t i=4; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"max() on {}\");\n  }\n\n  bool empty() const {\n    return !(vec[0] || vec[1] || vec[2] || vec[3]);\n  }\n};\n\nclass EmdeBoasTree {\n  using IndexType = unsigned long long;\n  static constexpr size_t TopHeight=5;\n\n  EmdeBoasTreeNode<TopHeight> *root;\n  size_t size_=0;\n\npublic:\n  EmdeBoasTree(): root(new EmdeBoasTreeNode<TopHeight>) {}\n\n  IndexType min() const { return root->min(); }\n  IndexType max() const { return root->max(); }\n  bool empty() const { return root->empty(); }\n  bool contains(IndexType u) const { return !empty() && root->contains(u); }\n  IndexType successor(IndexType u) const { return root->successor(u); }\n  IndexType predecessor(IndexType u) const { return root->predecessor(u); }\n  bool insert(IndexType u) { return root->insert(u) && ++size_; }\n  bool erase(IndexType u) { return !empty() && root->erase(u) && size_--; }\n  size_t size() const { return size_; }\n\n  void debug() const {\n    if (empty()) {\n      fprintf(stderr, \"{}\\n\");\n      return ;\n    }\n    fprintf(stderr, \"{\");\n    IndexType i_ub=max();\n    for (IndexType i=min(); i<i_ub; i=successor(i)) {\n      fprintf(stderr, \"%llu%s\", i, i<i_ub? \", \":\"\");\n      assert(contains(successor(i)));\n      assert(i < successor(i));\n    }\n\n    fprintf(stderr, \"%llu}\\n\", i_ub);\n    fflush(stderr);\n  }\n};\n\nint main() {\n  int q;\n  scanf(\"%d\", &q);\n\n  EmdeBoasTree veb;\n\n  for (int i=0; i<q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 0) {\n      /* insert */\n      int x;\n      scanf(\"%d\", &x);\n      veb.insert(x);\n      printf(\"%zu\\n\", veb.size());\n    } else if (t == 1) {\n      /* find */\n      int x;\n      scanf(\"%d\", &x);\n      printf(\"%d\\n\", veb.contains(x));\n    } else if (t == 2) {\n      /* delete */\n      int x;\n      scanf(\"%d\", &x);\n      veb.erase(x);\n    } else if (t == 3) {\n      /* dump */\n      unsigned long long l, r;\n      scanf(\"%llu %llu\", &l, &r);\n      if (veb.max() < l) continue;\n\n      if (veb.contains(l))\n        printf(\"%llu\\n\", l);\n\n      r = std::min(r, veb.max());\n      do {\n        l = veb.successor(l);\n        if (l > r) break;\n        printf(\"%llu\\n\", l);\n      } while (l < r);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <set>\n#include <iterator>\nusing namespace std;\nint main(){\n    int n,temp,k;\n    set<int> s;\n    set<int>::iterator u;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&k,&temp);\n        if(k==0){\n            s.insert(temp);\n            printf(\"%ld\\n\",s.size());\n        }\n        else if(k==1){\n            if(s.find(temp)==s.end())printf(\"0\\n\");\n            else printf(\"1\\n\");\n        }\n        else if(k==2)s.erase(temp);   \n        else{\n            u=s.lower_bound(temp);\n            cin>>temp;\n            while(u!=s.end()){\n                if(*u>temp)break;\n                cout<<*u<<endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 100000000\n#define INF 1000000000000000000\n#define MOD 1000000007\n#define mod 1000000007\n#define REP(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_time=clock();\n    //-------------------------------\n    set<ll>s;\n    ll q;cin>>q;\n    while(q--){\n        ll a,x;cin>>a>>x;\n        if(a==0){\n            s.insert(x);\n            cout<<s.size()<<endl;\n        }\n        else if(a==1){\n            cout<<s.count(x)<<endl;\n        }\n        else if(a==2){\n                s.erase(x);\n        }\n        else{\n            ll l=x;\n            ll r;cin>>r;\n            auto left=s.lower_bound(l);\n            auto right=s.upper_bound(r);\n            for(auto it=left;it!=right;it++){\n                cout<<*it<<endl;\n            }\n        }\n    }\n    //-------------------------------  \n    //ll end_time=clock();cout<<\"time=\"<<end_time-begin_time<<\"ms\"<<endl;\n    //-------------------------------\n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <map>\n\nclass EmdeBoasTree;\n\ntemplate <size_t Height>\nclass EmdeBoasTreeNode {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<Height+1>;\n  using IndexType = unsigned long long;\n  static constexpr int HALF_WIDTH=1<<(Height-1);\n\n  IndexType min_=1, max_=0;\n  EmdeBoasTreeNode<Height-1> *summary=nullptr;\n  std::map<IndexType, EmdeBoasTreeNode<Height-1>> cluster={};\n\n  EmdeBoasTreeNode() = default;\n\n  constexpr IndexType upper(IndexType u) const {\n    return u >> HALF_WIDTH;\n  }\n\n  constexpr IndexType lower(IndexType u) const {\n    return u & ((IndexType(1) << HALF_WIDTH) - 1);\n  }\n\n  bool contains(IndexType u) const {\n    if (u == min_ || u == max_) return true;\n    if (u < min_ || max_ < u) return false;\n    if (summary == nullptr || !summary->contains(upper(u))) return false;\n    assert(cluster.find(upper(u)) != cluster.end());\n    return cluster.at(upper(u)).contains(lower(u));\n  }\n\n  IndexType successor(IndexType u) const {\n    if (empty() || u >= max_) throw std::out_of_range(\"no successor\");\n    if (u < min_) return min_;\n    if (summary == nullptr) return max_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu < cluster.at(uu).max())\n      return uu << HALF_WIDTH | cluster.at(uu).successor(lu);\n\n    if (uu >= summary->max()) return max_;\n    IndexType bucket=summary->successor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).min();\n  }\n\n  IndexType predecessor(IndexType u) const {\n    if (empty() || u <= min_) throw std::out_of_range(\"no predecessor\");\n    if (u > max_) return max_;\n    if (summary == nullptr) return min_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu > cluster.at(uu).min())\n      return uu << HALF_WIDTH | cluster.at(uu).predecessor(lu);\n\n    if (uu <= summary->min()) return min_;\n    IndexType bucket=summary->predecessor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).max();\n  }\n\n  bool insert(IndexType u) {\n    if (empty()) {\n      min_ = max_ = u;\n      return true;\n    }\n    if (u == min_ || u == max_) return false;\n\n    if (min_ == max_) {\n      if (max_ < u) {\n        max_ = u;\n        return true;\n      }\n      min_ = u;\n      return true;\n    }\n\n    if (min_ > u) {\n      std::swap(min_, u);\n    } else if (max_ < u) {\n      std::swap(max_, u);\n    }\n\n    if (summary == nullptr) summary = new EmdeBoasTreeNode<Height-1>;\n    summary->insert(upper(u));\n\n    auto it=cluster.lower_bound(upper(u));\n    if (it == cluster.end() || it->first != upper(u))\n      it = cluster.emplace_hint(it, upper(u), EmdeBoasTreeNode<Height-1>());\n\n    return it->second.insert(lower(u));\n  }\n\n  bool erase(IndexType u) {\n    if (min_ == max_) {\n      if (min_ == u) {\n        min_ = 1;\n        max_ = 0;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    if (u < min_ || max_ < u) return false;\n\n    if (summary == nullptr) {\n      if (u == min_) {\n        min_ = max_;\n        return true;\n      } else if (u == max_) {\n        max_ = min_;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    IndexType bucket=upper(u), v=lower(u);\n    if (u == min_) {\n      bucket = summary->min();\n      v = cluster.at(bucket).min();\n      min_ = bucket << HALF_WIDTH | v;\n    } else if (u == max_) {\n      bucket = summary->max();\n      v = cluster.at(bucket).max();\n      max_ = bucket << HALF_WIDTH | v;\n    } else {\n      if (!summary->contains(bucket)) return false;\n    }\n    bool res=cluster.at(bucket).erase(v);\n    if (res && cluster.at(bucket).empty()) {\n      cluster.erase(bucket);\n      summary->erase(bucket);\n      if (summary->empty()) {\n        delete summary;\n        summary = nullptr;\n      }\n    }\n    return res;\n  }\n\n  IndexType min() const {\n    if (empty()) throw std::out_of_range(\"min() on {}\");\n    return min_;\n  }\n\n  IndexType max() const {\n    if (empty()) throw std::out_of_range(\"max() on {}\");\n    return max_;\n  }\n\n  bool empty() const {\n    return max_ < min_;\n  }\n};\n\ntemplate <>\nclass EmdeBoasTreeNode<3> {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<4>;\n  using IndexType = unsigned long long;\n\n  IndexType vec[4]={};\n\n  EmdeBoasTreeNode() = default;\n\n  bool contains(IndexType u) const {\n    return vec[u/64] >> (u%64) & 1;\n  }\n\n  IndexType successor(IndexType u) const {\n    IndexType tmp=vec[u/64]&-(1uLL<<((u+1)%64));\n    if (tmp > 0) return (u/64*64) | __builtin_ctzll(tmp);\n    for (size_t i=u/64+1; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"u <= minimum\");\n  }\n\n  IndexType predecessor(IndexType u) const {\n    IndexType tmp=vec[u/64]&((1uLL<<(u%64))-1);\n    if (tmp > 0) return (u/64*64) | (63-__builtin_clzll(tmp));\n    for (size_t i=u/64; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"u >= maximum\");\n  }\n\n  bool insert(IndexType u) {\n    if (vec[u/64] >> (u%64) & 1) return false;\n    vec[u/64] |= 1uLL << (u%64);\n    return true;\n  }\n\n  bool erase(IndexType u) {\n    if (!(vec[u/64] >> (u%64) & 1)) return false;\n    vec[u/64] ^= 1uLL << (u%64);\n    return true;\n  }\n\n  IndexType min() const {\n    for (int i=0; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"min() on {}\");\n  }\n\n  IndexType max() const {\n    for (size_t i=4; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"max() on {}\");\n  }\n\n  bool empty() const {\n    return !(vec[0] || vec[1] || vec[2] || vec[3]);\n  }\n};\n\nclass EmdeBoasTree {\n  using IndexType = unsigned long long;\n  static constexpr size_t TopHeight=5;\n\n  EmdeBoasTreeNode<TopHeight> *root;\n  size_t size_=0;\n\npublic:\n  EmdeBoasTree(): root(new EmdeBoasTreeNode<TopHeight>) {}\n\n  IndexType min() const { return root->min(); }\n  IndexType max() const { return root->max(); }\n  bool empty() const { return root->empty(); }\n  bool contains(IndexType u) const { return !empty() && root->contains(u); }\n  IndexType successor(IndexType u) const { return root->successor(u); }\n  IndexType predecessor(IndexType u) const { return root->predecessor(u); }\n  bool insert(IndexType u) { return root->insert(u) && ++size_; }\n  bool erase(IndexType u) { return !empty() && root->erase(u) && size_--; }\n  size_t size() const { return size_; }\n\n  void debug() const {\n    if (empty()) {\n      fprintf(stderr, \"{}\\n\");\n      return ;\n    }\n    fprintf(stderr, \"{\");\n    IndexType i_ub=max();\n    for (IndexType i=min(); i<i_ub; i=successor(i)) {\n      fprintf(stderr, \"%llu%s\", i, i<i_ub? \", \":\"\");\n      assert(contains(successor(i)));\n      assert(i < successor(i));\n    }\n\n    fprintf(stderr, \"%llu}\\n\", i_ub);\n    fflush(stderr);\n  }\n};\n\nint main() {\n  int q;\n  scanf(\"%d\", &q);\n\n  EmdeBoasTree veb;\n\n  for (int i=0; i<q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 0) {\n      /* insert */\n      int x;\n      scanf(\"%d\", &x);\n      veb.insert(x);\n      printf(\"%zu\\n\", veb.size());\n    } else if (t == 1) {\n      /* find */\n      int x;\n      scanf(\"%d\", &x);\n      printf(\"%d\\n\", veb.contains(x));\n    } else if (t == 2) {\n      /* delete */\n      int x;\n      scanf(\"%d\", &x);\n      veb.erase(x);\n    } else if (t == 3) {\n      /* dump */\n      unsigned long long l, r;\n      scanf(\"%llu %llu\", &l, &r);\n      if (veb.empty()) continue;\n      if (veb.max() < l) continue;\n\n      if (veb.contains(l))\n        printf(\"%llu\\n\", l);\n\n      r = std::min(r, veb.max());\n      do {\n        l = veb.successor(l);\n        if (l > r) break;\n        printf(\"%llu\\n\", l);\n      } while (l < r);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n#define PI acos(-1)\n#define Mod (int)1000000007\n#define INFTY (int)INT_MAX\n#define Rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define BitRep(i, n) for (int i = 0; i < (int)(1 << n); i++)\n#define All(vec) vec.begin(), vec.end()\n#define Part(vec, b, e) vec.begin() + b, vec.begin() + e\n#define Sum(vec) accumulate(vec.begin(), vec.end(), 0)\n#define Sort(vec) sort(vec.begin(), vec.end())\n#define Reverse(vec) reverse(vec.begin(), vec.end())\n#define Count(vec, x) count(vec.begin(), vec.end(), x)\n#define Next_permutation(vec) next_permutation(vec.begin(), vec.end())\n#define Find(vec, s) vec.find(s) != vec.end()\n\nint main() {\n\tset<int> S;\n\tint q;\n\tcin >> q;\n\tRep(i, q) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tS.insert(x);\n\t\t\tcout << S.size() << endl;\n\t\t}\n\t\telse if (n == 1) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tif (S.find(x) != S.end()) cout << 1 << endl;\n\t\t\telse cout << 0 << endl;\n\t\t}\n\t\telse if (n == 2) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tS.erase(x);\n\t\t}\n\t\telse if (n == 3) {\n\t\t\tint L, R;\n\t\t\tcin >> L >> R;\n\t\t\tfor (auto itr = S.lower_bound(L); itr != S.end() && *itr <= R; itr++) {\n\t\t\t\tcout << *itr << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nint main() {\n\tset<int> x;\n\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tint flag = 0;\n\t\tcin >> flag;\n\t\tlong int value;\n\t\tcin >> value;\n\t\tif(flag == 0) {\n\t\t\tx.insert(value);\n\t\t\tcout << x.size() << endl;\n\t\t}\n\t\telse if(flag == 1) {\n\t\t\tset<int>::iterator itr = x.find(value);\n\t\t\tif(itr != x.end()) {\n\t\t\t\tcout << 1 << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 0 << endl;\n\t\t\t}\n\t\t}\n\t\telse if(flag == 2) {\n\t\t\tx.erase(value);\n\t\t}\n\t\telse {\n\t\t\tint r;\n\t\t\tcin >> r;\n\t\t\tset<int>::iterator itr, end;\n\t\t\titr = x.lower_bound(value);\n\t\t\tend = x.upper_bound(r);\n\t\t\tfor(;itr != end; itr++) {\n\t\t\t\tcout << *itr << endl;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n//    ios_base::sync_with_stdio(false);\n//    cin.tie(NULL);\n//    cout.tie(NULL);\n\n    ll q, x, p, o;\n    set <ll> S;\n\n    cin >> q;\n\n    while(q--)\n    {\n        cin >> x >> p;\n\n        if(x == 0)\n        {\n            S.insert(p);\n            cout << S.size() << endl;\n        }\n\n        else if(x == 1)\n            cout << (S.find(p) != S.end() ? 1 : 0) << endl;\n\n        else if(x == 2)\n            S.erase(p);\n\n        else\n        {\n            cin >> o;\n            auto it = S.lower_bound(p);\n\n            for(; it != S.end() && *it <= o; it++)\n                cout << *it << endl;\n        }\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main(int argc, char *argv[]) {\n  int q;\n  std::cin >> q;\n  std::set<long> s;\n  for (int i = 0; i < q; ++i) {\n    int c, x;\n    std::cin >> c >> x;\n    switch (c) {\n    case 0:\n      s.insert(x);\n      std::cout << s.size() << std::endl;\n      break;\n    case 1:\n      std::cout << s.count(x) << std::endl;\n      break;\n    case 2:\n      s.erase(x);\n      break;\n    case 3:\n      int r;\n      std::cin >> r;\n      for (auto i = s.lower_bound(x); i != s.upper_bound(r); i++) {\n        std::cout << *i << std::endl;\n      }\n      break;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <map>\n\nclass EmdeBoasTree;\n\ntemplate <size_t Height>\nclass EmdeBoasTreeNode {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<Height+1>;\n  using IndexType = unsigned long long;\n  static constexpr int HALF_WIDTH=1<<(Height-1);\n\n  IndexType min_=1, max_=0;\n  EmdeBoasTreeNode<Height-1> *summary=nullptr;\n  std::map<IndexType, EmdeBoasTreeNode<Height-1>> cluster={};\n\n  EmdeBoasTreeNode() = default;\n\n  constexpr IndexType upper(IndexType u) const {\n    return u >> HALF_WIDTH;\n  }\n\n  constexpr IndexType lower(IndexType u) const {\n    return u & ((IndexType(1) << HALF_WIDTH) - 1);\n  }\n\n  bool contains(IndexType u) const {\n    if (u == min_ || u == max_) return true;\n    if (u < min_ || max_ < u) return false;\n    if (summary == nullptr || !summary->contains(upper(u))) return false;\n    assert(cluster.find(upper(u)) != cluster.end());\n    return cluster.at(upper(u)).contains(lower(u));\n  }\n\n  IndexType successor(IndexType u) const {\n    if (empty() || u >= max_) throw std::out_of_range(\"no successor\");\n    if (u < min_) return min_;\n    if (summary == nullptr) return max_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu < cluster.at(uu).max())\n      return uu << HALF_WIDTH | cluster.at(uu).successor(lu);\n\n    if (uu >= summary->max()) return max_;\n    IndexType bucket=summary->successor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).min();\n  }\n\n  IndexType predecessor(IndexType u) const {\n    if (empty() || u <= min_) throw std::out_of_range(\"no predecessor\");\n    if (u > max_) return max_;\n    if (summary == nullptr) return min_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu > cluster.at(uu).min())\n      return uu << HALF_WIDTH | cluster.at(uu).predecessor(lu);\n\n    if (uu <= summary->min()) return min_;\n    IndexType bucket=summary->predecessor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).max();\n  }\n\n  bool insert(IndexType u) {\n    if (empty()) {\n      min_ = max_ = u;\n      return true;\n    }\n    if (u == min_ || u == max_) return false;\n\n    if (min_ == max_) {\n      if (max_ < u) {\n        max_ = u;\n        return true;\n      }\n      min_ = u;\n      return true;\n    }\n\n    if (min_ > u) {\n      std::swap(min_, u);\n    } else if (max_ < u) {\n      std::swap(max_, u);\n    }\n\n    if (summary == nullptr) summary = new EmdeBoasTreeNode<Height-1>;\n    summary->insert(upper(u));\n\n    auto it=cluster.lower_bound(upper(u));\n    if (it == cluster.end() || it->first != upper(u))\n      it = cluster.emplace_hint(it, upper(u), EmdeBoasTreeNode<Height-1>());\n\n    return it->second.insert(lower(u));\n  }\n\n  bool erase(IndexType u) {\n    if (min_ == max_) {\n      if (min_ == u) {\n        min_ = 1;\n        max_ = 0;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    if (u < min_ || max_ < u) return false;\n\n    if (summary == nullptr) {\n      if (u == min_) {\n        min_ = max_;\n        return true;\n      } else if (u == max_) {\n        max_ = min_;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    IndexType bucket=upper(u), v=lower(u);\n    if (u == min_) {\n      bucket = summary->min();\n      v = cluster.at(bucket).min();\n      min_ = bucket << HALF_WIDTH | v;\n    } else if (u == max_) {\n      bucket = summary->max();\n      v = cluster.at(bucket).max();\n      max_ = bucket << HALF_WIDTH | v;\n    } else {\n      if (!summary->contains(bucket)) return false;\n    }\n    bool res=cluster.at(bucket).erase(v);\n    if (res && cluster.at(bucket).empty()) {\n      cluster.erase(bucket);\n      summary->erase(bucket);\n      if (summary->empty()) {\n        delete summary;\n        summary = nullptr;\n      }\n    }\n    return res;\n  }\n\n  IndexType min() const {\n    if (empty()) throw std::out_of_range(\"min() on {}\");\n    return min_;\n  }\n\n  IndexType max() const {\n    if (empty()) throw std::out_of_range(\"max() on {}\");\n    return max_;\n  }\n\n  bool empty() const {\n    return max_ < min_;\n  }\n};\n\ntemplate <>\nclass EmdeBoasTreeNode<3> {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<4>;\n  using IndexType = unsigned long long;\n\n  IndexType vec[4]={};\n\n  EmdeBoasTreeNode() = default;\n\n  bool contains(IndexType u) const {\n    return vec[u/64] >> (u%64) & 1;\n  }\n\n  IndexType successor(IndexType u) const {\n    IndexType tmp=vec[u/64]&-(1uLL<<((u+1)%64));\n    if (tmp > 0) return (u/64*64) | __builtin_ctzll(tmp);\n    for (size_t i=u/64+1; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"u <= minimum\");\n  }\n\n  IndexType predecessor(IndexType u) const {\n    IndexType tmp=vec[u/64]&((1uLL<<(u%64))-1);\n    if (tmp > 0) return (u/64*64) | (63-__builtin_clzll(tmp));\n    for (size_t i=u/64; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"u >= maximum\");\n  }\n\n  bool insert(IndexType u) {\n    if (vec[u/64] >> (u%64) & 1) return false;\n    vec[u/64] |= 1uLL << (u%64);\n    return true;\n  }\n\n  bool erase(IndexType u) {\n    if (!(vec[u/64] >> (u%64) & 1)) return false;\n    vec[u/64] ^= 1uLL << (u%64);\n    return true;\n  }\n\n  IndexType min() const {\n    for (int i=0; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"min() on {}\");\n  }\n\n  IndexType max() const {\n    for (size_t i=4; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"max() on {}\");\n  }\n\n  bool empty() const {\n    return !(vec[0] || vec[1] || vec[2] || vec[3]);\n  }\n};\n\nclass EmdeBoasTree {\n  using IndexType = unsigned long long;\n  static constexpr size_t TopHeight=5;\n\n  EmdeBoasTreeNode<TopHeight> *root;\n  size_t size_=0;\n\npublic:\n  EmdeBoasTree(): root(new EmdeBoasTreeNode<TopHeight>) {}\n\n  IndexType min() const { return root->min(); }\n  IndexType max() const { return root->max(); }\n  bool empty() const { return root->empty(); }\n  bool contains(IndexType u) const { return !empty() && root->contains(u); }\n  IndexType successor(IndexType u) const { return root->successor(u); }\n  IndexType predecessor(IndexType u) const { return root->predecessor(u); }\n  bool insert(IndexType u) { return root->insert(u) && ++size_; }\n  bool erase(IndexType u) { return !empty() && root->erase(u) && size_--; }\n  size_t size() const { return size_; }\n\n  void debug() const {\n    if (empty()) {\n      fprintf(stderr, \"{}\\n\");\n      return ;\n    }\n    fprintf(stderr, \"{\");\n    IndexType i_ub=max();\n    for (IndexType i=min(); i<i_ub; i=successor(i)) {\n      fprintf(stderr, \"%llu%s\", i, i<i_ub? \", \":\"\");\n      assert(contains(successor(i)));\n      assert(i < successor(i));\n    }\n\n    fprintf(stderr, \"%llu}\\n\", i_ub);\n    fflush(stderr);\n  }\n};\n\nint main() {\n  int q;\n  scanf(\"%d\", &q);\n\n  EmdeBoasTree veb;\n\n  for (int i=0; i<q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 0) {\n      /* insert */\n      int x;\n      scanf(\"%d\", &x);\n      veb.insert(x);\n      printf(\"%zu\\n\", veb.size());\n    } else if (t == 1) {\n      /* find */\n      int x;\n      scanf(\"%d\", &x);\n      printf(\"%d\\n\", veb.contains(x));\n    } else if (t == 2) {\n      /* delete */\n      int x;\n      scanf(\"%d\", &x);\n      veb.erase(x);\n    } else if (t == 3) {\n      /* dump */\n      unsigned long long l, r;\n      scanf(\"%llu %llu\", &l, &r);\n      if (veb.empty()) continue;\n      if (veb.max() < l) continue;\n\n      if (veb.contains(l))\n        printf(\"%llu\\n\", l);\n\n      r = std::min(r, veb.max());\n      while (l < r) {\n        l = veb.successor(l);\n        if (l > r) break;\n        printf(\"%llu\\n\", l);\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int q;\n    cin >> q;\n    set<int> se;\n    while(q--) {\n        int t, x;\n        cin >> t >> x;\n        if(t == 0) {\n            se.insert(x);\n            cout << se.size() << '\\n';\n        } else if(t == 1) {\n            auto itr = se.find(x);\n            cout << (itr != se.end()) << '\\n';\n        } else if(t == 2) {\n            se.erase(x);\n        } else {\n            int r;\n            cin >> r;\n            auto itr = se.lower_bound(x);\n            for(;*itr <= r and itr != se.end(); itr = next(itr)) {\n                cout << *itr << '\\n';\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} fast;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nlong long mod = 1000000007;\n#define REP(i, n) for (long long i = 0; i < (n); i++)\n#define rep(i, a, n) for (long long i = a; i < (n); i++)\nlong long modpow(long long m, long long n) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long long t = modpow(m, n / 2);\n        return (t * t) % mod;\n    } else {\n        return (modpow(m, n - 1) * m) % mod;\n    }\n}\nbool bitcheck(ll x, ll y) { return (x >> y) & 1; }\n\ntemplate <typename A, size_t N, typename T> void Fill(A (&array)[N], const T& val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\n// long long mod = 998244353;\nlong long power(long long m, long long n) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long long t = modpow(m, n / 2);\n        return t * t;\n    } else {\n        return modpow(m, n - 1) * m;\n    }\n}\n\nlong long moddiv(long long a, long long b) { return (a * modpow(b, mod - 2)) % mod; }\n\nconst ll INF = 1LL << 60;\n\nvoid print_binary(long long a) {\n    for (int i = 31; i >= 0; i--) {\n        cout << (a >> i & 1);\n    }\n    cout << endl;\n}\n\nll nCkmod(ll n, ll k) {\n    ll denomi = 1;\n    for (int i = n; i > n - k; i--) {\n        denomi *= i;\n        denomi %= mod;\n    }\n    ll numera = 1;\n    REP(i, k) {\n        numera *= (i + 1);\n        numera %= mod;\n    }\n    return moddiv(denomi, numera);\n}\nmap<ll, ll> cnt;\nvoid primeFactors(long long n) {\n    while (n % 2 == 0) {\n        cnt[2]++;\n        n = n / 2;\n    }\n    for (int i = 3; i <= sqrt(n); i = i + 2) {\n        while (n % i == 0) {\n            cnt[i]++;\n            n = n / i;\n        }\n    }\n    if (n > 2) {\n        cnt[n]++;\n    }\n}\nint main() {\n    ll q;\n    cin >> q;\n    set<ll> s;\n    REP(i, q) {\n        ll a, b;\n        cin >> a >> b;\n        if (a == 0) {\n            s.insert(b);\n            cout << s.size() << endl;\n        } else if (a == 1) {\n            cout << s.count(b) << endl;\n        } else if (a == 2) {\n            s.erase(b);\n        } else {\n            ll r;\n            cin >> r;\n            s.lower_bound(b);\n            auto it1 = s.lower_bound(b);\n            auto it2 = s.upper_bound(r);\n            for (auto it = it1; it != it2; it++) {\n                cout << *it << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint q;cin>>q;\n\n\tset<int> st;\n\tst.insert(1e9+1);\n\twhile(q--){\n\t\tint query,y;cin>>query>>y;\n\t\tif(query==0){\n\t\t\t// insert\n\t\t\tst.insert(y);\n\t\t\tcout<<(st.size()-1)<<endl;\n\t\t}else if(query==1){\n\t\t\tcout<<(st.find(y)!=st.end()?1:0)<<endl;\n\t\t}else if(query==2){\n\t\t\tst.erase(y);\n\t\t}else{\n\t\t\tint r;cin>>r;\n\t\t\tfor(auto it=st.lower_bound(y);it!=st.upper_bound(r);++it){\n\t\t\t\tcout<<*it<<endl;\n\t\t\t}\n\t\t}\n\t}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int num_query; scanf(\"%d\", &num_query);\n    int command, x, left, right;\n    set<int> S;\n    \n    for (int i = 0; i < num_query; ++i) {\n        scanf(\"%d\", &command);\n        int find_result = 0;\n        switch (command) {\n            case 0:\n                scanf(\"%d\", &x);\n                S.insert(x);\n                printf(\"%d\\n\", (int) S.size());\n                break;\n            case 1:\n                scanf(\"%d\", &x);\n                if (S.find(x) != S.end()) find_result = 1;\n                printf(\"%d\\n\", find_result);\n                break;\n            case 2:\n                scanf(\"%d\", &x);\n                S.erase(x);\n                break;\n            case 3:\n                scanf(\"%d%d\", &left, &right);\n                auto lower_itr = S.lower_bound(left);\n                auto upper_itr = S.upper_bound(right);\n                for (auto itr = lower_itr; itr != upper_itr; ++itr) printf(\"%d\\n\", *itr);\n                break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void) {\n\tset<int> S;\n\tint q, com, x, y;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> com;\n\t\tswitch (com) {\n\t\t\tcase 0:\n\t\t\t\tcin >> x;\n\t\t\t\tS.insert(x);\n\t\t\t\tcout << S.size() << endl;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcin >> x;\n\t\t\t\tif (S.find(x) != S.end()) {\n\t\t\t\t\tcout << \"1\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tcout << \"0\\n\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcin >> x;\n\t\t\t\tS.erase(x);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcin >> x >> y;\n\t\t\t\tint first;\n\t\t\t\tfor (int first = x; first <= y; first++) {\n\t\t\t\t\tif (S.find(first) != S.end())\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (first != y - 1) {\n\t\t\t\t\tset<int>::iterator it = S.lower_bound(x);\n\t\t\t\t\tset<int>::iterator end = S.upper_bound(y);\n\t\t\t\t\twhile (it != end) {\n\t\t\t\t\t\tcout << *it << endl;\n\t\t\t\t\t\tit++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int q, op, x, y;\n    set<int> s;\n\n    cin >> q;\n\n    while(q-- > 0){\n        cin >> op >> x;\n        if(op == 0){\n            s.insert(x);\n            cout << s.size() << endl;\n        }else if(op == 1){\n            cout << (s.find(x) != s.end()) << endl;\n        }else if(op == 2){\n            s.erase(x);\n        }else if(op == 3){\n            cin >> y;\n            auto l = s.lower_bound(x);\n            auto r = s.upper_bound(y);\n            for(; l != r; l++)  printf(\"%d\\n\", *l);\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#pragma GCC optimize (\"O0\")\n#else\n#pragma GCC optimize (\"O3\")\n#endif\n\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nusing ll = long long;\nconst int INF = 1e9 + 7;\nconst int MOD = INF;\nconst ll INF_LL = 1e18 + 7;\n\n#define __overload3(_1, _2, _3, name,...) name\n#define rep(...) __overload3(__VA_ARGS__, repFromUntil, repUntil, repeat)(__VA_ARGS__)\n#define repeat(times) repFromUntil(__name, 0, times)\n#define repUntil(name, times) repFromUntil(name, 0, times)\n#define repFromUntil(name, from, until) for (int name = from, name##__until = (until); name < name##__until; name++)\n#define repFromTo(name, from, to) repFromUntil(name, from, to + 1)\n#define repr(...) __overload3(__VA_ARGS__, reprFromUntil, reprUntil, repeat)(__VA_ARGS__)\n#define reprUntil(name, times) reprFromUntil(name, 0, times)\n#define reprFromUntil(name, from, until) for (int name = until - 1, name##__from = (from); name >= name##__from; name--)\n#define reprFromTo(name, from, to) reprFromUntil(name, from, to + 1)\n\n#define debugos OUT\n#ifdef LOCAL\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<newl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<newl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<newl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<newl;}}\n#else\n#define debug(v) {}\n#define debugv(v) {}\n#define debuga(m,w) {}\n#define debugaa(m,h,w) {}\n#endif\n\n#define newl \"\\n\"\n\n#define all(iter) begin(iter), end(iter)\n\n\ntemplate <class T> bool chmin(T& var, T x) {\n  if (var > x) {\n    var = x;\n    return true;\n  } else return false;\n}\ntemplate <class T> bool chmax(T& var, T x) {\n  if (var < x) {\n    var = x;\n    return true;\n  } else return false;\n}\n\nclass MyScanner {\n  public:\n    template<typename T> void input_integer(T& var) {\n        var = 0; T sign = 1;\n        int cc = getchar();\n        for (; cc<'0' || '9'<cc; cc = getchar())\n            if (cc == '-') sign = -1;\n        for (; '0' <= cc && cc <= '9'; cc = getchar())\n            var = (var << 3) + (var << 1) + cc - '0';\n        var = var * sign;\n    }\n    int c() { char c; while (c = getchar(), c == ' ' or c == '\\n'); return c; }\n    MyScanner& operator>>(char& var) { var = c(); return *this; }\n    MyScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n    MyScanner& operator>>(ll& var) { input_integer<ll>(var); return *this; }\n    MyScanner& operator>>(string& var) {\n        int cc = getchar();\n        for (; !isvisiblechar(cc); cc = getchar());\n        for (; isvisiblechar(cc); cc = getchar())\n            var.push_back(cc);\n        return *this;\n    }\n    operator int() {\n      int n;\n      *this >> n;\n      return n;\n    }\n    operator ll() {\n      ll n;\n      *this >> n;\n      return n;\n    }\n    private:\n      int isvisiblechar(int c) {\n        return 0x21 <= c && c <= 0x7E;\n      }\n};\nclass MyPrinter {\n  public:\n    template<typename T>\n    void output_integer(T var) {\n        if (var == 0) { putchar('0'); return; }\n        if (var < 0)\n            putchar('-'),\n            var = -var;\n        char stack[32]; int stack_p = 0;\n        while (var)\n            stack[stack_p++] = '0' + (var % 10),\n            var /= 10;\n        while (stack_p)\n            putchar(stack[--stack_p]);\n    }\n    MyPrinter& operator<<(char c) { putchar(c); return *this; }\n    template <typename T>\n    MyPrinter& operator<<(T var) { output_integer<T>(var); return *this; }\n    MyPrinter& operator<<(char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const string& str) {\n        const char* p = str.c_str();\n        const char* l = p + str.size();\n        while (p < l) putchar(*p++);\n        return *this;\n    }\n    // MyPrinter& operator<<(const modint& var) { output_integer<ll>(var.value); return *this; }\n    template <typename T>\n    void operator()(T x) {\n#ifdef LOCAL\n        *this << \"----- OUTPUT ----- > \";\n#endif\n        *this << x << newl;\n    }\n};\nMyScanner IN;\nMyPrinter OUT;\n\n\ntemplate <typename Iter>\nvoid dump(Iter s, Iter t) {\n#ifdef LOCAL\n        OUT << \"----- OUTPUT ----- > \";\n#endif\n  if (s == t) OUT << \"\\n\";\n  else {\n    for (; s != t; s++) {\n      OUT << *s << \" \\n\"[next(s, 1) == t];\n    }\n  }\n}\n\n\nint main() {\n  set<int> s;\n\n  int c, x, l, r;\n  rep(IN) {\n    IN >> c;\n    if (c == 0) {\n      IN >> x;\n      s.insert(x);\n      OUT(s.size());\n    } else if (c == 1) {\n      IN >> x;\n      OUT(s.count(x));\n    } else if (c == 2) {\n      IN >> x;\n      s.erase(x);\n    } else {\n      IN >> l >> r;\n      for_each(s.lower_bound(l), s.upper_bound(r), OUT);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\nusing namespace std;\n#ifndef FAST_IO\n #define IOS ios_base::sync_with_stdio(false);cin.tie(nullptr);\n#endif\n\n#define FILE_IO freopen(\"input.txt\",\"r\",stdin)\n#define int long long\n#define f first\n#define s second\n#define endl '\\n'\n#define all(c) c.begin(),c.end()\n#define bp __builtin_popcount\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e18;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>void print(T t){for(auto &it : t)cout<<it<<\" \";}\ninline int powerexp(int a, int b, int m = MOD){ int res = 1;while(b){if(b&1)res = res * a % m;a = a * a % m,b >>= 1;}return res % m;}\ninline int modinv(int a){ return powerexp(a,MOD-2,MOD);}\ninline int lcm(int a, int b){ int g = __gcd(a,b);return a/g*b;}\ninline int add(int x, int y){ x += y; if (x >= MOD) x -=  MOD; return x;}\ninline int mul(int x, int y){ return (x * 1ll * y) % MOD;}\ninline int sub(int x, int y){ x -= y; if (x<0) x += MOD; return x ;}\n\n//-------------------< start here >-------------------------// \n\nvoid solve(){\n   set<int> s;\n   int q;\n   cin >> q;\n   for(int i = 0; i < q; i++){\n\t  int cmd;\n\t  cin >> cmd;\n\t  if (cmd == 0){\n\t\t   int val;\n\t\t   cin >> val;\n\t\t   s.insert(val);\n\t\t   cout << (int)s.size() << endl;\n\t\t}\n      if (cmd == 1){\n\t\t  int val;\n\t\t  cin >> val;\n\t\t  if (s.find(val) == s.end()) cout << 0 << endl;\n\t\t  else cout << 1 << endl;  \n\t\t}\n\t  if (cmd == 2){\n\t\t  int val;\n\t\t  cin >> val;\n\t\t  s.erase(val);  \n\t\t}\n      if (cmd == 3){\n\t\t  int l, r;\n\t\t  cin >> l >> r;\n\t\t  auto it = s.lower_bound(l);\n\t\t  auto idx = s.upper_bound(r);\n\t\t  while(it != idx){\n\t\t\t   cout << *it << endl;\n\t\t\t   it++; \n\t\t\t }\n\t\t  }\n\t}   \n}\n\n//-----------------------------\n//comment from here for TOPCODER \nint32_t main(){\n   IOS;\n   solve();\n   //find();\n   #ifdef LOCAL_DEFINE\n   cerr << \"time elapsed \" << (double)clock()/CLOCKS_PER_SEC << endl;\n   #endif\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\nusing VULL = vector<ull>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst int NIL = -1;\n\ntemplate<class T, class S>\nbool chmax(T &a, const S &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T, class S>\nbool chmin(T &a, const S &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\nint main(){\n    set<int> S;\n    int q; cin >> q;\n    REP(i, q){\n        int op, x, y; cin >> op >> x;\n        switch(op){\n            case 0:\n                S.insert(x);\n                cout << S.size() << endl;\n                break;\n            case 1:\n                cout << noboolalpha << (S.find(x) != S.end()) << \"\\n\";\n                break;\n            case 2:\n                S.erase(x);\n                break;\n            case 3:\n                cin >> y;\n                for(auto itr = S.lower_bound(x); itr != S.end(); ++itr){\n                    if(x <= *itr && *itr <= y)\n                        cout << *itr << \"\\n\";\n                    if(y <= *itr)\n                        break;\n                }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <stdio.h>\nusing namespace std;\n\nint main()\n{\n    set<int> S;\n    int query, command, num, L, R;\n    \n    set<int>::iterator itr, itrL, itrR;\n    scanf(\"%d\", &query);\n\n    for (int i = 0; i < query; i++)\n    {\n        scanf(\"%d\", &command);\n        switch (command) {\n        case 0:\n            scanf(\"%d\", &num);\n            S.insert(num);\n\n            printf(\"%d\\n\", S.size());\n            break;\n        case 1:\n            scanf(\"%d\", &num);\n            itr = S.find(num);\n            if (itr == S.end())\n            {\n                printf(\"%d\\n\", 0);\n            }\n            else\n            {\n                printf(\"%d\\n\", 1);\n            }\n            break;\n        case 2:\n            \n            scanf(\"%d\", &num);\n            S.erase(num);\n            break;\n        case 3:\n            scanf(\"%d %d\", &L, &R);\n            itrL = S.lower_bound(L);\n            itrR = S.upper_bound(R);\n            for (itr = itrL; itr != itrR; itr++)\n            {\n                printf(\"%d\\n\", *itr);\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nset<int> s;\nusing namespace std;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\twhile(n--)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x == 0)\n\t\t{\n\t\t\ts.insert(y);\n\t\t\tprintf(\"%d\\n\",s.size());\n\t\t}\n\t\tif(x == 1) printf(\"%d\\n\",s.count(y));\n\t\tif(x == 2) s.erase(y);\n\t\tif(x == 3)\n\t\t{\n\t\t\tint l, r;\n\t\t\tl = y;\n\t\t\tscanf(\"%d\",&r);\n\t\t\tset<int>::iterator it, it2;\n\t\t\tit = s.lower_bound(l);\n\t\t\tit2 = s.upper_bound(r);\n\t\t\tfor(; it!=it2; it++) printf(\"%d\\n\",*it);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define all(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int q;\n  cin >> q;\n  set<int> st;\n  rep(_, q) {\n    int t, x, y;\n    cin >> t >> x;\n    switch (t) {\n    case 0:\n      st.insert(x);\n      cout << st.size() << '\\n';\n      break;\n    case 1:\n      cout << st.count(x) << '\\n';\n      break;\n    case 2:\n      st.erase(x);\n      break;\n    case 3:\n      cin >> y;\n      auto b = st.lower_bound(x), e = st.upper_bound(y);\n      for (auto it = b; it != e; ++it) cout << *it << '\\n';\n      break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n#define endl '\\n'\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    set<int> ss;\n    int q;\n    cin >> q;\n    while (q--) {\n        int t, x;\n        cin >> t >> x;\n        if (t == 1) {\n            cout << ss.count(x) << endl;\n        } else if (t == 0) {\n            ss.insert(x);\n            cout << ss.size() << endl;\n        } else if (t == 2) {\n            ss.erase(x);\n        } else {\n            int r;\n            cin >> r;\n            auto it = ss.lower_bound(x);\n            for (; it != ss.end(); it++) {\n                if (x <= *it && *it <= r) {\n                    cout << *it << endl;\n                }\n                if (*it > r) break;\n            }\n        }\n    } \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <set>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0');return m?-n:n;} //&&c<='9'\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n//_sc(string &s){int c;s=\"\";\n//\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n//_vo(string &s){for(char c:s)pcu(c);}\n//_vo(string s){for(char c:s)pcu(c);}\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n//_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nint main() {\n\tset<int> A;\n\tfor (int i = in(); i; i--)\n\t\tswitch(in()) {\n\t\tcase 0:\n\t\t\tA.insert(in());\n\t\t\toutl(A.size());\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\toutl(A.count(in()));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tA.erase(in());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tauto i = A.lower_bound(in()), e = A.upper_bound(in());\n\t\t\tfor (; i != e; i++)\n\t\t\t\toutl(*i);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define all(x) (x).begin(), (x).end()\n\nconst long long INFLL = 1LL << 60;\nconst int INFINT = 1 << 30;\nconst long long MOD = 1e9 + 7;\n\ntemplate <class T> void vecout(T V) {\n    auto t = V.begin();\n    while(t != V.end()) {\n        cout << *t++;\n        if(t != V.end()) cout << \" \";\n    }\n    cout << endl;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // int n;\n    // cin >> n;\n    set<int> s;\n    int q, a, b, c;\n    cin >> q;\n    rep(i, q) {\n        cin >> a >> b;\n        if(a == 0) {\n            s.insert(b);\n            cout << s.size() << \"\\n\";\n        } else if(a == 1) {\n            cout << (s.find(b) != s.end()) << \"\\n\";\n        } else if(a == 2) {\n            s.erase(b);\n        } else {\n            cin >> c;\n            auto p1 = s.equal_range(b);\n            auto p2 = s.equal_range(c);\n\n            while(p1.first != p2.second) {\n                cout << *p1.first++ << \"\\n\";\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<iostream>\n\nusing namespace std;\n\nint main() {\n    int T;\n    cin >> T;\n    set<int> s;\n    while (T--) {\n        int a;\n        cin >> a;\n        if (a == 0) {\n            int t;\n            cin >> t;\n            s.insert(t);\n            cout << s.size() << endl;\n        } else if (a == 1) {\n            int t;\n            cin >> t;\n            cout << (s.find(t) != s.end()) << endl;\n        } else if (a == 2) {\n            int t;\n            cin >> t;\n            s.erase(t);\n        } else {\n            int l, r;\n            cin >> l >> r;\n            auto it = s.lower_bound(l);\n            auto it1 = s.upper_bound(r);\n            for (; it != it1; it++) cout << *it << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n// #define DEBUG\n\nint main()\n{\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    int n, k, x, y;\n    cin >> n;\n    set<int> workspace;\n\n    for (int i = 0; i < n; i++)\n    {\n        cin >> k;\n        if (k == 0)\n        {\n            cin >> x;\n            workspace.insert(x);\n            cout << workspace.size() << \"\\n\";\n        }\n        else if (k == 1)\n        {\n            cin >> x;\n            auto z = workspace.find(x);\n            cout << ((z == workspace.end()) ? 0 : 1) << \"\\n\";\n        }\n        else if (k == 2)\n        {\n            cin >> x;\n            workspace.erase(x);\n        }\n        else if (k == 3)\n        {\n            cin >> x >> y;\n            for (auto itr = workspace.lower_bound(x); itr != workspace.upper_bound(y); itr++)\n                cout << *itr << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n// getline(cin,s);\n// a = strtok(s, \",\");  \",\"で分解\n// for (int i = 0; i < n; i++)\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include<vector>\n#include <algorithm>\n#include <queue>\n#include<string>\n#include <map>\n#include <cmath>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <set>\ntypedef long long ll;\ntypedef long double ld;\n\n\n#define REP(i,s,n)for(ll i=s;i<(n);++i)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nll S[1000] = { 0 };\nll N,M,Q;\n\n\nint main() {\n\tset<ll>A;\n\tcin >> Q;\n\trep(i, Q) {\n\t\tll a, b,c;\n\t\tcin >> a ;\n\t\tif (a==0) {\n\t\t\tcin >> b;\n\t\t\tA.insert(b);\n\t\t\tcout << A.size() << endl;\n\t\t}\n\t\telse if(a==1){\n\t\t\tcin >> b;\n\t\t\tif (A.find(b)!=A.end()) {\n\t\t\t\tcout << 1 << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 0 << endl;\n\t\t\t}\n\t\t}\n\t\telse if (a == 2) {\n\t\t\tcin >> b;\n\t\t\tA.erase(b);\n\t\t}\n\t\telse {\n\t\t\tcin >> b >> c;\n\t\t\tfor (set<ll>::iterator j = A.lower_bound(b); j != A.upper_bound(c); ++j) {\n\t\t\t\tcout << *j << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = 1LL<<55;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  set<int> S;\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int cmd, num;\n    cin>>cmd>>num;\n    if(cmd == 0){\n      S.insert(num);\n      cout<<S.size()<<endl;\n    }\n    if(cmd == 1){\n      cout<<S.count(num)<<endl;\n    }\n    if(cmd == 2){\n      S.erase(num);\n    }\n\n    if(cmd == 3){\n      int l = num, r;\n      cin>>r;\n      vector<int> ans;\n      auto start = S.lower_bound(l);\n      auto last= S.upper_bound(r);\n      for(auto it = start; it != last; it++) cout<<*it<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nint main() {\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tint q;\n\tstd::cin >> q;\n\tstd::set<int> set;\n\tint t, x;\n\tfor (int i = 0; i < q; ++i) {\n\t\tstd::cin >> t >> x;\n\t\tswitch (t) {\n\t\tcase 0: set.insert(x);\n\t\t\tstd::cout << set.size() << '\\n';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstd::cout << set.count(x) << '\\n';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tset.erase(x);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cin >> t;\n\t\t\tauto b = std::lower_bound(set.begin(), set.end(), x);\n\t\t\tfor (; x <= *b && *b <= t; ++b) {\n\t\t\t\tstd::cout << *b << '\\n';\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = long long;  // clang-format off\n#define REP_(i, a_, b_, a, b, ...) for (Int i = (a), lim##i = (b); i < lim##i; i++)\n#define REP(i, ...) REP_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\n#define ALL(v) std::begin(v), std::end(v)\nstruct SetupIO { SetupIO() { std::cin.tie(nullptr), std::ios::sync_with_stdio(false), std::cout << std::fixed << std::setprecision(13); } } setup_io;\n#ifndef dump\n#define dump(...)\n#endif  // clang-format on\n\n/**\n *    author:  knshnb\n *    created: Sun Jul 26 18:28:31 JST 2020\n **/\n\nsigned main() {\n    Int Q;\n    std::cin >> Q;\n    std::set<Int> s;\n    REP(q, Q) {\n        Int t, x;\n        std::cin >> t >> x;\n        if (t == 0) {\n            s.insert(x);\n            std::cout << s.size() << \"\\n\";\n        } else if (t == 1) {\n            std::cout << s.count(x) << \"\\n\";\n        } else if (t == 2) {\n            s.erase(x);\n        } else {\n            Int y;\n            std::cin >> y;\n            auto it1 = s.lower_bound(x);\n            auto it2 = s.upper_bound(y);\n            for (auto it = it1; it != it2; it++) {\n                std::cout << *it << \"\\n\";\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nint main()\n{\n    iostream::sync_with_stdio(0);\n    set<int>s;\n    int T,num=0;\n    cin>>T;\n    while(T--)\n    {\n        int flag,x;\n        cin>>flag>>x;\n        if(flag==0)\n        {\n            auto it=s.insert(x);\n            if(it.second==1)\n                num++;\n            cout<<num<<endl;\n        }\n        else if(flag==1)\n        {\n            auto it=s.find(x);\n            if(it==s.end())\n            {\n                cout<<0<<endl;\n            }\n            else cout<<1<<endl;\n        }\n        else if(flag==2)\n        {\n            int n=s.erase(x);\n            num-=n;\n        }\n        else\n        {\n            int R;\n            cin>>R;\n            for(auto it=s.lower_bound(x);it!=s.end()&&*it<=R;it++)\n            {\n\n                    cout<<*it<<endl;\n\n            }\n        }\n    }\n  //  cout << \"Hello world!\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <random>\n\n#define fprintf(...) void(0)\n\ntemplate <class T>\nclass RedBlackTree {\npublic:\n  struct Node {\n    Node *left=nullptr, *right=nullptr, *parent=nullptr;\n    T value;\n    enum Color { Red=false, Black=true } color=Red;\n    Node(T x): value(x) {}\n  } *root=nullptr;\n  size_t size_=0;\n\n  bool is_red(Node *node) const {\n    // NIL is black\n    return node != nullptr && node->color == Node::Red;\n  }\n\n  size_t black_height() const {\n    size_t res=0;\n    for (Node *cur=root; cur; cur=cur->left)\n      if (cur->color == Node::Black) ++res;\n\n    return res;\n  }\n\n  void left_rotate(Node *cur) {\n    Node *right=cur->right;\n    assert(right != nullptr);\n    cur->right = right->left;\n    if (right->left != nullptr)\n      right->left->parent = cur;\n    right->parent = cur->parent;\n    if (cur->parent == nullptr) {\n      root = right;\n    } else if (cur == cur->parent->left) {\n      cur->parent->left = right;\n    } else {\n      cur->parent->right = right;\n    }\n    right->left = cur;\n    cur->parent = right;\n  }\n\n  void right_rotate(Node *cur) {\n    Node *left=cur->left;\n    assert(left != nullptr);\n    cur->left = left->right;\n    if (left->right != nullptr)\n      left->right->parent = cur;\n    left->parent = cur->parent;\n    if (cur->parent == nullptr) {\n      root = left;\n    } else if (cur == cur->parent->right) {\n      cur->parent->right = left;\n    } else {\n      cur->parent->left = left;\n    }\n    left->right = cur;\n    cur->parent = left;\n  }\n\n  Node *successor(Node *cur) const {\n    if (cur->right != nullptr) {\n      cur = cur->right;\n      while (cur->left != nullptr)\n        cur = cur->left;\n\n      return cur;\n    }\n\n    while (true) {\n      if (cur->parent == nullptr) return nullptr;\n      if (cur == cur->parent->left)\n        return cur->parent;\n\n      cur = cur->parent;\n    }\n  }\n  \n  void insert_fixup(Node *cur) {\n    while (is_red(cur->parent)) {\n      Node *gparent=cur->parent->parent;\n      gparent || verify();\n      assert(gparent != nullptr);\n\n      Node *uncle=gparent->right;\n      bool mirrored=false;\n      if (cur->parent == uncle) {\n        uncle = gparent->left;\n        mirrored = true;\n      }\n      if (is_red(uncle)) {\n        cur->parent->color = uncle->color = Node::Black;\n        gparent->color = Node::Red;\n        cur = gparent;\n      } else {\n        if ((cur == cur->parent->right) ^ mirrored) {\n          cur = cur->parent;\n          mirrored? right_rotate(cur):left_rotate(cur);\n        }\n        cur->parent->color = Node::Black;\n        cur->parent->parent->color = Node::Red;\n        mirrored? left_rotate(gparent):right_rotate(gparent);\n      }\n    }\n    root->color = Node::Black;\n  }\n\n  void erase_fixup(Node *cur, Node *parent) {\n    while (cur != root && !is_red(cur)) {\n      Node *sibling=parent->right;\n      bool mirrored=false;\n      if (cur == sibling) {\n        sibling = parent->left;\n        mirrored = true;\n      }\n\n      if (is_red(sibling)) {\n        sibling->color = Node::Black;\n        parent->color = Node::Red;\n        mirrored? right_rotate(parent):left_rotate(parent);\n        sibling = (mirrored? parent->left:parent->right);\n      }\n\n      if (sibling && !is_red(sibling->left) && !is_red(sibling->right)) {\n        sibling->color = Node::Red;\n        cur = parent;\n        parent = cur->parent;\n      } else {\n        if (!mirrored) {\n          if (sibling && !is_red(sibling->right)) {\n            if (sibling->left != nullptr)\n              sibling->left->color = Node::Black;\n\n            sibling->color = Node::Red;\n            right_rotate(sibling);\n            sibling = parent->right;\n          }\n        } else {\n          if (sibling && !is_red(sibling->left)) {\n            if (sibling->right != nullptr)\n              sibling->right->color = Node::Black;\n\n            sibling->color = Node::Red;\n            left_rotate(sibling);\n            sibling = parent->left;\n          }\n        }\n        if (sibling) sibling->color = parent->color;\n        parent->color = Node::Black;\n        if (sibling)\n          (mirrored? sibling->left:sibling->right)->color = Node::Black;\n\n        mirrored? right_rotate(parent):left_rotate(parent);\n        cur = root;\n        parent = nullptr;\n      }\n    }\n    if (cur) cur->color = Node::Black;\n  }\n\npublic:\n  RedBlackTree() = default;\n\n  size_t size() const {\n    return size_;\n  }\n\n  bool insert(T x) {\n    if (root == nullptr) {\n      root = new Node(x);\n      root->color = Node::Black;\n      ++size_;\n      return true;\n    }\n\n    Node **child=&root, *parent=nullptr;\n    while (*child != nullptr) {\n      parent = *child;\n      if ((*child)->value > x) {\n        child = &(*child)->left;\n      } else if ((*child)->value < x) {\n        child = &(*child)->right;\n      } else {\n        return false;\n      }\n    }\n    *child = new Node(x);\n    ++size_;\n    (*child)->parent = parent;\n    insert_fixup(*child);\n    return true;\n  }\n\n  bool erase(T x) {\n    Node *cur=root;\n    while (cur != nullptr) {\n      if (cur->value > x) {\n        cur = cur->left;\n      } else if (cur->value < x) {\n        cur = cur->right;\n      } else {\n        break;\n      }\n    }\n    if (cur == nullptr) return false;\n\n    return erase(cur);\n  }\n\n  bool erase(Node *cur) {\n    if (cur == nullptr) return false;\n\n    --size_;\n    Node *y=cur;\n    if (cur->left != nullptr && cur->right != nullptr) y = successor(cur);\n    \n    assert(y != nullptr);\n    Node *x=y->left;\n    if (x == nullptr) x = y->right;\n\n    if (x != nullptr) x->parent = y->parent;\n    if (y->parent == nullptr) {\n      root = x;\n    } else if (y == y->parent->left) {\n      y->parent->left = x;\n    } else {\n      y->parent->right = x;\n    }\n\n    if (y != cur) {\n      cur->value = y->value;\n    }\n    if (y->color == Node::Black) {\n      erase_fixup(x, y->parent);\n    }\n    return true;\n  }\n\n  void join(RedBlackTree &oth, T x) {\n    join(oth, new Node(x));\n  }\n\n  void join(RedBlackTree &oth, Node *med) {\n    size_t bh1=black_height(), bh2=oth.black_height();\n    Node *cur;\n    if (bh1 >= bh2) {\n      cur = root;\n      while (bh1 > bh2) {\n        if (cur->color == Node::Black) {\n          if (bh1-- == bh2) break;\n        }\n        cur = cur->right;\n      }\n      med->left = cur;\n      med->right = oth.root;\n      med->parent = cur->parent;\n\n      if (med->parent == nullptr) {\n        root = med;\n        med->color = Node::Black;\n      } else {\n        med->parent->right = med;\n      }\n      cur->parent = med;\n      oth.root->parent = med;\n    } else {\n      cur = oth.root;\n      while (bh1 < bh2) {\n        if (cur->color == Node::Black) {\n          if (bh1 == bh2--) break;\n        }\n        cur = cur->left;\n      }\n      med->left = root;\n      med->right = cur;\n      med->parent = cur->parent;\n\n      med->parent->left = med;\n      cur->parent = med;\n      root->parent = med;\n\n      root = oth.root;\n    }\n\n    oth.root = nullptr;\n    size_ += oth.size_ + 1;\n    oth.size_ = 0;\n\n    insert_fixup(med);\n  }\n\n  bool contains(T x) const {\n    Node *cur=root;\n    while (cur != nullptr) {\n      if (cur->value < x) {\n        cur = cur->right;\n      } else if (cur->value > x) {\n        cur = cur->left;\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  Node *lower_bound(T x) const {\n    Node *cur=root, *prev=nullptr;\n    while (cur != nullptr) {\n      prev = cur;\n      if (cur->value > x) {\n        cur = cur->left;\n      } else if (cur->value < x) {\n        cur = cur->right;\n      } else {\n        return cur;\n      }\n    }\n    if (prev && prev->value < x) prev = successor(prev);\n    return prev;\n  }\n\n  bool verify() const {\n    if (root == nullptr) return true;\n\n    bool violated=false;\n    if (root->color == Node::Red) {\n      violated = true;\n      fprintf(stderr, \"root node is red\\n\");\n    }\n    \n    bool reached=false;\n    size_t bheight=-1;\n    std::function<void (Node *, int, size_t)> dfs=[&](\n        Node *subroot, int depth, size_t bh) {\n\n      if (subroot->color == Node::Red) {\n        if (subroot->parent && subroot->parent->color == Node::Red) {\n          violated = true;\n          fprintf(stderr, \"two red nodes are connected\\n\");\n        }\n      } else {\n        ++bh;\n      }\n\n      if (subroot->left == nullptr || subroot->right == nullptr) {\n        if (!reached) {\n          bheight = bh;\n          reached = true;\n        } else if (bheight != bh) {\n          violated = true;\n          fprintf(stderr, \"different number of black nodes in two root-leaf paths\\n\");\n        }\n      }\n\n      if (subroot->right != nullptr)\n        dfs(subroot->right, depth+1, bh);\n\n      fprintf(\n          stderr, \"%s%*s%d%s (%zu) %c\\n\",\n          (subroot->color == Node::Red)? \"\\x1b[31;1m\":\"\\x1b[37;1m\",\n          depth*2+2, \"  \", subroot->value, \"\\x1b[0m\", bh,\n          (subroot->left&&subroot->right)? ' ':'*');\n\n      if (subroot->left != nullptr)\n        dfs(subroot->left, depth+1, bh);\n    };\n    fprintf(stderr, \"================================================\\n\");\n    dfs(root, 0, 0);\n    fprintf(stderr, \"================================================\\n\");\n    return !violated;\n  }\n};\n\nint main() {\n  RedBlackTree<int> rbt;\n\n  int q;\n  scanf(\"%d\", &q);\n\n  for (int i=0; i<q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 0) {\n      int x;\n      scanf(\"%d\", &x);\n      rbt.insert(x);\n      printf(\"%zu\\n\", rbt.size());\n    } else if (t == 1) {\n      int x;\n      scanf(\"%d\", &x);\n      printf(\"%d\\n\", rbt.contains(x));\n    } else if (t == 2) {\n      int x;\n      scanf(\"%d\", &x);\n      rbt.erase(x);\n    } else if (t == 3) {\n      int L, R;\n      scanf(\"%d %d\", &L, &R);\n      auto node=rbt.lower_bound(L);\n      while (node != nullptr) {\n        if (node->value > R) break;\n        printf(\"%d\\n\", node->value);\n        node = rbt.successor(node);\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <map>\n\nclass EmdeBoasTree;\n\ntemplate <size_t Height>\nclass EmdeBoasTreeNode {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<Height+1>;\n  using IndexType = unsigned long long;\n  static constexpr int HALF_WIDTH=1<<(Height-1);\n\n  IndexType min_=1, max_=0;\n  EmdeBoasTreeNode<Height-1> *summary=nullptr;\n  std::map<IndexType, EmdeBoasTreeNode<Height-1>> cluster={};\n\n  EmdeBoasTreeNode() = default;\n\n  constexpr IndexType upper(IndexType u) const {\n    return u >> HALF_WIDTH;\n  }\n\n  constexpr IndexType lower(IndexType u) const {\n    return u & ((IndexType(1) << HALF_WIDTH) - 1);\n  }\n\n  bool contains(IndexType u) const {\n    if (u == min_ || u == max_) return true;\n    if (u < min_ || max_ < u) return false;\n    if (summary == nullptr || !summary->contains(upper(u))) return false;\n    assert(cluster.find(upper(u)) != cluster.end());\n    return cluster.at(upper(u)).contains(lower(u));\n  }\n\n  IndexType successor(IndexType u) const {\n    if (empty() || u >= max_) throw std::out_of_range(\"no successor\");\n    if (u < min_) return min_;\n    if (summary == nullptr) return max_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu < cluster.at(uu).max())\n      return uu << HALF_WIDTH | cluster.at(uu).successor(lu);\n\n    if (uu >= summary->max()) return max_;\n    IndexType bucket=summary->successor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).min();\n  }\n\n  IndexType predecessor(IndexType u) const {\n    if (empty() || u <= min_) throw std::out_of_range(\"no predecessor\");\n    if (u > max_) return max_;\n    if (summary == nullptr) return min_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu > cluster.at(uu).min())\n      return uu << HALF_WIDTH | cluster.at(uu).predecessor(lu);\n\n    if (uu <= summary->min()) return min_;\n    IndexType bucket=summary->predecessor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).max();\n  }\n\n  bool insert(IndexType u) {\n    if (empty()) {\n      min_ = max_ = u;\n      return true;\n    }\n    if (u == min_ || u == max_) return false;\n\n    if (min_ == max_) {\n      if (max_ < u) {\n        max_ = u;\n        return true;\n      }\n      min_ = u;\n      return true;\n    }\n\n    if (min_ > u) {\n      std::swap(min_, u);\n    } else if (max_ < u) {\n      std::swap(max_, u);\n    }\n\n    if (summary == nullptr) summary = new EmdeBoasTreeNode<Height-1>;\n    summary->insert(upper(u));\n\n    auto it=cluster.lower_bound(upper(u));\n    if (it == cluster.end() || it->first != upper(u))\n      it = cluster.emplace_hint(it, upper(u), EmdeBoasTreeNode<Height-1>());\n\n    return it->second.insert(lower(u));\n  }\n\n  bool erase(IndexType u) {\n    if (min_ == max_) {\n      if (min_ == u) {\n        min_ = 1;\n        max_ = 0;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    if (u < min_ || max_ < u) return false;\n\n    if (summary == nullptr) {\n      if (u == min_) {\n        min_ = max_;\n        return true;\n      } else if (u == max_) {\n        max_ = min_;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    IndexType bucket=upper(u), v=lower(u);\n    if (u == min_) {\n      bucket = summary->min();\n      v = cluster.at(bucket).min();\n      min_ = bucket << HALF_WIDTH | v;\n    } else if (u == max_) {\n      bucket = summary->max();\n      v = cluster.at(bucket).max();\n      max_ = bucket << HALF_WIDTH | v;\n    } else {\n      if (!summary->contains(bucket)) return false;\n    }\n    bool res=cluster.at(bucket).erase(v);\n    if (res && cluster.at(bucket).empty()) {\n      cluster.erase(bucket);\n      summary->erase(bucket);\n      if (summary->empty()) {\n        delete summary;\n        summary = nullptr;\n      }\n    }\n    return res;\n  }\n\n  IndexType min() const {\n    if (empty()) throw std::out_of_range(\"min() on {}\");\n    return min_;\n  }\n\n  IndexType max() const {\n    if (empty()) throw std::out_of_range(\"max() on {}\");\n    return max_;\n  }\n\n  bool empty() const {\n    return max_ < min_;\n  }\n};\n\ntemplate <>\nclass EmdeBoasTreeNode<3> {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<4>;\n  using IndexType = unsigned long long;\n\n  IndexType vec[4]={};\n\n  EmdeBoasTreeNode() = default;\n\n  bool contains(IndexType u) const {\n    return vec[u/64] >> (u%64) & 1;\n  }\n\n  IndexType successor(IndexType u) const {\n    IndexType tmp=vec[u/64]&-(1uLL<<((u+1)%64));\n    if (tmp > 0) return (u/64*64) | __builtin_ctzll(tmp);\n    for (size_t i=u/64+1; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"u <= minimum\");\n  }\n\n  IndexType predecessor(IndexType u) const {\n    IndexType tmp=vec[u/64]&((1uLL<<(u%64))-1);\n    if (tmp > 0) return (u/64*64) | (63-__builtin_clzll(tmp));\n    for (size_t i=u/64; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"u >= maximum\");\n  }\n\n  bool insert(IndexType u) {\n    if (vec[u/64] >> (u%64) & 1) return false;\n    vec[u/64] |= 1uLL << (u%64);\n    return true;\n  }\n\n  bool erase(IndexType u) {\n    if (!(vec[u/64] >> (u%64) & 1)) return false;\n    vec[u/64] ^= 1uLL << (u%64);\n    return true;\n  }\n\n  IndexType min() const {\n    for (int i=0; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"min() on {}\");\n  }\n\n  IndexType max() const {\n    for (size_t i=4; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"max() on {}\");\n  }\n\n  bool empty() const {\n    return !(vec[0] || vec[1] || vec[2] || vec[3]);\n  }\n};\n\nclass EmdeBoasTree {\n  using IndexType = unsigned long long;\n  static constexpr size_t TopHeight=5;\n\n  EmdeBoasTreeNode<TopHeight> *root;\n  size_t size_=0;\n\npublic:\n  EmdeBoasTree(): root(new EmdeBoasTreeNode<TopHeight>) {}\n\n  IndexType min() const { return root->min(); }\n  IndexType max() const { return root->max(); }\n  bool empty() const { return root->empty(); }\n  bool contains(IndexType u) const { return !empty() && root->contains(u); }\n  IndexType successor(IndexType u) const { return root->successor(u); }\n  IndexType predecessor(IndexType u) const { return root->predecessor(u); }\n  bool insert(IndexType u) { return root->insert(u) && ++size_; }\n  bool erase(IndexType u) { return !empty() && root->erase(u) && size_--; }\n  size_t size() const { return size_; }\n\n  void debug() const {\n    if (empty()) {\n      fprintf(stderr, \"{}\\n\");\n      return ;\n    }\n    fprintf(stderr, \"{\");\n    IndexType i_ub=max();\n    for (IndexType i=min(); i<i_ub; i=successor(i)) {\n      fprintf(stderr, \"%llu%s\", i, i<i_ub? \", \":\"\");\n      assert(contains(successor(i)));\n      assert(i < successor(i));\n    }\n\n    fprintf(stderr, \"%llu}\\n\", i_ub);\n    fflush(stderr);\n  }\n};\n\nint main() {\n  int q;\n  scanf(\"%d\", &q);\n\n  EmdeBoasTree veb;\n\n  for (int i=0; i<q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 0) {\n      /* insert */\n      int x;\n      scanf(\"%d\", &x);\n      veb.insert(x);\n      printf(\"%zu\\n\", veb.size());\n    } else if (t == 1) {\n      /* find */\n      int x;\n      scanf(\"%d\", &x);\n      printf(\"%d\\n\", veb.contains(x));\n    } else if (t == 2) {\n      /* delete */\n      int x;\n      scanf(\"%d\", &x);\n      veb.erase(x);\n    } else if (t == 3) {\n      /* dump */\n      unsigned long long l, r;\n      scanf(\"%llu %llu\", &l, &r);\n      if (veb.max() < l) continue;\n\n      if (veb.contains(l))\n        printf(\"%llu\\n\", l);\n\n      r = std::min(r, veb.max());\n      do {\n        l = veb.successor(l);\n        printf(\"%llu\\n\", l);\n      } while (l < r);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n/**\n *      purpose : \n *      author  : kyomukyomupurin\n *      created : \n**/\n\n// input/output\n#include <iostream>\n#include <fstream>\n#include <sstream>\n// container class\n#include <array>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n// math, algorithm\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <numeric>\n// etc\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cstring>\n#include <chrono>\n#include <iomanip>\n#include <random>\n#include <utility>\n// using-directive\nusing namespace std;\n// alias template\nusing int64 = long long;\nusing vi = vector<int>;\nusing vl = vector<int64>;\nusing pii = pair<int, int>;\nusing pll = pair<int64, int64>;\n// text macro replacement\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define print(x) cout << (x) << '\\n'\n#define debug(x) cerr << #x << \": \" << (x) << '\\n'\n#define dbg(v) for (size_t _ = 0; _ < v.size(); ++_){cerr << #v << \"[\" << _ << \"] : \" << v[_] << '\\n';}\n// variadic template\ntemplate<typename T> inline void chmin(T &a, T b) {if (a > b) a = b; return;}\ntemplate<typename T> inline void chmax(T &a, T b) {if (a < b) a = b; return;}\n// constant\nconst int INF = (1<<30) - 1;\nconst int64 INF64 = (1LL<<62) - 1;\nconst int MOD = 1000000007;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  set<int> st;\n  int query; cin >> query;\n\n  for (int i = 0; i < query; ++i) {\n    int op, x; cin >> op >> x;\n    if (op == 0) {\n      st.insert(x);\n      cout << st.size() << '\\n';\n    } else if (op == 1) {\n      cout << (st.find(x) != st.end()) << '\\n';\n    } else if (op == 2) {\n      st.erase(x);\n    } else {\n      int r; cin >> r;\n      auto it1 = st.lower_bound(x);\n      auto it2 = st.upper_bound(r);\n\n      for (auto it = it1; it != it2; ++it) {\n        cout << *it << '\\n';\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n\nint main()\n{\n    int n, q, x, y;\n\n    set<int> a;\n\n    cin >> n;\n\n    for( int i = 0; i < n; i++ )\n    {\n        cin >> q >> x;\n        if( q == 0 )\n        {\n            a.insert(x);\n            cout << a.size() << endl;\n        }\n        else if( q == 1 )\n            cout << a.count(x) << endl;                 //countという、指定された値の個数を返す関数もある。setは重複を許さないので0 or 1が返る。\n        else if( q == 2 )\n            a.erase(x);\n        else\n        {\n            cin >> y;\n\n            if( a.size() != 0 )\n            {\n                set<int>::iterator itr1 = a.end(), itr2 = a.end();\n                while( itr1 == a.end() && x <= y )\n                {\n                    itr1 = a.find(x);\n                    x++;\n                }\n\n                if( itr1 != a.end() )\n                {\n                    while( itr2 == a.end() )\n                    {\n                        itr2 = a.find(y);\n                        y--;\n                    }\n                    itr2++;\n                    for(; itr1 != itr2; itr1++ )\n                        cout << *itr1 << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll inf = 1ll << 60;\nconst ll mod = (ll)1e9 + 7;\n\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\n#define print(s) cout << s;\n#define println(s) cout << s << endl;\n#define printd(s, f) cout << fixed << setprecision(f) << s << endl;\n\n\nint main()\n{\n\tll n;\n\tcin >> n;\n\n\tset<ll> a;\n\tfor (ll i = 0; i < n; i++)\n\t{\n\t\tll q, x;\n\t\tcin >> q;\n\n\t\tswitch (q)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tcin >> x;\n\t\t\t\ta.insert(x);\n\t\t\t\tprintln(a.size());\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tcin >> x;\n\t\t\t\tif (a.count(x))\n\t\t\t\t{\n\t\t\t\t\tprintln(1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintln(0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcin >> x;\n\t\t\t\ta.erase(x);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tll l, r;\n\t\t\t\tcin >> l >> r;\n\n\t\t\t\tfor (auto it = a.equal_range(l).first; it != a.equal_range(r).second; it++)\n\t\t\t\t{\n\t\t\t\t\tprintln(*it);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main(void) {\n    int q{};\n    std::cin >> q;\n\n    std::set<int> my_set{};\n    for (int i = 0; i < q; ++i) {\n        int kind{};\n        std::cin >> kind;\n\n        int x{};\n        switch (kind) {\n            case 0:\n                /// insert\n                std::cin >> x;\n                my_set.insert(x);\n                std::cout << my_set.size() << std::endl;\n                break;\n            case 1:\n                /// find\n                std::cin >> x;\n                if (my_set.find(x) != my_set.end())\n                    std::cout << 1 << std::endl;\n                else\n                    std::cout << 0 << std::endl;\n\n                break;\n            case 2:\n                /// delete\n                std::cin >> x;\n                my_set.erase(x);\n                break;\n            case 3:\n                /// dump\n                int l{}, r{};\n                std::cin >> l >> r;\n                auto iter_begin = my_set.lower_bound(l);\n                auto iter_end = my_set.upper_bound(r);\n                for (auto iter = iter_begin; iter != iter_end; ++iter)\n                    std::cout << *iter << std::endl;\n\n                break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n//#include <boost/foreach.hpp>\n//#include <boost/range/algorithm.hpp>\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define ll long long\n#define Sort(v) sort(all(v))\n#define INF 1000000000\n#define END return 0\n#define pb push_back\n#define se second\n#define fi first\n#define pb push_back\n#define all(v) (v).begin() , (v).end()\n#define MP make_pair\n#define MOD 1000000007LL\nusing namespace std;\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n\nint main (){\n    int q;cin>>q;\n    set<int> st;\n    rep(i,0,q){\n        int a,b;cin>>a>>b;\n        if(a==0){\n            st.insert(b);\n            cout<<st.size()<<endl;\n        }else if(a==1){\n            cout<<((st.find(b)==st.end())?0:1)<<endl;\n        }else if(a==2){\n            st.erase(b);\n        }else {\n            int r;cin>>r;\n            auto it=lower_bound(all(st),b);\n            for(;it!=st.end()&&*it<=r;it++){\n                cout<<*it<<endl;\n            }\n            \n        }\n    }\n    \n    \n}\n\n\n\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\nint main() {\n  set<int> s;\n  int q, x;\n  cin >> q; // skip n\n  while (cin >> q >> x) {\n    if (q == 0) {\n      s.insert(x);\n      cout << s.size() << endl;\n    }\n    if (q == 1)\n      cout << s.count(x) << endl;\n    if (q == 2)\n      s.erase(x);\n    if (q == 3) {\n      int r;\n      cin >> r;\n      auto li = s.lower_bound(x);\n      auto ri = s.lower_bound(r + 1);\n      while (li != ri)\n        cout << *(li++) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vecll = vector<long long>;\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (long long i = 0; i < (long long)(n); i++)\n\nint main()\n{\n    ll q, que, x, y;\n    set<ll> S;\n    cin >> q;\n\n    rep(i, q)\n    {\n        cin >> que >> x;\n        if (que == 0)\n            S.insert(x);\n        else if (que == 2)\n        {\n            S.erase(x);\n            continue;\n        }\n        else if (que == 3)\n        {\n            cin >> y;\n            //delctype(S)\n            set<ll>::iterator first_itr = S.lower_bound(x);\n            set<ll>::iterator end_itr = S.upper_bound(y);\n\n            for (auto i = first_itr; i != end_itr; ++i)\n                cout << *i << endl;\n\n            /*for (int i = x; i <= y; i++)\n            {\n                if (S.find(i) != S.end())\n                {\n                    cout << *S.find(i) << endl;\n                }\n            }*/\n\n                /*for(struct { ll i; int j;} s = { x, 0} ; s.i <= y ; ++s.i , ++s.j)\n            {\n                if (S.find(s.i) != S.end())\n                {\n                    //cout << (s.j ? \" \" : \"\");\n                    cout << *S.find(s.i) << endl;\n                }\n            }*/\n                continue;\n        }\n\n        cout << (que ? S.count(x) : S.size()) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <map>\n\nclass EmdeBoasTree;\n\ntemplate <size_t Height>\nclass EmdeBoasTreeNode {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<Height+1>;\n  using IndexType = unsigned long long;\n  static constexpr int HALF_WIDTH=1<<(Height-1);\n\n  IndexType min_=1, max_=0;\n  EmdeBoasTreeNode<Height-1> *summary=nullptr;\n  std::map<IndexType, EmdeBoasTreeNode<Height-1>> cluster={};\n\n  EmdeBoasTreeNode() = default;\n\n  constexpr IndexType upper(IndexType u) const {\n    return u >> HALF_WIDTH;\n  }\n\n  constexpr IndexType lower(IndexType u) const {\n    return u & ((IndexType(1) << HALF_WIDTH) - 1);\n  }\n\n  bool contains(IndexType u) const {\n    if (u == min_ || u == max_) return true;\n    if (u < min_ || max_ < u) return false;\n    if (summary == nullptr || !summary->contains(upper(u))) return false;\n    assert(cluster.find(upper(u)) != cluster.end());\n    return cluster.at(upper(u)).contains(lower(u));\n  }\n\n  IndexType successor(IndexType u) const {\n    if (empty() || u >= max_) throw std::out_of_range(\"no successor\");\n    if (u < min_) return min_;\n    if (summary == nullptr) return max_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu < cluster.at(uu).max())\n      return uu << HALF_WIDTH | cluster.at(uu).successor(lu);\n\n    if (uu >= summary->max()) return max_;\n    IndexType bucket=summary->successor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).min();\n  }\n\n  IndexType predecessor(IndexType u) const {\n    if (empty() || u <= min_) throw std::out_of_range(\"no predecessor\");\n    if (u > max_) return max_;\n    if (summary == nullptr) return min_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu > cluster.at(uu).min())\n      return uu << HALF_WIDTH | cluster.at(uu).predecessor(lu);\n\n    if (uu <= summary->min()) return min_;\n    IndexType bucket=summary->predecessor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).max();\n  }\n\n  bool insert(IndexType u) {\n    if (empty()) {\n      min_ = max_ = u;\n      return true;\n    }\n    if (u == min_ || u == max_) return false;\n\n    if (min_ == max_) {\n      if (max_ < u) {\n        max_ = u;\n        return true;\n      }\n      min_ = u;\n      return true;\n    }\n\n    if (min_ > u) {\n      std::swap(min_, u);\n    } else if (max_ < u) {\n      std::swap(max_, u);\n    }\n\n    if (summary == nullptr) summary = new EmdeBoasTreeNode<Height-1>;\n    summary->insert(upper(u));\n\n    auto it=cluster.lower_bound(upper(u));\n    if (it == cluster.end() || it->first != upper(u))\n      it = cluster.emplace_hint(it, upper(u), EmdeBoasTreeNode<Height-1>());\n\n    return it->second.insert(lower(u));\n  }\n\n  bool erase(IndexType u) {\n    if (min_ == max_) {\n      if (min_ == u) {\n        min_ = 1;\n        max_ = 0;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    if (u < min_ || max_ < u) return false;\n\n    if (summary == nullptr) {\n      if (u == min_) {\n        min_ = max_;\n        return true;\n      } else if (u == max_) {\n        max_ = min_;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    IndexType bucket=upper(u), v=lower(u);\n    if (u == min_) {\n      bucket = summary->min();\n      v = cluster.at(bucket).min();\n      min_ = bucket << HALF_WIDTH | v;\n    } else if (u == max_) {\n      bucket = summary->max();\n      v = cluster.at(bucket).max();\n      max_ = bucket << HALF_WIDTH | v;\n    } else {\n      if (!summary->contains(bucket)) return false;\n    }\n    bool res=cluster.at(bucket).erase(v);\n    if (res && cluster.at(bucket).empty()) {\n      cluster.erase(bucket);\n      summary->erase(bucket);\n      if (summary->empty()) {\n        delete summary;\n        summary = nullptr;\n      }\n    }\n    return res;\n  }\n\n  IndexType min() const {\n    if (empty()) throw std::out_of_range(\"min() on {}\");\n    return min_;\n  }\n\n  IndexType max() const {\n    if (empty()) throw std::out_of_range(\"max() on {}\");\n    return max_;\n  }\n\n  bool empty() const {\n    return max_ < min_;\n  }\n};\n\ntemplate <>\nclass EmdeBoasTreeNode<3> {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<4>;\n  using IndexType = unsigned long long;\n\n  IndexType vec[4]={};\n\n  EmdeBoasTreeNode() = default;\n\n  bool contains(IndexType u) const {\n    return vec[u/64] >> (u%64) & 1;\n  }\n\n  IndexType successor(IndexType u) const {\n    IndexType tmp=vec[u/64]&~((1uLL<<((u+1)%64))-1);\n    if (u % 64 < 63 && tmp > 0) return (u/64*64) | __builtin_ctzll(tmp);\n    for (size_t i=u/64+1; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"u <= minimum\");\n  }\n\n  IndexType predecessor(IndexType u) const {\n    IndexType tmp=vec[u/64]&((1uLL<<(u%64))-1);\n    if (tmp > 0) return (u/64*64) | (63-__builtin_clzll(tmp));\n    for (size_t i=u/64; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"u >= maximum\");\n  }\n\n  bool insert(IndexType u) {\n    if (vec[u/64] >> (u%64) & 1) return false;\n    vec[u/64] |= 1uLL << (u%64);\n    return true;\n  }\n\n  bool erase(IndexType u) {\n    if (!(vec[u/64] >> (u%64) & 1)) return false;\n    vec[u/64] ^= 1uLL << (u%64);\n    return true;\n  }\n\n  IndexType min() const {\n    for (int i=0; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"min() on {}\");\n  }\n\n  IndexType max() const {\n    for (size_t i=4; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"max() on {}\");\n  }\n\n  bool empty() const {\n    return !(vec[0] || vec[1] || vec[2] || vec[3]);\n  }\n};\n\nclass EmdeBoasTree {\n  using IndexType = unsigned long long;\n  static constexpr size_t TopHeight=5;\n\n  EmdeBoasTreeNode<TopHeight> *root;\n  size_t size_=0;\n\npublic:\n  EmdeBoasTree(): root(new EmdeBoasTreeNode<TopHeight>) {}\n\n  IndexType min() const { return root->min(); }\n  IndexType max() const { return root->max(); }\n  bool empty() const { return root->empty(); }\n  bool contains(IndexType u) const { return !empty() && root->contains(u); }\n  IndexType successor(IndexType u) const { return root->successor(u); }\n  IndexType predecessor(IndexType u) const { return root->predecessor(u); }\n  bool insert(IndexType u) { return root->insert(u) && ++size_; }\n  bool erase(IndexType u) { return !empty() && root->erase(u) && size_--; }\n  size_t size() const { return size_; }\n\n  void debug() const {\n    if (empty()) {\n      fprintf(stderr, \"{}\\n\");\n      return ;\n    }\n    fprintf(stderr, \"{\");\n    IndexType i_ub=max();\n    for (IndexType i=min(); i<i_ub; i=successor(i)) {\n      fprintf(stderr, \"%llu%s\", i, i<i_ub? \", \":\"\");\n      assert(contains(successor(i)));\n      assert(i < successor(i));\n    }\n\n    fprintf(stderr, \"%llu}\\n\", i_ub);\n    fflush(stderr);\n  }\n};\n\nint main() {\n  int q;\n  scanf(\"%d\", &q);\n\n  EmdeBoasTree veb;\n\n  for (int i=0; i<q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 0) {\n      /* insert */\n      int x;\n      scanf(\"%d\", &x);\n      veb.insert(x);\n      printf(\"%zu\\n\", veb.size());\n    } else if (t == 1) {\n      /* find */\n      int x;\n      scanf(\"%d\", &x);\n      printf(\"%d\\n\", veb.contains(x));\n    } else if (t == 2) {\n      /* delete */\n      int x;\n      scanf(\"%d\", &x);\n      veb.erase(x);\n    } else if (t == 3) {\n      /* dump */\n      unsigned long long l, r;\n      scanf(\"%llu %llu\", &l, &r);\n      if (veb.empty()) continue;\n      if (veb.max() < l) continue;\n\n      if (veb.contains(l))\n        printf(\"%llu\\n\", l);\n\n      r = std::min(r, veb.max());\n      while (l < r) {\n        l = veb.successor(l);\n        if (l > r) break;\n        printf(\"%llu\\n\", l);\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tset<long long> s;\t\n\tlong q;\n\n\tcin >> q;\n\n\tfor (long i = 0; i < q; i++) {\n\t\tint t;\n\t\tlong long x;\n\t\tcin >> t >> x;\n\n\t\tif (t == 0) {\n\t\t\ts.insert(x);\n\t\t\tcout << s.size() << endl;\n\t\t}\n\t\telse if (t == 1) {\n\t\t\tint f = 1;\n\t\t\tif (s.find(x) == s.end())\n\t\t\t\tf = 0;\n\t\t\tcout << f << endl;\n\t\t}\n\t\telse if (t == 2)\n\t\t\ts.erase(x);\n\t\telse if (t == 3) {\n\t\t\tlong long y;\n\t\t\tstd::set<long long>::iterator it;\n\n\t\t\tcin >> y;\n\n\t\t\tfor (it = s.lower_bound(x); it != s.upper_bound(y); it++)\n\t\t\t\tcout << *it << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <map>\n#include <vector>\n\nclass EmdeBoasTree;\n\ntemplate <size_t Height>\nclass EmdeBoasTreeNode {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<Height+1>;\n  using IndexType = unsigned long long;\n  static constexpr int HALF_WIDTH=1<<(Height-1);\n\n  IndexType min_=1, max_=0;\n  EmdeBoasTreeNode<Height-1> *summary=nullptr;\n  std::map<IndexType, EmdeBoasTreeNode<Height-1>> cluster={};\n\n  EmdeBoasTreeNode() = default;\n\n  constexpr IndexType upper(IndexType u) const {\n    return u >> HALF_WIDTH;\n  }\n\n  constexpr IndexType lower(IndexType u) const {\n    return u & ((IndexType(1) << HALF_WIDTH) - 1);\n  }\n\n  bool contains(IndexType u) const {\n    if (u == min_ || u == max_) return true;\n    if (u < min_ || max_ < u) return false;\n    if (summary == nullptr || !summary->contains(upper(u))) return false;\n    assert(cluster.find(upper(u)) != cluster.end());\n    return cluster.at(upper(u)).contains(lower(u));\n  }\n\n  IndexType successor(IndexType u) const {\n    if (empty() || u >= max_) throw std::out_of_range(\"no successor\");\n    if (u < min_) return min_;\n    if (summary == nullptr) return max_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu < cluster.at(uu).max())\n      return uu << HALF_WIDTH | cluster.at(uu).successor(lu);\n\n    if (uu >= summary->max()) return max_;\n    IndexType bucket=summary->successor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).min();\n  }\n\n  IndexType predecessor(IndexType u) const {\n    if (empty() || u <= min_) throw std::out_of_range(\"no predecessor\");\n    if (u > max_) return max_;\n    if (summary == nullptr) return min_;\n\n    IndexType uu=upper(u), lu=lower(u);\n    if (summary->contains(uu) && lu > cluster.at(uu).min())\n      return uu << HALF_WIDTH | cluster.at(uu).predecessor(lu);\n\n    if (uu <= summary->min()) return min_;\n    IndexType bucket=summary->predecessor(uu);\n    return bucket << HALF_WIDTH | cluster.at(bucket).max();\n  }\n\n  bool insert(IndexType u) {\n    if (empty()) {\n      min_ = max_ = u;\n      return true;\n    }\n    if (u == min_ || u == max_) return false;\n\n    if (min_ == max_) {\n      if (max_ < u) {\n        max_ = u;\n        return true;\n      }\n      min_ = u;\n      return true;\n    }\n\n    if (min_ > u) {\n      std::swap(min_, u);\n    } else if (max_ < u) {\n      std::swap(max_, u);\n    }\n\n    if (summary == nullptr) summary = new EmdeBoasTreeNode<Height-1>;\n    summary->insert(upper(u));\n\n    auto it=cluster.lower_bound(upper(u));\n    if (it == cluster.end() || it->first != upper(u))\n      it = cluster.emplace_hint(it, upper(u), EmdeBoasTreeNode<Height-1>());\n\n    return it->second.insert(lower(u));\n  }\n\n  bool erase(IndexType u) {\n    if (min_ == max_) {\n      if (min_ == u) {\n        min_ = 1;\n        max_ = 0;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    if (u < min_ || max_ < u) return false;\n\n    if (summary == nullptr) {\n      if (u == min_) {\n        min_ = max_;\n        return true;\n      } else if (u == max_) {\n        max_ = min_;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    IndexType bucket=upper(u), v=lower(u);\n    if (u == min_) {\n      bucket = summary->min();\n      v = cluster.at(bucket).min();\n      min_ = bucket << HALF_WIDTH | v;\n    } else if (u == max_) {\n      bucket = summary->max();\n      v = cluster.at(bucket).max();\n      max_ = bucket << HALF_WIDTH | v;\n    } else {\n      if (!summary->contains(bucket)) return false;\n    }\n    bool res=cluster.at(bucket).erase(v);\n    if (res && cluster.at(bucket).empty()) {\n      cluster.erase(bucket);\n      summary->erase(bucket);\n      if (summary->empty()) {\n        delete summary;\n        summary = nullptr;\n      }\n    }\n    return res;\n  }\n\n  IndexType min() const {\n    if (empty()) throw std::out_of_range(\"min() on {}\");\n    return min_;\n  }\n\n  IndexType max() const {\n    if (empty()) throw std::out_of_range(\"max() on {}\");\n    return max_;\n  }\n\n  bool empty() const {\n    return max_ < min_;\n  }\n};\n\ntemplate <>\nclass EmdeBoasTreeNode<3> {\n  friend EmdeBoasTree;\n  friend EmdeBoasTreeNode<4>;\n  using IndexType = unsigned long long;\n\n  IndexType vec[4]={};\n\n  EmdeBoasTreeNode() = default;\n\n  bool contains(IndexType u) const {\n    return vec[u/64] >> (u%64) & 1;\n  }\n\n  IndexType successor(IndexType u) const {\n    IndexType tmp=vec[u/64]&~((1uLL<<((u+1)%64))-1);\n    if (u % 64 < 63 && tmp > 0) return (u/64*64) | __builtin_ctzll(tmp);\n    for (size_t i=u/64+1; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"u <= minimum\");\n  }\n\n  IndexType predecessor(IndexType u) const {\n    IndexType tmp=vec[u/64]&((1uLL<<(u%64))-1);\n    if (tmp > 0) return (u/64*64) | (63-__builtin_clzll(tmp));\n    for (size_t i=u/64; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"u >= maximum\");\n  }\n\n  bool insert(IndexType u) {\n    if (vec[u/64] >> (u%64) & 1) return false;\n    vec[u/64] |= 1uLL << (u%64);\n    return true;\n  }\n\n  bool erase(IndexType u) {\n    if (!(vec[u/64] >> (u%64) & 1)) return false;\n    vec[u/64] ^= 1uLL << (u%64);\n    return true;\n  }\n\n  IndexType min() const {\n    for (int i=0; i<4; ++i)\n      if (vec[i]) return i<<6 | __builtin_ctzll(vec[i]);\n\n    throw std::out_of_range(\"min() on {}\");\n  }\n\n  IndexType max() const {\n    for (size_t i=4; i--;)\n      if (vec[i]) return i<<6 | (63-__builtin_clzll(vec[i]));\n\n    throw std::out_of_range(\"max() on {}\");\n  }\n\n  bool empty() const {\n    return !(vec[0] || vec[1] || vec[2] || vec[3]);\n  }\n};\n\nclass EmdeBoasTree {\n  using IndexType = unsigned long long;\n  static constexpr size_t TopHeight=5;\n\n  EmdeBoasTreeNode<TopHeight> *root;\n  size_t size_=0;\n\npublic:\n  EmdeBoasTree(): root(new EmdeBoasTreeNode<TopHeight>) {}\n\n  IndexType min() const { return root->min(); }\n  IndexType max() const { return root->max(); }\n  bool empty() const { return root->empty(); }\n  bool contains(IndexType u) const { return !empty() && root->contains(u); }\n  IndexType successor(IndexType u) const { return root->successor(u); }\n  IndexType predecessor(IndexType u) const { return root->predecessor(u); }\n  bool insert(IndexType u) { return root->insert(u) && ++size_; }\n  bool erase(IndexType u) { return !empty() && root->erase(u) && size_--; }\n  size_t size() const { return size_; }\n\n  void debug() const {\n    if (empty()) {\n      fprintf(stderr, \"{}\\n\");\n      return ;\n    }\n    fprintf(stderr, \"{\");\n    IndexType i_ub=max();\n    for (IndexType i=min(); i<i_ub; i=successor(i)) {\n      fprintf(stderr, \"%llu%s\", i, i<i_ub? \", \":\"\");\n      assert(contains(successor(i)));\n      assert(i < successor(i));\n    }\n\n    fprintf(stderr, \"%llu}\\n\", i_ub);\n    fflush(stderr);\n  }\n};\n\nint main() {\n  int q;\n  scanf(\"%d\", &q);\n\n  EmdeBoasTree veb;\n\n  for (int i=0; i<q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 0) {\n      /* insert */\n      int x;\n      scanf(\"%d\", &x);\n      veb.insert(x);\n      printf(\"%zu\\n\", veb.size());\n    } else if (t == 1) {\n      /* find */\n      int x;\n      scanf(\"%d\", &x);\n      printf(\"%d\\n\", veb.contains(x));\n    } else if (t == 2) {\n      /* delete */\n      int x;\n      scanf(\"%d\", &x);\n      veb.erase(x);\n    } else if (t == 3) {\n      /* dump */\n      unsigned long long l, r;\n      scanf(\"%llu %llu\", &l, &r);\n      if (veb.empty()) continue;\n      // if (veb.max() < l) continue;\n\n      // if (veb.contains(l))\n      //   printf(\"%llu\\n\", l);\n\n      // r = std::min(r, veb.max());\n      // while (l < r) {\n      //   l = veb.successor(l);\n      //   if (l > r) break;\n      //   printf(\"%llu\\n\", l);\n      // }\n      std::vector<int> res;\n      if (veb.min() > r) continue;\n      if (veb.contains(r))\n        res.push_back(r);\n\n      l = std::max(l, veb.min());\n      while (l < r) {\n        r = veb.predecessor(r);\n        if (l > r) break;\n        res.push_back(r);\n      }\n      std::reverse(res.begin(), res.end());\n      for (int x: res)\n        printf(\"%d\\n\", x);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#define long long long\n#define LF '\\n'\n#define ALL(x) x.begin(), x.end()\nusing namespace std;\ntypedef pair<int,int> pii;\ntemplate<class A, class B>inline bool chmax(A &a, const B &b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, const B &b){return b<a ? a=b,1 : 0;}\nconstexpr int INF = 0x3f3f3f3f;\n\n\nsigned main()\n{\n  cin.tie(nullptr), ios::sync_with_stdio(false);\n  set<int> U;\n  int Q;\n\n  cin >> Q;\n  while(Q--) {\n    int com, x, y;\n    cin >> com;\n\n    switch(com) {\n    case 0:\n      cin >> x;\n      U.insert(x);\n      cout << U.size() << LF;\n      break;\n\n    case 1:\n      cin >> x;\n      cout << U.count(x) << endl;\n      break;\n\n    case 2:\n      cin >> x;\n      U.erase(x);\n      break;\n\n    default:\n      cin >> x >> y;\n      for (auto it = U.lower_bound(x); it != U.upper_bound(y); ++it) {\n        cout << *it << LF;\n      }\n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\nconst int mod = 1000000007;\n\nint main() {\n    set<ll> a;\n    int q;\n    cin >> q;\n    rep(i, q) {\n        int command;\n        ll x;\n        cin >> command >> x;\n\n        if (command == 0) {\n            a.insert(x);\n            cout << a.size() << endl;\n        } else if (command == 1) {\n            cout << (a.find(x) != a.end()) << endl;\n        } else if (command == 2) {\n            a.erase(x);\n        } else if (command == 3) {\n            ll l, r;\n            l = x;\n            cin >> r;\n            for (auto it = a.lower_bound(l); it != a.end() && *it <= r; it++) {\n                cout << *it << endl;\n            }\n        }\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tint q;\n\tstd::cin >> q;\n\tstd::set<int> set;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint t, x;\n\t\tstd::cin >> t >> x;\n\t\tswitch (t) {\n\t\tcase 0: set.insert(x);\n\t\t\tstd::cout << set.size() << '\\n';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstd::cout << set.count(x) << '\\n';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tset.erase(x);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cin >> t;\n\t\t\tauto b = std::lower_bound(set.begin(), set.end(), x);\n\t\t\tauto e = std::upper_bound(set.begin(), set.end(), t);\n\t\t\tfor (; b != e; ++b) {\n\t\t\t\tstd::cout << *b << '\\n';\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    set<int> s;\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        int x, y;\n        cin >> x >> y;\n        if (x == 0)\n        {\n            s.insert(y);\n            cout << s.size() << endl;\n        }\n        if (x == 1)\n        {\n            cout << s.count(y) << endl;\n        }\n        if (x == 2)\n        {\n            s.erase(y);\n        }\n        if (x == 3)\n        {\n            int z;\n            cin >> z;\n            for (auto it = s.lower_bound(y); it != s.upper_bound(z); it++)\n            {\n                cout << *it << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main() {\n    //std::cin.tie(nullptr);\n    //std::ios::sync_with_stdio(false);\n\n    std::set<int> s;\n    int Q;\n    std::cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int t;\n        std::cin >> t;\n        if (t == 0) {\n            int x;\n            std::cin >> x;\n            s.insert(x);\n            std::cout << s.size() << \"\\n\";\n        } else if (t == 1) {\n            int x;\n            std::cin >> x;\n            std::cout << s.count(x) << \"\\n\";\n        } else if (t == 2) {\n            int x;\n            std::cin >> x;\n            s.erase(x);\n        } else {\n            int l, r;\n            std::cin >> l >> r;\n            auto e = s.upper_bound(r);\n            for (auto itr = s.lower_bound(l); itr != e; ++itr) std::cout << *itr << \"\\n\";\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #include<initializer_list>\n// #include<iostream>\n\n#include<iostream>\nusing namespace std;\n\ntemplate<typename type>\nclass BTree {\npublic :\n\tstatic const int default_min_degree = 2;\n\tbool MULTISET = false; // true -> duplicate 　false -> not duplicate \n\tint SEARCH = 0; // linear search ->0  binary search ->1\n\tbool COUNT_NUM = true;\n\t\n\tint number_of_element;\n\tint min_degree;\n\t\n\t\n\tclass Node {\n\tpublic :\n\t\tbool leaf;\n\t\tint number_of_key;\n\t\tint w_num;\n\t\t\n\t\tNode* parent;\n\t\t// int *count;\n\t\tint *sum;\n\t\ttype *key;\n\t\tNode** children;\n\t\tBTree<type>* btree;\n\t\t\n\t\tNode(BTree<type>* btree, Node* parent = nullptr): btree(btree), parent(parent) {init();}\t\n\t\t\n\t\t~Node(){\n\t\t\tdelete[] sum;\n\t\t\tdelete[] key;\n\t\t\tdelete[] children;\n\t\t}\n\t\t\n\t\tvoid init() {\n\t\t\tleaf = true;\n\t\t\tnumber_of_key = 0;\n\t\t\tw_num = 0;\n\t\t\t// count = 1;\n\t\t\t\n\t\t\tkey = new type[btree->min_degree * 2 - 1];\n\t\t\tchildren = new Node*[btree->min_degree * 2];\n\t\t\t\n\t\t\tif(btree->COUNT_NUM) {\n\t\t\t\tsum = new int[btree->min_degree * 2];\n\t\t\t\tsum[0] = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t};\n\t\n\tNode* root;\n\t\n\t\n\tclass jnode {\n\tpublic:\n\t\tNode* node;\n\t\tint index;\n\t\t\n\t\tjnode(Node* node = nullptr, int index = -1): node(node), index(index){}\t\n\t\tjnode(const jnode &j) { node = j.node;  index = j.index;};\n\t\t\n\t\tjnode& operator ++(){\n\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\tif(node == nullptr) {\n\t\t\t\tindex = -2;\n\t\t\t} else if(node->number_of_key <= index){\n\t\t\t\t\n\t\t\t\tdo{\n\t\t\t\t\tindex = node->w_num;\n\t\t\t\t\tnode = node->parent;\n\t\t\t\t} while(node != nullptr && node->number_of_key <= index);\n\t\t\t\t\n\t\t\t} else if(node->leaf) { \n\t\t\t\tif(node->number_of_key - 1 <= index) {\n\t\t\t\t\tdo{\n\t\t\t\t\t\tindex = node->w_num;\n\t\t\t\t\t\tnode = node->parent;\n\t\t\t\t\t} while(node != nullptr && node->number_of_key <= index);\n\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = node->children[index+1];\n\t\t\t\t\n\t\t\t\twhile(!node->leaf){\n\t\t\t\t\tnode = node->children[0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t\n\t\t\treturn *this;\n\t\t}\n\t\t\n\t\tjnode operator ++(int) {\n\t\t\tjnode j = *this;\n\t\t\t\n\t\t\t++(*this);\n\t\t\t\n\t\t\treturn j;\n\t\t}\n\t\t\n\t\tjnode& operator --(){\n\t\t\t\n\t\t\tif(node == nullptr) {\n\t\t\t\tindex = -1;\n\t\t\t} else if(index < 0){\n\t\t\t\tdo{\n\t\t\t\t\tindex = node->w_num - 1;\n\t\t\t\t\tnode = node->parent;\n\t\t\t\t} while(node != nullptr && index < 0);\n\t\t\t\t\n\t\t\t} else if(node->leaf) {\n\t\t\t\tif(index == 0) {\n\t\t\t\t\tdo{\n\t\t\t\t\t\tindex = node->w_num - 1;\n\t\t\t\t\t\tnode = node->parent;\n\t\t\t\t\t} while(node != nullptr && index < 0);\n\t\t\t\t} else {\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = node->children[index];\n\t\t\t\t\n\t\t\t\twhile(!node->leaf){\n\t\t\t\t\tnode = node->children[node->children->number_of_key];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tindex = node->number_of_key - 1;\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t\t\n\t\tjnode operator --(int) {\n\t\t\tjnode j = *this;\n\t\t\t\n\t\t\t--(*this);\n\t\t\t\n\t\t\treturn j;\n\t\t}\t\t\n\t\t\n\t\tbool operator == (const jnode &j) const {\n\t\t\treturn node ==  j.node && index == j.index;\n\t\t}\n\t};\n\t\n\t\n\tBTree(int min_degree = default_min_degree) : min_degree(min_degree){ create();};\n\t\n\t~BTree(){\n\t\tclear(root);\n\t}\n\t\n\tint index_search(Node *node, int key, int k){  // lower bound\n\t\tint index;\n\t\t\n\t\tif(k == 0){\n\t\t\t// linear search\n\t\t\t\n\t\t\tfor(index = 0; index < node->number_of_key && (node->key[index] < key); index++);\n\t\t} else if(k == 1){\n\t\t\t//binary search\n\t\t\t\n\t\t\tindex = node->number_of_key;\n\t\t\tint low = -1, med;\n\t\t\twhile(low + 1< index){\n\t\t\t\tint med = (low + index) >> 1;\n\t\t\t\t\n\t\t\t\tif((node->key[med] < key)) {\n\t\t\t\t\tlow = med;\n\t\t\t\t} else {\n\t\t\t\t\tindex = med;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn index;\n\t}\n\t\n\tint index_search2(Node *node, int key, int k){ // upper bound\n\t\tint index;\n\t\t\n\t\tif(k == 0){\n\t\t\t// linear search\n\t\t\t\n\t\t\tfor(index = 0; index < node->number_of_key && (key >= node->key[index]); index++);\n\t\t} else if(k == 1){\n\t\t\t//binary search\n\t\t\t\n\t\t\tindex = node->number_of_key;\n\t\t\tint low = -1, med;\n\t\t\twhile(low + 1 < index){\n\t\t\t\tint med = (low + index) >> 1;\n\t\t\t\t\n\t\t\t\tif(key >= node->key[med]) {\n\t\t\t\t\tlow = med;\n\t\t\t\t} else {\n\t\t\t\t\tindex = med;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn index;\n\t}\n\t\n\tint sum_search(Node *node, int num, int k){\n\t\tint index = 0;\n\t\t\n\t\tif(k == 0){\n\t\t\t// linear search\n\t\t\t\n\t\t\tfor(index = 0; index < node->number_of_key && node->sum[index] < num; index++);\n\t\t} else if(k == 1){\n\t\t\t//binary search\n\t\t\t\n\t\t\tindex = node->number_of_key;\n\t\t\tint low = -1, med;\n\t\t\twhile(low + 1 < index){\n\t\t\t\tint med = (low + index) >> 1;\n\t\t\t\t\n\t\t\t\tif(node->sum[med] < num) {\n\t\t\t\t\tlow = med;\n\t\t\t\t} else {\n\t\t\t\t\tindex = med;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn index;\n\t}\n\t\n\tvoid clear(Node* node){\n\t\t\n\t\tif(!node->leaf) {\n\t\t\tfor(int i = 0; i <= node->number_of_key; i++){\n\t\t\t\tclear(node->children[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdelete node;\n\t}\n\t\n\tvoid create(){\n\t\tnumber_of_element = 0;\n\t\t\n\t\troot = new Node(this);\n\t}\n\t\n\tint lower_bound(type key){\n\t\treturn lower_bound(root, key);\n\t}\n\t\n\tint lower_bound(Node *node, type key){\n\t\tint index = index_search(node, key, SEARCH);\n\t\t\n\t\tif(node->leaf) {\n\t\t\tif(index < node->number_of_key) return node->sum[index];\n\t\t\telse return node->number_of_key;\n\t\t} else {\n\t\t\t if(index) return lower_bound(node->children[index], key) + node->sum[index-1] + 1;\n\t\t\telse return lower_bound(node->children[index], key);\n\t\t}\n\t}\n\t\n\tint upper_bound(type key){\n\t\treturn upper_bound(root, key);\n\t}\n\t\n\tint upper_bound(Node *node, type key){\n\t\tint index = index_search2(node, key, SEARCH);\n\t\t\n\t\tif(node->leaf) {\n\t\t\tif(index < node->number_of_key) return node->sum[index];\n\t\t\telse return node->number_of_key;\n\t\t} else {\n\t\t\t if(index) return upper_bound(node->children[index], key) + node->sum[index-1] + 1;\n\t\t\telse return upper_bound(node->children[index], key);\n\t\t}\n\t}\n\t\n\tint size(){\n\t\treturn number_of_element;\n\t}\n\t\n\tNode* search(type k){\n\t\treturn search(root, k);\n\t}\n\t\n\tNode* search(Node* node, type key){\n\t\t\n\t\tint index = index_search(node, key, SEARCH);\n\t\t\n\t\t\n\t\tif(index < node->number_of_key && (node->key[index] == key)) {\n\t\t\treturn node;\n\t\t} else if(node->leaf) {\n\t\t\treturn nullptr;\n\t\t} else {\n\t\t\treturn search(node->children[index], key);\n\t\t}\n\t}\n\t\n\tvoid operation(Node *node, int index = 0){\n\t\tif(COUNT_NUM) count_number(node, index);\n\t\tchange_w_num(node, index);\n\t}\n\t\n\tvoid count_number(Node *node, int index){\n\t\t\n\t\tif(node == nullptr) return;\n\t\t\n\t\tif(node->leaf) {\n\t\t\tfor(int i = index; i <= node->number_of_key; i++) {\n\t\t\t\tnode->sum[i] = 0;\n\t\t\t\tif(i) {\n\t\t\t\t\tnode->sum[i] += node->sum[i-1] + 1;\n\t\t\t\t\t// node->sum[i] += node->sum[i-1] + node->count[i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor(int i = index; i <= node->number_of_key; i++){\n\t\t\t\t\n\t\t\t\tnode->sum[i] = node->children[i]->sum[node->children[i]->number_of_key];\n\t\t\t\n\t\t\t\tif(i) {\n\t\t\t\t\tnode->sum[i] += node->sum[i-1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid change_w_num(Node *node, int index){\n\t\tif(node == nullptr) return;\n\t\tif(node == root) node->parent = nullptr;\n\t\t\n\t\tif(!node->leaf) {\n\t\t\tfor(int i = index; i <= node->number_of_key; i++){\n\t\t\t\tnode->children[i]->w_num = i;\n\t\t\t\tnode->children[i]->parent = node;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tjnode nth_element(int num){\n\t\tif(num < 0 || num >= size()) return jnode();\n\t\treturn nth_element(root, num);\n\t}\n\t\n\tjnode nth_element(Node* node, int num){\n\t\tint index = sum_search(node, num, SEARCH);\n\t\t\n\t\tif(index < node->number_of_key && num == node->sum[index]) {\n\t\t\treturn jnode(node, index);\n\t\t} else {\n\t\t\tif(node->leaf) {\n\t\t\t\t// どうしてここに？\n\t\t\t} else {\n\t\t\t\tif(index) return nth_element(node->children[index], num - node->sum[index-1] - 1);\n\t\t\t\telse return nth_element(node->children[index], num);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid split_child(Node* node, int index){\n\t\tNode *right_child = new Node(this, node);\n\t\tNode *left_child = node->children[index];\n\t\t\n\t\tright_child->leaf =  left_child->leaf;\n\t\tright_child->number_of_key = min_degree - 1;\n\t\t\n\t\tfor(int j = 0; j < min_degree - 1; j++){\n\t\t\tright_child->key[j] = left_child->key[j + min_degree];\n\t\t}\n\t\t\n\t\tif(!left_child->leaf) {\n\t\t\t\n\t\t\tfor(int j = 0; j < min_degree; j++){\n\t\t\t\tright_child->children[j] = left_child->children[j + min_degree];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tleft_child->number_of_key = min_degree - 1;\n\t\t\n\t\tfor(int j = node->number_of_key; j > index; j--){\n\t\t\tnode->children[j+1] = node->children[j];\n\t\t}\n\t\t\n\t\tnode->children[index+1] = right_child;\n\t\t\n\t\tfor(int j = node->number_of_key - 1; j >= index; j--){\n\t\t\tnode->key[j+1] = node->key[j];\n\t\t}\n\t\t\n\t\tnode->key[index] = left_child->key[min_degree-1];\n\t\t\n\t\tnode->number_of_key++;\n\t\t\n\t\tright_child->parent = node;\n\t\t\n\t\toperation(right_child);\n\t\toperation(left_child);\n\t}\n\t\n\tvoid insert_nonfull(Node* node, type key){\n\t\tint index = node->number_of_key - 1;\n\t\t\n\t\tif(node->leaf) {\n\t\t\t\n\t\t\tfor(; index >= 0 && (key < node->key[index]); index--){\n\t\t\t\tnode->key[index+1] = node->key[index];\n\t\t\t}\n\t\t\t\n\t\t\tnode->key[index+1] = key;\n\t\t\tnode->number_of_key++;\n\t\t} else {\n\t\t\tfor(; index >= 0 && (key < node->key[index]); index--);\n\t\t\t\n\t\t\tindex++;\n\t\t\t\n\t\t\tif(node->children[index]->number_of_key == 2 * min_degree - 1) {\n\t\t\t\tsplit_child(node, index);\n\t\t\t\t\n\t\t\t\tif((node->key[index] < key)) index++;\n\t\t\t}\n\t\t\t\n\t\t\tinsert_nonfull(node->children[index], key);\n\t\t}\n\t\t\n\t\toperation(node);\n\t}\n\t\n\tvoid insert(type key){\n\t\tif(!MULTISET && search(key) != nullptr) return ;\n\t\t\n\t\tnumber_of_element++;\n\t\t\n\t\t_insert(key);\n\t}\n\t\n\tvoid _insert(type key){\n\t\tNode* temp_root = root;\n\t\t\n\t\tif(root->number_of_key == 2 * min_degree - 1) {\n\t\t\tNode* new_node = new Node(this);\n\t\t\t\n\t\t\troot = new_node;\n\t\t\t\n\t\t\troot->leaf = false;\n\t\t\troot->children[0] = temp_root;\n\t\t\troot->parent = new_node;\n\t\t\t\n\n\t\t\tsplit_child(root, 0);\n\t\t\tinsert_nonfull(root, key);\n\t\t} else {\n\t\t\tinsert_nonfull(root, key);\n\t\t}\n\t}\n\t\n\tvoid erase(type key){\n\t\terase(root, key);\n\t\t\n\t\twhile(root->number_of_key == 0 && !root->leaf) {\n\t\t\tNode *temp = root;\n\t\t\t\n\t\t\troot = root->children[0];\n\t\t\troot->parent = nullptr;\t\t\n\t\t\t\n\t\t\tdelete temp;\n\t\t}\n\t}\n\t\n\tvoid erase(Node* node, type key){\n\t\tint index = index_search(node, key, SEARCH);\n\t\t\n\t\tif(index < node->number_of_key && (node->key[index] == key)) {\n\t\t\tif(node->leaf) {\n\t\t\t\tfor(int i = index; i + 1 < node->number_of_key; i++){\n\t\t\t\t\tnode->key[i] = node->key[i + 1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnumber_of_element--;\n\t\t\t\tnode->number_of_key--;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tNode* child1 = node->children[index];\n\t\t\t\tNode* child2 = node->children[index+1];\n\t\t\t\t\n\t\t\t\tif(child1->number_of_key >= min_degree) {\n\t\t\t\t\tNode *maximum = child1;\n\t\t\t\t\t\n\t\t\t\t\twhile(!maximum->leaf){\n\t\t\t\t\t\tmaximum = maximum->children[maximum->number_of_key];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnode->key[index] = maximum->key[maximum->number_of_key-1];\n\t\t\t\t\t\n\t\t\t\t\terase(child1, node->key[index]);\n\t\t\t\t} else if(child2->number_of_key >= min_degree){\n\t\t\t\t\tNode *minimum = child2;\n\t\t\t\t\t\n\t\t\t\t\twhile(!minimum->leaf){\n\t\t\t\t\t\tminimum = minimum->children[0];\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tnode->key[index] = minimum->key[0];\n\t\t\t\t\t\n\t\t\t\t\terase(child2, node->key[index]);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tchild1->key[min_degree - 1] = key;\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = min_degree; i < min_degree * 2 - 1; i++){\n\t\t\t\t\t\tchild1->key[i] = child2->key[i - min_degree];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = min_degree; i < min_degree * 2; i++){\n\t\t\t\t\t\tchild1->children[i] = child2->children[i - min_degree];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdelete child2;\n\t\t\t\t\t\n\t\t\t\t\tchild1->number_of_key = min_degree * 2 - 1;\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = index; i + 1 < node->number_of_key; i++){\n\t\t\t\t\t\tnode->key[i] = node->key[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = index + 1; i < node->number_of_key; i++){\n\t\t\t\t\t\tnode->children[i] = node->children[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnode->number_of_key--;\n\t\t\t\t\t\n\t\t\t\t\terase(child1, key);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(node->leaf) {\n\t\t\n\t\t} else {\n\t\t\n\t\t\tNode* child0 = nullptr;\n\t\t\tNode* child1 = child1 = node->children[index];;\n\t\t\tNode* child2 = nullptr;\n\t\t\t\n\t\t\tif(index >= 1) child0 = node->children[index-1];\n\t\t\tif(index + 1 <= node->number_of_key) child2 = node->children[index+1];\n\t\t\t\n\t\t\tif(child1 == nullptr) { \n\t\t\t\t//　ﾊﾞｶｼﾞｬﾈｰﾉ\n\t\t\t\treturn ;\n\t\t\t} else if(child1->number_of_key >= min_degree) {\n\t\t\t\terase(child1, key);\n\t\t\t} else if(child0 != nullptr && child0->number_of_key >= min_degree){\n\t\t\t\tindex--;\n\t\t\t\t\n\t\t\t\tfor(int i = child1->number_of_key - 1; i >= 0; i--){\n\t\t\t\t\tchild1->key[i+1] = child1->key[i];\n\t\t\t\t}\n\t\t\t\tfor(int i = child1->number_of_key; i >= 0; i--){\n\t\t\t\t\tchild1->children[i+1] = child1->children[i];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchild1->key[0] = node->key[index];\n\t\t\t\tchild1->children[0] = child0->children[child0->number_of_key];\n\t\t\t\t\n\t\t\t\tnode->key[index] = child0->key[child0->number_of_key-1];\n\t\t\t\t\n\t\t\t\tchild0->number_of_key--;\n\t\t\t\tchild1->number_of_key++;\n\t\t\t\t\n\t\t\t\terase(child1, key);\n\t\t\t\t\n\t\t\t} else if(child2 != nullptr && child2->number_of_key >= min_degree){\n\t\t\t\t\n\t\t\t\tchild1->key[child1->number_of_key] = node->key[index];\n\t\t\t\tchild1->children[child1->number_of_key + 1] = child2->children[0];\n\t\t\t\t\n\t\t\t\tnode->key[index] = child2->key[0];\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i + 1 < child2->number_of_key; i++){\n\t\t\t\t\tchild2->key[i] = child2->key[i+1];\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < child2->number_of_key; i++){\n\t\t\t\t\tchild2->children[i] = child2->children[i+1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchild2->number_of_key--;\n\t\t\t\tchild1->number_of_key++;\n\t\t\t\t\n\t\t\t\toperation(child2);\n\t\t\t\terase(child1, key);\n\t\t\t} else if(child2 != nullptr || child0 != nullptr){\n\t\t\t\tNode* child_left, *child_right;\n\t\t\t\t\n\t\t\t\tif(child2 != nullptr){\n\t\t\t\t\tchild_left = child1;\n\t\t\t\t\tchild_right = child2;\n\t\t\t\t\t\n\t\t\t\t} else if(child0 != nullptr){\n\t\t\t\t\tchild_left = child0;\n\t\t\t\t\tchild_right = child1;\n\t\t\t\t\t\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchild_left->key[min_degree - 1] = node->key[index];\n\t\t\t\t\t\n\t\t\t\tfor(int i = min_degree; i < min_degree * 2 - 1; i++){\n\t\t\t\t\tchild_left->key[i] = child_right->key[i - min_degree];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = min_degree; i < min_degree * 2; i++){\n\t\t\t\t\tchild_left->children[i] = child_right->children[i - min_degree];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdelete child_right;\n\t\t\t\t\n\t\t\t\tchild_left->number_of_key = min_degree * 2 - 1;\n\t\t\t\t\n\t\t\t\tfor(int i = index; i + 1 < node->number_of_key; i++){\n\t\t\t\t\tnode->key[i] = node->key[i + 1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = index + 1; i < node->number_of_key; i++){\n\t\t\t\t\tnode->children[i] = node->children[i + 1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnode->number_of_key--;\n\t\t\t\t\n\t\t\t\toperation(node);\n\t\t\t\terase(child_left, key);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\toperation(node);\n\t}\n\t\n\tconst type operator[](int num) & {\n\t\tjnode j = nth_element(num);\n\t\treturn j.node->key[j.index];\n\t}\n};\n\n\nstruct fast_io {\n\tfast_io(){\n\t\tstd::cin.tie(nullptr);\n\t\tstd::ios::sync_with_stdio(false);\n\t};\n} fio;\n\n \nint main(){\n\tusing namespace std;\n\t\n\tBTree<int> bt(12);\n\tint Q;\n\t\n\tstd::cin>>Q;\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tint a, b, c;\n\t\t\n\t\tstd::cin>>a>>b;\n\t\t\n\t\tif(a == 0){\n\t\t\tbt.insert(b);\n\t\t\tcout<<bt.size()<<endl;\n\t\t} else if(a == 1) {\n\t\t\tcout<<(bt.upper_bound(b) - bt.lower_bound(b))<<endl;\n\t\t} else if(a == 2){\n\t\t\t\n\t\t\t// while(bt.search(b) != nullptr) {\n\t\t\t\tbt.erase(b);\n\t\t\t// }\n\t\t} else if(a == 3) {\n\t\t\tBTree<int>::jnode jn;\n\t\t\t\n\t\t\tcin>>c;\n\t\t\t\n\t\t\t// int num = bt.lower_bound(b);\n\t\t\t\n\t\t\t// for(int i = num; i < bt.size() && bt[i] <= c; i++){\n\t\t\t\t// cout<<bt[i]<<endl;\n\t\t\t// }\n\t\t\tjn = bt.nth_element(bt.lower_bound(b));\n\t\t\t\n\t\t\tfor(; jn.node != nullptr && jn.node->key[jn.index] <= c; jn++){\n\t\t\t\tcout<<jn.node->key[jn.index]<<endl;\n\t\t\t}\n\t\t} else if(a == 4) {\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  set<int> s;\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int t,x;\n    cin>>t>>x;\n    if(t==0) s.emplace(x);\n    if(t==0) cout<<s.size()<<endl;\n    if(t==1) cout<<s.count(x)<<endl;\n    if(t==2) s.erase(x);\n    if(t==3){\n      int y;\n      cin>>y;\n      auto latte=s.lower_bound(x);\n      while(latte!=s.end()&&*latte<=y) cout<<*latte++<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  set<int> S;\n  int q, query, x, L, R;\n  scanf(\"%d\", &q);\n  for(int i = 0; i < q; i++){\n    scanf(\"%d\", &query);\n    if(query == 3){\n      scanf(\"%d%d\", &L, &R);\n      auto it = S.lower_bound(L);\n      for(auto i = it; i != S.end() && *i <= R; i++){\n        printf(\"%d\\n\", *i);\n      }\n    }else{\n      scanf(\"%d\", &x);\n      if(query == 0){\n        S.insert(x);\n        printf(\"%d\\n\", S.size());\n      }else if(query == 1){\n        auto it = S.find(x);\n        if(it != S.end()){\n          printf(\"%d\\n\", 1);\n        }else{\n          printf(\"%d\\n\", 0);\n        }\n      }else{\n        S.erase(x);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  set<int> st;\n  int q; cin >> q;\n  for(int i=0; i<q; i++){\n    int query, x;\n    cin >> query >> x;\n    if(query==0){\n      st.insert(x);\n      cout << st.size() << endl;\n    }\n    else if(query==1){\n      auto itr = st.find(x);\n      if(itr != st.end()) cout << 1 << endl;\n      else cout << 0 << endl;\n    }\n    else if(query==2){\n      st.erase(x);\n    }\n    else {\n      int y; cin >> y;\n      auto itrLower = st.lower_bound(x);\n      auto itrUpper = st.upper_bound(y);\n\n      while(itrLower != itrUpper){\n        cout << *itrLower << endl;\n        itrLower++;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void) {\n\tset<int> S;\n\tint q, com, x, y;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> com;\n\t\tswitch (com) {\n\t\t\tcase 0:\n\t\t\t\tcin >> x;\n\t\t\t\tS.insert(x);\n\t\t\t\tcout << S.size() << endl;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcin >> x;\n\t\t\t\tif (S.find(x) != S.end()) {\n\t\t\t\t\tcout << \"1\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tcout << \"0\\n\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcin >> x;\n\t\t\t\tS.erase(x);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcin >> x >> y;\n\t\t\t\tfor (int i = x; i <= y; i++) {\n\t\t\t\t\tif (S.find(i) != S.end()) {\n\t\t\t\t\t\tcout << i << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\nset<int>a;\nint main()\n{\n    int n,choose,temp,l,r;\n    cin >> n;\n    while (n--)\n    {\n        cin >> choose;\n        switch (choose)\n        {\n        case 0:\n            cin >> temp;\n            a.insert(temp);\n            cout << a.size() << endl;\n            break;\n        case 1:\n            cin >> temp;\n            if (a.find(temp) == a.end())cout << 0 << endl;\n            else cout << 1 << endl;\n            break;\n        case 2:\n            cin >> temp;\n            a.erase(temp);\n            break;\n        case 3:\n            cin >> l >> r;\n            set<int>::iterator begin, end;\n            begin = a.lower_bound(l);\n            end = a.upper_bound(r);\n            for (; begin != end; begin++)\n            {\n                cout << *begin << endl;\n            }\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<typename T = lint>inline T in() { T x; cin >> x; return x; }\n#define INF           1e9\n#define INFL          static_cast<lint>(INF)\n#define REP(i,n)      for(lint i=0,i##_len=(n);i<i##_len;++i)\n#define REP1(i,n)     for(lint i=1,i##_len=(n);i<=i##_len;++i)\n#define REPR(i,n)     for(lint i=n-1;i>=0;--i)\n#define REPR1(i,n)    for(lint i=n;i>0;--i)\n#define REPI(i,ini,n) for(lint i=(ini),i##_len=(n);i<i##_len;++i)\n#define REPC(i,obj)   for(auto i:obj)\n#define R_UP(a,b)     (((a)+(b)-1)/(b))\n#define ALL(obj)      (obj).begin(),(obj).end()\nint main()\n{\n\tint q = in();\n\tset<int>s;\n\tREP(i, q)\n\t{\n\t\tint n = in();\n\t\tint x, l, r;\n\t\tswitch (n)\n\t\t{\n\t\tcase 0:\n\t\t\tx = in();\n\t\t\ts.insert(x);\n\t\t\tcout << s.size() << endl;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tx = in();\n\t\t\tcout << (s.find(x) == s.end() ? 0 : 1) << endl;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tx = in();\n\t\t\ts.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tl = in();\n\t\t\tr = in();\n\t\t\tfor (auto start = s.lower_bound(l), last = s.upper_bound(r); start != last; start++)cout << *start << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n\nint main(){\n\n    int q;\n    cin >> q;\n    set<int> st;\n    for(int i = 0; i < q; ++i){\n        int com, x;\n        cin >> com;\n        if(com != 3){\n            cin >> x;\n        }\n        if(com == 0){\n            st.insert(x);\n            cout << st.size() << endl;\n        }\n        else if(com == 1){\n            cout << (st.find(x) != st.end()) << endl;\n        }\n        else if(com == 2){\n            st.erase(x);\n        }\n        else{\n            int L, R;\n            cin >> L >> R;\n            auto l = st.lower_bound(L);\n            auto r = st.upper_bound(R);\n            for(auto it = l; it != r; ++it){\n                cout << *it << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint q;\n\tscanf(\"%d\", &q);\n\tset<int> st;\n\twhile (q--) {\n\t\tint com, x;\n\t\tscanf(\"%d%d\", &com, &x);\n\t\tif (com == 0) {\n\t\t\tst.insert(x);\n\t\t\tprintf(\"%d\\n\", st.size());\n\t\t}\n\t\telse if (com == 1) {\n\t\t\tputs(st.count(x) ? \"1\" : \"0\");\n\t\t}\n\t\telse if (com == 2) {\n\t\t\tst.erase(x);\n\t\t}\n\t\telse {\n\t\t\tint L = x, R;\n\t\t\tscanf(\"%d\", &R);\n\t\t\tauto it = st.lower_bound(L);\n\t\t\twhile (it != st.end() && *it <= R) {\n\t\t\t\tprintf(\"%d\\n\", *it); ++it;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tint Q=in();\n\tset<int> S;\n\tREP(i,Q){\n\t\tint q=in();\n\t\tif(q==1){\n\t\t\tout(S.find(in())==S.end()?0:1);\n\t\t}\n\t\telse if(q==2){\n\t\t\tS.erase(in());\n\t\t}\n\t\telse if(q==3){\n\t\t\tint L=in(),R=in();\n\t\t\tauto start = S.lower_bound(L);\n\t\t\tauto end = S.upper_bound(R);\n\t\t\twhile(start!=end){\n\t\t\t\tout(*start);\n\t\t\t\t++start;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tS.insert(in());\n\t\t\tout(S.size());\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main (){\n  int q,t,x,y;\n  set<int> a;\n\n  cin >> q;\n\n  for (int i = 0; i < q; i++){\n    cin >> t;\n    cin >> x;\n    if (t==0){\n      a.insert(x);\n      cout << a.size() << endl;\n    }else if(t==1){\n      cout << a.count(x) << endl;\n    }else if(t==2){\n      a.erase(x);\n    }else{\n      cin >> y;\n      auto it = a.lower_bound(x);\n      auto last = a.upper_bound(y);\n\n      while (it != last) {\n        cout << *it << endl;\n        ++it;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tset<int> s;\n\tfor(int i = 0; i < n; i++) {\n\t\tint id, x;\n\t\tscanf(\"%d%d\", &id, &x);\n\t\tif(id == 0) {\n\t\t\ts.insert(x);\n\t\t\tprintf(\"%lu\\n\", s.size());\n\t\t}else if(id == 1) {\n\t\t\tprintf(\"%lu\\n\", s.count(x));\n\t\t}else if(id == 2) {\n\t\t\ts.erase(x);\n\t\t}else if(id == 3) {\n\t\t\tint y;\n\t\t\tscanf(\"%d\", &y);\n\t\t\tauto itr = s.lower_bound(x);\n\t\t\tfor(; itr != s.end() && *itr <= y; itr++)\n\t\t\t\tprintf(\"%d\\n\", *itr);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep_i(i, n) for (int i = 0; i < (n); ++i)\n#define rep_ll(i, n) for (long long i = 0; i < (n); ++i)\n#define r_rep_i(i, start, end) for (int i = (start); i < (end); ++i)\n#define r_rep_ll(i, start, end) for (long long i = (start); i < (end); ++i)\n#define debug_vi(v) copy((v).begin(), (v).end(), ostream_iterator<int>(cout, \" \"));\n#define debug_vll(v) copy((v).begin(), (v).end(), ostream_iterator<long long>(cout, \" \"));\n#define debug_vd(v) copy((v).begin(), (v).end(), ostream_iterator<double>(cout, \" \"));\n#define sort_v(v) sort((v).begin(), (v).end()); //昇順\n#define d_sort_vi(v) sort((v).begin(), (v).end(), greater<int>()); //降\n#define d_sort_vd(v) sort((v).begin(), (v).end(), greater<double>()); //昇順\n#define say(t) cout << (t) << endl;\n#define sum_vi(v) accumulate((v).begin(), (v).end(), 0);\n#define sum_vll(v)accumulate((v).begin(), (v).end(), 0LL);\n\nint main(){\n  set<int> s;\n  int q;\n  cin >> q;\n  int tmp, tmp2, tmp3;\n  rep_i(i, q){\n    cin >> tmp >> tmp2;\n    if(tmp == 0){\n      s.insert(tmp2);\n      say(s.size());\n    }else if(tmp == 1){\n      set<int>::iterator itr = s.find(tmp2);\n      if(itr == s.end()){\n        say(0);\n      }else{\n        say(1);\n      }\n    }else if(tmp == 2){\n      s.erase(tmp2);\n    }else{\n      cin >> tmp3;\n      // set<int>::iterator lit = s.lower_bound(tmp2);\n      // set<int>::iterator rit = s.lower_bound(tmp3);\n      // size_t start = distance(s.begin(), lit);\n      // size_t end = distance(s.begin(), rit);\n      set<int>::iterator itr = s.lower_bound(tmp2);\n      set<int>::iterator itr2 = s.find(tmp3);\n      for (auto i = itr; i != s.end() && *i <= tmp3; i++){\n        say(*i);\n      }\n      \n      // r_rep_i(i, tmp2, tmp3 + 1){\n      //   if(itr == s.end()){\n      //     continue;\n      //   }else{\n      //     say(*itr);\n      //   }\n      // }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\n\n//van Emde Boas trees 要素は正の整数\nclass VEBtree;\n\nclass VEBtreeNode{\n\tusing Number = unsigned long long;\n\tfriend VEBtree;\n\tconst Number K;\n\tconst Number uppersqrt = (1 << ((K+1) >> 1));\n\tconst Number lowersqrt = (1 << (K >> 1));\n\tNumber min_ = 1, max_ = 0;\n\tstd::vector<VEBtreeNode> cluster;\n\tVEBtreeNode *summary;\n\n\tNumber high(Number x){ return x/lowersqrt ;}\n\tNumber low(Number x){ return x % lowersqrt;}\n\tNumber index(Number x, Number y){ return x*lowersqrt + y;}\n\n\tvoid empty_insert(Number x){\n\t\tmin_ = x;\n\t\tmax_ = x;\n\t}\n\tNumber min(){ return min_;}\n\tNumber max(){ return max_;}\n\n\tbool member(Number x){\n\t\tif(min() > max())return false;\n\t\tif(x == min() || x == max())return true;\n\t\telse if(K == 1)return false;\n\t\tassert(high(x) < cluster.size());\n\t\treturn cluster[high(x)].member(low(x));\n\t}\n\n\tNumber successor(Number x){\n\t\tif(K == 1){\n\t\t\tif(x == 0 and max() == 1) return 1;\n\t\t\telse return x;\n\t\t}\n\t\telse if(min() <= max() and x < min()) return min();\n\t\telse{\n\t\t\tNumber max_low = cluster[high(x)].max();\n\t\t\tif(cluster[high(x)].min() <= max_low and low(x) < max_low){\n\t\t\t\tNumber offset = cluster[high(x)].successor(low(x));\n\t\t\t\treturn index(high(x), offset);\n\t\t\t}\n\t\t\tNumber succ_cluster = summary->successor(high(x));\n\t\t\tif(succ_cluster == high(x)) return x;\n\t\t\telse{\n\t\t\t\tNumber offset = cluster[succ_cluster].min();\n\t\t\t\treturn index(succ_cluster, offset);\n\t\t\t}\n\t\t}\n\t}\n\n\tNumber predecessor(Number x){\n\t\tif(K == 1){\n\t\t\tif(x == 1 and min() == 0) return 0;\n\t\t\telse return x;\n\t\t}\n\t\telse if(min() <= max() and x > max()){ return max();}\n\t\telse{\n\t\t\tNumber min_low = cluster[high(x)].min();\n\t\t\tif(min_low <= cluster[high(x)].max() and low(x) > min_low){\n\t\t\t\tNumber offset = cluster[high(x)].predecessor(low(x));\n\t\t\t\treturn index(high(x), offset);\n\t\t\t}\n\t\t\tNumber pred_cluster = summary->predecessor(high(x));\n\t\t\tif(pred_cluster == high(x)){ return x;}\n\t\t\telse{\n\t\t\t\tNumber offset = cluster[pred_cluster].max();\n\t\t\t\treturn index(pred_cluster, offset);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid insert(Number x){\n\t\tif(min() > max()) empty_insert(x);\n\t\telse{\n\t\t\tif(x < min()) std::swap(x, min_);\n\t\t\tif(K > 1){\n\t\t\t\tif(cluster[high(x)].min() > cluster[high(x)].max()){\n\t\t\t\t\tsummary->insert(high(x));\n\t\t\t\t\tcluster[high(x)].empty_insert(low(x));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcluster[high(x)].insert(low(x));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x > max()){\n\t\t\t\tmax_ = x;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid erase(Number x){\n\t\tif(min() == max()){\n\t\t\tmin_ = 1; max_ = 0;\n\t\t}\n\t\telse if(K == 1){\n\t\t\tif( x == 0) min_ = 1;\n\t\t\telse min_ = 0;\n\t\t\tmax_ = min_;\n\t\t}\n\t\telse{\n\t\t\tif(x == min()){\n\t\t\t\tNumber first_cluster = summary->min();\n\t\t\t\tx = index(first_cluster, cluster[first_cluster].min());\n\t\t\t\tmin_ = x;\n\t\t\t}\n\t\t\tcluster[high(x)].erase(low(x));\n\t\t\tif(cluster[high(x)].min() > cluster[high(x)].max()){\n\t\t\t\tsummary->erase(high(x));\n\t\t\t\tif(x == max()){\n\t\t\t\t\tNumber summary_max = summary->max();\n\t\t\t\t\tif(summary_max < summary->min()) max_ = min();\n\t\t\t\t\telse max_ = index(summary_max, cluster[summary_max].max());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(x == max()){\n\t\t\t\tmax_ = index(high(x), cluster[high(x)].max());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic:\n\t\tVEBtreeNode(const VEBtreeNode& m):K(m.getK()){\n\t\t\tif(K != 1){\n\t\t\t\tsummary = new VEBtreeNode((K+1)>>1);\n\t\t\t\tcluster = std::vector<VEBtreeNode>(uppersqrt, VEBtreeNode(K>>1));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsummary = NULL;\n\t\t\t}\n\t\t}\n\n\t\tVEBtreeNode(Number k): K(k){\n\t\t\tif(K != 1){\n\t\t\t\tsummary = new VEBtreeNode((K+1) >> 1);\n\t\t\t\tcluster = std::vector<VEBtreeNode>(uppersqrt, VEBtreeNode(K>>1));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsummary = NULL;\n\t\t\t}\n\t\t}\n\n\t\t~VEBtreeNode() = default;\n\n\t\tNumber getK()const{return K;}\n};\n\nclass VEBtree{\n\tusing Number = unsigned long long;\n\tVEBtreeNode *root;\n\tsize_t size_;\npublic:\n\tVEBtree(): root(new VEBtreeNode(24)), size_(0){}\n\tVEBtree(Number universe): size_(0){\n\t\tNumber K = 0;\n\t\tfor(universe--;universe;universe >>= 1)K++;\n\t\troot = new VEBtreeNode(K ? K : 1);\n\t}\n\t~VEBtree(){ delete root;}\n\n\tsize_t size()const{return size_;}\n\tNumber min(){ return root->min();}\n\tNumber max(){ return root->max();}\n\tbool member(Number e){ return root->member(e);}\n\tNumber successor(Number e){\n\t\treturn root->successor(e);\n\t}\n\tNumber predecessor(Number e){\n\t\treturn root->predecessor(e);\n\n\t}\n\tvoid insert(Number e){\n\t\tif(!root->member(e)){\n\t\t\troot->insert(e);\n\t\t\tsize_++;\n\t\t}\n\t}\n\tvoid erase(Number e){\n\t\tif(root->member(e)){\n\t\t\troot->erase(e);\n\t\t\tsize_--;\n\t\t}\n\t}\n\n\t\t\n};\n\nsigned main(){\n\tusing namespace std;\n\tint n; cin >> n;\n\tVEBtree t(30);\n\tfor(int i = 0; i < n; i++){\n\t\tint q;cin >> q;\n\t\tunsigned long long x, y, prev; cin >> x;\n\t\tswitch(q){\n\t\t\tcase 0:\n\t\t\t\tt.insert(x);\n\t\t\t\tcout << t.size() << endl;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcout << t.member(x) << endl;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tt.erase(x);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcin >> y;\n\t\t\t\tx = t.member(x) ? x : t.successor(x);\n\t\t\t\tdo{\n\t\t\t\t\tprev = x;\n\t\t\t\t\tcout << x << endl;\n\t\t\t\t\tx = t.successor(x);\n\t\t\t\t}while(prev != x && x <= y);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t{\n\t\tunsigned ll i = t.min(),prev;\n\t\tdo{\n\t\t\tprev = i;\n\t\t\ti = t.successor(i);\n\t\t}while(i != prev);\n\t}\n\t\t\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\nusing namespace std;\n\nint main(){\n  int q; cin>>q;\n  set<int>s;\n  while(q--){\n    int x,y;\n    cin>>x>>y;\n    if(x==1)cout<<s.count(y)<<endl;\n    else if(x==0){\n      s.insert(y);\n      cout<<s.size()<<endl;\n    }\n    else if(x==2)s.erase(y);\n    else{\n      int l=y,r;\n      cin>>r;\n      set<int>::iterator end,it;\n      it=s.lower_bound(l);\n      end=s.upper_bound(r);\n      for(;it!=end;it++){\n        cout<<(*it)<<endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  set<int> S;\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++){\n    int t;\n    cin >> t;\n    if (t == 0){\n      int x;\n      cin >> x;\n      S.insert(x);\n      cout << S.size() << endl;\n    }\n    if (t == 1){\n      int x;\n      cin >> x;\n      if (S.count(x)){\n        cout << 1 << endl;\n      } else {\n        cout << 0 << endl;\n      }\n    }\n    if (t == 2){\n      int x;\n      cin >> x;\n      S.erase(x);\n    }\n    if (t == 3){\n      int L, R;\n      cin >> L >> R;\n      auto itr = S.lower_bound(L);\n      while (*itr <= R && itr != S.end()){\n        cout << *itr << endl;\n        itr++;\n        if (R < *itr){\n          break;\n        }\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int q;\n    cin >> q;\n    set<int> s;\n    for(int i=0; i<q; i++){\n        int a, x;\n        cin >> a >> x;\n        if(a == 0){\n            s.insert(x);\n            cout << s.size() << endl;\n        }else if(a == 1){\n            cout << s.count(x) << endl;\n        }else if(a == 2){\n            s.erase(x);\n        }else{\n            int y;\n            cin >> y;\n            auto first = s.lower_bound(x);\n            auto last = s.upper_bound(y);\n            for(auto itr = first; itr != last; ++itr) {\n                cout << *itr << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void){\n    set<int> S;\n    set<int>::iterator begin,end;\n    int q;\n    cin >> q;\n\n    for(int i=0; i<q; i++){\n        int cmd;\n        cin >> cmd;\n        if(cmd==0){\n            int x;\n            cin >> x;\n            S.insert(x);\n            cout << S.size() << \"\\n\";\n        }\n        else if(cmd==1){\n            int x;\n            cin >> x;\n            if(S.find(x) != S.end()){\n                cout << 1 << \"\\n\";\n            }\n            else{\n                cout << 0 << \"\\n\";\n            }\n        }\n        else if(cmd==2){\n            int x;\n            cin >> x;\n            S.erase(x);\n        }\n        else if(cmd==3){\n            int L,R;\n            cin >> L >> R;\n            begin = S.lower_bound(L);\n            end = S.upper_bound(R);\n            for(; begin!=end; begin++){\n                cout << *begin << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int num_query; cin >> num_query;\n  set<int> integers;\n  \n  for (int i = 0; i < num_query; i++) {\n    int command, x; scanf(\"%d %d\", &command, &x);\n    \n    switch (command) {\n      case 0:\n        integers.insert(x);\n        printf(\"%d\\n\", integers.size());\n        break;\n        \n      case 1:\n        printf(\"%d\\n\", integers.count(x));\n        break;\n        \n      case 2:\n        integers.erase(x);\n        break;\n        \n      case 3:\n        int y; scanf(\"%d\", &y);\n        set<int>::iterator it = integers.lower_bound(x);\n        set<int>::iterator last = integers.upper_bound(y);\n        while (it != last) {\n          printf(\"%d\\n\", *it);\n          it++;\n        }\n        break;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\n  int q;\n  set <int> a;\n  cin>>q;\n\n  for(int i=0;i<q;i++){\n    int n,x,y;\n    cin>>n>>x;\n    if(n==1) cout<<(a.end()!=a.find(x))<<endl;\n    else if(n==2) a.erase(x);\n    else if(n==3){\n      cin>>y;\n      auto it=lower_bound(a.begin(),a.end(),x);\n      do{\n\tcout<<*it<<endl;\n\tit++;\n      }while(it!=a.end()&&*it<=y);\n    }\n    else{\n      a.insert(x);\n      cout<<a.size()<<endl;\n    }\n  }\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\n  int q;\n  set <int> a;\n  cin>>q;\n\n  for(int i=0;i<q;i++){\n    int n,x,y;\n    cin>>n>>x;\n    if(n==1) cout<<(a.end()!=a.find(x))<<endl;\n    else if(n==2) a.erase(x);\n    else if(n==3){\n      cin>>y;\n      auto it=a.lower_bound(x);\n      do{\n\tprintf(\"%d\\n\",*it);\n\tit++;\n      }while(it!=a.end()&&*it<=y);\n    }\n    else{\n      a.insert(x);\n      cout<<a.size()<<endl;\n    }\n  }\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain() {\n  int q = in();\n  set<int> s;\n  while (q--) {\n    int t = in();\n    if (t == 0) {\n      s.emplace(in());\n      cout << s.size() << endl;\n    }\n    if (t == 1) cout << s.count(in()) << endl;\n    if (t == 2) s.erase(in());\n    if (t == 3) {\n      int l, r;\n      cin >> l >> r;\n      for (auto it = s.lower_bound(l), end = s.upper_bound(r); it != end; it++) cout << *it << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n\nint main() {\n\tint n;\n\tstd::cin >> n;\n\tstd::set<int> set;\n\tfor (auto i = 0; i < n; ++i) {\n\t\tint o, x, r;\n\t\tstd::cin >> o >> x;\n\t\tswitch (o) {\n\t\tcase 0: set.insert(x); std::cout << set.size() << std::endl; break;\n\t\tcase 1: std::cout << set.count(x) << std::endl; break;\n\t\tcase 2: set.erase(x); break;\n\t\tdefault:\n\t\t\tstd::cin >> r;\n\t\t\tauto end = set.upper_bound(r);\n\t\t\tfor (auto begin = set.lower_bound(x); begin != end; ++begin) {\n\t\t\t\tstd::cout << *begin << std::endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void) {\n    set<int> st;\n    int q,a,b,c;\n    cin >> q;\n    for (int i=0;i<q;i++) {\n        cin >> a;\n        if ( a==0 ) {\n            cin >> b;\n            st.insert(b);\n            cout << st.size() << endl;\n        } else if ( a==1 ) {\n            cin >> b;\n            auto itr = st.find(b);\n            if (itr!=st.end()) {\n                cout << 1 << endl;\n            } else {\n                cout << 0 << endl;\n            }\n        } else if ( a==2 ) {\n            cin >> b;\n            st.erase(b);\n        } else if ( a==3 ) {\n            cin >> b >> c;\n            auto itr1 = st.lower_bound(b);\n            auto itr2 = st.upper_bound(c);\n            for (itr1;itr1!=itr2;++itr1) {\n                cout << *itr1 << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\n\nint main() {\n\tint q;\n\tcin >> q;\n\tset<int> S;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint query;\n\t\tcin >> query;\n\t\tif (query == 0) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tS.insert(x);\n\t\t\tcout << S.size() << endl;\n\t\t}\n\t\telse if (query == 1) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tcout << S.count(x) << endl;\n\t\t}\n\t\telse if (query == 2) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tS.erase(x);\n\t\t}\n\t\telse {\n\t\t\tint L, R;\n\t\t\tcin >> L >> R;\n\t\t\tfor (auto i = S.lower_bound(L); i != S.upper_bound(R); ++i) cout << *i << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,i,c,x,y;\nset<int>S;\nmain()\n{\n  cin>>n;\n  for(i=0;i<n;i++)\n  {\n    cin>>c>>x;\n    if(c==1)cout<<(S.find(x)!=S.end())<<endl;\n    else if(c==0)S.insert(x),cout<<S.size()<<endl;\n    else if(c==2)S.erase(x);\n    else\n    {\n      cin>>y;\n      auto a=S.lower_bound(x),b=S.upper_bound(y);\n      for(auto it=a;it!=b;it++)cout<<*it<<endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <array>\n#include <queue>\n#include <deque>\n#include <set>\n#include <list>\n#include <map>\n#include <stack>\n#include <utility>\n#include <bitset>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <random>\n#include <functional>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); i++)\n#define FOR(i, m, n) for(int i=(m);i<(n);i++)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REVE(x) reverse((x).begin(),(x).end())\n#define mp make_pair\n#define pb push_back\n#define Cout(x) cout << (x) << endl\n#define Cout2(x, y) cout << (x) << \" \" << (y) << endl\n#define dump(x) cout << #x << \" = \" << (x) << endl;\n#define forauto(i, a) for(auto i : a)cout << i << \" \"; puts(\"\");\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<string> VS;\ntypedef vector<bool> VB;\ntypedef vector<vector<int>> VVI;\ntypedef pair<int, int> PII;\ntypedef pair<double, double> PDD;\ntypedef complex<double> CD;\n\nint main() {\n\tset<int> s;\n\tint q; cin >> q;\n\trep(i, q) {\n\t\tint t, x;\n\t\tcin >> t;\n\n\t\tswitch (t) {\n\t\tcase 0:\n\t\t\tcin >> x;\n\t\t\ts.insert(x);\n\t\t\tCout(sz(s));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcin >> x;\n\t\t\tCout(s.count(x));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcin >> x;\n\t\t\ts.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tint l, r; cin >> l >> r;\n\t\t\tauto it = s.lower_bound(l);\n\t\t\tauto last = s.upper_bound(r);\n\t\t\twhile (it != last) {\n\t\t\t\tCout(*it);\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\n\n//van Emde Boas trees 要素は正の整数\nclass VEBtree;\n\nclass VEBtreeNode{\n\tusing Number = unsigned long long;\n\tfriend VEBtree;\n\tconst Number K; //universe = 2 ^ K\n\tconst Number uppersqrt = (1 << ((K+1)/2)); //sqrt(ceil(universe/2))\n\tconst Number lowersqrt = (1 << (K/2));//sqrt(floor(universe/2))\n\tNumber min_, max_;\n\tstd::map<Number, VEBtreeNode> cluster;\n\tVEBtreeNode *summary = nullptr;\n\n\tNumber high(Number x){ return x/lowersqrt ;}\n\tNumber low(Number x){ return x % lowersqrt;}\n\tNumber index(Number x, Number y){ return x*lowersqrt + y;}\n\n\tNumber min()const{ return min_;}\n\tNumber max()const{ return max_;}\n\n\tbool empty()const{ return max() < min();}\n\n\tbool member(Number x){\n\t\tif(empty())return false;\n\t\tif(x == min() || x == max()) return true;\n\t\telse if(K == 1) return false;\n\t\tif(summary == nullptr || !summary->member(high(x))) return false;\n\t\treturn cluster.at(high(x)).member(low(x));\n\t}\n\n\tNumber successor(Number x){\n\t\tif(empty()) return x;\n\t\tif(K == 1){\n\t\t\tif(x == 0 && max() == 1) return 1;\n\t\t\telse return x;\n\t\t}\n\t\tif(x < min()) return min();\n\t\tif(summary == nullptr) return max();\n\t\tif(summary->member(high(x)) && low(x) < cluster.at(high(x)).max()){\n\t\t\tNumber offset = cluster.at(high(x)).successor(low(x));\n\t\t\treturn index(high(x), offset);\n\t\t}\n\t\tNumber succ_cluster = summary->successor(high(x));\n\t\tif(succ_cluster == high(x)) return x;\n\t\telse{\n\t\t\tNumber offset = cluster.at(succ_cluster).min();\n\t\t\treturn index(succ_cluster, offset);\n\t\t}\n\t}\n\n\tNumber predecessor(Number x){\n\t\tif(empty()) return x;\n\t\tif(K == 1){\n\t\t\tif(x == 1 && min() == 0) return 0;\n\t\t\telse return x;\n\t\t}\n\t\tif(max() < x) return max();\n\t\tif(summary == nullptr) return min();\n\t\tif(summary->member(high(x)) && cluster.at(high(x)).min() < low(x)){\n\t\t\tNumber offset = cluster.at(high(x)).predecessor(low(x));\n\t\t\treturn index(high(x), offset);\n\t\t}\n\t\tNumber pred_cluster = summary->predecessor(high(x));\n\t\tif(pred_cluster == high(x)){ return x;}\n\t\telse{\n\t\t\tNumber offset = cluster.at(pred_cluster).max();\n\t\t\treturn index(pred_cluster, offset);\n\t\t}\n\t}\n\n\tvoid empty_insert(Number x){\n\t\tmin_ = x; max_ = x;\n\t}\n\n\tvoid insert(Number x){\n\t\tif(empty()) empty_insert(x);\n\t\telse{\n\t\t\tif(x < min()) std::swap(x, min_);\n\t\t\tif(K > 1){\n\t\t\t\tif(summary == nullptr){\n\t\t\t\t\tsummary = new VEBtreeNode((K+1)/2, high(x));\n\t\t\t\t\tcluster.insert({high(x), VEBtreeNode(K/2, low(x))});\n\t\t\t\t}\n\t\t\t\telse if(!summary->member(high(x))){\n\t\t\t\t\tsummary->insert(high(x));\n\t\t\t\t\tcluster.insert({high(x), VEBtreeNode(K/2, low(x))});\n\t\t\t\t}\n\t\t\t\telse cluster.at(high(x)).insert(low(x));\n\t\t\t}\n\t\t\tif(x > max()){\n\t\t\t\tmax_ = x;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid erase(Number x){\n\t\tassert(!empty());\n\t\tif(min() == max()){\n\t\t\tmin_ = 1; max_ = 0;\n\t\t}\n\t\telse if(K == 1){\n\t\t\t\tif(x == 0) min_ = 1;\n\t\t\t\telse min_ = 0;\n\t\t\t\tmax_ = min_;\n\t\t}\n\t\telse{\n\t\t\tif(x == min()){\n\t\t\t\tNumber first_cluster = summary->min();\n\t\t\t\tx = index(first_cluster, cluster.at(first_cluster).min());\n\t\t\t\tmin_ = x;\n\t\t\t}\n\t\t\tcluster.at(high(x)).erase(low(x));\n\t\t\tif(cluster.at(high(x)).empty()){\n\t\t\t\tsummary->erase(high(x));\n\t\t\t\tcluster.erase(high(x));\n\t\t\t\tif(x == max()){\n\t\t\t\t\tif(summary->empty()){\n\t\t\t\t\t\tmax_ = min();\n\t\t\t\t\t\tdelete summary;\n\t\t\t\t\t\tsummary = nullptr;\n\t\t\t\t\t}\n\t\t\t\t\telse max_ = index(summary->max(), cluster.at(summary->max()).max());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(x == max()) max_ = index(high(x), cluster.at(high(x)).max());\n\t\t}\n\t}\n\n\tpublic:\n\tVEBtreeNode(Number k, Number x): K(k), min_(x), max_(x){}\n\t~VEBtreeNode(){\n\t\tdelete summary;\n\t}\n\tNumber getK()const{return K;}\n};\n\nclass VEBtree{\n\tusing Number = unsigned long long;\n\tconst Number K;\n\tVEBtreeNode *root;\n\tsize_t size_;\n\tpublic:\n\tVEBtree(): K(24), root(nullptr), size_(0){}\n\tVEBtree(Number universe): K(sizeof(Number)*8 - __builtin_clzll(universe)), root(nullptr), size_(0){}\n\t~VEBtree(){ delete root;}\n\n\tsize_t size()const{return size_;}\n\tNumber min(){ return root->min();}\n\tNumber max(){ return root->max();}\n\tbool member(Number e){\n\t\tif(size() == 0) return false;\n\t\treturn root->member(e);\n\t}\n\tNumber successor(Number e){\n\t\tif(size() == 0) return e;\n\t\treturn root->successor(e);\n\t}\n\tNumber predecessor(Number e){\n\t\tif(size() == 0) return e;\n\t\treturn root->predecessor(e);\n\n\t}\n\tvoid insert(Number e){\n\t\tif(size() == 0){\n\t\t\troot = new VEBtreeNode(K, e);\n\t\t\tsize_++;\n\t\t}\n\t\telse if(!member(e)){\n\t\t\troot->insert(e);\n\t\t\tsize_++;\n\t\t}\n\t}\n\tvoid erase(Number e){\n\t\tif(member(e)){\n\t\t\troot->erase(e);\n\t\t\tsize_--;\n\t\t}\n\t}\n};\n/*\nsigned main(){\n\tusing namespace std;\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tVEBtree t((unsigned ll)1e9);\n\tfor(int i = 0; i < n; i++){\n\t\tint q;cin >> q;\n\t\tunsigned long long x, y, prev; cin >> x;\n\t\tswitch(q){\n\t\t\tcase 0:\n\t\t\t\tt.insert(x);\n\t\t\t\tcout << t.size() << \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcout << t.member(x) << \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n//\t\t\t\tcerr << \"erase, \" << x << \"\\n\";\n\t\t\t\tt.erase(x);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcin >> y; y++;\n\t\t\t\tx = t.member(x) ? x : t.successor(x);\n\t\t\t\tif(t.size() > 0 && x < y && t.member(x)){\n\t\t\t\t\tdo{\n\t\t\t\t\t\tprev = x;\n\t\t\t\t\t\tcout << x << \"\\n\";\n\t\t\t\t\t\tx = t.successor(x);\n\t\t\t\t\t}while(prev != x && x < y);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tcin >> y;\n\t\t\t\ty = t.member(y) ? y : t.predecessor(y);\n\t\t\t\tif(t.size() > 0){\n\t\t\t\t\tdo{\n\t\t\t\t\t\tprev = y;\n\t\t\t\t\t\tcout << y << \"\\n\";\n\t\t\t\t\t\ty = t.predecessor(y);\n\t\t\t\t\t}while(prev != y && x <= y);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tcout << t.successor(x) << \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tcout << t.predecessor(x) << \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tcout << t.min() << \":\" << t.max() << \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t{\n\t\tunsigned ll i = t.min(),prev;\n\t\tdo{\n\t\t\tprev = i;\n\t\t\ti = t.successor(i);\n\t\t}while(i != prev);\n\t}\n\n\n\treturn 0;\n}\n*/\n\n\nsigned main(){\n\tusing namespace std;\n\tint n; scanf(\"%d\", &n);\n\tVEBtree t((unsigned ll)1e9);\n\tfor(int i = 0; i < n; i++){\n\t\tint q;scanf(\"%d\",&q);\n\t\tunsigned long long x, y, prev;scanf(\"%d\", &x);\n\t\tswitch(q){\n\t\t\tcase 0:\n\t\t\t\tt.insert(x);\n\t\t\t\tprintf(\"%d\\n\", t.size());\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tprintf(\"%d\\n\", t.member(x));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n//\t\t\t\tcerr << \"erase, \" << x << \"\\n\";\n\t\t\t\tt.erase(x);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tscanf(\"%d\", &y);\n\t\t\t\ty++;\n\t\t\t\tx = t.member(x) ? x : t.successor(x);\n\t\t\t\tif(t.size() > 0 && x < y && t.member(x)){\n\t\t\t\t\tdo{\n\t\t\t\t\t\tprev = x;\n\t\t\t\t\t\tprintf(\"%d\\n\", x);\n\t\t\t\t\t\tx = t.successor(x);\n\t\t\t\t\t}while(prev != x && x < y);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tscanf(\"%d\", &y);\n\t\t\t\ty = t.member(y) ? y : t.predecessor(y);\n\t\t\t\tif(t.size() > 0){\n\t\t\t\t\tdo{\n\t\t\t\t\t\tprev = y;\n\t\t\t\t\t\tprintf(\"%d\\n\", y);\n\t\t\t\t\t\ty = t.predecessor(y);\n\t\t\t\t\t}while(prev != y && x <= y);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tprintf(\"%d\\n\", t.successor(x));\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tprintf(\"%d\\n\", t.predecessor(x));\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tprintf(\"%d : %d\\n\", t.min(), t.max());\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t{\n\t\tunsigned ll i = t.min(),prev;\n\t\tdo{\n\t\t\tprev = i;\n\t\t\ti = t.successor(i);\n\t\t}while(i != prev);\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx,ssse3,sse4a\")\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass vanEmdeBoasTree\n{\nprivate:\n    static const size_t LENGTH = 1073741824;\n    size_t _size;\n    #define msb(u) (63 - __builtin_clzll(u))\n    #define lsb(u) (__builtin_ctzll(u))\n    struct first_layer;\n    struct middle_layer;\n    struct last_layer;\n    struct first_layer {\n        unsigned long long *data;\n        middle_layer *summary;\n        int _max, _min;\n        first_layer() : _max(-1), _min(1073741824){\n            data = new unsigned long long[16777216](), summary = new middle_layer();\n        }\n        first_layer(const first_layer& another) : _max(another._max), _min(another._min){\n            data = new unsigned long long[16777216];\n            for(unsigned int i = 0; i < 16777216; ++i) data[i] = another.data[i];\n            summary = new middle_layer(*another.summary);\n        }\n        first_layer(first_layer&& another)\n            : _max(move(another._max)), _min(move(another._min)){\n            data = another.data, summary = another.summary;\n            data = nullptr, summary = nullptr;\n        }\n        first_layer& operator=(const first_layer& another){\n            this->~first_layer();\n            _max = another._max, _min = another._min;\n            data = new unsigned long long[16777216];\n            for(unsigned int i = 0; i < 16777216; ++i) data[i] = another.data[i];\n            summary = new middle_layer(*another.summary);\n            return *this;\n        }\n        first_layer& operator=(first_layer&& another){\n            this->~first_layer();\n            _max = move(another._max), _min = move(another._min);\n            data = another.data, summary = another.summary;\n            data = nullptr, summary = nullptr;\n            return *this;\n        }\n        // ~first_layer(){\n        //     delete summary;\n        //     delete[] data;\n        // }\n        inline bool empty() const noexcept { return (_max == -1); }\n        inline bool isOne() const noexcept { return (_max == _min); }\n        inline int max() const noexcept { return _max; }\n        inline int min() const noexcept { return _min; }\n        bool find(const int value) const noexcept {\n            return (value == _min) || ((data[value >> 6] >> (value & 63)) & 1ULL);\n        }\n        bool insert(int value) noexcept {\n            if(value == _min) return false;\n            else if(_max == -1) return _max = _min = value, true;\n            else if(value < _min) swap(value, _min);\n            else if(value > _max) _max = value;\n            const int id = (value >> 6);\n            if((data[id] >> (value & 63)) & 1ULL) return false;\n            else{\n                if(data[id] == 0) summary->insert(id);\n                data[id] ^= (1ULL << (value & 63));\n                return true;\n            }\n        }\n        void erase(int value) noexcept {\n            if(_max == _min){\n                _max = -1, _min = 1073741824;\n                return;\n            }else if(value == _min){\n                const int id = summary->min();\n                 _min = value = (id << 6) + lsb(data[id]);\n            }\n            const int id = (value >> 6);\n            data[id] ^= (1ULL << (value & 63));\n            if(data[id] == 0) summary->erase(id);\n            if(value == _max){\n                if(summary->empty()) _max = _min;\n                else{\n                    const int id = summary->max();\n                    _max = (id << 6) + msb(data[id]);\n                }\n            }\n        }\n        int predecessor(const int value) const noexcept {\n            if(_min >= value) return -1;\n            else if(value > _max) return _max;\n            const int id = (value >> 6), sm = (id << 6);\n            if(data[id] && value > sm + lsb(data[id]))\n                return sm + msb(data[id] & ((1ULL << (value & 63)) - 1ULL));\n            else{\n                const int id2 = summary->predecessor(id);\n                return (id2 >= 0) ? ((id2 << 6) + msb(data[id2])) : _min;\n            }\n        }\n        int successor(const int value) const noexcept {\n            if(value < _min) return _min;\n            else if(value >= _max) return 1073741824;\n            const int id = (value >> 6), sm = (id << 6);\n            if(data[id] && value < sm + msb(data[id]))\n                return sm + lsb(data[id] & ~((1ULL << ((value & 63) + 1)) - 1ULL));\n            else{\n                const int id2 = summary->successor(id);\n                return (id2 << 6) + lsb(data[id2]);\n            }\n        }\n    };\n    struct middle_layer{\n        last_layer *sublayers, *summary;\n        int _max, _min;\n        middle_layer() : _max(-1), _min(16777216){\n            sublayers = new last_layer[4096](), summary = new last_layer();\n        }\n        middle_layer(const middle_layer& another) : _max(another._max), _min(another._min){\n            sublayers = new last_layer[4096];\n            for(unsigned int i = 0; i < 4096; ++i)\n                sublayers[i] = last_layer(another.sublayers[i]);\n            summary = new last_layer(*another.summary);\n        }\n        middle_layer(middle_layer&& another)\n            : _max(move(another._max)), _min(move(another._min)){\n            sublayers = another.sublayers, summary = another.summary;\n            another.sublayers = another.summary = nullptr;\n        }\n        middle_layer& operator=(const middle_layer& another){\n            this->~middle_layer();\n            _max = another._max, _min = another._min;\n            sublayers = new last_layer[4096];\n            for(unsigned int i = 0; i < 4096; ++i)\n                sublayers[i] = last_layer(another.sublayers[i]);\n            summary = new last_layer(*another.summary);\n            return *this;\n        }\n        middle_layer& operator=(middle_layer&& another){\n            this->~middle_layer();\n            _max = move(another._max), _min = move(another._min);\n            sublayers = another.sublayers, summary = another.summary;\n            another.sublayers = another.summary = nullptr;\n            return *this;\n        }\n        // ~middle_layer(){\n        //     delete summary;\n        //     delete[] sublayers;\n        // }\n        inline bool empty() const noexcept { return (_max == -1); }\n        inline bool isOne() const noexcept { return (_max == _min); }\n        inline int max() const noexcept { return _max; }\n        inline int min() const noexcept { return _min; }\n        bool insert(int value) noexcept {\n            if(value == _min) return false;\n            else if(_max == -1) return _max = _min = value, true;\n            else if(value < _min) swap(value, _min);\n            else if(value > _max) _max = value;\n            const int id = (value >> 12);\n            if(sublayers[id].insert(value & 4095)){\n                if(sublayers[id].isOne()) summary->insert(id);\n                return true;\n            }else return false;\n        }\n        void erase(int value) noexcept {\n            if(_max == _min){\n                _max = -1, _min = 16777216;\n                return;\n            }else if(value == _min){\n                const int id = summary->min();\n                 _min = value = (id << 12) + sublayers[id].min();\n            }\n            const int id = (value >> 12);\n            sublayers[id].erase(value & 4095);\n            if(sublayers[id].empty()) summary->erase(id);\n            if(value == _max){\n                if(summary->empty()) _max = _min;\n                else{\n                    const int id = summary->max();\n                    _max = (id << 12) + sublayers[id].max();\n                }\n            }\n        }\n        int predecessor(const int value) const noexcept {\n            if(_min >= value) return -1;\n            else if(value > _max) return _max;\n            const int id = (value >> 12), sm = (id << 12);\n            if(value > sm + sublayers[id].min()){\n                return sm + sublayers[id].predecessor(value & 4095);\n            }else{\n                const int id2 = summary->predecessor(id);\n                return (id2 >= 0) ? ((id2 << 12) + sublayers[id2].max()) : _min;\n            }\n        }\n        int successor(const int value) const noexcept {\n            if(value < _min) return _min;\n            else if(value >= _max) return 16777216;\n            const int id = (value >> 12), sm = (id << 12);\n            if(value < sm + sublayers[id].max()){\n                return sm + sublayers[id].successor(value & 4095);\n            }else{\n                const int id2 = summary->successor(id);\n                return (id2 << 12) + sublayers[id2].min();\n            }\n        }\n    };\n    struct last_layer{\n        unsigned long long data[64], summary;\n        int _max, _min;\n        last_layer() noexcept : summary(0ULL), _max(-1), _min(4096){\n            memset(data, 0, sizeof(data));\n        }\n        inline bool empty() const noexcept { return (_max == -1); }\n        inline bool isOne() const noexcept { return (_max == _min); }\n        inline int max() const noexcept { return _max; }\n        inline int min() const noexcept { return _min; }\n        bool insert(int value) noexcept {\n            if(value == _min) return false;\n            else if(_max == -1) return _max = _min = value, true;\n            else if(value < _min) swap(value, _min);\n            else if(value > _max) _max = value;\n            const int id = (value >> 6);\n            if((data[id] >> (value & 63)) & 1ULL) return false;\n            else{\n                data[id] ^= (1ULL << (value & 63)), summary |= (1ULL << id);\n                return true;\n            }\n        }\n        void erase(int value) noexcept {\n            if(_max == _min){\n                _max = -1, _min = 4096;\n                return;\n            }else if(value == _min){\n                const int id = lsb(summary);\n                _min = value = (id << 6) + lsb(data[id]);\n            }\n            const int id = (value >> 6);\n            data[id] ^= (1ULL << (value & 63));\n            if(data[id] == 0) summary ^= (1ULL << id);\n            if(value == _max){\n                if(summary == 0) _max = _min;\n                else{\n                    const int id = msb(summary);\n                    _max = (id << 6) + msb(data[id]);\n                }\n            }\n        }\n        int predecessor(const int value) const noexcept {\n            if(_min >= value) return -1;\n            else if(value > _max) return _max;\n            const int id = (value >> 6), sm = (id << 6);\n            if(data[id] && value > sm + lsb(data[id]))\n                return sm + msb(data[id] & ((1ULL << (value & 63)) - 1ULL));\n            else{\n                const unsigned long long tmp = (summary & ((1ULL << id) - 1ULL));\n                if(tmp == 0ULL) return _min;\n                else{\n                    const int id2 = msb(tmp);\n                    return (id2 << 6) + msb(data[id2]);\n                }\n            }\n        }\n        int successor(const int value) const noexcept {\n            if(value < _min) return _min;\n            else if(value >= _max) return 4096;\n            const int id = (value >> 6), sm = (id << 6);\n            if(data[id] && value < sm + msb(data[id]))\n                return sm + lsb(data[id] & ~((1ULL << ((value & 63) + 1)) - 1ULL));\n            else{\n                const int id2 = lsb(summary & ~((1ULL << (id + 1)) - 1ULL));\n                return (id2 << 6) + lsb(data[id2]);\n            }\n        }\n    };\n    first_layer base_layer;\npublic:\n    vanEmdeBoasTree() : _size(0), base_layer(){}\n    vanEmdeBoasTree(const vanEmdeBoasTree&) = default;\n    vanEmdeBoasTree(vanEmdeBoasTree&&) = default;\n    vanEmdeBoasTree& operator=(const vanEmdeBoasTree&) = default;\n    vanEmdeBoasTree& operator=(vanEmdeBoasTree&&) = default;\n    friend ostream& operator<< (ostream& os, vanEmdeBoasTree& veb) noexcept {\n        for(unsigned int st = veb.successor(-1); st != veb.LENGTH; st = veb.successor(st))\n            os << st << \" \";\n        return os;\n    }\n    bool empty() const noexcept { return (_size == 0); }\n    size_t size() const noexcept { return _size; }\n    size_t max_size() const noexcept { return LENGTH; }\n    bool find(const unsigned int value) const noexcept {\n        if(value >= LENGTH) return false;\n        return base_layer.find(value);\n    }\n    size_t count(const unsigned int value) const noexcept {\n        return find(value);\n    }\n    int max() const noexcept { return base_layer.max(); }\n    int min() const noexcept { return base_layer.min(); }\n    void insert(const unsigned int value){\n        assert(value < LENGTH);\n        _size += base_layer.insert(value);\n    }\n    void erase(const unsigned int value){\n        assert(value < LENGTH);\n        base_layer.erase(value), --_size;\n    }\n    int predecessor(const int value) const noexcept {\n        return base_layer.predecessor(value);\n    }\n    int successor(const int value) const noexcept {\n        return base_layer.successor(value);\n    }\n};\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline unsigned int in() {\n    unsigned int n = 0; unsigned short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(unsigned int n) {\n    static unsigned short res[10], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\nint main()\n{\n    vanEmdeBoasTree veb;\n    unsigned int n = in(), a, b, st;\n    rep(i,n){\n        a = in();\n        if(a == 0){\n            veb.insert(in());\n            out(veb.size());\n        }else if(a == 1){\n            out(veb.find(in()));\n        }else if(a == 2){\n            a = in();\n            if(veb.find(a)) veb.erase(a);\n        }else{\n            a = in(), b = in();\n            for(st = veb.successor(a-1); st <= b; st = veb.successor(st))\n                out(st);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  \n  int q, com, x, l, r;\n  set<int> S;\n  \n  cin >> q;\n  for(int i = 0;i < q;i++){\n    cin >> com;\n    \n    if(com == 0){\n      cin >> x;\n      S.insert(x);\n      cout << S.size() << endl;\n    }else if(com == 1){\n      cin >> x;\n      cout << S.count(x) << endl;\n    }else if(com == 2){\n      cin >> x;\n      S.erase(x);\n    }else if(com == 3){\n      set<int>::iterator itl, itr;\n      \n      cin >> l >> r;\n      itl = S.lower_bound(l);\n      itr = S.upper_bound(r);\n      \n      for(set<int>::iterator it = itl;it != itr;it++) cout << *it << endl;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n    set<int> s;\n    int q;\n    cin>>q;\n    while(q--)\n    {\n        int c,t;\n        cin>>c>>t;\n        if(c==0) \n        {\n            s.insert(t);\n            cout<<s.size()<<endl;\n        }\n        else if(c==1) \n        {\n            cout<<s.count(t)<<endl;\n        }\n        else if(c==2)\n        {\n            s.erase(t);\n        }\n        else\n        {\n            int R;\n            cin>>R;\n            auto its=s.lower_bound(t);\n            auto ite=s.upper_bound(R);\n            for(auto it=its;it!=ite;it++)\n            {\n                cout<<*it<<endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n    set<int> s;\n    int q; cin >> q;\n    while (q--) {\n        int com, x; cin >> com >> x;\n        if (com == 0) {\n            s.emplace(x);\n            cout << s.size() << endl;\n        } else if (com == 1) {\n            cout << s.count(x) << endl;\n        } else if (com == 2) {\n            s.erase(x);\n        } else if (com == 3) {\n            int y; cin >> y;\n            auto it = s.lower_bound(x);\n            while (it != s.end() && *it <= y) {\n                cout << *it << endl;\n                it++;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n#include <list>\n#include <set>\n#include <stack>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\n/* typedef */\n\ntypedef long long ll;\n\n/* constant */\n\nconst int INF = 1 << 30;\nconst int MAX = 10000;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\n/* global variables */\n\n/* function */\nvoid printAns(bool can);\n\n/* main */\nint main(){\n    int q, option, num, num2; \n    set<int> S;\n    cin >> q;\n    for (int i  = 0; i < q; i++) {\n        cin >> option >> num;\n        switch(option) {\n        case 0:\n            // insert\n            S.insert(num);\n            cout << S.size() << '\\n';\n            break;\n        case 1:\n            // find\n            cout << S.count(num) << '\\n';\n            break;\n        case 2:\n            // delete\n            S.erase(num);\n            break;\n        case 3:\n            cin >> num2;\n            set<int>::iterator it = S.lower_bound(num);\n            set<int>::iterator last = S.upper_bound(num2);\n            for (; it != last ; it++)\n                cout << *it << '\\n';\n        }\n    }\n}\n\n\nvoid printAns(bool can) {\n    if (can) cout << 1 << '\\n';\n    else cout << 0 << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsigned main(){\n\n  int q;\n  cin>>q;\n  set<int> s;\n  while(q--){\n    int c,x;\n    cin>>c>>x;\n    if(c==0){\n      s.insert(x);\n      cout<< s.size() <<endl;\n    }\n    else if(c==1){\n      cout<< s.count(x) <<endl;\n    }\n    else if(c==2){\n      s.erase(x);\n    }\n    else if(c==3){\n      int y;\n      cin>>y;\n      auto itr = s.lower_bound(x);\n      auto end = s.upper_bound(y);\n      while(itr!=end){\n        cout<<*itr<<endl;\n        itr++;\n      }\n    }\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\nint n;\nset<int>S;\nmain()\n{\n  cin>>n;\n  for(int i=0;i<n;i++)\n  {\n    int c,x;cin>>c>>x;\n    if(c==1)cout<<(S.find(x)!=S.end())<<endl;\n    else if(c==0)S.insert(x),cout<<S.size()<<endl;\n    else if(c==2)S.erase(x);\n    else\n    {\n      int y;cin>>y;\n      auto a=S.lower_bound(x),b=S.upper_bound(y);\n      for(auto it=a;it!=b;it++)cout<<*it<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cassert>\n#include <climits>\n#include <string>\n#include <bitset>\n#include <cfloat>\n#include <random>\n#include <iomanip>\n#include <unordered_set>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntypedef long double ld;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<ll> vll;\ntypedef vector<pair<int,int> > vpii;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<ll> > vvll;\ntypedef map<int, int> mii;\ntypedef set<int> si;\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)\n#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define fin(ans) cout << (ans) << '\\n'\n#define STLL(s) strtoll(s.c_str(), NULL, 10)\n#define mp(p,q) make_pair(p, q)\n#define pb(n) push_back(n)\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define Sort(a) sort(a.begin(), a.end())\n#define Rort(a) sort(a.rbegin(), a.rend())\n#define MATHPI acos(-1)\n#define itn int\n#define endl '\\n';\n#define fi first\n#define se second\n#define NONVOID [[nodiscard]]\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}\ninline string getline(){string s; getline(cin,s); return s;}\ninline void yn(const bool b){b?fin(\"yes\"):fin(\"no\");}\ninline void Yn(const bool b){b?fin(\"Yes\"):fin(\"No\");}\ninline void YN(const bool b){b?fin(\"YES\"):fin(\"NO\");}\nstruct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};\nconst int INF = INT_MAX;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\n\n\n\n\nint main() {\n    set<ll> s;\n    ll q,x;\n    ll n;\n    cin>>n;\n    rep(i,n){\n        scanf(\"%lld %lld\",&q,&x);\n        if(q==1){\n            fin(s.count(x));\n        } else if(q==0){\n            s.insert(x);\n            fin(s.size());\n        }\n        else if(q==2){\n            s.erase((x));\n        } else {\n            int r;\n            cin>>r;\n            for(auto i=s.lower_bound(x);i!=s.end()&&*i<=r;i++){\n                if(*i>=x)cout<<*i<<endl;\n            }\n        }\n        \n    }\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    set <int> m;\n    int q;\n    cin>>q;\n    while(q--)\n    {\n        int a;\n        cin>>a;\n        if(a==0)\n        {\n            int x;\n            cin>>x;\n            m.emplace(x);\n            cout<<m.size()<<endl;\n        }\n        else if(a==1)\n        {\n            int x;\n            cin>>x;\n            cout<<m.count(x)<<endl;\n        }\n        else if(a==2)\n        {\n            int x;\n            cin>>x;\n            m.erase(x);\n        }\n        else\n        {\n            int l,r;\n            cin>>l>>r;\n            auto p=m.lower_bound(l);\n            while(p!=m.end()&&*p<=r)\n            {\n                cout<<*p<<endl;\n                p++;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main()\n{\n\tset<int> cpp;\n\tint q, com, o, r;\n\tscanf(\"%d\", &q);\n\n\twhile (q--)\n\t{\n\t\t\n\t\tscanf(\"%d%d\", &com,&o);\n\t\tswitch (com)\n\t\t{\n\t\tcase 0:\n\t\t\tcpp.insert(o);\n\t\t\tprintf(\"%d\\n\", cpp.size());\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tprintf(\"%d\\n\", cpp.count(o));\n\t\t\tbreak;\n\t\t\t\n\t\tcase 2:\n\t\t\tcpp.erase(o);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t\tscanf(\"%d\", &r);\n\t\t\t\tset<int>::iterator prev = cpp.lower_bound(o);\n\t\t\t\tset<int>::iterator next = cpp.upper_bound(r);\n\t\t\t\twhile (prev != next)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\", *prev);\n\t\t\t\t\tprev++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    set<int> st;\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int op, x;\n        cin >> op >> x;\n\n        switch (op) {\n            case 0:\n                st.insert(x);\n                cout << st.size() << endl;\n                break;\n            case 1:\n                cout << st.count(x) << endl;\n                break;\n            case 2:\n                st.erase(x);\n                break;\n            case 3:\n                int r;\n                cin >> r;\n                for (auto itr = st.lower_bound(x); itr != st.end() and *itr <= r; ++itr) {\n                    cout << *itr << endl;\n                }\n                break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nsigned main(){\n\tint q;\n\tset<int>s;\n\tcin>>q;\n\twhile(q--){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(x==1)cout<<s.count(y)<<endl;\n\t\telse if(!x){\n\t\t\ts.insert(y);\n\t\t\tcout<<s.size()<<endl;\n\t\t}\n\t\telse if(x==2)s.erase(y);\n\t\telse{\n\t\t\tint l=y,r;\n\t\t\tcin>>r;\n\t\t\tset<int>::iterator end,it;\n\t\t\tit=s.lower_bound(l);\n\t\t\tend=s.upper_bound(r);\n\t\t\tfor(;it!=end;it++){\n\t\t\t\tcout<<(*it)<<endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main() {\n    int q;\n    std::cin >> q;\n\n    std::set<int> S;\n    for (int i = 0; i < q; i++) {\n        int op;\n        std::cin >> op;\n        if (op == 0) {\n            int x;\n            std::cin >> x;\n            S.insert(x);\n            std::cout << S.size() << std::endl;\n        } else if (op == 1) {\n            int x;\n            std::cin >> x;\n            std::cout << (int)(S.find(x) != S.end()) << std::endl;\n        } else if (op == 2) {\n            int x;\n            std::cin >> x;\n            S.erase(x);\n        } else if (op == 3) {\n            int L, R;\n            std::cin >> L >> R;\n            auto begin = S.lower_bound(L);\n            auto end = S.upper_bound(R);\n            for (auto it = begin; it != end; it++) {\n                std::cout << *it << std::endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  int cmd, val;\n  int lhd, rhd;\n\n  set<int> s;\n  set<int>::iterator it;\n  for (int i = 0; i < n; i++) {\n    cin >> cmd;\n    switch (cmd) {\n      case 0:\n        cin >> val;\n        s.insert(val);\n        cout << s.size() << endl;\n        break;\n\n      case 1:\n        cin >> val;\n        it = s.find(val);\n\n        if (it != s.end() && *it == val) {\n          cout << 1 << endl;\n\n        } else {\n          cout << 0 << endl;\n        }\n        break;\n\n      case 2:\n        cin >> val;\n        it = s.find(val);\n        if (it != s.end()) {\n          s.erase(it);\n        }\n        break;\n\n      case 3:\n        cin >> lhd >> rhd;\n\n        for (auto itr = s.lower_bound(lhd); itr != s.end() && *itr <= rhd; itr++) {\n          cout << *itr << endl;\n        }\n        break;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nint main() {\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tint q;\n\tstd::cin >> q;\n\tstd::set<int> set;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint t, x;\n\t\tstd::cin >> t >> x;\n\t\tswitch (t) {\n\t\tcase 0: set.insert(x);\n\t\t\tstd::cout << set.size() << '\\n';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstd::cout << set.count(x) << '\\n';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tset.erase(x);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cin >> t;\n\t\t\tauto b = std::lower_bound(set.begin(), set.end(), x);\n\t\t\tauto e = std::upper_bound(set.begin(), set.end(), t);\n\t\t\tfor (; b != e; ++b) {\n\t\t\t\tstd::cout << *b << '\\n';\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n#define p_yes() p(\"Yes\")\n#define p_no() p(\"No\")\n\nint main(){\n    ll Q;\n    cin >> Q;\n\n    set<ll> se;\n\n    while(Q--){\n        ll a, x;\n        cin >> a >> x;\n\n        if(a==0){\n            // insert\n            se.insert(x);\n            p(se.size());\n        }\n        else if(a==1){\n            // find\n            p(se.count(x));\n        }\n        else if(a==2){\n            // delete\n            se.erase(x);\n        }\n        else{\n            // dump\n            ll L = x;\n            ll R; cin >> R;\n\n            auto it = se.lower_bound(L);\n            auto it2 = se.upper_bound(R);\n            for(; it!=it2; it++){\n                p(*it);\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\n  int q;\n  set <int> a;\n  cin>>q;\n\n  for(int i=0;i<q;i++){\n    int n,x,y;\n    cin>>n>>x;\n    if(n==1) cout<<(a.end()!=a.find(x))<<endl;\n    else if(n==2) a.erase(x);\n    else if(n==3){\n      cin>>y;\n      auto it=a.lower_bound(x);\n      do{\n\tcout<<*it<<endl;\n\tadvance(it,1);\n      }while(it!=a.end()&&*it<=y);\n    }\n    else{\n      a.insert(x);\n      cout<<a.size()<<endl;\n    }\n  }\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i, n, m) for (int i = (int) (n); i < (int) (m); i++)\n#define rep(i, n) reps(i, 0, (n))\n#define all(v) (v).begin(), (v).end()\n\nint main() {\n    int q; cin >> q;\n    set<int> s;\n    while (q--) {\n        int a, x; cin >> a >> x;\n        if (a == 0) {\n            s.insert(x); cout << s.size() << endl;\n            \n        } else if (a == 1) {\n            cout << s.count(x) << endl;\n        } else if (a == 2) {\n            s.erase(x);\n        } else {\n            int y; cin >> y;\n            auto b = s.lower_bound(x);\n            auto e = s.upper_bound(y);\n            for (auto i = b; i != e; i++) {\n                cout << *i << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 1000000000000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nset<int> SET;\n\nint main(){\n\n\tint num_query;\n\tscanf(\"%d\",&num_query);\n\n\tint command;\n\tint x,L,R;\n\n\tfor(int loop = 0; loop < num_query; loop++){\n\n\t\tscanf(\"%d\",&command);\n\n\t\tswitch(command){\n\n\t\tcase 0:\n\n\t\t\tscanf(\"%d\",&x);\n\t\t\tSET.insert(x);\n\t\t\tprintf(\"%lld\\n\",SET.size());\n\t\t\tbreak;\n\n\t\tcase 1:\n\n\t\t\tscanf(\"%d\",&x);\n\t\t\tprintf(\"%lld\\n\",SET.count(x));\n\t\t\tbreak;\n\n\t\tcase 2:\n\n\t\t\tscanf(\"%d\",&x);\n\t\t\tSET.erase(x);\n\t\t\tbreak;\n\n\t\tcase 3:\n\n\t\t\tscanf(\"%d %d\",&L,&R);\n\n\t\t\tauto at = SET.lower_bound(L);\n\n\t\t\twhile(at != SET.end() && *at <= R){\n\n\t\t\t\tprintf(\"%d\\n\",*at);\n\t\t\t\tat++;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nint main() {\n\tint q;\n\tstd::cin >> q;\n\tstd::set<int> set;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint t, x;\n\t\tstd::cin >> t >> x;\n\t\tswitch (t) {\n\t\tcase 0: set.insert(x);\n\t\t\tstd::cout << set.size() << std::endl;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstd::cout << set.count(x) << std::endl;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tset.erase(x);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cin >> t;\n\t\t\tauto b = std::lower_bound(set.begin(), set.end(), x);\n\t\t\tauto e = std::upper_bound(set.begin(), set.end(), t);\n\t\t\tfor (; b != e; ++b) {\n\t\t\t\tstd::cout << *b << '\\n';\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int q; cin >> q;\n  set<int> st;\n  for (int i = 0; i < q; i++) {\n    int cmd; cin >> cmd;\n    if (cmd == 0) {\n      int x; cin >> x;\n      st.insert(x);\n      cout << st.size() << endl;\n    }\n    if (cmd == 1) {\n      int x; cin >> x;\n      cout << st.count(x) << endl;\n    }\n    if (cmd == 2) {\n      int x; cin >> x;\n      st.erase(x);\n    }\n    if (cmd == 3) {\n      int l, r; cin >> l >> r;\n      for (auto itr = st.lower_bound(l), end = st.upper_bound(r); itr != end; itr++) {\n        cout << *itr << endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n    int num_query,command,val,val2;\n    scanf(\"%d\",&num_query);\n    set<int> int_set;\n    set<int>::iterator itr;\n    \n    for(int i = 0;i < num_query;i++){\n        scanf(\"%d %d\",&command,&val);\n        if(command == 0){\n            int_set.insert(val);\n            printf(\"%d\\n\",int_set.size());\n        }else if(command == 1){\n            itr = int_set.find(val);\n            if(int_set.end() == itr) printf(\"0\\n\");\n            else printf(\"1\\n\");\n        }else if(command == 2){\n            itr = int_set.find(val);\n            if(int_set.end() != itr) int_set.erase(itr);\n        }else if(command == 3){\n            scanf(\"%d\",&val2);\n            itr = int_set.lower_bound(val);\n            while(int_set.end() != itr && *itr <= val2){\n                printf(\"%d\\n\",*itr);\n                itr++;\n            }\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n \nusing namespace std;\n \ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n \ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n  \n\tset<int> s;\n\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tint op, el;\n\t\tcin >> op >> el;\n\t\tif(op == 1)cout << s.count(el) << '\\n';\n\t\telse if(op == 2)s.erase(el);\n\t\telse if(op == 3){\n\t\t\tint r;cin >> r;\n\t\t\tauto lef = s.lower_bound(el);\n\t\t\tauto right = s.upper_bound(r);\n\t\t\twhile(lef != right)cout << *lef << '\\n', lef++;\n\t\t\t\n\t\t}\n\t\telse s.insert(el), cout << s.size() << '\\n';\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <set>\n//#define LOCAL\nusing namespace std;\ntypedef long long ll;\nset<ll>s;\n\nint main() {\n#ifdef LOCAL\nifstream fin(\"1.txt\");\nstreambuf*p;\np=cin.rdbuf(fin.rdbuf());\n#endif // LOCAL\nll q;\ncin>>q;\nfor(ll i=0;i<q;i++){\n    ll a,b;\n    cin>>a>>b;\n    if(0==a){\n        s.insert(b);\n        cout<<s.size()<<endl;\n    }else if(1==a){\n        cout<<s.count(b)<<endl;\n    }else if(2==a){\n        s.erase(b);\n    }else{\n        ll t;\n        cin>>t;\n        set<ll>::iterator i1=s.lower_bound(b);\n        set<ll>::iterator i2=s.upper_bound(t);\n        for(;i1!=i2;i1++) cout<<(*i1)<<endl;\n    }\n}\n\n#ifdef LOCAL\nfin.close();\n#endif // LOCAL\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint main() {\n\tint\tN;\n\tcin >> N;\n\tset<int> s;\n\trep(i, N)\n\t{\n\t\tint\ta, b;\n\t\tcin >> a >> b;\n\t\tif (a == 0)\n\t\t{\n\t\t\ts.insert(b);\n\t\t\tcout << s.size() << endl;\n\t\t}\n\t\telse if (a == 1)\n\t\t\tcout << (s.find(b) != s.end()) << endl;\n\t\telse if (a == 2)\n\t\t\ts.erase(b);\n\t\telse\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tfor (set<int>::iterator it = s.lower_bound(b); it != s.upper_bound(c); it++)\n\t\t\t\tcout << *it << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF (2e9)\n#define FOR(i, a, b) for (ll (i) = (a); (i) < (b); ++(i))\n#define REP(i, n) FOR(i, 0, n)\n\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ld = long double;\n\n#define ALL(x) (x).begin(), (x).end()\ntemplate<class T>\nusing vc = vector<T>;\nusing vi = vc<ll>;\nusing vvi = vc<vi>;\n\ntemplate<class T>\nusing va = valarray<T>;\nusing vad = va<ld>;\nusing vai = va<ll>;\n\nusing pii = pair<ll, ll>;\n\nvi Read(ll n) {\n    auto      v = vi(n);\n    for (auto i = std::size_t(0); i < n; ++i) {\n        cin >> v[i];\n    }\n    return v;\n}\n\ntemplate<class T>\nvoid DumpRow(const T& A) {\n    for (const auto& value : A)\n        cout << value << \"\\n\";\n}\n\ntemplate<class T>\nvoid DumpColumn(const T& A) {\n    auto isFirst = true;\n    for (const auto& value : A) {\n        if (isFirst) {\n            cout << value;\n            isFirst = false;\n        } else {\n            cout << \" \" << value;\n        }\n\n    }\n    cout << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n    auto v = set<int>();\n\n    REP(i, n) {\n        int q, x;\n        cin >> q >> x;\n        if (q == 0) {\n            v.insert(x);\n            cout << v.size() << endl;\n        } else if (q == 1){\n            auto it = v.find(x);\n            if (it != v.end()) cout << 1 << endl;\n            else cout << 0 << endl;\n        } else if (q == 2){\n            v.erase(x);\n        } else if (q == 3){\n            int y;\n            cin >> y;\n            auto it = v.lower_bound(x);\n            while (it != v.end() && *it <= y){\n                cout << *it << endl;\n                ++it;\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef vector<ld> vld;\ntypedef vector<string> vstr;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> spqll;  // 小さい順に取り出し\ntypedef priority_queue<ll, vector<ll>, less<ll>> bpqll;     // 大きい順に取り出し\n\n#define REP(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define IREP(i, v) for (auto i = (v).begin(); i != (v).end(); ++i)\n#define TS to_string\n#define ALL(v) (v).begin(), (v).end()\n#define endl \"\\n\"\n\nll INF = 1e9;\nll MOD = 1000000007;\nll LINF = 1e18;\nld EPS = 1e-9;\nld PI = M_PI;\nvll dx = {1, 0, -1, 0, 1, -1, -1, 1};\nvll dy = {0, 1, 0, -1, 1, 1, -1, -1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a;} //最大公約数\nll lcm(ll a, ll b) { return a / gcd(a, b) * b;}     //最小公倍数\n\nvoid yes(){ cout << \"Yes\" << endl;}\nvoid no(){ cout << \"No\" << endl;}\n\n//-----------------------------------------\n\n//-----------------------------------------\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  ll q;\n  cin >> q;\n  set<ll> st;\n  REP(i,q){\n    ll com;\n    cin >> com;\n    if(com == 0){\n      ll x; cin >> x;\n      st.insert(x);\n      cout << st.size() <<endl;\n    }\n    else if(com == 1){\n      ll x; cin >> x;\n      cout << (st.find(x) != st.end()) <<endl;\n    }\n    else if(com == 2){\n      ll x;\n      cin >> x;\n      st.erase(x);\n    }\n    else{\n      ll l, r;\n      cin >> l >> r;\n      auto s = st.lower_bound(l);\n      auto t = st.upper_bound(r);\n      for(auto i = s; i != t; ++i){\n        cout << (*i) << endl;\n      }\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nint main() {\n\tint q;\n\tcin >> q;\n\n\tset<int> S;\n\n\tint query, x;\n\tint L, R;\n\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> query;\n\t\tif (query == 0) {\n\t\t\tcin >> x;\n\t\t\tS.insert(x);\n\t\t\tcout << S.size() << endl;\n\t\t}\n\t\telse if (query == 1){\n\t\t\tcin >> x;\n\t\t\tif (S.find(x) != S.end())\n\t\t\t\tcout << 1 << endl;\n\t\t\telse\n\t\t\t\tcout << 0 << endl;\t\t\n\t\t}\n\t\telse if(query == 2){\n\t\t\tcin >> x;\n\t\t\tS.erase(x);\t\t\n\t\t}\n\t\telse {\n\t\t\tcin >> L >> R;\n\t\t\tfor (auto itr = S.lower_bound(L); itr != S.upper_bound(R); itr++) {\n\t\t\t\tcout << *itr << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#define long long long\n#define LF '\\n'\n#define ALL(x) x.begin(), x.end()\nusing namespace std;\ntypedef pair<int,int> pii;\ntemplate<class A, class B>inline bool chmax(A &a, const B &b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, const B &b){return b<a ? a=b,1 : 0;}\nconstexpr int INF = 0x3f3f3f3f;\n\n\nsigned main()\n{\n  cin.tie(nullptr), ios::sync_with_stdio(false);\n  set<int> U;\n  int Q;\n\n  cin >> Q;\n  while(Q--) {\n    int com, x, y;\n    cin >> com;\n\n    switch(com) {\n    case 0:\n      cin >> x;\n      U.insert(x);\n      cout << U.size() << LF;\n      break;\n\n    case 1:\n      cin >> x;\n      cout << U.count(x) << endl;\n      break;\n\n    case 2:\n      cin >> x;\n      U.erase(x);\n      break;\n\n    default:\n      cin >> x >> y;\n      for (auto it = U.lower_bound(x), end=U.upper_bound(y); it != end; ++it) {\n        cout << *it << LF;\n      }\n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nset<int>st;\nint main() {\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint Q, k;\n\t\tcin >> Q >> k;\n\t\tif (Q == 0) {\n\t\t\tst.insert(k);\n\t\t\tcout << st.size() << endl;\n\t\t}\n\t\telse if (Q == 1) {\n\t\t\tcout << st.count(k) << endl;\n\t\t}\n\t\telse if (Q == 2) {\n\t\t\tst.erase(k);\n\t\t}\n\t\telse {\n\t\t\tint y;\n\t\t\tcin >> y;\n\t\t\tauto nowitr = st.lower_bound(k);\n\t\t\tauto enditr = st.upper_bound(y);\n\t\t\twhile (nowitr != enditr) {\n\t\t\t\tcout << *nowitr << endl;\n\t\t\t\tnowitr++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < (n); i++)\n#define repd(i,a,b) for (int i = (a); i < (b); i++)\ntypedef long long ll;\n\nint main(void)\n{\n\tint q, com, x;\n\tset<int> S;\n    cin >> q;\n    rep(i, q)\n    {\n        cin >> com >> x;\n        if (com == 0)\n        {\n            S.insert(x);\n            cout << S.size() << endl;\n        }\n        else if (com == 1)\n        {\n            cout << S.count(x) << endl;\n        }\n        else if (com == 2)\n        {\n            S.erase(x);\n        }\n        else\n        {\n            int y;\n            cin >> y;\n            set<int>::iterator st, en, itr;\n            st = S.lower_bound(x);\n            en = S.upper_bound(y);\n            for(itr = st; itr != en; ++itr) {\n                cout << *itr << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::set<int> s;\n    int Q;\n    std::cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int t;\n        std::cin >> t;\n        if (t == 0) {\n            int x;\n            std::cin >> x;\n            s.insert(x);\n            std::cout << s.size() << \"\\n\";\n        } else if (t == 1) {\n            int x;\n            std::cin >> x;\n            std::cout << s.count(x) << \"\\n\";\n        } else if (t == 2) {\n            int x;\n            std::cin >> x;\n            s.erase(x);\n        } else {\n            int l, r;\n            std::cin >> l >> r;\n            auto e = s.upper_bound(r);\n            for (auto itr = s.lower_bound(l); itr != e; ++itr) std::cout << *itr << \"\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    ll q, c, x, y;\n    set<ll> s;\n    cin >> q;\n    for(ll i = 0; i < q; i++){\n        cin >> c >> x;\n        if (c == 0){\n            s.insert(x);\n            cout << s.size() << endl;\n        }else if(c == 1){\n            if (s.find(x) != s.end()){\n                cout << \"1\" << endl;\n            }else{\n                cout << \"0\" << endl;\n            }\n        }else if(c == 2){\n            auto j = s.find(x);\n            if(j != s.end()){\n                s.erase(j);\n            }\n        }else{\n            cin >> y;\n            auto b = s.lower_bound(x);\n            auto e = s.upper_bound(y);\n            if(b != e){\n                for(auto j = b; j != e; j++){\n                    cout << *j << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n    int q;\n    cin >> q;\n    int a, x, y;\n    set<int> s;\n    while(q--){\n        cin >> a >> x;\n        if(a==0){\n            s.insert(x);\n            cout << s.size() << \"\\n\";\n        }else if(a==1){\n            cout << s.count(x) << \"\\n\";\n        }else if(a==2){\n            s.erase(x);\n        }else{\n            cin >> y;\n            set<int>:: iterator start, end;\n            end=s.upper_bound(y);\n            for(start=s.lower_bound(x); start!=end; start++){\n                cout << *start << \"\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define long int64_t\n\nint main() {\n\tios_base::sync_with_stdio( false );\n\n\tset<int> S;\n\tint q;\n\tcin >> q;\n\twhile( q-- > 0 ) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\n\t\tif( a == 0 ) {\n\t\t\tS.insert( b );\n\t\t\tcout << S.size() << '\\n';\n\t\t}\n\t\telse if( a == 1 ) {\n\t\t\tcout << (S.find( b ) != S.end()) << '\\n';\n\t\t}\n\t\telse if( a == 2 ) {\n\t\t\tS.erase( b );\n\t\t}\n\t\telse if( a == 3 ) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\n\t\t\tauto beg = S.lower_bound( b );\n\t\t\tauto end = S.upper_bound( c );\n\t\t\twhile( beg != end ) { cout << *beg++ << '\\n'; }\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\n#define lambda(RES_TYPE, ...) (function<RES_TYPE(__VA_ARGS__)>)[&](__VA_ARGS__) -> RES_TYPE\n#define method(FUNC_NAME, RES_TYPE, ...) function<RES_TYPE(__VA_ARGS__)> FUNC_NAME = lambda(RES_TYPE, __VA_ARGS__)\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<\"LINE \"<<__LINE__<<\": \"<<#x<<\" = \"<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nnamespace templates{\n  ll modpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n      if(b&1)res = res * x % MOD;\n      x = x * x % MOD;\n      b>>=1;\n    }\n    return res;\n  }\n\n  ll modinv(ll x){\n    return modpow(x, MOD-2);\n  }\n\n  bool was_output = false;\n  template<class t>\n  void output(t a){\n    if(was_output)cout << \" \";\n    cout << a;\n    was_output = true;\n  }\n  void outendl(){\n    was_output = false;\n    cout << endl;\n  }\n  ll in(){\n    ll res;\n    scanf(\"%lld\", &res);\n    return res;\n  }\n\n  template<class t>\n  istream& operator>>(istream&is, vector<t>&x){\n    for(auto &i:x)is >> i;\n    return is;\n  }\n\n  template<class t, class u>\n  istream& operator>>(istream&is, pair<t, u>&x){\n    is >> x.first >> x.second;\n    return is;\n  }\n\n  template<class t>\n  void in(t&x){\n    cin >> x;\n  }\n\n  template<class t>\n  t in(){\n    t res; cin >> res; return res;\n  }\n\n  template<class t>\n  void out(t x){\n    cout << x;\n  }\n\n  template<class t>\n  vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){\n    sort(line.begin(),line.end(),comp);\n    return line;\n  }\n\n  template<class t>\n  vector<t> reversed(vector<t> line){\n    reverse(line.begin(),line.end());\n    return line;\n  }\n}\n\nusing namespace templates;\n\nint main(){\n  int q = in();\n  set<int> s;\n  rep(_,q){\n    int kind = in();\n    if(kind==0){\n      int add = in();\n      s.emplace(add);\n      cout << s.size() << endl;\n    }else if(kind==1){\n      int x = in();\n      cout << s.count(x) << endl;\n    }else if(kind==2){\n      int x = in();\n      s.erase(x);\n    }else{\n      int x = in();\n      int y = in();\n      auto from = s.lower_bound(x);\n      auto end = s.upper_bound(y);\n      while(from!=end){\n        cout << *from << endl;\n        ++from;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <functional>\n#include <set>\n\nusing namespace std;\n\nint main()\n{\n    int q;\n    cin >> q;\n\n    set<int> S;\n    int cmd, x, L, R;\n    while (q--)\n    {\n        cin >> cmd;\n        if (cmd == 0)\n        {\n            cin >> x;\n            S.insert(x);\n            cout << S.size() << endl;\n        }\n        else if (cmd == 1)\n        {\n            cin >> x;\n            // cout << (S.find(x) != S.end()) << endl;\n            cout << S.count(x) << endl;\n        }\n        else if (cmd == 2)\n        {\n            cin >> x;\n            S.erase(x);\n            // remove(S.begin(), S.end(), x);\n        }\n        else\n        {\n            cin >> L >> R;\n            set<int>::iterator it1 = S.lower_bound(L), it2 = S.upper_bound(R);\n            while (it1 != it2)\n            {\n                cout << *it1 << endl;\n                it1++;\n            }\n\n        }\n        \n        \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <set>\n#include <iterator>\nusing namespace std;\nint main(){\n    int n,temp,k;\n    set<int> s;\n    set<int>::iterator u;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&k,&temp);\n        if(k==0){\n            s.insert(temp);\n            printf(\"%ld\\n\",s.size());\n        }\n        else if(k==1){\n            if(s.find(temp)==s.end())printf(\"0\\n\");\n            else printf(\"1\\n\");\n        }\n        else if(k==2)s.erase(temp);   \n        else{\n            u=s.lower_bound(temp);\n            scanf(\"%d\",&temp);\n            while(u!=s.end()){\n                if(*u>temp)break;\n                printf(\"%d\\n\",*u);\n                u++;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void) {\n\tset<int> S;\n\tint q, com, x, y;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> com;\n\t\tswitch (com) {\n\t\t\tcase 0:\n\t\t\t\tcin >> x;\n\t\t\t\tS.insert(x);\n\t\t\t\tcout << S.size() << endl;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcin >> x;\n\t\t\t\tif (S.find(x) != S.end()) {\n\t\t\t\t\tcout << \"1\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tcout << \"0\\n\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcin >> x;\n\t\t\t\tS.erase(x);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcin >> x >> y;\n\t\t\t\tset<int>::iterator it = S.lower_bound(x);\n\t\t\t\tset<int>::iterator end = S.upper_bound(y);\n\t\t\t\twhile (it != end) {\n\t\t\t\t\tcout << *it << endl;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//typedef long long ll;\n#define FOR(I,A,B) for(int I = int(A); I < int(B); ++I)\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n \nint main(){\n\tint q,c,x;\n\tcin >> q;\n\tset<int> se;\n\twhile(q--){\n\t\tcin >> c >> x;\n\t\tif(c==1){\n\t\t\tcout << se.count(x) << endl;\n\t\t}else if(c==0){\n\t\t\tse.insert(x);\n\t\t\tcout << se.size() << endl;\n\t\t}else if(c==2){\n\t\t\tse.erase(x);\n\t\t}else if(c==3){\n\t\t\tint L = x;\n\t\t\tint R; cin >> R;\n\t\t\tauto it = se.lower_bound(L);\n\t\t\tauto end = se.upper_bound(R);\n\t\t\tfor(;it!=end;it++){\n\t\t\t\tcout << (*it) << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <set>\n#include <iterator>\nusing namespace std;\nint main(){\n    int n,temp,k;\n    set<int> s;\n    set<int>::iterator u;\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&k,&temp);\n        if(k==0){\n            s.insert(temp);\n            printf(\"%ld\\n\",s.size());\n        }\n        else if(k==1){\n            if(s.find(temp)==s.end())printf(\"0\\n\");\n            else printf(\"1\\n\");\n        }\n        else if(k==2)s.erase(temp);   \n        else{\n            u=s.lower_bound(temp);\n            scanf(\"%d\",&temp);\n            while(u!=s.end()){\n                if(*u>temp)break;\n                printf(\"%d\\n\",*u);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\nconst int maxn=(int)1e6+5;\nset<int> s;\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int q;cin>>q;while(q--){\n        int op=0;cin>>op;\n        if(op==3){\n            int l,r;\n            cin>>l>>r;\n            auto ed=s.upper_bound(r);\n            for(auto it=s.lower_bound(l);it!=ed;it++)cout<<*it<<endl;\n        }else{\n            int x=0;\n            cin>>x;\n            if(op==0){s.insert(x);cout<<s.size()<<endl;}\n            if(op==1){cout<<s.count(x)<<endl;}\n            if(op==2){s.erase(x);}\n        }\n        \n    }\n}\n/* \n\n- insert(xx): Insert xx to SS and report the number of elements in SS after the operation.\n- find(xx): Report the number of xx in SS (0 or 1).\n- delete(xx): Delete xx from SS.\n- dump(LL, RR): Print elements xx in SS such that L≤x≤RL≤x≤R.\n9\n0 1\n0 2\n0 3\n2 2\n1 1\n1 2\n1 3\n0 4\n3 2 4\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  set<int> S;\n  int q;\n  cin >> q;\n  while (q--) {\n    int op, x;\n    cin >> op >> x;\n    if (op == 0) {\n      S.insert(x);\n      cout << S.size() << endl;\n    } else if (op == 1) {\n      cout << (S.find(x) != S.end()) << endl;\n    } else if (op == 2) {\n      S.erase(x);\n    } else {\n      int l = x, r;\n      cin >> r;\n      auto left = S.lower_bound(l);\n      auto right = S.upper_bound(r);\n      for (auto it = left; it != right; it++) {\n        cout << *it << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    set<int> s;\n    set<int>::iterator it;\n    int n;\n    cin>>n;\n\n    while(n--)\n    {\n        int a;\n        cin>>a;\n\n        if(a==0)\n        {\n            int x;\n            cin>>x;\n            s.insert(x);\n            cout<<s.size()<<endl;\n\n        }\n\n        else if(a==1)\n        {\n            int x;\n            cin>>x;\n\n            if(s.find(x)!=s.end())\n              cout<<1<<endl;\n            else\n                cout<<0<<endl;\n\n        }\n\n        else if(a==2)\n        {\n            int x;\n            cin>>x;\n            s.erase(x);\n\n        }\n\n        else if(a==3)\n        {\n            int x,y;\n            cin>>x>>y;\n            for(it=s.lower_bound(x);it!=s.upper_bound(y);it++)\n            {\n                cout<<*it<<endl;\n            }\n        }\n\n    }\n\n    return 0;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define FORR(i, m, n) for (int i = (m); i >= (n); i--)\n#define REP(i, n) FOR(i, 0, (n))\n#define REPR(i, n) FORR(i, (n) - 1, 0)\n#define REP1(i, n) FOR(i, 1, (n) + 1)\n#define REPS(c, s) for (char c : s)\n#define ALL(c) (c).begin(), (c).end()\n#define SORT(c) sort(ALL(c))\n#define REV(c) reverse(ALL(c))\n#define sz(v) (int)v.size()\n#define endl '\\n'\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return false;}\ntemplate<class T> inline void printv(vector<T>& v) {int n = sz(v); REP(i, n) cout << v[i] << (i == n - 1 ? endl : ' ');}\nconst int MOD = 1000000007;\nconst int INF = 1000000001;\nconst ll LINF = 1000000001000000001LL;\n \nvoid solve();\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(numeric_limits<double>::max_digits10);\n    solve();\n    return 0;\n}\n\nvoid solve() {\n    int q;\n    cin >> q;\n    set<int> s;\n    while (q--) {\n        int c, x;\n        cin >> c >> x;\n        if (c == 0) {\n            s.emplace(x);\n            cout << sz(s) << endl;\n        } else if (c == 1) {\n            cout << s.count(x) << endl;\n        } else if (c == 2) {\n            s.erase(x);\n        } else if (c == 3) {\n            int y;\n            cin >> y;\n            auto st = s.lower_bound(x);\n            auto ed = s.upper_bound(y);\n            for (;st != ed; st++) cout << *st << endl;\n        }\n    } \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define r(i, n) for(int i=0;i<n;i++)\n\nint main() {\n    int q;\n    set<int> s;\n    cin >> q;\n    while (q--) {\n        int x, y;\n        cin >> x >> y;\n        if (x == 1)cout << s.count(y) << endl;\n        else if (!x) {\n            s.insert(y);\n            cout << s.size() << endl;\n        } else if (x == 2)s.erase(y);\n        else {\n            int l = y, r;\n            cin >> r;\n            set<int>::iterator end, it;\n            it = s.lower_bound(l);\n            end = s.upper_bound(r);\n            for (; it != end; it++) {\n                cout << (*it) << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i = 0; i<n; i++)\ntypedef long long ll;\nusing namespace std;\n\nint main(){\n set<int> s;\n  int n,a,b,c;\n  cin >> n;\n  while(n--){\n    cin >> a>>b;\n    if(!a){\n      s.insert(b);\n      cout << s.size() <<endl;\n    }\n    else if(a==1)cout << s.count(b) << endl;\n    else if(a==2)s.erase(b);\n    else{\n      cin >> c;\n      auto it=s.lower_bound(b),end=s.upper_bound(c);\n      for(;it!=end;it++){\n        cout << *it<<endl;\n      }\n    }\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n   return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n   os << \"[\";\n   bool a = 1;\n   for (auto e : v ) {\n      os << (a ? \"\" : \" \"); \n      os << e;\n      a = 0;\n   }\n   os << \"]\";\n   return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n   os << \"(\" << p.first << \" \" << p.second << \")\";\n   return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n   os << \"{\";\n   bool a = 1;\n   for (auto e : st) {\n      os << (a ? \"\" : \" \");\n      os << e;\n      a = 0;\n   }\n   os << \"}\";\n   return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n   os << \"{\";\n   bool a = 1;\n   for (auto e : st) {\n      os << (a ? \"\" : \" \");\n      os << e;\n      a = 0;\n   }\n   os << \"}\";\n   return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n   os << \"{\";\n   bool a = 1;\n   for (auto e : mp) {\n      os << (a ? \"\" : \" \");\n      os << e.first << \":\" << e.second;\n      a = 0;\n   }\n   os << \"}\";\n   return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n   if (N) os << \" \";\n   os << get<N>(t);\n   out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n   os << \"(\";\n   out<0,tuple<Ts...>,Ts...>(os, t);\n   os << \")\";\n   return os;\n}\n\n// Debug\n#define DUMP(x) cout<<#x<<\" = \"<<(x)<<endl\n\n\nstruct edge { int to, cost; };\nostream& operator<<(ostream& os, const edge& e) {\n   os << \"(\" << e.to << \", \" << e.cost << \")\";\n   return os;\n}\n\nconst LL LINF = 1LL<<60;\nconst int IINF = 1<<30;\nconst LL MOD = 1e9+7;\n\n\nmt19937 mt{ random_device{}() };\nuniform_real_distribution<> dist(0, 1);\n\ntemplate<typename elem_t>\nstruct node_t\n{\n   using count_t = unsigned int;\n   using pri_t = double;\n\n   elem_t elem;\n   node_t *lch, *rch, *par;\n   count_t cnt;\n   pri_t pri;\n\n   node_t(elem_t elem) : elem(elem), lch(nullptr), rch(nullptr),\n                         par(nullptr), cnt(1), pri((pri_t)dist(mt)) {}\n\n   static count_t count(node_t* node) {\n      // cout << \"node_t::count is called\" << endl;\n      if (node != nullptr) {\n         return node->cnt;\n      } else {\n         return 0;\n      }\n   }\n\n   static node_t* update(node_t* node) {\n      // cout << \"node_t::update is called\" << endl;\n      assert(node != nullptr);\n      node->cnt = count(node->lch) + count(node->rch) + 1;\n\n      node->par = nullptr;\n      if (node->lch != nullptr) {\n         node->lch->par = node;\n      }\n      if (node->rch != nullptr) {\n         node->rch->par = node;\n      }\n\n      return node;\n   }\n\n   static node_t* merge(node_t* l, node_t* r) {\n      // cout << \"node_t::merge is called\" << endl;\n      if (l == nullptr) {\n         return r;\n      } else if (r == nullptr) {\n         return l;\n      }\n\n      // update(l);\n      // update(r);\n\n      assert(l->pri != r->pri);\n\n      if (r->pri < l->pri) {\n         l->rch = merge(l->rch, r);\n         return update(l);\n      } else {\n         r->lch = merge(l, r->lch);\n         return update(r);\n      }\n   }\n\n   // TODO elemをconst &\n   //\n   static pair<node_t*, node_t*> split(node_t* node, elem_t elem, bool includeToRight) {\n      // cout << \"node_t::split is called\" << endl;\n      if (node == nullptr) {\n         return { nullptr, nullptr };\n      }\n      // update(node);\n\n      node_t *l, *r;\n      if (includeToRight) {\n         if (node->elem < elem) {\n            tie(l, r) = split(node->rch, elem, includeToRight);\n            node->rch = l;\n            return { update(node), r };\n         } else {\n            tie(l, r) = split(node->lch, elem, includeToRight);\n            node->lch = r;\n            return { l, update(node) };\n         }\n      } else {\n         if (node->elem <= elem) {\n            tie(l, r) = split(node->rch, elem, includeToRight);\n            node->rch = l;\n            return { update(node), r };\n         } else {\n            tie(l, r) = split(node->lch, elem, includeToRight);\n            node->lch = r;\n            return { l, update(node) };\n         }\n      }\n   }\n\n   static node_t* insert(node_t* node, elem_t elem) {\n      // cout << \"nodt_t::insert is called\" << endl;\n      node_t *l, *c, *r;\n      tie(c, r) = split(node, elem, false);\n      tie(l, ignore) = split(c, elem, true);\n      auto p_node = new node_t(elem);\n      return merge(l, merge(p_node, r));\n   }\n\n   static pair<node_t*, node_t*> erase(node_t* node, elem_t elem) {\n      // cout << \"node_t::erase is called\" << endl;\n      node_t *l, *c, *r;\n      tie(c, r) = split(node, elem, false);\n      tie(l, ignore) = split(c, elem, true);\n      return { merge(l, r), c };\n   }\n\n   static node_t* find(node_t* node, elem_t elem) {\n      // cout << \"node_t::find is called\" << endl;\n      if (node == nullptr) {\n         return nullptr;\n      }\n      if (node->elem < elem) {\n         return find(node->rch, elem);\n      } else if (elem < node->elem) {\n         return find(node->lch, elem);\n      } else {\n         return node;\n      }\n   }\n\n   static node_t* at(node_t* node, count_t k) {\n      assert(node != nullptr);\n      assert(node->cnt > k);\n\n      if (count(node->lch) == k) {\n         return node;\n      } else if (count(node->lch) > k) {\n         return at(node->lch, k);\n      } else {\n         return at(node->rch, k-1-count(node->lch));\n      }\n   }\n\n   static node_t* lower_bound(node_t* node, elem_t elem) {\n      // cout << \"node_t::lower_bound is called\" << endl;\n      if (node == nullptr) {\n         return nullptr;\n      }\n      if (elem <= node->elem) {\n         node_t* lb = lower_bound(node->lch, elem);\n         if (lb != nullptr) {\n            return lb;\n         } else {\n            return node;\n         }\n      } else {\n         return lower_bound(node->rch, elem);\n      }\n   }\n\n   node_t* next() {\n      if (this->rch != nullptr) {\n         node_t* t = this->rch;\n         while (t->lch != nullptr) {\n            t = t->lch;\n         }\n         return t;\n      }\n      node_t* t = this;\n      while (t->par != nullptr && t->par->rch == t) {\n         t = t->par;\n      }\n      return t->par;\n   }\n\n   static void show(node_t* node) {\n      // cout << \"node_t::show is called\" << endl;\n      if (node == nullptr) {\n         return;\n      }\n      show(node->lch);\n      cout << \"node_t::show \" << node\n         << \", lch: \" << node->lch\n         << \", rch: \" << node->rch\n         << \", elem: \" << node->elem\n         << \", cnt: \" << node->cnt\n         << \", pri: \" << node->pri << endl;\n      show(node->rch);\n   }\n};\n\n\n\ntemplate<typename elem_t>\nstruct Treap\n{\n   using count_t = unsigned int;\n   using pri_t = double;\n\n   using node = node_t<elem_t>;\n   node* root;\n\n   Treap() : root(nullptr) {}\n\n   count_t size() {\n      return node::count(root);\n   }\n\n   void insert(elem_t elem) {\n      root = node::insert(root, elem);\n   }\n\n   void erase(elem_t elem) {\n      tie(root, ignore) = node::erase(root, elem);\n   }\n\n   node* find(elem_t elem) {\n      return node::find(root, elem);\n   }\n\n   node* lower_bound(elem_t elem) {\n      return node::lower_bound(root, elem);\n   }\n\n   node* at(count_t k) {\n      return node::at(root, k);\n   }\n\n   node* begin() {\n      return root;\n   }\n\n   void show() {\n      node::show(root);\n   }\n};\n\nint main()\n{\n   mt.seed(2);\n   int q; cin >> q;\n\n   vector<int> t(q), x(q), l(q), r(q);\n   for (int i = 0; i < q; ++i) {\n      cin >> t[i];\n      if (t[i] != 3) {\n         cin >> x[i];\n      } else {\n         cin >> l[i] >> r[i];\n      }\n   }\n\n   Treap<int> treap;\n\n   for (int i = 0; i < q; ++i) {\n      if (t[i] == 0) {\n         treap.insert(x[i]);\n         cout << treap.size() << endl;\n      } else if (t[i] == 1) {\n         cout << (treap.find(x[i]) ? 1 : 0) << endl;\n      } else if (t[i] == 2) {\n         treap.erase(x[i]);\n      } else {\n         for (auto node = treap.lower_bound(l[i]); node != nullptr && node->elem <= r[i]; node = node->next()) {\n            cout << node->elem << endl;\n         }\n      }\n   }\n\n   // treap.show();\n   // auto node = treap.lower_bound(2);\n   // for (; node != nullptr && node->elem <= 5; node = node->next()) {\n   //    cout << \"node: \" << node << endl;\n   //    cout << node->elem << endl;\n   // }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n\n/* 大文字を小文字に変換 */\nchar tolower(char c) {return (c + 0x20);}\n/* 小文字を大文字に変換 */\nchar toupr(char c) {return (c - 0x20);}\n\n// if('A'<=s[i] && s[i]<='Z') s[i] += 'a'-'A';\n\n/*\nstring s = \"abcdefg\"\ns.substr(4) \"efg\"\ns.substr(0,3) \"abc\"\ns.substr(2,4) \"cdef\"\n\n// イテレータ要素のインデックス\ndistance(A.begin(), itr);\n*/\n\nint main()\n{\n    int q; cin >> q;\n    set<int> S;\n    rep(i,q){\n        int query; cin >> query;\n        if(query == 0){\n            int x; cin >> x;\n            S.insert(x);\n            cout << S.size() << endl;\n        }else if(query == 1){\n            int x; cin >> x;\n            cout << S.count(x) << endl;\n        }else if(query == 2){\n            int x; cin >> x;\n            S.erase(x);\n        }else if(query == 3){\n            int L,R; cin >> L >> R;\n            auto it = S.lower_bound(L);\n\t\t\twhile (it != S.end() && *it <= R) {\n\t\t\t\tprintf(\"%d\\n\", *it); ++it;\n\t\t\t}\n        }\n        \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n//#include <boost/foreach.hpp>\n//#include <boost/range/algorithm.hpp>\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define ll long long\n#define Sort(v) sort(all(v))\n#define INF 1000000000\n#define END return 0\n#define pb push_back\n#define se second\n#define fi first\n#define pb push_back\n#define all(v) (v).begin() , (v).end()\n#define MP make_pair\n#define MOD 1000000007LL\nusing namespace std;\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n\nint main (){\n    int q;cin>>q;\n    set<int> st;\n    rep(i,0,q){\n        int a,b;cin>>a>>b;\n        if(a==0){\n            st.insert(b);\n            cout<<st.size()<<endl;\n        }else if(a==1){\n            cout<<((st.find(b)==st.end())?0:1)<<endl;\n        }else if(a==2){\n            st.erase(b);\n        }else {\n            int r;cin>>r;\n            rep(j,b,r+1){\n                auto ret=st.equal_range(j);\n                for(auto it=ret.first;it!=ret.second;it++)cout<<(*it)<<endl;\n            }\n        }\n    }\n    \n    \n}\n\n\n\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,x,n) for(int i=x; i<(n); i++)\n#define ALL(n) begin(n),end(n)\n#define MOD (1000000007)\n#define INF (1e9)\n#define INFL (1e18)\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntemplate<class T>using arr=vector<vector<T>>;\ntemplate<class T>void pr(T x){cout << x << endl;}\ntemplate<class T>void prvec(vector<T>& a){rep(i, a.size()-1){cout << a[i] << \" \";} cout << a[a.size()-1] << endl;}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nint main()\n{\n    set<int> s;\n    int q; cin >> q;\n    rep(i, q){\n        int c, x, l ,r;\n        cin >> c;\n        if(c==0){\n            cin >> x;\n            s.insert(x);\n            pr(s.size());\n        }else if(c==1){\n            cin >> x;\n            if(s.find(x)!=s.end()) pr(1);\n            else pr(0);\n        }else if(c==2){\n            cin >> x;\n            s.erase(x);\n        }else{\n            cin >> l >> r;\n            if(l<r){\n                auto li = s.lower_bound(l);\n                auto ri = s.lower_bound(r);\n                for(; li!=ri; li++) pr(*li);\n                if(*li==r) pr(*li);\n            }if(l==r){\n                if(s.find(x)!=s.end()) pr(l);\n            }\n        }\n    }\n    return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n\nint main() {\n  std::set<int> s;\n  int q;\n  scanf(\"%d\", &q);\n\n  for (int i=0; i<q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 0) {\n      int x;\n      scanf(\"%d\", &x);\n      s.insert(x);\n      printf(\"%zu\\n\", s.size());\n    } else if (t == 1) {\n      int x;\n      scanf(\"%d\", &x);\n      printf(\"%td\\n\", s.count(x));\n    } else if (t == 2) {\n      int x;\n      scanf(\"%d\", &x);\n      s.erase(x);\n    } else if (t == 3) {\n      int l, r;\n      scanf(\"%d %d\", &l, &r);\n      auto it=s.lower_bound(l);\n      while (it != s.end() && *it <= r) {\n        printf(\"%d\\n\", *it);\n        ++it;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\nint main(){\n\tint q,a,b;\n\tint s,t;\n\tcin>>q;\n\tset<int>m;\n\tfor(;q--;){\n\t\tcin>>a;\n\t\tif(a==0)cin>>s,m.insert(s),cout<<m.size()<<endl;\n\t\tif(a==1)cin>>s,cout<<m.count(s)<<endl;\n\t\tif(a==2)cin>>s,m.erase(s);\n\t\tif(a==3){cin>>s>>t;auto it1=m.lower_bound(s),it2=m.upper_bound(t);for(;it1!=it2;++it1)cout<<*it1<<endl;}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <numeric>\n#include <climits>\n#include <iterator>\n#include <iomanip>\n#include <stack>\n#include <set>\n#include <cstdio>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <list>\n#include <deque>\nusing namespace std;\ntypedef pair<int, int> P;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i<(ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ntypedef long long ll;\ntypedef vector<int> VI;\n\nint a[200010];\nint b[200010];\nint main() {\n    cin.tie(0);\n   \tios::sync_with_stdio(false);\n    \n    ll n; cin >> n;\n    set<ll> st;\n    REP(i, n){\n        ll a, b; cin >> a >> b;\n        if(a==1){\n            if(st.find(b)!=st.end()) cout << 1 << endl;\n            else cout << 0 << endl;\n        }else if(a==0){\n            st.insert(b);\n            cout << st.size() << endl;\n        }else if(a==2){\n            st.erase(b);\n        }else{\n            ll c; cin >> c;\n            for(auto itr=st.lower_bound(b); itr!=st.upper_bound(c); ++itr) cout << *itr << endl;\n        }\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tset<int> v;\n\tfor(int i=0;i<n;i++){\n\t\tint o,x;\n\t\tscanf(\"%d%d\",&o,&x);\n\t\tif(o==0){\n\t\t\tv.insert(x);\n\t\t\tprintf(\"%d\\n\",v.size());\n\t\t}\n\t\tif(o==1){\n\t\t\tprintf(\"%d\\n\",v.count(x));\n\t\t}\n\t\tif(o==2){\n\t\t\tv.erase(x);\n\t\t}\n\t\tif(o==3){\n\t\t\tint s;\n\t\t\tscanf(\"%d\",&s);\n\t\t\tfor(set<int>::iterator j=v.lower_bound(x);j!=v.upper_bound(s);j++)printf(\"%d\\n\",*j);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = 1LL<<55;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  set<int> S;\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int cmd, num;\n    cin>>cmd>>num;\n    if(cmd == 0){\n      S.insert(num);\n      cout<<S.size()<<endl;\n    }\n\n    if(cmd == 1){\n      cout<<S.count(num)<<endl;\n    }\n    \n    if(cmd == 2){\n      S.erase(num);\n    }\n\n    if(cmd == 3){\n      int l = num, r;\n      cin>>r;\n      //      auto start = S.lower_bound(l);\n      //auto last= S.upper_bound(r);\n      for(auto it = S.lower_bound(l); it != S.upper_bound(r); it++) cout<<*it<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\n  int q;\n  set <int> a;\n  cin>>q;\n\n  for(int i=0;i<q;i++){\n    int n,x,y;\n    cin>>n>>x;\n    if(n==1) cout<<(a.end()!=a.find(x))<<endl;\n    else if(n==2) a.erase(x);\n    else if(n==3){\n      cin>>y;\n      auto it=a.lower_bound(x);\n      do{\n\tprintf(\"%d\\n\",*it);\n\t++it;\n      }while(it!=a.end()&&*it<=y);\n    }\n    else{\n      a.insert(x);\n      cout<<a.size()<<endl;\n    }\n  }\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\ntypedef long long ll;\nconst ll inf = 1e9;\nint main(){\n    int q; cin >> q;\n    set<ll> st;\n    rep(i,q){\n        ll com, x, y;\n        cin >> com >> x;\n        if(com == 0){\n            st.insert(x);\n            cout << st.size() << endl;\n        }else if(com == 1)cout << st.count(x) << endl;\n        else if(com == 2)st.erase(x);\n        else{\n            cin >> y;\n            for(set<ll>::iterator it=st.lower_bound(x); it != st.upper_bound(y); it++)cout << *it << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nint main() {\n set<UL> S;\n UL Q; scanf(\"%u\",&Q);\n rep(q,Q){\n  UL c; scanf(\"%u\",&c);\n  if(c==0){\n   UL x; scanf(\"%u\",&x);\n   S.insert(x);\n   printf(\"%u\\n\",S.size());\n  }\n  if(c==1){\n   UL x; scanf(\"%u\",&x);\n   printf(\"%u\\n\",S.count(x));\n  }\n  if(c==2){\n   UL x; scanf(\"%u\",&x);\n   S.erase(x);\n  }\n  if(c==3){\n   UL L,R; scanf(\"%u%u\",&L,&R);\n   for(auto itr=S.lower_bound(L); itr!=S.end(); itr++){\n    if(*itr>R) break;\n    printf(\"%u\\n\",*itr);\n   }\n  }fflush(stdout);\n }\n return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\n  int q;\n  set <int> a;\n  cin>>q;\n\n  for(int i=0;i<q;i++){\n    int n,x,y;\n    cin>>n>>x;\n    if(n==1) cout<<(a.end()!=a.find(x))<<endl;\n    else if(n==2) a.erase(x);\n    else if(n==3){\n      cin>>y;\n      auto it=a.lower_bound(x);\n      do{\n\tcout<<*it<<endl;\n\tit++;\n      }while(it!=a.end()&&*it<=y);\n    }\n    else{\n      a.insert(x);\n      cout<<a.size()<<endl;\n    }\n  }\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i ,n) for(int i=0;i<(int)(n);++i)\nusing namespace std;\ntypedef long long int int64;\ntypedef unsigned long long uint64;\n\nint main(){\n    int q; cin >> q;\n    set<int> a;\n    decltype(a)::iterator itr1;\n    decltype(a)::iterator itr2;\n    rep(i ,q){\n        int m , x , y;\n        cin >> m >> x;\n        switch (m)\n        {\n        case 0: \n            a.insert(x);\n            cout << a.size() << endl; \n            break;\n        case 1:\n            itr1 = a.find(x);\n            cout << (itr1!=a.cend() ? 1 : 0) << endl;\n            break;\n        case 2:\n            a.erase(x);\n            break;\n        case 3:\n            cin >> y;\n            if(a.empty()) break;\n            else { \n                set<int>::iterator itr1,itr2;\n                itr1 = a.lower_bound(x);\n                itr2 = a.upper_bound(y);\n                set<int>::iterator it = itr1;\n                while(it != itr2){\n                    cout << *(it++) << endl;\n                }\n            }\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\nint main(){\n\tset<int>s;\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tint c,x;\n\t\tcin>>c>>x;\n\t\tif(c==0){\n\t\t\ts.insert(x);\n\t\t\tcout<<s.size()<<endl;\n\t\t}\n\t\telse if(c==1){\n\t\t\tcout<<s.count(x)<<endl;\n\t\t}\n\t\telse if(c==2){\n\t\t\ts.erase(x);\n\t\t}\n\t\telse if(c==3){\n\t\t\tint y;\n\t\t\tcin>>y;\n\t\t\tfor(set<int>::iterator i=s.lower_bound(x); i!=s.upper_bound(y); i++)\n\t\t\t\tcout<<*i<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() \n{\n    int n, x, y, z, i;\n    scanf(\"%d\", &n);\n    \n    set<int> s;\n    \n    for(i = 0; i < n; i++)\n    {\n        scanf(\"%d %d\", &x, &y);\n        \n        if(x == 0)\n        {\n            s.insert(y);\n            printf(\"%d\\n\", (int)s.size());\n        }\n        else if(x == 1)\n        {\n            printf(\"%d\\n\", (int)s.count(y));\n        }\n        else if(x == 2)\n        {\n            s.erase(y);\n        }\n        else if(x == 3)\n        {\n            scanf(\"%d\", &z);\n            \n            auto L = s.lower_bound(y);\n            auto R = s.upper_bound(z);\n            \n            while(L != R)\n            {\n                printf(\"%d\\n\", *L);\n                L++;\n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\nusing namespace std;\n\nint main()\n{  \n    int n;\n    cin>>n;\n    set<int>s;\n    REP(i,n)\n    {\n        int x,y;\n        cin>>x>>y;\n        if(x==0){s.insert(y);cout<<s.size()<<endl;}\n        if(x==1)cout<<s.count(y)<<endl;\n        if(x==2)\n        {\n            if(s.find(y)!=s.end())s.erase(y);\n        }\n        if(x==3)\n        {\n            int z;\n            cin>>z;\n            decltype(s)::iterator it=s.lower_bound(y);\n            decltype(s)::iterator end=s.upper_bound(z);\n            while(it!=end)\n            {\n                cout<<*it<<endl;\n                ++it;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int q;\n    cin >> q;\n    set<int> st;\n    for(int i = 0; i < q; i++)\n    {\n        int com, x;\n        cin >> com >> x;\n        if(com == 0)\n        {\n            st.insert(x);\n            cout << st.size() << endl;\n        }\n        else if(com == 1)\n        {\n            cout << (st.find(x) != st.end() ? 1 : 0) << endl;\n        }\n        else if(com == 2)\n        {\n            st.erase(x);\n        }\n        else if(com == 3)\n        {\n            int y;\n            cin >> y;\n            auto it = st.lower_bound(x);\n            auto last = st.upper_bound(y);\n            while(it != last)\n            {\n                cout << *it << endl;\n                it++;\n            }\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro_and_Function\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nT DEG_2_RAD(T deg) {\n    return deg * PI / 180;\n}\ntemplate <class T>\nT RAD_2_DEG(T rad) {\n    return rad * 180 / PI;\n}\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\nvoid operator*=(string& l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r - 1; i++) { l += str; }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r - 1; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro_and_Function\n\nint main() {\n    PRE_COMMAND\n    int n;\n    set<int> s;\n    INPUT(n);\n    REP(i, n) {\n        int a, b, c;\n        INPUT(a, b);\n        if (a == 0) {\n            s.insert(b);\n            PRINT(SZ(s));\n        } else if (a == 1) {\n            PRINT(s.count(b));\n        } else if (a == 2) {\n            s.erase(b);\n        } else {\n            INPUT(c);\n            for (auto j = s.lower_bound(b); j != s.lower_bound(c + 1); j++) {\n                PRINT(*j);\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nsigned main(){\n\tint q;\n\tset<int>s;\n\tcin>>q;\n\twhile(q--){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(x==1)cout<<s.count(y)<<endl;\n\t\telse if(!x){\n\t\t\ts.insert(y);\n\t\t\tcout<<s.size()<<endl;\n\t\t}\n\t\telse if(x==2)s.erase(y);\n\t\telse{\n\t\t\tint l=y,r;\n\t\t\tcin>>r;\n\t\t\tset<int>::iterator end,it;\n\t\t\tit=s.lower_bound(l);\n\t\t\tend=s.upper_bound(r);\n\t\t\tfor(;it!=end;it++){\n\t\t\t\tcout<<(*it)<<endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin >> n;\n\tset<int> p;\n\twhile (n--)\n\t{\n\t\tint type;\n\t\tcin >> type;\n\t\tswitch (type)\n\t\t{\n\t\t\tint num;\n\t\tcase 0:\n\t\t\tcin >> num;\n\t\t\tp.insert(num);\n\t\t\tcout << p.size() << endl;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcin >> num;\n\t\t\tcout << p.count(num) << endl;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcin >> num;\n\t\t\tp.erase(num);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tint head, end;\n\t\t\tcin >> head >> end;\n\t\t\tset<int>::iterator hed=p.lower_bound(head);\n\t\t\tset<int>::iterator ed = p.upper_bound(end);\n\t\t\tfor (; hed != ed;hed++)\n\t\t\t{\n\t\t\t\tcout << (*hed) << endl;\n\t\t\t}\n\t\t\tbreak;\n\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define reps(i,a,b) for(int i=a;i<b;++i)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\ntemplate<typename T> inline bool chmax(T &a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T> inline bool chmin(T &a,T b){if(b<a){a=b;return 1;}return 0;}\ntemplate<typename T> vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_vec(size_t a,Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a,make_vec<T>(ts...));}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T,U>::value>::type fill_v(U &u,const V... v){u=U(v...);}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<!is_same<T,U>::value>::type fill_v(U &u,const V... v){for(auto &e:u)fill_v<T>(e,v...);}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int q;\n    cin >> q;\n    set<int> st;\n    while (q--) {\n        int com, x, l, r;\n        cin >> com;\n        if (com == 0) {\n            cin >> x;\n            st.insert(x);\n            cout << st.size() << endl;\n        } else if (com == 1) {\n            cin >> x;\n            cout << st.count(x) << endl;\n        } else if (com == 2) {\n            cin >> x;\n            st.erase(x);\n        } else {\n            cin >> l >> r;\n            auto litr = st.lower_bound(l);\n            auto ritr = st.upper_bound(r);\n            for (auto itr = litr; itr != ritr; ++itr) cout << *itr << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#include <boost/multiprecision/cpp_int.hpp>\n//using multiInt = boost::multiprecision::cpp_int;\n\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconst int MOD_TYPE = 1;\nconst ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\nconst int INF = (int)1e9;\nconst ll LINF = (ll)4e18;\nconst double PI = acos(-1.0);\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << endl\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << endl\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << endl\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << endl;\n\nvector<int> Dx = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nvector<int> Dy = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(50) << setiosflags(ios::fixed);\n  int q;\n  cin >> q;\n  set<int> st;\n  rep(qi, q)\n  {\n    int type;\n    cin >> type;\n    if (type == 0)\n    {\n      int x;\n      cin >> x;\n      st.insert(x);\n      cout << st.size() << endl;\n    }\n    else if (type == 1)\n    {\n      int x;\n      cin >> x;\n      cout << st.count(x) << endl;\n    }\n    else if (type == 2)\n    {\n      int x;\n      cin >> x;\n      st.erase(x);\n    }\n    else\n    {\n      int l, r;\n      cin >> l >> r;\n      auto itr = st.lower_bound(l);\n      while (itr != st.end() && *itr <= r)\n      {\n        cout << *itr << endl;\n        itr++;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (1ll<<60)\n#define sq(n) ((n)*(n))\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nusing ll = long long;\n\nsigned main(){\n    set<int> set;\n    int q;\n    cin>>q;\n    while(q--){\n        int y,x;\n        cin>>y>>x;\n        if(y==0){\n            set.insert(x);\n            cout<<set.size()<<endl;\n        }\n        else if(y==1){\n            cout<<(set.find(x)!=set.end())<<endl;\n        }\n        else if(y==2){\n            set.erase(x);\n        }\n        else{\n            int z;\n            cin>>z;\n            for(auto it=set.lower_bound(x);it!=set.upper_bound(z);it++){\n                cout<<*it<<endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main()\n{\n    int N; cin >> N;\n    set<int> Set;\n    \n    for(int i = 0; i < N; ++i)\n    {\n        int Command; cin >> Command;\n        \n        if(Command == 0)\n        {\n            int Val; cin >> Val;\n            Set.insert(Val);\n            cout << Set.size() << endl;\n        }\n        else if(Command == 1)\n        {\n            int Val; cin >> Val;\n            cout << (Set.find(Val) != Set.end()) << endl;\n        }\n        else if(Command == 2)\n        {\n            int Val; cin >> Val;\n            Set.erase(Val);\n        }\n        else if(Command == 3)\n        {\n            int LB, UB; cin >> LB >> UB;\n            \n            set<int>::iterator ite = Set.lower_bound(LB);\n            set<int>::iterator last = Set.upper_bound(UB);\n            \n            while(ite != last)\n            {\n                cout << *ite << endl;\n                ++ite;\n            }\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lli long long int\n#define FILE_IN freopen(\"input.txt\", \"r\", stdin);\n#define FILE_OUT freopen(\"output.txt\", \"w\", stdout);\n#define PI acos(-1)\nusing namespace std;\nvoid fastio()\n{\n ios_base::sync_with_stdio(false);\n  cin. tie(0);\n  cout. tie(0);\n\n}\nint main() {\n fastio();\n  int f,t,x,y;\n    set<int>s;\n set<int>::iterator it1,it2;\n    cin>>t;\n    while(t--) {\n        cin>>f>>x;\n        if(f==0) {\n            s.insert(x);\n            cout<<s.size()<<endl;\n        }\n        else if(f==1)\n            cout<<s.count(x)<<endl;\n\n       else if(f==2)\n          s.erase(x);\n\n       else{\n          cin>>y;\n\n         it1=s.lower_bound(x);\n         it2=s.upper_bound(y);\n         for(;it1 != it2;it1++)\n          cout<<*it1<<endl;\n       }\n\n}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int q; cin >> q;\n  set<int> st;\n  int cnt = 0;\n  for (int i = 0; i < q; i++) {\n    int cmd; cin >> cmd;\n    if (cmd == 0) {\n      int x; cin >> x;\n      st.insert(x);\n      cnt++;\n      cout << cnt << endl;\n    }\n    if (cmd == 1) {\n      int x; cin >> x;\n      cout << st.count(x) << endl;\n    }\n    if (cmd == 2) {\n      int x; cin >> x;\n      st.erase(x);\n      cnt--;\n    }\n    if (cmd == 3) {\n      int l, r; cin >> l >> r;\n      for (int i = l; i <= r; i++) {\n        if (st.count(i)) {\n          auto itr = st.find(i);\n          cout << *itr << endl;\n        }\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<list>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint main()\n{\n    set<int > s;\n    int q;\n    cin>>q;\n    int b,tp1;\n    while(q--){\n        cin>>tp1;\n        if(tp1==1){\n                cin>>b;\n            if(s.find(b)!=s.end()){\n                cout<<\"1\\n\";\n            }\n            else{\n                cout<<\"0\\n\";\n            }\n        }\n        else if(tp1==0){\n            cin>>b;\n            s.insert(b);\n            cout<<s.size()<<\"\\n\";\n        }\n        else if(tp1==2){\n            cin>>b;\n            s.erase(b);\n        }\n        else{\n            int r,l;\n            cin>>l>>r;\n            set<int>::iterator it=s.lower_bound(l);\n            while(*it<=r&&it!=s.end()){\n                cout<<*it<<\"\\n\";\n                it++;\n            }\n        }\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)\n  { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)\n { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\nunsigned long xor128() {\n  static unsigned long x=123456789, y=362436069, z=521288629, w=88675123;\n  unsigned long t=(x^(x<<11));\n  x=y; y=z; z=w;\n  return ( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\ntemplate <class T>\nstruct treap_set_node {\n  using key_type = T;\n  using value_type = T;\n  T key;\n  int priority;\n  treap_set_node *l, *r;\n  treap_set_node(T key, int priority)\n    : key(key), priority(priority), l(nullptr), r(nullptr) {}\n};\n\n\ntemplate <class T, class U>\nstruct treap_map_node {\n  using key_type = T;\n  using mapped_type = U;\n  using value_type = std::pair<T,U>;\n  T key;\n  U mapped;\n  int priority;\n  treap_map_node *l, *r;\n  treap_map_node(T key, U mapped, int priority)\n    : key(key), mapped(mapped), priority(priority), l(nullptr), r(nullptr) {}\n};\n\ntemplate <class Node> struct extract_key;\n\ntemplate <class T>\nstruct extract_key<treap_set_node<T>> {\n  T operator()(treap_set_node<T>* t){ return t->key; }\n};\n\ntemplate <class T, class U>\nstruct extract_key<treap_map_node<T,U>> {\n  T operator()(treap_map_node<T,U>* t){ return t->key; }\n};\n\ntemplate <class Node> struct extract_value;\ntemplate <class T>\nstruct extract_value<treap_set_node<T>> {\n  T operator()(treap_set_node<T>* t){ return t->key; }\n};\ntemplate <class T, class U>\nstruct extract_value<treap_map_node<T,U>> {\n  std::pair<T,U> operator()(treap_map_node<T,U>* t){ return std::make_pair(t->key, t->mapped); }\n};\n\ntemplate <class Node, bool HasUniqueKey>\nclass treap {\n    std::size_t size_ = 0;\n\n    using Tree = Node *;\n\n    using key_type = typename Node::key_type;\n    using value_type = typename Node::value_type;\n    // using mapped_type = typename Node::mapped_type;\n\n    extract_key<Node> key_fn{};\n    extract_value<Node> value_fn{};\n\n    Tree root = nullptr;\n\n    void split(Tree t, key_type key, Tree& l, Tree& r, bool by_upper_bound) {\n        if (!t) {\n            l = r = nullptr;\n        } else if (key < key_fn(t) || (key == key_fn(t) && !by_upper_bound)) {\n            split(t->l, key, l, t->l, by_upper_bound), r = t;\n        } else {\n            split(t->r, key, t->r, r, by_upper_bound), l = t;\n        }\n    }\n\n    void split_by_lower_bound(Tree t, key_type key, Tree& l, Tree& r) {\n      split(t,key,l,r,false);\n    }\n    void split_by_upper_bound(Tree t, key_type key, Tree& l, Tree& r) {\n      split(t,key,l,r,true);\n    }\n    void split_into_tree_parts(Tree t, key_type key, Tree& l, Tree& c, Tree& r) {\n      Tree tmp;\n      split_by_lower_bound(t, key, l, tmp);\n      split_by_upper_bound(tmp, key, c, r);\n    }\n\n    void merge(Tree& t, Tree l, Tree r) {\n      if (!l || !r) {\n        t = l ? l : r;\n      } else if (l->priority > r->priority) {\n        merge(l->r, l->r, r), t = l;\n      } else {\n        merge(r->l, l, r->l), t = r;\n      }\n    }\n    void merge_three_trees(Tree& t, Tree l, Tree c, Tree r) {\n      Tree tmp;\n      merge(tmp, c, r);\n      merge(t, l, tmp);\n    }\n\n    void insert(Tree& t, Tree item) {\n      if (!t) {\n        t = item;\n      } else if (item->priority > t->priority) {\n        split_by_lower_bound(t, item->key, item->l, item->r), t = item;\n      } else {\n        insert(item->key < key_fn(t) ? t->l : t->r, item);\n      }\n    }\n\n    void erase(Tree& t, key_type key) {\n      Tree l,r,c;\n      split_into_tree_parts(t, key, l, c, r);\n      merge(t, l, r);\n      size_ -= nuke(c);\n    }\n\n    std::size_t find(Tree& t, key_type key) {\n      Tree l,r,c;\n      split_into_tree_parts(t, key, l, c, r);\n      std::size_t ans = count(c);\n      merge_three_trees(t, l, c, r);\n      return ans;\n    }\n\n    std::size_t nuke(Tree t) {\n      if (!t) return 0;\n      std::size_t ret = 1;\n      ret += nuke(t->l);\n      ret += nuke(t->r);\n      delete t;\n      return ret;\n    }\n\n    std::size_t count(Tree t) {\n      if (!t) return 0;\n      std::size_t ret = 1;\n      ret += count(t->l);\n      ret += count(t->r);\n      return ret;\n    }\n\n    void collect_(std::vector<value_type>& v, Tree t) {\n      if (!t) return;\n      collect_(v, t->l);\n      v.push_back(value_fn(t));\n      collect_(v, t->r);\n    }\n\n  public:\n    std::size_t size() const { return size_; }\n\n    // set\n    void insert(key_type key) {\n      if (HasUniqueKey && find(key)) return;\n      size_++;\n      insert(root, new Node(key, xor128()));\n    }\n\n   // void insert(key_type key, mapped_type value) {\n    //   if (HasUniqueKey && find(key)) return;\n    //   size_++;\n    //   insert(root, new Node(key, value, xor128()));\n    // }\n\n    // void insert_or_replace(key_type key, mapped_type value) {\n    //   erase(key);\n    //   size_++;\n    //   insert(root, new Node(key, value, xor128()));\n    // }\n\n    void erase(key_type key) {\n      erase(root, key);\n    }\n\n    std::size_t find(key_type key) {\n      return find(root, key);\n    }\n\n    std::vector<value_type> collect(key_type x, key_type y) {\n      std::vector<value_type> v;\n      Tree l,r,c,tmp;\n      split_by_lower_bound(root, x, l, tmp);\n      split_by_upper_bound(tmp, y, c, r);\n      collect_(v, c);\n      merge(tmp, c, r);\n      merge(root, l, tmp);\n      return v;\n    }\n    std::vector<value_type> collect() {\n      std::vector<value_type> v;\n      collect_(v, root);\n      return v;\n    }\n};\n\ntemplate <class T>\nclass set : public treap<treap_set_node<T>,true> {};\ntemplate <class T>\nclass multiset : public treap<treap_set_node<T>,false>{};\n\ntemplate <class T, class U>\nclass map : public treap<treap_map_node<T,U>,true> {};\ntemplate <class T, class U>\nclass multimap : public treap<treap_map_node<T,U>,false>{};\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  set<int> treap;\n  int q; std::cin >> q;\n  rep(i,0,q){\n    int c; std::cin >> c;\n    if (c == 0) {\n      int x; std::cin >> x;\n      treap.insert(x);\n      std::cout << treap.size() << std::endl;\n    } else if (c == 1) {\n      int x; std::cin >> x;\n      bool ans = treap.find(x);\n      std::cout << ans << std::endl;\n    } else if (c == 2) {\n      int x; std::cin >> x;\n      treap.erase(x);\n    } else if (c == 3) {\n      int l, r; std::cin >> l >> r;\n      auto v = treap.collect(l,r);\n      std::sort(all(v));\n      for (auto&& x : v) {\n        std::cout << x << std::endl;\n      }\n    }\n    // debug(treap.collect());\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long int\nusing namespace std;\nint main()\n{\n  set<ll>::iterator it;\n  set<ll>s;\n  ll temp,tc,q,x,l,r;\n  cin>>tc;\n  while(tc--)\n  {\n    cin>>q;\n    if(q==0)\n    {\n      cin>>temp;\n      s.insert(temp);\n      cout<<s.size()<<endl;\n    }\n    else if(q==1)\n    {\n      cin>>x;\n      cout<<s.count(x)<<endl;\n    }\n    else if(q==2)\n    {\n      cin>>x;\n      s.erase(x);\n    }\n    else\n    {\n      cin>>l>>r;\n\t\t\tfor(it=s.lower_bound(l);it!=s.upper_bound(r);it++){\n\t\t\tcout<<(*it)<<endl;\n    }\n  }\n}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nint main()\n{\t\n\tstd::set<int> S;\n\t\n\tint q; std::cin >> q;\n\tfor (int i=0; i<q; i++) {\n\t\tint op, x, L, R;\n\t\tstd::cin >> op;\n\t\tif (op==0) {\n\t\t\tstd::cin >> x;\n\t\t\tS.insert(x);\n\t\t\tstd::cout << S.size() << std::endl;\n\t\t}\n\t\telse if (op==1) {\n\t\t\tstd::cin >> x;\n\t\t\tif (S.find(x) != S.end()) std::cout << 1 << std::endl;\n\t\t\telse std::cout << 0 << std::endl;\n\t\t}\n\t\telse if (op==2) {\n\t\t\tstd::cin >> x;\n\t\t\tS.erase(x);\n\t\t}\n\t\telse {\n\t\t\tstd::cin >> L >> R;\n\t\t\tstd::set<int>::iterator lb = S.lower_bound(L);\n\t\t\tstd::set<int>::iterator ub = S.upper_bound(R);\n\t\t\tfor (std::set<int>::iterator it = lb; it != ub; ++it) std::cout << *it << std::endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n//#include <boost/foreach.hpp>\n//#include <boost/range/algorithm.hpp>\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define ll long long\n#define Sort(v) sort(all(v))\n#define INF 1000000000\n#define END return 0\n#define pb push_back\n#define se second\n#define fi first\n#define pb push_back\n#define all(v) (v).begin() , (v).end()\n#define MP make_pair\n#define MOD 1000000007LL\nusing namespace std;\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n\nint main (){\n    int q;cin>>q;\n    set<int> st;\n    rep(i,0,q){\n        int a,b;cin>>a>>b;\n        if(a==0){\n            st.insert(b);\n            cout<<st.size()<<endl;\n        }else if(a==1){\n            cout<<((st.find(b)==st.end())?0:1)<<endl;\n        }else if(a==2){\n            st.erase(b);\n        }else {\n            int r;cin>>r;\n            auto it=st.lower_bound(b);\n            for(;it!=st.end()&&*it<=r;it++){\n                cout<<*it<<endl;\n            }\n            \n        }\n    }\n    \n    \n}\n\n\n\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include<iostream>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<list>\n#include<stack>\n#include<map>\n#include<set>\n#include<string>\n#include <sstream>\n\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<limits.h>\n\nusing namespace std;\n\n\nint main(){\n  long ii,jj,kk;\n  vector<int> a;\n  set<int> s;\n  int q,c,x,l,r;\n\n  cin >> q;\n  set<int>::iterator it;\n  set<int>::iterator lit,rit;  \n  for(ii=0;ii<q;ii++){\n    cin >> c >> x;\n    if(c == 0){\n      s.insert(x);\n      cout << s.size() << endl;\n    }\n    else if(c == 1){\n      it = s.find(x);\n      if(it != s.end()){\n        cout << 1 << endl;\n      }\n      else{\n        cout << 0 << endl;\n      }\n    }\n    else if(c == 2){\n      s.erase(x);\n    }\n    else{\n      l = x;\n      cin >> r;\n      lit = s.lower_bound(l);\n      rit = s.lower_bound(r);\n\n      while(lit != rit){\n        cout << *lit << endl;\n        lit++;\n      }\n      if(*lit <= r && lit!=s.end()){\n        cout << *lit << endl;\n      }\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\nint n;\nset<int>S;\nmain()\n{\n  cin>>n;\n  for(int i=0;i<n;i++)\n  {\n    int c,x;cin>>c>>x;\n    if(c==1)cout<<(S.find(x)!=S.end())<<endl;\n    else if(c==0)S.insert(x),cout<<S.size()<<endl;\n    else if(c==2)S.erase(x);\n    else\n    {\n      int y;cin>>y;\n      auto a=S.lower_bound(x),b=S.upper_bound(y),u=0;\n      for(auto it=a;it!=b;it++)cout<<*it<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n,command,x,l,r;\n    set<int> mySet;\n    set<int>::iterator begin;\n    set<int>::iterator end;\n    cin >> n;\n\n    for(int i = 0;i < n;++i){\n        cin >> command;\n        if(command == 0){\n            cin >> x;\n            mySet.insert(x);\n            cout << mySet.size() << endl;\n        }else if(command == 1){\n            cin >> x;\n            bool find = mySet.find(x) != mySet.end() ? true : false;\n            cout << find << endl;\n        }\n        else if(command == 2){\n            cin >> x;\n            mySet.erase(x);\n        }\n        else{\n            cin >> l >> r;\n            begin = mySet.lower_bound(l);\n            end = mySet.upper_bound(r);\n\n            for(;begin != end;++begin){\n                cout << *begin << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <memory>\n#include <array>\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\n// constexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\ntemplate <typename Tp>\nclass order_statistic_tree {\n  // based on splay tree\n\npublic:\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using value_type = Tp;\n  using reference = Tp&;\n  using const_reference = Tp const&;\n  class iterator;\n  class const_iterator;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\nprivate:\n  class node;\n  using pointer = std::shared_ptr<node>;\n\n  class node {\n    friend order_statistic_tree;\n    friend iterator;\n    friend const_iterator;\n\n  public:\n    using size_type = size_t;\n    using difference_type = ptrdiff_t;\n    using value_type = Tp;\n    using reference = Tp&;\n    using const_reference = Tp const&;\n\n  private:\n    using pointer = std::shared_ptr<node>;\n\n    mutable pointer M_parent = nullptr;\n    mutable std::array<pointer, 2> M_children{{nullptr, nullptr}};\n    value_type M_value;\n    mutable size_type M_size = 1;\n\n  public:\n    node() = default;\n    node(node const&) = delete;  // !\n    node(node&&) = default;\n    node(const_reference value): M_value(value) {}\n    node(value_type&& value): M_value(std::move(value)) {}\n\n    ~node() {\n      // if (M_children[0]) delete M_children[0].get();\n      // if (M_children[1]) delete M_children[1].get();\n    }\n\n    void set_size() const {\n      // for splaying\n      M_size = 1;\n      if (M_children[0]) M_size += M_children[0]->M_size;\n      if (M_children[1]) M_size += M_children[1]->M_size;\n    }\n\n    size_type left_size() const {\n      if (!M_children[0]) return 0;\n      return M_children[0]->M_size;\n    }\n    size_type right_size() const {\n      if (!M_children[1]) return 0;\n      return M_children[1]->M_size;\n    }\n  };\n\n  static pointer S_next(pointer ptr, order_statistic_tree* tree,\n                        difference_type n = 1) {\n\n    if (n == 0) return ptr;\n    if (n < 0) return S_prev(ptr, tree, -n);\n\n    tree->M_root = S_splay(ptr);\n    // fprintf(stderr, \"null? %d\\n\", !ptr);\n    // if (ptr) fprintf(stderr, \"next: %p, size: %zu\\n\", ptr.get(), ptr->M_size);\n    ptr = ptr->M_children[1];\n    --n;\n    while (ptr) {\n      difference_type ls = ptr->left_size();\n      if (n == ls) return S_splay(ptr);\n      if (n < ls) {\n        ptr = ptr->M_children[0];\n      } else {\n        ptr = ptr->M_children[1];\n        n -= ls+1;\n      }\n    }\n    return nullptr;\n  }\n  static pointer S_prev(pointer ptr, order_statistic_tree* tree,\n                        difference_type n = 1) {\n\n    if (n == 0) return S_splay(ptr);\n    if (n < 0) return S_next(ptr, tree, -n);\n    if (!ptr)\n      return S_prev(tree->M_rightmost, tree, n-1);  // past-the-end\n\n    tree->M_root = S_splay(ptr);\n    ptr = ptr->M_children[0];\n    --n;\n    while (ptr) {\n      difference_type rs = ptr->right_size();\n      if (n == rs) return S_splay(ptr);\n      if (n < rs) {\n        ptr = ptr->M_children[1];\n      } else {\n        ptr = ptr->M_children[0];\n        n -= rs+1;\n      }\n    }\n    return nullptr;\n  }\n\n  static size_type S_index(pointer ptr, order_statistic_tree* tree) {\n    if (!ptr) return tree->size();\n    tree->M_root = S_splay(ptr);\n    return ptr->left_size();\n  }\n\n  static size_type S_parent_dir(pointer ptr) {\n    if (!ptr->M_parent) return -1_zu;\n    if (ptr->M_parent->M_children[0] == ptr) return 0;\n    if (ptr->M_parent->M_children[1] == ptr) return 1;\n    return -1_zu;\n  }\n\n  static pointer S_zig(pointer cur, size_type dir) {\n    pointer par = cur->M_parent;\n    pointer sub = cur->M_children[!dir];\n\n    cur->M_parent = nullptr;\\\n    cur->M_children[!dir] = par;\n    par->M_parent = cur;\n    par->M_children[dir] = sub;\n    if (sub) sub->M_parent = par;\n\n    par->set_size();\n    cur->set_size();\n    return cur;\n  }\n  static pointer S_zigzig(pointer cur, size_type dir) {\n    pointer par = cur->M_parent;\n    pointer gpar = par->M_parent;\n    pointer sub1 = cur->M_children[!dir];\n    pointer sub2 = par->M_children[!dir];\n    size_type gd = S_parent_dir(gpar);\n\n    cur->M_parent = gpar->M_parent;\n    if (gd != -1_zu) cur->M_parent->M_children[gd] = cur;\n    cur->M_children[!dir] = par;\n    par->M_parent = cur;\n    par->M_children[dir] = sub1;\n    if (sub1) sub1->M_parent = par;\n    par->M_children[!dir] = gpar;\n    gpar->M_parent = par;\n    gpar->M_children[dir] = sub2;\n    if (sub2) sub2->M_parent = gpar;\n\n    gpar->set_size();\n    par->set_size();\n    cur->set_size();\n    return cur;\n  }\n  static pointer S_zigzag(pointer cur, size_type dir) {\n    pointer par = cur->M_parent;\n    pointer gpar = par->M_parent;\n    pointer sub1 = cur->M_children[dir];\n    pointer sub2 = cur->M_children[!dir];\n    size_type gd = S_parent_dir(gpar);\n\n    cur->M_parent = gpar->M_parent;\n    if (gd != -1_zu) cur->M_parent->M_children[gd] = cur;\n    cur->M_children[dir] = gpar;\n    gpar->M_parent = cur;\n    cur->M_children[!dir] = par;\n    par->M_parent = cur;\n    gpar->M_children[!dir] = sub1;\n    if (sub1) sub1->M_parent = gpar;\n    par->M_children[dir] = sub2;\n    if (sub2) sub2->M_parent = par;\n\n    gpar->set_size();\n    par->set_size();\n    cur->set_size();\n    return cur;\n  }\n\n  static pointer S_splay(pointer ptr) {\n    if (!ptr) return nullptr;\n    while (true) {\n      size_type pd = S_parent_dir(ptr);\n      if (pd == -1_zu) return ptr;\n      size_type gd = S_parent_dir(ptr->M_parent);\n      if (gd == -1_zu) return S_zig(ptr, pd);\n      ptr = ((gd == pd)? S_zigzig(ptr, pd): S_zigzag(ptr, pd));\n    }\n  }\n\npublic:\n  class iterator {\n    friend order_statistic_tree;\n    friend const_iterator;\n\n  public:\n    using size_type = size_t;\n    using difference_type = ptrdiff_t;\n    using value_type = Tp;\n    using reference = Tp&;\n    using const_reference = Tp const&;\n    using pointer = std::shared_ptr<node>;\n    using iterator_category = std::random_access_iterator_tag;\n\n  private:\n    pointer M_ptr = nullptr;\n    mutable order_statistic_tree* M_tree = nullptr;\n\n  public:\n    iterator() = default;\n    iterator(iterator const&) = default;\n    iterator(iterator&&) = default;\n    iterator(pointer ptr, order_statistic_tree* tree):\n      M_ptr(ptr), M_tree(tree) {}\n\n    iterator& operator =(iterator const&) = default;\n    iterator& operator =(iterator&&) = default;\n\n    iterator& operator ++() { M_ptr = S_next(M_ptr, M_tree); return *this; }\n    iterator& operator --() { M_ptr = S_prev(M_ptr, M_tree); return *this; }\n\n    iterator& operator +=(difference_type n) {\n      M_ptr = S_next(M_ptr, M_tree, n); return *this;\n    }\n    iterator& operator -=(difference_type n) {\n      M_ptr = S_prev(M_ptr, M_tree, n); return *this;\n    }\n\n    iterator operator ++(int) { iterator tmp(*this); ++*this; return tmp; }\n    iterator operator --(int) { iterator tmp(*this); --*this; return tmp; }\n\n    iterator operator +(difference_type n) const {\n      return iterator(*this) += n;\n    }\n    iterator operator -(difference_type n) const {\n      return iterator(*this) -= n;\n    }\n\n    difference_type operator -(const_iterator const& other) const {\n      return S_index(M_ptr, M_tree) - S_index(other.M_ptr, M_tree);\n    }\n\n    bool operator ==(const_iterator const& other) const {\n      return M_ptr == other.M_ptr;\n    }\n    bool operator !=(const_iterator const& other) const {\n      return !(*this == other);\n    }\n\n    bool operator <(const_iterator const& other) const {\n      return S_index(M_ptr, M_tree) < S_index(other.M_ptr, M_tree);\n    }\n    bool operator >(const_iterator const& other) const {\n      return other < *this;\n    }\n    bool operator <=(const_iterator const& other) const {\n      return !(other < *this);\n    }\n    bool operator >=(const_iterator const& other) const {\n      return !(*this < other);\n    }\n\n    reference operator *() {\n      M_tree->M_root = S_splay(M_ptr); return M_ptr->M_value;\n    }\n    const_reference operator *() const {\n      M_tree->M_root = S_splay(M_ptr); return M_ptr->M_value;\n    }\n  };\n\npublic:\n  class const_iterator {\n    friend order_statistic_tree;\n    friend iterator;\n\n  public:\n    using size_type = size_t;\n    using difference_type = ptrdiff_t;\n    using value_type = Tp;\n    using reference = Tp const&;\n    using const_reference = Tp const&;\n    using pointer = std::shared_ptr<node>;\n    using iterator_category = std::random_access_iterator_tag;\n\n  private:\n    pointer M_ptr = nullptr;\n    mutable order_statistic_tree* M_tree = nullptr;\n\n  public:\n    const_iterator() = default;\n    const_iterator(const_iterator const&) = default;\n    const_iterator(const_iterator&&) = default;\n    const_iterator(iterator const& other): M_ptr(other.M_ptr) {}\n    const_iterator(iterator&& other): M_ptr(other.M_ptr) {}\n    const_iterator(pointer ptr, order_statistic_tree* tree):\n      M_ptr(ptr), M_tree(tree) {}\n\n    const_iterator& operator =(const_iterator const&) = default;\n    const_iterator& operator =(const_iterator&&) = default;\n    const_iterator& operator =(iterator const& other) {\n      M_ptr = other.M_ptr;\n      M_tree = other.M_tree;\n      return *this;\n    }\n    const_iterator& operator =(iterator&& other) {\n      M_ptr = other.M_ptr;\n      M_tree = other.M_tree;\n      return *this;\n    }\n\n    const_iterator& operator ++() { M_ptr = S_next(M_ptr, M_tree); return *this; }\n    const_iterator& operator --() { M_ptr = S_prev(M_ptr, M_tree); return *this; }\n\n    const_iterator& operator +=(difference_type n) {\n      M_ptr = S_next(M_ptr, M_tree, n); return *this;\n    }\n    const_iterator& operator -=(difference_type n) {\n      M_ptr = S_prev(M_ptr, M_tree, n); return *this;\n    }\n\n    const_iterator operator ++(int) {\n      const_iterator tmp(*this); ++*this; return tmp;\n    }\n    const_iterator operator --(int) {\n      const_iterator tmp(*this); --*this; return tmp;\n    }\n\n    const_iterator operator +(difference_type n) const {\n      return const_iterator(*this) += n;\n    }\n    const_iterator operator -(difference_type n) const {\n      return const_iterator(*this) -= n;\n    }\n\n    difference_type operator -(const_iterator const& other) const {\n      return S_index(M_ptr, M_tree) - S_index(other.M_ptr, M_tree);\n    }\n\n    bool operator ==(const_iterator const& other) const {\n      return M_ptr == other.M_ptr;\n    }\n    bool operator !=(const_iterator const& other) const {\n      return !(*this == other);\n    }\n\n    bool operator <(const_iterator const& other) const {\n      return S_index(M_ptr, M_tree) < S_index(other.M_ptr, M_tree);\n    }\n    bool operator >(const_iterator const& other) const {\n      return other < *this;\n    }\n    bool operator <=(const_iterator const& other) const {\n      return !(other < *this);\n    }\n    bool operator >=(const_iterator const& other) const {\n      return !(*this < other);\n    }\n\n    reference operator *() const {\n      M_tree->M_root = S_splay(M_ptr); return M_ptr->M_value;\n    }\n  };\n\nprivate:\n  size_type M_size = 0;\n  pointer M_root = nullptr;\n  pointer M_leftmost = nullptr;\n  pointer M_rightmost = nullptr;\n\n  static pointer S_leftmost(pointer root) {\n    if (!root) return nullptr;\n    while (root->M_children[0]) root = root->M_children[0];\n    return root;\n  }\n  static pointer S_rightmost(pointer root) {\n    if (!root) return nullptr;\n    while (root->M_children[1]) root = root->M_children[1];\n    return root;\n  }\n\n  void M_init_ends() {\n    M_leftmost = M_rightmost = M_root;\n    if (!M_root) return;\n    M_leftmost = S_leftmost(M_root);\n    M_rightmost = S_rightmost(M_root);\n  }\n\n  static void S_deep_copy(pointer& dst, pointer const& src) {\n    dst = std::make_shared<node>(src->M_value);\n    for (size_type i = 0; i <= 1; ++i)\n      if (src->M_children[i])\n        S_deep_copy(dst->M_children[i], src->M_children[i]);\n  }\n\n  void M_deep_copy(order_statistic_tree const& other) {\n    clear();\n    if (!other.M_root) return;\n\n    S_deep_copy(M_root, other.M_root);\n    M_size = other.M_size;\n    M_init_ends();\n  }\n\n  void M_move(order_statistic_tree&& other) {\n    clear();\n    M_root = other.M_root;\n    M_leftmost = other.M_leftmost;\n    M_rightmost = other.M_rightmost;\n    M_size = other.M_size;\n    other.clear();\n  }\n\n  // explicit order_statistic_tree(pointer root): M_root(root) {\n  //   if (!root) return;\n  //   M_root->set_size();\n  //   M_size = M_root->M_size;\n  //   M_init_ends();\n  // }\n\npublic:\n  order_statistic_tree() = default;\n  order_statistic_tree(order_statistic_tree const& other) {\n    M_deep_copy(other);\n  }\n  order_statistic_tree(order_statistic_tree&& other) {\n    M_move(std::move(other));\n  }\n\n  template <typename InputIt>\n  order_statistic_tree(InputIt first, InputIt last) { assign(first, last); }\n  order_statistic_tree(std::initializer_list<value_type> il) { assign(il); }\n\n  explicit order_statistic_tree(size_type size, const_reference value) {\n    assign(size, value);\n  }\n  explicit order_statistic_tree(size_type size) { assign(size); }\n\n  template <typename InputIt>\n  void assign(InputIt first, InputIt last) {\n    clear();\n    while (first != last) {\n      pointer tmp = M_root;\n      M_root = std::make_shared<node>(*first++);\n      M_root->M_children[0] = tmp;\n      M_root->M_size = ++M_size;\n      if (tmp) tmp->M_parent = M_root;\n    }\n    M_init_ends();\n  }\n  void assign(std::initializer_list<value_type> il) {\n    assign(il.begin(), il.end());\n  }\n\n  void assign(size_type size, const_reference value) {\n    clear();\n    for (size_type i = 0; i < size; ++i) {\n      pointer tmp = M_root;\n      M_root = std::make_shared<node>(value);\n      M_root->M_children[0] = tmp;\n      M_root->M_size = ++M_size;\n      if (tmp) tmp->M_parent = M_root;\n    }\n    M_init_ends();\n  }\n  void assign(size_type size) {\n    clear();\n    for (size_type i = 0; i < size; ++i) {\n      pointer tmp = M_root;\n      M_root = std::make_shared<node>();\n      M_root->M_children[0] = tmp;\n      M_root->M_size = ++M_size;\n      if (tmp) tmp->M_parent = M_root;\n    }\n    M_init_ends();\n  }\n\n  void clear() {\n    M_size = 0;\n    M_root = M_leftmost = M_rightmost = nullptr;\n  }\n\n  order_statistic_tree& operator =(order_statistic_tree const& other) {\n    M_deep_copy(other);\n    return *this;\n  }\n  order_statistic_tree& operator =(order_statistic_tree&& other) {\n    M_move(std::move(other));\n    return *this;\n  }\n\n  reference at(size_type n) {\n    if (n >= size()) throw std::out_of_range(\"n >= size()\");\n    return *(begin() + n);\n  }\n  const_reference at(size_type n) const {\n    if (n >= size()) throw std::out_of_range(\"n >= size()\");\n    return *(begin() + n);\n  }\n\n  reference operator [](size_type n) { return *(begin() + n); }\n  const_reference operator [](size_type n) const { return *(begin() + n); }\n\n  reference front() { return *begin(); }\n  const_reference front() const { *begin(); }\n  reference back() { return *rbegin(); }\n  const_reference back() const { *rbegin(); }\n\n  iterator begin() { return iterator(M_leftmost, this); }\n  const_reference begin() const { return const_reference(M_leftmost, this); }\n  const_reference cbegin() const { return const_reference(M_leftmost, this); }\n\n  iterator end() { return iterator(nullptr, this); }\n  const_reference end() const { return const_reference(nullptr, this); }\n  const_reference cend() const { return const_reference(nullptr, this); }\n\n  reverse_iterator rbegin() { return end(); }\n  const_reverse_iterator rbegin() const { return end(); }\n  const_reverse_iterator crbegin() const { return cend(); }\n\n  reverse_iterator rend() { return begin(); }\n  const_reverse_iterator rend() const { return begin(); }\n  const_reverse_iterator crend() const { return cbegin(); }\n\n  bool empty() const noexcept { return M_size == 0; }\n  size_type size() const { return M_size; }\n\n  iterator insert(const_iterator pos, const_reference value) {\n    // fprintf(stderr, \"pos: %p\\n\", pos.M_ptr.get());\n    if (pos == end()) return push_back(value);\n    M_root = S_splay(pos.M_ptr);\n    order_statistic_tree tmp = split(pos);\n    // fprintf(stderr, \"split [%zu]:[%zu]\\n\", size(), tmp.size());\n    iterator res = push_back(value);\n    // fprintf(stderr, \"inserted [%zu]:[%zu]\\n\", size(), tmp.size());\n    merge(std::move(tmp));\n    // fprintf(stderr, \"begin(): %p\\n\", begin().M_ptr.get());\n    return res;\n  }\n\n  iterator insert(const_iterator pos, value_type&& value) {\n    if (pos == end()) return push_back(std::move(value));\n    M_root = S_splay(pos.M_ptr);\n    order_statistic_tree tmp = split(pos);\n    iterator res = push_back(std::move(value));\n    merge(std::move(tmp));\n    return res;\n  }\n\n  iterator insert(const_iterator pos, size_type count, const_reference value) {\n    if (count == 0) return pos;\n    if (pos == end()) {\n      auto res = push_back(value);\n      for (size_type i = 1; i < count; ++i) push_back(value);\n      return res;\n    }\n    M_root = S_splay(pos.M_ptr);\n    order_statistic_tree tmp = split(pos);\n    iterator res = push_back(value);\n    for (size_type i = 1; i < count; ++i) push_back(value);\n    merge(std::move(tmp));\n    return res;\n  }\n\n  template <typename InputIt>\n  iterator insert(const_iterator pos, InputIt first, InputIt last) {\n    if (first == last) return pos;\n    if (pos == end()) {\n      auto res = push_back(*first++);\n      while (first != last) push_back(*first++);\n      return res;\n    }\n    M_root = S_splay(pos.M_ptr);\n    order_statistic_tree tmp = split(pos);\n    iterator res = push_back(*first++);\n    while (first != last) push_back(*first++);\n    merge(std::move(tmp));\n    return res;\n  }\n\n  iterator insert(const_iterator pos, std::initializer_list<value_type> il) {\n    return insert(pos, il.begin(), il.end());\n  }\n\n  template <typename... Args>\n  iterator emplace(const_iterator pos, Args&&... args) {\n    if (pos == end()) return emplace_back(std::forward<Args>(args)...);\n    M_root = S_splay(pos.M_ptr);\n    order_statistic_tree tmp = split(pos);\n    iterator res = emplace_back(std::forward<Args>(args)...);\n    merge(std::move(tmp));\n    return res;    \n  }\n\n  iterator push_back(const_reference value) {\n    M_root = S_splay(M_rightmost);\n    pointer tmp = std::make_shared<node>(value);\n    tmp->M_children[0] = M_root;\n    tmp->M_size = ++M_size;\n    if (M_root) M_root->M_parent = tmp;\n    if (!M_leftmost) M_leftmost = tmp;\n    M_root = M_rightmost = tmp;\n    return iterator(tmp, this);\n  }\n\n  iterator push_back(value_type&& value) {\n    M_root = S_splay(M_rightmost);\n    pointer tmp = std::make_shared<node>(std::move(value));\n    tmp->M_children[0] = M_root;\n    tmp->M_size = ++M_size;\n    if (M_root) M_root->M_parent = tmp;\n    if (!M_leftmost) M_leftmost = tmp;\n    M_root = M_rightmost = tmp;\n    return iterator(tmp, this);\n  }\n\n  template <typename... Args>\n  iterator emplace_back(Args&&... args) {\n    M_root = S_splay(M_rightmost);\n    pointer tmp = std::make_shared<node>(std::forward<Args>(args)...);\n    tmp->M_children[0] = M_root;\n    tmp->M_size = ++M_size;\n    if (M_root) M_root->M_parent = tmp;\n    if (!M_leftmost) M_leftmost = tmp;\n    M_root = M_rightmost = tmp;\n    return iterator(tmp, this);\n  }\n\n  iterator push_front(const_reference value) {\n    M_root = S_splay(M_leftmost);\n    pointer tmp = std::make_shared<node>(value);\n    tmp->M_children[1] = M_root;\n    tmp->M_size = ++M_size;\n    if (M_root) M_root->M_parent = tmp;\n    if (!M_rightmost) M_rightmost = tmp;\n    M_root = M_leftmost = tmp;\n    return iterator(tmp, this);\n  }\n\n  iterator push_front(value_type&& value) {\n    M_root = S_splay(M_leftmost);\n    pointer tmp = std::make_shared<node>(std::move(value));\n    tmp->M_children[1] = M_root;\n    tmp->M_size = ++M_size;\n    if (M_root) M_root->M_parent = tmp;\n    if (!M_rightmost) M_rightmost = tmp;\n    M_root = M_leftmost = tmp;\n    return iterator(tmp, this);\n  }\n\n  template <typename... Args>\n  iterator emplace_front(Args&&... args) {\n    M_root = S_splay(M_leftmost);\n    pointer tmp = std::make_shared<node>(std::forward<Args>(args)...);\n    tmp->M_children[1] = M_root;\n    tmp->M_size = ++M_size;\n    if (M_root) M_root->M_parent = tmp;\n    if (!M_rightmost) M_rightmost = tmp;\n    M_root = M_leftmost = tmp;\n    return iterator(tmp, this);\n  }\n\n  iterator pop_back() {\n    M_root = S_splay(M_rightmost);\n    M_root = M_rightmost->M_children[0];\n    if (M_root) M_root->M_parent = nullptr;\n    M_rightmost->M_children[0] = nullptr;\n    M_rightmost = S_rightmost(M_root);\n    if (--M_size == 0) M_leftmost = nullptr;\n    return end();\n  }\n\n  iterator pop_front() {\n    M_root = S_splay(M_leftmost);\n    M_root = M_leftmost->M_children[1];\n    if (M_root) M_root->M_parent = nullptr;\n    M_leftmost->M_children[1] = nullptr;\n    M_leftmost = S_leftmost(M_root);\n    if (--M_size == 0) M_rightmost = nullptr;\n    return begin();\n  }\n\n  iterator erase(const_iterator pos) {\n    if (pos == begin()) return pop_front();\n    order_statistic_tree tmp = split(pos);\n    tmp.pop_front();\n    // fprintf(stderr, \"tmp.root: %d\\n\", tmp.M_root->M_value);\n    // fprintf(stderr, \"size: %zu, %zu\\n\", size(), tmp.size());\n    auto res = tmp.begin();\n    merge(std::move(tmp));\n    return res;\n  }\n\n  iterator erase(const_iterator first, const_iterator last) {\n    if (first == last) return first;\n    order_statistic_tree tmp = split(last);\n    split(first);  // discard\n    auto res = tmp.begin();\n    merge(std::move(tmp));\n    return res;\n  }\n\n  iterator merge(order_statistic_tree& other) {\n    return merge(std::move(other));\n  }\n\n  iterator merge(order_statistic_tree&& other) {\n    if (other.empty()) return end();\n    if (empty()) {\n      M_move(std::move(other));\n      return begin();\n    }\n    M_root = S_splay(M_rightmost);\n    M_root->M_children[1] = other.M_root;\n    other.M_root->M_parent = M_root;\n    M_size = (M_root->M_size += other.M_size);\n    M_rightmost = other.M_rightmost;\n    iterator res(other.M_leftmost, this);\n    other.clear();  // not destruct nodes\n    // fprintf(stderr, \"[%p] [%p]\\n\", M_root->M_children[0].get(), M_root->M_children[1].get());\n    return res;\n  }\n\n  order_statistic_tree split(const_iterator pos) {\n    if (pos == end()) return {};\n    if (pos == begin()) return std::move(*this);\n    M_root = S_splay(pos.M_ptr);\n    // fprintf(stderr, \"split: %p %zu\\n\", M_root.get(), M_root->M_size);\n    pointer resp = M_root;\n    M_root = resp->M_children[0];\n    resp->M_children[0] = nullptr;\n    resp->set_size();\n    if (M_root) {\n      M_root->M_parent = nullptr;\n      M_root->set_size();\n      M_size = M_root->M_size;\n    } else {\n      M_size = 0;\n    }\n\n    order_statistic_tree res;\n    res.M_root = resp;\n    res.M_size = resp->M_size;\n    res.M_leftmost = pos.M_ptr;\n    res.M_rightmost = M_rightmost;\n\n    M_rightmost = S_rightmost(M_root);\n    // if (M_leftmost) fprintf(stderr, \"leftmost: %d\\n\", M_leftmost->M_value);\n    // if (M_rightmost) fprintf(stderr, \"rightmost: %d\\n\", M_rightmost->M_value);\n    // if (res.M_leftmost) fprintf(stderr, \"other.leftmost: %d\\n\", res.M_leftmost->M_value);\n    // if (res.M_rightmost) fprintf(stderr, \"other.rightmost: %d\\n\", res.M_rightmost->M_value);\n    return res;\n  }\n\n  template <typename Predicate>\n  iterator partition_point(Predicate pred) {\n    pointer cur = M_root;\n    if (!cur) return end();\n    // ... true false ...\n    //          ^\n    // fprintf(stderr, \"root: %d\\n\", cur->M_value);\n    // fprintf(stderr, \"left: [%p], right: [%p]\\n\", cur->M_children[0].get(), cur->M_children[1].get());\n    while (true) {\n      pointer tmp = cur->M_children[pred(cur->M_value)];\n      if (!tmp) break;\n      // fprintf(stderr, \"tmp: %d\\n\", tmp->M_value);\n      cur = tmp;\n    }\n    // fprintf(stderr, \"-> cur: %p\\n\", cur.get());\n    if (pred(cur->M_value)) cur = S_next(cur, this);\n    // fprintf(stderr, \"--> cur: %p\\n\", cur.get());\n    // if (cur) {\n    //   fprintf(stderr, \"cur: %d (%p)\\n\", cur->M_value, cur.get());\n    // }\n    M_root = S_splay(cur? cur: M_rightmost);\n    return iterator(cur, this);\n  }\n};\n\nint arc033_c() {\n  size_t q;\n  scanf(\"%zu\", &q);\n\n  order_statistic_tree<int> ost;\n  for (size_t i = 0; i < q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 1) {\n      int x;\n      scanf(\"%d\", &x);\n      ost.insert(ost.partition_point([x](int y) { return y < x; }), x);\n    } else if (t == 2) {\n      ptrdiff_t x;\n      scanf(\"%td\", &x);\n      --x;\n      auto it = ost.begin() + x;\n      printf(\"%d\\n\", *it);\n      ost.erase(it);\n    }\n\n    // fprintf(stderr, \"size: %zu\\n\", ost.size());\n    // for (auto it = ost.begin(); it != ost.end(); ++it)\n    //   fprintf(stderr, \"%d%c\", *it, (std::next(it) != ost.end())? ' ': '\\n');\n  }\n  return 0;\n}\n\n#include <vector>\n#include <numeric>\n\nint aoj2890() {\n  size_t n, q;\n  scanf(\"%zu %zu\", &n, &q);\n\n  std::vector<int> a(n);\n  for (auto& ai: a) scanf(\"%d\", &ai), --ai;\n  order_statistic_tree<int> ost(a.begin(), a.end());\n\n  std::vector<typename order_statistic_tree<int>::const_iterator> its(n);\n  {\n    for (auto it = ost.begin(); it != ost.end(); ++it)\n      its[*it] = it;\n  }\n\n  for (size_t i = 0; i < q; ++i) {\n    size_t j;\n    scanf(\"%zu\", &j);\n    --j;\n\n    auto center = ost.split(its[j]);\n    auto right = center.split(++center.begin());\n    center.merge(ost);\n    right.merge(center);\n    ost = std::move(right);\n  }\n\n  for (auto it = ost.begin(); it != ost.end(); ++it)\n    printf(\"%d%c\", *it+1, (std::next(it)!=ost.end())? ' ': '\\n');\n\n  return 0;\n}\n\nint aoj_itp2_7_c() {\n  size_t q;\n  scanf(\"%zu\", &q);\n\n  order_statistic_tree<int> ost;\n  for (size_t i = 0; i < q; ++i) {\n    int t;\n    scanf(\"%d\", &t);\n\n    if (t == 0) {\n      // insert(x)\n      int x;\n      scanf(\"%d\", &x);\n      auto it = ost.partition_point([x](int y) { return x > y; });\n      if (it == ost.end() || *it != x) ost.insert(it, x);\n      // fprintf(stderr, \"inserted %d\\n\", x);\n      printf(\"%zu\\n\", ost.size());\n    } else if (t == 1) {\n      // find(x)\n      int x;\n      scanf(\"%d\", &x);\n      auto it = ost.partition_point([x](int y) { return x > y; });\n      printf(\"%d\\n\", (it != ost.end() && *it == x));\n    } else if (t == 2) {\n      // delete(x)\n      int x;\n      scanf(\"%d\", &x);\n      auto it = ost.partition_point([x](int y) { return x > y; });\n      if (it != ost.end() && *it == x) ost.erase(it);\n      // fprintf(stderr, \"erased %d\\n\", x);\n    } else if (t == 3) {\n      // dump(x, y)\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      auto it = ost.partition_point([x](int z) { return x > z; });\n      while (it != ost.end() && *it <= y)\n        printf(\"%d\\n\", *it++);\n    }\n  }\n  return 0;\n}\n\nint main() {\n  aoj_itp2_7_c();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = 1LL<<55;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  set<int> S;\n  \n  int q;\n  cin>>q;\n  while(q--){\n    int cmd, num;\n    cin>>cmd>>num;\n    if(cmd == 0){\n      S.insert(num);\n      cout<<S.size()<<endl;\n    }\n\n    if(cmd == 1){\n      cout<<S.count(num)<<endl;\n    }\n    \n    if(cmd == 2){\n      S.erase(num);\n    }\n\n    if(cmd == 3){\n      int l = num, r;\n      cin>>r;\n      auto start = S.lower_bound(l);\n      //auto last= S.upper_bound(r);\n      for(auto it = start; it != S.end() && *it <= r; it++) cout<<*it<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int q;\n    cin>>q;\n\n    set<int> Set;\n    while(q--)\n    {\n        int op,x;\n        cin>>op>>x;\n\n        if(!op)\n        {\n            Set.insert(x);\n            cout<<Set.size()<<endl;\n        }else if(op==1)\n        {\n            cout<<(Set.find(x)!=Set.end())<<endl;\n        }else if(op==2)\n        {\n            Set.erase(x);\n        }else if(op==3)\n        {\n            int l=x,r,cnt=0;\n            cin>>r;\n            for(auto i=Set.lower_bound(l);i!=Set.end()&&*i<=r;i++)\n                cout<<*i<<endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define MAX 100005\n#define INF 1001001001\n\nint main(int, char**)\n{\n  set<int> a;\n  int q;\n  cin >> q;\n  vector<int> ans;\n  rep(i,q) {\n    int command; cin >> command;\n    if (command == 0) {\n      int x; cin >> x;\n      a.insert(x);\n      ans.push_back(a.size());\n    } else if (command == 1) {\n      int x; cin >> x;\n      ans.push_back(a.find(x) != a.end());\n    } else if (command == 2) {\n      int x; cin >> x;\n      a.erase(x);\n    } else if (command == 3) {\n      int l, r; cin >> l >> r;      \n      auto itrl = a.lower_bound(l);\n      auto itrr = a.upper_bound(r);\n      for (auto itr = itrl; itr != itrr; itr++) ans.push_back(*itr);\n    }\n  }\n\n  for (auto a : ans) cout << a << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i) \n#define PI acos(-1)\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing LP = pair<ll, ll>;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int q;\n    cin>>q;\n    set<int> st;\n    rep(i, q) {\n        int m, x;\n        cin>>m>>x;\n        if (m == 0) {\n            st.insert(x);\n            cout<<st.size()<<endl;\n        }\n        else if (m == 1) {\n            cout<<st.count(x)<<endl;\n        }\n        else if (m == 2) {\n            st.erase(x);\n        }\n        else {\n            int r;\n            cin>>r;\n            auto it = st.lower_bound(x);\n            auto cl = st.upper_bound(r);\n            for (; it != cl; ++it) {\n                cout<<*it<<endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nset<int>st;\nint main() {\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint Q, k;\n\t\tcin >> Q >> k;\n\t\tif (Q == 0) {\n\t\t\tst.insert(k);\n\t\t\tcout << st.size() << endl;\n\t\t}\n\t\telse if (Q == 1) {\n\t\t\tcout << st.count(k) << endl;\n\t\t}\n\t\telse if (Q == 2) {\n\t\t\tst.erase(k);\n\t\t}\n\t\telse {\n\t\t\tint y;\n\t\t\tcin >> y;\n\t\t\tauto itr = st.lower_bound(k);\n\t\t\twhile (*itr <= y) {\n\t\t\t\tcout << *itr << endl;\n\t\t\t\titr++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main(void) {\n  set<int> s;\n  int q, command, x;\n  cin >> q;\n\n  for(int i = 0; i < q; i++) {\n    cin >> command >> x;\n    switch(command) {\n      case 0:\n        s.insert(x);\n        cout << s.size() << endl;\n        break;\n      case 1:\n        cout << s.count(x) << endl;\n        break;\n      case 2:\n        s.erase(x);\n        break;\n      case 3:\n        int l, r;\n        l = x;\n        set<int>::iterator st, tm, it;\n        cin >> r;\n        st = s.lower_bound(l);\n        tm = s.upper_bound(r);\n        for(it = st; it != tm; it++) {\n          cout << *it << endl;\n        }\n        break;\n    }  \n  }\n  \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nset<int>st;\nint main() {\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint Q, k;\n\t\tcin >> Q >> k;\n\t\tif (Q == 0) {\n\t\t\tst.insert(k);\n\t\t\tcout << st.size() << endl;\n\t\t}\n\t\telse if (Q == 1) {\n\t\t\tcout << st.count(k) << endl;\n\t\t}\n\t\telse if (Q == 2) {\n\t\t\tst.erase(k);\n\t\t}\n\t\telse {\n\t\t\tint y;\n\t\t\tcin >> y;\n\t\t\tfor (auto t : st)if (k <= t && t <= y)cout << t << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\n\nint main()\n{\n    int q,ope;\n    long long num,L,R;\n    std::cin>>q;\n    std::set<long long> S;\n    \n    for(int i = 0; i < q; i++)\n    {\n        std::cin>>ope;\n        if(ope==1){std::cin>>num; std::cout<<S.count(num)<<std::endl;}\n        else if(ope==0){std::cin>>num; S.insert(num); std::cout<<S.size()<<std::endl;}\n        else if(ope==2){std::cin>>num; S.erase(num);}\n        else{\n            std::cin>>L>>R;\n            auto a = S.lower_bound(L);\n            auto b = S.upper_bound(R);\n            for(auto it = a; it!=b; it++){std::cout<<*it<<std::endl;}\n        }\n    } \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  \n  int q, com, x, l, r;\n  set<int> S;\n  \n  cin >> q;\n  for(int i = 0;i < q;i++){\n    cin >> com;\n    \n    if(com == 0){\n      cin >> x;\n      S.insert(x);\n      cout << S.size() << endl;\n    }else if(com == 1){\n      cin >> x;\n      cout << S.count(x) << endl;\n    }else if(com == 2){\n      cin >> x;\n      S.erase(x);\n    }else if(com == 3){\n      set<int>::iterator itl, itr;\n      \n      cin >> l >> r;\n      itl = lower_bound(S.begin(), S.end(), l);\n      itr = upper_bound(S.begin(), S.end(), r);\n      \n      for(set<int>::iterator it = itl;it != itr;it++) cout << *it << endl;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<set>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\n//#define int long long\ntypedef pair<int, int> pii;\ntypedef pair<int, pii > piii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, char> pic;\ntypedef priority_queue<pii, vector<pii>, greater<pii> > RPQ;\n#define mk make_pair\n#define INF (1 << 30)\n#define INFL (1ll << 60ll)\n#define mod 1000000007\n\nint Q;\n\nsigned main(){\n    set<int> s;\n    scanf(\"%d\", &Q);\n    s.insert(INF);\n    for(int i = 0; i < Q; i++){\n        int q;\n        cin >> q;\n        if(q < 3){\n            int x;\n            scanf(\"%d\", &x);\n            if(q == 0){\n                s.insert(x);\n                printf(\"%d\\n\", (int)s.size() - 1);\n            }\n            else if(q == 1)printf(\"%d\\n\", s.count(x));\n            else {\n                if(s.count(x))s.erase(x);\n            }\n        }\n        else {\n            int L, R;\n            scanf(\"%d%d\", &L, &R);\n            auto lb = s.lower_bound(L);\n            auto ub = s.upper_bound(R);\n            for(auto j = lb; j != ub; j++){\n                printf(\"%d\\n\", *j);\n            }\n        }\n    }\n\n\n    return 0;\n}\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <functional>\n#include <set>\n\n#define INPUT_FROM_FILE (0) \n#if INPUT_FROM_FILE\n#include <fstream>\n#endif\n\n\nint main(){\n\tint q, com;\n\tlong x;\n\tlong L, R;\n\tstd::set<long> s;\n\n#if INPUT_FROM_FILE\n\tstd::ifstream ifs(\"test.txt\");\n#endif\n\n#if INPUT_FROM_FILE\n\tifs >> q;\n#else\n\tstd::cin >> q;\n#endif\n\t\n\tfor(int i = 0; i < q; i++){\n#if INPUT_FROM_FILE\n\t\tifs >> com >> x;\n#else\n\t\tstd::cin >> com >> x;\n#endif\n\t\tif(com == 0){\n\t\t\ts.insert(x);\n\t\t\tstd::cout << s.size() << std::endl;\n\t\t}\n\t\telse if(com == 1){\n\t\t\tstd::cout << s.count(x) << std::endl;\n\t\t}\n\t\telse if(com == 2){\n\t\t\ts.erase(x);\n\t\t}\n\t\telse{\n\t\t\tL = x;\n#if INPUT_FROM_FILE\n\t\t\tifs >> R;\n#else\n\t\t\tstd::cin >> R;\n#endif\n\t\t\tstd::set<long>::iterator it = s.lower_bound(L);\n\t\t\twhile(it != s.end() && *it <= R){\n\t\t\t\tstd::cout <<  *it << std::endl;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\n\n//van Emde Boas trees 要素は正の整数\nclass VEBtree;\n\nclass VEBtreeNode{\n\tusing Number = unsigned long long;\n\tfriend VEBtree;\n\tconst Number K;\n\tconst Number uppersqrt = (1 << ((K+1) >> 1));\n\tconst Number lowersqrt = (1 << (K >> 1));\n\tNumber min_ = 1, max_ = 0;\n\tstd::vector<VEBtreeNode> cluster;\n\tVEBtreeNode *summary;\n\n\tNumber high(Number x){ return x/lowersqrt ;}\n\tNumber low(Number x){ return x % lowersqrt;}\n\tNumber index(Number x, Number y){ return x*lowersqrt + y;}\n\n\tvoid empty_insert(Number x){\n\t\tmin_ = x;\n\t\tmax_ = x;\n\t}\n\tNumber min(){ return min_;}\n\tNumber max(){ return max_;}\n\n\tbool member(Number x){\n\t\tif(min() > max())return false;\n\t\tif(x == min() || x == max())return true;\n\t\telse if(K == 1)return false;\n\t\tassert(high(x) < cluster.size());\n\t\treturn cluster[high(x)].member(low(x));\n\t}\n\n\tNumber successor(Number x){\n\t\tif(K == 1){\n\t\t\tif(x == 0 and max() == 1) return 1;\n\t\t\telse return x;\n\t\t}\n\t\telse if(min() <= max() and x < min()) return min();\n\t\telse{\n\t\t\tNumber max_low = cluster[high(x)].max();\n\t\t\tif(cluster[high(x)].min() <= max_low and low(x) < max_low){\n\t\t\t\tNumber offset = cluster[high(x)].successor(low(x));\n\t\t\t\treturn index(high(x), offset);\n\t\t\t}\n\t\t\tNumber succ_cluster = summary->successor(high(x));\n\t\t\tif(succ_cluster == high(x)) return x;\n\t\t\telse{\n\t\t\t\tNumber offset = cluster[succ_cluster].min();\n\t\t\t\treturn index(succ_cluster, offset);\n\t\t\t}\n\t\t}\n\t}\n\n\tNumber predecessor(Number x){\n\t\tif(K == 1){\n\t\t\tif(x == 1 and min() == 0) return 0;\n\t\t\telse return x;\n\t\t}\n\t\telse if(min() <= max() and x > max()){ return max();}\n\t\telse{\n\t\t\tNumber min_low = cluster[high(x)].min();\n\t\t\tif(min_low <= cluster[high(x)].max() and low(x) > min_low){\n\t\t\t\tNumber offset = cluster[high(x)].predecessor(low(x));\n\t\t\t\treturn index(high(x), offset);\n\t\t\t}\n\t\t\tNumber pred_cluster = summary->predecessor(high(x));\n\t\t\tif(pred_cluster == high(x)){ return x;}\n\t\t\telse{\n\t\t\t\tNumber offset = cluster[pred_cluster].max();\n\t\t\t\treturn index(pred_cluster, offset);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid insert(Number x){\n\t\tif(min() > max()) empty_insert(x);\n\t\telse{\n\t\t\tif(x < min()) std::swap(x, min_);\n\t\t\tif(K > 1){\n\t\t\t\tif(cluster[high(x)].min() > cluster[high(x)].max()){\n\t\t\t\t\tsummary->insert(high(x));\n\t\t\t\t\tcluster[high(x)].empty_insert(low(x));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcluster[high(x)].insert(low(x));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x > max()){\n\t\t\t\tmax_ = x;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid erase(Number x){\n\t\tif(min() == max()){\n\t\t\tmin_ = 1; max_ = 0;\n\t\t}\n\t\telse if(K == 1){\n\t\t\tif( x == 0) min_ = 1;\n\t\t\telse min_ = 0;\n\t\t\tmax_ = min_;\n\t\t}\n\t\telse{\n\t\t\tif(x == min()){\n\t\t\t\tNumber first_cluster = summary->min();\n\t\t\t\tx = index(first_cluster, cluster[first_cluster].min());\n\t\t\t\tmin_ = x;\n\t\t\t}\n\t\t\tcluster[high(x)].erase(low(x));\n\t\t\tif(cluster[high(x)].min() > cluster[high(x)].max()){\n\t\t\t\tsummary->erase(high(x));\n\t\t\t\tif(x == max()){\n\t\t\t\t\tNumber summary_max = summary->max();\n\t\t\t\t\tif(summary_max < summary->min()) max_ = min();\n\t\t\t\t\telse max_ = index(summary_max, cluster[summary_max].max());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(x == max()){\n\t\t\t\tmax_ = index(high(x), cluster[high(x)].max());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic:\n\t\tVEBtreeNode(const VEBtreeNode& m):K(m.getK()){\n\t\t\tif(K != 1){\n\t\t\t\tsummary = new VEBtreeNode((K+1)>>1);\n\t\t\t\tcluster = std::vector<VEBtreeNode>(uppersqrt, VEBtreeNode(K>>1));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsummary = NULL;\n\t\t\t}\n\t\t}\n\n\t\tVEBtreeNode(Number k): K(k){\n\t\t\tif(K != 1){\n\t\t\t\tsummary = new VEBtreeNode((K+1) >> 1);\n\t\t\t\tcluster = std::vector<VEBtreeNode>(uppersqrt, VEBtreeNode(K>>1));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsummary = NULL;\n\t\t\t}\n\t\t}\n\n\t\t~VEBtreeNode() = default;\n\n\t\tNumber getK()const{return K;}\n};\n\nclass VEBtree{\n\tusing Number = unsigned long long;\n\tVEBtreeNode *root;\n\tsize_t size_;\npublic:\n\tVEBtree(): root(new VEBtreeNode(24)), size_(0){}\n\tVEBtree(Number universe): size_(0){\n\t\tNumber K = 0;\n\t\tfor(universe--;universe;universe >>= 1)K++;\n\t\troot = new VEBtreeNode(K ? K : 1);\n\t}\n\t~VEBtree(){ delete root;}\n\n\tsize_t size()const{return size_;}\n\tNumber min(){ return root->min();}\n\tNumber max(){ return root->max();}\n\tbool member(Number e){ return root->member(e);}\n\tNumber successor(Number e){\n\t\treturn root->successor(e);\n\t}\n\tNumber predecessor(Number e){\n\t\treturn root->predecessor(e);\n\n\t}\n\tvoid insert(Number e){\n\t\tif(!root->member(e)){\n\t\t\troot->insert(e);\n\t\t\tsize_++;\n\t\t}\n\t}\n\tvoid erase(Number e){\n\t\tif(root->member(e)){\n\t\t\troot->erase(e);\n\t\t\tsize_--;\n\t\t}\n\t}\n\n\t\t\n};\n\nsigned main(){\n\tusing namespace std;\n\tint n; cin >> n;\n\tVEBtree t((unsigned ll)1e9);\n\tfor(int i = 0; i < n; i++){\n\t\tint q;cin >> q;\n\t\tunsigned long long x, y, prev; cin >> x;\n\t\tswitch(q){\n\t\t\tcase 0:\n\t\t\t\tt.insert(x);\n\t\t\t\tcout << t.size() << endl;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcout << t.member(x) << endl;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tt.erase(x);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcin >> y;\n\t\t\t\tx = t.member(x) ? x : t.successor(x);\n\t\t\t\tif(t.size() > 0){\n\t\t\t\t\tdo{\n\t\t\t\t\t\tprev = x;\n\t\t\t\t\t\tcout << x << endl;\n\t\t\t\t\t\tx = t.successor(x);\n\t\t\t\t\t}while(prev != x && x <= y);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t{\n\t\tunsigned ll i = t.min(),prev;\n\t\tdo{\n\t\t\tprev = i;\n\t\t\ti = t.successor(i);\n\t\t}while(i != prev);\n\t}\n\t\t\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#define int long long\nusing namespace std;\nsigned main() {\n\tset<int>s;\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint k, x; cin >> k >> x;\n\t\tif (k == 0) {\n\t\t\ts.insert(x);\n\t\t\tcout << s.size() << endl;\n\t\t}\n\t\telse if (k == 1) {\n\t\t\tif (s.lower_bound(x) != s.end()) {\n\t\t\t\tif (*s.lower_bound(x) == x)cout << \"1\\n\";\n\t\t\t\telse cout << \"0\\n\";\n\t\t\t}\n\t\t\telse cout << \"0\\n\";\n\t\t}\n\t\telse if (k == 2) {\n\t\t\tif (s.lower_bound(x) != s.end()) {\n\t\t\t\tif (*s.lower_bound(x) == x)s.erase(s.lower_bound(x));\n\t\t\t}\n\t\t}\n\t\telse if (k == 3) {\n\t\t\tint y; cin >> y;\n\t\t\tfor (auto i = s.lower_bound(x); i != s.upper_bound(y); i++)cout << *i << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int q; cin >> q;\n  set<int> st;\n  for (int i = 0; i < q; i++) {\n    int cmd; cin >> cmd;\n    if (cmd == 0) {\n      int x; cin >> x;\n      st.insert(x);\n      cout << st.size() << endl;\n    }\n    if (cmd == 1) {\n      int x; cin >> x;\n      cout << st.count(x) << endl;\n    }\n    if (cmd == 2) {\n      int x; cin >> x;\n      st.erase(x);\n    }\n    if (cmd == 3) {\n      int l, r; cin >> l >> r;\n      for (int i = l; i <= r; i++) {\n        if (st.count(i)) {\n          auto itr = st.find(i);\n          cout << *itr << endl;\n        }\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<time.h>\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left;\n\tstruct node *right;\n}node;\n\nint cnt=0;\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n\n\twhile(p!=NULL){\n\t\tif(p->key == x)return 1;\n\t\telse if(p->key > x)p=p->left;\n\t\telse p=p->right;\n\t}\n\t\n\treturn 0;\n\t\n}\n\n\nnode * makenode(int x,int y){\n\tnode *new=malloc(sizeof(node));\n\tnew->key=x;\n\tnew->priority=y;\n\tnew->left=NULL;\n\tnew->right=NULL;\n\treturn new;\n}\n\nnode *rightRotate(node *p){\n\tnode *q=p->left;\n\tp->left=q->right;\n\tq->right=p;\n\treturn q;\n}\n\nnode *leftRotate(node *p){\n\tnode *q=p->right;\n\tp->right=q->left;\n\tq->left=p;\n\treturn q;\n}\n\n\nnode* insert(node **t,int key,int priority){\n\tnode *new;\n\t\n\tif((*t)==NULL)\n\t\treturn new=makenode(key,priority);\n\tif ((*t)->key==key)\n\t\treturn *t;\n\t\n\tif(key < (*t)->key){\n\t\t(*t)->left=insert(&(*t)->left,key,priority);\n\t\tif((*t)->priority < (*t)->left->priority)\n\t\t\t(*t)=rightRotate((*t));\n\t}\n\telse {\n\t\t(*t)->right=insert(&(*t)->right,key,priority);\n\t\tif((*t)->priority < (*t)->right->priority)\n\t\t\t(*t)=leftRotate((*t));\n\t}\n\t\n\treturn *t;\n}\n\n\nnode * Delete(node **t,int key){\n\tif((*t)==NULL)\n\t\treturn NULL;\n\t\t\n\tif(key < (*t)->key)\n\t\t(*t)->left=Delete(&((*t)->left),key);\n\t\t\n\telse if(key > (*t)->key)\n\t\t(*t)->right=Delete(&((*t)->right),key);\n\t\t\n\telse return _delete(t,key);\n\t\n\treturn *t;\n}\n\nnode * _delete(node **t,int key){\n\tif((*t)->left==NULL && (*t)->right==NULL)\n\t\treturn NULL;\n\telse if((*t)->left==NULL)\n\t\t(*t)=leftRotate(*t);\n\telse if((*t)->right==NULL)\n\t\t(*t)=rightRotate(*t);\n\telse {\n\t\tif((*t)->left->priority > (*t)->right->priority)\n\t\t\t(*t)=rightRotate(*t);\n\t\telse\n\t\t\t(*t)=leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\n\nvoid dump(node *p,int L,int R){\n\tif(p==NULL)return;\n\tif(cnt>=1000000)return;\n\n\tif(p->left!=NULL && p->key!=L)\n\t\tdump(p->left,L,R);\n\t\n\tif(p->key >= L && p->key <= R){\n\t\tprintf(\"%d\\n\",p->key);\n\t\tcnt++;\n\t\tif(cnt>=1000000)return;\n\t}\n\t\n\tif(p->right!=NULL && p->key!=R)\n\t\tdump(p->right,L,R);\n\t\n\treturn;\n\t\n}\n\t\n\nint main(){\n\tint q,x,com,y;\n\tint num=0;\n\tnode *root=NULL;\n\tsrand((unsigned)time(NULL));\n\t\n\tscanf(\"%d\",&q);\n\t\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d %d\",&com,&x);\n\t\t\n\t\tif(com==0){\n\t\t\tif(!find(root,x)){\n\t\t\t\troot=insert(&root,x,rand()%200001);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",num);\n\t\t}\n\t\telse if(com==1){\n\t\t\tif(find(root,x))printf(\"1\\n\");\n\t\t\telse printf(\"0\\n\");\n\t\t}\n\t\t\n\t\telse if(com==2){\n\t\t\tif(find(root,x)){\n\t\t\t\troot=Delete(&root,x);\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse {\n\t\t\tscanf(\"%d\",&y);\n\t\t\tdump(root,x,y);\n\t\t}\n\t}\n\t\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nunsigned xor128() {\n\tstatic unsigned x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n\tunsigned t = x ^ (x << 11);\n\tx = y; y = z; z = w;\n\treturn w = w ^ (w >> 19) ^ (t ^ (t >> 8));\n}\n\ntypedef struct node_t {\n\tint val;\n\tstruct node_t *lch, *rch;\n\tint size;\n\tunsigned int pri;\n} node;\n\nnode* new_node(int val) {\n\tstatic int it = 0;\n\tstatic node pool[200000];\n\tpool[it] = (node) { val, 0, 0, 1, xor128() };\n\treturn &pool[it++];\n}\n\nint count(node *t) {\n\treturn !t ? 0 : t->size;\n}\n\nnode *update(node *t) {\n\tt->size = count(t->lch) + count(t->rch) + 1;\n\treturn t;\n}\n\nnode *merge(node *l, node *r) {\n\tif (!l || !r) return !l ? r : l;\n\tif (l->pri > r->pri) {\n\t\tl->rch = merge(l->rch, r);\n\t\treturn update(l);\n\t}\n\tr->lch = merge(l, r->lch);\n\treturn update(r);\n}\n\ntypedef struct{ node *a, *b; } pnode;\n\npnode split(node *t, int k) {\n\tif (!t) return (pnode) { 0, 0 };\n\tif (k <= count(t->lch)) {\n\t\tpnode s = split(t->lch, k);\n\t\tt->lch = s.b;\n\t\treturn (pnode) { s.a, update(t) };\n\t}\n\tpnode s = split(t->rch, k - count(t->lch) - 1);\n\tt->rch = s.a;\n\treturn (pnode) { update(t), s.b };\n}\n\nnode* find(node *t, int val) {\n\twhile (t) {\n\t\tif (t->val == val) break;\n\t\tt = val < t->val ? t->lch : t->rch;\n\t}\n\treturn t;\n}\n\nint count_lower(node *t, int v) {\n\tif (!t) return 0;\n\tif (t->val < v) return count(t->lch) + 1 + count_lower(t->rch, v);\n\tif (t->val == v) return count(t->lch);\n\treturn count_lower(t->lch, v);\n}\n\nnode *insert(node *t, int val) {\n\tint k = count_lower(t, val);\n\tpnode s = split(t, k);\n\treturn merge(merge(s.a, new_node(val)), s.b);\n}\n\nnode *erase(node *t, int k) {\n\tpnode s1 = split(t, k), s2 = split(s1.b, 1);\n\treturn merge(s1.a, s2.b);\n}\n\nvoid print(node *t) {\n\tif (!t) return;\n\tprint(t->lch);\n\tprintf(\"%d\\n\", t->val);\n\tprint(t->rch);\n}\n\nint main(void)\n{\n\tint q, com, x, l, r, cnt = 0;\n\tnode *root = 0;\n\tpnode p1, p2;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tscanf(\"%d%d\", &com, &x);\n\t\tif (com == 0) {\n\t\t\tif (!find(root, x)) ++cnt, root = insert(root, x);\n\t\t\tprintf(\"%d\\n\", cnt);\n\t\t}\n\t\telse if (com == 1) {\n\t\t\tputs(find(root, x) ? \"1\" : \"0\");\n\t\t}\n\t\telse if (com == 2) {\n\t\t\tif (find(root, x)) --cnt, root = erase(root, count_lower(root, x));\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d\", &r);\n\t\t\tl = count_lower(root, x);\n\t\t\tr = count_lower(root, r + 1);\n\t\t\tp1 = split(root, l), p2 = split(p1.b, r - l);\n\t\t\tprint(p2.a);\n\t\t\troot = merge(merge(p1.a, p2.a), p2.b);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<time.h>\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left;\n\tstruct node *right;\n}node;\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n\n\twhile(p!=NULL){\n\t\tif(p->key == x)return 1;\n\t\telse if(p->key > x)p=p->left;\n\t\telse p=p->right;\n\t}\n\t\n\treturn 0;\n\t\n}\n\n\nnode * makenode(int x,int y){\n\tnode *new=malloc(sizeof(node));\n\tnew->key=x;\n\tnew->priority=y;\n\tnew->left=NULL;\n\tnew->right=NULL;\n\treturn new;\n}\n\nnode *rightRotate(node *p){\n\tnode *q=p->left;\n\tp->left=q->right;\n\tq->right=p;\n\treturn q;\n}\n\nnode *leftRotate(node *p){\n\tnode *q=p->right;\n\tp->right=q->left;\n\tq->left=p;\n\treturn q;\n}\n\n\nnode* insert(node **t,int key,int priority){\n\tnode *new;\n\t\n\tif((*t)==NULL)\n\t\treturn new=makenode(key,priority);\n\tif ((*t)->key==key)\n\t\treturn *t;\n\t\n\tif(key < (*t)->key){\n\t\t(*t)->left=insert(&(*t)->left,key,priority);\n\t\tif((*t)->priority < (*t)->left->priority)\n\t\t\t(*t)=rightRotate((*t));\n\t}\n\telse {\n\t\t(*t)->right=insert(&(*t)->right,key,priority);\n\t\tif((*t)->priority < (*t)->right->priority)\n\t\t\t(*t)=leftRotate((*t));\n\t}\n\t\n\treturn *t;\n}\n\n\nnode * Delete(node **t,int key){\n\tif((*t)==NULL)\n\t\treturn NULL;\n\t\t\n\tif(key < (*t)->key)\n\t\t(*t)->left=Delete(&((*t)->left),key);\n\t\t\n\telse if(key > (*t)->key)\n\t\t(*t)->right=Delete(&((*t)->right),key);\n\t\t\n\telse return _delete(t,key);\n\t\n\treturn *t;\n}\n\nnode * _delete(node **t,int key){\n\tif((*t)->left==NULL && (*t)->right==NULL)\n\t\treturn NULL;\n\telse if((*t)->left==NULL)\n\t\t(*t)=leftRotate(*t);\n\telse if((*t)->right==NULL)\n\t\t(*t)=rightRotate(*t);\n\telse {\n\t\tif((*t)->left->priority > (*t)->right->priority)\n\t\t\t(*t)=rightRotate(*t);\n\t\telse\n\t\t\t(*t)=leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\n\nvoid dump(node *p,int L,int R){\n\tif(p==NULL)return;\n\tif(p->key < L || p->key >R)return;\n\n\tif(p->left!=NULL)\n\t\tdump(p->left,L,R);\n\t\n\tif(p->key >= L && p->key <= R)\n\t\tprintf(\"%d\\n\",p->key);\n\t\n\tif(p->right!=NULL)\n\t\tdump(p->right,L,R);\n\t\n\treturn;\n\t\n}\n\t\n\nint main(){\n\tint q,x,com,y;\n\tint num=0;\n\tnode *root=NULL;\n\tsrand((unsigned)time(NULL));\n\t\n\tscanf(\"%d\",&q);\n\t\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d %d\",&com,&x);\n\t\t\n\t\tif(com==0){\n\t\t\tif(!find(root,x)){\n\t\t\t\troot=insert(&root,x,rand()%200001);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",num);\n\t\t}\n\t\telse if(com==1){\n\t\t\tif(find(root,x))printf(\"1\\n\");\n\t\t\telse printf(\"0\\n\");\n\t\t}\n\t\t\n\t\telse if(com==2){\n\t\t\tif(find(root,x)){\n\t\t\t\troot=Delete(&root,x);\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse {\n\t\t\tscanf(\"%d\",&y);\n\t\t\tdump(root,x,y);\n\t\t}\n\t}\n\t\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<time.h>\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left;\n\tstruct node *right;\n}node;\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n\n\twhile(p!=NULL){\n\t\tif(p->key == x)return 1;\n\t\telse if(p->key > x)p=p->left;\n\t\telse p=p->right;\n\t}\n\t\n\treturn 0;\n\t\n}\n\n\nnode * makenode(int x,int y){\n\tnode *new=malloc(sizeof(node));\n\tnew->key=x;\n\tnew->priority=y;\n\tnew->left=NULL;\n\tnew->right=NULL;\n\treturn new;\n}\n\nnode *rightRotate(node *p){\n\tnode *q=p->left;\n\tp->left=q->right;\n\tq->right=p;\n\treturn q;\n}\n\nnode *leftRotate(node *p){\n\tnode *q=p->right;\n\tp->right=q->left;\n\tq->left=p;\n\treturn q;\n}\n\n\nnode* insert(node **t,int key,int priority){\n\tnode *new;\n\t\n\tif((*t)==NULL)\n\t\treturn new=makenode(key,priority);\n\tif ((*t)->key==key)\n\t\treturn *t;\n\t\n\tif(key < (*t)->key){\n\t\t(*t)->left=insert(&(*t)->left,key,priority);\n\t\tif((*t)->priority < (*t)->left->priority)\n\t\t\t(*t)=rightRotate((*t));\n\t}\n\telse {\n\t\t(*t)->right=insert(&(*t)->right,key,priority);\n\t\tif((*t)->priority < (*t)->right->priority)\n\t\t\t(*t)=leftRotate((*t));\n\t}\n\t\n\treturn *t;\n}\n\n\nnode * Delete(node **t,int key){\n\tif((*t)==NULL)\n\t\treturn NULL;\n\t\t\n\tif(key < (*t)->key)\n\t\t(*t)->left=Delete(&((*t)->left),key);\n\t\t\n\telse if(key > (*t)->key)\n\t\t(*t)->right=Delete(&((*t)->right),key);\n\t\t\n\telse return _delete(t,key);\n\t\n\treturn *t;\n}\n\nnode * _delete(node **t,int key){\n\tif((*t)->left==NULL && (*t)->right==NULL)\n\t\treturn NULL;\n\telse if((*t)->left==NULL)\n\t\t(*t)=leftRotate(*t);\n\telse if((*t)->right==NULL)\n\t\t(*t)=rightRotate(*t);\n\telse {\n\t\tif((*t)->left->priority > (*t)->right->priority)\n\t\t\t(*t)=rightRotate(*t);\n\t\telse\n\t\t\t(*t)=leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\n\nvoid dump(node *p,int L,int R){\n\tif(p==NULL)return;\n\n\tif(p->left!=NULL)\n\t\tdump(p->left,L,R);\n\t\n\tif(p->key >= L && p->key <= R)\n\t\tprintf(\"%d\\n\",p->key);\n\t\n\tif(p->right!=NULL)\n\t\tdump(p->right,L,R);\n\t\n\treturn;\n\t\n}\n\t\n\nint main(){\n\tint q,x,com,y;\n\tint num=0;\n\tnode *root=NULL;\n\tsrand((unsigned)time(NULL));\n\t\n\tscanf(\"%d\",&q);\n\t\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d %d\",&com,&x);\n\t\t\n\t\tif(com==0){\n\t\t\tif(!find(root,x)){\n\t\t\t\troot=insert(&root,x,rand()%200001);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",num);\n\t\t}\n\t\telse if(com==1){\n\t\t\tif(find(root,x))printf(\"1\\n\");\n\t\t\telse printf(\"0\\n\");\n\t\t}\n\t\t\n\t\telse if(com==2){\n\t\t\tif(find(root,x)){\n\t\t\t\troot=Delete(&root,x);\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse {\n\t\t\tscanf(\"%d\",&y);\n\t\t\tdump(root,x,y);\n\t\t}\n\t}\n\t\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint search(int s[],int key,int head,int tail){\n    if(head>tail)return -1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]==key)return mid;\n    else if(s[mid]>key)tail=mid-1;\n    else if(s[mid]<key)head=mid+1;\n    \n    return search(s,key,head,tail);\n}\nint getLB(int s[],int key,int head,int tail){\n    if(s[0]>key)return 0;\n    if(s[tail]<key)return tail+1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]<key)head=mid+1;\n    else if(s[mid]>=key){\n        if(s[mid-1]<key)return mid;\n        else tail=mid-1;\n    }\n        \n    return getLB(s,key,head,tail);\n}\nint insert(int s[],int key,int cnt){\n    int d;\n    if(cnt==0)d=0;\n    else d=getLB(s,key,0,cnt-1);\n    \n    int i;\n    for(i=cnt;i>d;i--)s[i]=s[i-1];\n    s[i]=key;\n    return 1;\n}\nint delete(int s[],int key,int cnt){\n    int d;\n    d=search(s,key,0,cnt-1);\n    if(d<0)return -1;\n    \n    int i;\n    for(i=d;i<cnt-1;i++)s[i]=s[i+1];\n    return 1;\n}\nvoid dump(int s[],int l,int r,int cnt){\n    int i;\n    i=getLB(s,l,0,cnt-1);\n    \n    while(s[i]<=r&&i<cnt)printf(\"%d\\n\",s[i++]);\n    return;\n}\nvoid print(int s[],int cnt){\n    printf(\"cnt=%d,s:\",cnt);\n    for(int i=0;i<cnt;i++)printf(\"%d \",s[i]);\n    printf(\"\\n\");\n    return;\n}\nint main(void){\n    int q;\n    scanf(\"%d\\n\",&q);\n    \n    int s[q];\n    int cnt=0;\n    \n    int com,x,y;\n    while(q--){\n        scanf(\"%d \",&com);\n        switch(com){\n            case 0:\n                //insert\n                scanf(\"%d\\n\",&x);\n//    printf(\"insert:%d\\n\",x);\n                if(search(s,x,0,cnt-1)==-1){\n                    if(insert(s,x,cnt)==1)cnt++;\n                }\n                printf(\"%d\\n\",cnt);\n                break;\n            case 1:\n                //find\n                scanf(\"%d\\n\",&x);\n//    printf(\"find:%d\\n\",x);\n                if(search(s,x,0,cnt-1)==-1)printf(\"0\\n\");\n                else printf(\"1\\n\");\n                break;\n            case 2:\n                //delete\n                scanf(\"%d\\n\",&x);\n//    printf(\"delete:%d\\n\",x);\n                if(delete(s,x,cnt)==1)cnt--;\n                break;\n            case 3:\n                //dump\n                scanf(\"%d %d\\n\",&x,&y);\n                dump(s,x,y,cnt);\n                break;\n        }\n//        print(s,cnt);\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\n#define\tll_int\tlong long int\n#define\tBUCKET_SIZE\t1000000\n#define\tSUB_SIZE\t1000\n\n\nint ELEMENT_N;\n\ntypedef struct data_t{\n\tll_int num;\n\tint n;\n\tstruct data_t *next;\n} DATA_T;\n\nDATA_T **S;\n\n\n// ハッシュテーブルの初期化\nvoid Init()\n{\n\tint i;\n\n\tfor(i = 0; i < BUCKET_SIZE; i++)\n\t\tS[i] = NULL;\n}\n\n\nll_int Hash(ll_int num)\n{\n\treturn num / SUB_SIZE;\n}\n\n\nDATA_T *Find(ll_int num)\n{\n\tll_int h;\n\tDATA_T *p;\n\n\n\th = Hash(num);\n\n\tfor(p = S[h]; p != NULL; p = p->next){\n\t\tif(num == p->num)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}\n\n\nvoid Insert(ll_int num)\n{\n\tll_int h;\n\tDATA_T *p;\n\tDATA_T *i, *j;\n\n\n\tif(( p = Find(num) )){\n\t\tp->n++;\n\t\treturn;\n\t}\n\n\n\t/* 挿入処理(比較して該当する場所へ突っ込む) */\n\tif( ( p = (DATA_T *)malloc(sizeof(DATA_T)) ) == NULL){\n\t\tprintf(\"malloc error\\n\");\n\t\texit(1);\n\t}\n\n\tp->num = num;\n\tp->n = 1;\n\th = Hash(num);\n\n\tif(S[h] == NULL){\n\t// 該当する添え字の箱が空の場合\n\t\tS[h] = p;\n\t\tp->next = NULL;\n\t}else if(num < S[h]->num){\n\t// 該当する添え字の先頭に挿入\n\t\tp->next = S[h];\n\t\tS[h] = p;\n\t}else{\n\t// 先頭以降への挿入\n\t\tfor(i = S[h], j = i->next; j != NULL; i = j, j = j->next){\n\t\t\tif(i->num < num && num < j->num){\n\t\t\t\ti->next = p;\n\t\t\t\tp->next = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(j == NULL){\n\t\t// 最後尾に突っ込む\n\t\t\ti->next = p;\n\t\t\tp->next = j;\n\t\t}\n\t}\n\n\tELEMENT_N++;\n}\n\n\nvoid Delete(ll_int num)\n{\n\tDATA_T *p, *q;\n\tll_int h;\n\n\n\tif(Find(num) == NULL)\n\t\treturn;\n\n\n\th = Hash(num);\n\tp = S[h];\n\tELEMENT_N--;\n\n\t// 先頭にある場合の処理\n\tif(num == p->num){\n\t\tS[h] = p->next;\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\t// 先頭以降の処理\n\tfor(q = p->next;; p = q, q = q->next){\n\t\tif(num == q->num){\n\t\t\tp->next = q->next;\n\t\t\tfree(q);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n// lとrを基準にハッシュテーブルの添え字を計算、条件にあった数値を出力\nvoid Dump(ll_int l, ll_int r)\n{\n\tDATA_T *p;\n\tll_int start_h, end_h;\n\tll_int i;\n\n\n\tstart_h = Hash(l);\n\tend_h = Hash(r);\n\n\tfor(i = start_h; i <= end_h; i++){\n\t\tfor(p = S[i]; p != NULL; p = p->next){\n\t\t\tif(r < p->num)\n\t\t\t\treturn;\n\n\t\t\tif(l <= p->num && p->num <= r)\n\t\t\t\tprintf(\"%lld\\n\", p->num);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tint q;\n\tint query;\n\tll_int num, l, r;\n\tDATA_T *p;\n\tint i;\n\n\n\tELEMENT_N = 0;\n\tS = (DATA_T **)malloc(sizeof(DATA_T *) * BUCKET_SIZE);\n\n\tscanf(\"%d\", &q);\n\n\tfor(i = 0; i < q; i++){\n\t\tscanf(\"%d\", &query);\n\n\t\tif(query == 0){\n\t\t// insert\n\t\t\tscanf(\"%lld\", &num);\n\t\t\tInsert(num);\n\t\t\tprintf(\"%d\\n\", ELEMENT_N);\n\t\t}else if(query == 1){\n\t\t// find\n\t\t\tscanf(\"%lld\", &num);\n\t\t\tif(( p = Find(num) ))\n\t\t\t\tprintf(\"1\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"0\\n\");\n\t\t}else if(query == 2){\n\t\t// Delete\n\t\t\tscanf(\"%lld\", &num);\n\t\t\tDelete(num);\n\t\t}else if(query == 3){\n\t\t// Dump\n\t\t\tscanf(\"%lld %lld\", &l, &r);\n\t\t\tDump(l, r);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n/*\n\t1,ハッシュ関数でいつも使う「find」でDumpしようと思ったがタイムオーバー\n\t->失敗：いちいちfindで探索してると間に合わない\n\n\t2,ハッシュテーブルからデータを取り出してクイックソートからのDumpもタイムオーバー\n\t->失敗：いちいちソートしてるから間に合わない\n\n\t3,ハッシュテーブル自体を特殊な形にする\n\t->成功：ハッシュテーブルとほぼ同じだが箱の扱いを以下のようにする\n\tS[num] は「100 * num ～ 100 * num + 99」までの数値を入れる\n\t例：S[0]は0～99、S[100]は10000～10099という具合\n\n\tそしてInsertは数値の並びが昇順になるように処理\n\n\tこれによって全ての操作が高速になる\n*/\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<time.h>\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left;\n\tstruct node *right;\n}node;\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n\n\twhile(p!=NULL){\n\t\tif(p->key == x)return 1;\n\t\telse if(p->key > x)p=p->left;\n\t\telse p=p->right;\n\t}\n\t\n\treturn 0;\n\t\n}\n\n\nnode * makenode(int x,int y){\n\tnode *new=malloc(sizeof(node));\n\tnew->key=x;\n\tnew->priority=y;\n\tnew->left=NULL;\n\tnew->right=NULL;\n\treturn new;\n}\n\nnode *rightRotate(node *p){\n\tnode *q=p->left;\n\tp->left=q->right;\n\tq->right=p;\n\treturn q;\n}\n\nnode *leftRotate(node *p){\n\tnode *q=p->right;\n\tp->right=q->left;\n\tq->left=p;\n\treturn q;\n}\n\n\nnode* insert(node **t,int key,int priority){\n\tnode *new;\n\t\n\tif((*t)==NULL)\n\t\treturn new=makenode(key,priority);\n\tif ((*t)->key==key)\n\t\treturn *t;\n\t\n\tif(key < (*t)->key){\n\t\t(*t)->left=insert(&(*t)->left,key,priority);\n\t\tif((*t)->priority < (*t)->left->priority)\n\t\t\t(*t)=rightRotate((*t));\n\t}\n\telse {\n\t\t(*t)->right=insert(&(*t)->right,key,priority);\n\t\tif((*t)->priority < (*t)->right->priority)\n\t\t\t(*t)=leftRotate((*t));\n\t}\n\t\n\treturn *t;\n}\n\n\nnode * Delete(node **t,int key){\n\tif((*t)==NULL)\n\t\treturn NULL;\n\t\t\n\tif(key < (*t)->key)\n\t\t(*t)->left=Delete(&((*t)->left),key);\n\t\t\n\telse if(key > (*t)->key)\n\t\t(*t)->right=Delete(&((*t)->right),key);\n\t\t\n\telse return _delete(t,key);\n\t\n\treturn *t;\n}\n\nnode * _delete(node **t,int key){\n\tif((*t)->left==NULL && (*t)->right==NULL)\n\t\treturn NULL;\n\telse if((*t)->left==NULL)\n\t\t(*t)=leftRotate(*t);\n\telse if((*t)->right==NULL)\n\t\t(*t)=rightRotate(*t);\n\telse {\n\t\tif((*t)->left->priority > (*t)->right->priority)\n\t\t\t(*t)=rightRotate(*t);\n\t\telse\n\t\t\t(*t)=leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\n\nvoid dump(node *p,int L,int R){\n\n\tif(p->left!=NULL)\n\t\tdump(p->left,L,R);\n\t\n\tif(p->key >= L && p->key <= R)\n\t\tprintf(\"%d\\n\",p->key);\n\t\n\tif(p->right!=NULL)\n\t\tdump(p->right,L,R);\n\t\n\treturn;\n\t\n}\n\t\n\nint main(){\n\tint q,x,com,y;\n\tint num=0;\n\tnode *root=NULL;\n\tsrand((unsigned)time(NULL));\n\t\n\tscanf(\"%d\",&q);\n\t\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d %d\",&com,&x);\n\t\t\n\t\tif(com==0){\n\t\t\tif(!find(root,x)){\n\t\t\t\troot=insert(&root,x,rand()%200001);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",num);\n\t\t}\n\t\telse if(com==1){\n\t\t\tif(find(root,x))printf(\"1\\n\");\n\t\t\telse printf(\"0\\n\");\n\t\t}\n\t\t\n\t\telse if(com==2){\n\t\t\tif(find(root,x)){\n\t\t\t\troot=Delete(&root,x);\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse {\n\t\t\tscanf(\"%d\",&y);\n\t\t\tdump(root,x,y);\n\t\t}\n\t}\n\t\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n\n//block linked list\n#define Bsize 700 /*2sqrt(n)*/\ntypedef struct block{\n\tint cnt;\n\tll a[Bsize+1];\n\tstruct block*pre;\n\tstruct block*nxt;\n}block;\nvoid Bpush(block*b,ll x){\n\t//リストにxを追加する\n\tif((*b).nxt&&(*(*b).nxt).a[0]<x){\n\t\t//次へ\n\t\tBpush((*b).nxt,x);\n\t\treturn;\n\t}\n\tint i=(*b).cnt;\n\tfor(;i>0&&(*b).a[i-1]>x;i--)(*b).a[i]=(*b).a[i-1];\n\t(*b).a[i]=x;\n\t(*b).cnt++;\n\tif((*b).cnt>=Bsize){\n\t\t//分割\n\t\tblock*nn=(block*)malloc(sizeof(block));\n\t\t(*nn).cnt=Bsize-Bsize/2;\n\t\trep(i,0,Bsize-Bsize/2)(*nn).a[i]=(*b).a[i+Bsize/2];\n\t\t(*nn).pre=b;\n\t\t(*nn).nxt=(*b).nxt;\n\t\tif((*b).nxt)(*(*b).nxt).pre=nn;\n\t\t(*b).cnt=Bsize/2;\n\t\t(*b).nxt=nn;\n\t}\n}\nvoid con(block*p,block*q){\n\t//qをpにマージしてqを消す\n\trep(i,0,(*q).cnt)(*p).a[(*p).cnt+i]=(*q).a[i];\n\t(*p).cnt+=(*q).cnt;\n\t(*p).nxt=(*q).nxt;\n\tif((*q).nxt)(*(*q).nxt).pre=p;\n\tfree(q);\n}\nvoid Bdel(block*b,int idx){\n\t//idx番目を削除する(必ずidx個以上ある)\n\tfor(;idx<(*b).cnt-1;idx++)(*b).a[idx]=(*b).a[idx+1];\n\t(*b).cnt--;\n\t \n\tif((*b).cnt==0&&(*b).pre)con((*b).pre,b);\n\telse if((*b).pre&&(*(*b).pre).cnt+(*b).cnt<Bsize/4)con((*b).pre,b);\n\telse if((*b).nxt&&(*(*b).nxt).cnt+(*b).cnt<Bsize/4)con(b,(*b).nxt);\n}\n\nll Bans(block*b,int k,int flag){\n\t//リストのk番目を返す\n\t//リストにk個未満しかなければ適当に返す\n\t//flagがtrueなら削除する\n\tif((*b).cnt<=k){\n\t\tif((*b).nxt)return Bans((*b).nxt,k-(*b).cnt,flag);\n\t\telse return -1;//<-例外\n\t}\n\tll ans=(*b).a[k];\n\tif(flag)Bdel(b,k);\n\treturn ans;\n}\nint Bfind(block*b,ll k,int flag){\n\t//リストにkが存在すれか答える\n\t//flagがtrueなら削除する\n\tif((*b).cnt==0||(*b).a[(*b).cnt-1]<k){\n\t\tif((*b).nxt)return Bfind((*b).nxt,k,flag);\n\t\telse return 0;\n\t}\n\tint i=0;\n\tfor(;(*b).a[i]<k;i++);\n\tif((*b).a[i]!=k)return 0;\n\tif(flag)Bdel(b,i);\n\treturn 1;\n}\nvoid Bdump(block*b,ll l,ll r){\n\tif((*b).cnt==0){\n\t\tif((*b).nxt)Bdump((*b).nxt,l,r);\n\t}else if((*b).a[0]>r)return;\n\telse if((*b).a[(*b).cnt-1]<l){\n\t\tif((*b).nxt)Bdump((*b).nxt,l,r);\n\t}\n\telse{\n\t\trep(i,0,(*b).cnt)if(l<=(*b).a[i]&&(*b).a[i]<=r)printf(\"%lld\\n\",(*b).a[i]);\n\t\tif((*b).a[(*b).cnt-1]<=r&&(*b).nxt)Bdump((*b).nxt,l,r);\n\t}\n}\n#undef Bsize\n\n\nblock*b;\nint main(){\n\tb=calloc(1,sizeof(block));\n\tint q;\n\tscanf(\"%d\",&q);\n\tint cnt=0;\n\twhile(q--){\n\t\tint t,x;\n\t\tscanf(\"%d%d\",&t,&x);\n\t\tif(t==0){\n\t\t\tif(!Bfind(b,x,0)){\n\t\t\t\tBpush(b,x);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",cnt);\n\t\t}else if(t==1){\n\t\t\tprintf(\"%d\\n\",Bfind(b,x,0));\n\t\t}else if(t==2){\n\t\t\tif(Bfind(b,x,1))cnt--;\n\t\t}else{\n\t\t\tint y;\n\t\t\tscanf(\"%d\",&y);\n\t\t\tBdump(b,x,y);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<time.h>\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left;\n\tstruct node *right;\n}node;\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n\n\twhile(p!=NULL){\n\t\tif(p->key == x)return 1;\n\t\telse if(p->key > x)p=p->left;\n\t\telse p=p->right;\n\t}\n\t\n\treturn 0;\n\t\n}\n\n\nnode * makenode(int x,int y){\n\tnode *new=malloc(sizeof(node));\n\tnew->key=x;\n\tnew->priority=y;\n\tnew->left=NULL;\n\tnew->right=NULL;\n\treturn new;\n}\n\nnode *rightRotate(node *p){\n\tnode *q=p->left;\n\tp->left=q->right;\n\tq->right=p;\n\treturn q;\n}\n\nnode *leftRotate(node *p){\n\tnode *q=p->right;\n\tp->right=q->left;\n\tq->left=p;\n\treturn q;\n}\n\n\nnode* insert(node **t,int key,int priority){\n\tnode *new;\n\t\n\tif((*t)==NULL)\n\t\treturn new=makenode(key,priority);\n\tif ((*t)->key==key)\n\t\treturn *t;\n\t\n\tif(key < (*t)->key){\n\t\t(*t)->left=insert(&(*t)->left,key,priority);\n\t\tif((*t)->priority < (*t)->left->priority)\n\t\t\t(*t)=rightRotate((*t));\n\t}\n\telse {\n\t\t(*t)->right=insert(&(*t)->right,key,priority);\n\t\tif((*t)->priority < (*t)->right->priority)\n\t\t\t(*t)=leftRotate((*t));\n\t}\n\t\n\treturn *t;\n}\n\n\nnode * Delete(node **t,int key){\n\tif((*t)==NULL)\n\t\treturn NULL;\n\t\t\n\tif(key < (*t)->key)\n\t\t(*t)->left=Delete(&((*t)->left),key);\n\t\t\n\telse if(key > (*t)->key)\n\t\t(*t)->right=Delete(&((*t)->right),key);\n\t\t\n\telse return _delete(t,key);\n\t\n\treturn *t;\n}\n\nnode * _delete(node **t,int key){\n\tif((*t)->left==NULL && (*t)->right==NULL)\n\t\treturn NULL;\n\telse if((*t)->left==NULL)\n\t\t(*t)=leftRotate(*t);\n\telse if((*t)->right==NULL)\n\t\t(*t)=rightRotate(*t);\n\telse {\n\t\tif((*t)->left->priority > (*t)->right->priority)\n\t\t\t(*t)=rightRotate(*t);\n\t\telse\n\t\t\t(*t)=leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\n\nvoid dump(node *p,int L,int R){\n\tif(p==NULL)return;\n\n\tif(p->left!=NULL)\n\t\tdump(p->left,L,R);\n\t\n\tif(p->key >= L && p->key <= R)\n\t\tprintf(\"%d\\n\",p->key);\n\t\n\tif(p->right!=NULL)\n\t\tdump(p->right,L,R);\n\t\n\treturn;\n\t\n}\n\t\n\nint main(){\n\tint q,x,com,y;\n\tint num=0;\n\tnode *root=NULL;\n\tsrand((unsigned)time(NULL));\n\t\n\tscanf(\"%d\",&q);\n\t\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d %d\",&com,&x);\n\t\t\n\t\tif(com==0){\n\t\t\tif(!find(root,x)){\n\t\t\t\troot=insert(&root,x,rand()%200001);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",num);\n\t\t}\n\t\telse if(com==1){\n\t\t\tif(find(root,x))printf(\"1\\n\");\n\t\t\telse printf(\"0\\n\");\n\t\t}\n\t\t\n\t\telse if(com==2){\n\t\t\tif(find(root,x)){\n\t\t\t\troot=Delete(&root,x);\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse {\n\t\t\tscanf(\"%d\",&y);\n\t\t\tdump(root,x,y);\n\t\t}\n\t}\n\t\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<time.h>\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left;\n\tstruct node *right;\n}node;\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n\n\twhile(p!=NULL){\n\t\tif(p->key == x)return 1;\n\t\telse if(p->key > x)p=p->left;\n\t\telse p=p->right;\n\t}\n\t\n\treturn 0;\n\t\n}\n\n\nnode * makenode(int x,int y){\n\tnode *new=malloc(sizeof(node));\n\tnew->key=x;\n\tnew->priority=y;\n\tnew->left=NULL;\n\tnew->right=NULL;\n\treturn new;\n}\n\nnode *rightRotate(node *p){\n\tnode *q=p->left;\n\tp->left=q->right;\n\tq->right=p;\n\treturn q;\n}\n\nnode *leftRotate(node *p){\n\tnode *q=p->right;\n\tp->right=q->left;\n\tq->left=p;\n\treturn q;\n}\n\n\nnode* insert(node **t,int key,int priority){\n\tnode *new;\n\t\n\tif((*t)==NULL)\n\t\treturn new=makenode(key,priority);\n\tif ((*t)->key==key)\n\t\treturn *t;\n\t\n\tif(key < (*t)->key){\n\t\t(*t)->left=insert(&(*t)->left,key,priority);\n\t\tif((*t)->priority < (*t)->left->priority)\n\t\t\t(*t)=rightRotate((*t));\n\t}\n\telse {\n\t\t(*t)->right=insert(&(*t)->right,key,priority);\n\t\tif((*t)->priority < (*t)->right->priority)\n\t\t\t(*t)=leftRotate((*t));\n\t}\n\t\n\treturn *t;\n}\n\n\nnode * Delete(node **t,int key){\n\tif((*t)==NULL)\n\t\treturn NULL;\n\t\t\n\tif(key < (*t)->key)\n\t\t(*t)->left=Delete(&((*t)->left),key);\n\t\t\n\telse if(key > (*t)->key)\n\t\t(*t)->right=Delete(&((*t)->right),key);\n\t\t\n\telse return _delete(t,key);\n\t\n\treturn *t;\n}\n\nnode * _delete(node **t,int key){\n\tif((*t)->left==NULL && (*t)->right==NULL)\n\t\treturn NULL;\n\telse if((*t)->left==NULL)\n\t\t(*t)=leftRotate(*t);\n\telse if((*t)->right==NULL)\n\t\t(*t)=rightRotate(*t);\n\telse {\n\t\tif((*t)->left->priority > (*t)->right->priority)\n\t\t\t(*t)=rightRotate(*t);\n\t\telse\n\t\t\t(*t)=leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\n\nvoid dump(node *p,int L,int R){\n\tif(p==NULL)return;\n\t\n\n\tif(p->left!=NULL && p->key!=L)\n\t\tdump(p->left,L,R);\n\t\n\tif(p->key >= L && p->key <= R)\n\t\tprintf(\"%d\\n\",p->key);\n\t\n\tif(p->right!=NULL && p->key!=R)\n\t\tdump(p->right,L,R);\n\t\n\treturn;\n\t\n}\n\t\n\nint main(){\n\tint q,x,com,y;\n\tint num=0;\n\tnode *root=NULL;\n\tsrand((unsigned)time(NULL));\n\t\n\tscanf(\"%d\",&q);\n\t\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d %d\",&com,&x);\n\t\t\n\t\tif(com==0){\n\t\t\tif(!find(root,x)){\n\t\t\t\troot=insert(&root,x,rand()%200001);\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",num);\n\t\t}\n\t\telse if(com==1){\n\t\t\tif(find(root,x))printf(\"1\\n\");\n\t\t\telse printf(\"0\\n\");\n\t\t}\n\t\t\n\t\telse if(com==2){\n\t\t\tif(find(root,x)){\n\t\t\t\troot=Delete(&root,x);\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse {\n\t\t\tscanf(\"%d\",&y);\n\t\t\tdump(root,x,y);\n\t\t}\n\t}\n\t\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define XMAX 1000000000\n\nint main(){\n  int n, i, j, k, x, q;\n  char buf[32];\n  unsigned int *a;\n  a = (unsigned int *)malloc(XMAX/8);\n  for (i=0; i<XMAX/8/sizeof(int); i++)\n    a[i] = 0;\n  \n  int count=0;\n  unsigned int bit[32];\n  unsigned int u = 1;\n  for (i=0; i<32; i++) {\n    bit[i] = u;\n    u *= 2;\n  }\n  \n  fgets(buf, 32, stdin);\n  n = atoi(buf);\n  for (i = 0; i < n; i++){\n    fgets(buf, 32, stdin);\n    char *p = buf;\n    q = atoi(p);\n    p=strchr(p, ' ');\n    x = atoi(p);\n    \n    if (q==0) {\n      if ((a[x/32] & bit[x%32]) == 0) {\n\ta[x/32] |= bit[x%32];\n\tcount++;\n      }\n      \n      k = count;\n      if (k==0) {\n\tputc_unlocked('0', stdout);\n      } else {\n\tif (k<0) {\n\t  putc_unlocked('-', stdout);\n\t  k=-k;\n\t}\n\tfor (j=1; j*10<=k; j*=10);\n\tfor (;j>0; j/=10) {\n\t  putc_unlocked('0'+k/j, stdout);\n\t  k %= j;\n\t}\n      }\n      putc_unlocked('\\n', stdout);\n      \n    } else if (q==1){\n      if ((a[x/32] & bit[x%32]) == 0)\n\tputc_unlocked('0', stdout);\n      else\n\tputc_unlocked('1', stdout);\n      putc_unlocked('\\n', stdout);\n    } else if (q==2) {\n      if (a[x/32] & bit[x%32]) {\n\tcount--;\n\ta[x/32] &= ~bit[x%32];\n      }\n    } else { //q==3\n      int r = atoi(strchr(p+1, ' '));\n      for (int v=x; v<=r; v++) {\n\twhile (a[v/32]==0 && v<=r) v+= 32-v%32;\n\t\n\tif (a[v/32] & bit[v%32]) {\n\t  k = v;\n\t  if (k==0) {\n\t    putc_unlocked('0', stdout);\n\t  } else {\n\t    if (k<0) {\n\t      putc_unlocked('-', stdout);\n\t      k=-k;\n\t    }\n\t    for (j=1; j*10<=k; j*=10);\n\t    for (;j>0; j/=10) {\n\t      putc_unlocked('0'+k/j, stdout);\n\t      k %= j;\n\t    }\n\t  }\n\t  putc_unlocked('\\n', stdout);\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint search(int s[],int key,int head,int tail){\n    if(head>tail)return -1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]==key)return mid;\n    else if(s[mid]>key)tail=mid-1;\n    else if(s[mid]<key)head=mid+1;\n    \n    return search(s,key,head,tail);\n}\nint getLB(int s[],int key,int head,int tail){\n    if(s[0]>key||tail<0)return 0;\n    if(s[tail]<key||head>tail)return tail+1;\n    \n    int mid=(head+tail)/2;\n    \n    if(s[mid]<key)head=mid+1;\n    else if(s[mid]>=key){\n        if(s[mid-1]<key)return mid;\n        else tail=mid-1;\n    }\n        \n    return getLB(s,key,head,tail);\n}\nint insert(int s[],int key,int cnt){\n    int d;\n    if(cnt==0)d=0;\n    else d=getLB(s,key,0,cnt-1);\n    \n    int i;\n    for(i=cnt;i>d;i--)s[i]=s[i-1];\n    s[i]=key;\n    return 1;\n}\nint delete(int s[],int key,int cnt){\n    int d;\n    d=search(s,key,0,cnt-1);\n    if(d<0)return -1;\n    \n    int i;\n    for(i=d;i<cnt-1;i++)s[i]=s[i+1];\n    return 1;\n}\nvoid dump(int s[],int l,int r,int cnt){\n    int i;\n    i=getLB(s,l,0,cnt-1);\n\n    while(s[i]<=r&&i<cnt)printf(\"%d\\n\",s[i++]);\n    return;\n}\nvoid print(int s[],int cnt){\n    printf(\"cnt=%d,s:\",cnt);\n    for(int i=0;i<cnt;i++)printf(\"%d \",s[i]);\n    printf(\"\\n\");\n    return;\n}\nint main(void){\n    int q;\n    scanf(\"%d\\n\",&q);\n    \n    int s[q];\n    int cnt=0;\n    \n    int com,x,y;\n    while(q--){\n        scanf(\"%d \",&com);\n        switch(com){\n            case 0:\n                //insert\n                scanf(\"%d\\n\",&x);\n//    printf(\"insert:%d\\n\",x);\n                if(search(s,x,0,cnt-1)==-1){\n                    if(insert(s,x,cnt)==1)cnt++;\n                }\n                printf(\"%d\\n\",cnt);\n                break;\n            case 1:\n                //find\n                scanf(\"%d\\n\",&x);\n//    printf(\"find:%d\\n\",x);\n                if(search(s,x,0,cnt-1)==-1)printf(\"0\\n\");\n                else printf(\"1\\n\");\n                break;\n            case 2:\n                //delete\n                scanf(\"%d\\n\",&x);\n//    printf(\"delete:%d\\n\",x);\n                if(delete(s,x,cnt)==1)cnt--;\n                break;\n            case 3:\n                //dump\n                scanf(\"%d %d\\n\",&x,&y);\n//    printf(\"dump:%d %d\\n\",x,y);\n                dump(s,x,y,cnt);\n                break;\n        }\n//        print(s,cnt);\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "//import java.lang.Math;\nimport java.util.*;\n//import java.util.ListIterator;\n//import java.util.Iterator;\n//import java.util.LinkedList;\n \npublic class Main{\n \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tpublic static void main(String[] arg) {\n \n        TreeSet<Integer> ht = new TreeSet<Integer>();\n        Scanner sc = new Scanner(System.in);\n        int cnt = sc.nextInt();\n \n        for (int i = 0; i < cnt; i++) {\n \n            int cmt = sc.nextInt();\n \n            switch (cmt) {\n \n            case 0:\n                int num = sc.nextInt();\n                if(!ht.contains(num)) ht.add(num);\n                 \n                 \n                System.out.println(ht.size());\n                 \n                break;\n            case 1:\n                int num2 = sc.nextInt();\n                int cnt2 = 0;\n                if(ht.contains(num2)) cnt2=1;\n                 \n                System.out.println(cnt2);\n                    break;\n            case 2:\n                int num3=sc.nextInt();\n                ht.remove(num3);\n                break;\n            case 3:\n            \t\n                int l=sc.nextInt();\n                int r=sc.nextInt();\n                TreeSet<Integer> treesubset = new TreeSet<Integer>();\n                treesubset=(TreeSet) ht.subSet(l, true, r, true);\n               for(Iterator<Integer> it=treesubset.iterator();it.hasNext();){\n            \t   int ll=it.next();\n                 System.out.println(ll);\n                 }\n               \n               break;\n                }\n                }\n             \n        }\n    }\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tMySet S=new MySet();\n\t\tint q=Integer.parseInt(in.next());\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tint odr=Integer.parseInt(in.next());\n\t\t\t\n\t\t\tswitch(odr) {\n\t\t\tcase 0:\n\t\t\t\tint x0=Integer.parseInt(in.next());\n\t\t\t\tS.add(x0);\n\t\t\t\tout.println(S.size());\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tint x1=Integer.parseInt(in.next());\n\t\t\t\tout.println((S.contains(x1))? 1 : 0);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tint x2=Integer.parseInt(in.next());\n\t\t\t\tS.remove(x2);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tint l=Integer.parseInt(in.next()),r=Integer.parseInt(in.next());\n\t\t\t\tfor(int j=l;j<=r;j++) {\n\t\t\t\t\tif(S.contains(j)) out.println(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\n}\n\nclass MySet{\n\tboolean index[];int size;\n\t\n\tMySet(){\n\t\tindex=new boolean[1000000001];\n\t\tArrays.fill(index, false);\n\t\tsize=0;\n\t}\n\t\n\tvoid add(int x) {\n\t\tindex[x]=true;\n\t\tsize++;\n\t}\n\t\n\tint size() {\n\t\treturn this.size;\n\t}\n\t\n\tboolean contains(int x) {\n\t\treturn index[x];\n\t}\n\t\n\tvoid remove(int x) {\n\t\tindex[x]=false;\n\t\tsize--;\n\t}\n\t\n\tList<Integer> dump(int a,int b) {\n\t\tList<Integer> ls=new ArrayList<>();\n\t\tfor(int i=a;i<=b;i++) {\n\t\t\tif(index[i]) ls.add(i);\n\t\t}\n\t\t\n\t\treturn ls;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tSet<Integer> S=new HashSet<>();\n\t\tint q=Integer.parseInt(in.next());\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tint odr=Integer.parseInt(in.next());\n\t\t\tif(odr==0) {\n\t\t\t\tint x=Integer.parseInt(in.next());\n\t\t\t\tS.add(x);\n\t\t\t\tout.println(S.size());\n\t\t\t}\n\t\t\telse if(odr==1){\n\t\t\t\tint x=Integer.parseInt(in.next());\n\t\t\t\tout.println((S.contains(x))? 1 : 0);\n\t\t\t}\n\t\t\telse if(odr==2){\n\t\t\t\tint x=Integer.parseInt(in.next());\n\t\t\t\tS.remove(x);\n\t\t\t}\n\t\t\telse if(odr==3) {\n\t\t\t\tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n\t\t\t\tIterator<Integer> it=S.iterator();\n\t\t\t\twhile(it.hasNext()) {\n\t\t\t\t\tint num=it.next();\n\t\t\t\t\tif(num>=L && num<=R)out.println(num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, L, R, next;\n\t\tSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tset.add(x);\n\t\t\t\t\tSystem.out.println(set.size());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tSystem.out.println(set.contains(x) ?  \"1\" : \"0\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tset.remove(x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tObject[] set_array = set.toArray();\n\t\t\t\t\tR = sc.nextInt();\n\t\t\t\t\tL = Arrays.binarySearch(set_array, x);\n\t\t\t\t\tR = Arrays.binarySearch(set_array, R);\n\t\t\t\t\tif(L < 0) {\n\t\t\t\t\t\tL = -L - 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(R < 0) {\n\t\t\t\t\t\tR = -R - 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(R > set_array.length - 1) {\n\t\t\t\t\t\tR = set_array.length - 1;\n\t\t\t\t\t}\n\t\t\t\t\tfor(j = L; j <= R; j++) {\n\t\t\t\t\t\tSystem.out.println(set_array[j]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "package ITP2_7_C;\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tMySet S=new MySet();\n\t\tint q=Integer.parseInt(in.next());\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tint odr=Integer.parseInt(in.next());\n\t\t\t\n\t\t\tswitch(odr) {\n\t\t\tcase 0:\n\t\t\t\tint x0=Integer.parseInt(in.next());\n\t\t\t\tS.add(x0);\n\t\t\t\tout.println(S.size());\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tint x1=Integer.parseInt(in.next());\n\t\t\t\tout.println((S.contains(x1))? 1 : 0);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tint x2=Integer.parseInt(in.next());\n\t\t\t\tS.remove(x2);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tint l=Integer.parseInt(in.next()),r=Integer.parseInt(in.next());\n\t\t\t\tfor(int j=l;j<=r;j++) {\n\t\t\t\t\tif(S.contains(j)) out.println(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\n}\n\nclass MySet{\n\tboolean index[];int size;\n\t\n\tMySet(){\n\t\tindex=new boolean[1000000001];\n\t\tArrays.fill(index, false);\n\t\tsize=0;\n\t}\n\t\n\tvoid add(int x) {\n\t\tindex[x]=true;\n\t\tsize++;\n\t}\n\t\n\tint size() {\n\t\treturn this.size;\n\t}\n\t\n\tboolean contains(int x) {\n\t\treturn index[x];\n\t}\n\t\n\tvoid remove(int x) {\n\t\tindex[x]=false;\n\t\tsize--;\n\t}\n\t\n\tList<Integer> dump(int a,int b) {\n\t\tList<Integer> ls=new ArrayList<>();\n\t\tfor(int i=a;i<=b;i++) {\n\t\t\tif(index[i]) ls.add(i);\n\t\t}\n\t\t\n\t\treturn ls;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main  {\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = scan.nextInt();\n\t\tTreeSet<Integer> list = new TreeSet<Integer>();\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = scan.nextInt();\n\t\t\tint b = scan.nextInt();\n\n\t\t\tswitch(a) {\n\t\t\t\n\t\t\tcase 0:\n\t\t\t\tlist.add(b);\n\t\t\t\tSystem.out.println(list.size());\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tSystem.out.println(list.contains(b) ? \"1\" : \"0\");\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tlist.remove(b);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tint c = scan.nextInt();\n\t\t\t\tlist.subSet(b, true, c, true).forEach(d -> System.out.println(d));\n//\t\t\t\tfor(int value : list) {\n//\t\t\t\t\tSystem.out.println(value);\n//\t\t\t\t}\n//\t\t\t\tlist.subSet(b, true, c, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\t\tint q = sc.nextInt();\n\t\tTreeSet<Integer> set = new TreeSet<>();\n\t\tint count = 0;  //setの要素数\n\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tint query = sc.nextInt();\n\n\t\t\tswitch(query) {\n\t\t\tcase 0:\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(set.add(x)) count++;\n\t\t\t\tSystem.out.println(count);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tif(set.contains(x)) System.out.println(1);\n\t\t\t\telse System.out.println(0);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tif(set.remove(x)) count--;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tfor(int n : set.subSet(l, true, r, true)) {\n\t\t\t\t\tSystem.out.println(n);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, L, R, next;\n\t\tSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tset.add(x);\n\t\t\t\t\tSystem.out.println(set.size());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tSystem.out.println(set.contains(x) ?  \"1\" : \"0\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tset.remove(x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tObject[] set_array = set.toArray();\n\t\t\t\t\tR = sc.nextInt();\n\t\t\t\t\tL = Arrays.binarySearch(set_array, x);\n\t\t\t\t\tR = Arrays.binarySearch(set_array, R);\n\t\t\t\t\tif(L < 0) {\n\t\t\t\t\t\tL = -L - 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(R < 0) {\n\t\t\t\t\t\tR = -R - 1;\n\t\t\t\t\t}\n\t\t\t\t\tfor(j = L; j <= R; j++) {\n\t\t\t\t\t\tSystem.out.println(set_array[j]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\tTreeSet<Integer> S = new TreeSet<Integer>();\n\t\t\tint q = sc.nextInt();\n\t\t\tfor(int i = 0; i < q; i++) {\n\t\t\t\tint cmd = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(cmd == 0) {\n\t\t\t\t\tS.add(x);\n\t\t\t\t\tSystem.out.println(S.size());\n\t\t\t\t}\n\t\t\t\telse if(cmd == 1){\n\t\t\t\t\tSystem.out.println(S.contains(x) ? \"1\" : \"0\");\n\t\t\t\t}\n\t\t\t\telse if(cmd == 2) {\n\t\t\t\t\tS.remove(x);\n\t\t\t\t}\n\t\t\t\telse /* cmd == 3 */{\n\t\t\t\t\tint r = sc.nextInt();\n\t\t\t\t\tS.subSet(x,true, r, true).forEach(xx->System.out.println(xx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\nclass Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint q = sc.nextInt();\n\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\tfor(int i = 0; i < q; i++) {\n\t\t\t\tint query = sc.nextInt();\n\t\t\t\tswitch(query) {\n\t\t\t\tcase 0:\n\t\t\t\t\ts.add(sc.nextInt());\n\t\t\t\t\tSystem.out.println(s.size());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tSystem.out.println(s.contains(sc.nextInt())?\"1\":\"0\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\ts.remove(sc.nextInt());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tSet<Integer> sub = s.subSet(sc.nextInt(), true, sc.nextInt(), true);\n\t\t\t\t\tfor (Integer e : sub) System.out.println(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tSet<Integer> S=new HashSet<>();\n\t\tint q=Integer.parseInt(in.next());\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tint odr=Integer.parseInt(in.next());\n\t\t\t\n\t\t\tswitch(odr) {\n\t\t\tcase 0:\n\t\t\t\tint x0=Integer.parseInt(in.next());\n\t\t\t\tS.add(x0);\n\t\t\t\tout.println(S.size());\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tint x1=Integer.parseInt(in.next());\n\t\t\t\tout.println((S.contains(x1))? 1 : 0);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tint x2=Integer.parseInt(in.next());\n\t\t\t\tS.remove(x2);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tint l=Integer.parseInt(in.next()),r=Integer.parseInt(in.next());\n\t\t\t\tfor(int j=l;j<=r;j++) {\n\t\t\t\t\tif(S.contains(j)) out.println(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "//\nimport java.util.Scanner;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint times = sc.nextInt();\n\t\t\tTreeSet<Long> set = new TreeSet<Long>();  //自動ソートができるように\n\t\t\tfor (int i = 0; i<times; i++){\n\t\t\t\tint query = sc.nextInt();\n\t\t\t\tlong x = sc.nextLong();\n\t\t\t\tswitch (query) {\n\t\t\t\tcase 0:\n\t\t\t\t\tset.add(x);\n\t\t\t\t\tSystem.out.println(set.size());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (set.contains(x)) {\n\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t} else System.out.println(0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tset.remove(x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tlong large = sc.nextLong();\n\t\t\t\t\tSortedSet<Long> subset = set.subSet(x,true,large,true);\n\t\t\t\t\tfor (long l :subset) {\n\t\t\t\t\t\tSystem.out.println(l);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in=new Scanner (System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        TreeSet<Integer> set=new TreeSet<>();\n        int q=Integer.parseInt(in.next());\n        for(int i=0;i<q;i++) {\n            int odr=Integer.parseInt(in.next());\n\n            switch(odr) {\n            case 0:\n            \tint x0=Integer.parseInt(in.next());\n            \tif(!set.contains(x0)) set.add(x0);\n            \tout.println(set.size());\n            \tbreak;\n\n            case 1:\n            \tint x1=Integer.parseInt(in.next());\n            \tout.println(set.contains(x1)? 1:0);\n            \tbreak;\n            \t\n            case 2:\n            \tint x2=Integer.parseInt(in.next());\n            \tset.remove(x2);\n            \tbreak;\n            \t\n            case 3:\n            \tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n            \tNavigableSet<Integer> sub=set.subSet(L, true, R, true);\n            \tIterator<Integer> itr=sub.iterator();\n            \t\n            \twhile(itr.hasNext()) {\n            \t\tint key=itr.next();\n            \t\tout.println(key);\n            \t}\n            }\n\n        }\n        out.flush();\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tSet<Integer> S=new HashSet<>();\n\t\tint q=Integer.parseInt(in.next());\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tint odr=Integer.parseInt(in.next());\n\t\t\tif(odr==0) {\n\t\t\t\tint x=Integer.parseInt(in.next());\n\t\t\t\tS.add(x);\n\t\t\t\tout.println(S.size());\n\t\t\t}\n\t\t\telse if(odr==1){\n\t\t\t\tint x=Integer.parseInt(in.next());\n\t\t\t\tout.println((S.contains(x))? 1 : 0);\n\t\t\t}\n\t\t\telse if(odr==2){\n\t\t\t\tint x=Integer.parseInt(in.next());\n\t\t\t\tS.remove(x);\n\t\t\t}\n\t\t\telse if(odr==3) {\n\t\t\t\tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n\t\t\t\tList<Integer> ls=new ArrayList<>();\n\t\t\t\tIterator<Integer> it=S.iterator();\n\t\t\t\twhile(it.hasNext()) {\n\t\t\t\t\tint num=it.next();\n\t\t\t\t\tif(num>=L && num<=R)ls.add(num);\n\t\t\t\t}\n\t\t\t\tCollections.sort(ls);\n\t\t\t\tfor(int j=0;j<ls.size();j++)out.println(ls.get(j));\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tTreeSet<Integer> S = new TreeSet<Integer>();\n\t\tint q = sc.nextInt();\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint com = sc.nextInt();\n\t\t\tif(com == 0){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tS.add(x);\n\t\t\t\tSystem.out.println(S.size());\n\t\t\t}else if(com == 1){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(S.contains(x)) System.out.println(1);\n\t\t\t\telse System.out.println(0);\n\t\t\t}else if(com == 2){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tS.remove(x);\n\t\t\t}else{\n\t\t\t\tint L = sc.nextInt();\n\t\t\t\tint R = sc.nextInt();\n\t\t\t\tSortedSet SS = S.subSet(L, R + 1);\n\t\t\t\tfor(Iterator j = SS.iterator(); j.hasNext();) System.out.println(j.next());\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tTreeSet<Integer> set = new TreeSet<>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t    int type = sc.nextInt();\n\t\t    int x = sc.nextInt();\n\t\t    if (type == 0) {\n\t\t        set.add(x);\n\t\t        sb.append(set.size()).append(\"\\n\");\n\t\t    } else if (type == 1) {\n\t\t        if (set.contains(x)) {\n\t\t            sb.append(1);\n\t\t        } else {\n\t\t            sb.append(0);\n\t\t        }\n\t\t        sb.append(\"\\n\");\n\t\t    } else if (type == 2) {\n\t\t        set.remove(x);\n\t\t    } else {\n\t\t        int y = sc.nextInt();\n\t\t        Integer tmp = x - 1;\n\t\t        while ((tmp = set.higher(tmp)) != null && tmp <= y) {\n\t\t            sb.append(tmp).append(\"\\n\");\n\t\t        }\n\t\t    }\n\t\t}\n\t\tSystem.out.print(sb);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSortedSet<Integer> set = new TreeSet<>();\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint op = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tswitch (op) {\n\t\t\t\tcase 0:\n\t\t\t\t\tset.add(y);\n\t\t\t\t\tSystem.out.println(set.size());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (set.contains(y)) {\n\t\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tset.remove(y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tint z = sc.nextInt() + 1;\n\t\t\t\t\tSet<Integer> subset = set.subSet(y, z);\n\t\t\t\t\tfor (int num : subset) {\n\t\t\t\t\t\tSystem.out.println(num);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tSet<Integer> S=new HashSet<>();\n\t\tint q=Integer.parseInt(in.next());\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tint odr=Integer.parseInt(in.next());\n\t\t\tif(odr==0) {\n\t\t\t\tint x=Integer.parseInt(in.next());\n\t\t\t\tS.add(x);\n\t\t\t\tout.println(S.size());\n\t\t\t}\n\t\t\telse if(odr==1){\n\t\t\t\tint x=Integer.parseInt(in.next());\n\t\t\t\tout.println((S.contains(x))? 1 : 0);\n\t\t\t}\n\t\t\telse if(odr==2){\n\t\t\t\tint x=Integer.parseInt(in.next());\n\t\t\t\tS.remove(x);\n\t\t\t}\n\t\t\telse if(odr==3) {\n\t\t\t\tint L=Integer.parseInt(in.next()),R=Integer.parseInt(in.next());\n\t\t\t\tList<Integer> ls=new ArrayList<>();\n\t\t\t\tIterator<Integer> it=S.iterator();\n\t\t\t\twhile(it.hasNext()) {\n\t\t\t\t\tint num=it.next();\n\t\t\t\t\tif(num>=L && num<=R)ls.add(num);\n\t\t\t\t}\n\t\t\t\tCollections.sort(ls);\n\t\t\t\tfor(int j=0;i<ls.size();j++)out.println(ls.get(j));\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tMySet S=new MySet();\n\t\tint q=Integer.parseInt(in.next());\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tint odr=Integer.parseInt(in.next());\n\t\t\t\n\t\t\tswitch(odr) {\n\t\t\tcase 0:\n\t\t\t\tint x0=Integer.parseInt(in.next());\n\t\t\t\tS.add(x0);\n\t\t\t\tout.println(S.size());\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tint x1=Integer.parseInt(in.next());\n\t\t\t\tout.println((S.contains(x1))? 1 : 0);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tint x2=Integer.parseInt(in.next());\n\t\t\t\tS.remove(x2);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tint l=Integer.parseInt(in.next()),r=Integer.parseInt(in.next());\n\t\t\t\tfor(int j=l;j<=r;j++) {\n\t\t\t\t\tif(S.index[j]) out.println(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\n}\n\nclass MySet{\n\tboolean index[];int size;\n\t\n\tMySet(){\n\t\tindex=new boolean[1000000001];\n\t\tArrays.fill(index, false);\n\t\tsize=0;\n\t}\n\t\n\tvoid add(int x) {\n\t\tif(!index[x]) {\n\t\t\tindex[x]=true;\n\t\t\tsize++;\n\t\t}\n\t}\n\t\n\tint size() {\n\t\treturn this.size;\n\t}\n\t\n\tboolean contains(int x) {\n\t\treturn index[x];\n\t}\n\t\n\tvoid remove(int x) {\n\t\tif(index[x]) {\n\t\t\tindex[x]=false;\n\t\t\tsize--;\n\t\t}\n\t\t\n\t}\n\t\n\tList<Integer> dump(int a,int b) {\n\t\tList<Integer> ls=new ArrayList<>();\n\t\tfor(int i=a;i<=b;i++) {\n\t\t\tif(index[i]) ls.add(i);\n\t\t}\n\t\t\n\t\treturn ls;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, L, R, next;\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tset.add(x);\n\t\t\t\t\tSystem.out.println(set.size());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tSystem.out.println(set.contains(x) ?  \"1\" : \"0\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tset.remove(x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tfor(Integer output : set.subSet(x, true, sc.nextInt(), true)) {\n\t\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tvoid solve (FastScanner in, PrintWriter out, Methods ms) {\n\n\t\tint n = in.nextInt();\n\t\tTreeSet<Integer> set = new TreeSet<>();\n\t\t\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint mode = in.nextInt();\n\t\t\tif (mode == 0) {\n\t\t\t\tset.add(in.nextInt());\n\t\t\t\tout.println(set.size());\n\t\t\t}\n\t\t\telse if (mode == 1) {\n\t\t\t\tout.println(set.contains(in.nextInt())? 1 : 0);\n\t\t\t}\n\t\t\telse if (mode == 2) {\n\t\t\t\tset.remove(in.nextInt());\n\t\t\t}\n\t\t\telse if (mode == 3) {\n\t\t\t\tNavigableSet<Integer> sub = set.subSet(\n\t\t\t\t\t\tin.nextInt(), true, in.nextInt(), true);\n\t\t\t\tfor (Integer e : sub) out.println(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tMethods ms = new Methods();\n\t\tmain.solve(in, out, ms);\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic class Methods {\n\n\t\tpublic void print (Object... ar) {System.out.println(Arrays.deepToString(ar));}\n\n\t\tpublic void yesno (PrintWriter out, boolean b) {out.println(b?\"Yes\":\"No\");}\n\n\t\tpublic void YESNO (PrintWriter out, boolean b) {out.println(b?\"YES\":\"NO\");}\n\n\t\tpublic int max (int... ar) {Arrays.sort(ar); return ar[ar.length-1];}\n\n\t\tpublic int min (int... ar) {Arrays.sort(ar); return ar[0];}\n\n\t}\n\n\tstatic class FastScanner {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate  int length = 0, p = 0;\n\n\t\tpublic FastScanner (InputStream stream) {\n\t\t\tin = stream;\n\t\t}\n\n\t\tpublic boolean hasNextByte () {\n\t\t\tif (p < length) return true;\n\t\t\telse {\n\t\t\t\tp = 0;\n\t\t\t\ttry {length = in.read(buffer);}\n\t\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\t\tif (length <= 0) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int readByte () {\n\t\t\tif (hasNextByte() == true) return buffer[p++];\n\t\t\treturn -1;\n\t\t}\n\n\t\tpublic boolean isPrintable (int n) {return 33<=n&&n<=126;}\n\n\t\tpublic void skip () {\n\t\t\twhile (hasNextByte() && !isPrintable(buffer[p])) p++;\n\t\t}\n\n\t\tpublic boolean hasNext () {skip(); return hasNextByte();}\n\n\t\tpublic String next () {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint t = readByte();\n\t\t\twhile (isPrintable(t)) {\n\t\t\t\tsb.appendCodePoint(t);\n\t\t\t\tt = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic String[] nextArray (int n) {\n\t\t\tString[] ar = new String[n];\n\t\t\tfor (int i=0; i<n; i++) ar[i] = next();\n\t\t\treturn ar;\n\t\t}\n\n\t\tpublic int nextInt () {return Math.toIntExact(nextLong());}\n\n\t\tpublic int[] nextIntArray (int n) {\n\t\t\tint[] ar = new int[n];\n\t\t\tfor (int i=0; i<n; i++) ar[i] = nextInt();\n\t\t\treturn ar;\n\t\t}\n\n\t\tpublic long nextLong () {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tboolean minus = false;\n\t\t\tint temp = readByte();\n\t\t\tif (temp == '-') {\n\t\t\t\tminus = true;\n\t\t\t\ttemp = readByte();\n\t\t\t}\n\t\t\tif (temp<'0' || '9'<temp) throw new NumberFormatException();\n\t\t\tlong n = 0;\n\t\t\twhile (isPrintable(temp)) {\n\t\t\t\tif ('0'<=temp && temp<='9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += temp - '0';\n\t\t\t\t}\n\t\t\t\telse throw new NumberFormatException();\n\t\t\t\ttemp = readByte();\n\t\t\t}\n\t\t\treturn minus? -n : n;\n\t\t}\n\n\t\tpublic long[] nextLongArray (int n) {\n\t\t\tlong[] ar = new long[n];\n\t\t\tfor (int i=0; i<n; i++) ar[i] = nextLong();\n\t\t\treturn ar;\n\t\t}\n\n\t\tpublic double nextDouble () {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray (int n) {\n\t\t\tdouble[] ar = new double[n];\n\t\t\tfor (int i=0; i<n; i++) ar[i] = nextDouble();\n\t\t\treturn ar;\n\t\t}\n\n\t\tpublic void close () {\n\t\t\ttry {in.close();}\n\t\t\tcatch(Exception e){}\n\t\t}\n\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, L, R, next;\n\t\tSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tset.add(x);\n\t\t\t\t\tSystem.out.println(set.size());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tSystem.out.println(set.contains(x) ?  \"1\" : \"0\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tset.remove(x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tObject[] set_array = set.toArray();\n\t\t\t\t\tR = sc.nextInt();\n\t\t\t\t\tL = Arrays.binarySearch(set_array, x);\n\t\t\t\t\tR = Arrays.binarySearch(set_array, R);\n\t\t\t\t\tif(L < 0) {\n\t\t\t\t\t\tL = -L - 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(R < 0) {\n\t\t\t\t\t\tR = -R;\n\t\t\t\t\t}\n\t\t\t\t\tif(R > set_array.length) {\n\t\t\t\t\t\tR = set_array.length - 1;\n\t\t\t\t\t}\n\t\t\t\t\tfor(j = L; j <= R; j++) {\n\t\t\t\t\t\tSystem.out.println(set_array[j]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\tstatic Scanner InData = new Scanner(System.in);\n\tstatic TreeSet<Integer> S = new TreeSet<Integer>();\n\tstatic int qType, qVal, qVal2;\n\t\n\tpublic static void main(String[] args) {\n\t\tgetQuery();\n\t}\n\n\tprivate static void getQuery() {\n\t\tint qNum = InData.nextInt();\n\t\t\n\t\tfor(int indexOfQuery = 0; indexOfQuery < qNum; indexOfQuery++) {\n\t\t\tqType = InData.nextInt();\n\t\t\tqVal = InData.nextInt();\n\t\t\tdoQuery(qType, qVal);\n\t\t}\n\t}\n\n\tprivate static void doQuery(int type, int val) {\n\t\tswitch(type) {\n\t\tcase 0:\n\t\t\tS.add(val);\n\t\t\tSystem.out.println(S.size());\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tSystem.out.println(S.contains(val) ? 1 : 0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tS.remove(val);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tqVal2 = InData.nextInt();\n\t\t\tSortedSet<Integer> subSet = S.subSet(val, qVal2 + 1);\n\t\t\tfor(int idxOfOut : subSet) {\n\t\t\t\tSystem.out.println(idxOfOut);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i, j, q, order, x, L, R, next;\n\t\tSet<Integer> set = new TreeSet<Integer>();\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tq = sc.nextInt();\n\t\t\tfor(i = 0; i < q; i++) {\n\t\t\t\torder = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tswitch(order) {\n\t\t\t\tcase 0 :\n\t\t\t\t\tset.add(x);\n\t\t\t\t\tSystem.out.println(set.size());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1 :\n\t\t\t\t\tSystem.out.println(set.contains(x) ?  \"1\" : \"0\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\t\tset.remove(x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\t\tObject[] set_array = set.toArray();\n\t\t\t\t\tR = sc.nextInt();\n\t\t\t\t\tL = Arrays.binarySearch(set_array, x);\n\t\t\t\t\tR = Arrays.binarySearch(set_array, R);\n\t\t\t\t\tif(L < 0) {\n\t\t\t\t\t\tL = -L - 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(R < 0) {\n\t\t\t\t\t\tR = -R;\n\t\t\t\t\t}\n\t\t\t\t\tif(R > set_array.length) {\n\t\t\t\t\t\tR = set_array.length;\n\t\t\t\t\t}\n\t\t\t\t\tfor(j = L; j <= R; j++) {\n\t\t\t\t\t\tSystem.out.println(set_array[j]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n    public int v { get; set; }\n    public int w { get; set; }\n    public string t { get; set; }\n    public long d { get; set; }\n    public string s { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var hs = new HashSet<int>();\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var c = int.Parse(line[0]);\n            var c2 = int.Parse(line[1]);\n            if (c == 0)\n            {\n                hs.Add(c2);\n                Console.WriteLine(hs.Count());\n            }\n            else if (c == 1) Console.WriteLine(hs.Contains(c2) ? 1 : 0);\n            else if (c == 2) hs.Remove(c2);\n            else\n            {\n                var c3 = int.Parse(line[2]);\n                foreach (var x in hs.Where(y => y >= c2 && y <= c3).OrderBy(y => y))\n                    Console.WriteLine(x);\n            }\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        var hs = new HashSet<int>();\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var c = int.Parse(line[0]);\n            var c2 = int.Parse(line[1]);\n            if (c == 0)\n            {\n                hs.Add(c2);\n                Console.WriteLine(hs.Count());\n            }\n            else if (c == 1)\n            {\n                if (hs.Add(c2)) { Console.WriteLine(0); hs.Remove(c2); }\n                else Console.WriteLine(1);\n            }\n            else if (c == 2) hs.Remove(c2);\n            else\n            {\n                var c3 = int.Parse(line[2]);\n                foreach (var x in hs.Where(y => y >= c2 && y <= c3).OrderBy(y => y))\n                    Console.WriteLine(x);\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new SortedSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                if (S.Contains(cin.nextint))\n                {\n                    WriteLine(1);\n                }\n                else\n                {\n                    WriteLine(0);\n                }\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                var v = S.GetViewBetween(cin.nextint, cin.nextint);\n                if (v.Count > 0) v.join(\"\\n\");\n            }\n        }\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Text;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        var hs = new HashSet<int>();\n        var n = int.Parse(Console.ReadLine().Trim());\n        var sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var c = int.Parse(line[0]);\n            var c2 = int.Parse(line[1]);\n            if (c == 0)\n            {\n                hs.Add(c2);\n                sb.Append(string.Format(\"{0}\\n\", hs.Count()));\n            }\n            else if (c == 1)\n            {\n                if (hs.Add(c2)) { sb.Append(\"0\\n\"); hs.Remove(c2); }\n                else sb.Append(\"1\\n\");\n            }\n            else if (c == 2) hs.Remove(c2);\n            else\n            {\n                var c3 = int.Parse(line[2]);\n                foreach (var x in hs.Where(y => y >= c2 && y <= c3).OrderBy(y => y))\n                    sb.Append(string.Format(\"{0}\\n\", x));\n            }\n            Console.Write(sb);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Text;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        var hs = new HashSet<int>();\n        var n = int.Parse(Console.ReadLine().Trim());\n        var sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var c = int.Parse(line[0]);\n            var c2 = int.Parse(line[1]);\n            if (c == 0)\n            {\n                hs.Add(c2);\n                sb.Append(string.Format(\"{0}\\n\", hs.Count()));\n            }\n            else if (c == 1)\n            {\n                if (hs.Add(c2)) { sb.Append(\"0\\n\"); hs.Remove(c2); }\n                else sb.Append(\"1\\n\");\n            }\n            else if (c == 2) hs.Remove(c2);\n            else\n            {\n                var c3 = int.Parse(line[2]);\n                foreach (var x in hs.Where(y => y >= c2 && y <= c3).OrderBy(y => y))\n                    sb.Append(string.Format(\"{0}\\n\", x));\n            }\n        }\n        Console.Write(sb);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new SortedSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if(mode == 1)\n            {\n                if (S.Contains(cin.nextint))\n                {\n                    WriteLine(1);\n                }\n                else\n                {\n                    WriteLine(0);\n                }\n            }\n            else if(mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                S.GetViewBetween(cin.nextint, cin.nextint).join();\n            }\n        }\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var hs = new SortedSet<int>();\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var c = int.Parse(line[0]);\n            var c2 = int.Parse(line[1]);\n            if (c == 0)\n            {\n                hs.Add(c2);\n                Console.WriteLine(hs.Count());\n            }\n            else if (c == 1) Console.WriteLine(hs.Contains(c2) ? 1 : 0);\n            else if (c == 2) hs.Remove(c2);\n            else\n            {\n                var c3 = int.Parse(line[2]);\n                foreach (var x in hs.Where(y => y >= c2 && y <= c3))\n                    Console.WriteLine(x);\n            }\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new SortedSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                if (S.Contains(cin.nextint))\n                {\n                    WriteLine(1);\n                }\n                else\n                {\n                    WriteLine(0);\n                }\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                var v = S.GetViewBetween(cin.nextint, cin.nextint);\n                foreach (var item in v)\n                {\n                    WriteLine(item);\n                }\n                //if (v.Count > 0) v.join(\"\\n\");\n            }\n        }\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new SortedSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if(mode == 1)\n            {\n                if (S.Contains(cin.nextint))\n                {\n                    WriteLine(1);\n                }\n                else\n                {\n                    WriteLine(0);\n                }\n            }\n            else if(mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                WriteLine(string.Join(\"\\n\", S.GetViewBetween(cin.nextint, cin.nextint)));\n            }\n        }\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Text;\nusing static System.Math;\nusing System.Collections.Generic;\nusing System;\n\npublic class SB_BinarySearchTree<T> where T : IComparable\n{\n    public class Node\n    {\n        public T Value;\n        public Node LChild;\n        public Node RChild;\n        public int Count;\n\n        public Node(T v)\n        {\n            Value = v;\n            Count = 1;\n        }\n    }\n\n    static Random _rnd = new Random();\n\n    public static int Count(Node t)\n    {\n        return t == null ? 0 : t.Count;\n    }\n\n    static Node Update(Node t)\n    {\n        t.Count = Count(t.LChild) + Count(t.RChild) + 1;\n        return t;\n    }\n\n    public static Node Merge(Node l, Node r)\n    {\n        if (l == null || r == null) return l == null ? r : l;\n\n        if (Count(l) / (double)(Count(l) + Count(r)) > _rnd.NextDouble())\n        {\n            l.RChild = Merge(l.RChild, r);\n            return Update(l);\n        }\n        else\n        {\n            r.LChild = Merge(l, r.LChild);\n            return Update(r);\n        }\n    }\n\n    public static Tuple<Node, Node> Split(Node t, int k)\n    {\n        if (t == null) return new Tuple<Node, Node>(null, null);\n        if (k <= Count(t.LChild))\n        {\n            var s = Split(t.LChild, k);\n            t.LChild = s.Item2;\n            return new Tuple<Node, Node>(s.Item1, Update(t));\n        }\n        else\n        {\n            var s = Split(t.RChild, k - Count(t.LChild) - 1);\n            t.RChild = s.Item1;\n            return new Tuple<Node, Node>(Update(t), s.Item2);\n        }\n    }\n\n    public static Node Remove(Node t, T v)\n    {\n        if (Find(t, v) == null) return t;\n        return RemoveAt(t, LowerBound(t, v));\n    }\n\n    public static Node RemoveAt(Node t, int k)\n    {\n        var s = Split(t, k);\n        var s2 = Split(s.Item2, 1);\n        return Merge(s.Item1, s2.Item2);\n    }\n\n    public static bool Contains(Node t, T v)\n    {\n        return Find(t, v) != null;\n    }\n\n    public static Node Find(Node t, T v)\n    {\n        while (t != null)\n        {\n            var cmp = t.Value.CompareTo(v);\n            if (cmp > 0) t = t.LChild;\n            else if (cmp < 0) t = t.RChild;\n            else break;\n        }\n        return t;\n    }\n\n    public static Node FindByIndex(Node t, int idx)\n    {\n        if (t == null) return null;\n\n        var currentIdx = Count(t) - Count(t.RChild) - 1;\n        while (t != null)\n        {\n            if (currentIdx == idx) return t;\n            if (currentIdx > idx)\n            {\n                t = t.LChild;\n                currentIdx -= (Count(t == null ? null : t.RChild) + 1);\n            }\n            else\n            {\n                t = t.RChild;\n                currentIdx += (Count(t == null ? null : t.LChild) + 1);\n            }\n        }\n\n        return null;\n    }\n\n    public static int UpperBound(Node t, T v)\n    {\n        var torg = t;\n        if (t == null) return -1;\n\n        var ret = int.MaxValue;\n        var idx = Count(t) - Count(t.RChild) - 1;\n        while (t != null)\n        {\n            var cmp = t.Value.CompareTo(v);\n\n            if (cmp > 0)\n            {\n                ret = Min(ret, idx);\n                t = t.LChild;\n                idx -= (Count(t == null ? null : t.RChild) + 1);\n            }\n            else if (cmp <= 0)\n            {\n                t = t.RChild;\n                idx += (Count(t == null ? null : t.LChild) + 1);\n            }\n        }\n        return ret == int.MaxValue ? Count(torg) : ret;\n    }\n\n    public static int LowerBound(Node t, T v)\n    {\n        var torg = t;\n        if (t == null) return -1;\n\n        var idx = Count(t) - Count(t.RChild) - 1;\n        var ret = int.MaxValue;\n        while (t != null)\n        {\n            var cmp = t.Value.CompareTo(v);\n            if (cmp >= 0)\n            {\n                if (cmp == 0) ret = Min(ret, idx);\n                t = t.LChild;\n                if (t == null) ret = Min(ret, idx);\n                idx -= t == null ? 0 : (Count(t.RChild) + 1);\n            }\n            else if (cmp < 0)\n            {\n                t = t.RChild;\n                idx += (Count(t == null ? null : t.LChild) + 1);\n                if (t == null) return idx;\n            }\n        }\n        return ret == int.MaxValue ? Count(torg) : ret;\n    }\n\n    public static Node Insert(Node t, T v)\n    {\n        var ub = LowerBound(t, v);\n        return InsertByIdx(t, ub, v);\n    }\n\n    static Node InsertByIdx(Node t, int k, T v)\n    {\n        var s = Split(t, k);\n        return Merge(Merge(s.Item1, new Node(v)), s.Item2);\n    }\n\n    public static IEnumerable<T> Enumerate(Node t)\n    {\n        var ret = new List<T>();\n        Enumerate(t, ret);\n        return ret;\n    }\n\n    static void Enumerate(Node t, List<T> ret)\n    {\n        if (t == null) return;\n        Enumerate(t.LChild, ret);\n        ret.Add(t.Value);\n        Enumerate(t.RChild, ret);\n    }\n}\n\npublic class Set<T> where T : IComparable\n{\n    protected SB_BinarySearchTree<T>.Node _root;\n\n    public T this[int idx] { get { return ElementAt(idx); } }\n\n    public int Count()\n    {\n        return SB_BinarySearchTree<T>.Count(_root);\n    }\n\n    public virtual void Insert(T v)\n    {\n        if (_root == null) _root = new SB_BinarySearchTree<T>.Node(v);\n        else\n        {\n            if (SB_BinarySearchTree<T>.Find(_root, v) != null) return;\n            _root = SB_BinarySearchTree<T>.Insert(_root, v);\n        }\n    }\n\n    public void Clear()\n    {\n        _root = null;\n    }\n\n    public void Remove(T v)\n    {\n        _root = SB_BinarySearchTree<T>.Remove(_root, v);\n    }\n\n    public bool Contains(T v)\n    {\n        return SB_BinarySearchTree<T>.Contains(_root, v);\n    }\n\n    public T ElementAt(int k)\n    {\n        var node = SB_BinarySearchTree<T>.FindByIndex(_root, k);\n        if (node == null) throw new IndexOutOfRangeException();\n        return node.Value;\n    }\n\n    public int Count(T v)\n    {\n        return SB_BinarySearchTree<T>.UpperBound(_root, v) - SB_BinarySearchTree<T>.LowerBound(_root, v);\n    }\n\n    public int LowerBound(T v)\n    {\n        return SB_BinarySearchTree<T>.LowerBound(_root, v);\n    }\n\n    public int UpperBound(T v)\n    {\n        return SB_BinarySearchTree<T>.UpperBound(_root, v);\n    }\n\n    public Tuple<int, int> EqualRange(T v)\n    {\n        if (!Contains(v)) return new Tuple<int, int>(-1, -1);\n        return new Tuple<int, int>(SB_BinarySearchTree<T>.LowerBound(_root, v), SB_BinarySearchTree<T>.UpperBound(_root, v) - 1);\n    }\n\n    public List<T> ToList()\n    {\n        return new List<T>(SB_BinarySearchTree<T>.Enumerate(_root));\n    }\n}\n\npublic class MultiSet<T> : Set<T> where T : IComparable\n{\n    public override void Insert(T v)\n    {\n        if (_root == null) _root = new SB_BinarySearchTree<T>.Node(v);\n        else _root = SB_BinarySearchTree<T>.Insert(_root, v);\n    }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        var q = int.Parse(Console.ReadLine().Trim());\n        getAns(q);\n    }\n    static void getAns(int q)\n    {\n        var sb = new StringBuilder();\n        var ms = new Set<int>();\n        for (int i = 0; i < q; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            if (line[0] == \"0\")\n            {\n                var x = int.Parse(line[1]);\n                ms.Insert(x);\n                sb.Append(ms.Count().ToString() + \"\\n\");\n            }\n            else if (line[0] == \"1\")\n            {\n                var x = int.Parse(line[1]);\n                if (ms.Contains(x)) sb.Append(\"1\\n\");\n                else sb.Append(\"0\\n\");\n            }\n            else if (line[0] == \"2\")\n            {\n                var x = int.Parse(line[1]);\n                ms.Remove(x);\n            }\n            else\n            {\n                var L = int.Parse(line[1]);\n                var r = int.Parse(line[2]);\n                var s = ms.LowerBound(L);\n                var e = ms.UpperBound(r) - 1;\n                for (int j = s; j <= e; j++) sb.Append(ms.ElementAt(j).ToString() + \"\\n\");\n            }\n        }\n        Console.Write(sb);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new SortedSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if(mode == 1)\n            {\n                if (S.Contains(cin.nextint))\n                {\n                    WriteLine(1);\n                }\n                else\n                {\n                    WriteLine(0);\n                }\n            }\n            else if(mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                Write(string.Join(\"\\n\", S.GetViewBetween(cin.nextint, cin.nextint)) + \"\\n\");\n            }\n        }\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new MultiSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                WriteLine(S[cin.nextint]);\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                S.GetViewBetween(cin.nextint, cin.nextint);\n            }\n        }\n        \n    }\n\n}\n\nclass MultiSet<T> : SortedList<T, int> where T : IComparable<T>\n{\n    readonly bool is_multi;\n    public MultiSet(bool is_multi = false)\n    {\n        this.is_multi = is_multi;\n    }\n    public void Add(T item)\n    {\n        if (is_multi || this[item] == 0)\n        {\n            Count++;\n            this[item]++;\n        }\n    }\n    public new void Remove(T item)\n    {\n        Count -= this[item];\n        base.Remove(item);\n    }\n    public void GetViewBetween(T lowerValue, T upperValue)\n    {\n        var s = Keys.lower_bound(lowerValue);\n        var t = Keys.upper_bound(upperValue);\n        for (int i = s; i < t; i++)\n        {\n            for (int j = 0; j < Values[i]; j++)\n            {\n                WriteLine(Keys[i]);\n            }\n        }\n    }\n    public new int this[T key]\n    {\n        get\n        {\n            int value;\n            return TryGetValue(key, out value) ? value : base[key] = default(int);\n        }\n        set\n        {\n            base[key] = value;\n        }\n    }\n    public new int Count { get; private set; }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new SortedSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                if (S.Contains(cin.nextint))\n                {\n                    WriteLine(1);\n                }\n                else\n                {\n                    WriteLine(0);\n                }\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                var v = S.GetViewBetween(cin.nextint, cin.nextint);\n                if (v.Count > 0) v.join(\"\\n\");\n            }\n        }\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new SortedSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if(mode == 1)\n            {\n                if (S.Contains(cin.nextint))\n                {\n                    WriteLine(1);\n                }\n                else\n                {\n                    WriteLine(0);\n                }\n            }\n            else if(mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                Write(string.Join(\"\\n\", S.GetViewBetween(cin.nextint, cin.nextint)));\n            }\n        }\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ITP2_7_C\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            int n = ReadInt();\n            SortedSet<int> ss = new SortedSet<int>();\n            for (int i = 0 ; i < n ; i++)\n            {\n                int[] line = ReadIntAr();\n                switch (line[0])\n                {\n                    case 0:\n                        ss.Add(line[1]);\n                        Console.WriteLine(ss.Count());\n                        break;\n                    case 1:\n                        Console.WriteLine(ss.Contains(line[1]) ? 1 : 0);\n                        break;\n                    case 2:\n                        ss.Remove(line[1]);\n                        break;\n                    case 3:               \n                        foreach (var item in ss.GetViewBetween(line[1], line[2]))\n                        {\n\n                            Console.WriteLine(item);\n                        }\n                        break;\n                }\n\n            }\n        }\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n        static string WriteAr(int[] array, string sep = \" \") { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n        static string WriteAr(double[] array, string sep = \" \") { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n        static string WriteAr(long[] array, string sep = \" \") { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new MultiSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                WriteLine(S[cin.nextint]);\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                S.GetViewBetween(cin.nextint, cin.nextint);\n            }\n        }\n\n    }\n\n}\n\nclass MultiSet<T> : SortedList<T, int> where T : IComparable<T>\n{\n    readonly bool is_multi;\n    public MultiSet(bool is_multi = false)\n    {\n        this.is_multi = is_multi;\n    }\n    public void Add(T item)\n    {\n        if (is_multi || this[item] == 0)\n        {\n            Count++;\n            this[item]++;\n        }\n    }\n    public new void Remove(T item)\n    {\n        int size;\n        if (TryGetValue(item, out size))\n        {\n            Count -= size;\n            base.Remove(item);\n        }\n    }\n    public void GetViewBetween(T lowerValue, T upperValue)\n    {\n        var s = Keys.lower_bound(lowerValue);\n        var t = Keys.upper_bound(upperValue);\n        for (int i = s; i < t; i++)\n        {\n            for (int j = 0; j < Values[i]; j++)\n            {\n                WriteLine(Keys[i]);\n            }\n        }\n    }\n    public new int this[T key]\n    {\n        get\n        {\n            int value;\n            return TryGetValue(key, out value) ? value : 0;\n        }\n        set\n        {\n            base[key] = value;\n        }\n    }\n    public new int Count { get; private set; }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new SortedSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if(mode == 1)\n            {\n                if (S.Contains(cin.nextint))\n                {\n                    WriteLine(1);\n                }\n                else\n                {\n                    WriteLine(0);\n                }\n            }\n            else if(mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                S.GetViewBetween(cin.nextint, cin.nextint).join(\"\\n\");\n            }\n        }\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int Q = cin.nextint;\n        var S = new SortedSet<int>();\n        for (int i = 0; i < Q; i++)\n        {\n            int mode = cin.nextint;\n            if (mode == 0)\n            {\n                S.Add(cin.nextint);\n                WriteLine(S.Count);\n            }\n            else if (mode == 1)\n            {\n                if (S.Contains(cin.nextint))\n                {\n                    WriteLine(1);\n                }\n                else\n                {\n                    WriteLine(0);\n                }\n            }\n            else if (mode == 2)\n            {\n                S.Remove(cin.nextint);\n            }\n            else\n            {\n                var v = S.GetViewBetween(cin.nextint, cin.nextint);\n                if (v.Count > 0) v.join(\"\\n\");\n            }\n        }\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var hs = new SortedSet<int>();\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var c = int.Parse(line[0]);\n            var c2 = int.Parse(line[1]);\n            if (c == 0)\n            {\n                hs.Add(c2);\n                Console.WriteLine(hs.Count());\n            }\n            else if (c == 1) Console.WriteLine(hs.Contains(c2) ? 1 : 0);\n            else if (c == 2) hs.Remove(c2);\n            else\n            {\n                var c3 = int.Parse(line[2]);\n                foreach (var x in hs.Where(y => y >= c2 && y <= c3))\n                    Console.WriteLine(x);\n            }\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Text;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        var hs = new SortedSet<int>();\n        var n = int.Parse(Console.ReadLine().Trim());\n        var sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var c = int.Parse(line[0]);\n            var c2 = int.Parse(line[1]);\n            if (c == 0)\n            {\n                hs.Add(c2);\n                sb.Append(string.Format(\"{0}\\n\", hs.Count()));\n            }\n            else if (c == 1)\n            {\n                if (hs.Add(c2)) { sb.Append(\"0\\n\"); hs.Remove(c2); }\n                else sb.Append(\"1\\n\");\n            }\n            else if (c == 2) hs.Remove(c2);\n            else\n            {\n                var c3 = int.Parse(line[2]);\n                foreach (var x in hs.Where(y => y >= c2 && y <= c3))\n                    sb.Append(string.Format(\"{0}\\n\", x));\n            }\n        }\n        Console.Write(sb);\n    }\n}\n\n\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n\t\"fmt\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextInt() int {\n\tscanner.Scan()\n\ti, e := strconv.Atoi(scanner.Text())\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn i\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\tq := nextInt()\n\tset := make(map[int]struct{})\n\tfor i := 0; i < q; i++ {\n\t\tswitch nextInt() {\n\t\tcase 0:\n\t\t\tx := nextInt()\n\t\t\tset[x] = struct{}{}\n\t\t\tfmt.Println(len(set))\n\t\tcase 1:\n\t\t\tx := nextInt()\n\t\t\tif _, ok := set[x]; ok {\n\t\t\t\tfmt.Println(1)\n\t\t\t} else {\n\t\t\t\tfmt.Println(0)\n\t\t\t}\n\t\tcase 2:\n\t\t\tx := nextInt()\n\t\t\tdelete(set, x)\n\t\tcase 3:\n\t\t\tL := nextInt()\n\t\t\tR := nextInt()\n\t\t\tfor i := L; i <= R; i++ {\n\t\t\t\tif _, ok := set[i]; ok {\n\t\t\t\t\tfmt.Println(i)\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tpanic(\"no such operation!\")\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"sort\"\n\n\t\"bufio\"\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\n\t\"strconv\"\n\t\"strings\"\n)\n\n//  長い入力を読む\nfunc ReadLongLines(times int) ([]string, error) {\n\tresult := make([]string, times)\n\treader := bufio.NewReader(os.Stdin)\n\tbuffer := bytes.NewBuffer(make([]byte, 0))\n\treadBytes := int64(2)\n\tfor i := 0; i < times; i++ {\n\t\tfor {\n\t\t\treadBuf, isPrefix, err := reader.ReadLine()\n\t\t\t// fmt.Printf(\"Reader.Read: %d\\n\", len(readBuf))\n\t\t\treadBytes += int64(len(readBuf) + 1)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tfmt.Println(\"EOF\")\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\treturn result, err\n\t\t\t\t}\n\t\t\t}\n\t\t\t_, err = buffer.Write(readBuf)\n\t\t\tif err != nil {\n\t\t\t\treturn result, err\n\t\t\t}\n\t\t\t// end of line\n\t\t\tif !isPrefix {\n\t\t\t\tresult[i] = buffer.String()\n\t\t\t\tbuffer.Reset()\n\t\t\t\t// reader = bufio.NewReader(os.Stdin)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t// 先読みしてしまうようなので、戻しておく\n\tos.Stdin.Seek(-int64(reader.Buffered()), os.SEEK_CUR)\n\treturn result, nil\n}\n\n// 出力 for 競プロ\ntype Console struct {\n\twriter *bufio.Writer\n}\n\nfunc NewConsole() Console {\n\treturn Console{bufio.NewWriter(os.Stdout)}\n}\nfunc (this *Console) Printf(format string, a ...interface{}) {\n\tfmt.Fprintf(this.writer, format, a...)\n}\nfunc (this *Console) Println(s string) {\n\tfmt.Fprintln(this.writer, s)\n}\nfunc (this *Console) Close() {\n\tthis.Flush()\n}\nfunc (this Console) Flush() {\n\tthis.writer.Flush()\n}\n\nfunc PrintList(list []int) {\n\tcon := NewConsole()\n\tdefer con.Flush()\n\tfor i := range list {\n\t\tif i == 0 {\n\t\t\tcon.Printf(\"%d\", list[i])\n\t\t} else {\n\t\t\tcon.Printf(\" %d\", list[i])\n\t\t}\n\t}\n\tcon.Println(\"\")\n}\n\nconst MAX int = 1000000001\nconst CAP int = 512\n\nfunc GetLank(i int) int {\n\treturn int(math.Floor(float64(i) / float64(CAP)))\n}\nfunc GetIndex(i int) int {\n\treturn i % CAP\n}\n\ntype MySet struct {\n\tdataList []map[int]struct{}\n\tcount    []int\n\ttotal    int\n}\n\nfunc NewSet() MySet {\n\tn := (MAX / CAP) + 1\n\tdataList := make([]map[int]struct{}, n)\n\tfor i := range dataList {\n\t\tdataList[i] = make(map[int]struct{})\n\t}\n\tcounts := make([]int, n)\n\treturn MySet{dataList, counts, 0}\n}\n\nfunc (this *MySet) Exists(i int) bool {\n\t_, ok := this.dataList[GetLank(i)][GetIndex(i)]\n\treturn ok\n}\n\nfunc (this *MySet) Count() int {\n\treturn this.total\n}\nfunc (this *MySet) Add(i int) int {\n\tlank := GetLank(i)\n\tif this.Exists(i) {\n\t\treturn this.Count()\n\t}\n\tthis.dataList[GetLank(i)][GetIndex(i)] = struct{}{}\n\tthis.count[lank]++\n\tthis.total++\n\treturn this.Count()\n}\n\nfunc (this *MySet) Remove(i int) {\n\tif this.Exists(i) {\n\t\tdelete(this.dataList[GetLank(i)], GetIndex(i))\n\t\tthis.count[GetLank(i)]--\n\t\tthis.total--\n\t}\n}\n\nfunc (this *MySet) Find(i int) int {\n\tif this.Exists(i) {\n\t\treturn 1\n\t} else {\n\t\treturn 0\n\t}\n}\n\nfunc (this *MySet) Dump(left, right int) []int {\n\tfound := 0 // found in current lank\n\tcount := 0 // num total\n\tresult := make([]int, 8)\n\t// result := make([]int, this.count)\n\tfor i := left; i <= right; i++ {\n\t\t// boundary\n\t\tif i % CAP == 0 {\n\t\t\tfound = 0\n\t\t}\n\t\t// not exists in current lank\n\t\tlank := GetLank(i)\n\t\tif this.count[lank] == 0 {\n\t\t\ti = (lank + 1) * CAP - 1\n\t\t\tfound = 0\n\t\t\tcontinue\n\t\t}\n\t\tif this.Exists(i) {\n\t\t\tfound++\n\t\t\tif len(result) <= count {\n\t\t\t\tresult = append(result, i)\n\t\t\t} else {\n\t\t\t\tresult[count] = i\n\t\t\t}\n\t\t\t// done in current lank\n\t\t\tif found == this.count[lank] {\n\t\t\t\ti = (lank + 1) * CAP - 1\n\t\t\t}\n\t\t\tcount++\n\t\t}\n\t}\n\t_ = sort.Slice\n\tresult = result[:count]\n\tsort.Slice(result, func(lhs, rhs int) bool {\n\t\treturn result[lhs] < result[rhs]\n\t})\n\treturn result\n}\n\nfunc main() {\n\tcon := NewConsole()\n\tdefer con.Flush()\n\n\t// create list\n\tvar n int\n\tfmt.Scanf(\"%d\", &n)\n\n\tset := NewSet()\n\n\tlines, _ := ReadLongLines(n)\n\n\tfor i := range lines {\n\t\targs := strings.Split(lines[i], \" \")\n\t\tcommand, _ := strconv.Atoi(args[0])\n\t\tx, _ := strconv.Atoi(args[1])\n\n\t\tswitch command {\n\t\tcase 0: //insert\n\t\t\tl := set.Add(x)\n\t\t\tcon.Printf(\"%d\\n\", l)\n\t\tcase 1: //find\n\t\t\tcon.Printf(\"%d\\n\", set.Find(x))\n\t\tcase 2: // delete\n\t\t\tset.Remove(x)\n\t\tcase 3: // dump\n\t\t\tl, _ := strconv.Atoi(args[1])\n\t\t\tr, _ := strconv.Atoi(args[2])\n\t\t\tresult := set.Dump(l, r)\n\t\t\tfor i := range result {\n\t\t\t\tcon.Printf(\"%d\\n\", result[i])\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\n// NewTreapNode is a constructor of TreapNode\nfunc NewTreapNode(key int, priority int) *TreapNode {\n\ttp := TreapNode{}\n\ttp.key = key\n\ttp.priority = priority\n\treturn &tp\n}\n\n// TreapNode contains integer\ntype TreapNode struct {\n\tkey      int\n\tpriority int\n\tleft     *TreapNode\n\tright    *TreapNode\n}\n\nfunc (node *TreapNode) setLeftChild(key int, priority int) {\n\tchild := NewTreapNode(key, priority)\n\tnode.left = child\n}\n\nfunc (node *TreapNode) setRightChild(key int, priority int) {\n\tchild := NewTreapNode(key, priority)\n\tnode.right = child\n}\n\n// NewTreap is a constructor of Treap\nfunc NewTreap() *Treap {\n\ttreap := Treap{}\n\treturn &treap\n}\n\n// Treap described at\n//  https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_D\ntype Treap struct {\n\troot *TreapNode\n}\n\nfunc (t *Treap) insert(key int, priority int) {\n\tif t.root == nil {\n\t\tnode := NewTreapNode(key, priority)\n\t\tt.root = node\n\t} else {\n\t\tt.root = t.insertLoop(t.root, key, priority)\n\t}\n}\n\nfunc (t *Treap) insertLoop(current *TreapNode, key int, priority int) *TreapNode {\n\tif current == nil {\n\t\tnewNode := NewTreapNode(key, priority)\n\t\treturn newNode\n\t}\n\n\tif key == current.key {\n\t\treturn current\n\t}\n\n\tif key < current.key {\n\t\tcurrent.left = t.insertLoop(current.left, key, priority)\n\t\tif current.priority < current.left.priority {\n\t\t\tcurrent = t.rightRotate(current)\n\t\t}\n\t} else {\n\t\tcurrent.right = t.insertLoop(current.right, key, priority)\n\t\tif current.priority < current.right.priority {\n\t\t\tcurrent = t.leftRotate(current)\n\t\t}\n\t}\n\n\treturn current\n}\n\nfunc (t *Treap) leftRotate(x *TreapNode) *TreapNode {\n\ty := x.right\n\tx.right = y.left\n\ty.left = x\n\treturn y\n}\n\nfunc (t *Treap) rightRotate(y *TreapNode) *TreapNode {\n\tx := y.left\n\ty.left = x.right\n\tx.right = y\n\treturn x\n}\n\nfunc (t *Treap) find(key int) *TreapNode {\n\treturn t.findLoop(t.root, key)\n}\n\nfunc (t *Treap) findLoop(current *TreapNode, key int) *TreapNode {\n\tif current == nil {\n\t\treturn nil\n\t}\n\n\tif key < current.key {\n\t\treturn t.findLoop(current.left, key)\n\t} else if current.key == key {\n\t\treturn current\n\t}\n\treturn t.findLoop(current.right, key)\n}\n\nfunc (t *Treap) delete(key int) {\n\tt.root = t.deleteLoop(t.root, key)\n}\n\nfunc (t *Treap) deleteLoop(current *TreapNode, key int) *TreapNode {\n\tif current == nil {\n\t\treturn nil\n\t}\n\tif key < current.key {\n\t\tcurrent.left = t.deleteLoop(current.left, key)\n\t} else if key > current.key {\n\t\tcurrent.right = t.deleteLoop(current.right, key)\n\t} else {\n\t\treturn t.deleteNode(current, key)\n\t}\n\treturn current\n}\n\nfunc (t *Treap) deleteNode(node *TreapNode, key int) *TreapNode {\n\tif node.left == nil && node.right == nil {\n\t\treturn nil\n\t} else if node.left == nil {\n\t\tnode = t.leftRotate(node)\n\t} else if node.right == nil {\n\t\tnode = t.rightRotate(node)\n\t} else {\n\t\tif node.left.priority > node.right.priority {\n\t\t\tnode = t.rightRotate(node)\n\t\t} else {\n\t\t\tnode = t.leftRotate(node)\n\t\t}\n\t}\n\treturn t.deleteLoop(node, key)\n}\n\nfunc (t *Treap) inorderTreeWalkV2(p *TreapNode) string {\n\tif p == nil {\n\t\treturn \".\"\n\t}\n\n\tl := t.inorderTreeWalkV2(p.left)\n\tr := t.inorderTreeWalkV2(p.right)\n\treturn fmt.Sprintf(\"(%v %v %v)\", p.key, l, r)\n}\n\nfunc (t *Treap) printInorderWalk(l, r int) {\n\tif t.root != nil {\n\t\tfmt.Print(t.printInorderWalkRoop(t.root, l, r))\n\t}\n}\n\nfunc (t *Treap) printInorderWalkRoop(mid *TreapNode, l, r int) string {\n\t// fmt.Println(\"*\", l, r, mid.key)\n\t// if mid.left != nil {\n\t// \tfmt.Println(\"left:\", mid.left.key)\n\t// }\n\t// if mid.right != nil {\n\t// \tfmt.Println(\"right:\", mid.right.key)\n\t// }\n\n\tconcated := \"\"\n\tif mid.left != nil && l <= mid.key {\n\t\tconcated += t.printInorderWalkRoop(mid.left, l, r)\n\t}\n\tif l <= mid.key && mid.key <= r {\n\t\tconcated += strconv.Itoa(mid.key) + \"\\n\"\n\t}\n\tif mid.right != nil && mid.key <= r {\n\t\tconcated += t.printInorderWalkRoop(mid.right, l, r)\n\t}\n\treturn concated\n}\n\n// NewSet is constructer of Set\nfunc NewSet() *Set {\n\ts := new(Set)\n\ts.tree = *NewTreap()\n\ts.size = 0\n\treturn s\n}\n\n// Set for integer\ntype Set struct {\n\ttree Treap\n\tsize int\n}\n\nfunc (s *Set) insert(x int) int {\n\txNode := s.tree.find(x)\n\tif xNode == nil {\n\t\tpriority := rand.Int()\n\t\ts.tree.insert(x, priority)\n\t\ts.size++\n\t}\n\treturn s.size\n}\n\nfunc (s *Set) find(x int) int {\n\ttarget := s.tree.find(x)\n\tif target != nil {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc (s *Set) delete(x int) {\n\ttarget := s.tree.find(x)\n\tif target != nil {\n\t\ts.tree.delete(x)\n\t\ts.size--\n\t}\n}\n\nfunc (s *Set) printRange(l, r int) {\n\ts.tree.printInorderWalk(l, r)\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tnQueries := nextInt()\n\tset := NewSet()\n\tfor iQuery := 0; iQuery < nQueries; iQuery++ {\n\t\tqueryType := nextInt()\n\t\tx := nextInt()\n\t\tif queryType == 0 { // insert\n\t\t\tsetSize := set.insert(x)\n\t\t\tfmt.Println(setSize)\n\t\t} else if queryType == 1 { // find\n\t\t\tfmt.Println(set.find(x))\n\t\t} else if queryType == 2 { // delete\n\t\t\t// fmt.Println(\"delete\", x)\n\t\t\tset.delete(x)\n\t\t} else if queryType == 3 { // dump(L, R)\n\t\t\tl := x\n\t\t\tr := nextInt()\n\t\t\t// fmt.Println(l, r)\n\t\t\t// fmt.Println(set.tree.inorderTreeWalkV2(set.tree.root))\n\t\t\tset.printRange(l, r)\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n\t\"fmt\"\n\t\"sort\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextInt() int {\n\tscanner.Scan()\n\ti, e := strconv.Atoi(scanner.Text())\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn i\n}\n\nfunc lowerBound(a []int, x int, n int) int {\n\tl := 0\n\th := n\n\tfor l < h {\n\t\tmid := (l + h)/2\n\t\tif x <= a[mid] {\n\t\t\th = mid\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\treturn l\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\tq := nextInt()\n\tset := make(map[int]struct{})\n\tfor i := 0; i < q; i++ {\n\t\tswitch nextInt() {\n\t\tcase 0:\n\t\t\tx := nextInt()\n\t\t\tset[x] = struct{}{}\n\t\t\tfmt.Println(len(set))\n\t\tcase 1:\n\t\t\tx := nextInt()\n\t\t\tif _, ok := set[x]; ok {\n\t\t\t\tfmt.Println(1)\n\t\t\t} else {\n\t\t\t\tfmt.Println(0)\n\t\t\t}\n\t\tcase 2:\n\t\t\tx := nextInt()\n\t\t\tdelete(set, x)\n\t\tcase 3:\n\t\t\tL := nextInt()\n\t\t\tR := nextInt()\n\t\t\tkeys := make([]int, 0)\n\t\t\tfor k, _ := range set {\n\t\t\t\tkeys = append(keys, k)\n\t\t\t}\n\t\t\tsort.Sort(sort.IntSlice(keys))\n\t\t\t// fmt.Println(keys)\n\t\t\t// tmp := lowerBound(keys, L, len(keys))\n\t\t\tfor i := 0; i < len(keys); i++ {\n\t\t\t\tkey := keys[i]\n\t\t\t\tif L > key {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif key > R {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif _, ok := set[key]; ok {\n\t\t\t\t\tfmt.Println(key)\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// keyをソートして別配列に持っておく。\n\t\t\t// key配列keysのlower_boundしてL以上になる配列要素のいちを\n\t\t\t// 取得しておけば、そこから隣に進んでいく。映った先がRよりデカイならおしまい\n\t\t\t// keys[L]からkeys[R]までをなめて\n\t\tdefault:\n\t\t\tpanic(\"no such operation!\")\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n)\n\nvar DEBUG = true\n\nfunc main() {\n\tdefer Flush()\n\n\tQ := readi()\n\tb := NewBST()\n\tfor q := 0; q < Q; q++ {\n\t\tt := readi()\n\t\tswitch t {\n\t\tcase 0:\n\t\t\tx := readi()\n\t\t\tb.Insert(x, true)\n\t\t\tprintln(b.Len())\n\t\tcase 1:\n\t\t\tx := readi()\n\t\t\tnd := b.Find(x)\n\t\t\tif nd == nil {\n\t\t\t\tprintln(0)\n\t\t\t} else {\n\t\t\t\tprintln(1)\n\t\t\t}\n\t\tcase 2:\n\t\t\tx := readi()\n\t\t\tb.Remove(x)\n\t\tdefault:\n\t\t\tl := readi()\n\t\t\tr := readi()\n\t\t\tb.RangeForEach(l, r+1, func(nd *BSTNode, cancel func()) {\n\t\t\t\tprintln(nd.key)\n\t\t\t})\n\t\t}\n\t}\n\n}\n\n//\n// Binary Search Tree\n//\n//   This is Go implementation of LLRB Tree. Some parts of code are\n//   based on the paper \"Left-leaning Red-Black Trees\" by Robert Sedgewick.\n//\n\n// BST represents Binary Search Tree\ntype BST struct {\n\troot  *BSTNode\n\tsize  int\n\tdebug bool\n}\n\n// NewBST returns the pointer a BST object\nfunc NewBST() *BST {\n\tt := &BST{}\n\treturn t\n}\n\n// Len returns the size of the BST\nfunc (t *BST) Len() int {\n\treturn t.size\n}\n\n// Insert inserts the val on the key\nfunc (t *BST) Insert(key int, val interface{}) bool {\n\tvar ok bool\n\tt.root, ok = t.root.insert(key, val)\n\tt.root.color = BST_BLACK\n\tif ok {\n\t\tt.size++\n\t}\n\treturn ok\n}\n\nfunc (t *BST) Debug() {\n\tt.debug = !t.debug\n}\n\nvar dump func()\n\nfunc defaultDump() {\n\treturn\n}\n\nfunc (t *BST) mkDumpFunc(label string) func() {\n\treturn func() {\n\t\tpc, file, line, _ := runtime.Caller(1)\n\t\tfmt.Fprintf(os.Stderr, \"* %s [0x%x@%s:%d]\\n\", label, pc, file, line)\n\t\tfmt.Fprintln(os.Stderr, \"```graphviz\")\n\t\tfmt.Fprintf(os.Stderr, \"%s\", t.Graphviz())\n\t\tfmt.Fprintln(os.Stderr, \"```\")\n\t}\n}\n\n// Remove removes the value on the key\nfunc (t *BST) Remove(key int) bool {\n\t//if t.debug {\n\t//\tfmt.Fprintf(os.Stderr, \"\\n## Remove %d\\n\\n\", key)\n\t//\tdump = t.mkDumpFunc(fmt.Sprintf(\"Remove(%d)\", key))\n\t//} else {\n\t//\tdump = defaultDump\n\t//}\n\n\tvar ok bool\n\tt.root, ok = t.root.remove(key)\n\tif t.root != nil {\n\t\tt.root.color = BST_BLACK\n\t}\n\tif ok {\n\t\tt.size--\n\t}\n\t//if t.debug {\n\t//\tdump = defaultDump\n\t//}\n\treturn ok\n}\n\n// Find returns the BSTNode that matches the key.  It returns nil if the key is not found.\nfunc (t *BST) Find(key int) *BSTNode {\n\treturn t.root.find(key)\n}\n\n// ForEach iterates calling fn on all the BST nodes.\nfunc (t *BST) ForEach(fn func(nd *BSTNode, cancel func())) {\n\tvar isCanceled bool\n\n\tcancel := func() {\n\t\tisCanceled = true\n\t}\n\n\tt.root.forEach(func(nd *BSTNode) bool {\n\t\tfn(nd, cancel)\n\t\treturn isCanceled\n\t})\n}\n\n// ReverseForEach iterates like ForEach but in reverse order.\nfunc (t *BST) ReverseForEach(fn func(nd *BSTNode, cancel func())) {\n\tvar isCanceled bool\n\n\tcancel := func() {\n\t\tisCanceled = true\n\t}\n\n\tt.root.reverseForEach(func(nd *BSTNode) bool {\n\t\tfn(nd, cancel)\n\t\treturn isCanceled\n\t})\n}\n\n// RangeForEach iterates calling fn with all the BST nodes that has keys such that low <= key < high\nfunc (t *BST) RangeForEach(low, high int, fn func(nd *BSTNode, cancel func())) {\n\tvar isCanceled bool\n\n\tcancel := func() {\n\t\tisCanceled = true\n\t}\n\n\tt.root.rangeForEach(low, high, func(nd *BSTNode) bool {\n\t\tfn(nd, cancel)\n\t\treturn isCanceled\n\t})\n}\n\n// ReverseRangeForEach iterates calling fn with all the BST nodes that has keys such that low < key <= high in reverse order.\nfunc (t *BST) ReverseRangeForEach(low, high int, fn func(nd *BSTNode, cancel func())) {\n\tvar isCanceled bool\n\n\tcancel := func() {\n\t\tisCanceled = true\n\t}\n\n\tt.root.reverseRangeForEach(low, high, func(nd *BSTNode) bool {\n\t\tfn(nd, cancel)\n\t\treturn isCanceled\n\t})\n}\n\n// Find returns the BSTNode that has a key which is greater than or equal to the specified key.\nfunc (t *BST) LowerBound(key int) *BSTNode {\n\treturn t.root.lowerBound(key)\n}\n\n// Find returns the BSTNode that has a key which is lesser than or equal to the specified key.\nfunc (t *BST) UpperBound(key int) *BSTNode {\n\treturn t.root.upperBound(key)\n}\n\n// String returns the string representation of the BST\nfunc (t *BST) String() string {\n\tbuf := new(bytes.Buffer)\n\tfmt.Fprintf(buf, \"BST[\")\n\tsp := \"\"\n\tt.ForEach(func(nd *BSTNode, cancel func()) {\n\t\tfmt.Fprintf(buf, \"%s%s\", sp, nd)\n\t\tsp = \" \"\n\t})\n\tfmt.Fprintf(buf, \"]\")\n\treturn buf.String()\n}\n\n// Graphviz returns the graph directives of the BST in graphviz format\nfunc (t *BST) Graphviz() string {\n\tbuf := new(bytes.Buffer)\n\tfmt.Fprintf(buf, \"digraph hierarchy {\\n\")\n\tfmt.Fprintf(buf, \"graph [splines=line];\\n\")\n\tt.root.graphviz(buf)\n\tfmt.Fprintf(buf, \"}\\n\")\n\treturn buf.String()\n}\n\n//\n// BST Node\n//\n\n// BSTNode represents the node of BST\ntype BSTNode struct {\n\tkey         int\n\tvalue       interface{}\n\tleft, right *BSTNode\n\tcolor       bool\n}\n\n// BST_RED and BST_BLACK represent colors of the BSTNode\nconst (\n\tBST_RED   = false\n\tBST_BLACK = true\n)\n\n// Key returns the key of the node\nfunc (nd *BSTNode) Key() int {\n\treturn nd.key\n}\n\n// Value returns the value of the node\nfunc (nd *BSTNode) Value() interface{} {\n\treturn nd.value\n}\n\n// SetValue updates the value of the node with val\nfunc (nd *BSTNode) SetValue(val interface{}) {\n\tnd.value = val\n}\n\n// String returns the string representation of the node\nfunc (nd *BSTNode) String() string {\n\treturn fmt.Sprintf(\"%d:%s\", nd.key, nd.value)\n}\n\nfunc (nd *BSTNode) find(key int) *BSTNode {\n\tif nd == nil {\n\t\treturn nil\n\t}\n\tif key < nd.key {\n\t\treturn nd.left.find(key)\n\t} else if nd.key < key {\n\t\treturn nd.right.find(key)\n\t}\n\treturn nd\n}\n\nfunc (nd *BSTNode) fixup() *BSTNode {\n\tif !nd.left.isRed() && nd.right.isRed() {\n\t\tnd = nd.rotateLeft()\n\t}\n\tif nd.left.isRed() && nd.left != nil && nd.left.left.isRed() {\n\t\tnd = nd.rotateRight()\n\t}\n\tif nd.left.isRed() && nd.right.isRed() {\n\t\tnd.flipColors()\n\t}\n\treturn nd\n}\n\nfunc (nd *BSTNode) insert(key int, val interface{}) (*BSTNode, bool) {\n\tvar ok bool\n\tif nd == nil {\n\t\tnd = &BSTNode{\n\t\t\tkey:   key,\n\t\t\tvalue: val,\n\t\t}\n\t\treturn nd, true\n\t} else if key < nd.key {\n\t\tnd.left, ok = nd.left.insert(key, val)\n\t} else if nd.key < key {\n\t\tnd.right, ok = nd.right.insert(key, val)\n\t} else {\n\t\tnd.value = val\n\t}\n\treturn nd.fixup(), ok\n}\n\nfunc (nd *BSTNode) findMin() (int, interface{}) {\n\tp := nd\n\tfor p.left != nil {\n\t\tp = p.left\n\t}\n\treturn p.key, p.value\n}\n\nfunc (nd *BSTNode) removeMin() *BSTNode {\n\tif nd.left == nil {\n\t\treturn nd.right\n\t}\n\n\tif !nd.left.isRed() && nd.left != nil && !nd.left.left.isRed() {\n\t\tnd = nd.moveRedLeft()\n\t}\n\n\tnd.left = nd.left.removeMin()\n\n\treturn nd.fixup()\n}\n\nfunc (nd *BSTNode) moveRedLeft() *BSTNode {\n\tnd.flipColors()\n\tif nd.right != nil && nd.right.left.isRed() {\n\t\tnd.right = nd.right.rotateRight()\n\t\tnd = nd.rotateLeft()\n\t\tnd.flipColors()\n\t}\n\treturn nd\n}\n\nfunc (nd *BSTNode) moveRedRight() *BSTNode {\n\tnd.flipColors()\n\tif nd.left != nil && nd.left.left.isRed() {\n\t\tnd = nd.rotateRight()\n\t\tnd.flipColors()\n\t}\n\treturn nd\n}\n\nfunc (nd *BSTNode) remove(key int) (*BSTNode, bool) {\n\tif nd == nil {\n\t\treturn nil, false\n\t}\n\n\tvar ok bool\n\tif key < nd.key {\n\t\tif !nd.left.isRed() && nd.left != nil && !nd.left.left.isRed() {\n\t\t\tnd = nd.moveRedLeft()\n\t\t}\n\t\tnd.left, ok = nd.left.remove(key)\n\t} else {\n\t\tif nd.left.isRed() {\n\t\t\tnd = nd.rotateRight()\n\t\t}\n\t\tif nd.key == key && nd.right == nil {\n\t\t\treturn nil, true\n\t\t}\n\t\tif !nd.right.isRed() && nd.right != nil && !nd.right.left.isRed() {\n\t\t\tnd = nd.moveRedRight()\n\t\t}\n\t\tif nd.key == key {\n\t\t\tnd.key, nd.value = nd.right.findMin()\n\t\t\tnd.right = nd.right.removeMin()\n\t\t\tok = true\n\t\t} else {\n\t\t\tnd.right, ok = nd.right.remove(key)\n\t\t}\n\t}\n\treturn nd.fixup(), ok\n}\n\nfunc (nd *BSTNode) forEach(fn func(nd *BSTNode) bool) bool {\n\tif nd == nil {\n\t\treturn false\n\t}\n\n\tif nd.left != nil {\n\t\tif nd.left.forEach(fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif fn(nd) {\n\t\treturn true\n\t}\n\n\tif nd.right != nil {\n\t\tif nd.right.forEach(fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (nd *BSTNode) reverseForEach(fn func(nd *BSTNode) bool) bool {\n\tif nd == nil {\n\t\treturn false\n\t}\n\n\tif nd.right != nil {\n\t\tif nd.right.reverseForEach(fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif fn(nd) {\n\t\treturn true\n\t}\n\n\tif nd.left != nil {\n\t\tif nd.left.reverseForEach(fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (nd *BSTNode) rangeForEach(low, high int, fn func(nd *BSTNode) bool) bool {\n\tif nd == nil {\n\t\treturn false\n\t}\n\n\tif low < nd.key && nd.left != nil {\n\t\tif nd.left.rangeForEach(low, high, fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif low <= nd.key && nd.key < high {\n\t\tif fn(nd) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif nd.key < high && nd.right != nil {\n\t\tif nd.right.rangeForEach(low, high, fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (nd *BSTNode) reverseRangeForEach(low, high int, fn func(nd *BSTNode) bool) bool {\n\tif nd == nil {\n\t\treturn false\n\t}\n\n\tif nd.key < high && nd.right != nil {\n\t\tif nd.right.reverseRangeForEach(low, high, fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif low < nd.key && nd.key <= high {\n\t\tif fn(nd) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif low < nd.key && nd.left != nil {\n\t\tif nd.left.reverseRangeForEach(low, high, fn) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (nd *BSTNode) lowerBound(key int) *BSTNode {\n\tif nd == nil {\n\t\treturn nil\n\t}\n\n\tif key < nd.key && nd.left != nil {\n\t\tif res := nd.left.lowerBound(key); res != nil {\n\t\t\treturn res\n\t\t}\n\t}\n\n\tif key <= nd.key {\n\t\treturn nd\n\t}\n\n\tif nd.key < key && nd.right != nil {\n\t\treturn nd.right.lowerBound(key)\n\t}\n\treturn nil\n}\n\nfunc (nd *BSTNode) upperBound(key int) *BSTNode {\n\tif nd == nil {\n\t\treturn nil\n\t}\n\n\tif nd.key < key && nd.right != nil {\n\t\tif res := nd.right.upperBound(key); res != nil {\n\t\t\treturn res\n\t\t}\n\t}\n\n\tif nd.key <= key {\n\t\treturn nd\n\t}\n\n\tif key < nd.key && nd.left != nil {\n\t\treturn nd.left.upperBound(key)\n\t}\n\n\treturn nil\n}\n\nfunc (nd *BSTNode) rotateLeft() *BSTNode {\n\tx := nd.right\n\tnd.right = x.left\n\tx.left = nd\n\tx.color = nd.color\n\tnd.color = BST_RED\n\treturn x\n}\n\nfunc (nd *BSTNode) rotateRight() *BSTNode {\n\tx := nd.left\n\tnd.left = x.right\n\tx.right = nd\n\tx.color = nd.color\n\tnd.color = BST_RED\n\treturn x\n}\n\nfunc (nd *BSTNode) flipColors() {\n\tnd.color = !nd.color\n\tif nd.left != nil {\n\t\tnd.left.color = !nd.left.color\n\t}\n\tif nd.right != nil {\n\t\tnd.right.color = !nd.right.color\n\t}\n}\n\nfunc (nd *BSTNode) isRed() bool {\n\tif nd == nil {\n\t\treturn false\n\t}\n\treturn nd.color == BST_RED\n}\n\nfunc (nd *BSTNode) graphviz(w io.Writer) {\n\tif nd == nil {\n\t\treturn\n\t}\n\tif nd.left != nil {\n\t\tfmt.Fprintf(w, `%d -> %d`, nd.key, nd.left.key)\n\t\tif nd.left.isRed() {\n\t\t\tfmt.Fprintf(w, ` [color=red]`)\n\t\t}\n\t\tfmt.Fprintln(w)\n\t\tnd.left.graphviz(w)\n\t}\n\tif nd.right != nil {\n\t\tfmt.Fprintf(w, `%d -> %d`, nd.key, nd.right.key)\n\t\tif nd.right.isRed() {\n\t\t\tfmt.Fprintf(w, ` [color=red]`)\n\t\t}\n\t\tfmt.Fprintln(w)\n\t\tnd.right.graphviz(w)\n\t}\n\tif nd.isRed() {\n\t\tfmt.Fprintf(w, \"%d [color=red fontcolor=red]\\n\", nd.key)\n\t} else {\n\t\tfmt.Fprintf(w, \"%d [color=black fontcolor=black]\\n\", nd.key)\n\t}\n}\n\n// -----------------------------------------------------------------------------\n\n// IO helper functions\n\n// Returns next token from input.  It must be initialized by SetInput()\n// before the first call.\nvar nextToken func() ([]byte, error)\nvar nextLine func() ([]byte, error)\n\n// Holds a buffer for output.  It must be initialized by SetOutput().\n// All IO fucntions (read*() and [e]print*()) should write to OutputWriter\n// instead of this.\nvar OutputBuffer *bufio.Writer\n\n// Holds an io.Writer.  It must be initialized by SetOutput()\nvar OutputWriter io.Writer\n\n// Set IO functions for interactive input/output.\nfunc SetInteractive(w io.Writer, r io.Reader) {\n\tSetUnbefferedInput(r)\n\tOutputBuffer = nil\n\tOutputWriter = w\n}\n\n// Setup OutputBuffer and OutputWriter.\nfunc SetOutput(w io.Writer) {\n\tOutputBuffer = bufio.NewWriter(w)\n\tOutputWriter = OutputBuffer\n}\n\n// Flushes OutputBuffer\nfunc Flush() {\n\tif OutputBuffer != nil {\n\t\tOutputBuffer.Flush()\n\t}\n}\n\n// Returns true if c is a white space\nfunc IsSpace(c byte) bool {\n\tswitch c {\n\tcase '\\t', '\\n', '\\v', '\\f', '\\r', ' ':\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc IsNewLine(c byte) bool {\n\tswitch c {\n\tcase '\\n', '\\r':\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Setup nextToken with input buffer.\nfunc SetInput(r io.Reader) {\n\tbuf := new(bytes.Buffer)\n\tvar b []byte\n\n\tvar i int\n\trest := func() ([]byte, error) {\n\t\tfor i < len(b) && IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tif i == len(b) {\n\t\t\treturn nil, io.ErrUnexpectedEOF\n\t\t}\n\t\tj := i\n\t\tfor i < len(b) && !IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\treturn b[j:i], nil\n\t}\n\tinitial := func() ([]byte, error) {\n\t\tio.Copy(buf, r)\n\t\tb = buf.Bytes()\n\t\tnextToken = rest\n\t\treturn rest()\n\t}\n\tnextToken = initial\n\n\trestLn := func() ([]byte, error) {\n\t\tfor i < len(b) && IsNewLine(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tif i == len(b) {\n\t\t\treturn nil, io.ErrUnexpectedEOF\n\t\t}\n\t\tj := i\n\t\tfor i < len(b) && !IsNewLine(b[i]) {\n\t\t\ti++\n\t\t}\n\t\treturn b[j:i], nil\n\t}\n\n\tinitialLn := func() ([]byte, error) {\n\t\tio.Copy(buf, r)\n\t\tb = buf.Bytes()\n\t\tnextLine = restLn\n\t\treturn restLn()\n\t}\n\tnextLine = initialLn\n}\n\n// Setup nextToken without input buffer.\nfunc SetUnbefferedInput(r io.Reader) {\n\tbuf := bufio.NewReader(r)\n\tvar b []byte\n\n\tvar i int\n\tnextToken = func() ([]byte, error) {\n\t\tvar err error\n\t\tif i == len(b) {\n\t\t\tb, err = buf.ReadBytes('\\n')\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ti = 0\n\t\t\tj := len(b) - 1\n\t\t\tfor 0 <= j && IsSpace(b[j]) {\n\t\t\t\tj--\n\t\t\t}\n\t\t\tb = b[0 : j+1]\n\t\t}\n\t\tfor i < len(b) && IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tj := i\n\t\tfor i < len(b) && !IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tif i == j {\n\t\t\treturn nil, io.ErrUnexpectedEOF\n\t\t}\n\t\treturn b[j:i], nil\n\t}\n}\n\n// -----------------------------------------------------------------------------\n\n// IO functions\n\n// Reads next token and return it as []byte\nfunc readb() []byte {\n\tb, err := nextToken()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b[:len(b):len(b)]\n}\n\n// Reads next token and return it as string\nfunc reads() string {\n\treturn string(readb())\n}\n\n// Read next line as []byte.  Trailing '\\n' will not be included.\n// See also comments on readb()\nfunc readbln() []byte {\n\tb, err := nextLine()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b[:len(b):len(b)]\n}\n\n// Read next line as string\nfunc readsln() string {\n\treturn string(readbln())\n}\n\n// Reads next token and return it as int64\nfunc readll() int64 {\n\ti, err := strconv.ParseInt(reads(), 10, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// Reads next token and return it as int\nfunc readi() int {\n\treturn int(readll())\n}\n\n// Reads next token and return it as float64\nfunc readf() float64 {\n\tf, err := strconv.ParseFloat(reads(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// Write args to OutputWriter with the format f\nfunc printf(f string, args ...interface{}) (int, error) {\n\treturn fmt.Fprintf(OutputWriter, f, args...)\n}\n\n// Write args to OutputWriter without format\nfunc println(args ...interface{}) (int, error) {\n\treturn fmt.Fprintln(OutputWriter, args...)\n}\n\n// Write args to stderr with the format f\nfunc eprintf(f string, args ...interface{}) (int, error) {\n\treturn fmt.Fprintf(os.Stderr, f, args...)\n}\n\n// Write args to stderr without format\nfunc eprintln(args ...interface{}) (int, error) {\n\treturn fmt.Fprintln(os.Stderr, args...)\n}\n\nfunc dbgf(f string, args ...interface{}) {\n\tif !DEBUG {\n\t\treturn\n\t}\n\tfmt.Fprintf(os.Stderr, f, args...)\n}\n\nfunc dbg(args ...interface{}) {\n\tif !DEBUG {\n\t\treturn\n\t}\n\tfmt.Fprintln(os.Stderr, args...)\n}\n\n// -----------------------------------------------------------------------------\n\n// Utilities\n\nfunc sumSlice(a []int) int {\n\tvar res int\n\tfor _, v := range a {\n\t\tres += v\n\t}\n\treturn res\n}\n\nfunc sumSlicell(a []int64) int64 {\n\tvar res int64\n\tfor _, v := range a {\n\t\tres += v\n\t}\n\treturn res\n}\n\nfunc readInts(N int) (int, []int) {\n\tif N == 0 {\n\t\tN = readi()\n\t}\n\ta := make([]int, N)\n\tfor i := range a {\n\t\ta[i] = readi()\n\t}\n\treturn N, a\n}\n\nfunc readIntsll(N int) (int, []int64) {\n\tif N == 0 {\n\t\tN = readi()\n\t}\n\ta := make([]int64, N)\n\tfor i := range a {\n\t\ta[i] = readll()\n\t}\n\treturn N, a\n}\n\n// -----------------------------------------------------------------------------\n\n// Simple math functions\n\nconst (\n\t// big prime\n\tINF  = 1000000007\n\tINF2 = 1000000009\n\tINF3 = 998244353\n)\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc minll(a, b int64) int64 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc minf(a, b float64) float64 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc maxll(a, b int64) int64 {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc maxf(a, b float64) float64 {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\nfunc absll(a int64) int64 {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\nfunc absf(a float64) float64 {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\n// egcd(a, b) returns d, x, y:\n//   d is gcd(a,b)\n//   x, y are  integers that satisfy ax + by = d\nfunc egcd(a, b int) (int, int, int) {\n\tif b == 0 {\n\t\treturn a, 1, 0\n\t}\n\td, x, y := egcd(b, a%b)\n\treturn d, y, x - a/b*y\n}\n\nfunc egcdll(a, b int64) (int64, int64, int64) {\n\tif b == 0 {\n\t\treturn a, 1, 0\n\t}\n\td, x, y := egcdll(b, a%b)\n\treturn d, y, x - a/b*y\n}\n\nfunc gcd(a, b int) int {\n\td, _, _ := egcd(a, b)\n\treturn d\n}\n\nfunc gcdll(a, b int64) int64 {\n\td, _, _ := egcdll(a, b)\n\treturn d\n}\n\n// set up IO functions\nfunc init() {\n\t// for non-interactive\n\tSetInput(os.Stdin)\n\tSetOutput(os.Stdout)\n\n\t// Enable below when interactive.  Its ok to leave above intact.\n\t// SetInteractive(os.Stdout, os.Stdin)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nfunc configure(scanner *bufio.Scanner) {\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanned := scanner.Scan()\n\tif !scanned {\n\t\tpanic(\"scan failed\")\n\t}\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\textra := 0\n\tif os.Getenv(\"I\") == \"IronMan\" {\n\t\tfp, _ = os.Open(os.Getenv(\"END_GAME\"))\n\t\textra = 100\n\t}\n\tscanner := bufio.NewScanner(fp)\n\tconfigure(scanner)\n\twriter := bufio.NewWriter(wfp)\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tfmt.Fprintln(writer, r)\n\t\t}\n\t\twriter.Flush()\n\t}()\n\tsolve(scanner, writer)\n\tfor i := 0; i < extra; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tq := getNextInt(scanner)\n\tqq := make([]query, q)\n\taa := make([]int, 0)\n\tfor i := 0; i < q; i++ {\n\t\tqq[i].t = getNextInt(scanner)\n\t\tqq[i].arg1 = getNextInt(scanner)\n\t\taa = append(aa, qq[i].arg1)\n\t\tif qq[i].t != 3 {\n\t\t\tcontinue\n\t\t}\n\t\tqq[i].arg2 = getNextInt(scanner)\n\t\taa = append(aa, qq[i].arg2)\n\t}\n\tc := newCompress(aa)\n\tr := map[int]int{}\n\tfor v, i := range c {\n\t\tr[i] = v\n\t}\n\tseg := newSegment(len(c) + 1)\n\tfor i := 0; i < q; i++ {\n\t\tswitch qq[i].t {\n\t\tcase 0:\n\t\t\tseg.update(c.get(qq[i].arg1), 1, seg.add)\n\t\t\tfmt.Fprintln(writer, seg[len(seg)-1][0])\n\t\tcase 1:\n\t\t\tfmt.Fprintln(writer, seg[0][c.get(qq[i].arg1)])\n\t\tcase 2:\n\t\t\tseg.update(c.get(qq[i].arg1), 0, seg.add)\n\t\tcase 3:\n\t\t\tans := make([]int, 0)\n\t\t\tfor j := seg.left(0, c.get(qq[i].arg2), 1); j >= c.get(qq[i].arg1); j = seg.left(0, j-1, 1) {\n\t\t\t\tans = append(ans, r[j])\n\t\t\t}\n\t\t\tfor j := len(ans) - 1; j >= 0; j-- {\n\t\t\t\tfmt.Fprintln(writer, ans[j])\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype query struct {\n\tt          int\n\targ1, arg2 int\n}\ntype segment [][]int\n\nfunc newSegment(n int) segment {\n\tseg := make(segment, 0)\n\tfor n > 1 {\n\t\tseg = append(seg, make([]int, n))\n\t\tn = (n + 1) >> 1\n\t}\n\tseg = append(seg, make([]int, 1))\n\treturn seg\n}\nfunc (seg segment) update(i int, v int, f func(x, y int) int) {\n\tseg[0][i] = v\n\tfor h := 1; h < len(seg); h++ {\n\t\ti >>= 1\n\t\tif i<<1+1 < len(seg[h-1]) {\n\t\t\tseg[h][i] = f(seg[h-1][i<<1], seg[h-1][i<<1+1])\n\t\t} else {\n\t\t\tseg[h][i] = seg[h-1][i<<1]\n\t\t}\n\t}\n}\nfunc (seg segment) query(l, r int, s int, f func(x, y int) int) int {\n\tfor h := 0; h < len(seg) && l < r; h++ {\n\t\tif l&1 == 1 {\n\t\t\ts = f(s, seg[h][l])\n\t\t\tl++\n\t\t}\n\t\tl >>= 1\n\t\tif r&1 == 1 {\n\t\t\ts = f(s, seg[h][r-1])\n\t\t}\n\t\tr >>= 1\n\t}\n\treturn s\n}\nfunc (seg segment) add(x, y int) int {\n\treturn x + y\n}\nfunc (seg segment) min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\nfunc (seg segment) max(x, y int) int {\n\treturn -seg.min(-x, -y)\n}\nfunc (seg segment) left(h, i, k int) int {\n\tif i < 0 {\n\t\treturn -1\n\t}\n\tif seg[h][i] < k {\n\t\tk -= seg[h][i]\n\t\ti--\n\t\tif i&1 == 0 {\n\t\t\treturn seg.left(h, i, k)\n\t\t}\n\t\treturn seg.left(h+1, i>>1, k)\n\t}\n\tif h == 0 {\n\t\treturn i\n\t}\n\tif k <= seg[h][i]-seg[h-1][i<<1] {\n\t\treturn seg.left(h-1, i<<1+1, k)\n\t}\n\treturn seg.left(h-1, i<<1, k-seg[h][i]+seg[h-1][i<<1])\n}\nfunc (seg segment) right(h, i, k int) int {\n\tif h >= len(seg) || i >= len(seg[h]) {\n\t\treturn len(seg[0])\n\t}\n\tif seg[h][i] < k {\n\t\tk -= seg[h][i]\n\t\ti++\n\t\tif i&1 == 1 {\n\t\t\treturn seg.right(h, i, k)\n\t\t}\n\t\treturn seg.right(h+1, i>>1, k)\n\t}\n\tif h == 0 {\n\t\treturn i\n\t}\n\tif k <= seg[h-1][i<<1] {\n\t\treturn seg.right(h-1, i<<1, k)\n\t}\n\treturn seg.right(h-1, i<<1+1, k-seg[h-1][i<<1])\n}\n\ntype compress map[int]int\n\nfunc newCompress(aa []int) compress {\n\tn := len(aa)\n\tbb := make([]int, n)\n\tcopy(bb, aa)\n\tsort.SliceStable(bb, func(i, j int) bool {\n\t\treturn bb[i] < bb[j]\n\t})\n\tc := compress{}\n\tl := 0\n\ti := 0\n\tfor r := 0; r < n; r++ {\n\t\tfor r > l && bb[r] != bb[l] {\n\t\t\tl++\n\t\t}\n\t\tif r == l {\n\t\t\tc[bb[l]] = i\n\t\t\ti++\n\t\t}\n\t}\n\treturn c\n}\nfunc (c compress) get(x int) int {\n\treturn c[x]\n}\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n\n    q = int(input())\n    s = set()\n\n    for _ in range(q):\n        para = [int(a) for a in input().split()]\n\n        if para[0] == 0:\n            s.add(para[1])\n            print(len(s))\n        elif para[0] == 1:\n            if para[1] in s:\n                print(\"1\")\n            else:\n                print(\"0\")\n        elif para[0] == 2:\n            s.discard(para[1])\n        elif para[0] == 3:\n\n            if len(s) > (para[2] - para[1]):\n                for i in range(para[1], para[2] + 1):\n                    if i in s:\n                        print(i)\n            else:\n                s = sorted(s)\n                for e in s:\n                    if para[1] <= e <= para[2]:\n                        print(e)\n                s = set(s)\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left, bisect_right, insort_left\n\nq = int(input())\nS = []\nD = {}\na = []\nc = 0\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        if not a[i][1] in D:\n            insort_left(S,a[i][1])\n            D[a[i][1]] = 1\n            c += 1\n        else:\n            if not D[a[i][1]] == 1:\n                D[a[i][1]] = 1\n                c += 1\n        print(c)\n    elif a[i][0] == 1:\n        if a[i][1] in D:\n            if D[a[i][1]] == 1:\n                print(1)\n            else:\n                print(0)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in D:\n            if D[a[i][1]] == 1:\n                D[a[i][1]] = 0\n                c -= 1\n    else:\n        L = bisect_left(S,a[i][1])\n        R = bisect_right(S,a[i][2])\n        for j in range(L,R):\n            if D[S[j]] == 1:\n                print(S[j])\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if mid == 0:\n        l.insert(mid,c)\n    elif l[mid] < c:\n        mid+=1\n        l.insert(mid,c)\n\nq = int(input())\nS = []\na = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        if not a[i][1] in S:\n            binary(S,a[i][1])\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n    else:\n        for b in range(len(S)):\n            if S[b] >= a[i][1] and S[b] <= a[i][2]:\n                print(S[b])\n\n"
  },
  {
    "language": "Python",
    "code": "\nclass BinarySearchTree:\n    class Node:\n        __slots__ = ('key', 'left', 'right', 'count')\n\n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n            self.count = 0\n\n        def __str__(self):\n            return \"{}, {} ({}, {})\".format(self.key, self.count,\n                                            self.left, self.right)\n\n    def __init__(self):\n        self.root = None\n\n    def put(self, key):\n        def _put(node):\n            if node is None:\n                node = self.Node(key)\n            if node.key > key:\n                node.left = _put(node.left)\n            elif node.key < key:\n                node.right = _put(node.right)\n            node.count = self._size(node.left) + self._size(node.right) + 1\n            return node\n\n        self.root = _put(self.root)\n\n    def __contains__(self, key):\n        def _contains(node):\n            if node is None:\n                return False\n            if node.key > key:\n                return _contains(node.left)\n            elif node.key < key:\n                return _contains(node.right)\n            else:\n                return True\n        return _contains(self.root)\n\n    def delete(self, key):\n        def _delete(node):\n            if node is None:\n                return None\n\n            if node.key > key:\n                node.left = _delete(node.left)\n            elif node.key < key:\n                node.right = _delete(node.right)\n            else:\n                node = _remove(node)\n\n            if node is not None:\n                node.count = self._size(node.right) + self._size(node.left) + 1\n            return node\n\n        def _remove(node):\n            if node.left is None:\n                right, node.right = node.right, None\n                return right\n            elif node.right is None:\n                left, node.left = node.left, None\n                return left\n            else:\n                if self._size(node.right) > self._size(node.left):\n                    x = _find_min(node.right)\n                    x.right = _remove_min(node.right)\n                    x.left = node.left\n                else:\n                    x = _find_max(node.left)\n                    x.left = _remove_max(node.left)\n                    x.right = node.right\n                return x\n\n        def _find_max(node):\n            if node.right is None:\n                return node\n            else:\n                return _find_max(node.right)\n\n        def _find_min(node):\n            if node.left is None:\n                return node\n            else:\n                return _find_min(node.left)\n\n        def _remove_max(node):\n            if node.right is None:\n                return node.left\n            else:\n                node.right = _remove_max(node.right)\n                node.count = self._size(node.right) + self._size(node.left) + 1\n                return node\n\n        def _remove_min(node):\n            if node.left is None:\n                return node.right\n            else:\n                node.left = _remove_min(node.left)\n                node.count = self._size(node.right) + self._size(node.left) + 1\n                return node\n\n        self.root = _delete(self.root)\n\n    @property\n    def size(self):\n        return self._size(self.root)\n\n    def _size(self, node):\n        if node is None:\n            return 0\n        else:\n            return node.count\n\n    def range(self, min_, max_):\n        def _range(node):\n            if node is None:\n                return\n\n            if node.key > max_:\n                yield from _range(node.left)\n            elif node.key < min_:\n                yield from _range(node.right)\n            else:\n                yield from _range(node.left)\n                yield node.key\n                yield from _range(node.right)\n\n        if min_ > max_:\n            return\n        yield from _range(self.root)\n\nclass BstSet:\n    def __init__(self):\n        self.bst = BinarySearchTree()\n\n    def add(self, key):\n        self.bst.put(key)\n\n    def __contains__(self, key):\n        return key in self.bst\n\n    def delete(self, key):\n        self.bst.delete(key)\n\n    def range(self, a, b):\n        for k in self.bst.range(a, b):\n            yield k\n\n    @property\n    def count(self):\n        return self.bst.size\n\n    def __str__(self):\n        return str(self.bst.root)\n\ndef run():\n    q = int(input())\n    s = BstSet()\n\n    for _ in range(q):\n        command, *value = [int(x) for x in input().split()]\n        print('>>', command, value)\n        if command == 0:\n            s.add(value[0])\n            print(s.count)\n        elif command == 1:\n            if value[0] in s:\n                print(1)\n            else:\n                print(0)\n        elif command == 2:\n            s.delete(value[0])\n        elif command == 3:\n            for i in s.range(*value):\n                print(i)\n        else:\n            raise ValueError('invalid command')\n        print(s)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] == c:\n        return\n    elif l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n\nq = int(input())\nS = []\na = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1])\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n    else:\n        for b in range(len(S)):\n            if S[b] >= a[i][1] and S[b] <= a[i][2]:\n                print(S[b])\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\n\nQ = int(input())\n\nS = set()\n\nfor i in range(Q):\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        S.add(query[1])\n        print(len(S))\n    elif query[0] == 1:\n        if query[1] in S:\n            print(1)\n        else:\n            print(0)\n    elif query[0] == 2:\n        try:\n            S.remove(query[1])\n        except KeyError:\n            pass\n    elif query[0] == 3:\n        S_sub = list(S)\n        S_sub.sort()\n        [print(j) for j in S_sub if j >= query[1] and query[2] >= j]\n\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n\nq = int(input())\nS = []\na = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        if not a[i][1] in S:\n            if not S:\n                S.append(a[i][1])\n            else:\n                binary(S,a[i][1])\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n    else:\n        for b in range(len(S)):\n            if S[b] >= a[i][1] and S[b] <= a[i][2]:\n                print(S[b])\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import insort, bisect_right, bisect_left\n\n\nclass IntSet:\n    def __init__(self) -> None:\n        self.total = 0\n        self.ms: dict = dict()\n        self.lr: list = []\n\n    def insert(self, x: int) -> None:\n        if x in self.ms:\n            if self.ms[x] == 0:\n                self.ms[x] = 1\n                self.total += 1\n        else:\n            self.total += 1\n            self.ms[x] = 1\n            insort(self.lr, x)\n        print(self.total)\n\n    def find(self, x: int) -> None:\n        print(self.ms.get(x, 0))\n\n    def delete(self, x: int) -> None:\n        if x in self.ms:\n            self.total -= self.ms[x]\n            self.ms[x] = 0\n\n    def dump(self, l: int, r: int) -> None:\n        lb = bisect_left(self.lr, l)\n        ub = bisect_right(self.lr, r)\n        for i in range(lb, ub):\n            k = self.lr[i]\n            v = self.ms[k]\n            print(f'{k}\\n' * v, end='')\n\n\nif __name__ == \"__main__\":\n    ms = IntSet()\n    num_query = int(input())\n    for _ in range(num_query):\n        op, *v = map(lambda x: int(x), input().split())\n        if 0 == op:\n            ms.insert(v[0])\n        elif 1 == op:\n            ms.find(v[0])\n        elif 2 == op:\n            ms.delete(v[0])\n        else:\n            ms.dump(v[0], v[1])\n\n"
  },
  {
    "language": "Python",
    "code": "\nclass BinarySearchTree:\n    class Node:\n        __slots__ = ('key', 'left', 'right', 'count')\n\n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n            self.count = 0\n\n        def __str__(self):\n            return \"{}, {} ({}, {})\".format(self.key, self.count,\n                                            self.left, self.right)\n\n    def __init__(self):\n        self.root = None\n\n    def put(self, key):\n        def _put(node):\n            if node is None:\n                node = self.Node(key)\n            if node.key > key:\n                node.left = _put(node.left)\n            elif node.key < key:\n                node.right = _put(node.right)\n            node.count = self._size(node.left) + self._size(node.right) + 1\n            return node\n\n        self.root = _put(self.root)\n\n    def __contains__(self, key):\n        def _contains(node):\n            if node is None:\n                return False\n            if node.key > key:\n                return _contains(node.left)\n            elif node.key < key:\n                return _contains(node.right)\n            else:\n                return True\n        return _contains(self.root)\n\n    def delete(self, key):\n        def _delete(node):\n            if node is None:\n                return None\n\n            if node.key > key:\n                node.left = _delete(node.left)\n            elif node.key < key:\n                node.right = _delete(node.right)\n            else:\n                node = _remove(node)\n\n            if node is not None:\n                node.count = self._size(node.right) + self._size(node.left) + 1\n            return node\n\n        def _remove(node):\n            if node.left is None:\n                right, node.right = node.right, None\n                return right\n            elif node.right is None:\n                left, node.left = node.left, None\n                return left\n            else:\n                if self._size(node.right) > self._size(node.left):\n                    x = _find_min(node.right)\n                    x.right = _remove_min(node.right)\n                    x.left = node.left\n                else:\n                    x = _find_max(node.left)\n                    x.left = _remove_max(node.left)\n                    x.right = node.right\n                return x\n\n        def _find_max(node):\n            if node.right is None:\n                return node\n            else:\n                return _find_max(node.right)\n\n        def _find_min(node):\n            if node.left is None:\n                return node\n            else:\n                return _find_min(node.left)\n\n        def _remove_max(node):\n            if node.right is None:\n                return node.left\n            else:\n                node.right = _remove_max(node.right)\n                return node\n\n        def _remove_min(node):\n            if node.left is None:\n                return node.right\n            else:\n                node.left = _remove_min(node.left)\n                return node\n\n        self.root = _delete(self.root)\n\n    @property\n    def size(self):\n        return self._size(self.root)\n\n    def _size(self, node):\n        if node is None:\n            return 0\n        else:\n            return node.count\n\n    def range(self, min_, max_):\n        def _range(node):\n            if node is None:\n                return\n\n            if node.key > max_:\n                yield from _range(node.left)\n            elif node.key < min_:\n                yield from _range(node.right)\n            else:\n                yield from _range(node.left)\n                yield node.key\n                yield from _range(node.right)\n\n        if min_ > max_:\n            return\n        yield from _range(self.root)\n\n\n\nclass BstSet:\n    def __init__(self):\n        self.bst = BinarySearchTree()\n\n    def add(self, key):\n        self.bst.put(key)\n\n    def __contains__(self, key):\n        return key in self.bst\n\n    def delete(self, key):\n        self.bst.delete(key)\n\n    def range(self, a, b): \n        for k in self.bst.range(a, b): \n            yield k\n\n    @property\n    def count(self):\n        return self.bst.size\n\ndef run():\n    q = int(input())\n    s = BstSet()\n\n    for _ in range(q):\n        command, *value = [int(x) for x in input().split()]\n        if command == 0:\n            s.add(value[0])\n            print(s.count)\n        elif command == 1:\n            if value[0] in s:\n                print(1)\n            else:\n                print(0)\n        elif command == 2:\n            s.delete(value[0])\n        elif command == 3:\n            for i in s.range(*value):\n                print(i)\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if l[mid] == c:\n            return\n        elif last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n\nq = int(input())\nS = []\na = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1])\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n    else:\n        for b in range(len(S)):\n            if S[b] >= a[i][1]:\n                start = b\n                break\n        for b in range(start,len(S)):\n            if S[b] <= a[i][2]:\n                print(S[b])\n            else:\n                break\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\n\nQ = int(input())\n\nS = set()\n\nfor i in range(Q):\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        S.add(query[1])\n        print(len(S))\n    elif query[0] == 1:\n        if query[1] in S:\n            print(1)\n        else:\n            print(0)\n    elif query[0] == 2:\n        try:\n            S.remove(query[1])\n        except KeyError:\n            pass\n    elif query[0] == 3:\n        S_sub = list(S)\n        S_sub.sort()\n        [print(j) for j in S_sub if j >= query[1] and query[2] >= j]\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import *\nimport sys\nn = int(input())\nss = []\ncolor = {}\ncnt = 0\nfor _ in range(n):\n    a, b, *c = map(int,sys.stdin.readline().split())\n    if a == 0:\n        if b not in color:\n            insort_left(ss,b)\n            color[b]=1\n            cnt += 1\n        elif color[b] == 0:\n            color[b] = 1\n            cnt += 1\n        print(cnt)\n    elif a == 1:\n        print(color[b] if b in color else 0)\n    elif a == 2:\n        if b in color:\n            cnt -=color[b]\n            color[b] = 0\n    else:\n        L = bisect_left(ss,b)\n        R = bisect(ss,c[0])\n        for i in range(L,R):\n            if color[ss[i]] == 1:\n                print(ss[i])\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\n\nq = int(input())\n\nS = []\n\n\nfor _ in range(q):\n\n    command, *list_num = input().split()\n    x = int(list_num[0])\n\n    index = bisect.bisect_left(S, x)\n\n    if   command == \"0\":\n        # insert(x)\n        x = int(list_num[0])\n        if ((index == len(S)) or\n            (S[index] != x)):\n            S.insert(index, x)\n        print(len(S))\n    elif command == \"1\":\n        # find(x)\n        x = int(list_num[0])\n        if ((index < len(S)) and\n            (S[index] == x)):\n            print(1)\n        else:\n            print(0)\n    elif command == \"2\":\n        # delete(x)\n        x = int(list_num[0])\n        if ((index < len(S)) and\n            (S[index] == x)):\n            del S[index]\n    elif command == \"3\":\n        # dump(L, R)\n        L = x\n        R = int(list_num[1])\n\n        index_left = bisect.bisect_left(S, L)\n        index_right = bisect.bisect_right(S, R)\n        \n        for element in S[index_left:index_right]:\n            print(element)\n    else:\n        raise\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# FileName: \tset_range_search\n# CreatedDate:  2020-07-25 12:57:11 +0900\n# LastModified: 2020-07-25 13:36:16 +0900\n#\n\n\nimport os\nimport sys\n# import numpy as np\n# import pandas as pd\n\n\ndef main():\n    q = int(input())\n    ans = set()\n    for _ in range(q):\n        s = list(map(int, input().split()))\n        if s[0] == 0:\n            ans.add(s[1])\n            print(len(ans))\n        elif s[0] == 1:\n            if s[1] in ans:\n                print(1)\n            else:\n                print(0)\n        elif s[0] == 2:\n            if s[1] in ans:\n                ans.remove(s[1])\n        else:\n            if len(ans) > s[2] - s[1]:\n                for i in range(s[1], s[2]+1):\n                    if i in ans:\n                        print(i)\n            else:\n                ans = sorted(ans)\n                for a in ans:\n                    if s[1] <= a and a <= s[2]:\n                        print(a)\n                ans = set(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "class BinarySearchTree:\n    class Node:\n        __slots__ = ('key', 'left', 'right', 'count')\n \n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n            self.count = 0\n \n        def __str__(self):\n            return \"{}, {} ({}, {})\".format(self.key, self.count,\n                                            self.left, self.right)\n \n    def __init__(self):\n        self.root = None\n \n    def put(self, key):\n        def _put(node):\n            if node is None:\n                node = self.Node(key)\n            if node.key > key:\n                node.left = _put(node.left)\n            elif node.key < key:\n                node.right = _put(node.right)\n            node.count = self._size(node.left) + self._size(node.right) + 1\n            return node\n \n        self.root = _put(self.root)\n \n    def __contains__(self, key):\n        def _contains(node):\n            if node is None:\n                return False\n            if node.key > key:\n                return _contains(node.left)\n            elif node.key < key:\n                return _contains(node.right)\n            else:\n                return True\n        return _contains(self.root)\n \n    def delete(self, key):\n        def _delete(node):\n            if node is None:\n                return None\n \n            if node.key > key:\n                node.left = _delete(node.left)\n            elif node.key < key:\n                node.right = _delete(node.right)\n            else:\n                node = _remove(node)\n \n            if node is not None:\n                node.count = self._size(node.right) + self._size(node.left) + 1\n            return node\n \n        def _remove(node):\n            if node.left is None:\n                right, node.right = node.right, None\n                return right\n            elif node.right is None:\n                left, node.left = node.left, None\n                return left\n            else:\n                if self._size(node.right) > self._size(node.left):\n                    x = _find_min(node.right)\n                    x.right = _remove_min(node.right)\n                    x.left = node.left\n                else:\n                    x = _find_max(node.left)\n                    x.left = _remove_max(node.left)\n                    x.right = node.right\n                return x\n \n        def _find_max(node):\n            if node.right is None:\n                return node\n            else:\n                return _find_max(node.right)\n \n        def _find_min(node):\n            if node.left is None:\n                return node\n            else:\n                return _find_min(node.left)\n \n        def _remove_max(node):\n            if node.right is None:\n                return node.left\n            else:\n                node.right = _remove_max(node.right)\n                node.count = self._size(node.right) + self._size(node.left) + 1\n                return node\n \n        def _remove_min(node):\n            if node.left is None:\n                return node.right\n            else:\n                node.left = _remove_min(node.left)\n                node.count = self._size(node.right) + self._size(node.left) + 1\n                return node\n \n        self.root = _delete(self.root)\n \n    @property\n    def size(self):\n        return self._size(self.root)\n \n    def _size(self, node):\n        if node is None:\n            return 0\n        else:\n            return node.count\n \n    def range(self, min_, max_):\n        def _range(node):\n            if node is None:\n                return\n \n            if node.key > max_:\n                yield from _range(node.left)\n            elif node.key < min_:\n                yield from _range(node.right)\n            else:\n                yield from _range(node.left)\n                yield node.key\n                yield from _range(node.right)\n \n        if min_ > max_:\n            return\n        yield from _range(self.root)\n \nclass BstSet:\n    def __init__(self):\n        self.bst = BinarySearchTree()\n \n    def add(self, key):\n        self.bst.put(key)\n \n    def __contains__(self, key):\n        return key in self.bst\n \n    def delete(self, key):\n        self.bst.delete(key)\n \n    def range(self, a, b):\n        for k in self.bst.range(a, b):\n            yield k\n \n    @property\n    def count(self):\n        return self.bst.size\n \n    def __str__(self):\n        return str(self.bst.root)\n \ndef run():\n    q = int(input())\n    s = BstSet()\n \n    for _ in range(q):\n        command, *value = [int(x) for x in input().split()]\n        if command == 0:\n            s.add(value[0])\n            print(s.count)\n        elif command == 1:\n            if value[0] in s:\n                print(1)\n            else:\n                print(0)\n        elif command == 2:\n            s.delete(value[0])\n        elif command == 3:\n            for i in s.range(*value):\n                print(i)\n        else:\n            raise ValueError('invalid command')\n \n \nif __name__ == '__main__':\n    run()\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c,low,index):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        for i in range(len(index)):\n            if low[i] > c:\n                index[i] += 1\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if l[mid] == c:\n            return\n        elif last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n    for i in range(len(index)):\n        if low[i] > c:\n            index[i] += 1\n\nq = int(input())\nS = []\na = []\nlow = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n    if a[i][0] == 3:\n        low.append(a[i][1])\n\nindex = [0]*len(low)\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1],low,index)\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n            for b in range(len(index)):\n                if low[b] > a[i][1]:\n                    index[b] -= 1\n    else:\n        if index[0] < len(S):\n            for b in range(index[0],len(S)):\n                if S[b] <= a[i][2]:\n                    print(S[b])\n                    if b == len(S):\n                        del low[0]\n                        del index[0]\n                else:\n                    del low[0]\n                    del index[0]\n                    break\n        else:\n            del low[0]\n            del index[0]\n"
  },
  {
    "language": "Python",
    "code": "q = int(input())\ns = []\nrs = [] # for discretization\n\n# download the input\nfor i in range(q):\n    s.append(list(map(int, input().split())))\n    if s[i][0] == 3:\n        rs.append(s[i][1])\n        rs.append(s[i][2])\n    else:\n        rs.append(s[i][1])\n\nrs.append(10**9 + 1)\nrs = sorted(list(set(rs)))\nindex = {rs[i]:i for i in range(len(rs))} # discretization\nused = [False for i in range(len(rs) + 1)] # tag the elements in set\ncnt = 0\nfor i in range(q):\n    op, x = s[i][0], s[i][1]\n    idx = index[x]\n    if op == 0:\n        if not used[idx]:\n            cnt += 1\n        used[idx] = True\n        print(cnt)\n    elif op == 1:\n        print(+used[idx])\n    elif op == 2:\n        if used[idx]:\n            cnt -= 1\n        used[idx] = False\n    else:\n        l = idx\n        r = index[s[i][2]]\n        for j in range(l, r+1):\n            if used[j]:\n                print(rs[j])\n\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c,low,index):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        for i in range(len(index)):\n            if low[i] > c:\n                index[i] += 1\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if l[mid] == c:\n            return\n        elif last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n    for i in range(len(index)):\n        if low[i] > c:\n            index[i] += 1\n\nq = int(input())\nS = []\na = []\nlow = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n    if a[i][0] == 3:\n        low.append(a[i][1])\n\nindex = [0]*len(low)\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1],low,index)\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n            for b in range(len(index)):\n                if low[b] > a[i][1]:\n                    index[b] -= 1\n    else:\n        if index[0] < len(S)1:\n            for b in range(index[0],len(S)):\n                if S[b] <= a[i][2]:\n                    print(S[b])\n                else:\n                    del low[0]\n                    del index[0]\n                    break\n        else:\n            del low[0]\n            del index[0]\n"
  },
  {
    "language": "Python",
    "code": "numset = set([])\n\nq = int(input())\nfor i in range(q):\n    q, *val = list(map(int, input().split(' ')))\n    if q == 0:\n        numset.add(val[0])\n        print(len(numset))\n    elif q == 1:\n        rst = 1 if val[0] in numset else 0\n        print(rst)\n    elif q == 2:\n        if val[0] in numset: numset.remove(val[0])\n    elif q == 3:\n        L, R = val\n        ans = []\n        for n in numset:\n            if L <= n and n <= R:\n                ans.append(n)\n        ans = sorted(ans)\n        for num in ans:\n            print(num)\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c,low,index):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        for i in range(len(index)):\n            if low[i] > c:\n                index[i] += 1\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if l[mid] == c:\n            return\n        elif last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n    for i in range(len(index)):\n        if low[i] > c:\n            index[i] += 1\n\nq = int(input())\nS = []\na = []\nlow = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n    if a[i][0] == 3:\n        low.append(a[i][1])\n\nindex = [0]*len(low)\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1],low,index)\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n            for b in range(len(index)):\n                if low[b] > a[i][1]:\n                    index[b] -= 1\n    else:\n        if index[0] < len(S):\n            for b in range(index[0],len(S)):\n                if S[b] <= a[i][2]:\n                    print(S[b])\n                else:\n                    del low[0]\n                    del index[0]\n                    break\n        else:\n            del low[0]\n            del index[0]\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if mid == 0:\n        l.insert(mid,c)\n    elif l[mid] < c:\n        mid+=1\n        l.insert(mid,c)\n\nq = int(input())\nS = []\na = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1])\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n    else:\n        for b in range(len(S)):\n            if S[b] >= a[i][1] and S[b] <= a[i][2]:\n                print(S[b])\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c,low,index):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        for i in range(len(index)):\n            if low[i] > c:\n                index[i] += 1\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if l[mid] == c:\n            return\n        elif last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n    for i in range(len(index)):\n        if low[i] > c:\n            index[i] += 1\n\nq = int(input())\nS = []\na = []\nlow = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n    if a[i][0] == 3:\n        low.append(a[i][1])\n\nindex = [0]*len(low)\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1],low,index)\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n            for b in range(len(index)):\n                if low[b] > a[i][1]:\n                    index[b] -= 1\n    else:\n        for b in range(index[0],len(S)):\n            if S[b] <= a[i][2]:\n                print(S[b])\n            else:\n                del low[0]\n                del index[0]\n                break\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n\nq = int(input())\nS = []\na = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        if not a[i][1] in S:\n            if not S:\n                S.append(a[i][1])\n            else:\n                binary(S,a[i][1])\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n    else:\n        for b in range(len(S)):\n            if S[b] >= a[i][1] and S[b] <= a[i][2]:\n                print(S[b])\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nS=[]\n\nq=int(input())\n\ndef find(x):\n    index=bisect.bisect_left(S,x)\n    if index==len(S):\n        return False\n    return S[index]==x\n\n\nfor _ in range(q):\n    query=[int(i) for i in input().split(\" \")]\n    if query[0]==0:\n        if find(query[1]):\n            pass\n        else:\n            bisect.insort_left(S, query[1])\n        print(len(S))\n    elif query[0]==1:\n        if find(query[1]):\n            print(1)\n        else:\n            print(0)\n    elif query[0]==2:\n        if find(query[1]):\n            S.remove(query[1])\n    else:\n        L,R=query[1],query[2]\n        indL=bisect.bisect_left(S,L)\n        indR=bisect.bisect_right(S,R)\n        for s in S[indL:indR]:\n            print(s)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nSet - Set: Range Search\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP2_7_C&lang=jp\n\n\"\"\"\nfrom bisect import insort, bisect_right, bisect_left\n\nclass Multi_set:\n    def __init__(self):\n        self.total = 0\n        self.ms = dict()\n        self.lr = []\n\n    def insert(self, x):\n        if x in self.ms:\n            if self.ms[x] == 0:\n                self.ms[x] = 1\n                self.total += 1\n        else:\n            self.total += 1\n            self.ms[x] = 1\n            insort(self.lr, x)\n        print(self.total)\n\n    def find(self, x):\n        print(self.ms.get(x, 0))\n\n    def delete(self, x):\n        if x in self.ms:\n            self.total -= self.ms[x]\n            self.ms[x] = 0\n\n    def dump(self, l, r):\n        lb = bisect_left(self.lr, l)\n        ub = bisect_right(self.lr, r)\n        for i in range(lb, ub):\n            k = self.lr[i]\n            v = self.ms[k]\n            print(f'{k}\\n' * v, end='')\n\n\nms = Multi_set()\nfor _ in range(int(input())):\n    op, x, y = (input() + ' 1').split()[:3]\n    if op == '0':\n        ms.insert(int(x))\n    elif op == '1':\n        ms.find(int(x))\n    elif op == '2':\n        ms.delete(int(x))\n    else:\n        ms.dump(int(x), int(y))\n\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left,bisect_right,insort_left\ndict = {}\nkeytbl = []\ncnt = 0\nq = int(input())\nfor i in range(q):\n    a = list(input().split())\n    ki = int(a[1])\n    if a[0] == \"0\":\n        if ki not in dict:\n            dict[ki] =1\n            cnt += 1\n            insort_left(keytbl,ki)\n        elif dict[ki] == 0:\n            dict[ki] = 1\n            cnt += 1\n        print(cnt)\n    elif a[0] == \"1\":print(dict[ki] if ki in dict else 0)\n    elif a[0] == \"2\":\n        if ki in dict:\n            cnt -= dict[ki]\n            dict[ki] =0\n    else:\n        L = bisect_left(keytbl,int(a[1]))\n        R = bisect_right(keytbl,int(a[2]),L)\n        for j in range(L,R):\n            if dict[keytbl[j]] == 1:print(keytbl[j])\n\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c,low,index):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        for i in range(len(index)):\n            if low[i] > c:\n                index[i] += 1\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if l[mid] == c:\n            return\n        elif last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n    for i in range(len(index)):\n        if low[i] > c:\n            index[i] += 1\n\nq = int(input())\nS = []\na = []\nlow = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n    if a[i][0] == 3:\n        low.append(a[i][1])\n\nindex = [0]*len(low)\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1],low,index)\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n            for b in range(len(index)):\n                if low[b] > a[i][1]:\n                    index[b] -= 1\n    else:\n        for b in range(index[0],len(S)):\n            if S[b] <= a[i][2]:\n                print(S[b])\n            else:\n                del low[0]\n                del index[0]\n                break\n"
  },
  {
    "language": "Python",
    "code": "\nfrom enum import Enum\nimport math\n\n\nclass Color(Enum):\n    BLACK = 0\n    RED = 1\n\n    @staticmethod\n    def flip(c):\n        return [Color.RED, Color.BLACK][c.value]\n\n\nclass RedBlackBinarySearchTree:\n    \"\"\"Red Black Binary Search Tree with range, min, max.\n    \"\"\"\n\n    class Node:\n        __slots__ = ('key', 'left', 'right', 'count', 'color')\n\n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n            self.count = 0\n            self.color = Color.RED\n\n        def __str__(self):\n            if self.color == Color.RED:\n                key = '*{}'.format(self.key)\n            else:\n                key = '{}'.format(self.key)\n            return \"{}[{}] ({}, {})\".format(key, self.count,\n                                            self.left, self.right)\n\n    def __init__(self):\n        self.root = None\n\n    def put(self, key):\n        def _put(node):\n            if node is None:\n                node = self.Node(key)\n            if node.key > key:\n                node.left = _put(node.left)\n            elif node.key < key:\n                node.right = _put(node.right)\n\n            node = self._restore(node)\n\n            node.count = self._size(node.left) + self._size(node.right) + 1\n            return node\n\n        self.root = _put(self.root)\n        self.root.color = Color.BLACK\n\n    def _is_red(self, node):\n        if node is None:\n            return False\n        else:\n            return node.color == Color.RED\n\n    def _is_black(self, node):\n        if node is None:\n            return False\n        else:\n            return node.color == Color.BLACK\n\n    def _is_2node(self, node):\n        if node is None:\n            return False\n        elif self._is_red(node):\n            return False\n        else:\n            return (self._is_black(node) and\n                    not self._is_red(node.left) and\n                    not self._is_red(node.right))\n\n    def _is_34node(self, node):\n        if node is None:\n            return False\n        elif self._is_red(node):\n            return True\n        else:\n            return (self._is_black(node) and\n                    self._is_red(node.left) and\n                    not self._is_red(node.right))\n\n    def _rotate_left(self, node):\n        assert self._is_red(node.right)\n        x = node.right\n        node.right = x.left\n        x.left = node\n        x.color = node.color\n        node.color = Color.RED\n        node.count = self._size(node.left) + self._size(node.right) + 1\n        return x\n\n    def _rotate_right(self, node):\n        assert self._is_red(node.left)\n        x = node.left\n        node.left = x.right\n        x.right = node\n        x.color = node.color\n        node.color = Color.RED\n        node.count = self._size(node.left) + self._size(node.right) + 1\n        return x\n\n    def _flip_colors(self, node):\n        node.color = Color.flip(node.color)\n        node.left.color = Color.flip(node.left.color)\n        node.right.color = Color.flip(node.right.color)\n        return node\n\n    def __contains__(self, key):\n        def _contains(node):\n            if node is None:\n                return False\n            if node.key > key:\n                return _contains(node.left)\n            elif node.key < key:\n                return _contains(node.right)\n            else:\n                return True\n        return _contains(self.root)\n\n    def delete(self, key):\n        def _delete_from(node):\n            if node is None:\n                return None\n            else:\n                assert not self._is_2node(node)\n\n                if node.key > key:\n                    node = self._convert_left(node)\n                    # print('_convert_left', node)\n                    node.left = _delete_from(node.left)\n                    node = self._restore(node)\n                    # print('_restore', node)\n                elif node.key < key:\n                    node = self._convert_right(node)\n                    # print('_convert_right', node)\n                    node.right = _delete_from(node.right)\n                    node = self._restore(node)\n                    # print('_restore', node)\n                else:\n                    node = _remove(node)\n\n            if node is not None:\n                node.count = self._size(node.right) + self._size(node.left) + 1\n            return node\n\n        def _remove(node):\n            if node.left is None:\n                return None\n            elif node.right is None:\n                if self._is_red(node.left):\n                    node.left.color = Color.BLACK\n                return node.left\n            else:\n                node = self._convert_right(node)\n                if node.key == key:\n                    x = self._find_min(node.right)\n                    node.key = x.key\n                    node.right = self._delete_min(node.right)\n                else:\n                    # print(node)\n                    node.right = _delete_from(node.right)\n                node = self._restore(node)\n                # print('min', x.key, 'node', node.key)\n                return node\n\n        if self.root is None:\n            return\n        # print('initial', self.root)\n        if not self._is_red(self.root.left):\n            self.root.color = Color.RED\n        self.root = _delete_from(self.root)\n        if self.root is not None:\n            self.root.color = Color.BLACK\n        # print('result', self.root)\n        assert self._is_balanced(self.root)\n\n    def delete_max(self):\n        if self.root is None:\n            raise ValueError('remove max on empty tree')\n        if self.root.left is None:\n            self.root = None\n            return\n        if not self._is_red(self.root.left):\n            self.root.color = Color.RED\n        self.root = self._delete_max(self.root)\n        self.root.color = Color.BLACK\n        assert self._is_balanced(self.root)\n\n    def _delete_max(self, node):\n        if node.right is None:\n            if self._is_red(node.left):\n                node.left.color = Color.BLACK\n            return node.left\n        else:\n            assert not self._is_2node(node)\n            node = self._convert_right(node)\n            node.right = self._delete_max(node.right)\n            node = self._restore(node)\n            return node\n\n    def _convert_right(self, node):\n        if self._is_2node(node.right):\n            assert not self._is_2node(node)\n            if self._is_2node(node.left):\n                self._flip_colors(node)\n            elif self._is_red(node.left) and self._is_2node(node.left.right):\n                node = self._rotate_right(node)\n                self._flip_colors(node.right)\n            elif self._is_red(node.left):\n                x = node.left.right\n                node.left.right = x.left\n                node.left, node.right, x.left, x.right = \\\n                    x.right, node.right.left, node.left, node.right\n                x.right.left = node\n                x.color = Color.BLACK\n                node.color = Color.RED\n                if self._is_red(x.left.right):\n                    x.left.right.color = Color.BLACK\n                node.count = (self._size(node.left) +\n                              self._size(node.right) + 1)\n                x.left.count = (self._size(x.left.left) +\n                                self._size(x.left.right) + 1)\n                node = x\n            elif self._is_34node(node.left):\n                x = node.left\n                node.left, node.right, x.right = \\\n                    x.right, node.right.left, node.right\n                x.right.left = node\n                x.color = node.color\n                if self._is_red(x.left):\n                    x.left.color = Color.BLACK\n                if self._is_black(x.right.left):\n                    x.right.left.color = Color.RED\n                node.count = (self._size(node.left) +\n                              self._size(node.right) + 1)\n                x.left.count = (self._size(x.left.left) +\n                                self._size(x.left.right) + 1)\n                node = x\n        return node\n\n    def delete_min(self):\n        if self.root is None:\n            raise ValueError('remove min on empty tree')\n        if self.root.left is None:\n            self.root = None\n            return\n        if not self._is_red(self.root.left):\n            self.root.color = Color.RED\n        self.root = self._delete_min(self.root)\n        self.root.color = Color.BLACK\n        assert self._is_balanced(self.root)\n\n    def _delete_min(self, node):\n        if node.left is None:\n            return None\n        else:\n            assert not self._is_2node(node)\n            node = self._convert_left(node)\n            node.left = self._delete_min(node.left)\n            node = self._restore(node)\n            return node\n\n    def _convert_left(self, node):\n        if self._is_2node(node.left):\n            assert not self._is_2node(node)\n            if self._is_2node(node.right):\n                self._flip_colors(node)\n            elif self._is_34node(node.right):\n                x = node.right.left\n                node.right.left = x.right\n                x.left, x.right, node.right = node, node.right, x.left\n                x.color = node.color\n                node.color = Color.BLACK\n                node.left.color = Color.RED\n                x.right.count = (self._size(x.right.left) +\n                                 self._size(x.right.right) + 1)\n                node = x\n        return node\n\n    def _restore(self, node):\n        if self._is_red(node.right) and not self._is_red(node.left):\n            node = self._rotate_left(node)\n        if self._is_red(node.left) and self._is_red(node.left.left):\n            node = self._rotate_right(node)\n        if self._is_red(node.left) and self._is_red(node.right):\n            node = self._flip_colors(node)\n\n        node.count = self._size(node.left) + self._size(node.right) + 1\n        return node\n\n    def _is_balanced(self, node):\n        def depth(node):\n            if node is None:\n                return 0\n            left = depth(node.left)\n            right = depth(node.right)\n            if left != right:\n                raise Exception('unbalanced')\n            if self._is_black(node):\n                return 1 + left\n            else:\n                return left\n\n        if node is None:\n            return True\n\n        try:\n            left = depth(node.left)\n            right = depth(node.right)\n            return left == right\n        except Exception:\n            return False\n\n    @property\n    def size(self):\n        return self._size(self.root)\n\n    def _size(self, node):\n        if node is None:\n            return 0\n        else:\n            return node.count\n\n    @property\n    def max(self):\n        if self.root is None:\n            raise ValueError('max on empty tree')\n        return self._max(self.root)\n\n    def _max(self, node):\n        x = self._find_max(node)\n        return x.key\n\n    def _find_max(self, node):\n        if node.right is None:\n            return node\n        else:\n            return self._find_max(node.right)\n\n    @property\n    def min(self):\n        if self.root is None:\n            raise ValueError('min on empty tree')\n        return self._min(self.root)\n\n    def _min(self, node):\n        x = self._find_min(node)\n        return x.key\n\n    def _find_min(self, node):\n        if node.left is None:\n            return node\n        else:\n            return self._find_min(node.left)\n\n    def range(self, min_, max_):\n        def _range(node):\n            if node is None:\n                return\n\n            if node.key > max_:\n                yield from _range(node.left)\n            elif node.key < min_:\n                yield from _range(node.right)\n            else:\n                yield from _range(node.left)\n                yield node.key\n                yield from _range(node.right)\n\n        if min_ > max_:\n            return\n        yield from _range(self.root)\n\n\nclass BalancedBstSet:\n    def __init__(self):\n        self.bst = RedBlackBinarySearchTree()\n\n    def add(self, key):\n        self.bst.put(key)\n\n    def __contains__(self, key):\n        return key in self.bst\n\n    def delete(self, key):\n        self.bst.delete(key)\n\n    def range(self, a, b):\n        for k in self.bst.range(a, b):\n            yield k\n\n    @property\n    def count(self):\n        return self.bst.size\n\n    def __str__(self):\n        return str(self.bst.root)\n\n\ndef run():\n    q = int(input())\n    s = BalancedBstSet()\n\n    for _ in range(q):\n        command, *value = [int(x) for x in input().split()]\n        if command == 0:\n            s.add(value[0])\n            print(s.count)\n        elif command == 1:\n            if value[0] in s:\n                print(1)\n            else:\n                print(0)\n        elif command == 2:\n            s.delete(value[0])\n        elif command == 3:\n            for i in s.range(*value):\n                print(i)\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "\nfrom enum import Enum\nimport math\n\n\nclass Color(Enum):\n    BLACK = 0\n    RED = 1\n\n    @staticmethod\n    def flip(c):\n        return [Color.RED, Color.BLACK][c.value]\n\n\nclass RedBlackBinarySearchTree:\n    \"\"\"Red Black Binary Search Tree with range, min, max.\n    \"\"\"\n\n    class Node:\n        __slots__ = ('key', 'left', 'right', 'count', 'color')\n\n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n            self.count = 0\n            self.color = Color.RED\n\n        def __str__(self):\n            if self.color == Color.RED:\n                key = '*{}'.format(self.key)\n            else:\n                key = '{}'.format(self.key)\n            return \"{}[{}] ({}, {})\".format(key, self.count,\n                                            self.left, self.right)\n\n    def __init__(self):\n        self.root = None\n\n    def put(self, key):\n        def _put(node):\n            if node is None:\n                node = self.Node(key)\n            if node.key > key:\n                node.left = _put(node.left)\n            elif node.key < key:\n                node.right = _put(node.right)\n\n            node = self._restore(node)\n\n            node.count = self._size(node.left) + self._size(node.right) + 1\n            return node\n\n        self.root = _put(self.root)\n        self.root.color = Color.BLACK\n\n    def _is_red(self, node):\n        if node is None:\n            return False\n        else:\n            return node.color == Color.RED\n\n    def _is_black(self, node):\n        if node is None:\n            return False\n        else:\n            return node.color == Color.BLACK\n\n    def _is_2node(self, node):\n        if node is None:\n            return False\n        elif self._is_red(node):\n            return False\n        else:\n            return (self._is_black(node) and\n                    not self._is_red(node.left) and\n                    not self._is_red(node.right))\n\n    def _is_34node(self, node):\n        if node is None:\n            return False\n        elif self._is_red(node):\n            return True\n        else:\n            return (self._is_black(node) and\n                    self._is_red(node.left) and\n                    not self._is_red(node.right))\n\n    def _rotate_left(self, node):\n        x = node.right\n        node.right = x.left\n        x.left = node\n        x.color = node.color\n        node.color = Color.RED\n        node.count = self._size(node.left) + self._size(node.right) + 1\n        return x\n\n    def _rotate_right(self, node):\n        x = node.left\n        node.left = x.right\n        x.right = node\n        x.color = node.color\n        node.color = Color.RED\n        node.count = self._size(node.left) + self._size(node.right) + 1\n        return x\n\n    def _flip_colors(self, node):\n        node.color = Color.flip(node.color)\n        node.left.color = Color.flip(node.left.color)\n        node.right.color = Color.flip(node.right.color)\n        return node\n\n    def __contains__(self, key):\n        def _contains(node):\n            if node is None:\n                return False\n            if node.key > key:\n                return _contains(node.left)\n            elif node.key < key:\n                return _contains(node.right)\n            else:\n                return True\n        return _contains(self.root)\n\n    def delete(self, key):\n        def _delete_from(node):\n            if node is None:\n                return None\n            else:\n                assert not self._is_2node(node)\n\n                if node.key > key:\n                    node = self._convert_left(node)\n                    # print('_convert_left', node)\n                    node.left = _delete_from(node.left)\n                    node = self._restore(node)\n                    # print('_restore', node)\n                elif node.key < key:\n                    node = self._convert_right(node)\n                    # print('_convert_right', node)\n                    node.right = _delete_from(node.right)\n                    node = self._restore(node)\n                    # print('_restore', node)\n                else:\n                    node = _remove(node)\n\n            if node is not None:\n                node.count = self._size(node.right) + self._size(node.left) + 1\n            return node\n\n        def _remove(node):\n            if node.left is None:\n                return None\n            elif node.right is None:\n                if self._is_red(node.left):\n                    node.left.color = Color.BLACK\n                return node.left\n            else:\n                node = self._convert_right(node)\n                if node.key == key:\n                    x = self._find_min(node.right)\n                    node.key = x.key\n                    node.right = self._delete_min(node.right)\n                else:\n                    # print(node)\n                    node.right = _delete_from(node.right)\n                node = self._restore(node)\n                # print('min', x.key, 'node', node.key)\n                return node\n\n        if self.root is None:\n            return\n        # print('initial', self.root)\n        if not self._is_red(self.root.left):\n            self.root.color = Color.RED\n        self.root = _delete_from(self.root)\n        if self.root is not None:\n            self.root.color = Color.BLACK\n\n    def delete_max(self):\n        if self.root is None:\n            raise ValueError('remove max on empty tree')\n        if self.root.left is None:\n            self.root = None\n            return\n        if not self._is_red(self.root.left):\n            self.root.color = Color.RED\n        self.root = self._delete_max(self.root)\n        self.root.color = Color.BLACK\n\n    def _delete_max(self, node):\n        if node.right is None:\n            if self._is_red(node.left):\n                node.left.color = Color.BLACK\n            return node.left\n        else:\n            assert not self._is_2node(node)\n            node = self._convert_right(node)\n            node.right = self._delete_max(node.right)\n            node = self._restore(node)\n            return node\n\n    def _convert_right(self, node):\n        if self._is_2node(node.right):\n            if self._is_2node(node.left):\n                self._flip_colors(node)\n            elif self._is_red(node.left) and self._is_2node(node.left.right):\n                node = self._rotate_right(node)\n                self._flip_colors(node.right)\n            elif self._is_red(node.left):\n                x = node.left.right\n                node.left.right = x.left\n                node.left, node.right, x.left, x.right = \\\n                    x.right, node.right.left, node.left, node.right\n                x.right.left = node\n                x.color = Color.BLACK\n                node.color = Color.RED\n                if self._is_red(x.left.right):\n                    x.left.right.color = Color.BLACK\n                node.count = (self._size(node.left) +\n                              self._size(node.right) + 1)\n                x.left.count = (self._size(x.left.left) +\n                                self._size(x.left.right) + 1)\n                node = x\n            elif self._is_34node(node.left):\n                x = node.left\n                node.left, node.right, x.right = \\\n                    x.right, node.right.left, node.right\n                x.right.left = node\n                x.color = node.color\n                if self._is_red(x.left):\n                    x.left.color = Color.BLACK\n                if self._is_black(x.right.left):\n                    x.right.left.color = Color.RED\n                node.count = (self._size(node.left) +\n                              self._size(node.right) + 1)\n                x.left.count = (self._size(x.left.left) +\n                                self._size(x.left.right) + 1)\n                node = x\n        return node\n\n    def delete_min(self):\n        if self.root is None:\n            raise ValueError('remove min on empty tree')\n        if self.root.left is None:\n            self.root = None\n            return\n        if not self._is_red(self.root.left):\n            self.root.color = Color.RED\n        self.root = self._delete_min(self.root)\n        self.root.color = Color.BLACK\n\n    def _delete_min(self, node):\n        if node.left is None:\n            return None\n        else:\n            node = self._convert_left(node)\n            node.left = self._delete_min(node.left)\n            node = self._restore(node)\n            return node\n\n    def _convert_left(self, node):\n        if self._is_2node(node.left):\n            if self._is_2node(node.right):\n                self._flip_colors(node)\n            elif self._is_34node(node.right):\n                x = node.right.left\n                node.right.left = x.right\n                x.left, x.right, node.right = node, node.right, x.left\n                x.color = node.color\n                node.color = Color.BLACK\n                node.left.color = Color.RED\n                x.right.count = (self._size(x.right.left) +\n                                 self._size(x.right.right) + 1)\n                node = x\n        return node\n\n    def _restore(self, node):\n        if self._is_red(node.right) and not self._is_red(node.left):\n            node = self._rotate_left(node)\n        if self._is_red(node.left) and self._is_red(node.left.left):\n            node = self._rotate_right(node)\n        if self._is_red(node.left) and self._is_red(node.right):\n            node = self._flip_colors(node)\n\n        node.count = self._size(node.left) + self._size(node.right) + 1\n        return node\n\n    def _is_balanced(self, node):\n        def depth(node):\n            if node is None:\n                return 0\n            left = depth(node.left)\n            right = depth(node.right)\n            if left != right:\n                raise Exception('unbalanced')\n            if self._is_black(node):\n                return 1 + left\n            else:\n                return left\n\n        if node is None:\n            return True\n\n        try:\n            left = depth(node.left)\n            right = depth(node.right)\n            return left == right\n        except Exception:\n            return False\n\n    @property\n    def size(self):\n        return self._size(self.root)\n\n    def _size(self, node):\n        if node is None:\n            return 0\n        else:\n            return node.count\n\n    @property\n    def max(self):\n        if self.root is None:\n            raise ValueError('max on empty tree')\n        return self._max(self.root)\n\n    def _max(self, node):\n        x = self._find_max(node)\n        return x.key\n\n    def _find_max(self, node):\n        if node.right is None:\n            return node\n        else:\n            return self._find_max(node.right)\n\n    @property\n    def min(self):\n        if self.root is None:\n            raise ValueError('min on empty tree')\n        return self._min(self.root)\n\n    def _min(self, node):\n        x = self._find_min(node)\n        return x.key\n\n    def _find_min(self, node):\n        if node.left is None:\n            return node\n        else:\n            return self._find_min(node.left)\n\n    def range(self, min_, max_):\n        def _range(node):\n            if node is None:\n                return\n\n            if node.key > max_:\n                yield from _range(node.left)\n            elif node.key < min_:\n                yield from _range(node.right)\n            else:\n                yield from _range(node.left)\n                yield node.key\n                yield from _range(node.right)\n\n        if min_ > max_:\n            return\n        yield from _range(self.root)\n\n\nclass BalancedBstSet:\n    def __init__(self):\n        self.bst = RedBlackBinarySearchTree()\n\n    def add(self, key):\n        self.bst.put(key)\n\n    def __contains__(self, key):\n        return key in self.bst\n\n    def delete(self, key):\n        self.bst.delete(key)\n\n    def range(self, a, b):\n        for k in self.bst.range(a, b):\n            yield k\n\n    @property\n    def count(self):\n        return self.bst.size\n\n    def __str__(self):\n        return str(self.bst.root)\n\n\ndef run():\n    q = int(input())\n    s = BalancedBstSet()\n\n    for _ in range(q):\n        command, *value = [int(x) for x in input().split()]\n        if command == 0:\n            s.add(value[0])\n            print(s.count)\n        elif command == 1:\n            if value[0] in s:\n                print(1)\n            else:\n                print(0)\n        elif command == 2:\n            s.delete(value[0])\n        elif command == 3:\n            for i in s.range(*value):\n                print(i)\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "S = set()\n\nfor _ in range(int(input())):\n    order = tuple(map(int,input().split()))\n    value = order[1]\n\n    if order[0] == 0:\n        S.add(value)\n        print(len(S))\n    elif order[0] == 1:\n        if value in S:\n            print(1)\n        else:\n            print(0)\n    elif order[0] == 2:\n        S.discard(value)\n    else:\n        if len(S) > order[2] - order[1]:\n            for i in range(order[1],order[2]+1):\n                if i in S:\n                    print(i)\n        else:\n            tmp = sorted(S)\n            for i in tmp:\n                if order[1] <= i <= order[2]:\n                    print(i)\n"
  },
  {
    "language": "Python",
    "code": "numset = set([])\nq = int(input())\nfor i in range(q):\n    q, *val = list(map(int, input().split(' ')))\n    if q == 0:\n        numset.add(val[0])\n        print(len(numset))\n    elif q == 1:\n        rst = 1 if set(val).issubset(numset) else 0\n        print(rst)\n    elif q == 2:\n        if val[0] in numset: numset.remove(val[0])\n    elif q == 3:\n        nums = [x for x in range(val[0], val[1]+1)]\n        for num in nums:\n            if num in numset: print(num)\n"
  },
  {
    "language": "Python",
    "code": "\nclass BinarySearchTree:\n    class Node:\n        __slots__ = ('key', 'left', 'right', 'count')\n\n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n            self.count = 0\n\n        def __str__(self):\n            return \"{}, {} ({}, {})\".format(self.key, self.count,\n                                            self.left, self.right)\n\n    def __init__(self):\n        self.root = None\n\n    def put(self, key):\n        def _put(node):\n            if node is None:\n                node = self.Node(key)\n            if node.key > key:\n                node.left = _put(node.left)\n            elif node.key < key:\n                node.right = _put(node.right)\n            node.count = self._size(node.left) + self._size(node.right) + 1\n            return node\n\n        self.root = _put(self.root)\n\n    def __contains__(self, key):\n        def _contains(node):\n            if node is None:\n                return False\n            if node.key > key:\n                return _contains(node.left)\n            elif node.key < key:\n                return _contains(node.right)\n            else:\n                return True\n        return _contains(self.root)\n\n    def delete(self, key):\n        def _delete(node):\n            if node is None:\n                return None\n\n            if node.key > key:\n                node.left = _delete(node.left)\n            elif node.key < key:\n                node.right = _delete(node.right)\n            else:\n                node = _remove(node)\n\n            if node is not None:\n                node.count = self._size(node.right) + self._size(node.left) + 1\n            return node\n\n        def _remove(node):\n            if node.left is None:\n                right, node.right = node.right, None\n                return right\n            elif node.right is None:\n                left, node.left = node.left, None\n                return left\n            else:\n                if self._size(node.right) > self._size(node.left):\n                    x = _find_min(node.right)\n                    x.right = _remove_min(node.right)\n                    x.left = node.left\n                else:\n                    x = _find_max(node.left)\n                    x.left = _remove_max(node.left)\n                    x.right = node.right\n                return x\n\n        def _find_max(node):\n            if node.right is None:\n                return node\n            else:\n                return _find_max(node.right)\n\n        def _find_min(node):\n            if node.left is None:\n                return node\n            else:\n                return _find_min(node.left)\n\n        def _remove_max(node):\n            if node.right is None:\n                return node.left\n            else:\n                node.right = _remove_max(node.right)\n                return node\n\n        def _remove_min(node):\n            if node.left is None:\n                return node.right\n            else:\n                node.left = _remove_min(node.left)\n                return node\n\n        self.root = _delete(self.root)\n\n    @property\n    def size(self):\n        return self._size(self.root)\n\n    def _size(self, node):\n        if node is None:\n            return 0\n        else:\n            return node.count\n\n    def range(self, min_, max_):\n        def _range(node):\n            if node is None:\n                return\n\n            if node.key > max_:\n                yield from _range(node.left)\n            elif node.key < min_:\n                yield from _range(node.right)\n            else:\n                yield from _range(node.left)\n                yield node.key\n                yield from _range(node.right)\n\n        if min_ > max_:\n            return\n        yield from _range(self.root)\n\n\n\nclass BstSet:\n    def __init__(self):\n        self.bst = BinarySearchTree()\n\n    def add(self, key):\n        self.bst.put(key)\n\n    def __contains__(self, key):\n        return key in self.bst\n\n    def delete(self, key):\n        self.bst.delete(key)\n\n    def range(self, a, b): \n        for k in self.bst.range(a, b): \n            yield k\n\n    @property\n    def count(self):\n        return self.bst.size\n\n#!/usr/bin/env python3\n# ITP2_7_C: Set Range Search\n\n\nfrom Set import BstSet\n\n\ndef run():\n    q = int(input())\n    s = BstSet()\n\n    for _ in range(q):\n        command, *value = [int(x) for x in input().split()]\n        if command == 0:\n            s.add(value[0])\n            print(s.count)\n        elif command == 1:\n            if value[0] in s:\n                print(1)\n            else:\n                print(0)\n        elif command == 2:\n            s.delete(value[0])\n        elif command == 3:\n            for i in s.range(*value):\n                print(i)\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nSet - Set: Range Search\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP2_7_C&lang=jp\n\n\"\"\"\nfrom bisect import insort, bisect_right, bisect_left\n\nclass Multi_set:\n    def __init__(self):\n        self.total = 0\n        self.ms = dict()\n        self.lr = []\n\n    def insert(self, x):\n        if x in self.ms:\n            if self.ms[x] == 0:\n                self.ms[x] = 1\n                self.total += 1\n        else:\n            self.total += 1\n            self.ms[x] = 1\n            insort(self.lr, x)\n        print(self.total)\n\n    def find(self, x):\n        print(self.ms.get(x, 0))\n\n    def delete(self, x):\n        if x in self.ms:\n            self.total -= self.ms[x]\n            self.ms[x] = 0\n\n    def dump(self, l, r):\n        lb = bisect_left(self.lr, l)\n        ub = bisect_right(self.lr, r)\n        for i in range(lb, ub):\n            k = self.lr[i]\n            v = self.ms[k]\n            print(f'{k}\\n' * v, end='')\n\n\nms = Multi_set()\nfor _ in range(int(input())):\n    op, x, y = (input() + ' 1').split()[:3]\n    if op == '0':\n        ms.insert(int(x))\n    elif op == '1':\n        ms.find(int(x))\n    elif op == '2':\n        ms.delete(int(x))\n    else:\n        ms.dump(int(x), int(y))\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ ITP2_7_C: Set: Range Search\n# Python3 2018.6.24 bal4u\n\nfrom bisect import bisect_left, bisect_right, insort_left\ndict = {}\nkeytbl = []\ncnt = 0\nq = int(input())\nfor i in range(q):\n\ta = list(input().split())\n\tki = int(a[1])\n\tif a[0] == '0':\n\t\tif ki not in dict:\n\t\t\tdict[ki] = 1\n\t\t\tcnt += 1\n\t\t\tinsort_left(keytbl, ki)\n\t\tprint(cnt)\n\telif a[0] == '1': print(dict[ki] if ki in dict else 0)\n\telif a[0] == '2':\n\t\tif ki in dict:\n\t\t\tcnt -= dict[ki]\n\t\t\tdict[ki] = 0\n\telse:\n\t\tL = bisect_left (keytbl, int(a[1]))\n\t\tR = bisect_right(keytbl, int(a[2]), L)\n\t\tfor j in range(L, R):\n\t\t\tif dict[keytbl[j]] == 1: print(keytbl[j])\n"
  },
  {
    "language": "Python",
    "code": "q = int(input())\nS = set()\n\nfor i in range(q):\n    query = input()\n\n    # insert\n    if query[0] == \"0\":\n        _, x = list(map(int, query.split()))\n        S.add(x)\n        print(len(S))\n\n    # find\n    elif query[0] == \"1\":\n        _, x = list(map(int, query.split()))\n        if x in S:\n            print(1)\n        else:\n            print(0)\n\n    # delete\n    elif query[0] == \"2\":\n        _, x = list(map(int, query.split()))\n        S.discard(x)\n\n    # dump\n    else:\n        _, L, R = list(map(int, query.split()))\n        \n        if len(S) > (R - L):\n            for i in range(L, R + 1):\n                if i in S:\n                    print(i)\n        else:\n            answer = []\n            for SItem in S:\n                if L <= SItem <= R:\n                    answer.append(SItem)\n\n            [print(answerItem) for answerItem in sorted(answer)]\n\n\n"
  },
  {
    "language": "Python",
    "code": "# Solved by QBnewb\n# Discretization\n# off-line\n\nq = int(input())\ns = []\nrs = [] # for discretization\n\n# download the input\nfor i in range(q):\n    s.append(list(map(int, input().split())))\n    if s[i][0] == 3:\n        rs.append(s[i][1])\n        rs.append(s[i][2])\n    else:\n        rs.append(s[i][1])\n\nrs.append(10**9 + 1)\nrs = sorted(list(set(rs)))\nindex = {rs[i]:i for i in range(len(rs))} # discretization\nused = [False for i in range(len(rs) + 1)] # tag the elements in set\ncnt = 0\nfor i in range(q):\n    op, x = s[i][0], s[i][1]\n    idx = index[x]\n    if op == 0:\n        if not used[idx]:\n            cnt += 1\n        used[idx] = True\n        print(cnt)\n    elif op == 1:\n        print(+used[idx])\n    elif op == 2:\n        if used[idx]:\n            cnt -= 1\n        used[idx] = False\n    else:\n        l = idx\n        r = index[s[i][2]]\n        for j in range(l, r+1):\n            if used[j]:\n                print(rs[j])\n"
  },
  {
    "language": "Python",
    "code": "\nfrom enum import Enum\nimport math\n\n\nclass Color(Enum):\n    BLACK = 0\n    RED = 1\n\n    @staticmethod\n    def flip(c):\n        return [Color.RED, Color.BLACK][c.value]\n\n\nclass RedBlackBinarySearchTree:\n    \"\"\"Red Black Binary Search Tree with range, min, max.\n    \"\"\"\n\n    class Node:\n        __slots__ = ('key', 'left', 'right', 'count', 'color')\n\n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n            self.count = 0\n            self.color = Color.RED\n\n        def __str__(self):\n            if self.color == Color.RED:\n                key = '*{}'.format(self.key)\n            else:\n                key = '{}'.format(self.key)\n            return \"{}[{}] ({}, {})\".format(key, self.count,\n                                            self.left, self.right)\n\n    def __init__(self):\n        self.root = None\n\n    def put(self, key):\n        def _put(node):\n            if node is None:\n                node = self.Node(key)\n            if node.key > key:\n                node.left = _put(node.left)\n            elif node.key < key:\n                node.right = _put(node.right)\n\n            node = self._restore(node)\n\n            node.count = self._size(node.left) + self._size(node.right) + 1\n            return node\n\n        self.root = _put(self.root)\n        self.root.color = Color.BLACK\n\n    def _is_red(self, node):\n        if node is None:\n            return False\n        else:\n            return node.color == Color.RED\n\n    def _is_black(self, node):\n        if node is None:\n            return False\n        else:\n            return node.color == Color.BLACK\n\n    def _is_2node(self, node):\n        if node is None:\n            return False\n        elif self._is_red(node):\n            return False\n        else:\n            return (self._is_black(node) and\n                    not self._is_red(node.left) and\n                    not self._is_red(node.right))\n\n    def _is_34node(self, node):\n        if node is None:\n            return False\n        elif self._is_red(node):\n            return True\n        else:\n            return (self._is_black(node) and\n                    self._is_red(node.left) and\n                    not self._is_red(node.right))\n\n    def _rotate_left(self, node):\n        assert self._is_red(node.right)\n        x = node.right\n        node.right = x.left\n        x.left = node\n        x.color = node.color\n        node.color = Color.RED\n        node.count = self._size(node.left) + self._size(node.right) + 1\n        return x\n\n    def _rotate_right(self, node):\n        assert self._is_red(node.left)\n        x = node.left\n        node.left = x.right\n        x.right = node\n        x.color = node.color\n        node.color = Color.RED\n        node.count = self._size(node.left) + self._size(node.right) + 1\n        return x\n\n    def _flip_colors(self, node):\n        node.color = Color.flip(node.color)\n        node.left.color = Color.flip(node.left.color)\n        node.right.color = Color.flip(node.right.color)\n        return node\n\n    def __contains__(self, key):\n        def _contains(node):\n            if node is None:\n                return False\n            if node.key > key:\n                return _contains(node.left)\n            elif node.key < key:\n                return _contains(node.right)\n            else:\n                return True\n        return _contains(self.root)\n\n    def delete(self, key):\n        def _delete_from(node):\n            if node is None:\n                return None\n            else:\n                assert not self._is_2node(node)\n\n                if node.key > key:\n                    node = self._convert_left(node)\n                    # print('_convert_left', node)\n                    node.left = _delete_from(node.left)\n                    node = self._restore(node)\n                    # print('_restore', node)\n                elif node.key < key:\n                    node = self._convert_right(node)\n                    # print('_convert_right', node)\n                    node.right = _delete_from(node.right)\n                    node = self._restore(node)\n                    # print('_restore', node)\n                else:\n                    node = _remove(node)\n\n            if node is not None:\n                node.count = self._size(node.right) + self._size(node.left) + 1\n            return node\n\n        def _remove(node):\n            if node.left is None:\n                return None\n            elif node.right is None:\n                if self._is_red(node.left):\n                    node.left.color = Color.BLACK\n                return node.left\n            else:\n                node = self._convert_right(node)\n                if node.key == key:\n                    x = self._find_min(node.right)\n                    node.key = x.key\n                    node.right = self._delete_min(node.right)\n                else:\n                    # print(node)\n                    node.right = _delete_from(node.right)\n                node = self._restore(node)\n                # print('min', x.key, 'node', node.key)\n                return node\n\n        # print('initial', self.root)\n        if not self._is_red(self.root.left):\n            self.root.color = Color.RED\n        self.root = _delete_from(self.root)\n        if self.root is not None:\n            self.root.color = Color.BLACK\n        # print('result', self.root)\n        assert self._is_balanced(self.root)\n\n    def delete_max(self):\n        if self.root is None:\n            raise ValueError('remove max on empty tree')\n        if self.root.left is None:\n            self.root = None\n            return\n        if not self._is_red(self.root.left):\n            self.root.color = Color.RED\n        self.root = self._delete_max(self.root)\n        self.root.color = Color.BLACK\n        assert self._is_balanced(self.root)\n\n    def _delete_max(self, node):\n        if node.right is None:\n            if self._is_red(node.left):\n                node.left.color = Color.BLACK\n            return node.left\n        else:\n            assert not self._is_2node(node)\n            node = self._convert_right(node)\n            node.right = self._delete_max(node.right)\n            node = self._restore(node)\n            return node\n\n    def _convert_right(self, node):\n        if self._is_2node(node.right):\n            assert not self._is_2node(node)\n            if self._is_2node(node.left):\n                self._flip_colors(node)\n            elif self._is_red(node.left) and self._is_2node(node.left.right):\n                node = self._rotate_right(node)\n                self._flip_colors(node.right)\n            elif self._is_red(node.left):\n                x = node.left.right\n                node.left.right = x.left\n                node.left, node.right, x.left, x.right = \\\n                    x.right, node.right.left, node.left, node.right\n                x.right.left = node\n                x.color = Color.BLACK\n                node.color = Color.RED\n                if self._is_red(x.left.right):\n                    x.left.right.color = Color.BLACK\n                node.count = (self._size(node.left) +\n                              self._size(node.right) + 1)\n                x.left.count = (self._size(x.left.left) +\n                                self._size(x.left.right) + 1)\n                node = x\n            elif self._is_34node(node.left):\n                x = node.left\n                node.left, node.right, x.right = \\\n                    x.right, node.right.left, node.right\n                x.right.left = node\n                x.color = node.color\n                if self._is_red(x.left):\n                    x.left.color = Color.BLACK\n                if self._is_black(x.right.left):\n                    x.right.left.color = Color.RED\n                node.count = (self._size(node.left) +\n                              self._size(node.right) + 1)\n                x.left.count = (self._size(x.left.left) +\n                                self._size(x.left.right) + 1)\n                node = x\n        return node\n\n    def delete_min(self):\n        if self.root is None:\n            raise ValueError('remove min on empty tree')\n        if self.root.left is None:\n            self.root = None\n            return\n        if not self._is_red(self.root.left):\n            self.root.color = Color.RED\n        self.root = self._delete_min(self.root)\n        self.root.color = Color.BLACK\n        assert self._is_balanced(self.root)\n\n    def _delete_min(self, node):\n        if node.left is None:\n            return None\n        else:\n            assert not self._is_2node(node)\n            node = self._convert_left(node)\n            node.left = self._delete_min(node.left)\n            node = self._restore(node)\n            return node\n\n    def _convert_left(self, node):\n        if self._is_2node(node.left):\n            assert not self._is_2node(node)\n            if self._is_2node(node.right):\n                self._flip_colors(node)\n            elif self._is_34node(node.right):\n                x = node.right.left\n                node.right.left = x.right\n                x.left, x.right, node.right = node, node.right, x.left\n                x.color = node.color\n                node.color = Color.BLACK\n                node.left.color = Color.RED\n                x.right.count = (self._size(x.right.left) +\n                                 self._size(x.right.right) + 1)\n                node = x\n        return node\n\n    def _restore(self, node):\n        if self._is_red(node.right) and not self._is_red(node.left):\n            node = self._rotate_left(node)\n        if self._is_red(node.left) and self._is_red(node.left.left):\n            node = self._rotate_right(node)\n        if self._is_red(node.left) and self._is_red(node.right):\n            node = self._flip_colors(node)\n\n        node.count = self._size(node.left) + self._size(node.right) + 1\n        return node\n\n    def _is_balanced(self, node):\n        def depth(node):\n            if node is None:\n                return 0\n            left = depth(node.left)\n            right = depth(node.right)\n            if left != right:\n                raise Exception('unbalanced')\n            if self._is_black(node):\n                return 1 + left\n            else:\n                return left\n\n        if node is None:\n            return True\n\n        try:\n            left = depth(node.left)\n            right = depth(node.right)\n            return left == right\n        except Exception:\n            return False\n\n    @property\n    def size(self):\n        return self._size(self.root)\n\n    def _size(self, node):\n        if node is None:\n            return 0\n        else:\n            return node.count\n\n    @property\n    def max(self):\n        if self.root is None:\n            raise ValueError('max on empty tree')\n        return self._max(self.root)\n\n    def _max(self, node):\n        x = self._find_max(node)\n        return x.key\n\n    def _find_max(self, node):\n        if node.right is None:\n            return node\n        else:\n            return self._find_max(node.right)\n\n    @property\n    def min(self):\n        if self.root is None:\n            raise ValueError('min on empty tree')\n        return self._min(self.root)\n\n    def _min(self, node):\n        x = self._find_min(node)\n        return x.key\n\n    def _find_min(self, node):\n        if node.left is None:\n            return node\n        else:\n            return self._find_min(node.left)\n\n    def range(self, min_, max_):\n        def _range(node):\n            if node is None:\n                return\n\n            if node.key > max_:\n                yield from _range(node.left)\n            elif node.key < min_:\n                yield from _range(node.right)\n            else:\n                yield from _range(node.left)\n                yield node.key\n                yield from _range(node.right)\n\n        if min_ > max_:\n            return\n        yield from _range(self.root)\n\n\nclass BalancedBstSet:\n    def __init__(self):\n        self.bst = RedBlackBinarySearchTree()\n\n    def add(self, key):\n        self.bst.put(key)\n\n    def __contains__(self, key):\n        return key in self.bst\n\n    def delete(self, key):\n        self.bst.delete(key)\n\n    def range(self, a, b):\n        for k in self.bst.range(a, b):\n            yield k\n\n    @property\n    def count(self):\n        return self.bst.size\n\n    def __str__(self):\n        return str(self.bst.root)\n\n\ndef run():\n    q = int(input())\n    s = BalancedBstSet()\n\n    for _ in range(q):\n        command, *value = [int(x) for x in input().split()]\n        if command == 0:\n            s.add(value[0])\n            print(s.count)\n        elif command == 1:\n            if value[0] in s:\n                print(1)\n            else:\n                print(0)\n        elif command == 2:\n            s.delete(value[0])\n        elif command == 3:\n            for i in s.range(*value):\n                print(i)\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c,low,index):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        for i in range(len(index)):\n            if low[i] > c:\n                index[i] += 1\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if l[mid] == c:\n            return\n        elif last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n    for i in range(len(index)):\n        if low[i] > c:\n            index[i] += 1\n\nq = int(input())\nS = []\na = []\nlow = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n    if a[i][0] == 3:\n        low.append(a[i][1])\n\nindex = [0]*len(low)\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1],low,index)\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n            for b in range(len(index)):\n                if low[b] > a[i][1]:\n                    index[b] -= 1\n    else:\n        if index[0] < len(S):\n            for b in range(index[0],len(S)):\n                if S[b] <= a[i][2]:\n                    print(S[b])\n                    if b == len(S)-1:\n                        del low[0]\n                        del index[0]\n                else:\n                    del low[0]\n                    del index[0]\n                    break\n        else:\n            del low[0]\n            del index[0]\n"
  },
  {
    "language": "Python",
    "code": "\nq = int(input())\nfor i in range(q):\n    q, *val = list(map(int, input().split(' ')))\n    if q == 0:\n        numset.add(val[0])\n        print(len(numset))\n    elif q == 1:\n        rst = 1 if set(val).issubset(numset) else 0\n        print(rst)\n    elif q == 2:\n        if val[0] in numset: numset.remove(val[0])\n    elif q == 3:\n        nums = [x for x in range(val[0], val[1]+1)]\n        for num in nums:\n            if num in numset: print(num)\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left, bisect_right, insort_left\ndict = {}\nkeytbl = []\ncnt = 0\nq = int(input())\nfor i in range(q):\n\ta = list(input().split())\n\tki = int(a[1])\n\tif a[0] == '0':\n\t\tif ki not in dict:\n\t\t\tdict[ki] = 1\n\t\t\tcnt += 1\n\t\t\tinsort_left(keytbl, ki)\n\t\telif dict[ki] == 0:\n\t\t\tdict[ki] = 1\n\t\t\tcnt += 1\n\t\tprint(cnt)\n\telif a[0] == '1': print(dict[ki] if ki in dict else 0)\n\telif a[0] == '2':\n\t\tif ki in dict:\n\t\t\tcnt -= dict[ki]\n\t\t\tdict[ki] = 0\n\telse:\n\t\tL = bisect_left (keytbl, int(a[1]))\n\t\tR = bisect_right(keytbl, int(a[2]), L)\n\t\tfor j in range(L, R):\n\t\t\tif dict[keytbl[j]] == 1: print(keytbl[j])\n\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if l[mid] == c:\n            return\n        elif last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n\nq = int(input())\nS = []\na = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1])\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n    else:\n        for b in range(len(S)):\n            if S[b] >= a[i][1]:\n                for c in range(b,len(S)):\n                    if S[c] <= a[i][2]:\n                        print(S[c])\n                    else:\n                        break\n                break\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\nnq = int(input())\nlines = sys.stdin.readlines()\nans = [None] * nq\narr = []\nfor i in range(nq):\n    q, *arg = lines[i].split()\n    x = int(arg[0])\n    idx = bisect.bisect_left(arr,x)\n    if q == '0':    # insert x\n        if idx == len(arr) or arr[idx] != x:\n            arr.insert(idx, x)\n        ans[i] = str(len(arr))\n    elif q == '1':   # find x\n        ans[i] = '1' if idx < len(arr) and arr[idx] == x else '0'\n    elif q == '2':           # delete x\n        if idx < len(arr) and arr[idx] == x:\n            del arr[idx]\n    else:                   # dump L R\n        l_idx = bisect.bisect_left(arr, x)\n        r_idx = bisect.bisect_right(arr, int(arg[1]))\n        ans[i] = '\\n'.join(map(str, arr[l_idx:r_idx]))\n    #print(q, *arg, '\\t', arr)\n\n[print(x) for x in ans if x]\n"
  },
  {
    "language": "Python",
    "code": "def binary(l,c):\n    fst = 0\n    last = len(l)\n    mid = int(last/2)\n    if fst == 0 and last ==0:\n        l.insert(0,c)\n        return\n    while fst < last:\n        mid = int((fst+last) / 2)\n        if l[mid] == c:\n            return\n        elif last == mid:\n            break\n        elif fst == mid:\n            break\n        elif l[mid] >= c:\n            last = mid\n        elif l[mid] <= c:\n            fst = mid\n    if l[mid] < c:\n        mid+=1\n    l.insert(mid,c)\n\nq = int(input())\nS = []\na = []\nfor i in range(q):\n    a.append(list(map(int,input().split())))\n\nfor i in range(q):\n    if a[i][0] == 0:\n        binary(S,a[i][1])\n        print(len(S))\n    elif a[i][0] == 1:\n        if a[i][1] in S:\n            print(1)\n        else:\n            print(0)\n    elif a[i][0] == 2:\n        if a[i][1] in S:\n            S.remove(a[i][1])\n    else:\n        for b in range(len(S)):\n            if S[b] >= a[i][1]:\n                start = b\n        for b in range(start,len(S)):\n            if S[b] <= a[i][2]:\n                print(S[b])\n            else:\n                break\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ns = set()\ninput()\n\nfor q in sys.stdin:\n    q = q.split()\n    if q[0] == '0':\n        s.add(int(q[1]))\n        print(len(s))\n    elif q[0] == '1':\n        print(int(int(q[1]) in s))\n    elif q[0] == '2':\n        s.discard(int(q[1]))\n    else:\n        ans = []\n        if len(s) > int(q[2]) - int(q[1]):\n            for i in range(int(q[1]), int(q[2])+1):\n                if i in s:\n                    print(i)\n        else:\n            for i in s:\n                if int(q[1]) <= i <= int(q[2]):\n                    ans.append(i)\n    \n            for i in sorted(ans):\n                print(i)\n"
  },
  {
    "language": "Python",
    "code": "# AOJ ITP2_7_C: Set: Range Search\n# Python3 2018.6.24 bal4u\n\nfrom bisect import bisect_left, bisect_right, insort_left\ndict = {}\nkeytbl = []\ncnt = 0\nq = int(input())\nfor i in range(q):\n\ta = list(input().split())\n\tki = int(a[1])\n\tif a[0] == '0':\n\t\tif ki not in dict:\n\t\t\tdict[ki] = 1\n\t\t\tcnt += 1\n\t\t\tinsort_left(keytbl, ki)\n\t\telif dict[ki] == 0:\n\t\t\tdict[ki] = 1\n\t\t\tcnt += 1\n\t\tprint(cnt)\n\telif a[0] == '1': print(dict[ki] if ki in dict else 0)\n\telif a[0] == '2':\n\t\tif ki in dict:\n\t\t\tcnt -= dict[ki]\n\t\t\tdict[ki] = 0\n\telse:\n\t\tL = bisect_left (keytbl, int(a[1]))\n\t\tR = bisect_right(keytbl, int(a[2]), L)\n\t\tfor j in range(L, R):\n\t\t\tif dict[keytbl[j]] == 1: print(keytbl[j])\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nS=[]\n\ndef insert(S,count,x):\n    y=bisect.bisect_left(S,x)\n    if y>=count or S[y]!=x:\n        S.insert(y,x)\n        count+=1\n    print(count)\n    return S,count\n\ndef find(S,x):\n    y=bisect.bisect_left(S,x)\n    if y<count and S[y]==x:\n        judge=1\n    else:\n        judge=0\n    return judge,y\n\ndef erase(S,count,x):\n    judge,y=find(S,x)\n    if judge==1:\n        S.pop(y)\n        count-=1\n    return S,count\n\ndef dump(S,L,R):\n    s=bisect.bisect_left(S,L)\n    e=bisect.bisect_right(S,R)\n    if e-s>0:\n        print('\\n'.join(map(str,S[s:e])))\n\nq=int(input())\ncount=0\nfor i in range(q):\n    query=list(map(int,input().split()))\n    \n    if query[0]==0:\n        S,count=insert(S,count,query[1])\n    elif query[0]==1:\n        print(find(S,query[1])[0])\n    elif query[0]==2:\n        S,count=erase(S,count,query[1])\n    else:\n        dump(S,query[1],query[2])\n\n"
  }
]