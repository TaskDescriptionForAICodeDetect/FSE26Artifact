[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 1000001\n\ntypedef struct {\n    int size;\n    int elements[MAX_SIZE];\n} Set;\n\nvoid init(Set *s) {\n    s->size = 0;\n}\n\nint find(Set *s, int x) {\n    for (int i = 0; i < s->size; i++) {\n        if (s->elements[i] == x) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid insert(Set *s, int x) {\n    if (!find(s, x)) {\n        s->elements[s->size++] = x;\n        printf(\"%d\\n\", s->size);\n    }\n}\n\nvoid delete(Set *s, int x) {\n    for (int i = 0; i < s->size; i++) {\n        if (s->elements[i] == x) {\n            for (int j = i; j < s->size - 1; j++) {\n                s->elements[j] = s->elements[j + 1];\n            }\n            s->size--;\n            break;\n        }\n    }\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid dump(Set *s, int L, int R) {\n    int temp[MAX_SIZE];\n    int count = 0;\n    \n    for (int i = 0; i < s->size; i++) {\n        if (s->elements[i] >= L && s->elements[i] <= R) {\n            temp[count++] = s->elements[i];\n        }\n    }\n    \n    qsort(temp, count, sizeof(int), compare);\n    \n    for (int i = 0; i < count; i++) {\n        printf(\"%d \", temp[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    Set s;\n    init(&s);\n    \n    char op[10];\n    int x, L, R;\n    \n    while (scanf(\"%s\", op) != EOF) {\n        if (strcmp(op, \"insert\") == 0) {\n            scanf(\"%d\", &x);\n            insert(&s, x);\n        } else if (strcmp(op, \"find\") == 0) {\n            scanf(\"%d\", &x);\n            printf(\"%d\\n\", find(&s, x));\n        } else if (strcmp(op, \"delete\") == 0) {\n            scanf(\"%d\", &x);\n            delete(&s, x);\n        } else if (strcmp(op, \"dump\") == 0) {\n            scanf(\"%d %d\", &L, &R);\n            dump(&s, L, R);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:22:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct Node {\n    int value;\n    struct Node *left;\n    struct Node *right;\n} Node;\n\nNode* createNode(int value) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->value = value;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nNode* insertNode(Node* root, int value, int* count) {\n    if (root == NULL) {\n        (*count)++;\n        return createNode(value);\n    }\n    if (value < root->value) {\n        root->left = insertNode(root->left, value, count);\n    } else if (value > root->value) {\n        root->right = insertNode(root->right, value, count);\n    }\n    return root;\n}\n\nbool findNode(Node* root, int value) {\n    if (root == NULL) {\n        return false;\n    }\n    if (value == root->value) {\n        return true;\n    } else if (value < root->value) {\n        return findNode(root->left, value);\n    } else {\n        return findNode(root->right, value);\n    }\n}\n\nNode* minValueNode(Node* node) {\n    Node* current = node;\n    while (current && current->left != NULL) {\n        current = current->left;\n    }\n    return current;\n}\n\nNode* deleteNode(Node* root, int value, int* count) {\n    if (root == NULL) {\n        return root;\n    }\n    if (value < root->value) {\n        root->left = deleteNode(root->left, value, count);\n    } else if (value > root->value) {\n        root->right = deleteNode(root->right, value, count);\n    } else {\n        if (root->left == NULL) {\n            Node* temp = root->right;\n            free(root);\n            (*count)--;\n            return temp;\n        } else if (root->right == NULL) {\n            Node* temp = root->left;\n            free(root);\n            (*count)--;\n            return temp;\n        }\n        Node* temp = minValueNode(root->right);\n        root->value = temp->value;\n        root->right = deleteNode(root->right, temp->value, count);\n    }\n    return root;\n}\n\nvoid dumpRange(Node* root, int L, int R) {\n    if (root == NULL) {\n        return;\n    }\n    if (root->value > L) {\n        dumpRange(root->left, L, R);\n    }\n    if (root->value >= L && root->value <= R) {\n        printf(\"%d \", root->value);\n    }\n    if (root->value < R) {\n        dumpRange(root->right, L, R);\n    }\n}\n\nvoid freeTree(Node* root) {\n    if (root == NULL) {\n        return;\n    }\n    freeTree(root->left);\n    freeTree(root->right);\n    free(root);\n}\n\nint main() {\n    Node* root = NULL;\n    int count = 0;\n    char command[10];\n    int x, L, R;\n\n    while (scanf(\"%s\", command) != EOF) {\n        if (command[0] == 'i') {\n            scanf(\"%d\", &x);\n            if (!findNode(root, x)) {\n                root = insertNode(root, x, &count);\n            }\n            printf(\"%d\\n\", count);\n        } else if (command[0] == 'f') {\n            scanf(\"%d\", &x);\n            printf(\"%d\\n\", findNode(root, x) ? 1 : 0);\n        } else if (command[0] == 'd') {\n            if (command[1] == 'e') {\n                scanf(\"%d\", &x);\n                if (findNode(root, x)) {\n                    root = deleteNode(root, x, &count);\n                }\n            } else if (command[1] == 'u') {\n                scanf(\"%d %d\", &L, &R);\n                dumpRange(root, L, R);\n                printf(\"\\n\");\n            }\n        }\n    }\n\n    freeTree(root);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\n\nset<int> S;\n\nvoid insert(int x) {\n    S.insert(x);\n    cout << S.size() << endl;\n}\n\nvoid find(int x) {\n    cout << (S.find(x) != S.end() ? 1 : 0) << endl;\n}\n\nvoid delete_(int x) {\n    S.erase(x);\n}\n\nvoid dump(int L, int R) {\n    auto it_low = S.lower_bound(L);\n    auto it_up = S.upper_bound(R);\n    for (auto it = it_low; it != it_up; ++it) {\n        cout << *it << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    int Q;\n    cin >> Q;\n    while (Q--) {\n        string cmd;\n        cin >> cmd;\n        if (cmd == \"insert\") {\n            int x;\n            cin >> x;\n            insert(x);\n        } else if (cmd == \"find\") {\n            int x;\n            cin >> x;\n            find(x);\n        } else if (cmd == \"delete\") {\n            int x;\n            cin >> x;\n            delete_(x);\n        } else if (cmd == \"dump\") {\n            int L, R;\n            cin >> L >> R;\n            dump(L, R);\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass UniqueSet {\n    private TreeSet<Integer> set;\n\n    public UniqueSet() {\n        set = new TreeSet<>();\n    }\n\n    public int insert(int x) {\n        set.add(x);\n        return set.size();\n    }\n\n    public int find(int x) {\n        return set.contains(x) ? 1 : 0;\n    }\n\n    public void delete(int x) {\n        set.remove(x);\n    }\n\n    public List<Integer> dump(int L, int R) {\n        List<Integer> result = new ArrayList<>();\n        for (int num : set.subSet(L, true, R, true)) {\n            result.add(num);\n        }\n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        UniqueSet set = new UniqueSet();\n        int Q = scanner.nextInt();\n        for (int i = 0; i < Q; i++) {\n            String op = scanner.next();\n            switch (op) {\n                case \"insert\":\n                    int x = scanner.nextInt();\n                    System.out.println(set.insert(x));\n                    break;\n                case \"find\":\n                    x = scanner.nextInt();\n                    System.out.println(set.find(x));\n                    break;\n                case \"delete\":\n                    x = scanner.nextInt();\n                    set.delete(x);\n                    break;\n                case \"dump\":\n                    int L = scanner.nextInt();\n                    int R = scanner.nextInt();\n                    List<Integer> res = set.dump(L, R);\n                    for (int num : res) {\n                        System.out.print(num + \" \");\n                    }\n                    System.out.println();\n                    break;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:23:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass SetOperations {\n    private TreeSet<Integer> set;\n\n    public SetOperations() {\n        set = new TreeSet<>();\n    }\n\n    public int insert(int x) {\n        set.add(x);\n        return set.size();\n    }\n\n    public int find(int x) {\n        return set.contains(x) ? 1 : 0;\n    }\n\n    public void delete(int x) {\n        set.remove(x);\n    }\n\n    public void dump(int L, int R) {\n        for (int num : set.subSet(L, R + 1)) {\n            System.out.println(num);\n        }\n    }\n\n    public static void main(String[] args) {\n        SetOperations so = new SetOperations();\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNext()) {\n            String op = scanner.next();\n            switch (op) {\n                case \"insert\":\n                    int x = scanner.nextInt();\n                    System.out.println(so.insert(x));\n                    break;\n                case \"find\":\n                    x = scanner.nextInt();\n                    System.out.println(so.find(x));\n                    break;\n                case \"delete\":\n                    x = scanner.nextInt();\n                    so.delete(x);\n                    break;\n                case \"dump\":\n                    int L = scanner.nextInt();\n                    int R = scanner.nextInt();\n                    so.dump(L, R);\n                    break;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:23:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nclass SetOperations {\nprivate:\n    set<int> S;\n\npublic:\n    int insert(int x) {\n        S.insert(x);\n        return S.size();\n    }\n\n    int find(int x) {\n        return S.count(x);\n    }\n\n    int remove(int x) {\n        return S.erase(x);\n    }\n\n    void dump(int L, int R) {\n        auto start = S.lower_bound(L);\n        auto end = S.upper_bound(R);\n        \n        for (auto it = start; it != end; ++it) {\n            cout << *it << \" \";\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    SetOperations setOps;\n    string op;\n    int x, L, R;\n\n    while (cin >> op) {\n        if (op == \"insert\") {\n            cin >> x;\n            cout << setOps.insert(x) << endl;\n        } else if (op == \"find\") {\n            cin >> x;\n            cout << setOps.find(x) << endl;\n        } else if (op == \"delete\") {\n            cin >> x;\n            cout << setOps.remove(x) << endl;\n        } else if (op == \"dump\") {\n            cin >> L >> R;\n            setOps.dump(L, R);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UniqueSet:\n    def __init__(self):\n        self.set = set()\n\n    def insert(self, x):\n        self.set.add(x)\n        return len(self.set)\n\n    def find(self, x):\n        return 1 if x in self.set else 0\n\n    def delete(self, x):\n        self.set.discard(x)\n\n    def dump(self, L, R):\n        result = [x for x in self.set if L <= x <= R]\n        result.sort()\n        print(result)\n\n\n# Example usage:\ns = UniqueSet()\nprint(s.insert(5))  # Outputs: 1\nprint(s.insert(3))  # Outputs: 2\nprint(s.find(3))    # Outputs: 1\nprint(s.find(7))    # Outputs: 0\ns.delete(3)\nprint(s.find(3))    # Outputs: 0\ns.dump(2, 6)        # Outputs: [5]",
    "timestamp": "2025-08-13 10:19:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass CustomSet {\n    private TreeSet<Integer> set;\n\n    public CustomSet() {\n        set = new TreeSet<>();\n    }\n\n    public int insert(int x) {\n        set.add(x);\n        return set.size();\n    }\n\n    public int find(int x) {\n        return set.contains(x) ? 1 : 0;\n    }\n\n    public void delete(int x) {\n        set.remove(x);\n    }\n\n    public void dump(int L, int R) {\n        for (int val : set.subSet(L, true, R, true)) {\n            System.out.print(val + \" \");\n        }\n        System.out.println();\n    }\n    \n    public static void main(String[] args) {\n        CustomSet customSet = new CustomSet();\n        \n        // Example Operations:\n        System.out.println(customSet.insert(10)); // Insert 10\n        System.out.println(customSet.insert(20)); // Insert 20\n        System.out.println(customSet.find(10));   // Find 10\n        System.out.println(customSet.find(15));   // Find 15\n        customSet.delete(10);                     // Delete 10\n        customSet.dump(5, 25);                    // Dump elements between 5 and 25\n    }\n}",
    "timestamp": "2025-08-13 10:19:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node *left, *right;\n} Node;\n\nNode* createNode(int data) {\n    Node *newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = data;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nNode* insert(Node* root, int data, int* count) {\n    if (root == NULL) {\n        (*count)++;\n        return createNode(data);\n    }\n    if (data < root->data) {\n        root->left = insert(root->left, data, count);\n    } else if (data > root->data) {\n        root->right = insert(root->right, data, count);\n    }\n    return root;\n}\n\nNode* minValueNode(Node* root) {\n    Node* current = root;\n    while (current && current->left != NULL) {\n        current = current->left;\n    }\n    return current;\n}\n\nNode* delete(Node* root, int data) {\n    if (root == NULL) return root;\n    if (data < root->data) {\n        root->left = delete(root->left, data);\n    } else if (data > root->data) {\n        root->right = delete(root->right, data);\n    } else {\n        if (root->left == NULL) {\n            Node* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n        Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = delete(root->right, temp->data);\n    }\n    return root;\n}\n\nint find(Node* root, int data) {\n    if (root == NULL) return 0;\n    if (data < root->data) return find(root->left, data);\n    else if (data > root->data) return find(root->right, data);\n    return 1;\n}\n\nvoid dump(Node* root, int L, int R) {\n    if (root == NULL) return;\n    if (L < root->data) dump(root->left, L, R);\n    if (L <= root->data && R >= root->data) printf(\"%d \", root->data);\n    if (R > root->data) dump(root->right, L, R);\n}\n\nint main() {\n    Node *root = NULL;\n    int count = 0;\n    \n    // Example operations\n    root = insert(root, 5, &count);\n    printf(\"Count after insert: %d\\n\", count); // Prints 1\n\n    root = insert(root, 3, &count);\n    printf(\"Count after insert: %d\\n\", count); // Prints 2\n\n    root = insert(root, 7, &count);\n    printf(\"Count after insert: %d\\n\", count); // Prints 3\n\n    printf(\"Find 3: %d\\n\", find(root, 3)); // Prints 1\n    printf(\"Find 10: %d\\n\", find(root, 10)); // Prints 0\n\n    root = delete(root, 3);\n    printf(\"Find 3 after delete: %d\\n\", find(root, 3)); // Prints 0\n\n    printf(\"Dump elements from 4 to 8:\\n\");\n    dump(root, 4, 8); // Prints 5 7\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:19:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UniqueSet:\n    def __init__(self):\n        self.elements = set()\n\n    def insert(self, x):\n        self.elements.add(x)\n        return len(self.elements)\n\n    def find(self, x):\n        return 1 if x in self.elements else 0\n\n    def delete(self, x):\n        if x in self.elements:\n            self.elements.remove(x)\n\n    def dump(self, L, R):\n        sorted_range = sorted(num for num in self.elements if L <= num <= R)\n        print(*sorted_range)\n\ndef main():\n    us = UniqueSet()\n    while True:\n        try:\n            op = input().split()\n            if op[0] == 'insert':\n                print(us.insert(int(op[1])))\n            elif op[0] == 'find':\n                print(us.find(int(op[1])))\n            elif op[0] == 'delete':\n                us.delete(int(op[1]))\n            elif op[0] == 'dump':\n                us.dump(int(op[1]), int(op[2]))\n            elif op[0] == 'exit':\n                break\n        except EOFError:\n            break\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 10:19:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import bisect\n\nclass UniqueSet:\n    def __init__(self):\n        self.s = []\n    \n    def insert(self, x):\n        pos = bisect.bisect_left(self.s, x)\n        if pos == len(self.s) or self.s[pos] != x:\n            bisect.insort(self.s, x)\n        return len(self.s)\n    \n    def find(self, x):\n        pos = bisect.bisect_left(self.s, x)\n        return 1 if pos < len(self.s) and self.s[pos] == x else 0\n    \n    def delete(self, x):\n        pos = bisect.bisect_left(self.s, x)\n        if pos < len(self.s) and self.s[pos] == x:\n            self.s.pop(pos)\n    \n    def dump(self, L, R):\n        left = bisect.bisect_left(self.s, L)\n        right = bisect.bisect_right(self.s, R)\n        return self.s[left:right]",
    "timestamp": "2025-08-13 10:19:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nclass UniqueSet {\nprivate:\n    std::set<int> data;\n\npublic:\n    int insert(int x) {\n        data.insert(x);\n        return data.size();\n    }\n\n    int find(int x) {\n        return data.count(x) ? 1 : 0;\n    }\n\n    void deleteElement(int x) {\n        data.erase(x);\n    }\n\n    std::vector<int> dump(int L, int R) {\n        std::vector<int> result;\n        for (int x : data) {\n            if (x >= L && x <= R) {\n                result.push_back(x);\n            }\n        }\n        std::sort(result.begin(), result.end());\n        return result;\n    }\n};\n\nint main() {\n    UniqueSet s;\n    s.insert(5);\n    s.insert(3);\n    s.insert(8);\n    std::cout << \"Find 3: \" << s.find(3) << std::endl;\n    std::cout << \"Find 7: \" << s.find(7) << std::endl;\n    s.deleteElement(3);\n    std::vector<int> dumpResult = s.dump(2, 6);\n    std::cout << \"Dump [2, 6]: \";\n    for (int x : dumpResult) {\n        std::cout << x << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:58:28"
  }
]